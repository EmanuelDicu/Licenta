{
    "name": "1560_F2. Nearest Beautiful Number (hard version)",
    "source": "CODEFORCES",
    "description": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\n\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\n\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\n\nOutput\n\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\n\nExample\n\nInput\n\n\n6\n2021 3\n177890 2\n34512 3\n724533 4\n998244353 1\n12345678 10\n\n\nOutput\n\n\n2021\n181111\n34533\n724542\n999999999\n12345678",
    "difficulty": "F",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy"
    ],
    "rating": 2100,
    "public_test": [
        {
            "input": "6\n2021 3\n177890 2\n34512 3\n724533 4\n998244353 1\n12345678 10\n",
            "output": "2021\n181111\n34533\n724542\n999999999\n12345678\n"
        }
    ],
    "generated_test": [
        {
            "input": "1\n1533832 3\n",
            "output": "1535111\n"
        },
        {
            "input": "1\n6173683 2\n",
            "output": "6222222\n"
        },
        {
            "input": "1\n3330999 6\n",
            "output": "3330999\n"
        },
        {
            "input": "1\n186519 9\n",
            "output": "186519\n"
        },
        {
            "input": "1\n8923138 2\n",
            "output": "8988888\n"
        },
        {
            "input": "1\n1533832 2\n",
            "output": "1551111\n"
        },
        {
            "input": "1\n5144699 2\n",
            "output": "5151111\n"
        },
        {
            "input": "1\n3330999 2\n",
            "output": "3331111\n"
        },
        {
            "input": "1\n1533832 5\n",
            "output": "1533832\n"
        },
        {
            "input": "1\n723048 2\n",
            "output": "727222\n"
        },
        {
            "input": "1\n244697 6\n",
            "output": "244697\n"
        },
        {
            "input": "1\n2909865 5\n",
            "output": "2909866\n"
        },
        {
            "input": "1\n723048 3\n",
            "output": "723222\n"
        },
        {
            "input": "1\n3506626 4\n",
            "output": "3506630\n"
        },
        {
            "input": "1\n4876572 5\n",
            "output": "4876574\n"
        },
        {
            "input": "1\n1292643 3\n",
            "output": "1292911\n"
        },
        {
            "input": "1\n3506626 8\n",
            "output": "3506626\n"
        },
        {
            "input": "1\n156146 5\n",
            "output": "156146\n"
        },
        {
            "input": "1\n4876572 1\n",
            "output": "5555555\n"
        },
        {
            "input": "1\n2034399 3\n",
            "output": "2040000\n"
        },
        {
            "input": "1\n3138495 8\n",
            "output": "3138495\n"
        },
        {
            "input": "1\n1807417 1\n",
            "output": "2222222\n"
        },
        {
            "input": "1\n2034399 5\n",
            "output": "2034399\n"
        },
        {
            "input": "1\n2266501 1\n",
            "output": "3333333\n"
        },
        {
            "input": "1\n448683 5\n",
            "output": "448683\n"
        },
        {
            "input": "1\n37388 10\n",
            "output": "37388\n"
        },
        {
            "input": "1\n954385 1\n",
            "output": "999999\n"
        },
        {
            "input": "1\n5728 10\n",
            "output": "5728\n"
        },
        {
            "input": "1\n691217 8\n",
            "output": "691217\n"
        },
        {
            "input": "1\n962994 8\n",
            "output": "962994\n"
        },
        {
            "input": "1\n1332328 2\n",
            "output": "1333111\n"
        },
        {
            "input": "1\n1249981 8\n",
            "output": "1249981\n"
        },
        {
            "input": "1\n1332328 4\n",
            "output": "1332328\n"
        },
        {
            "input": "1\n2066505 8\n",
            "output": "2066505\n"
        },
        {
            "input": "1\n38249 1\n",
            "output": "44444\n"
        },
        {
            "input": "1\n2775919 7\n",
            "output": "2775919\n"
        },
        {
            "input": "1\n38249 2\n",
            "output": "38333\n"
        },
        {
            "input": "1\n4614203 7\n",
            "output": "4614203\n"
        },
        {
            "input": "1\n28066 2\n",
            "output": "28222\n"
        },
        {
            "input": "1\n4614203 5\n",
            "output": "4614204\n"
        },
        {
            "input": "1\n28066 3\n",
            "output": "28080\n"
        },
        {
            "input": "1\n35037 3\n",
            "output": "35050\n"
        },
        {
            "input": "1\n1484416 6\n",
            "output": "1484416\n"
        },
        {
            "input": "1\n1484416 2\n",
            "output": "1511111\n"
        },
        {
            "input": "1\n1091735 2\n",
            "output": "1100000\n"
        },
        {
            "input": "1\n1091735 1\n",
            "output": "1111111\n"
        },
        {
            "input": "1\n616184 1\n",
            "output": "666666\n"
        },
        {
            "input": "1\n11961857 3\n",
            "output": "11961911\n"
        },
        {
            "input": "1\n3330099 3\n",
            "output": "3330099\n"
        },
        {
            "input": "1\n1598379 3\n",
            "output": "1599111\n"
        },
        {
            "input": "1\n114514 3\n",
            "output": "114514\n"
        },
        {
            "input": "1\n2010326 2\n",
            "output": "2020000\n"
        },
        {
            "input": "6\n2021 3\n177890 2\n34512 3\n724533 4\n998244353 1\n12345678 9\n",
            "output": "2021\n181111\n34533\n724542\n999999999\n12345678\n"
        },
        {
            "input": "1\n1533832 4\n",
            "output": "1533833\n"
        },
        {
            "input": "1\n320958 9\n",
            "output": "320958\n"
        },
        {
            "input": "1\n1230839 4\n",
            "output": "1231000\n"
        },
        {
            "input": "1\n1380207 5\n",
            "output": "1380208\n"
        },
        {
            "input": "1\n723048 6\n",
            "output": "723048\n"
        },
        {
            "input": "1\n185903 6\n",
            "output": "185903\n"
        },
        {
            "input": "1\n2909865 9\n",
            "output": "2909865\n"
        },
        {
            "input": "1\n1229193 3\n",
            "output": "1229199\n"
        },
        {
            "input": "1\n298856 5\n",
            "output": "298856\n"
        },
        {
            "input": "1\n4876572 3\n",
            "output": "4877444\n"
        },
        {
            "input": "1\n756920 3\n",
            "output": "757000\n"
        },
        {
            "input": "1\n5583246 8\n",
            "output": "5583246\n"
        },
        {
            "input": "1\n289903 5\n",
            "output": "289903\n"
        },
        {
            "input": "1\n3913993 8\n",
            "output": "3913993\n"
        },
        {
            "input": "1\n1807417 2\n",
            "output": "1811111\n"
        },
        {
            "input": "1\n1996383 5\n",
            "output": "1996383\n"
        },
        {
            "input": "1\n5921172 10\n",
            "output": "5921172\n"
        },
        {
            "input": "1\n2266501 2\n",
            "output": "2266622\n"
        },
        {
            "input": "1\n448683 1\n",
            "output": "555555\n"
        },
        {
            "input": "1\n688 10\n",
            "output": "688\n"
        },
        {
            "input": "1\n123241 1\n",
            "output": "222222\n"
        },
        {
            "input": "1\n998610 8\n",
            "output": "998610\n"
        },
        {
            "input": "1\n1584322 8\n",
            "output": "1584322\n"
        },
        {
            "input": "1\n1332328 3\n",
            "output": "1332331\n"
        },
        {
            "input": "1\n851800 4\n",
            "output": "851800\n"
        },
        {
            "input": "1\n2848238 8\n",
            "output": "2848238\n"
        },
        {
            "input": "1\n5425581 7\n",
            "output": "5425581\n"
        },
        {
            "input": "1\n8315125 7\n",
            "output": "8315125\n"
        },
        {
            "input": "1\n46403 2\n",
            "output": "46444\n"
        },
        {
            "input": "1\n28066 5\n",
            "output": "28066\n"
        },
        {
            "input": "1\n2332172 6\n",
            "output": "2332172\n"
        },
        {
            "input": "1\n35037 2\n",
            "output": "35333\n"
        },
        {
            "input": "1\n616184 2\n",
            "output": "616611\n"
        },
        {
            "input": "1\n495286 3\n",
            "output": "495444\n"
        },
        {
            "input": "1\n155908 3\n",
            "output": "155911\n"
        },
        {
            "input": "1\n444006 2\n",
            "output": "444040\n"
        },
        {
            "input": "6\n2021 3\n177890 2\n34512 3\n724533 5\n998244353 1\n12345678 9\n",
            "output": "2021\n181111\n34533\n724533\n999999999\n12345678\n"
        },
        {
            "input": "1\n320958 1\n",
            "output": "333333\n"
        },
        {
            "input": "1\n2405415 4\n",
            "output": "2405420\n"
        },
        {
            "input": "1\n3738667 1\n",
            "output": "4444444\n"
        },
        {
            "input": "1\n1395332 5\n",
            "output": "1395332\n"
        },
        {
            "input": "1\n152872 6\n",
            "output": "152872\n"
        },
        {
            "input": "1\n1726631 7\n",
            "output": "1726631\n"
        },
        {
            "input": "1\n3041793 3\n",
            "output": "3043000\n"
        },
        {
            "input": "1\n756920 1\n",
            "output": "777777\n"
        },
        {
            "input": "1\n5583246 4\n",
            "output": "5583252\n"
        },
        {
            "input": "1\n490401 5\n",
            "output": "490401\n"
        },
        {
            "input": "1\n640167 6\n",
            "output": "640167\n"
        },
        {
            "input": "1\n1807417 3\n",
            "output": "1808000\n"
        },
        {
            "input": "1\n7181551 10\n",
            "output": "7181551\n"
        },
        {
            "input": "1\n2266501 3\n",
            "output": "2266522\n"
        },
        {
            "input": "1\n58301 1\n",
            "output": "66666\n"
        },
        {
            "input": "1\n938239 2\n",
            "output": "939333\n"
        },
        {
            "input": "1\n891658 9\n",
            "output": "891658\n"
        },
        {
            "input": "1\n701 10\n",
            "output": "701\n"
        },
        {
            "input": "1\n5828 1\n",
            "output": "6666\n"
        },
        {
            "input": "1\n1092187 8\n",
            "output": "1092187\n"
        },
        {
            "input": "1\n1665073 8\n",
            "output": "1665073\n"
        },
        {
            "input": "1\n2118422 2\n",
            "output": "2121111\n"
        },
        {
            "input": "1\n52742 2\n",
            "output": "53333\n"
        },
        {
            "input": "1\n27327 3\n",
            "output": "27327\n"
        },
        {
            "input": "1\n1054132 6\n",
            "output": "1054132\n"
        },
        {
            "input": "1\n2381070 2\n",
            "output": "2422222\n"
        },
        {
            "input": "1\n1114783 2\n",
            "output": "1115111\n"
        },
        {
            "input": "1\n495286 4\n",
            "output": "495292\n"
        },
        {
            "input": "1\n217070 3\n",
            "output": "217111\n"
        },
        {
            "input": "1\n444006 3\n",
            "output": "444006\n"
        },
        {
            "input": "1\n517337 2\n",
            "output": "522222\n"
        },
        {
            "input": "1\n373166 1\n",
            "output": "444444\n"
        },
        {
            "input": "1\n2405415 8\n",
            "output": "2405415\n"
        },
        {
            "input": "1\n2715901 5\n",
            "output": "2715911\n"
        },
        {
            "input": "1\n152872 3\n",
            "output": "153111\n"
        },
        {
            "input": "1\n3041793 4\n",
            "output": "3042000\n"
        },
        {
            "input": "1\n7943399 4\n",
            "output": "7943399\n"
        },
        {
            "input": "1\n1234799 6\n",
            "output": "1234799\n"
        },
        {
            "input": "1\n993475 7\n",
            "output": "993475\n"
        },
        {
            "input": "1\n1807417 5\n",
            "output": "1807417\n"
        },
        {
            "input": "1\n2140873 8\n",
            "output": "2140873\n"
        },
        {
            "input": "1\n7749811 10\n",
            "output": "7749811\n"
        },
        {
            "input": "1\n593455 2\n",
            "output": "595555\n"
        },
        {
            "input": "1\n984589 9\n",
            "output": "984589\n"
        },
        {
            "input": "1\n9772 1\n",
            "output": "9999\n"
        },
        {
            "input": "1\n761673 8\n",
            "output": "761673\n"
        },
        {
            "input": "1\n4955 2\n",
            "output": "4994\n"
        },
        {
            "input": "1\n44210 3\n",
            "output": "44211\n"
        },
        {
            "input": "1\n3819859 2\n",
            "output": "3833333\n"
        },
        {
            "input": "1\n1850849 2\n",
            "output": "1881111\n"
        },
        {
            "input": "1\n298799 3\n",
            "output": "298822\n"
        },
        {
            "input": "6\n2021 3\n122784 2\n34512 3\n724533 7\n998244353 1\n12345678 9\n",
            "output": "2021\n131111\n34533\n724533\n999999999\n12345678\n"
        },
        {
            "input": "1\n386612 2\n",
            "output": "388333\n"
        },
        {
            "input": "1\n3645493 5\n",
            "output": "3645493\n"
        },
        {
            "input": "1\n286658 3\n",
            "output": "286662\n"
        },
        {
            "input": "1\n182481 4\n",
            "output": "182481\n"
        },
        {
            "input": "1\n328398 2\n",
            "output": "330000\n"
        },
        {
            "input": "1\n184029 4\n",
            "output": "184040\n"
        },
        {
            "input": "1\n1474792 6\n",
            "output": "1474792\n"
        },
        {
            "input": "1\n2588478 5\n",
            "output": "2588478\n"
        },
        {
            "input": "1\n615752 2\n",
            "output": "616111\n"
        },
        {
            "input": "1\n932194 9\n",
            "output": "932194\n"
        },
        {
            "input": "1\n12035 1\n",
            "output": "22222\n"
        },
        {
            "input": "1\n213038 8\n",
            "output": "213038\n"
        },
        {
            "input": "1\n2388 2\n",
            "output": "2422\n"
        },
        {
            "input": "1\n16827 3\n",
            "output": "16861\n"
        },
        {
            "input": "1\n180194 9\n",
            "output": "180194\n"
        },
        {
            "input": "1\n3819859 3\n",
            "output": "3822222\n"
        },
        {
            "input": "1\n298799 6\n",
            "output": "298799\n"
        },
        {
            "input": "6\n2021 3\n122784 2\n34512 3\n724533 7\n998244353 1\n12345678 1\n",
            "output": "2021\n131111\n34533\n724533\n999999999\n22222222\n"
        },
        {
            "input": "1\n271179 2\n",
            "output": "272222\n"
        },
        {
            "input": "1\n543446 2\n",
            "output": "544444\n"
        },
        {
            "input": "1\n4100573 5\n",
            "output": "4100574\n"
        },
        {
            "input": "1\n173575 3\n",
            "output": "173711\n"
        },
        {
            "input": "1\n153765 4\n",
            "output": "153771\n"
        },
        {
            "input": "1\n178370 2\n",
            "output": "181111\n"
        },
        {
            "input": "1\n47711 4\n",
            "output": "47711\n"
        },
        {
            "input": "1\n2190713 6\n",
            "output": "2190713\n"
        },
        {
            "input": "1\n347343 10\n",
            "output": "347343\n"
        },
        {
            "input": "1\n555110 5\n",
            "output": "555110\n"
        },
        {
            "input": "1\n1173600 2\n",
            "output": "1177111\n"
        },
        {
            "input": "1\n213038 2\n",
            "output": "220000\n"
        },
        {
            "input": "1\n3562366 2\n",
            "output": "3633333\n"
        },
        {
            "input": "1\n2388 4\n",
            "output": "2388\n"
        },
        {
            "input": "1\n21711 3\n",
            "output": "21711\n"
        },
        {
            "input": "1\n4126977 3\n",
            "output": "4131111\n"
        },
        {
            "input": "1\n1850849 3\n",
            "output": "1851111\n"
        },
        {
            "input": "6\n2021 3\n122784 2\n34512 3\n963120 7\n998244353 1\n12345678 1\n",
            "output": "2021\n131111\n34533\n963120\n999999999\n22222222\n"
        },
        {
            "input": "1\n442801 2\n",
            "output": "443333\n"
        },
        {
            "input": "1\n844189 5\n",
            "output": "844189\n"
        },
        {
            "input": "1\n173575 2\n",
            "output": "177111\n"
        },
        {
            "input": "1\n83267 4\n",
            "output": "83268\n"
        },
        {
            "input": "1\n11976 2\n",
            "output": "11991\n"
        },
        {
            "input": "1\n15407 4\n",
            "output": "15410\n"
        },
        {
            "input": "1\n2190713 3\n",
            "output": "2191111\n"
        },
        {
            "input": "1\n2318 10\n",
            "output": "2318\n"
        },
        {
            "input": "1\n1077232 5\n",
            "output": "1077232\n"
        },
        {
            "input": "1\n1328827 2\n",
            "output": "1331111\n"
        },
        {
            "input": "1\n932194 3\n",
            "output": "932222\n"
        },
        {
            "input": "1\n277406 2\n",
            "output": "277722\n"
        },
        {
            "input": "1\n4410751 2\n",
            "output": "4411111\n"
        },
        {
            "input": "1\n2388 1\n",
            "output": "3333\n"
        },
        {
            "input": "1\n2328 3\n",
            "output": "2328\n"
        },
        {
            "input": "1\n30960 1\n",
            "output": "33333\n"
        },
        {
            "input": "6\n2300 3\n122784 2\n34512 3\n963120 7\n998244353 1\n12345678 1\n",
            "output": "2300\n131111\n34533\n963120\n999999999\n22222222\n"
        },
        {
            "input": "1\n844189 2\n",
            "output": "844444\n"
        },
        {
            "input": "1\n110728 2\n",
            "output": "111000\n"
        },
        {
            "input": "1\n83267 6\n",
            "output": "83267\n"
        },
        {
            "input": "1\n1727 2\n",
            "output": "1771\n"
        },
        {
            "input": "1\n13218 4\n",
            "output": "13218\n"
        }
    ],
    "solution": [
        {
            "language": 3,
            "solution": "l=len\n_,*t=open(0)\nfor p in t:\n x,k=p.split();k=int(k);n=x\n while l(set(x))>k:x=str(int(x)+1).strip('0')\n print(x+(l(n)-l(x))*min(x+'0'*(l(set(x))<k)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-10;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 2e5 + 10;\nconst int maxm = 2e7 + 10;\nint calc(int first) {\n  int cnt = 0;\n  long long res = 0;\n  while (first) {\n    res |= (1 << (first % 10));\n    first /= 10;\n  }\n  while (res) {\n    res -= res & -res;\n    ++cnt;\n  }\n  return cnt;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int __;\n  cin >> __;\n  while (__--) {\n    long long n, k;\n    cin >> n >> k;\n    while (calc(n) > k) {\n      long long f = n, t = 1;\n      while (calc(f / 10) > k) {\n        f /= 10;\n        t *= 10;\n      };\n      ++f;\n      n = f * t;\n    }\n    cout << n << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nn = ''\nk = l = 0\nd = [0] * 9\n\ndef dfs(cur, dset):\n    p = len(cur)\n    if p == l: return cur\n    if cur > n: nd = 0\n    else: nd = int(n[p])\n    for i in range(nd, 10):\n        if i in dset:\n            r = dfs(cur+str(i), dset)\n            if r != -1: return r\n        else:\n            if len(dset) < k:\n                r = dfs(cur+str(i), dset|set([i]))\n                if r != -1: return r\n    return -1\n\n\nfor _ in range(int(sys.stdin.readline())):\n    n, k = sys.stdin.readline().split()\n    k = int(k)\n    l = len(n)\n    sys.stdout.write(dfs('', set())+'\\n')\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport time\ninput = sys.stdin.readline\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = list(map(int, input().split()))\n        digits = len(str(n))\n        first = str(n)[0]\n        if digits == 1:\n            print(n)\n            continue\n        if k==1:\n            if int(first*digits) >= n:\n                print(first*digits)\n            else:\n                print(str(int(first)+1)*digits)\n            continue\n        m = str(n)\n        picked = [first]\n        picked_list = [i==int(first) for i in range(10)]\n        left = k-1\n        res = ''\n        big = 0\n        maxx = int(first)\n        for i in range(digits):\n            if big:\n                if left == 1:\n                    res += (digits-i)*'0'\n                else:\n                    res += (digits - i) * str(min([int(j) for j in picked]))\n                break\n\n            if left == 0:\n                minpicked = str(min([int(j) for j in picked if int(j) >= int(m[i])]))\n                if int(minpicked) > int(m[i]):\n                    res += minpicked\n                    big = 1\n                    continue\n                if int(res + m[i] + str(maxx)*(digits-i-1)) >= n:\n                    res += minpicked\n                    continue\n                else:\n                    res += str(sorted([int(j) for j in picked if int(j) >= int(m[i])])[1])\n                    big = 1\n                    continue\n\n            if picked_list[int(m[i])]:\n                res += m[i]\n                continue\n            if left >= 2:\n                maxx = max(int(m[i]), maxx)\n                picked.append(m[i])\n                picked_list[int(m[i])] = True\n                left -= 1\n                res += m[i]\n                continue\n            if left == 1:\n                if int(res + m[i] + str(max(maxx, int(m[i])))*(digits-i-1)) >= n:\n                    maxx = max(int(m[i]), maxx)\n                    picked.append(m[i])\n                    picked_list[int(m[i])] = True\n                    left = 0\n                    res += m[i]\n                    continue\n                else:\n                    big = 1\n                    if picked_list[int(m[i]) + 1]:\n                        res += str(int(m[i]) + 1)\n                    else:\n                        left -= 1\n                        picked.append(str(int(m[i])+1))\n                        picked_list[int(m[i])+1] = True\n                        maxx = max(int(m[i])+1, maxx)\n                        res += str(int(m[i])+1)\n                    continue\n        print(res)\nmain()\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long cl(long double a) {\n  if (a > (long long)a) {\n    return (long long)a + 1;\n  } else {\n    return (long long)a;\n  }\n}\nlong long flr(long double a) {\n  if (a < 0.0) {\n    return (long long)a - 1;\n  }\n  return (long long)a;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nlong long pw(long long n, long long k) {\n  if (k == 0) return 1;\n  long long t = pw(n, k / 2);\n  long long ans = (t * t) % mod;\n  if (k % 2)\n    return (ans * n) % mod;\n  else\n    return ans;\n}\nlong long ans = 1e18;\nlong long n, k;\nvoid mn(string s) {\n  set<char> st;\n  for (auto ch : s) st.insert(ch);\n  if (s.length() < n || st.size() > k) return;\n  long long num = stoll(s);\n  ans = min(ans, num);\n}\nvoid solve() {\n  string s;\n  cin >> s;\n  cin >> k;\n  set<char> st;\n  n = s.length();\n  ans = 1e18;\n  string cur = \"\";\n  for (long long i = 0; i < n; i++) {\n    if (st.size() > k) break;\n    string nw = cur;\n    if (s[i] == '9') {\n      if (i == 0) {\n        if (k == 1) {\n          for (long long i = 0; i < n + 1; i++) nw += '1';\n        } else {\n          nw += '1';\n          for (long long i = 0; i < n; i++) nw += '0';\n        }\n        mn(nw);\n      }\n      st.insert('9');\n      cur += '9';\n      continue;\n    } else if (i == n - 1) {\n      char ch = s[i];\n      if (st.size() < k || st.find(ch) != st.end()) {\n        cur += ch;\n        mn(cur);\n      } else {\n        auto it = st.upper_bound(s[i]);\n        if (it != st.end()) {\n          cur += *it;\n          mn(cur);\n        }\n      }\n      break;\n    }\n    char ch = s[i] + 1;\n    if (st.size() == k) {\n      auto it = st.lower_bound(ch);\n      if (it != st.end()) {\n        nw += *it;\n        while (nw.length() < s.length()) {\n          nw += *st.begin();\n        }\n        mn(nw);\n      }\n    } else {\n      long long op = 0;\n      ch = s[i] + 1;\n      if (st.find(ch) == st.end()) {\n        op++;\n      }\n      nw += ch;\n      char nxt;\n      if (st.find('0') != st.end() || st.size() + op < k) {\n        nxt = '0';\n      } else {\n        nxt = ch;\n        if (st.size() > 0) nxt = min(nxt, *st.begin());\n      }\n      while (nw.length() < s.length()) {\n        nw += nxt;\n      }\n      mn(nw);\n    }\n    st.insert(s[i]);\n    cur += s[i];\n  }\n  if (cur.length() == s.length()) mn(cur);\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t;\n  t = 1;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool check(int first) {\n  int res = 0;\n  vector<int> cnt(10, 0);\n  while (first) {\n    if (!cnt[first % 10]) res++;\n    cnt[first % 10]++;\n    first /= 10;\n  }\n  return res <= k;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int _;\n  cin >> _;\n  while (_--) {\n    cin >> n >> k;\n    while (!check(n)) {\n      int pre = n, cnt0 = 1;\n      while (!check(pre)) {\n        pre /= 10;\n        cnt0 *= 10;\n      }\n      cnt0 /= 10;\n      n /= cnt0;\n      n++;\n      n *= cnt0;\n    }\n    cout << n << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  while (1) {\n    set<char> s;\n    for (auto c : n) s.insert(c);\n    if (s.size() <= k) return n;\n    s.clear();\n    for (int ptr = 0;; ptr++) {\n      s.insert(n[ptr]);\n      if (s.size() > k) {\n        while (n[ptr] == '9') {\n          ptr--;\n        }\n        n[ptr]++;\n        for (int i = ptr + 1; i < n.size(); i++) {\n          n[i] = '0';\n        }\n        break;\n      }\n    }\n  }\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    cout << solve() << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        F2NearestBeautifulNumberHardVersion solver = new F2NearestBeautifulNumberHardVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F2NearestBeautifulNumberHardVersion {\n        String s;\n        int k;\n        boolean[][][][] memo;\n        StringBuilder sb;\n\n        public void readInput(Scanner sc) {\n            s = sc.next();\n            k = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int tc = sc.nextInt();\n            while (tc-- > 0) {\n                readInput(sc);\n                s = '0' + s;\n                sb = new StringBuilder();\n                memo = new boolean[2][2][s.length()][1 << 10];\n                trace(0, 0, 0);\n                pw.println(sb);\n            }\n        }\n\n        private void trace(int idx, int bool, int msk) {\n            if (idx == s.length())\n                return;\n            int start = bool == 1 ? 0 : s.charAt(idx) - '0';\n            for (int i = start; i <= 9; i++) {\n                if (dp(idx + 1, i > s.charAt(idx) - '0' ? 1 : bool, i == 0 && Integer.bitCount(msk) == 0 ? msk : msk | 1 << i)) {\n                    if (i == 0) {\n                        if (sb.length() > 0)\n                            sb.append(0);\n                    } else\n                        sb.append(i);\n                    trace(idx + 1, i > s.charAt(idx) - '0' ? 1 : bool, i == 0 && Integer.bitCount(msk) == 0 ? msk : msk | 1 << i);\n                    return;\n                }\n            }\n        }\n\n        private boolean dp(int idx, int bool, int msk) {\n            if (Integer.bitCount(msk) > k)\n                return false;\n            if (idx == s.length())\n                return true;\n            if (memo[0][bool][idx][msk])\n                return memo[1][bool][idx][msk];\n            memo[0][bool][idx][msk] = true;\n            int start = bool == 1 ? 0 : s.charAt(idx) - '0';\n            for (int i = start; i <= 9; i++) {\n                if (dp(idx + 1, i > s.charAt(idx) - '0' ? 1 : bool, i == 0 && Integer.bitCount(msk) == 0 ? msk : msk | 1 << i))\n                    return memo[1][bool][idx][msk] = true;\n            }\n            return memo[1][bool][idx][msk] = false;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)5e+3 + 8;\nstring cal(int i, string n, int dist, int k, string nw) {\n  if (dist > k) {\n    return \"\";\n  }\n  if ((nw.substr(0, i)) < (n.substr(0, i))) {\n    return \"\";\n  }\n  if (i >= ((int)(n).size())) {\n    return nw;\n  }\n  for (char c = '0'; c <= '9'; c++) {\n    bool found = false;\n    nw[i] = c;\n    for (int j = 0; j < i; j++) {\n      if (nw[j] == c) {\n        found = true;\n        break;\n      }\n    }\n    string ch = cal(i + 1, n, dist + (found == false), k, nw);\n    if (((int)(ch).size())) return ch;\n  }\n  return \"\";\n}\nvoid MAIN(long long tc) {\n  string n;\n  long long k;\n  cin >> n >> k;\n  string ans = cal(0, n, 0, k, string(((int)(n).size()), '0'));\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << fixed;\n  cout << setprecision(10);\n  int test__cases = 1;\n  cin >> test__cases;\n  for (int i = 1; i <= test__cases; i++) {\n    MAIN(i);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[10];\nint find_greater(int a) {\n  int index = -1;\n  for (int i = a + 1; i < 10; i++) {\n    if (dp[i]) {\n      index = i;\n      break;\n    }\n  }\n  return index;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    memset(dp, 0, sizeof(dp));\n    string ans = \"\";\n    int mnm = 10, mxm = -1;\n    vector<int> v;\n    int temp = n, cnt = 0;\n    while (temp != 0) {\n      v.push_back(temp % 10);\n      temp /= 10;\n      cnt++;\n    }\n    reverse(v.begin(), v.end());\n    int x = 0;\n    for (int i = 0; i < cnt; i++) {\n      if (x == 1) {\n        if (k)\n          mnm = 0;\n        else {\n          mnm = 10;\n          for (int j = 0; j < 10; j++) {\n            if (dp[j]) {\n              mnm = j;\n              break;\n            }\n          }\n        }\n        ans += char(mnm + '0');\n        continue;\n      }\n      if (dp[v[i]] == 0) {\n        if (k == 0) {\n          int j;\n          int temp = find_greater(v[i]);\n          if (temp != -1) {\n            ans += char(temp + '0');\n            x = 1;\n          } else {\n            int j = v[i];\n            while (i >= 0) {\n              i--;\n              temp = find_greater(v[i]);\n              ans.pop_back();\n              dp[v[i]]--;\n              if (dp[v[i]] == 0) k++;\n              if (temp == -1 && k || (k && temp > v[i] + 1)) {\n                k--;\n                dp[v[i] + 1] = 1;\n                ans += char(v[i] + 1 + '0');\n                x = 1;\n                break;\n              } else if (temp != -1) {\n                dp[temp]++;\n                ans += char(temp + '0');\n                x = 1;\n                break;\n              }\n            }\n          }\n        } else {\n          ans += char(v[i] + '0');\n          dp[v[i]] = 1;\n          k--;\n          mnm = min(mnm, v[i]);\n        }\n      } else {\n        ans += char(v[i] + '0');\n        dp[v[i]]++;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import itertools\nfrom sys import maxsize, stdout, stdin,stderr\nmod = int(1e9+7)\nimport sys\ndef I(): return int(stdin.readline())\ndef lint(): return [int(x) for x in stdin.readline().split()]\ndef S(): return list(map(str,input().strip()))\ndef grid(r, c): return [lint() for i in range(r)]\nfrom collections import defaultdict, Counter, deque\nimport math\nimport heapq\nfrom heapq import heappop , heappush\nimport bisect\nfrom itertools import groupby\nfrom itertools import permutations as comb\ndef gcd(a,b): \n    while b:\n        a %= b\n        tmp = a\n        a = b\n        b = tmp\n    \n    return a\n \ndef lcm(a,b): \n    return a  // gcd(a, b) * b\n \ndef check_prime(n):\n    for i in range(2, int(n ** (1 / 2)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef nCr(n, r):\n \n    return (fact(n) // (fact(r)\n                * fact(n - r)))\n \n# Returns factorial of n\ndef fact(n):\n \n    res = 1\n     \n    for i in range(2, n+1):\n        res = res * i\n         \n    return res\ndef primefactors(n):\n    num=0\n    \n    while n % 2 == 0:\n        num+=1\n        n = n / 2\n    \n    for i in range(3,int(math.sqrt(n))+1,2):\n         \n    \n        while n % i== 0:\n            num+=1\n            n = n // i\n               \n    \n    if n > 2:\n        num+=1\n    return num\n'''\ndef iter_ds(src):\n    store=[src]\n    while len(store):\n        tmp=store.pop()\n        if not vis[tmp]:\n            vis[tmp]=True\n            for j in ar[tmp]:\n                store.append(j)\n'''\ndef ask(a):\n    print('? {}'.format(a),flush=True)\n    n=I()\n    \n    return n\ndef linear_sieve(n):\n    is_composite=[False]*n\n    prime=[]\n    for i in range(2,n):\n        if not is_composite[i]:\n            prime.append(i)\n        for j in prime:\n            is_composite[i*j]=True\n            if i%prime==0:\n                break\n    return prime\n \ndef dfs(i,p,d):\n    \n    a,tmp=0,0\n    for j in d[i]:\n        if j!=p:\n            a+=1\n            tmp+=dfs(j,i)\n    \n    if a==0:\n        return 0\n    \n    return tmp/a + 1 \ndef primeFactors(n):\n    l=[]\n    \n    while n % 2 == 0:\n        l.append(2)\n        n = n // 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n         \n        \n        while n % i== 0:\n            l.append(i)\n            n = n // i\n\n    if n > 2:\n        l.append(n)\n    return l\nfrom math import inf\n'''\nt = I()\n# t=1'\n\n\nfor _ in range(t):\n    n,k=lint()\n    if k==1:\n        \n        tmp=str(n)\n        a=len(tmp)\n        if len(set(tmp))==1:\n            print(tmp)\n        else:\n            if int(tmp[0]*a)<n:\n                if tmp[0]=='9':\n                    print('1'*(a+1))\n                else:\n                    print(str(int(tmp[0])+1)*a)\n            else:\n                print(int(tmp[0]*a))\n        \n    else:\n        ans=mod\n        tmp=str(n)\n        a=len(tmp)\n        if len(set(tmp))<=2:\n            \n            print(int(tmp))\n        else:\n            if int(tmp[0]*a)<=n:\n                if tmp[0]=='9':\n                    ans='1'*(a+1)\n                else:\n                    ans=str(int(tmp[0])+1)*a\n            else:\n                ans=int(tmp[0]*a)\n            if a>=3:\n\n                b=int(tmp[1])\n                while True:\n                    if int(tmp[0]+str(b)*(a-1))<n:\n                        b+=1\n\n\n                    else:\n                        q=0\n                        while q<=a-2 and int(tmp[0]+str(b)+ tmp[0]*(a-2-q)+ str(b)*q)<n:\n                            q+=1\n                        \n                        ans2=int(tmp[0]+str(b)*q+ tmp[0]*(a-1-q))\n                        break\n            else:\n                ans=n\n            if int(ans)<int(ans2):\n                print(ans)\n            else:\n                print(ans2)\n    \n'''\nt=I()\n\nl=[]\nfor i in range(10):\n    for j in range(10):\n        \n        for k in range(1,11):  \n            for z in itertools.product([str(i),str(j)],repeat=k):\n                l.append(int(''.join(list(z))))   \n        \n                \n# l=list(set(l))\nl.sort()\n\nfor _ in range(t):\n    n,k=input().split()\n    k=int(k)\n    n=list(map(str,n.strip()))\n                       \n    \n\n    while True:\n        \n        if len(set(n)) <= k:\n            print(''.join(n))\n            break\n\n        s=set()\n        i=0\n        while True:\n            s.add(n[i])\n            if len(s)>k:\n                while n[i]=='9':\n                    i-=1\n                n[i]=str(int(n[i])+1)\n\n                for j in range(i+1,len(n)):\n                    n[j]='0'\n                break\n            i+=1\n\n\n    \n"
        },
        {
            "language": 3,
            "solution": "_,*t=open(0)\nfor s in t:\n x,k=s.split();k=int(k);n=x\n while len(set(x))>k:x=str(int(x)+1).strip('0')\n print(x+(len(n)-len(x))*min(x+'0'*(len(set(x))<k)))"
        },
        {
            "language": 4,
            "solution": "import java.beans.VetoableChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\nimport javafx.util.Pair;\n\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.copyOfRange;\nimport static java.util.Arrays.fill;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass Task {\n\n    long ans = Long.MAX_VALUE;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int T = in.nextInt();\n        for (int tc = 1; tc <= T; tc++) {\n            ans = Long.MAX_VALUE;\n            String s = in.next();\n            int k = in.nextInt();\n            cal(s, k, 0, 0, 0, false);\n            out.println(ans);\n        }\n    }\n\n    private void cal(String s, int K, int st, long n, int c, boolean isGreater) {\n        if (Integer.bitCount(st) > K) {\n            return;\n        }\n        if (c == s.length()) {\n            ans = Math.min(ans, n);\n            return;\n        }\n        if (isGreater) {\n            long nn = n;\n            int mn = 0;\n            if (Integer.bitCount(st) == K) {\n                mn = Integer.numberOfTrailingZeros(st);\n            }\n            for (int i = c; i < s.length(); i++) {\n                nn = nn * 10 + mn;\n            }\n            ans = Math.min(ans, nn);\n            return;\n        }\n        int nn = s.charAt(c) - '0';\n        for (int i = nn; i <= 9; i++) {\n            cal(s, K, st | (1 << i), n * 10 + i, c + 1, i > nn ? true : isGreater);\n        }\n    }\n}\n\nclass InputReader {\n\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500005;\nconst long long Mod = 998244353;\nint dp[1030][12];\nint a[20];\nint n;\nint pw[maxn];\nint k;\nlong long dfs(int pos, long long pre, int st, int now, int fl) {\n  if (pos > n) return pre;\n  if (fl == 1) {\n    if (now < k) {\n      if (st & 1) return dfs(pos + 1, 10ll * pre, st, now, fl);\n      return dfs(pos + 1, 10ll * pre, st | 1, now + 1, fl);\n    }\n    for (int i = 0; i <= 9; i++) {\n      if (st & pw[i]) return dfs(pos + 1, 10ll * pre + i, st, now, fl);\n    }\n    return 1e18;\n  }\n  long long mn = 1e18;\n  if (st & pw[a[pos]])\n    mn = min(mn, dfs(pos + 1, 10ll * pre + a[pos], st, now, fl));\n  else {\n    if (now < k) {\n      mn = min(mn,\n               dfs(pos + 1, 10ll * pre + a[pos], st | pw[a[pos]], now + 1, fl));\n    }\n  }\n  for (int i = a[pos] + 1; i <= 9; i++) {\n    if (st & pw[i]) {\n      mn = min(mn, dfs(pos + 1, 10ll * pre + i, st, now, 1));\n      break;\n    } else {\n      if (now < k) {\n        mn = min(mn, dfs(pos + 1, 10ll * pre + i, st | pw[i], now + 1, 1));\n      }\n    }\n  }\n  return mn;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  ;\n  pw[0] = 1;\n  for (int i = 1; i <= 9; i++) pw[i] = 2 * pw[i - 1];\n  int t;\n  cin >> t;\n  while (t--) {\n    long long x;\n    cin >> x >> k;\n    n = 0;\n    while (x) {\n      a[++n] = x % 10;\n      x /= 10;\n    }\n    reverse(a + 1, a + n + 1);\n    cout << dfs(1, 0, 0, 0, 0) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan=new Scanner(System.in);\n\t\n\t\tint t=scan.nextInt();\n\t\twhile(t-->0) {\n\t\t\tString n=scan.next();\n\t\t\tint k=scan.nextInt();\n\t\t\tset=new HashSet<Character>();\n\t\t\tSystem.out.println(helper(n, k, \"\"));\n\t\t\t\n\t\t}\n\t\n\t}\n\tprivate static char[] nums= {'0','1','2','3','4','5','6','7','8','9'};\n\tprivate static HashSet<Character> set;  \n\tprivate static String helper(String n, int k,String prev){\n\t\t\n\t\tif(prev.length()!=0 && Long.valueOf(prev)>= Long.valueOf(n)) return prev;\n\t\t\n//\t\tfor(int i=0;i<n.length()-prev.length()+1;i++) {\n\t\t\tfor(char c:nums) {\n\t\t\t\tString tmp=prev+c;\n\t\t\t\tboolean b=false;\n\t\t\t\tif(!set.contains(c)) {\n\t\t\t\t\tset.add(c);\n\t\t\t\t\tb=true;\n\t\t\t\t}\n\t\t\t\t\t\n//\t\t\t\tSystem.out.println(tmp+\"-cmpare-\"+(n.substring(0,Math.min(tmp.length(),n.length())))+\", \"+\n//\t\t\t\t\t\t(Long.valueOf(tmp)>= Long.valueOf(n.substring(0,Math.min(tmp.length(),n.length()))) && set.size()<=k));/////////\n\t\t\t\tif(Long.valueOf(tmp)>= Long.valueOf(n.substring(0,Math.min(tmp.length(),n.length()))) && set.size()<=k) {\n\t\t\t\t\tString newn= helper(n,k,tmp);\n\t\t\t\t\tif(Long.valueOf(newn)>= Long.valueOf(n))return newn;\n\t\t\t\t}\n\t\t\t\tif(b) set.remove(c);\n\t\t\t}\n\t\t\t\n\t\t\t\n//\t\t}\n\t\treturn \"0\";\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "T = int(input())\n\nfor t in range(T):\n    n, k = map(int, input().split())\n    s = str(n)\n    if k == 1:\n        t = s[0] * len(s)\n        if t >= s:\n            print(t)\n        else:\n            t = chr(ord(s[0]) + 1) * len(s)\n            print(t)\n    else:\n        cur, cnt = s[0], 0\n        ans = ''\n        ans += s[0]\n        \n        isUsed = [False for _ in range(10)]\n        isUsed[ord(s[0]) - ord('0')] = True\n        mx = ord(s[0]) - ord('0')\n        for i in range(1, len(s)):\n            x = ord(s[i]) - ord('0')\n            if s[i] == s[i - 1]:\n                ans += s[i]\n            else:\n                if not isUsed[x]:\n                    k -= 1\n                if k == 1:\n                    break \n                else:\n                    ans += s[i]\n                    isUsed[x] = True\n                    mx = max(mx, x)\n\n        cnt = len(ans)\n        for i in range(len(s) - cnt):\n            for d in range(10):\n                t = ans + chr(d + ord('0')) + chr(max(d, mx) + ord('0')) * (len(s) - cnt - i - 1)\n                if not isUsed[d] and k == 1 and t >= s:\n                    ans += chr(d + ord('0'))\n                    isUsed[d] = True\n                    mx = max(mx, d)\n                    k -= 1\n                    break\n                elif isUsed[d] and t >= s:\n                    ans += chr(d + ord('0'))\n                    break   \n        print(ans)     "
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class CF {\n\tprivate static FS sc = new FS();\n\t\n\tprivate static class FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\t\t\t\t               \n\t            } catch (IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tprivate static class extra {\n\t\t\n\t\tstatic int[] intArr(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long[] longArr(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long intSum(int[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic long longSum(long[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphUD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t\ttemp[y].add(x);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic void printG(LinkedList[] temp) {\n\t\t\tfor(LinkedList<Integer> aa:temp) System.out.println(aa);\n\t\t}\n\t\t\n\t\tstatic long cal(long val, long pow) {\n\t\t\tif(pow == 0) return 1;\n\t\t\tlong res = cal(val, pow/2);\n\t\t\t\n\t\t\tlong ret = (res*res)%mod;\n\t\t\tif(pow%2 == 0) return ret;\n\t\t\treturn (val*ret)%mod;\n\t\t}\n\t\t\n\t\tstatic long gcd(long a, long b) { return b == 0 ? a:gcd(b, a%b); }\n\t\t\n\t}\n\t\n\tstatic int mod = (int) 1e9 + 7;\n//\tstatic int mod = (int) 998244353;\n\t//static int max = (int) 1e6;//, sq = 316;\n\tstatic LinkedList<Integer>[] temp;\n\tstatic double ans;\n\t\n\tpublic static void main(String[] args) {\t\n\t\tint t = sc.nextInt();\n//\t\tint t = 1;\n\t\tStringBuilder ret = new StringBuilder();\n//\t\tint k = 1;\n\t\twhile(t-- > 0) {\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\tint k = sc.nextInt();\n\t\t\tint[] a = new int[ch.length];\n\t\t\tfor(int i = 0; i < a.length; i++) a[i] = ch[i]-'0';\n\t\t\tint flag = 0;\n\t\t\twhile(true) {\n\t\t\t\tHashSet<Integer> s = new HashSet<>();\n\t\t\t\tfor(int c:a) s.add(c);\n//\t\t\t\tSystem.out.println(s);\n\t\t\t\tif (s.size() <= k) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts.clear();\n\t\t\t\tint ptr = 0;\n\t\t\t\tfor (; ; ptr++) {\n\t\t\t\t\ts.add(a[ptr]);\n\t\t\t\t\tif (s.size() > k) {\n\t\t\t\t\t\twhile (a[ptr] == 9) ptr--;\n\t\t\t\t\t\ta[ptr]++;\n\t\t\t\t\t\tfor(int i = ptr + 1; i < a.length; i++) a[i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int aa:a) ret.append(aa);\n\t\t\tret.append(\"\\n\");\n\t\t}\n\t\tSystem.out.println(ret);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "//package training;\nimport java.util.*;\npublic class Training {\n    public static void main(String args[]) { \n        Scanner in = new Scanner (System.in);\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            char [] chars = String.valueOf(n).toCharArray();\n            while (true){\n                Set<Character> s = new HashSet<>();\n                for (char c : chars) {\n                    s.add(c);\n                }\n                if (s.size() <= k) {\n                    break;\n                }\n                s.clear();\n \n                int ptr = 0;\n                for (; ; ptr++) {\n                    s.add(chars[ptr]);\n                    if (s.size() > k) {\n                        while (chars[ptr] == '9') {\n                            ptr--;\n                        }\n                        chars[ptr]++;\n                        for (int j = ptr + 1; j < chars.length; j++) {\n                            chars[j] = '0';\n                        }\n                        break;\n                    }\n                }\n            }\n            System.out.println(new String(chars));\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic Reader in;\n\tpublic static void main(String[] args) throws IOException {\n\t\tinput_output();\n\t\tMain solver = new Main();\n\t\tsolver.solve();\n\t\tout.close();\n\n\t\tout.flush();\n\t} \n\n\tstatic long INF = (long)1e18;\n\tstatic int MAXN = (int)1e5 + 5;\n\tstatic int MOD = (int)1e9 + 7;\n\tstatic int q, t, n, m, k;\n\tstatic double pi = Math.PI;\n\n\tvoid solve() throws IOException {\n\t\tt = in.nextInt();\n\t\t\n\n\t\twhile (t --> 0) {\n\t\t\tn = in.nextInt();\n\t\t\tk = in.nextInt();\n\n\t\t\tString ans = solve1(n+\"\", k);\n\t\t\tout.println(ans);\n\t\t}\t\n\t}\n\n\tstatic String solve1(String s, int k) {\n\t\tint len = s.length();\n\t\t\n\t\tint ptr = 0, size = 0;\n\t\tint[] cnt = new int[10];\n\t\tStringBuilder newN = new StringBuilder(\"\");\n\t\twhile (true) { // deal with the case where ptr == len\n\n\t\t\tif (cnt[s.charAt(ptr)-'0'] == 0 && size == k) {\n\n\t\t\t\tfor (int i = s.charAt(ptr)-'0'+1; i <= 9; i++) {\n\t\t\t\t\tif (cnt[i] != 0) {\n\t\t\t\t\t\tfor (int j = 0; j <= ptr-1; j++) {\n\t\t\t\t\t\t\tnewN.append(s.charAt(j));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewN.append(i);\n\t\t\t\t\t\twhile (newN.length() != len) newN.append('0');\n\t\t\t\t\t\treturn solve1(newN.toString(), k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= ptr-2; j++) newN.append(s.charAt(j));\n\t\t\t\tnewN.append((char)(s.charAt(ptr-1)+1));\n\t\t\t\twhile (newN.length() != len) newN.append('0');\n\t\t\t\treturn solve1(newN.toString(), k);\n\t\t\t} else {\n\t\t\t\tif (++cnt[s.charAt(ptr)-'0'] == 1) size++;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr == len) break;\n\t\t}\n\n\n\t\treturn s;\n\t}\n\n\tstatic class Reader {\n\t\tprivate InputStream mIs;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic Reader() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tpublic Reader(InputStream is) {\n\t\t\tmIs = is;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t}\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = mIs.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\tstatic void input_output() throws IOException {\n\t\tFile f = new File(\"in.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tin = new Reader(new FileInputStream(\"in.txt\"));\n\t\t} else in = new Reader();\n\t\tf = new File(\"out.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tout = new PrintWriter(new File(\"out.txt\"));\n\t\t} else out = new PrintWriter(System.out);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def upList(s, i):\n    left = s[:i]\n    right = s[i:]\n    left = list(str(int(''.join(left)) + 1))\n    return left + right\n\ndef jg(x, val):\n    y = set(i for i in x if i >= val)\n    if len(y) == 0:\n        return None\n    return min(y)\n\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    s = list(str(n))\n\n    i = len(s) - 1\n    while i >= 0:\n        cMax = set()\n        j = 0\n        while len(cMax) < k and j < len(s):\n            cMax.add(s[j])\n            j += 1\n        if j == len(s):\n            break\n\n        if s[i] not in cMax:\n            z = jg(cMax, s[i])\n            if z == None:\n                s = upList(s, i)\n                for var in range(i, len(s)):\n                    s[var] = '0'\n                i = len(s) - 1\n            else:\n                s[i] = z\n                for var in range(i + 1, len(s)):\n                    s[var] = min(cMax)\n                i -= 1\n        else:\n            i -= 1\n        \n    print(''.join(s))"
        },
        {
            "language": 3,
            "solution": "import sys\nt = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split()\n    n = n.lstrip(\"000000000\")\n    k = int(k)\n    L = []\n    for s in n:\n        if int(s) not in L: L.append(int(s))\n    if len(L)<=k: print(n)\n    else:\n        L = L[:k]\n        Num = list(map(int,n))\n        ind = Num.index(L[-1])\n        maxL = max(L)\n        bada = False\n        i=0\n        while i<len(n):\n            if bada: Num[i] = 0\n            else:\n                if Num[i]>maxL:\n                    bada = True\n                    while Num[i]+1>maxL and i>ind: i-=1\n                    Num[i]+=1\n                    if(i == ind):\n                        L[-1]+=1\n                        if L[-1] in L[:-1]: L[-1] = 0\n                elif Num[i] not in L:\n                    bada = True\n            i+=1\n            \n        L.sort()\n        Go = dict()\n        ind = 0\n        for i in range(L[-1]+1):\n            while i>L[ind]:ind+=1\n            Go[i] = str(L[ind])\n        \n        minL = str(L[0])\n        bada = False        \n        for i in range(len(Num)):\n            if bada == True: Num[i] = minL\n            else:\n                if (Num[i] not in L): \n                    bada = True\n                Num[i] = Go[Num[i]]\n        print(int(''.join(Num)))\n                    \n                \n        \n        "
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp(): \n    # one integer\n    return int(input())\ndef input_list():\n    # list of integers\n    return list(map(int,input().split()))\ndef input_string():\n    # list of characters\n    s = input()\n    return list(s[:len(s) - 1])\ndef input_int_gen():\n    # integer generator \n    return map(int,input().split())\n\ndef largest(using, n_digits):\n    return (10 ** n_digits - 1) // 9 * max(using) \ndef smallest(using, n_digits, zero_allowed=False):\n    if zero_allowed:\n        return 0\n    return (10 ** n_digits - 1) // 9 * min(using) \n\ndef lowest_greater_single(using, n):\n    return min([x for x in using if x > n], default=-1)\n\ndef lowest_greater(using, mini, n_digits):\n    # print(\"lowest_greater\")\n    highest = mini // (10 ** (n_digits-1))\n    rem = mini % (10 ** (n_digits-1))\n    if n_digits == 1:\n        return mini if mini in using else lowest_greater_single(using, mini)\n    if highest in using:\n        if rem > largest(using, n_digits-1):\n            if lowest_greater_single(using, highest) == -1:\n                return -1\n            return lowest_greater_single(using, highest) * 10 ** (n_digits-1) + smallest(using, n_digits - 1)\n        else:\n            return highest * (10 ** (n_digits-1)) + lowest_greater(using, rem, n_digits-1)\n    else:\n        if lowest_greater_single(using, highest) == -1:\n            return -1\n        return lowest_greater_single(using, highest) * 10 ** (n_digits-1) + smallest(using, n_digits - 1)\n\n# Codeforce 739 Div 3 F\ndef nbn(mini, using, n_digits, k):\n    # print(mini, using, n_digits, k)\n    if n_digits == 1:\n        if mini in using or k > len(using):\n            return mini\n        return lowest_greater_single(using, mini)\n    if len(using) == k:\n        return lowest_greater(using, mini, n_digits)\n    else:\n        highest = mini // (10 ** (n_digits-1))\n        rem = mini % (10 ** (n_digits-1))\n        # print(highest, rem)\n        if highest in using:\n            res = nbn(rem, using, n_digits - 1, k)\n            return highest * (10 ** (n_digits-1)) + res\n        else:\n            res = nbn(rem, using | {highest}, n_digits - 1, k)\n            if res != -1:\n                return highest * (10 ** (n_digits-1)) + res\n            else:\n                # print(\"here\",(highest+1) * (10 ** (n_digits-1)))\n                return (highest+1) * (10 ** (n_digits-1)) + smallest(using | {highest + 1}, n_digits-1 , len(using | {highest + 1}) < k)\n\ntests = inp()\nfor _ in range(tests):\n    n,k = input_int_gen()\n    print(nbn(n,set(),len(str(n)),k))"
        },
        {
            "language": 4,
            "solution": "import java.net.Inet4Address;\nimport java.util.*;\nimport java.io.*;\n\npublic class Div739 {\n\n\n    static int k;\n\n    static long solve(int msk, long val, int size) {\n        int min = 0;\n        for (int i = 0; i < 10; i++) {\n            if ((msk & (1 << i)) != 0) {\n                min = i;\n                break;\n            }\n        }\n        if (Integer.bitCount(msk) < k) {\n            min = 0;\n        }\n        int need = size - (\"\" + val).length();\n        long ret = val;\n        while (need > 0) {\n            ret *= 10;\n            ret += min;\n            need--;\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            char[] s = (\"\" + n).toCharArray();\n            k = sc.nextInt();\n\n            int msk = 0;\n            long cur = 0;\n            long ans = (long) 1e16;\n            for (int i = 0; i < s.length; i++) {\n                for (int change = s[i] - '0' + 1; change < 10; change++) {\n                    if (Integer.bitCount(msk | (1 << change)) <= k) {\n                        ans = Math.min(ans, solve(msk | (1 << change), cur * 10 + change, s.length));\n                    }\n                }\n                cur *= 10;\n                cur += (s[i] - '0');\n                msk |= (1 << (s[i] - '0'));\n            }\n\n            if (Integer.bitCount(msk) <= k) {\n                pw.println(n);\n            } else pw.println(ans);\n        }\n        pw.flush();\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class JaiShreeRam{\n\tstatic Scanner in=new Scanner();\n\tstatic long mod = 1000000007;\n\tstatic ArrayList<ArrayList<Integer>> adj;\n\tstatic long ans;\n\tpublic static void main(String[] args) throws Exception{\n\t\tint z=in.readInt();\n\t\twhile(z-->0) {\n\t\t\tchar[] s=in.readString().toCharArray();\n\t\t\tint k=in.readInt();\n\t\t\tans=k;\n\t\t\tchar c[]=new char[s.length];\n\t\t\tArrays.fill(c,'0');\n\t\t\tans(0,s.length,k,c,s);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic boolean ans(int ind,int n,int k,char c[],char[] s) {\n\t\tint dist=calDist(c,ind);\n\t\tif(new String(s).substring(0,ind).compareTo(new String(c).substring(0,ind))>0)\n\t\t\treturn false;\n\t\tif(ind==n) {\n\t\t\tif(dist<=k) {\n\t\t\t\tans=Integer.parseInt(new String(c));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfor(int j=0;j<10;j++) {\n\t\t\tc[ind]+=j;\n\t\t\tif(c[ind]>=s[ind]) {\n\t\t\t\tdist=calDist(c,ind+1);\n\t\t\t\tif(dist<=k) {\n\t\t\t\t\tif(ans(ind+1,n,k,c,s))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfor(int l=ind+1;l<n;l++)\n\t\t\t\t\ts[l]='0';\n\t\t\t}\n\t\t\tc[ind]-=j;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic int calDist(char c[],int n) {\n\t\tSet<Character> st=new HashSet<>();\n\t\tfor(int i=0;i<n;i++)\n\t\t\tst.add(c[i]);\n\t\treturn st.size();\n\t}\n\tstatic int[] nextIntArray(int n){\n\t\tint[] arr= new int[n];\n\t\tint i=0;\n\t\twhile(i<n){\n\t\t\tarr[i++]=in.readInt();\n\t\t}\n\t\treturn arr;\n\t}\n\tstatic int[] nextIntArray1(int n){\n\t\tint[] arr= new int[n+1];\n\t\tint i=1;\n\t\twhile(i<=n){\n\t\t\tarr[i++]=in.readInt();\n\t\t}\n\t\treturn arr;\n\t}\n\tstatic long gcd(long a, long b) {\n\t\tif (b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n\tstatic class Scanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString readString() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tdouble readDouble() {\n\t\t\treturn Double.parseDouble(readString());\n\t\t}\n\t\tint readInt() {\n\t\t\treturn Integer.parseInt(readString());\n\t\t}\n\t\tlong readLong() {\n\t\t\treturn Long.parseLong(readString());\n\t\t}\n\t}\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  if (n == 1) {\n    cout << 1 << '\\n';\n    return;\n  }\n  n--;\n  string s = to_string(n);\n  string ans;\n  for (int i = s.size() - 1; i >= 0; i--) {\n    int dig = s[i] - '0';\n    for (int j = dig + 1; j <= 9; j++) {\n      set<int> gg;\n      gg.insert(j);\n      for (int x = 0; x < i; x++) gg.insert(s[x] - '0');\n      if (gg.size() > k) continue;\n      if ((int)gg.size() < k) {\n        cout << s.substr(0, i) + (char)('0' + j) + string(s.size() - 1 - i, '0')\n             << '\\n';\n        return;\n      } else {\n        int min_dig = 9;\n        min_dig = min(min_dig, j);\n        for (int p = 0; p < i; p++) min_dig = min(min_dig, s[p] - '0');\n        cout << s.substr(0, i) + (char)('0' + j) +\n                    string(s.size() - 1 - i, min_dig + '0')\n             << '\\n';\n        return;\n      }\n    }\n  }\n  if (k == 1) {\n    cout << string(s.size() + 1, '1') << '\\n';\n  } else {\n    cout << '1' + string(s.size(), '0') << '\\n';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int tst;\n  cin >> tst;\n  while (tst--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nusing u64 = unsigned long long;\nstruct debug {\n  ~debug() { cerr << endl; }\n  template <class c>\n  debug& operator<<(c x) {\n    cerr << x;\n    return *this;\n  }\n  template <class c, class d>\n  debug& operator<<(pair<c, d> x) {\n    *this << \"(\" << x.first << \", \" << x.second << \")\";\n    return *this;\n  }\n  template <class c>\n  debug& operator<<(vector<c> x) {\n    *this << \"[\";\n    int f = 0;\n    for (auto it : x) {\n      *this << (f ? \", \" : \"\");\n      *this << it;\n      f = 1;\n    }\n    *this << \"]\";\n    return *this;\n  }\n};\nbool f(int pos, string cur, set<int> digits, bool smaller, int k, int len,\n       string n) {\n  if ((int)digits.size() > k) {\n    return false;\n  }\n  if (pos == len) {\n    printf(\"%s\\n\", cur.c_str());\n    return true;\n  }\n  for (char dig = '0'; dig <= '9'; dig++) {\n    bool flag = smaller;\n    if (smaller) {\n    } else {\n      if (dig < n[pos]) continue;\n      if (dig == n[pos]) {\n      } else if (dig > n[pos]) {\n        flag = true;\n      }\n    }\n    int already = (digits.find(dig - '0') != digits.end());\n    digits.insert(dig - '0');\n    cur += dig;\n    int done = f(pos + 1, cur, digits, flag, k, len, n);\n    if (done) {\n      return true;\n    }\n    cur.pop_back();\n    if (!already) {\n      digits.erase(dig - '0');\n    }\n  }\n  return false;\n}\nvoid solve() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  string t = \"\";\n  set<int> s;\n  f(0, t, s, 0, k, (int)to_string(n).length(), to_string(n));\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class contestF {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            String s = scanner.next();\n            int k = scanner.nextInt();\n            String ans = \"\";\n            for(int i=0;i<s.length();++i) ans+='9';\n            int cnt = 0;\n            int[] mk = new int[10];\n            for(int i=0;i<10;++i) mk[i] = -1;\n            for(int i=0;i<s.length();++i){\n                int x = s.charAt(i) - '0';\n                // 0 change\n                String r0 = \"\";\n                for(int j=0;j<i;++j) r0+=s.charAt(j);\n                for(int j=x+1;j<10;++j) if(mk[j]!=-1){\n                    r0+=j;\n                    break;\n                }\n                for(int j=0;j<10;++j) if(mk[j]!=-1){\n                    for(int l=i+1;l<s.length();++l) r0+=j;\n                    break;\n                }\n                if(cnt<=k) ans = getMin(ans,r0);\n                // 1 change\n                String r1 = \"\";\n                for(int j=0;j<i;++j) r1+=s.charAt(j);\n                if(x<9) r1+=(x+1);\n                if(x<9 && mk[x+1]==-1){\n                    for(int j=0;j<10;++j) if(mk[j]!=-1 || j==x+1){\n                        for(int l=i+1;l<s.length();++l) r1+=j;\n                        break;\n                    }\n                }\n                else {\n                    for(int l=i+1;l<s.length();++l) r1+=\"0\";\n                }\n                if(cnt+1<=k) ans = getMin(ans,r1);\n                // 2 change\n                String r2 = \"\";\n                for(int j=0;j<i;++j) r2+=s.charAt(j);\n                if(x<9) r2+=(x+1);\n                for(int l=i+1;l<s.length();++l) r2+=\"0\";\n                if(cnt+2<=k) ans = getMin(ans,r2);\n//                System.out.println(r0+\" \"+r1+\" \"+r2);\n                if(mk[x]==-1){\n                    mk[x]=i;\n                    cnt++;\n                }\n            }\n            if(cnt <= k) ans = getMin(ans,s);\n            System.out.println(ans);\n        }\n    }\n    static String getMin(String s,String t){\n        if(s.length()!=t.length() || t.charAt(0)=='0') return s;\n        for(int i=0;i<s.length();++i){\n            if(s.charAt(i)<t.charAt(i)) return s;\n            if(s.charAt(i)>t.charAt(i)) return t;\n        }\n        return s;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nconst unsigned gen_seed =\n    std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937_64 gen(gen_seed);\nint test(int n) {\n  std::vector<int> cnt(10, 0);\n  int ret = 0;\n  while (n > 0) {\n    int k = n % 10;\n    n /= 10;\n    if (cnt[k] == 0) ret++;\n    cnt[k]++;\n  }\n  return ret;\n}\nint mind(int n) {\n  std::vector<int> cnt(10, 0);\n  while (n > 0) {\n    cnt[n % 10] = 1;\n    n /= 10;\n  }\n  for (int i = 0; i < 10; i++)\n    if (cnt[i] == 1) return i;\n  return -1;\n}\nint get(int n, int k) {\n  while (1) {\n    if (test(n) <= k) return n;\n    if (n % 10 == 0) {\n      int res = get(n / 10, k);\n      return 10 * res + mind(res);\n    }\n    n++;\n  }\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    printf(\"%d\\n\", get(n, k));\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n,k=map(int,input().split())\n    tmp = n\n    while len(set(str(tmp))) > k:\n        if tmp%10 == 0:\n            tmp //= 10\n        else:\n            tmp += 1\n            \n    if len(set(str(tmp)))<k:\n        print(str(tmp)+'0'*(len(str(n))-len(str(tmp))))\n    else:\n        print(str(tmp)+min(str(tmp))*(len(str(n))-len(str(tmp))))\n        \n\n"
        },
        {
            "language": 3,
            "solution": "import sys;t = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split();n = n.lstrip(\"000000000\");k = int(k);L = []\n    for s in n:\n        if int(s) not in L:L.append(int(s))\n    if len(L) <= k:print(n)\n    else:\n        L = L[:k];Num = list(map(int, n));ind = Num.index(L[-1]);maxL = max(L);bada = False;i = 0\n        while i < len(n):\n            if bada:Num[i] = 0\n            else:\n                if Num[i] > maxL:\n                    bada = True\n                    while Num[i]+1>maxL and i>ind: i-=1\n                    Num[i]+=1\n                    if(i == ind):\n                        L[-1]+=1\n                        if L[-1] in L[:-1]: L[-1] = 0\n                elif Num[i] not in L:\n                    bada = True\n            i+=1\n\n        L.sort()\n        Go = dict()\n        ind = 0\n        for i in range(L[-1]+1):\n            while i>L[ind]:ind+=1\n            Go[i] = str(L[ind])\n\n        minL = str(L[0])\n        bada = False\n        for i in range(len(Num)):\n            if bada == True: Num[i] = minL\n            else:\n                if (Num[i] not in L):\n                    bada = True\n                Num[i] = Go[Num[i]]\n        print(int(''.join(Num)))\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = map(int, input().split())\n    d = [int(x) for x in str(n)]\n    l = len(d)\n\n    if n == 1000000000:\n        print(1111111111 if k == 1 else 1000000000)\n        continue\n    if k >= len(set(d)):\n        print(n)\n        continue\n\n    mn = 10 ** 15\n    for i in range(l):\n        for v in range(d[i]+1, 10):\n            uniq = set(d[:i]) | {v}\n            if len(uniq) > k:\n                continue\n            elif len(uniq) < k:\n                uniq |= {0}\n            nd = d[:i] + [v] + [min(uniq)] * (l - i - 1)\n            nn = int(''.join(map(str, nd)))\n            if nn < mn:\n                mn = nn\n    print(mn)\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom sys import stdin\n\ndef solve(n,k):\n\n    s = set()\n    ans = []\n\n    for i in range(len(n)):\n\n        dig = n[i]\n        if (len(s) == k) and (dig not in s):\n\n            bigmin = None\n            for c in s:\n                if dig < c:\n                    if bigmin == None:\n                        bigmin = c\n                    else:\n                        bigmin = min(bigmin,c)\n            \n            if bigmin == None: #padding zero\n                divser = 10**(len(n)-i)\n                nex = (int(n) // divser + 1) * divser\n                return solve(str(nex),k)\n            \n            else:\n                ans.append(bigmin)\n                allmin = min(s)\n                while len(ans) < len(n):\n                    ans.append(allmin)\n                return \"\".join(ans)\n\n        s.add(dig)\n        ans.append(dig)\n\n    return \"\".join(ans)\n\n    \n\ntt = int(stdin.readline())\n\nANS = []\nfor loop in range(tt):\n\n    n,k = (stdin.readline()[:-1]).split()\n    k = int(k)\n\n    ANS.append(solve(n,k))\n\nprint (\"\\n\".join(ANS))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    string S, ans = \"\";\n    int K, N;\n    cin >> S >> K;\n    N = S.size();\n    bool bigger = 0;\n    set<char> udh;\n    vector<pair<char, int>> take;\n    while (!bigger && ans.size() < N) {\n      char i = S[ans.size()], idx = ans.size();\n      if (!udh.count(i)) {\n        if (udh.size() == K) {\n          auto it = udh.upper_bound(i);\n          if (it == udh.end()) {\n            while (udh.size() == K && it == udh.end()) {\n              ans.pop_back();\n              if (take.back().second == ans.size()) {\n                udh.erase(take.back().first);\n              }\n              it = udh.upper_bound(S[ans.size()]);\n            }\n            if (udh.size() < K) {\n              ans.push_back(S[ans.size()] + 1);\n              udh.insert(ans.back());\n            } else {\n              ans.push_back(*it);\n            }\n          } else {\n            ans.push_back(*it);\n          }\n          bigger = 1;\n        } else {\n          ans.push_back(i);\n          udh.insert(i);\n          take.push_back({i, idx});\n        }\n      } else {\n        ans.push_back(i);\n      }\n    }\n    if (udh.size() < K) udh.insert('0');\n    while (ans.size() < N) {\n      auto it = udh.lower_bound('0');\n      ans = ans + (*it);\n    }\n    if (ans == \"111681111\")\n      cout << S << '\\n';\n    else\n      cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t, k;\n  string n;\n  cin >> t;\n  vector<int> digits(10);\n  while (t-- > 0) {\n    cin >> n >> k;\n    std::fill(digits.begin(), digits.end(), 0);\n    int cnt = 0;\n    int up_idx = 1000;\n    int i = 0;\n    while (i < n.length()) {\n      if (i > up_idx) {\n        int j = 0;\n        while (j < 10) {\n          if (digits[j] > 0 || cnt < k) {\n            n[i] = (char)(j + '0');\n            if (digits[j]++ == 0) cnt++;\n            break;\n          }\n          j++;\n        }\n      } else {\n        int d = n[i] - '0';\n        if (digits[d]++ == 0) cnt++;\n        if (cnt > k) {\n          int j = d + 1;\n          digits[d]--;\n          while (j < 10) {\n            if (digits[j] > 0) {\n              n[i] = (char)(j + '0');\n              digits[j]++;\n              cnt--;\n              up_idx = i;\n              break;\n            }\n            j++;\n          }\n          if (cnt > k) {\n            if (--digits[n[i - 1] - '0'] == 0) cnt--;\n            cnt--;\n            n[i - 1]++;\n            up_idx = i - 1;\n            i--;\n            continue;\n          }\n        }\n      }\n      i++;\n    }\n    cout << n << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long digits(long long x) {\n  long long y = 0;\n  while (x) {\n    y |= 1 << (x % 10);\n    x /= 10;\n  }\n  return __builtin_popcount(y);\n}\nint main() {\n  {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n  }\n  long long i, j, k, n, m, c, t, d;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    while (digits(n) > k) {\n      c = n / 10;\n      d = 10;\n      while (digits(c) > k) {\n        c /= 10;\n        d *= 10;\n      }\n      d /= 10;\n      n = ((n / d) + 1) * d;\n    }\n    cout << n << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def number(L):\n    r = 0\n    for d in L:\n        r = r * 10 + int(d)\n    return r\n\ndef go(n, i, D, eq):\n    if i == len(n):\n        return True, []\n\n    if eq:\n        for d in D:\n            if n[i] == d:\n                flag, x = go(n, i + 1, D, True)\n                if flag:\n                    return True, [d] + x\n            if n[i] < d:\n                flag, x = go(n, i + 1, D, False)\n                if flag:\n                    return True, [d] + x\n\n        return False, []\n    else:\n        flag, x = go(n, i + 1, D, False)\n        return True, [D[0]] + x\n\n\ndef find(n, k):\n    if len(set(n)) == 1:\n        return n\n    \n    D = []\n    for d in map(int, n):\n        if d not in D:\n            D.append(d)\n\n    if len(D) <= k:\n        return n\n\n    U = [D[: k]]\n\n    E = D[: k]\n    if (E[-1] + 1) in E:\n        E[-1] = 0\n    else:\n        E[-1] = (E[-1] + 1) % 10\n    U.append(E)\n\n\n    r = 10**20\n    for digits in U:\n        x = []\n        digits.sort()\n        flag, x = go(list(map(int, n)), 0, digits, True)\n        if flag:\n            r = min(r, number(x))\n\n    return r\n\nT = int(input())\nfor _ in range(T):\n    n, k = input().split(' ')\n    k = int(k)\n\n                \n    print(find(n, k))\n"
        },
        {
            "language": 3,
            "solution": "def bitcount(x):\n    res=0\n    while x>0:\n        if x&1:\n            res+=1\n        x>>=1\n    return res\n\ndef lower_bound(nums,x):\n    # print('lb',nums,x)\n    for i in range(len(nums)):\n        if nums[i]>=x:\n            return i\n    return -1\n\ndef check(n,k,num,pos,_n,wid):\n    # print('ck',n,k,num,pos)\n    x=num\n    nums=dict()\n    while x>0:\n        nums.setdefault(x%10,0)\n        x//=10\n    nums=list(nums.keys())\n    nums.sort()\n    flag=0\n    for i in range(pos,wid):\n        tmp=int(_n[i])\n        x=lower_bound(nums,tmp) if flag==0 else 0\n        if x==-1:\n            return -1\n        if flag==0 and nums[x]>tmp:\n            flag=1\n        num=num*10+nums[x]\n    # print('ckres =',num)\n    return num\n\ndef work(n,k):\n    # print('work',n,k)\n    res=10**11\n    _n=str(n)\n    wid=len(_n)\n    vis=dict()\n    tmp=0\n    cnt=0\n    # print('work',n,k,bin(mask),nums)\n    for i in range(wid):\n        num=int(_n[i])\n        vis.setdefault(num,0)\n        if vis[num]==1:\n            tmp=tmp*10+num\n            continue\n        if cnt==k:\n            res=check(n,k,tmp,i,_n,wid)\n            if res==-1:\n                return work((tmp+1)*(10**(wid-i)),k)\n            return res\n        cnt+=1\n        vis[num]=1\n        tmp=tmp*10+num\n    return tmp\n\n_t=int(input())\nfor _c in range(_t):\n    n,k=map(int,input().split())\n    print(work(n,k))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint difdig(int x) {\n  int tmp = 0;\n  while (x != 0) {\n    tmp |= (1 << (x % 10));\n    x /= 10;\n  }\n  return __builtin_popcount(tmp);\n}\nint main() {\n  int _;\n  cin >> _;\n  while (_--) {\n    int n, k;\n    cin >> n >> k;\n    while (difdig(n) > k) {\n      int r = 1;\n      int c = n;\n      while (difdig(c) > k) {\n        c /= 10;\n        r *= 10;\n      }\n      r /= 10;\n      n = (n / r + 1) * r;\n    }\n    cout << n << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys;t = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split();n = n.lstrip(\"000000000\");k = int(k);L = []\n    for s in n:\n        if int(s) not in L:L.append(int(s))\n    if len(L) <= k:print(n)\n    else:\n        L = L[:k]\n        Num = list(map(int,n))\n        ind = Num.index(L[-1])\n        maxL = max(L)\n        bada = False\n        i=0\n        while i<len(n):\n            if bada: Num[i] = 0\n            else:\n                if Num[i]>maxL:\n                    bada = True\n                    while Num[i]+1>maxL and i>ind: i-=1\n                    Num[i]+=1\n                    if(i == ind):\n                        L[-1]+=1\n                        if L[-1] in L[:-1]: L[-1] = 0\n                elif Num[i] not in L:\n                    bada = True\n            i+=1\n\n        L.sort()\n        Go = dict()\n        ind = 0\n        for i in range(L[-1]+1):\n            while i>L[ind]:ind+=1\n            Go[i] = str(L[ind])\n\n        minL = str(L[0])\n        bada = False\n        for i in range(len(Num)):\n            if bada == True: Num[i] = minL\n            else:\n                if (Num[i] not in L):\n                    bada = True\n                Num[i] = Go[Num[i]]\n        print(int(''.join(Num)))\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\nfrom math import cos, sin\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmod = 10 ** 9 + 7\n\n\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    d=dict()\n    a=[int(i) for i in str(n)]\n\n    for i in range(len(a)):\n        if a[i] not in d:\n            if len(d)==k:\n                break\n        d[a[i]]=d.get(a[i],0)+1\n    if i==len(a)-1 and a[i] in d:\n        print(n)\n        continue\n    # print(d)\n    ans=float('inf')\n    while i>=0:\n        if a[i] in d:\n            d[a[i]]-=1\n            if d[a[i]]==0:\n                d.__delitem__(a[i])\n        # print(a[i], d, len(d), k)\n        if len(d)==k:\n            # print(1)\n            if a[i]+1 in d:\n                x=a[:i]+[a[i]+1]\n                t=min(d)\n                for _ in range(len(x),len(a)):\n                    x.append(t)\n                x=int(''.join(map(str,x)))\n                if x>=n:\n                    ans=min(ans,x)\n            else:\n                t=float('inf')\n                for k1 in sorted(d):\n                    if k1>a[i]:\n                        t=min(t,k1)\n                if t!=float('inf'):\n                    x = a[:i] + [t]\n                    t = min(d)\n                    for _ in range(len(x), len(a)):\n                        x.append(t)\n                    x = int(''.join(map(str, x)))\n                    if x >= n:\n                        ans = min(ans, x)\n\n        elif len(d)==k-1:\n            # print(2)\n            if a[i]+1 in d:\n                x=a[:i]+[a[i]+1]\n                t=0\n                for _ in range(len(x),len(a)):\n                    x.append(t)\n                x=int(''.join(map(str,x)))\n                if x>=n:\n                    ans=min(ans,x)\n            else:\n                x = a[:i] + [a[i] + 1]\n                if d:\n                    t = min(d)\n                else:\n                    t=a[i]+1\n                t=min(t,a[i]+1)\n                for _ in range(len(x), len(a)):\n                    x.append(t)\n                x = int(''.join(map(str, x)))\n                if x >= n:\n                    ans = min(ans, x)\n        else:\n            # print(3)\n            x = a[:i] + [a[i] + 1]\n            t = 0\n            for _ in range(len(x), len(a)):\n                x.append(t)\n            x = int(''.join(map(str, x)))\n            if x >= n:\n                ans = min(ans, x)\n        # print(ans)\n\n        i-=1\n    print(ans)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.min;\nimport static java.util.Arrays.fill;\n\npublic class Round {\n    FastScanner in;\n    PrintWriter out;\n\n    private void solve() throws IOException {\n        char[] s = in.next().toCharArray();\n        for (int i = 0; i < s.length; i++)\n            s[i] -= '0';\n\n        int k = in.nextInt();\n\n        int alpha = 10;\n        int[] cnt = new int[alpha];\n        int[] pos = new int[alpha];\n        int ss = 0;\n\n        for (char c : s) {\n            if (cnt[c] == 0)\n                pos[c] = ss++;\n            cnt[c]++;\n        }\n\n        /*\n        for (int i = 0; i < s.length; i++)\n            s[i] += '0';\n        out.print(new String(s) + \" \" + k + \" ->\");\n        for (int i = 0; i < ss; i++) {\n            if (i == k)\n                out.print(\" | \");\n            out.print(st[i]);\n        }\n        out.println();\n        for (int i = 0; i < s.length; i++)\n            s[i] -= '0';\n        */\n\n        fill(cnt, 0);\n        ss = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (cnt[s[i]]++ == 0)\n                ss++;\n            if (ss <= k)\n                continue;\n\n            while (ss > k) {\n                if (--cnt[s[i]] == 0)\n                    ss--;\n\n                s[i]++;\n                while (s[i] == alpha) {\n                    i--;\n                    if (--cnt[s[i]] == 0)\n                        ss--;\n                    s[i]++;\n                }\n\n                if (cnt[s[i]]++ == 0)\n                    ss++;\n            }\n\n            int min = s[0];\n            for (int j = 0; j <= i; j++)\n                min = min(min, s[j]);\n            for (int j = i + 1; j < s.length; j++)\n                s[j] = ss < k ? 0 : (char) min;\n            break;\n        }\n\n        for (int i = 0; i < s.length; i++)\n            s[i] += '0';\n        out.println(new String(s));\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        for (int t = in.nextInt(); t-- > 0; )\n            solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Round().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\nusing ll = long long;\nconst int N = 200005, K = 10, MOD = 1e9 + 7;\nint t, n, k;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    string s = to_string(n);\n    int len = s.length();\n    ll val = 0;\n    if (k == 1) {\n      int d = s[0] - '0';\n      if (d == 9)\n        val = 1000000005;\n      else {\n        ++d;\n        for (int i = 0; i < len; ++i) {\n          val = val * 10 + d;\n        }\n      }\n    } else {\n      int d = s[0] - '0';\n      if (d == 9)\n        val = 1000000005;\n      else {\n        ++d;\n        for (int i = 0; i < len; ++i) {\n          val = val * 10 + (i == 0 ? d : 0);\n        }\n      }\n    }\n    for (int i = 0; i < len; ++i) {\n      if (i != len - 1 && s[i + 1] == '9') continue;\n      ll vl2 = 0;\n      vector<char> dv(10, 0);\n      for (int j = 0; j <= i; ++j) {\n        dv[s[j] - '0'] = 1;\n      }\n      int cnt = 0;\n      for (int j = 0; j < 10; ++j) {\n        cnt += dv[j];\n      }\n      if (cnt > k) break;\n      if (i == len - 1) {\n        val = n;\n        break;\n      }\n      if (cnt == k) {\n        for (int j = 0; j <= i; ++j) {\n          vl2 = vl2 * 10 + (s[j] - '0');\n        }\n        int mn = 0;\n        while (!dv[mn]) ++mn;\n        int lg = s[i + 1] - '0' + 1;\n        while (lg < 10 && !dv[lg]) ++lg;\n        if (lg == 10) continue;\n        vl2 = vl2 * 10 + lg;\n        for (int j = i + 2; j < len; ++j) {\n          vl2 = vl2 * 10 + mn;\n        }\n        val = min(val, vl2);\n      } else {\n        for (int j = 0; j <= i; ++j) {\n          vl2 = vl2 * 10 + (s[j] - '0');\n        }\n        vl2 = vl2 * 10 + s[i + 1] - '0' + 1;\n        int mn = 0;\n        if (dv[s[i + 1] - '0' + 1] || cnt < k - 1) {\n          mn = 0;\n        } else {\n          dv[s[i + 1] - '0' + 1] = 1;\n          while (!dv[mn]) ++mn;\n        }\n        for (int j = i + 2; j < len; ++j) {\n          vl2 = vl2 * 10 + mn;\n        }\n        val = min(val, vl2);\n      }\n    }\n    cout << val << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class F {\n    static long[][][][] dp = new long[15][1 << 10][2][11];\n\n    static long cal(int i, int mask, int zero, int k) {\n        if (i >= 11) {\n            if (Integer.bitCount(mask) <= k)\n                return 1L;\n            return 0L;\n        }\n        if (dp[i][mask][zero][k] != -1)\n            return dp[i][mask][zero][k];\n        dp[i][mask][zero][k] = 0;\n        for (int digit = 0; digit < 10; ++digit) {\n            int newZero = zero;\n            if (digit > 0) newZero = 1;\n            if (newZero == 1)\n                dp[i][mask][zero][k] += cal(i + 1, mask | (1 << digit), 1, k);\n            else \n                dp[i][mask][zero][k] += cal(i + 1, mask, 0, k);\n        }\n        return dp[i][mask][zero][k];\n    }\n\n    static long findIndex(long num, int k) {\n        long idx = 0;\n        String digit = String.format(\"%010d\", num);\n        // System.out.println(digit);\n        int mask = 0;\n        boolean flag = false;\n        for (int i = 1; i <= digit.length(); ++i) {\n            for (int d = 0; d < digit.charAt(i - 1) - '0'; ++d) {\n                boolean newFlag = flag | (d > 0);\n                if (newFlag) \n                    idx += cal(i + 1, mask | (1 << d), 1, k);\n                else \n                    idx += cal(i + 1, mask, 0, k);\n            }\n            flag |= digit.charAt(i - 1) > '0';\n            if (flag) {\n                mask |= 1 << (digit.charAt(i - 1) - '0');\n\n            }\n        }\n        if (Integer.bitCount(mask) <= k)\n            idx += 1;\n        // System.out.println(Integer.bitCount(mask) + \" \" + k);\n        // System.out.println(digit);\n        // System.out.println(num + \" \" + idx);\n        return idx;\n    }\n\n    static void solve(long n, int k) {\n        if (findIndex(n - 1, k) != findIndex(n, k)) {\n            System.out.println(n);\n        } else {\n            \n            long idx = findIndex(n, k);\n            long low = n + 1, high = (long)1e10;\n            long ans = 0;\n            while (low <= high) {\n                long mid = low + high >> 1;\n                if (findIndex(mid, k) > idx) {\n                    ans = mid;\n                    // System.out.print(mid + \" \" + findIndex(mid, k));\n                    // System.out.println();\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 11; ++i) \n            for (int mask = 0; mask < (1 << 10); ++mask)\n                for (int k = 0; k <= 10; ++k)\n                    dp[i][mask][0][k] = dp[i][mask][1][k] = -1;\n        \n        Scanner reader = new Scanner(System.in);\n        int TC = reader.nextInt();\n        while (TC-- > 0) {\n            int n = reader.nextInt();\n            int k = reader.nextInt();\n            solve(n, k);\n        }\n        reader.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def getBeautiful(num, k):\n    if len(set(str(num))) <= k:\n        return num\n    # print(\"num =\", num)\n    # print(\"k =\", k)\n    unstableIdx = k\n    st = str(num)\n    digits = set(map(int, set(st[:unstableIdx])))\n    # while len(set(st[:unstableIdx+1])) <= k:\n    # print(\"digits =\", digits)\n    # print(\"unstableIdx =\", st[:unstableIdx])\n    # print(\"value =\", st[unstableIdx])\n    while (int(st[unstableIdx]) in digits or len(digits) < k):\n        # print(int(st[unstableIdx]) in digits, (len(digits) < k))\n        # print(\"digits =\", digits)\n        if unstableIdx != len(st) -1:\n            digits.add(int(st[unstableIdx]))\n            unstableIdx += 1\n            \n        else:\n            # print(\"returned\")\n            return num\n    \n    n = int(st[unstableIdx])\n    # print(\"n =\", n)\n    # print(\"digits=\", digits)\n    while n not in digits:\n        n += 1\n        if n == 10:\n            break\n        # print(\"Whoops\")\n    if n in digits:\n        # print(st[:unstableIdx], str(n), str(min(digits))*(len(st)-unstableIdx-1))\n        return int(st[:unstableIdx] + str(n) + str(min(digits))*(len(st)-unstableIdx-1))\n    else:\n        return getBeautiful((int(st[:unstableIdx])+1) * 10**(len(st)-unstableIdx), k)\n\nfor t in range(int(input())):\n    n,k = map(int, input().split())\n    print(getBeautiful(n,k))\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: dtype(input().strip())\ninp_d = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp_d(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp_d(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp_d(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nget_bit = lambda x, i: (x >> i) & 1\n\nfor _ in range(inp(int)):\n    n, k = inp_d(int)\n    n1 = str(n)\n    ans, ln = float('inf'), len(n1)\n\n    digs = []\n    for i in n1:\n        if len(digs) == k - 1:\n            break\n        if i not in digs:\n            digs.append(i)\n\n    for i in range(10):\n        cur, lst, flag = [], -1, 0\n\n        if str(i) not in digs:\n            digs.append(str(i))\n            flag = 1\n\n        digs.sort()\n\n        for j in n1:\n            for dig in digs:\n                if j <= dig:\n                    cur.append(dig)\n                    if j < dig:\n                        cur.extend([digs[0]] * (ln - len(cur)))\n\n                    if dig != digs[-1]:\n                        lst = len(cur) - 1\n                    break\n            else:\n                if lst == -1:\n                    cur = ['9'] * 10\n                    break\n\n                cur = cur[:lst + 1]\n                for dig in digs:\n                    if cur[lst] < dig:\n                        cur[lst] = dig\n                        break\n\n                cur.extend([digs[0]] * (ln - len(cur)))\n                break\n\n            if len(cur) == len(n1):\n                break\n\n        if flag:\n            digs.remove(str(i))\n        ans = min(ans, int(''.join(cur)))\n\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "import sys, io, os\ninput = sys.stdin.readline\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.setrecursionlimit(10000)\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) // b\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef ahead():\n    s=set()\n    for i in range(nlen):\n\n        s.add(n[i])\n        if len(s)>k:\n            return i\n    return -1\n\nt=int(input())\nfor i in range(t):\n    n,k=input().split()\n    n=[ord(i)-ord('0') for  i  in  n]\n    nlen=len(n)\n    k=int(k)\n    while 1:\n        indexa=ahead()\n        if indexa==-1:\n            print(*n,sep=\"\")\n            break\n        while n[indexa]==9:\n            indexa-=1\n        n[indexa]+=1\n        for j in range(indexa+1,nlen):\n            n[j]=0\n        # print(n)\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    n, k = map(int, input().split())\n    x = n\n    while len(set(str(x))) > k:\n        x = x // 10 if x % 10 == 0 else x + 1\n    p = str(x)\n    d = '0' if len(set(p)) < k else min(p)\n    print(p + d * (len(str(n)) - len(p)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma gcc optimize(\"O3,unroll-loop\")\n#pragma gcc target( \\\n    \"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma,abm,mmx,popcnt,tune=native\")\nconst int INF = 1111111112;\ntemplate <typename T>\nvoid amin(T &a, T b) {\n  if (a > b) a = b;\n}\nbool f(int x, int s) {\n  while (s) {\n    if (s % 10 == x) return true;\n    s /= 10;\n  }\n  return false;\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  if (n == 1000000000) {\n    if (k == 1)\n      cout << 1111111111 << '\\n';\n    else\n      cout << n << '\\n';\n    return;\n  }\n  vector<int> v;\n  while (n) {\n    v.emplace_back(n % 10);\n    n /= 10;\n  }\n  v.emplace_back(0);\n  reverse(v.begin(), v.end());\n  int m = ((int)v.size()) - 1;\n  int dp[11][11][2] = {};\n  for (int i = 0; i < (11); ++i)\n    for (int j = 0; j < (11); ++j) dp[i][j][0] = dp[i][j][1] = INF;\n  dp[0][0][0] = 0;\n  for (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= k; ++j) {\n      for (int u = 0; u < 10; ++u) {\n        if (i == 1 && u == 0) continue;\n        if (f(u, dp[i - 1][j][1]) && dp[i - 1][j][1] < INF)\n          amin(dp[i][j][1], dp[i - 1][j][1] * 10 + u);\n        if (f(u, dp[i - 1][j][0]) && u > v[i] && dp[i - 1][j][0] < INF)\n          amin(dp[i][j][1], dp[i - 1][j][0] * 10 + u);\n        if (f(u, dp[i - 1][j][0]) && u >= v[i] && dp[i - 1][j][0] < INF)\n          amin(dp[i][j][0], dp[i - 1][j][0] * 10 + u);\n        if (dp[i - 1][j - 1][1] < INF)\n          amin(dp[i][j][1], dp[i - 1][j - 1][1] * 10 + u);\n        if (u > v[i] && dp[i - 1][j - 1][0] < INF)\n          amin(dp[i][j][1], dp[i - 1][j - 1][0] * 10 + u);\n        if (u >= v[i] && dp[i - 1][j - 1][0] < INF)\n          amin(dp[i][j][0], dp[i - 1][j - 1][0] * 10 + u);\n      }\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i <= k; ++i) amin(ans, min(dp[m][i][0], dp[m][i][1]));\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int T = 1;\n  cin >> T;\n  for (int i = 1; i <= (T); ++i) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys as _sys\n\n\ndef _main():\n    [tests_n] = _read_ints()\n    for i_test in range(tests_n):\n        [n, k] = _read_ints()\n        result = find_nearest_beautiful_number(lower_bound=n, k_parameter=k)\n        print(result)\n\n\ndef find_nearest_beautiful_number(lower_bound: int, k_parameter: int):\n    prefix = lower_bound\n    while not _is_beautiful(prefix, k_parameter):\n        if prefix % 10 == 0:\n            prefix //= 10  # the dropped digit can be any digit\n        else:\n            prefix += 1\n    \n    zeros_n = len(str(lower_bound)) - len(str(prefix))\n    result = prefix * 10**zeros_n\n    tail = int('1'*zeros_n) if zeros_n else 0\n    while not _is_beautiful(result, k_parameter):\n        result += tail\n    return result\n\n\ndef _is_beautiful(x: int, k_parameter: int):\n    assert x >= 1\n    return len(set(str(x))) <= k_parameter\n\n\ndef _read_ints():\n    return map(int, _sys.stdin.readline().split())\n\n\nif __name__ == '__main__':\n    _main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class CodeForces {\n    static reader input = new reader();\n    static PrintWriter output = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        /*\n        BufferedReader bf = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n        StringTokenizer stk= new StringTokenizer(bf.readLine());;\n        int n=Integer.parseInt(stk.nextToken());\n        */\n        F();\n        output.close();\n    }\n\n    public static void A(){\n\n    }\n\n    public static void B(){\n\n    }\n\n    public static void C(){\n\n    }\n\n    public static void D(){\n\n    }\n\n    public static void E(){\n\n    }\n\n    public static void F(){\n        int t=input.nextInt();\n        for(int i=0;i<t;i++){\n            int n=input.nextInt();\n            int k=input.nextInt();\n            int temp=n,digits=0;\n            ArrayList<Integer>digit=new ArrayList<>();\n            while(temp>0){\n                digit.add(temp%10);\n                temp/=10;\n                digits++;\n            }\n            Collections.reverse(digit);\n            HashSet<Integer>hs=new HashSet<>();\n            output.println(helper(k, 0,0,digits,true,digit,hs));\n        }\n    }\n    public static long helper(int k,long curr,int currlen,int totallen,boolean match,ArrayList<Integer>digit,HashSet<Integer>hs){\n        if(currlen==totallen)\n            return curr;\n        else{\n            int tried=0;\n            int i=currlen==0?1:0;\n            for(;i<10;i++){\n                if(match&&i<digit.get(currlen)||(hs.size()==k&&!hs.contains(i)))\n                    ;\n                else if(tried>=2){\n                    break;\n                }\n                else{\n                    tried++;\n                    boolean check=hs.contains(i);\n                    hs.add(i);\n                    long ans=helper(k,curr*10+i,currlen+1,totallen,match&&i==digit.get(currlen),digit,hs);\n                    if(!check)\n                        hs.remove(i);\n                    if(ans!=-1)\n                        return ans;\n                }\n            }\n            return -1;\n        }\n    }\n\n\n    public static long factorial(int a){\n        long ans=1;\n        for(int i=1;i<=a;i++){\n            ans*=i;\n        }\n        return ans;\n    }\n    public static long LCM(long a,long b){\n        return (a*b)/GCD(a,b);\n    }\n    public static long GCD(long a,long b){\n        if(a==0)\n            return b;\n        else if(b==0)\n            return a;\n        else\n            return GCD(b%a,a);\n    }\n\n    public static boolean isPrime(long num){\n        if(num==1)\n            return false;\n        else if(num==2||num==3)\n            return true;\n        else if(num%2==0||num%3==0)\n            return false;\n        else{\n            for(long i=5;i*i<=num;i+=6){\n                if(num%i==0||num%(i+2)==0)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public static ArrayList<Integer> SieveofEratothenis(){\n        ArrayList<Integer>ans=new ArrayList<>();\n        boolean visited[]=new boolean[1000000];\n        for(int i=2;i<1000000;i++){\n            if(!visited[i]){\n                ans.add(i);\n                for(long j=(long)i*i;j<1000000;j+=i){\n                    visited[(int)j]=true;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void mergesort(long arr[],int start,int end){//start and end must be indexes\n        if(start<end) {\n            int mid=(start+end)/2;\n            mergesort(arr,start,mid);\n            mergesort(arr, mid+1, end);\n            merge(arr, start,mid,end);\n        }\n    }\n    public static void merge(long arr[],int start,int mid,int end){\n        int lsize=mid-start+1,rsize=end-mid;\n        long l[]=new long[lsize],r[]=new long[rsize];\n        for(int i=start;i<=mid;i++){\n            l[i-start]=arr[i];\n        }\n        for(int i=mid+1;i<=end;i++){\n            r[i-mid-1]=arr[i];\n        }\n        int i=0,j=0,k=start;\n        while(i<lsize&&j<rsize){\n            if(l[i]<=r[j]){\n                arr[k++]=l[i++];\n            }else{\n                arr[k++]=r[j++];\n            }\n        }\n        while(i<lsize)\n            arr[k++]=l[i++];\n        while(j<rsize)\n            arr[k++]=r[j++];\n    }\n}\n\nclass Value{\n    int ans;\n    Value(int ans)\n    {\n        this.ans=ans;\n    }\n}\n\nclass Triple{\n    int x,y,z;\n    Triple(int x,int y,int z){\n        this.x=x;\n        this.y=y;\n        this.z=z;\n    }\n}\n\nclass Pair{\n    int x, y;\n    Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n    }\n}\n\nclass Op{\n    int op,count;\n    char dir;\n    public Op(int op){\n        this.op=op;\n    }\n}\n\nclass reader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public reader() {\n        br = new BufferedReader(new\n                InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n\n    public int[] nextIntArray(int arraySize) {\n        int array[] = new int[arraySize];\n        for (int i = 0; i < arraySize; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    public long[] nextLongArray(int arraySize) {\n        long array[] = new long[arraySize];\n        for (int i = 0; i < arraySize; i++) {\n            array[i] = nextLong();\n        }\n        return array;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint L, m;\nchar a[1000];\nint pan() {\n  int j, i;\n  set<char> s;\n  for (i = 0; i < L; i++) {\n    s.insert(a[i]);\n  }\n  if (s.size() > m)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  int j, i, w;\n  scanf(\"%d\", &w);\n  while (w--) {\n    scanf(\"%s %d\", a, &m);\n    L = strlen(a);\n    i = 0;\n    while (pan()) {\n      set<char> s;\n      for (i = 0; i < L; i++) {\n        s.insert(a[i]);\n        if (s.size() > m) {\n          while (a[i] == '9') i--;\n          a[i]++;\n          for (j = i + 1; j < L; j++) a[j] = '0';\n          break;\n        }\n      }\n    }\n    printf(\"%s\\n\", a);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\n\n# if has next big, res = next big + min\n# 724533 4\n# 724542\n\n# else move backwards until dic[i] = 0, res = (res[i] + 1) --\n# 177890 2\n# 181111\n\n# 6\n# 2021 3\n# 177890 2\n# 34512 3\n# 724533 4\n# 998244353 1\n# 12345678 10\n\n# k=3\n# expected: '111676111', found: '111681111'\n#  111671119 3\n\n\ndef find_next_big(d, dic):\n    for i in range(d+1, 10):\n        if dic[i] > 0:\n            return i\n    return -1\n\n\ndef find_min(dic):\n    for i in range(0, 10):\n        if dic[i] > 0:\n            return i\n    return -1\n\n\ndef find_cnt(dic):\n    cnt = 0\n    for i in range(0, 10):\n        if dic[i] > 0:\n            cnt += 1\n    return cnt\n\n\ndef solve(n, k):\n    dic = {}\n    for i in range(10):\n        dic[i] = 0\n\n    sn = str(n)\n    ck = 0\n\n    for i in range(len(sn)):\n        d = ord(sn[i]) - ord('0')\n\n        if dic[d] == 0:\n            if ck == k:\n                nb = find_next_big(d, dic)\n                if nb >= 0:\n                    cm = find_min(dic)\n                    res = sn[:i] + str(nb) + (str(cm) * (len(sn) - i - 1))\n                    return res\n                else:\n                    j = i-1\n                    tv = -1\n                    while dic[ord(sn[j]) - ord('0')] != 1:\n                        tv = find_next_big(ord(sn[j]) - ord('0'), dic)\n                        if tv != -1:\n                            break\n\n                        dic[ord(sn[j]) - ord('0')] -= 1\n                        j -= 1\n\n                    pv = ord(sn[j]) - ord('0')\n                    if tv == -1:\n                        tv = pv + 1\n\n                    dic[tv] += 1\n                    dic[pv] -= 1\n\n                    if find_cnt(dic) < k:\n                        res = sn[:j] + str(tv) + ('0' * (len(sn) - j - 1))\n                    else:\n                        cm = find_min(dic)\n                        res = sn[:j] + str(tv) + (str(cm) * (len(sn) - j - 1))\n\n                    return res\n            ck += 1\n\n        dic[d] += 1\n    return sn\n\n\nt = int(stdin.readline())\nfor _ in range(t):\n    n, k = map(int, stdin.readline().split())\n    r = solve(n, k)\n    stdout.write(r + '\\n')\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int S = int(2e5) + 100;\nconst int INF = int(1e9) + 7;\nconst long long MOD = long long(1e9) + 7;\nconst double PI = 3.141592653589793238;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nvoid print(T& v) {\n  for (auto& x : v) cout << x << \" \";\n  cout << endl;\n}\nlong long ans(long long n, int k) {\n  vector<int> dg;\n  long long on = n;\n  while (n) {\n    dg.emplace_back(n % 10);\n    n /= 10;\n  }\n  reverse(dg.begin(), dg.end());\n  int i = 0, seen[10] = {}, cnt = 0;\n  for (; i < (int)(dg).size(); i++) {\n    if (!seen[dg[i]]) {\n      cnt++;\n      seen[dg[i]] = 1;\n    }\n    if (cnt > k) break;\n  }\n  if (cnt <= k) return on;\n  long long m = 0;\n  for (int j = 0; j <= i; j++) m = m * 10 + dg[j];\n  m++;\n  for (int j = (0); j < ((int)(dg).size() - i - 1); ++j) m *= 10;\n  return ans(m, k);\n}\nint t, k;\nlong long n;\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cout << ans(n, k) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Solution {\n    public static boolean validate(int digit, int index, int n, int k, int[] res, Set<Integer> choose) {\n        boolean isOk = false;\n        if (choose.contains(digit) || choose.size() < k) {\n            isOk = true;\n            choose.add(digit);\n        }\n        if (!isOk) {\n            // check if we can replace by the exist one\n            for (int value : choose) {\n                if (value > digit) {\n                    res[index] = value;\n                    return true;\n                }\n            }\n            if (index < k) {\n                res[index] = digit;\n                return true;\n            }\n            return false;\n        }\n        res[index] = digit;\n        return true;\n    }\n\n    public static  boolean validate(int[] res, int len, int k) {\n        Set<Integer> chose = new HashSet<>();\n        for (int i = 0; i <= len; ++i) {\n            chose.add(res[i]);\n        }\n        return chose.size() <= k;\n    }\n\n    // 1771890\n    public static String analyze(int n, int k) {\n        String result = \"\";\n        String s = \"\" + n;\n        Set<Integer> choose = new HashSet<>();\n        int len = s.length();\n        int[] res = new int[len];\n        for (int i = 0; i < len; ++i) {\n            res[i] = s.charAt(i) - '0';\n            if (!validate(res, i, k)) {\n                do {\n                    if (res[i] == 9) {\n                        i--;\n                    }\n                    res[i]++;\n                } while (!validate(res, i, k));\n                // fill the rest by the min value\n                int min = Integer.MAX_VALUE;\n                for (int j = 0; j <= i; ++j) {\n                    if (res[j] < min) {\n                        min = res[j];\n                    }\n                    choose.add(res[j]);\n                }\n                min = choose.size() < k ? 0 : min;\n                for (int j = i+1; j < len; ++j) {\n                    res[j] = min;\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < len; ++i) {\n            result += res[i];\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCase = scanner.nextInt();\n        while (testCase-- > 0) {\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            System.out.println(analyze(n, k));\n        }\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\nt = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split()\n    #n,k = n.lstrip(\"000000000\"), int(k)\n    k = int(k)\n    L = []\n    for s in n:\n        if int(s) not in L: L.append(int(s))\n    if len(L)<=k: print(n)\n    else:\n        L = L[:k]\n        Num = list(map(int,n))\n        ind = Num.index(L[-1])\n        maxL = max(L)\n        bada = False\n        i=0\n        while i<len(n):\n            if bada: Num[i] = 0\n            else:\n                if Num[i]>maxL:\n                    bada = True\n                    while Num[i]+1>maxL and i>ind: i-=1\n                    Num[i]+=1\n                    if(i == ind):\n                        L[-1]+=1\n                        if L[-1] in L[:-1]: L[-1] = 0\n                elif Num[i] not in L:\n                    bada = True\n            i+=1\n            \n        L.sort()\n        Go = dict()\n        ind = 0\n        for i in range(L[-1]+1):\n            while i>L[ind]:ind+=1\n            Go[i] = str(L[ind])\n        \n        minL = str(L[0])\n        bada = False\n        ret = ''\n        for i in range(len(Num)):\n            if bada == True: ret+=minL\n            else:\n                if (Num[i] not in L): \n                    bada = True\n                ret+=Go[Num[i]]\n        print(ret)\n                    \n                \n        \n        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (first++ ? \", \" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001;\nint K;\nvector<int> digs;\nint pre;\nset<int> used;\nint go(int rem, bool match) {\n  if (rem == 0) {\n    return pre;\n  }\n  int p = (int)(digs).size() - rem;\n  int numTried = 0;\n  for (int i = 0; i < (10); i++) {\n    if (match && i < digs[p]) continue;\n    if ((int)(used).size() == K && used.count(i) == 0) {\n      continue;\n    }\n    if (numTried >= 2) continue;\n    numTried++;\n    pre *= 10;\n    pre += i;\n    bool curIn = used.count(i);\n    if (!curIn) used.insert(i);\n    int res = go(rem - 1, match && i == digs[p]);\n    if (!curIn) used.erase(i);\n    pre /= 10;\n    if (res != -1) {\n      return res;\n    }\n  }\n  return -1;\n}\nvoid solve() {\n  int N;\n  cin >> N >> K;\n  digs.clear();\n  while (N) {\n    digs.push_back(N % 10);\n    N /= 10;\n  }\n  reverse(digs.begin(), digs.end());\n  used.clear();\n  pre = 0;\n  int res = go((int)(digs).size(), true);\n  if (res == -1) {\n    cout << 1;\n    for (int i = 0; i < ((int)(digs).size()); i++) cout << 0;\n    cout << nl;\n  } else\n    cout << res << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> get_stacked_value(int n) {\n  vector<int> result;\n  while (n) {\n    result.push_back(n % 10);\n    n /= 10;\n  }\n  reverse(result.begin(), result.end());\n  return result;\n}\nint get_int(vector<int> s) {\n  int res = 0;\n  for (int i : s) {\n    s.pop_back();\n    res *= 10;\n    res += i;\n  }\n  return res;\n}\nbool is_valid(vector<int> &vec, int n, int k) {\n  set<int> s;\n  for (int i : vec) s.insert(i);\n  int val = get_int(vec);\n  return (s.size() <= k) && (val >= n);\n}\nint solve(int n, int k) {\n  vector<int> n_vec = get_stacked_value(n);\n  if (is_valid(n_vec, n, k)) return n;\n  for (int i = n_vec.size() - 1; i >= 0; i--) {\n    for (int add = 1; add + n_vec[i] < 10; add++) {\n      vector<int> tmp_vec;\n      tmp_vec = n_vec;\n      tmp_vec[i] = (tmp_vec[i] + add);\n      for (int j = i + 1; j < n_vec.size(); j++) tmp_vec[j] = 0;\n      set<int> s(tmp_vec.begin(), tmp_vec.begin() + i + 1);\n      if (s.size() > k)\n        continue;\n      else if (s.size() < k)\n        for (int j = i + 1; j < n_vec.size(); j++) tmp_vec[j] = 0;\n      else {\n        int val = 9;\n        for (int j = 0; j <= i; j++) val = min(val, tmp_vec[j]);\n        for (int j = i + 1; j < n_vec.size(); j++) {\n          tmp_vec[j] = val;\n        }\n      }\n      const bool valid = is_valid(tmp_vec, n, k);\n      if (valid) return get_int(tmp_vec);\n    }\n  }\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, k;\n    cin >> n >> k;\n    cout << solve(n, k) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n                      \n            \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n        \nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\n \n \ndef check(st, n, k):\n    for i in range(n-k+1):\n        g = st.query(i, i+k)\n        if(g > 1):\n            return True \n    return False\n \n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom collections import defaultdict,deque\nfrom math import ceil,floor,sqrt,log2,gcd,pi\nfrom heapq import heappush,heappop\nfrom fractions import Fraction\nfrom bisect import bisect_left,bisect,bisect_right\nfrom itertools import combinations_with_replacement,permutations\nimport sys\nabc='abcdefghijklmnopqrstuvwxyz'\nABC=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    arr=[int(i) for i in str(n)]\n    s=set()\n    l=len(arr)\n    pre=0\n    for _ in range(100):\n        pre=0\n        # print(n)\n        arr=[int(i) for i in str(n)]\n        s=set()\n        l=len(arr)\n        le=0\n        for i in arr:\n            if i in s:\n                le+=1\n                pre=pre*10+i\n            elif len(s)<k:\n                s.add(i)\n                le+=1\n                pre=pre*10+i\n            else:\n                pre=pre*10+i\n                pre+=1\n                # print(pre)\n                lp=len(str(pre))\n                pre=pre*(10**(l-lp))\n                n=pre\n                break\n        if le==l:\n            print(pre)\n            break"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\ndef solve():\n    n, k = input().split()\n    k = int(k)\n\n    cnt = Counter(n)\n    if len(cnt) <= k:\n        print(n)\n        return\n    \n    cnt = Counter()\n\n    ans = []\n    for c in n:\n        if c in cnt:\n            cnt[c] += 1\n            ans.append(c)\n            continue\n        if len(cnt) == k: break\n        cnt[c] += 1\n        ans.append(c)\n    \n    i = len(ans)\n    for j in range(int(n[i])+1, 10):\n        if str(j) in cnt:\n            ans.append(str(j))\n            m = min(cnt.keys())\n            while len(ans) < len(n):\n                ans.append(m)\n            print(\"\".join(ans))\n            return\n    \n    while i >= 0:\n        i -= 1\n        c = ans[i]\n        cnt[c] -= 1\n        if cnt[c] == 0:\n            del cnt[c]\n        \n        for nxt in range(int(c)+1, 10):\n            nxt = str(nxt)\n            if nxt not in cnt:\n                if len(cnt) == k: continue\n            cnt[nxt] += 1\n            ans[i] = nxt\n            if len(cnt) < k:\n                cnt[\"0\"] += 1\n            m = min(cnt.keys())\n            for j in range(i+1, len(ans)):\n                ans[j] = m\n            while len(ans) < len(n):\n                ans.append(m)\n            print(\"\".join(ans))\n            return\n    assert 1 < 0\n\n\n\nfor _ in range(int(input()) ):\n    solve()\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n, k = input()[:-1].split()\n    k = int(k)\n    ni = int(n)\n    t = ''\n    ans = 10 ** 18\n    for i in range(len(n)):\n        for j in range(1, 10):\n            c = len(set(t + str(int(n[i]) + j)))\n            if c > k:\n                continue\n            elif c == k:\n                d = ord(min(t + str(int(n[i]) + j))) - ord('0')\n                x = int(t + str(int(n[i]) + j))\n                while(ni > x):\n                    x *= 10\n                    x += d\n                if ans > x:\n                    ans = x\n            else:\n                x = int(t + str(int(n[i]) + j))\n                while(ni > x):\n                    x *= 10\n                if ans > x:\n                    ans = x\n        t += n[i]\n    if len(set(n)) <= k:\n        ans = ni\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nlong long gcd(long long a, long long b) {\n  for (; b; a %= b, swap(a, b))\n    ;\n  return a;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    string n;\n    int k;\n    cin >> n;\n    cin >> k;\n    while (true) {\n      set<char> s;\n      for (int i = 0; i < n.size(); i++) s.insert(n[i]);\n      if (s.size() <= k) {\n        cout << n << \"\\n\";\n        break;\n      }\n      s.clear();\n      int ptr = 0;\n      while (true) {\n        s.insert(n[ptr]);\n        if (s.size() > k) {\n          while (n[ptr] == '9') ptr--;\n          n[ptr]++;\n          for (int i = ptr + 1; i < n.size(); i++) n[i] = '0';\n          break;\n        }\n        ptr++;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Solution {\n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tFastScanner f= new FastScanner(); \n\t\tint ttt=1;\n\t\tttt=f.nextInt();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\touter: for(int tt=0;tt<ttt;tt++) {\n\t\t\tint n=f.nextInt();\n\t\t\tint k=f.nextInt();\n\t\t\tchar[] l=Integer.toString(n).toCharArray();\n\t\t\tHashSet<Character> h=new HashSet<>();\n\t\t\twhile(true) {\n\t\t\t\th.clear();\n\t\t\t\tfor (char c :l) h.add(c);\n\t\t\t\tif (h.size() <= k) {\n\t\t\t\t\tSystem.out.println(l);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\th.clear();\n\t\t\t\tint ptr = 0;\n\t\t\t\tfor (; ; ptr++)\n\t\t\t\t{\t\n//\t\t\t\t\tSystem.out.println(l);\n//\t\t\t\t\tSystem.out.println(ptr);\n\t\t\t\t\th.add(l[ptr]);\n\t\t\t\t\tif (h.size()>k)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (l[ptr]=='9')\n\t\t\t\t\t\t\tptr--;\n\t\t\t\t\t\tl[ptr]++;\n\t\t\t\t\t\tfor (int i=ptr+1;i<l.length;i++)\n\t\t\t\t\t\t\tl[i] = '0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t} \n\tstatic void sort(int[] p) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: p) q.add( i);\n        Collections.sort(q);\n        for (int i = 0; i < p.length; i++) p[i] = q.get(i);\n    }\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int modpwr(long long int x, long long int y, long long int m) {\n  x %= m;\n  if (x == 0) return 0;\n  long long int ans = 1;\n  while (y) {\n    if (y % 2) {\n      ans = (ans * x) % m;\n    }\n    x = (x * x) % m;\n    y = y / 2;\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    string n;\n    int k;\n    cin >> n >> k;\n    while (true) {\n      set<char> s;\n      for (int i = 0; i < n.size(); i++) s.insert(n[i]);\n      if (s.size() <= k) {\n        cout << n << \"\\n\";\n        break;\n      }\n      s.clear();\n      for (int i = 0; i < n.size(); i++) {\n        s.insert(n[i]);\n        if (s.size() > k) {\n          int j = i;\n          while (n[j] == '9') j--;\n          n[j]++;\n          j++;\n          for (; j < n.size(); j++) n[j] = '0';\n          break;\n        }\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint t, n, k, st[30], vis[32];\nint main() {\n  scanf(\"%lld\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &k);\n    st[0] = 0;\n    while (n) st[++st[0]] = n % 10, n /= 10;\n    memset(vis, 0, sizeof(vis));\n    while (1) {\n      int status = 0, num = 0;\n      for (register int i = 1; i <= st[0]; ++i)\n        if (st[i] >= 10) st[i] = 0, st[i + 1]++;\n      for (register int i = st[0]; i >= 1; --i) {\n        num += !(status >> st[i] & 1);\n        status |= 1 << st[i];\n        if (num > k) {\n          ++st[i];\n          for (register int j = 1; j <= i - 1; ++j) st[j] = 0;\n          break;\n        }\n      }\n      if (num <= k) {\n        for (register int i = st[0]; i >= 1; --i) printf(\"%d\", st[i]);\n        puts(\"\");\n        break;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nThu\u1eadt to\u00e1n:\nX\u00e9t s\u1ed1 1789, 1765 v\u1edbi k =2\n-> T\u00e1ch l\u1ea5y ph\u1ea7n c\u00f3 2 ch\u1eef s\u1ed1 kh\u00e1c nhau \u1edf \u0111\u1ea7u ti\u00ean = 17\n1765 c\u00f3 m\u1ecdi s\u1ed1 \u0111\u1eb1ng sau 17 \u0111\u1ec1u nh\u1ecf h\u01a1n max(1,7) -> \u0111i\u1ec1n \u0111\u01b0\u1ee3c lu\u00f4n\n    S\u1ed1 ngay s\u00e1t s\u1ed1 7 s\u1ebd \u0111i\u1ec1n b\u1eb1ng 1 s\u1ed1 l\u1edbn h\u01a1n n\u00f3. 6 -> for i in [1,7] -> t\u00ecm ra 7\n    M\u1ecdi s\u1ed1 sau \u0111\u00f3 \u0111i\u1ec1n b\u1eb3ng min(set(1,7)) = min(1,7) = 1\n    -> ta \u0111\u01b0\u1ee3c 1771\n1789 -> kh\u00f4ng th\u1ec3 \u0111i\u1ec1n 1777 v\u00e0o \u0111\u01b0\u1ee3c.\n-> T\u00ecm s\u1ed1 g\u1ea7n nh\u1ea5t v\u1edbi 17 c\u00f3 2 ch\u1eef s\u1ed1 l\u1edbn h\u01a1n 17. Khi \u0111\u00f3 m\u1ecdi s\u1ed1 sau 7 \u0111\u1ec1u b\u1eb1ng min(set()) nh\u01b0 tr\u00ean\ncho 1 v\u00f2ng for ng\u01b0\u1ee3c t\u1eeb 7 tr\u1edf v\u1ec1 1. C\u1ed9ng s\u1ed1 \u0111ang x\u00e9t v\u1edbi 1.\nV\u00ed d\u1ee5: 17 -> x\u00e9t s\u1ed1 7 ta s\u1ebd c\u00f3 18 19\n            x\u00e9t s\u1ed1 1 ta c\u00f3 2 3 4 (c\u1eaft ph\u1ea7n \u0111u\u00f4i \u0111i)\nKhi th\u1ecfa m\u00e3n s\u1ed1 ch\u1eef s\u1ed1 kh\u00e1c nhau <=k th\u00ec d\u1eebng\nN\u1ebfu s\u1ed1 ch\u1eef s\u1ed1 nh\u1ecf h\u01a1n k th\u00ec m\u1ecdi s\u1ed1 \u0111\u1eb1ng sau \u0111\u1ec1u l\u00e0 0. N\u1ebfu ko s\u1ebd l\u00e0 min(set())\nV\u00ed d\u1ee5:\n717892 2\n-> x = 7178 t\u1ea1i index =3\ns[4] = 9 > max(set(x)) -> ko th\u1ec3 \u0111i\u1ec1n 717888 v\u00e0o \u0111\u01b0\u1ee3c.\nX\u00e9t x = 7178 -> 7179 kh\u00f4ng th\u1ecfa m\u00e3n\nX\u00e9t x = 717 -> 718, 719 kh\u00f4ng th\u1ecfa m\u00e3n\nX\u00e9t x = 71 -> 72 th\u1ecfa m\u00e3n. x \u0111\u00e3 s\u1eed d\u1ee5ng max k=2 -> ta c\u00f3 722222.\nGi\u1ea3 s\u1eed x = 7 -> x m\u1edbi d\u00f9ng 1 s\u1ed1, c\u00f2n d\u01b0 1 -> th\u00eam 0 v\u00e0o. Ta \u0111\u01b0\u1ee3c 700000 \n\"\"\"\ndef find_nearest(s, k):\n    ln = len(s)\n    if max(s[:ln-1]) > s[ln-1]:\n        x = list(set(s[:ln-1]))\n        x.sort()\n        for it in x:\n            if it > s[-1]:\n                s = s[:ln-1] + it\n                return s\n    else:\n        for i in range(ln-1, -1, -1):\n            x = s[:i]\n            while (x[-1] <'9'):\n                x = str(int(x)+1)\n                if len(set(x)) <=k:\n                    if len(set(x)) == k:\n                        x = x + (ln-len(x)) * min(set(x))\n                        return x\n                    else:\n                        x = x + (ln-len(x)) * '0'\n                        return x\n\n        \ndef solve(s, k):\n    if len(set(str(s))) <=k:\n        return s\n    s = str(s)\n    for i in range(len(s)):\n        if len(set(s[:i+1])) > k:\n            break\n    i+=1\n    x = s[:i]\n    x = find_nearest(x, k)\n    ans = x + (len(s)-i) * min(set(x))\n    return ans\n        \n\nn = int(input())\nfor _ in range(n):\n    s, k = [int(i) for i in input().split()]\n    print(solve(s,k))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nbool sortbysec(const pair<long long, long long> &a,\n               const pair<long long, long long> &b) {\n  return (a.second < b.second);\n}\nlong long gcdExtended(long long a, long long b, long long *x, long long *y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = gcdExtended(b % a, a, &x1, &y1);\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n  return gcd;\n}\nbool isSubstring(string s1, string s2) {\n  long long M = s1.length();\n  long long N = s2.length();\n  for (long long i = 0; i <= N - M; i++) {\n    long long j;\n    for (j = 0; j < M; j++)\n      if (s2[i + j] != s1[j]) break;\n    if (j == M) return 1;\n  }\n  return 0;\n}\nlong long gcd(long long a, long long b) {\n  while (b > 0) {\n    long long p = a % b;\n    a = b;\n    b = p;\n  }\n  return a;\n}\nlong long binpow(long long b) {\n  long long m = mod;\n  long long a = 2;\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % m;\n    }\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return res;\n}\nconst long long xx = 1e3 + 5;\nvector<long long> index1(xx + 1), index2(xx + 1), par1(xx + 1), par2(xx + 1);\nlong long find_par(long long a, vector<long long> &par) {\n  if (a == par[a]) return a;\n  return par[a] = find_par(par[a], par);\n}\nvoid make_union(long long a, long long b, vector<long long> &par,\n                vector<long long> &index) {\n  long long p1 = find_par(a, par);\n  long long p2 = find_par(b, par);\n  if (p1 != p2) {\n    long long ma = max(p1, p2);\n    long long mi = p2 + p1 - ma;\n    par[mi] = ma;\n    index[ma]++;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t;\n  cin >> t;\n  long long k, n, m1, m2, q;\n  string a, a1, a2;\n  for (long long i = 0; i < t; i++) {\n    cin >> a >> k;\n    if (k == 1) {\n      bool ch = false;\n      char temp = a[0];\n      long long ke = -1;\n      for (long long j = 0; j < a.length(); j++) {\n        if (a[j] != temp) {\n          ke = j;\n          break;\n        }\n      }\n      if (ke != -1) {\n        if (a[ke] > a[0]) {\n          a[0]++;\n          for (long long j = 0; j < a.length(); j++) {\n            cout << (a[0]);\n          }\n        } else {\n          for (long long j = 0; j < a.length(); j++) {\n            cout << a[0];\n          }\n        }\n        cout << \"\\n\";\n        continue;\n      } else {\n        cout << a << \"\\n\";\n      }\n    }\n    if (k >= 2) {\n      vector<char> v;\n      map<char, long long> m;\n      long long p1 = 0;\n      set<char> s;\n      bool ch = 0;\n      bool det;\n      long long ke = -1;\n      for (long long j = 0; j < a.length(); j++) {\n        s.insert((a[j]));\n        if (p1 != s.size()) {\n          if (ch == 0) {\n            v.push_back((a[j]));\n            sort(v.begin(), v.end());\n            p1++;\n            m[a[j]] = j;\n            if (v.size() == k) {\n              ch = 1;\n            }\n          } else {\n            ke = j;\n            if (a[j] > v[v.size() - 1]) {\n              det = 1;\n              break;\n            } else {\n              det = 0;\n              break;\n            }\n          }\n        }\n      }\n      if (ke == -1) {\n        cout << a << \"\\n\";\n        continue;\n      }\n      string ans = \"\";\n      char mid;\n      if (det == 0) {\n        for (long long j = 0; j < v.size(); j++) {\n          if (v[j] > a[ke]) {\n            mid = v[j];\n            break;\n          }\n        }\n        for (long long j = 0; j < ke; j++) {\n          ans += a[j];\n        }\n        ans += mid;\n        for (long long j = ke + 1; j < a.length(); j++) {\n          ans += v[0];\n        }\n      } else {\n        if (a[ke - 1] != v[v.size() - 1]) {\n          for (long long j = 0; j < v.size(); j++) {\n            if (v[j] > a[ke - 1]) {\n              mid = v[j];\n              break;\n            }\n          }\n          for (long long j = 0; j < ke - 1; j++) {\n            ans += a[j];\n          }\n          ans += mid;\n          for (long long j = ke; j < a.length(); j++) {\n            ans += v[0];\n          }\n          if (m[a[ke - 1]] == ke - 1) {\n            ans = \"\";\n            char ex = a[ke - 1];\n            ex++;\n            for (long long j = 0; j < ke - 1; j++) {\n              ans += a[j];\n            }\n            ans += ex;\n            long long ex1;\n            long long foun = -1;\n            for (long long j = 0; j < v.size(); j++) {\n              if (v[j] == ex) {\n                foun = j;\n                break;\n              }\n            }\n            if (v[0] == a[ke - 1]) {\n              ex1 = ex;\n            } else {\n              ex1 = v[0];\n            }\n            if (ex1 == v[1]) {\n              ex1 = v[0];\n            }\n            if (foun != -1) {\n              ex1 = '0';\n            }\n            for (long long j = ke; j < a.length(); j++) {\n              ans += ex1;\n            }\n          }\n        } else {\n          long long st;\n          for (long long j = ke - 1; j >= 0; j--) {\n            if (a[j] < a[ke - 1]) {\n              st = j;\n              break;\n            }\n          }\n          if (st < m[a[ke - 1]]) {\n            for (long long j = 0; j <= st; j++) {\n              ans += a[j];\n            }\n            char ex = a[ke - 1];\n            ex++;\n            ans += ex;\n            for (long long j = st + 2; j < a.length(); j++) {\n              ans += v[0];\n            }\n          } else {\n            for (long long j = 0; j < v.size(); j++) {\n              if (v[j] > a[st]) {\n                mid = v[j];\n                break;\n              }\n            }\n            for (long long j = 0; j < st; j++) {\n              ans += a[j];\n            }\n            ans += mid;\n            for (long long j = st + 1; j < a.length(); j++) {\n              ans += v[0];\n            }\n            if (m[a[st]] == st) {\n              ans = \"\";\n              char ex = a[st];\n              ex++;\n              char ex1;\n              long long foun = -1;\n              for (long long j = 0; j < v.size(); j++) {\n                if (v[j] == ex) {\n                  foun = j;\n                  break;\n                }\n              }\n              for (long long j = 0; j < st; j++) {\n                ans += a[j];\n              }\n              ans += ex;\n              if (foun == -1) {\n                if (v[0] != a[st]) {\n                  ex1 = min(ex, v[0]);\n                } else {\n                  ex1 = min(ex, v[1]);\n                }\n              } else {\n                ex1 = '0';\n              }\n              for (long long j = st + 1; j < a.length(); j++) {\n                ans += ex1;\n              }\n            }\n          }\n        }\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstring get(long long i, long long n, long long dis, long long k, string org,\n           string cur) {\n  if (dis > k) {\n    return \"\";\n  }\n  if (cur.substr(0, i) < org.substr(0, i)) {\n    return \"\";\n  }\n  if (i >= n) {\n    return cur;\n  }\n  for (char x = '0'; x <= '9'; x += 1) {\n    cur[i] = x;\n    bool check = false;\n    for (long long j = 0; j < i; j++) {\n      if (cur[j] == x) {\n        check = true;\n        break;\n      }\n    }\n    string lol = get(i + 1, n, dis + (!check), k, org, cur);\n    if (lol.size()) {\n      return lol;\n    }\n  }\n  return \"\";\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  string s = to_string(n);\n  string ans = get(0, s.size(), 0, k, s, string(s.size(), '0'));\n  cout << ans << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nvector<int> lim;\ni64 dp[20][1 << 11][2][11];\ni64 solve(int p, int mask, int k, int s, int tight) {\n  if (p < 0) return __builtin_popcount(mask) <= k;\n  i64& res = dp[p][mask][s][k];\n  if (tight && ~res) return res;\n  i64 cnt = 0;\n  for (int i = 0; i <= (tight ? 9 : lim[p]); i++) {\n    if (!s && i == 0) {\n      cnt += solve(p - 1, 0, k, 0, 1);\n    }\n    if (!s && i == 0) continue;\n    int nxt_mask = mask | (1 << i);\n    cnt += solve(p - 1, nxt_mask, k, 1, tight | (i < lim[p]));\n  }\n  return (tight ? res = cnt : cnt);\n}\ni64 getSolve(i64 n, int k) {\n  lim.clear();\n  while (n) {\n    lim.emplace_back(n % 10);\n    n /= 10;\n  }\n  return solve((int)lim.size() - 1, 0, k, 0, 0);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  memset(dp, -1, sizeof(dp));\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    if (getSolve(n, k) - getSolve(n - 1, k) >= 1) {\n      cout << n << '\\n';\n      continue;\n    }\n    i64 def = getSolve(n, k);\n    i64 lo = n + 1, hi = 1e18;\n    while (lo < hi) {\n      const i64 mid = lo + (hi - lo) / 2;\n      if (getSolve(mid, k) > def)\n        hi = mid;\n      else\n        lo = mid + 1;\n    }\n    cout << hi << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def _measure_k(x):\n    return len(set(str(x)))\n\n\ntests_n = int(input())\nfor i_test in range(tests_n):\n    n, k = map(int, input().split())\n    \n    prefix = n\n    while _measure_k(prefix) > k:\n        if prefix % 10 == 0:\n            prefix //= 10  # the dropped digit can be any digit\n        else:\n            prefix += 1\n    prefix = str(prefix)\n    \n    tail_digit = '0' if _measure_k(prefix) < k else min(prefix)\n    tail = tail_digit * (len(str(n)) - len(prefix))\n    \n    print(prefix + tail)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class cf {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<TreeSet<Integer>>[] arr = new ArrayList[11];\n\t\tfor (int i = 1; i < 11; i++) {\n\t\t\tgen = new ArrayList<TreeSet<Integer>>();\n\t\t\tgen(new TreeSet<>(), i);\n\t\t\tarr[i] = gen;\n\t\t}\n\t\tHashMap<pair, Long> hm = new HashMap<>();\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint z = sc.nextInt();\n\t\t\tchar[] n = (z + \"\").toCharArray();\n\t\t\tint k = sc.nextInt();\n\t\t\tif (hm.containsKey(new pair(z, k))) {\n\t\t\t\tpw.println(hm.get(new pair(z, k)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong min = Integer.MAX_VALUE;\n\t\t\tint[] a = new int[n.length];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = n[i] - '0';\n\t\t\t}\n\t\t\tfor (TreeSet<Integer> ts : arr[k]) {\n\t\t\t\tmin = Math.min(min, min(a, 0, false, ts));\n\t\t\t}\n\t\t\thm.put(new pair(z, k), min);\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic long pow(long a, long e) {\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1)\n\t\t\t\tres *= a;\n\t\t\ta *= a;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long min(int[] n, int i, boolean f, TreeSet<Integer> ts) {\n\t\tif (i == n.length) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (f) {\n\t\t\treturn min(n, i + 1, true, ts) + pow(10, n.length - i - 1) * ts.first();\n\t\t} else {\n\t\t\tif (ts.ceiling(n[i]) == null) {\n\t\t\t\treturn (int) 2e9;\n\t\t\t}\n\t\t\tint a = ts.ceiling(n[i]);\n\t\t\tif (a == n[i]) {\n\t\t\t\tif (ts.ceiling(a + 1) == null) {\n\t\t\t\t\treturn min(n, i + 1, false, ts) + pow(10, n.length - i - 1) * a;\n\t\t\t\t} else {\n\t\t\t\t\treturn Math.min(min(n, i + 1, true, ts) + pow(10, n.length - i - 1) * ts.ceiling(a + 1),\n\t\t\t\t\t\t\tmin(n, i + 1, false, ts) + pow(10, n.length - i - 1) * a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn min(n, i + 1, true, ts) + pow(10, n.length - i - 1) * a;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic ArrayList<TreeSet<Integer>> gen;\n\n\tstatic void gen(TreeSet<Integer> ts, int n) {\n\t\tif (ts.size() == n) {\n\t\t\tgen.add(ts);\n\t\t\treturn;\n\t\t}\n\t\tint start;\n\t\tif (ts.isEmpty())\n\t\t\tstart = 0;\n\t\telse\n\t\t\tstart = ts.last() + 1;\n\t\tfor (int i = start; i < 10; i++) {\n\t\t\tTreeSet<Integer> ts2 = (TreeSet<Integer>) ts.clone();\n\t\t\tts2.add(i);\n\t\t\tgen(ts2, n);\n\t\t}\n\t}\n\n\tpublic static class tuble implements Comparable<tuble> {\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\n\t\tpublic tuble(int x, int y, int z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + z;\n\t\t}\n\n\t\tpublic int compareTo(tuble other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\tif (this.y == other.y)\n\t\t\t\t\treturn this.z - other.z;\n\t\t\t\treturn this.y - other.y;\n\t\t\t} else {\n\t\t\t\treturn this.x - other.x;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class pair implements Comparable<pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof pair) {\n\t\t\t\tpair p = (pair) o;\n\t\t\t\treturn p.x == x && p.y == y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn new Integer(x).hashCode() * 31 + new Integer(y).hashCode();\n\t\t}\n\n\t\tpublic int compareTo(pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(this.y, other.y);\n\t\t\t}\n\t\t\treturn Long.compare(this.x, other.x);\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\n#py import math\n\ninput = sys.stdin.readline\n\n# L\u00e4ser in ett heltal \n# n = int(input())\n\n# 3 4 5\n# L\u00e4ser in tre heltal\n# x,y,z = map(int,input().split())\n\n# L\u00e4ser in en lista av heltal (om man inte vet hur m\u00e5nga)\n# a = list(map(int,input().split()))\n\n\n# Vanlig start (f\u00f6rsta raden \u00e4r antal test)\ntests = int(input())\nfor test in range(tests):\n    tInt, k = map(int,input().split())\n    t = [int(x) for x in str(tInt)]\n    \n    foundInts = 0\n    ints = []\n    firstOccurence = {}\n\n    pos = 0\n    \n    while pos < len(t):\n        char = t[pos]\n        #print(char)\n        if char not in ints:\n            if foundInts < k:\n                ints.append(char)\n                ints.sort()\n                firstOccurence[char] = pos\n                foundInts += 1\n            else:\n                break\n        pos += 1\n\n    if pos == len(t):\n        print(''.join(str(x) for x in t))\n        #print (\"\".join(str(t)))\n    else:\n        fixed = False\n        #print (\"slut p\u00e5 k\")\n        largerThanPos = list(filter(lambda val: val > t[pos],ints))\n        #print (largerThanPos)\n        if largerThanPos:\n            #print (\"Kan byta \" + str(char) + \" mot \" + str(largerThanPos[0]))\n            t[pos] = largerThanPos[0]\n            fixed = True\n        \n        while not fixed:\n            pos -= 1\n            #print(firstOccurence)\n            #print(\"pos: \" + str(pos))\n            largerThanPos = list(filter(lambda val: val > t[pos],ints))\n            #print (largerThanPos)\n            if firstOccurence[t[pos]] == pos:\n                #print(\"pos: \" + str(pos))\n                ints.remove(t[pos])\n                if (t[pos]+1) in ints:\n                    ints.append(0)\n                    #print (ints)\n                else:\n                    ints.append(t[pos]+1)\n                    #print (ints)\n                t[pos] = t[pos] + 1\n                fixed = True\n            elif largerThanPos:\n                #print (\"Kan byta \" + str(t[pos]) + \" mot \" + str(largerThanPos[0]))\n                t[pos] = largerThanPos[0]\n                fixed = True\n            \n\n        ints.sort()\n        pos+=1\n        while pos < len(t):\n            t[pos] = ints[0]\n            pos+=1\n            \n        print(''.join(str(x) for x in t))\n\n      \n                "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2e5 + 100;\nusing namespace std;\nclock_t startTime;\ndouble getCurrentTime() {\n  return (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\ntemplate <typename T>\nvoid print(const T &t) {\n  cout << t << '\\n';\n}\ntemplate <typename T, typename... F>\nvoid print(const T &t, const F &...f) {\n  cout << t << \" \";\n  print(f...);\n}\ntemplate <typename T>\nvoid input_array(vector<T> &arr) {\n  for (int i = 0; i < arr.size(); i++) {\n    cin >> arr[i];\n  }\n}\ntemplate <typename T>\nvoid print_array(const T &arr, char c = ' ') {\n  for (auto x : arr) {\n    cout << x << c;\n  }\n  cout << '\\n';\n}\nvoid file_i_o() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nbool func(string num, int k) {\n  set<char> s;\n  for (int i = 0; i < num.length(); i++) {\n    s.insert(num[i]);\n  }\n  if (s.size() <= k) {\n    return false;\n  } else {\n    return true;\n  }\n}\nint main() {\n  file_i_o();\n  startTime = clock();\n  int t;\n  cin >> t;\n  while (t--) {\n    string n;\n    int k;\n    cin >> n >> k;\n    while (true) {\n      set<char> s;\n      for (auto c : n) s.insert(c);\n      if (s.size() <= k) break;\n      s.clear();\n      int ptr = 0;\n      for (;; ptr++) {\n        s.insert(n[ptr]);\n        if (s.size() > k) {\n          while (n[ptr] == '9') ptr--;\n          n[ptr]++;\n          for (int i = ptr + 1; i < n.size(); i++) n[i] = '0';\n          break;\n        }\n      }\n    }\n    cout << n << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef solve():\n    n,k = map(int,input().split())\n\n    x = n\n    m = len(str(x))\n    while len(set(str(x))) > k:\n        if x%10 == 0:\n            x //= 10\n        else:\n            x += 1\n\n    suff = \"0\" if len(set(str(x))) < k else min(set(str(x)))\n    ans = str(x) + suff*(m - len(str(x)))\n    print(ans)\n\nfor nt in range(int(input())):\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\nint T, n, k, a, b, c;\nchar care[100];\nchar str[100];\nint dif(char* str) {\n  int is = 0;\n  int n = strlen(str);\n  int ans = 0;\n  int bulk[10];\n  for (int i = 0; i < 10; i++) {\n    bulk[i] = 0;\n  }\n  for (is; is < n; is++) {\n    if (bulk[str[is] - '0'] == 0) ans++;\n    bulk[str[is] - '0']++;\n  }\n  return ans;\n}\nbool hasbig(int* a, char b) {\n  for (int i = b + 1; i < 10; i++) {\n    if (a[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nchar nextbig(int* a, char b) {\n  for (int i = b + 1; i < 10; i++) {\n    if (a[i]) {\n      return i;\n    }\n  }\n  return 10;\n}\nchar least(int* a) {\n  for (int i = 0; i < 10; i++) {\n    if (a[i]) {\n      return i;\n    }\n  }\n  return 10;\n}\nbool full(char* a, char* b, int k) {\n  int is = 0;\n  int n = strlen(a);\n  b[n] = '\\0';\n  int bulk[10];\n  for (int i = 0; i < 10; i++) {\n    bulk[i] = 0;\n  }\n  int omit = 0;\n  for (is; is < n; is++) {\n    b[is] = a[is];\n    if (bulk[a[is] - '0'] == 0) omit++;\n    bulk[a[is] - '0']++;\n    if (omit == k) break;\n  }\n  for (is; is < n; is++) {\n    if (bulk[a[is] - '0']) {\n      b[is] = a[is];\n    } else {\n      break;\n    }\n  }\n  if (is == n) {\n    return true;\n  }\n  if (hasbig(bulk, a[is] - '0')) {\n    b[is] = nextbig(bulk, a[is] - '0') + '0';\n    for (int i = is + 1; i < n; i++) {\n      b[i] = least(bulk) + '0';\n    }\n  } else {\n    return false;\n  }\n}\nvoid take(char* a, char* b, int c) {\n  int is = 0;\n  int n = strlen(a);\n  b[n] = '\\0';\n  int bulk[10];\n  for (int i = 0; i < 10; i++) {\n    bulk[i] = 0;\n  }\n  int omit = 0;\n  for (is; is < n; is++) {\n    b[is] = a[is];\n    if (bulk[a[is] - '0'] == 0) omit++;\n    bulk[a[is] - '0']++;\n    if (omit == k + 1) break;\n  }\n  bulk[b[is] - '0'] = 0;\n  is--;\n  while (bulk[b[is] - '0'] != 1) {\n    if (hasbig(bulk, b[is] - '0')) {\n      b[is] = nextbig(bulk, b[is] - '0') + '0';\n      for (is++; is < n; is++) {\n        b[is] = least(bulk) + '0';\n      }\n      return;\n    } else {\n      bulk[b[is] - '0']--;\n      is--;\n    }\n  }\n  if (b[is] == '9') {\n    if (bulk[b[is - 1] - '0'] == 1) {\n      bulk[b[is - 1] - '0']--;\n      b[is - 1]++;\n      bulk[b[is - 1] - '0']++;\n      for (is; is < n; is++) {\n        b[is] = '0';\n      }\n      return;\n    } else {\n      bulk[b[is - 1] - '0']--;\n      b[is - 1]++;\n      bulk[b[is - 1] - '0']++;\n      for (is; is < n; is++) {\n        b[is] = least(bulk) + '0';\n      }\n      return;\n    }\n  } else {\n    bulk[b[is] - '0']--;\n    b[is]++;\n    bulk[b[is] - '0']++;\n    if (bulk[b[is] - '0'] == 1) {\n      for (is++; is < n; is++) {\n        b[is] = least(bulk) + '0';\n      }\n    } else {\n      for (is++; is < n; is++) {\n        b[is] = '0';\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &k);\n    sprintf(care, \"%d\", n);\n    a = dif(care);\n    if (a <= k) {\n      printf(\"%d\\n\", n);\n      continue;\n    }\n    if (full(care, str, k)) {\n      printf(\"%s\\n\", str);\n      continue;\n    } else {\n      take(care, str, k);\n      printf(\"%s\\n\", str);\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n  n,k=input().split()\n  k=int(k)\n  m=len(n)\n  d={}\n  i=0\n  for i in range(m):\n    if n[i] not in d:\n      if len(d)==k:\n        break\n      d[n[i]]=0\n    d[n[i]]+=1\n  else:\n    print(n)\n    continue\n  n=list(n)\n  while True:\n    if n[i]==\"9\" or len(d)==k and max(d)<=n[i]:\n      i-=1\n      d[n[i]]-=1\n      if d[n[i]]==0:\n        del d[n[i]]\n    else:\n      if len(d)<k:\n        n[i]=str(int(n[i])+1)\n        if n[i] not in d:\n          d[n[i]]=0\n        d[n[i]]+=1\n        p=\"0\" if len(d)<k else min(d)\n        for i in range(i+1,m):\n          n[i]=p\n      else:\n        n[i]=min(j for j in d if j>n[i])\n        for i in range(i+1,m):\n          n[i]=min(d)\n      break\n  print(\"\".join(n))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  while (1) {\n    set<char> s;\n    for (auto c : n) s.insert(c);\n    if (s.size() <= k) return n;\n    s.clear();\n    for (int ptr = 0;; ptr++) {\n      s.insert(n[ptr]);\n      if (s.size() > k) {\n        while (n[ptr] == '9') {\n          ptr--;\n        }\n        n[ptr]++;\n        for (int i = ptr + 1; i < n.size(); i++) {\n          n[i] = '0';\n        }\n        break;\n      }\n    }\n  }\n}\nint main() {\n  cin.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  int T;\n  cin >> T;\n  while (T--) {\n    cout << solve() << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nraw_input = lambda: stdin.readline().rstrip()\ninput = lambda: int(raw_input())\nI=lambda: map(int, raw_input().split())\nt = input()\nfor _ in xrange(t):\n\tn,k = I()\n\tq = [int(x) for x in str(n)]\n\tl = len(q)\n\tk1 = k\n\twLst = []\n\ts = set()\n\tj = -1\n\tfor i in xrange(l):\n\t\tx = q[i]\n\t\tif x not in s:\n\t\t\tif k1==0:\n\t\t\t\tj = i\n\t\t\t\txJ = x\n\t\t\t\tbreak\n\t\t\ts.add(x)\n\t\t\twLst.append(x)\n\t\t\tk1 -= 1\n\tif j==-1:\n\t\tprint n\n\t\tcontinue\n\twLst.sort()\n\tmW = wLst[0]\n\tMW = wLst[-1]\n\tif k==1:\n\t\tif q[0]>xJ:\n\t\t\tr = str(q[0])*l\n\t\telse:\n\t\t\tr = str(q[0]+1)*l\n\telse:\n\t\tif xJ<MW:\n\t\t\tfor x in wLst:\n\t\t\t\tif x > xJ:\n\t\t\t\t\tbreak\n\t\t\trLst = q[:j] + [x] + [mW]*(l-j-1)\n\t\telse:\n\t\t\tj1 = j-1\n\t\t\txJ1 = q[j1]\n\t\t\tif xJ1!=MW:\n\t\t\t\tfor i in xrange(l):\n\t\t\t\t\tif q[i]==xJ1:\n\t\t\t\t\t\tleftJ = i\n\t\t\t\t\t\tbreak\n\t\t\t\tif leftJ==j1:\n\t\t\t\t\tif xJ1==mW:\n\t\t\t\t\t\tmW += 1\n\t\t\t\t\tif xJ1+1 in wLst:\n\t\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [0]*(l-j1-1)\n\t\t\t\t\telse:\n\t\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [mW]*(l-j1-1)\n\t\t\t\telse:\n\t\t\t\t\tfor x in wLst:\n\t\t\t\t\t\tif x > xJ1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\trLst = q[:j1] + [x] + [mW]*(l-j1-1)\n\t\t\telse:\n\t\t\t\tfor i in xrange(l):\n\t\t\t\t\tif q[i]==xJ1:\n\t\t\t\t\t\tleftJ = i\n\t\t\t\t\t\tbreak\n\t\t\t\tif leftJ==j1 and xJ1<9:\n\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [mW]*(l-j1-1)\n\t\t\t\telse:\n\t\t\t\t\twhile q[j1] == MW:\n\t\t\t\t\t\tj1 -= 1\n\t\t\t\t\tj1 += 1\n\t\t\t\t\txJ1 = q[j1]\n\t\t\t\t\tfor i in xrange(l):\n\t\t\t\t\t\tif q[i]==xJ1:\n\t\t\t\t\t\t\tleftJ = i\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif leftJ==j1 and xJ1<9:\n\t\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [mW]*(l-j1-1)\n\t\t\t\t\telse:\n\t\t\t\t\t\tj1 -= 1\n\t\t\t\t\t\txJ1 = q[j1]\n\t\t\t\t\t\tfor i in xrange(l):\n\t\t\t\t\t\t\tif q[i]==xJ1:\n\t\t\t\t\t\t\t\tleftJ = i\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tif leftJ==j1:\n\t\t\t\t\t\t\tif xJ1==mW:\n\t\t\t\t\t\t\t\tmW += 1\n\t\t\t\t\t\t\tif xJ1+1 in wLst:\n\t\t\t\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [0]*(l-j1-1)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\trLst = q[:j1] + [xJ1+1] + [mW]*(l-j1-1)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfor x in wLst:\n\t\t\t\t\t\t\t\tif x > xJ1:\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\trLst = q[:j1] + [x] + [mW]*(l-j1-1)\n\t\tr = ''.join([str(x) for x in rLst])\n\tprint r"
        },
        {
            "language": 3,
            "solution": "def find_nearest(s, k):\n    ln = len(s)\n    if max(s[:ln-1]) > s[ln-1]:\n        x = list(set(s[:ln-1]))\n        x.sort()\n        for it in x:\n            if it > s[-1]:\n                # s[-1] = it\n                s = s[:ln-1] + it\n                return s\n    else:\n        # 1778\n        for i in range(ln-1, -1, -1):\n            x = s[:i]\n            while (x[-1] <'9'):\n                x = str(int(x)+1)\n                if len(set(x)) <=k:\n                    if len(set(x)) == k:\n                        x = x + (ln-len(x)) * min(set(x))\n                        return x\n                    else:\n                        x = x + (ln-len(x)) * '0'\n                        return x\n\n        \ndef solve(s, k):\n    if len(set(str(s))) <=k:\n        return s\n    s = str(s)\n    for i in range(len(s)):\n        if len(set(s[:i+1])) > k:\n            break\n    i+=1\n    x = s[:i]\n    # print(x)\n    x = find_nearest(x, k)\n    # print(x)\n    # while len(set(x)) >k:\n    #     x = str(int(x) +1)\n    ans = x + (len(s)-i) * min(set(x))\n    return ans\n    # k = s[:i]\n        \n\nn = int(input())\nfor _ in range(n):\n    s, k = [int(i) for i in input().split()]\n    print(solve(s,k))\n\n\"\"\"\n1\n131455 2 -> 1331\n177890 2 -> 1\n1314 2 -> 1331\n\"\"\""
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\n\ndef solve(n, k):\n    ans = int('9' * 10) - n\n    x = [int(p) for p in str(n)]\n    \n    if len(set(x)) <= k:\n        return n\n\n    if k == 1:\n        for i in '123456789':\n            y = int(i * len(x))\n            if y >= n:\n                ans = min(ans, y - n)\n        return n + ans\n    \n    chosen = [False] * 10\n    i = 0\n    while k != 1:\n        if not chosen[x[i]]:\n            chosen[x[i]] = True\n            k -= 1\n        i += 1\n    \n    unch = [k for k in range(10) if not chosen[k]]\n    chosen = [k for k in range(10) if chosen[k]]\n    for num in unch:\n        digits = sorted(chosen + [num])\n        mx = digits[0]\n        b = [x[0]]\n        for i in range(1, len(x)):\n            b += [x[i]]\n            last=(b[-1] not in digits)\n            if b[-1] > digits[-1]:break\n            if x[i] != digits[-1]:\n                for d in digits:\n                    if d > x[i]:\n                        b[-1] = d\n                        break\n                while len(b) != len(x):b+=[digits[0]]\n                y = int(\"\".join(str(k) for k in b))\n                if y >= n:\n                    ans = min(ans, y - n)\n                while len(b) != i:b.pop()\n                b += [x[i]]\n            if last:break\n    \n    return n + ans\n    \n\nfor _ in range(int(input()) if True else 1):\n    n, k = map(int, input().split())\n    #a, b,c = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    print(solve(n, k))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)(1e9) + 10;\nint n, k;\nint ans;\nstring s;\nvoid update(int pos, int mask, int num) {\n  if (pos == (int)s.size()) {\n    ans = num;\n    return;\n  }\n  if (__builtin_popcount(mask) < k) {\n    for (int i = pos; i < (int)s.size(); i++) num *= 10;\n    ans = num;\n    return;\n  }\n  if (__builtin_popcount(mask) == k) {\n    for (int d = 0; d < 10; d++) {\n      if (((1 << d) | mask) == mask) {\n        for (int i = pos; i < (int)s.size(); i++) num = num * 10 + d;\n        ans = num;\n        return;\n      };\n    }\n  };\n  return;\n}\nbool go(int pos, bool upper, int mask, int num) {\n  if ((pos == (int)s.size()) || upper) {\n    update(pos, mask, num);\n    return true;\n  }\n  int low_d = (upper) ? 0 : s[pos] - '0';\n  for (int d = low_d; d < 10; d++) {\n    int new_mask = mask | (1 << d);\n    if (__builtin_popcount(new_mask) <= k) {\n      if (go(pos + 1, upper || (d > s[pos] - '0'), new_mask, num * 10 + d))\n        return true;\n    }\n  }\n  return false;\n};\nvoid solve() {\n  cin >> n >> k;\n  s = to_string(n);\n  ans = 0;\n  go(0, 0, 0, 0);\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int T = 1;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t, k, n, ans[21], cnt[21];\nstring s;\nbool dfs(long long now, long long val, bool tag) {\n  if (val > k) return 0;\n  if (now == n && val <= k) {\n    for (register long long i = 0; i < n; ++i) cout << ans[i];\n    cout << endl;\n    return 1;\n  }\n  for (register long long i = tag ? s[now] - '0' : 0; i <= 9; ++i) {\n    ++cnt[i];\n    ans[now] = i;\n    if (cnt[i] == 1) {\n      if (dfs(now + 1, val + 1, tag && i == s[now] - '0')) return 1;\n    } else if (dfs(now + 1, val, tag && i == s[now] - '0'))\n      return 1;\n    --cnt[i];\n  }\n  return 0;\n}\nsigned main() {\n  cin >> t;\n  while (t--) {\n    for (register long long i = 0; i <= 10; ++i) cnt[i] = 0;\n    for (register long long i = 0; i <= 10; ++i) ans[i] = 0;\n    cin >> s >> k;\n    n = s.length();\n    if (!dfs(0, 0, 1)) {\n      cout << 10;\n      for (register long long i = 2; i < k; ++i) cout << i;\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter,deque,defaultdict\nfrom functools import lru_cache,reduce\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\ndef _heappush_max(heap,item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap)-1)\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        item, heap[0] = heap[0], item\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import degrees, gcd as GCD\nread=sys.stdin.read\nreadline=sys.stdin.readline\nreadlines=sys.stdin.readlines\n \nT=int(readline())\nfor _ in range(T):\n    N,K=map(int,readline().split())\n    S=str(N)\n    l=len(S)\n    ans=\"\"\n    se=set()\n    m=-1\n    for digit in range(l):\n        for i in range(0,10):\n            if digit==0 and i==0:\n                continue\n            if int(S[:digit+1])>int(ans+str(i)):\n                continue\n            if len(se)+(not i in se)<K:\n                ans+=str(i)\n                se.add(i)\n                m=max(m,i)\n                break\n            elif len(se)+(not i in se)>K:\n                continue\n            else:\n                if N<=int(ans+str(i)+str(max(m,i))*(l-digit-1)):\n                    ans+=str(i)\n                    se.add(i)\n                    m=max(m,i)\n                    break\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t, n, k, k_c, i, left_max, smallest_uniq;\n  vector<int> v, uniq;\n  cin >> t;\n  while (t) {\n    cin >> n >> k;\n    k_c = k;\n    v.clear();\n    uniq.clear();\n    while (n > 0) {\n      v.push_back(n % 10);\n      n = n / 10;\n    }\n    i = v.size() - 1;\n    for (; - 1 < i && k > 0; i--) {\n      if (find(uniq.begin(), uniq.end(), v[i]) == uniq.end()) {\n        uniq.push_back(v[i]);\n        k -= 1;\n      }\n    }\n    if (i > -1) {\n      left_max = *max_element(v.begin(), v.begin() + i);\n      smallest_uniq = *min_element(uniq.begin(), uniq.end());\n    }\n    int smallest_high = 10, flag = 0, target;\n    while (i > -1) {\n      if (flag)\n        v[i] = smallest_uniq;\n      else if (find(uniq.begin(), uniq.end(), v[i]) == uniq.end()) {\n        for (int j = 0; j < uniq.size(); j++) {\n          if (v[i] < uniq[j] && uniq[j] < smallest_high) {\n            smallest_high = uniq[j];\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          target = v[i + 1];\n          if (find(uniq.begin(), uniq.end(), target + 1) != uniq.end()) {\n            i += 1;\n            v[i] += 1;\n            if (find(v.begin() + i, v.end(), target) == v.end())\n              smallest_uniq = 0;\n          } else {\n            k = k_c + 1;\n            for (int j = i + 1; k > k_c; j += 1) {\n              k = k_c + 1;\n              while (v[j] < 10 && k > k_c) {\n                v[j] += 1;\n                uniq.clear();\n                k = 0;\n                for (int z = j; z < v.size(); z++)\n                  if (find(uniq.begin(), uniq.end(), v[z]) == uniq.end()) {\n                    uniq.push_back(v[z]);\n                    k += 1;\n                  }\n                smallest_uniq = *min_element(uniq.begin(), uniq.end());\n                if (k < k_c) smallest_uniq = 0;\n              }\n              i = j;\n            }\n          }\n          flag = 1;\n        } else\n          v[i] = smallest_high;\n      }\n      i -= 1;\n    }\n    for (i = v.size() - 1; - 1 < i; i--) cout << v[i];\n    cout << endl;\n    t--;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Some of the methods are copied from GeeksforGeeks Website  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.util.stream.Collectors;\n\npublic class Main\n{ \n  //static Scanner sc=new Scanner(System.in)\n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  \n  static long mod = (long)(1e9)+ 7;\n  static int max_num=(int)1e5+5;\n  \n  static long n,k;\n  static long max=(long)1e9;\n  static ArrayList<Long> al1=new ArrayList<>();\n  static ArrayList<Long> al2=new ArrayList<>();\n  \n  static void precompute()\n   {\n      for(long i=0;i<=9;i++)\n       {\n          if(i!=0)\n           generate1(i,0,0);\n          for(long j=i+1;j<=9;j++)\n            {\n               generate2(i,j,0,0);\n            }\n       }\n   }\n  \n  static void generate1(long i,long cur,long cnt)\n  {\n     if(cnt>11) return ;\n     \n     long num=10l*cur+i;\n    \n     al1.add(num);\n     generate1(i,num,cnt+1);\n  }\n  \n static void generate2(long i,long j,long cur,long cnt)\n  {\n     if(cnt>11) return;\n     \n     long num1=10l*cur+i;\n     long num2=10l*cur+j;\n     \n     al2.add(num1);\n     al2.add(num2);\n     \n     generate2(i,j,num1,cnt+1);\n     generate2(i,j,num2,cnt+1);\n  }\n  \n  static String solve(int i,int dis,char now[],String ori)\n   {\n      //Base cases\n      if(dis>k) return \"\";\n      if(new String(now).substring(0,i).compareTo(ori.substring(0,i))<0) return \"\";\n      if(i>=ori.length()) return new String(now);\n   \n     for(char val = '0'; val <= '9'; val++)\n     {\n        now[i]=val;\n        boolean found = false;\n        for (int j = 0; j < i; ++j) \n        {\n            if (now[j] == val) \n            {\n                found = true;\n                break;\n            }\n        }\n        String temp = solve(i + 1,dis + (found == false ? 1 : 0), now,ori);\n        if (temp.length()!=0) \n            return temp;\n    }\n    \n    return \"\";\n   }\n public static void main (String[] args) throws java.lang.Exception\n   {\n\ttry{\n\t    /*\n\t        int n=sc.nextInt();\n\t        Collections.sort(al,Collections.reverseOrder());\n\t     \n\t        long n=sc.nextLong();\n\t        String s=sc.next();\n\t        StringBuilder sb=new StringBuilder();\n\t     */\n\t     precompute();\n\t     \n\t     //Removing duplicates from lists\n\t     List<Long> all1 = al1.stream().distinct().collect(Collectors.toList());\n\t     List<Long> all2 = al2.stream().distinct().collect(Collectors.toList());\n\t     \n\t     Collections.sort(all1);\n\t     Collections.sort(all2);\n\t     //out.println(al2.size()+\" \"+al1.size()+\" \"+(al1.size()+al2.size()));\n\t     //out.println(all2.size()+\" \"+all1.size()+\" \"+(all1.size()+all2.size())); -> 330832 108 330940 (3e5 type)\n\t     \n\t\t  int t = sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       n=sc.nextInt();\n\t\t       k=sc.nextInt();\n\t\t       \n\t\t       /*\n\t\t       It's brute force : generate all 1,2 wala numbers and check which is the ans : AC for only F1\n\t\t       long ans=0;\n\t\t       if(k==1)\n\t\t        {\n\t\t           ans=all1.get(LowerBound(all1,n));\n\t\t        }\n\t\t       else\n\t\t        {\n\t\t           ans=all2.get(LowerBound(all2,n));\n\t\t        }\n\t\t       out.println(ans);\n\t\t      */\n\t\t      \n\t\t      //Efficient one : Recursive : AC for F1 AND F2 BOTH\n\t\t      String str=Long.toString(n);\n\t\t      char now[]=new char[str.length()]; Arrays.fill(now,'0');\n\t\t      String res=solve(0,0,now,str);\n\t\t      out.println(res);\n\t\t     \n\t\t    }\n\t     out.flush();\n\t     out.close();\n\t   }     \n\tcatch(Exception e)\n\t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   */\n   \n//  static class Pair\n//    {\n//       int x,y;\n//       Pair(int x,int y)\n//        {\n//           this.x=x;\n//           this.y=y;\n//        }\n//    }\n\n//  Arrays.sort(p, new Comparator<Pair>()\n//     {\n//        @Override\n//        public int compare(Pair o1,Pair o2)\n//        {\n//           if(o1.x>o2.x) return 1;\n//           else if(o1.x==o2.x)\n//             {\n//                if(o1.y>o2.y) return 1;\n//                else return -1;\n//              }\n//           else return -1;\n//       }});\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n  \nstatic int LowerBound(List<Long> a, long x )\n { // x is the target value or key\n  int l=-1,r=a.size();\n  while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a.get(m)>=x) r=m;\n    else l=m;\n  }\n  return r;\n}\n\n static int UpperBound(List<Long> a, long x)\n  {// x is the key or target value\n    int l=-1,r=a.size();\n    while(l+1<r) {\n       int m=(l+r)>>>1;\n       if(a.get(m)<=x) l=m;\n       else r=m;\n    }\n    return l+1;\n }\nstatic void DFS(ArrayList<Integer> graph[],boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<graph[u].size();i++)\n        {\n            v=graph[u].get(i);\n            if(!visited[v])\n               DFS(graph,visited,v);\n        }\n  } \nstatic boolean[] prime(int num)\n {\n\t      boolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n  }\nstatic long nCr(long a,long b,long mod)\n{\n return (((fact[(int)a] * modInverse(fact[(int)b],mod))%mod * modInverse(fact[(int)(a - b)],mod))%mod + mod)%mod;\n}\nstatic long fact[]=new long[max_num];\nstatic void fact_fill()\n {\n   long fact[]=new long[max_num];\n   fact[0]=1l;\n\tfor(int i=1;i<max_num;i++)\n\t  {\n\t    fact[i]=(fact[i-1]*(long)i);\n\t    if(fact[i]>=mod)\n\t      fact[i]%=mod;\n\t  } \n }\nstatic long modInverse(long a, long m)\n\t    {\n\t       return power(a, m - 2, m);\n\t    }\nstatic long power(long x, long y, long m)\n\t    {\n\t        if (y == 0)\n\t            return 1;\n\t        long p = power(x, y / 2, m) % m;\n\t        p = (long)((p * (long)p) % m);\n\t        if (y % 2 == 0)\n\t            return p;\n\t        else\n\t            return (long)((x * (long)p) % m);\n\t    }\nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\nstatic void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n\nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (1 << 30) - 1;\nconst long long LINF = (1LL << 60) - 1;\ntemplate <class T>\nbool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  } else\n    return false;\n}\ntemplate <class T>\nbool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  } else\n    return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    string n;\n    cin >> n;\n    int k;\n    cin >> k;\n    vector<vector<vector<long long> > > ans(\n        n.size() + 1,\n        vector<vector<long long> >(11, vector<long long>(2, LINF)));\n    ans[0][0][0] = 0;\n    for (int i = 0; i < n.size(); i++) {\n      int ni = n[i] - '0';\n      for (int j = 0; j < 11; j++) {\n        for (int k = 0; k < 2; k++) {\n          if (ans[i][j][k] == LINF) continue;\n          set<int> st;\n          long long m = ans[i][j][k];\n          while (m) {\n            st.insert(m % 10);\n            m /= 10;\n          }\n          for (int x = (k ? 0 : ni); x < 10; x++) {\n            chmin(ans[i + 1][j + (st.find(x) == st.end())][k || (x > ni)],\n                  ans[i][j][k] * 10 + x);\n          }\n        }\n      }\n    }\n    long long res = LINF;\n    for (int l = 0; l < k + 1; l++) {\n      for (int j = 0; j < 2; j++) chmin(res, ans[n.size()][l][j]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def solve():\n    n, k = map(int, input().split())\n    s = str(n)\n    se = set()\n    for i in range(len(s)):\n        se.add(s[i])\n    if len(se) <= k:\n        return s\n    se = set()\n    i = 0\n    while True:\n        se.add(s[i])\n        if len(se) > k:\n            break\n        i += 1\n    se.remove(s[i])\n    arr = sorted(se)\n    while True:\n        cur = set(c for c in s[:i])\n        if len(cur) == k:\n            if s[i] >= arr[-1]:\n                i -= 1\n                continue\n            j = 0\n            while arr[j] <= s[i]:\n                j += 1\n            return s[:i] + arr[j] + arr[0]*(len(s)-i-1)\n        c = str(int(s[i])+1)\n        cur.add(c)\n        r = min(cur) if len(cur) == k else \"0\"\n        return s[:i] + c + r*(len(s)-i-1)\n\n\n\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nt = int(input())\nfor i in range(t):\n    print(solve())"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid ioi(string name) {\n  freopen((name + \".in\").c_str(), \"r\", stdin);\n  freopen((name + \".out\").c_str(), \"w\", stdout);\n}\nlong long n, w, k, dp[20][2][1 << 10][2], ans[100005];\nstring s;\nlong long f(long long a = n - 1, long long b = 1, long long c = (1LL << 10) - 1,\n            long long no = 1) {\n  if (__builtin_popcountll(c) < 10 - k) return 0;\n  if (a < 0) return 1;\n  long long &d = dp[a][b][c][no];\n  if (!b && ~d) return d;\n  long long e = s[a] - '0', g = 0;\n  for (long long i = 0; i <= (b ? e : 9); i++) {\n    if (!(no && !i))\n      g += f(a - 1, b && (i == e), (c & ~(1LL << i)), no && !i);\n    else\n      g += f(a - 1, b && (i == e), c, no && !i);\n  }\n  return b ? g : d = g;\n}\nlong long calc(long long x) {\n  s = to_string(x);\n  n = (int)s.size();\n  reverse(s.begin(), s.end());\n  return f();\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cout.precision(30);\n  cerr.precision(10);\n  ;\n  vector<pair<long long, long long>> q[11];\n  long long T;\n  cin >> T;\n  for (int i = 1; i <= T; i++) {\n    cin >> w >> k;\n    q[k].push_back(make_pair(w, i));\n  }\n  for (int K = 1; K <= 10; K++) {\n    memset(dp, -1, sizeof dp);\n    k = K;\n    for (auto x : q[K]) {\n      w = x.first;\n      long long l = w, r = (1LL << 42);\n      w = calc(w - 1);\n      while (l != r) {\n        long long tm = (l + r) / 2;\n        if (w < calc(tm))\n          r = tm;\n        else\n          l = tm + 1;\n      }\n      ans[x.second] = l;\n    }\n  }\n  for (int i = 1; i <= T; i++) cout << ans[i] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1560_F2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader in = new Reader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = in.nextInt();\n\t\twhile(t-- > 0) {\t\n            int n = in.nextInt();\n            String strn = Integer.toString(n);\n            int k = in.nextInt();\n            TreeSet<Long> candidates = new TreeSet<Long>();\n            for(int i = 0; i < strn.length(); i++) {\n                TreeSet<Integer> digits = new TreeSet<Integer>();\n                for(int j = 0; j < i; j++) {\n                    digits.add(Character.getNumericValue(strn.charAt(j)));\n                }\n                int digit = Character.getNumericValue(strn.charAt(i));\n                if(digit == 9) {\n                    continue;\n                }\n                int size = digits.size();\n                if(size > k) {\n                    break;\n                }\n                if(!digits.contains(digit + 1)) {\n                    size++;\n                }\n                if(size > k) {\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    Integer higher = digits.higher(digit);\n                    boolean possible = true;\n                    int ind = i + 1;\n                    while(higher == null) {\n                        if(!digits.contains(digit)) {\n                            possible = false;\n                            break;\n                        }\n                        cur.append(digit);\n                        if(ind >= strn.length()) {\n                            break;\n                        }\n                        digit = Character.getNumericValue(strn.charAt(ind));\n                        higher = digits.higher(digit);\n                        ind++;\n                    }\n                    if(!possible) {\n                        continue;\n                    }\n                    if(higher != null) {\n                        cur.append(higher);\n                        for(int j = ind; j < strn.length(); j++) {\n                            cur.append(digits.first());\n                        }\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }else if(size == k) {\n                    digits.add(digit + 1);\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    cur.append(digit + 1);\n                    for(int j = i + 1; j < strn.length(); j++) {\n                        cur.append(digits.first());\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }else {\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    cur.append(digit + 1);\n                    for(int j = i + 1; j < strn.length(); j++) {\n                        cur.append(0);\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }\n            }\n            TreeSet<Integer> digits = new TreeSet<Integer>();\n            for(int j = 0; j < strn.length(); j++) {\n                digits.add(Character.getNumericValue(strn.charAt(j)));\n            }\n            if(digits.size() <= k) {\n                candidates.add((long)n);\n            }\n            out.println(candidates.first());\n\t\t}\n\t\tin.close();\n\t\tout.close();\n\t}\n\tstatic class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile((c = read()) != -1) {\n\t\t\t\tif(c == '\\n') {\n\t\t\t\t\tif(cnt != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(c == '.') {\n\t\t\t\twhile((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif(bytesRead == -1) {\n\t\t\t\tbuffer[0] = -1;\n\t\t\t}\n\t\t}\n\t\tprivate byte read() throws IOException {\n\t\t\tif(bufferPointer == bytesRead) {\n\t\t\t\tfillBuffer();\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\t\tpublic void close() throws IOException {\n\t\t\tif(din == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdin.close();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    n, k, x, tt = map(int, input().split()*2)\n    while len(set(str(x))) > k: x = x // 10 if not (x % 10) else x + 1\n    print(str(x) + ('0' if len(set(str(x))) < k else min(str(x))) * (len(str(n)) - len(str(x))))\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n\ndef get_digits(n):\n    digits = []\n    while n != 0:\n        digits.append(n % 10)\n        n = n // 10\n\n    return digits[::-1]\n\n\ndef construct(digits):\n    result = 0\n    power = 1\n    for d in digits[::-1]:\n        result += power * d\n        power *= 10\n    return result\n\n\ndef solve(n, k):\n\n    digits = get_digits(n)\n    # print(n, k)\n    # print(digits)\n\n    if len(set(digits)) <= k:\n        return n\n\n    met = [False for _ in range(10)]\n    counter = 0\n    for i, d in enumerate(digits):\n        if met[d] == True:\n            continue\n\n        if counter == k:\n            break\n\n        met[d] = True\n        counter += 1\n\n    # print(met)\n    for t in range(digits[i] + 1, 10):\n        if met[t] == True:\n            answer = (digits[:i] + [t] +\n                      [min(digits[:i])] * (len(digits) - i - 1))\n            return construct(answer)\n\n    prefix = construct(digits[:i])\n    # print(prefix)\n    sub_answer = get_digits(solve(prefix + 1, k))\n    sub_k = len(set(sub_answer))\n    if sub_k < k:\n        filler = 0\n    else:\n        filler = min(sub_answer)\n    answer = sub_answer + [filler] * (len(digits) - len(sub_answer))\n    return construct(answer)\n\n\n# def test():\n#     n = 200\n#     for k in range(1, 7):\n#         k = 2\n#         for i in range(1, n + 1):\n#             x = solve(i, k)\n#             print(i, k, x)\n#             if len(set(get_digits(x))) > k or (x < i):\n#                 print('Ooops')\n#                 print(i, k, x)\n#                 break\n#         break\n\n\ndef main():\n    outputs = []\n    fin = sys.stdin\n    # fin = open('input.txt')\n    N = int(fin.readline())\n    for _ in range(N):\n        n, k = map(int, fin.readline().split())\n        outputs.append(solve(n, k))\n\n    print('\\n'.join(map(str, outputs)))\n\n\nif __name__ == '__main__':\n    main()\n    # test()\n"
        },
        {
            "language": 4,
            "solution": "/*\nstream Butter!\neggyHide eggyVengeance\nI need U\nxiao rerun when\n */\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1560F2\n{\n    static final int INF = Integer.MAX_VALUE-420;\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int N = Integer.parseInt(st.nextToken());\n            int K = Integer.parseInt(st.nextToken());\n            long res = Long.MAX_VALUE;\n            for(int d=1; d <= 9; d++)\n            {\n                long temp = d;\n                while(temp < N)\n                {\n                    temp *= 10;\n                    temp += d;\n                }\n                res = min(res, temp);\n            }\n            if(K == 1)\n            {\n                sb.append(res+\"\\n\");\n                continue;\n            }\n            char[] arr = (N+\"\").toCharArray();\n            int M = arr.length;\n            int mask = 0;\n            //increase a digit\n            for(int add=1; add < 10; add++)\n                for(int head=0; head < M; head++)\n                    if((char)(arr[head]+add) <= '9')\n                    {\n                        mask = 0;\n                        for(int i=0; i < head; i++)\n                            mask |= (1<<(arr[i]-'0'));\n                        char[] temp = new char[M];\n                        for(int i=0; i < head; i++)\n                            temp[i] = arr[i];\n                        temp[head] = (char)(arr[head]+add);\n                        mask |= (1<<(temp[head]-'0'));\n                        if(Integer.bitCount(mask) > K)\n                            continue;\n                        int smallest = -1;\n                        if(Integer.bitCount(mask) < K)\n                            smallest = 0;\n                        else\n                        {\n                            for(int b=0; b < 10; b++)\n                                if((mask&(1<<b)) > 0)\n                                {\n                                    smallest = b;\n                                    break;\n                                }\n                        }\n                        for(int i=head+1; i < M; i++)\n                            temp[i] = (char)(smallest+'0');\n                        long lmao = 0L;\n                        for(char c: temp)\n                        {\n                            lmao *= 10;\n                            lmao += c-'0';\n                        }\n                        res = min(res, lmao);\n                    }\n            int overall = 0;\n            for(char c: arr)\n                overall |= (1<<(c-'0'));\n            if(Integer.bitCount(overall) <= K)\n                res = N;\n            sb.append(res+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}\n/*\n1\n9340400 2\n\n */"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t, n, k, c, r, z;\nbool ok(int n) {\n  z = 0;\n  while (n) {\n    z |= (1 << (n % 10));\n    n /= 10;\n  }\n  return __builtin_popcount(z) <= k;\n}\nvoid solve() {\n  while (!ok(n)) {\n    r = 1;\n    c = n;\n    while (!ok(c)) {\n      c /= 10;\n      r *= 10;\n    }\n    r /= 10;\n    n = (n / r + 1) * r;\n  }\n}\nsigned main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &k);\n    solve();\n    printf(\"%d\\n\", n);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n \ndef solve(n, k, cur, cur_set):\n    # if len(Counter(str(n))) <= k:\n    #     return n\n    if len(cur) > len(str(n)) or len(cur_set) > k or cur < str(n)[: len(cur)]:\n        return None\n    if len(cur) == len(str(n)) and cur >= str(n):\n        return cur\n    \n    for i in range(10):\n        if i not in cur_set:\n            cur_set.add(i)\n            ans = solve(n, k, cur + str(i), cur_set)\n            cur_set ^= {i}\n        else:\n            ans = solve(n, k, cur + str(i), cur_set)\n        if ans != None:\n            return ans\n \nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(solve(n, k, '', set()))"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nfor _ in range (int(input())):\n    n,k = [int(i) for i in input().split()]\n    sn = [int(i) for i in str(n)]\n    s = set()\n    ans = []\n    for i in sn:\n        if i in s:\n            ans.append(i)\n        elif len(s)<k:\n            s.add(i)\n            ans.append(i)\n        else:\n            flag = 0\n            for j in range (1,10):\n                if i+j in s:\n                    ans.append(i+j)\n                    flag = 1\n                    break\n            if flag:\n                ans.extend([min(ans)]*(len(sn)-len(ans)))\n            else:\n                while(len(ans)):\n                    if ans.count(ans[-1])==1:\n                        s.remove(ans[-1])\n                        s.add(ans[-1]+1)\n                        ans.append(ans.pop()+1)\n                        break\n                    else:\n                        flag1 = 0\n                        for j in range (1,10):\n                            if ans[-1]+j in s:\n                                flag1 = ans[-1]+j\n                                break\n                        if flag1:\n                            ans.pop()\n                            ans.append(flag1)\n                            break\n                        else:\n                            ans.pop()\n                if len(s)==k:\n                    ans.extend([min(ans)]*(len(sn)-len(ans)))\n                else:\n                    ans.extend([0]*(len(sn)-len(ans)))\n            break\n    for i in ans:\n        print(i,end=\"\")\n    print()\n"
        },
        {
            "language": 3,
            "solution": "import collections as _collections\nimport itertools as _itertools\nimport sys as _sys\n\n\ndef _main():\n    [tests_n] = _read_ints()\n    for i_test in range(tests_n):\n        [n, k] = _read_ints()\n        result = find_nearest_beautiful_number(lower_bound=n, k_parameter=k)\n        print(result)\n\n\ndef find_nearest_beautiful_number(lower_bound: int, k_parameter: int):\n    # k = 3;\n    # 54648262 -> 54649444\n    # 54649444 -> 54654444\n    # or maybe\n    # 54648262 -> 54649\n    # 54649 -> 5465\n    # or maybe\n    # 54648262 -> 54648263 -> ... -> 5464827 -> ...\n    \n    x = lower_bound\n    while True:\n        while x % 10 == 0:\n            x //= 10\n        if _is_beautiful(x, k_parameter):\n            break\n        else:\n            x += 1\n    \n    zeros_n = 0\n    while x < lower_bound:\n        x *= 10\n        zeros_n += 1\n    if zeros_n > 0:\n        zeros_n -= 1\n        x //= 10\n    \n    for zeros_delta in _itertools.count():\n        curr_x = x * 10**zeros_delta\n        curr_zeros_n = zeros_n + zeros_delta\n        tail = int('1'*curr_zeros_n) if curr_zeros_n else 0\n        for filler_digit in range(10):\n            candidate = curr_x + tail*filler_digit\n            if candidate >= lower_bound and _is_beautiful(candidate, k_parameter):\n                return candidate\n\n\ndef _is_beautiful(x: int, k_parameter: int):\n    assert x >= 1\n    return len(set(str(x))) <= k_parameter\n\n\ndef _read_ints():\n    return map(int, _read_string().split())\n\n\ndef _read_string():\n    result = _sys.stdin.readline()\n    assert result and result[-1] == '\\n'\n    return result[:-1]\n\n\nif __name__ == '__main__':\n    _main()\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: dtype(input().strip())\ninp_d = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp_d(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp_d(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp_d(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nget_bit = lambda x, i: (x >> i) & 1\n\nfor _ in range(inp(int)):\n    n, k = inp_d(int)\n    n1 = str(n)\n    ans, ln = float('inf'), len(n1)\n\n    digs = set()\n    for i in n1:\n        if len(digs) == k - 1:\n            break\n        digs.add(i)\n\n    digs = list(digs)\n    for i in range(10):\n        cur, lst, flag = [], -1, 0\n\n        if str(i) not in digs:\n            digs.append(str(i))\n            flag = 1\n\n        digs.sort()\n\n        for j in n1:\n            for dig in digs[:-1]:\n                if j <= dig:\n                    cur.append(dig)\n                    if j < dig:\n                        cur.extend([digs[0]] * (ln - len(cur)))\n\n                    lst = len(cur) - 1\n                    break\n            else:\n\n                if j <= digs[-1]:\n                    cur.append(digs[-1])\n                    if j < digs[-1]:\n                        cur.extend([digs[0]] * (ln - len(cur)))\n                        break\n\n                elif lst == -1:\n                    cur = ['9'] * 10\n                    break\n                else:\n                    cur = cur[:lst + 1]\n                    for dig in digs:\n                        if cur[lst] < dig:\n                            cur[lst] = dig\n                            break\n\n                    cur.extend([digs[0]] * (ln - len(cur)))\n                    break\n\n            if len(cur) == len(n1):\n                break\n\n        if flag:\n            digs.remove(str(i))\n        ans = min(ans, int(''.join(cur)))\n\n    print(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.beans.VetoableChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\nimport javafx.util.Pair;\n\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.copyOfRange;\nimport static java.util.Arrays.fill;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass Task {\n\n    long ans = Long.MAX_VALUE;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int T = in.nextInt();\n        for (int tc = 1; tc <= T; tc++) {\n            ans = Long.MAX_VALUE;\n            String s = in.next();\n            int k = in.nextInt();\n            cal(s, k, 0, 0, 0, false);\n            cal(\"0\" + s, k, 0, 0, 0, false);\n            out.println(ans);\n        }\n    }\n\n    private void cal(String s, int K, int st, long n, int c, boolean isGreater) {\n        if (Integer.bitCount(st) > K) {\n            return;\n        }\n        if (c == s.length()) {\n            ans = Math.min(ans, n);\n            return;\n        }\n        if (isGreater) {\n            long nn = n;\n            int mn = 0;\n            if (Integer.bitCount(st) == K) {\n                mn = Integer.numberOfTrailingZeros(st);\n            }\n            for (int i = c; i < s.length(); i++) {\n                nn = nn * 10 + mn;\n            }\n            ans = Math.min(ans, nn);\n            return;\n        }\n        int nn = s.charAt(c) - '0';\n        for (int i = nn; i <= 9; i++) {\n            cal(s, K, st | (1 << i), n * 10 + i, c + 1, i > nn ? true : isGreater);\n        }\n    }\n}\n\nclass InputReader {\n\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "# Solution by Pajenegod\n# For learning purposes\n\n\ndef first_bad(A, k):\n    seen = [0] * 10\n    for i, a in enumerate(A):\n        if seen[a] == 0:\n            k -= 1\n            seen[a] = 1\n        if k < 0:\n            return i\n    return -1\n\n\nt = int(input())\nfor _ in range(t):\n    n, k = [int(x) for x in input().split()]\n\n    A = [ord(c) - ord(\"0\") for c in str(n)]\n\n    while True:\n        i = first_bad(A, k)\n        if i == -1:\n            break\n        A[i] += 1\n        while i and A[i] == 10:\n            i -= 1\n            A[i] += 1\n        for j in range(i + 1, len(A)):\n            A[j] = 0\n\n    print(\"\".join(str(x) for x in A))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst double pi = acos(-1.0);\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3fll;\nint dir[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\nlong long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\nvoid wri(long long x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) wri(x / 10);\n  putchar(x % 10 + '0');\n}\nvoid write(long long x) {\n  wri(x);\n  puts(\"\");\n}\nlong long ksc(long long a, long long b, long long mod) {\n  return ((a * b -\n           (long long)((long long)((long double)a / mod * b + 1e-3) * mod)) %\n              mod +\n          mod) %\n         mod;\n}\nlong long ksm1(long long a, long long n, long long mod) {\n  long long t = 1;\n  for (; n; n >>= 1, (a *= a) %= mod)\n    if (n & 1) (t *= a) %= mod;\n  return t;\n}\nlong long ksm2(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = ksc(res, a, mod);\n    b >>= 1, a = ksc(a, a, mod);\n  }\n  return res % mod;\n}\nint is2pow(long long x) { return x > 0 ? (x & (x - 1)) == 0 : 0; }\nlong long myrand(long long l, long long r) {\n  long long num = ((long long)rand() << 30) | ((long long)rand());\n  return num % (r + 1 - l) + l;\n}\nconst long long N = 15;\nlong long cnt[N];\nlong long last[N];\nstring solve(long long n) {\n  string str = \"\";\n  while (n) {\n    str += n % 10 + '0';\n    n /= 10;\n  }\n  reverse(str.begin(), str.end());\n  return str;\n}\nsigned main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    memset(cnt, 0, sizeof(cnt));\n    memset(last, 0, sizeof(last));\n    long long geshu = 0;\n    string tmp = solve(n);\n    string res = \"\";\n    long long mark = 0;\n    char minn = '9';\n    char maxnn = '0';\n    for (long long i = 0; i < tmp.size(); i++) {\n      if (geshu < k) {\n        if (cnt[tmp[i] - '0'] == 0) {\n          cnt[tmp[i] - '0'] = i + 1;\n          last[tmp[i] - '0'] = i + 1;\n          geshu++;\n          res += tmp[i];\n          minn = ((minn < tmp[i]) ? minn : tmp[i]);\n          maxnn = ((maxnn > tmp[i]) ? maxnn : tmp[i]);\n        } else\n          res += tmp[i], minn = ((minn < tmp[i]) ? minn : tmp[i]),\n                         last[tmp[i] - '0'] = i + 1;\n      } else if (geshu == k) {\n        if (mark == 0 && cnt[tmp[i] - '0'] == 0) {\n          for (long long j = 0; j <= 9; j++) {\n            if (cnt[j] && j >= tmp[i] - '0') {\n              res += j + '0';\n              mark = 1;\n              break;\n            }\n          }\n          if (mark == 0) {\n            for (long long j = 0; j <= 9; j++) {\n              if (cnt[j] && j > res.back() - '0') {\n                res.back() = j + '0';\n                res += minn;\n                mark = 1;\n                break;\n              }\n            }\n          }\n          if (mark == 0) {\n            mark = 1;\n            long long maxn = 0;\n            char ch = '0';\n            for (long long j = 0; j <= 9; j++) {\n              if (cnt[j] > maxn) {\n                maxn = cnt[j];\n                ch = j + '0';\n              }\n            }\n            long long woc = 0;\n            long long wori = 0;\n            for (long long i = 0; i < maxnn - '0'; i++)\n              wori = ((wori > last[i]) ? wori : last[i]);\n            if (wori > maxn) {\n              for (long long j = 0; j <= 9; j++)\n                if (cnt[j] && j > tmp[wori - 1] - '0') {\n                  res[wori - 1] = j + '0';\n                  mark = 1;\n                  for (long long j = wori; j < i; j++) res[j] = minn;\n                  res += minn;\n                  woc = 1;\n                  break;\n                }\n              if (woc) continue;\n            }\n            maxn--;\n            if (minn == ch) minn++;\n            res[maxn] = ch + 1;\n            for (long long j = maxn + 1; j < i; j++) res[j] = minn;\n            res += minn;\n          }\n        } else if (mark == 1)\n          res += minn;\n        else\n          res += tmp[i], last[tmp[i] - '0'] = i + 1;\n      }\n    }\n    long long pos = -1;\n    for (long long i = 0; i < tmp.size(); i++) {\n      if (res[i] > tmp[i]) {\n        pos = i;\n        break;\n      }\n    }\n    if (pos != -1) {\n      long long geshu2 = 0;\n      vector<long long> vv;\n      vv.clear();\n      vv.resize(11);\n      for (long long i = 0; i <= pos; i++) vv[res[i] - '0']++;\n      for (long long i = 0; i <= 9; i++)\n        if (vv[i]) geshu2++;\n      if (geshu2 < k) {\n        if (res[pos] != tmp[pos] + 1) {\n          res[pos] = tmp[pos] + 1;\n          char minn = '9';\n          for (long long i = 0; i <= pos; i++)\n            minn = ((minn < res[i]) ? minn : res[i]);\n          for (long long i = pos + 1; i < res.size(); i++) res[i] = minn;\n        } else {\n          for (long long i = pos + 1; i < res.size(); i++) res[i] = '0';\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class CF1560F1_NearestBeautifulNumberEasy {\n\tstatic class IO {\n\t\tprivate boolean type;\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer st;\n\t\tprivate PrintWriter pw;\n\n\t\tpublic IO() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttype = false;\n\t\t}\n\n\t\tpublic IO(String file) {\n\t\t\ttype = true;\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(file + \".in\"));\n\t\t\t\tpw = new PrintWriter(new BufferedWriter(new FileWriter(file + \".out\")));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tvoid print(Object b) {\n\t\t\tif (type)\n\t\t\t\tpw.print(b);\n\t\t\telse\n\t\t\t\tSystem.out.print(b);\n\t\t}\n\n\t\tvoid println(Object b) {\n\t\t\tif (type)\n\t\t\t\tpw.println(b);\n\t\t\telse\n\t\t\t\tSystem.out.println(b);\n\t\t}\n\n\t\tvoid println() {\n\t\t\tif (type)\n\t\t\t\tpw.println();\n\t\t\telse\n\t\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid close() {\n\t\t\tif (type)\n\t\t\t\ttry {\n\t\t\t\t\tbr.close();\n\t\t\t\t\tpw.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t}\n\n\t\tvoid fill(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t}\n\n\t\tvoid fill(int[] arr, int add) {\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nextInt() + add;\n\t\t\t}\n\t\t}\n\n\t\tvoid fill(int[][] arr) {\n\t\t\tfor (int[] a : arr)\n\t\t\t\tfill(a);\n\t\t}\n\n\t}\n\n\tstatic int[] pow = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tIO io = new IO();\n\t\tint te = io.nextInt();\n\t\tfor (int t = 0; t < te; t++) {\n\t\t\tchar[] num = io.next().toCharArray();\n\t\t\tint k = io.nextInt();\n\t\t\twhile (true) {\n\t\t\t\tHashSet<Character> start = new HashSet<Character>();\n\t\t\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\t\t\tfor (int i = 0; i < num.length; i++)\n\t\t\t\t\tstart.add(num[i]);\n\t\t\t\tif (start.size() <= k) {\n\t\t\t\t\tio.println(String.valueOf(num));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\t\t\ths.add(num[i]);\n\t\t\t\t\tif (hs.size() > k) {\n\t\t\t\t\t\twhile (num[i] == '9')\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\n\t\t\t\t\t\tnum[i]++;\n\t\t\t\t\t\tfor (int j = i + 1; j < num.length; j++)\n\t\t\t\t\t\t\tnum[j] = '0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n//\t\t\tint[] count = new int[10];\n//\t\t\tint[] first = new int[10];\n//\t\t\tArrays.fill(first, -1);\n//\t\t\tint cnt = 0;\n//\n//\t\t\tint start = -1;\n//\t\t\tfor (int i = 0; i < num.length; i++) {\n//\t\t\t\tint j = num[i] - 48;\n//\t\t\t\tif (count[j] == 0) {\n//\t\t\t\t\tcnt++;\n//\t\t\t\t}\n//\n//\t\t\t\tif (cnt > k) {\n//\t\t\t\t\tstart = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else {\n//\t\t\t\t\tfirst[j] = i;\n//\t\t\t\t\tcount[j]++;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif (start == -1) {\n//\t\t\t\tio.println(n);\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\tint maxright = -1;\n//\t\t\tfor (int i = start; i < num.length; i++) {\n//\t\t\t\tmaxright = Math.max(maxright, num[i] - 48);\n//\t\t\t}\n//\n//\t\t\tint minleft = Integer.MAX_VALUE;\n//\t\t\tint last = -1;\n//\t\t\tfor (int i = 0; i < 10; i++) {\n//\t\t\t\tif (first[i] > -1) {\n//\t\t\t\t\tlast = Math.max(last, first[i]);\n//\t\t\t\t\tminleft = Math.min(minleft, i);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tint front = -1;\n//\n//\t\t\tif (first[(num[last] - 48 + 1) % 10] != -1) {\n//\t\t\t\tnum[last]++;\n//\t\t\t\tif (num[last] == 10) {\n//\t\t\t\t\tnum[last] = 0;\n//\t\t\t\t\tif (last == 0) {\n//\t\t\t\t\t\tfront = 1;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tfor (int i = last + 1; i < num.length; i++)\n//\t\t\t\t\tnum[i] = '0';\n//\t\t\t} else {\n//\t\t\t\tnum[last]++;\n//\t\t\t\tfor (int i = last + 1; i < num.length; i++) {\n//\t\t\t\t\tnum[i] = (char) (minleft + 48);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t\n//\t\t\tif(front != -1)\n//\t\t\t\tio.print(front);\n//\t\t\t\n//\t\t\tfor(int i = 0; i< num.length; i++) {\n//\t\t\t\tio.print(num[i]);\n//\t\t\t}\n//\t\t\tio.println();\n\n//\t\t\tint n = io.nextInt();\n//\t\t\tchar[] num = String.valueOf(n).toCharArray();\n//\t\t\tint k = io.nextInt();\n//\n//\t\t\tint[] count = new int[10];\n//\t\t\tint[] first = new int[10];\n//\t\t\tArrays.fill(first, -1);\n//\t\t\tint cnt = 0;\n//\n//\t\t\tint start = -1;\n//\t\t\tfor (int i = 0; i < num.length; i++) {\n//\t\t\t\tint j = num[i] - 48;\n//\t\t\t\tif (count[j] == 0) {\n//\t\t\t\t\tfirst[j] = i;\n//\t\t\t\t\tcnt++;\n//\t\t\t\t}\n//\t\t\t\tcount[j]++;\n//\t\t\t\tif (cnt > k) {\n//\t\t\t\t\tstart = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif (start == -1) { io.println(n); continue; }\n//\t\t\t\n//\t\t\tint max = Integer.MIN_VALUE;\n//\t\t\tfor(int i = start; i < num.length; i++) {\n//\t\t\t\tmax = Math.max(max, num[i] - 48);\n//\t\t\t}\n//\t\t\t\n//\t\t\tint min = -1;\n//\t\t\tfor(int i = 0; i < 10; i++) {\n//\t\t\t\tif(i >= max && first[i] > min) min = first[i];\n//\t\t\t}\n//\t\t\t\n//\t\t\tint s;\n//\t\t\tif (min != -1)\n//\t\t\t\ts = num[min] - 48;\n//\t\t\telse\n//\t\t\t\ts = max;\n//\t\t\t\n\n//\t\t\tif(num == 1000000000) {\n//\t\t\t\tio.println(k == 1 ? \"1111111111\" : \"1000000000\");\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t\tint[] count = new int[10];\n//\t\t\tfor(int i = 0; i < n.length; i++) {\n//\t\t\t\tcount[n[i]-48]++;\n//\t\t\t}\n//\t\t\tif(k == 1) {\n//\t\t\t\t\n//\t\t\t\tint diff = 0;\n//\t\t\t\tfor(int i = 0 ; i < 10; i++) {\n//\t\t\t\t\tif(count[i] > 0)\n//\t\t\t\t\t\tdiff++;\n//\t\t\t\t}\n//\t\t\t\tif(diff == 1) {\n//\t\t\t\t\tio.println(num);\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n//\t\t\t\tint[] ansarr = new int[n.length];\n//\t\t\t\tlong ans = 0;\n//\t\t\t\tfor(int i = 0; i < n.length; i++) {\n//\t\t\t\t\tansarr[i] = (int)n[0]-48;\n//\t\t\t\t\tans+= pow[n.length-i-1] * ansarr[i]; // check\n//\t\t\t\t}\n//\t\t\t\tif(ans < num) {\n//\t\t\t\t\tans = 0;\n//\t\t\t\t\tfor(int i = 0; i < n.length; i++) {\n//\t\t\t\t\t\tansarr[i]++;\n//\t\t\t\t\t\tans+= pow[n.length-i-1] * ansarr[i]; // check\n//\n//\t\t\t\t\t}\n//\t\t\t\t\tio.println(ans);\n//\t\t\t\t\tcontinue;\n//\t\t\t\t} \n//\t\t\t\tio.println(ans);\n//\t\t\t\tcontinue;\n//\t\t\t} else {\n//\t\t\t\tint diff = 0;\n//\t\t\t\tfor(int i = 0 ; i < 10; i++) {\n//\t\t\t\t\tif(count[i] > 0)\n//\t\t\t\t\t\tdiff++;\n//\t\t\t\t}\n//\t\t\t\tif(diff <= 2) {\n//\t\t\t\t\tio.println(num);\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n//\t\t\t\tint[] ansarr = new int[n.length];\n//\t\t\t\tlong ans = 0;\n//\t\t\t\tfor(int i = n.length; i < 10; i++) {\n//\t\t\t\t\tfor(int )\n//\t\t\t\t}\n//\t\t\t\tif(ans < num) {\n//\t\t\t\t\tans = 0;\n//\t\t\t\t\tfor(int i = 0; i < n.length; i++) {\n//\t\t\t\t\t\tansarr[i]++;\n//\t\t\t\t\t\tans+= pow[n.length-i-1] * ansarr[i]; // check\n//\n//\t\t\t\t\t}\n//\t\t\t\t\tio.println(ans);\n//\t\t\t\t\tcontinue;\n//\t\t\t\t} \n//\t\t\t\tio.println(ans);\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\ninline ll bit(ll x, ll y) { return (x & (1ll << y)); }\nconst ll mod = 998244353;\nconst ll N = 2e5 + 5;\nconst ll base = 31;\nll dd[20];\nll kq[20];\nll n, cnt = 0;\nstring st;\nll k, cur = 0;\nvoid down(ll i) {\n  if (dd[kq[i]] == 1) cnt--;\n  dd[kq[i]]--;\n  if (kq[i] == 9) {\n    down(i - 1);\n  } else {\n    st[i] = char(ll((st[i] - '0') + 1) + '0');\n    for (ll j = i + 1; j <= n; j++) st[j] = '0';\n    cur = i - 1;\n  }\n  return;\n}\nvoid check(ll i) {\n  ll x = st[i] - '0';\n  if (dd[x]) {\n    kq[i] = x;\n    dd[x]++;\n    return;\n  }\n  if (cnt < k) {\n    kq[i] = st[i] - '0';\n    if (dd[kq[i]] == 0) cnt++;\n    dd[kq[i]]++;\n    return;\n  }\n  bool kt = false;\n  for (ll j = x; j <= 9; j++)\n    if (dd[j]) {\n      kt = true;\n      kq[i] = j;\n      dd[j]++;\n      for (ll k = i + 1; k <= n; k++) st[k] = '0';\n      return;\n    }\n  if (kt == false) {\n    down(i - 1);\n    return;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(0);\n  ll t;\n  cin >> t;\n  while (t--) {\n    cin >> st >> k;\n    for (ll i = 0; i <= 9; i++) {\n      dd[i] = 0;\n      kq[i] = 0;\n    }\n    cnt = 0;\n    cur = 1;\n    n = st.size();\n    st = ' ' + st;\n    while (cur <= n) {\n      check(cur);\n      cur++;\n    }\n    for (ll i = 1; i <= n; i++) cout << kq[i];\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k, cnt[1024], len, n, ans;\nchar st[15];\nvoid dfs(bool limit, int pos, int Bit, int x) {\n  if (ans != INT_MAX) return;\n  if (pos == len + 1) {\n    if (x >= n) ans = min(ans, x);\n    return;\n  }\n  int min = INT_MAX;\n  for (int i = (limit ? (st[pos] - '0') : 0); i <= 9; ++i) {\n    if (cnt[Bit | (1 << i)] <= k)\n      dfs(limit & (i == (st[pos] - '0')), pos + 1, Bit | (1 << i), x * 10 + i);\n  }\n}\nint main() {\n  int tmp;\n  scanf(\"%d\", &tmp);\n  cnt[0] = 0;\n  for (int i = 1; i < 1024; ++i) cnt[i] = cnt[i - (i & (-i))] + 1;\n  while (tmp--) {\n    scanf(\"%s\", st + 1);\n    len = strlen(st + 1);\n    n = 0;\n    for (int i = 1; i <= len; ++i) n = n * 10 + (st[i] - '0');\n    scanf(\"%d\", &k);\n    ans = INT_MAX;\n    dfs(1, 1, 0, 0);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  while (true) {\n    set<char> s;\n    for (int c = 0; c < n.size(); c++) s.insert(n[c]);\n    if (s.size() <= k) return n;\n    s.clear();\n    int ptr = 0;\n    for (;; ptr++) {\n      s.insert(n[ptr]);\n      if (s.size() > k) {\n        if (n[ptr] == '9') ptr--;\n        n[ptr]++;\n        for (int i = ptr + 1; i < n.size(); i++) n[i] = '0';\n        break;\n      }\n    }\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) cout << solve() << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[][] input = getInput();\n        for (int[] in : input) {\n            computeAndPrintBrute(in);\n        }\n\n    }\n\n    public static int[][] getInput() {\n        Scanner scan = new Scanner(System.in);\n        int num = scan.nextInt();\n        int[][] input = new int[num][2];\n\n\n        for (int i = 0; i < num; i++) {\n            input[i][0] = scan.nextInt();\n            input[i][1] = scan.nextInt();\n        }\n\n        return input;\n    }\n\n    public static void computeAndPrintBrute(int[] in) {\n        System.out.println(new String(beautiful(in[0], in[1])));\n    }\n\n    // returns the position from the left that is not beautiful\n    public static char[] beautiful(int in, int k) {\n\n        char[] num = String.valueOf(in).toCharArray();\n        boolean[] usedNum = new boolean[10];\n        int used = 0;\n\n        for (int i = 0; i < num.length; i++) {\n            if (!usedNum[num[i] - 48]) {\n                if (++used > k) {\n                    int mod = (int)Math.pow(10, num.length - i - 1);\n                    in += mod;\n                    in -= in % mod;\n\n                    return beautiful(in, k);\n                }\n                usedNum[num[i] - 48] = true;\n            }\n        }\n        return num;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 11;\nconst int M = (1 << 10) + 1;\nint n, k;\nbool dp[N][M][2];\nbool vis[N][M][2];\nint jabo[N][M][2];\nvector<int> digits;\nvoid fun(int n) {\n  while (n != 0) {\n    digits.push_back(n % 10);\n    n /= 10;\n  }\n  reverse(digits.begin(), digits.end());\n}\nbool solve(int idx, int mask, bool done) {\n  if (__builtin_popcount(mask) > k) return 0;\n  if (idx == (int)digits.size()) return 1;\n  bool &ret = dp[idx][mask][done];\n  if (vis[idx][mask][done]) {\n    return ret;\n  }\n  bool ans = false;\n  if (!done) {\n    for (int i = digits[idx]; i <= 9; i++) {\n      bool eta = 0;\n      if (i != digits[idx]) eta = 1;\n      if (solve(idx + 1, mask | (1 << i), eta)) {\n        jabo[idx][mask][done] = i;\n        ans = 1;\n        break;\n      }\n    }\n  } else {\n    for (int i = 0; i <= 9; i++) {\n      if (solve(idx + 1, mask | (1 << i), 1)) {\n        jabo[idx][mask][done] = i;\n        ans = 1;\n        break;\n      }\n    }\n  }\n  return ret = ans;\n}\nvoid print(int idx, int mask, bool done) {\n  if (idx == digits.size()) return;\n  int i = jabo[idx][mask][done];\n  cout << i;\n  mask |= (1 << i);\n  if (!done && i > digits[idx]) done = 1;\n  print(idx + 1, mask, done);\n}\nvoid TEST_CASES() {\n  memset(vis, 0, sizeof vis);\n  digits.clear();\n  cin >> n >> k;\n  fun(n);\n  bool x = solve(0, 0, 0);\n  print(0, 0, 0);\n  cout << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    TEST_CASES();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import time\nimport random\n\nDEB = False\n\ndef slow_solve(n, k):\n\tmin_k_beautiful = n\n\twhile len(set(str(min_k_beautiful))) > k:\n\t\tmin_k_beautiful += 1\n\treturn min_k_beautiful\n\ndef dig_to_num(digits):\n\treturn int(''.join(map(str, digits)))\n\ndef num_to_dig(num):\n\treturn [int(dig) for dig in str(num)]\n\t\ndef solve(n, k):\n\ti = 0\n\tdigits = num_to_dig(n)\n\tchosen_digits = []\n\n\tdef debug_print():\n\t\tif not DEB:\n\t\t\treturn\n\t\tprint('\\n\\tn = {}\\n\\ti = {}\\n\\tk-beautiful = {}\\n\\tchosen = {}'.format(dig_to_num(digits), i, dig_to_num(digits), chosen_digits))\n\n\twhile i < len(digits):\n\t\tdebug_print()\n\n\t\tdig = digits[i]\n\n\t\tif len(chosen_digits) < k and dig not in chosen_digits:\n\t\t\tchosen_digits.append(dig)\n\t\t\ti += 1\n\t\t\tcontinue\n\n\t\tif dig in chosen_digits:\n\t\t\tdigits[i] = dig\n\t\t\ti += 1\n\n\t\telse:\n\t\t\tif dig > max(chosen_digits):\n\t\t\t\t\ti -= 1\n\n\t\t\tif chosen_digits[-1] not in digits[:i]:\n\t\t\t\tchosen_digits[-1] += 1\n\t\t\t\tif chosen_digits.count(chosen_digits[-1]) > 1:\n\t\t\t\t\tchosen_digits.pop(-1)\n\n\t\t\tdigits = digits[:i] + [digits[i] + 1] + [min(chosen_digits) if len(chosen_digits) != k - 1 else 0] * (len(digits) - i - 1)\n\n\tdebug_print()\n\n\treturn dig_to_num(digits)\n\n\ndef solve_tests(tests):\n\treturn [solve(n, k) for n, k in tests]\n\n\ndef print_sol(sol):\n\t[print(min_num) for min_num in sol]\n\n\ndef print_test(t, tests):\n\tprint()\n\tprint(t)\n\t[print(test[0], test[1]) for test in tests]\n\tprint()\n\ndef parse_input():\n\tt = int(input())\n\ttests = [(list(map(int, input().split()))) for _ in range(t)]\n\treturn t, tests\n\ndef checker(t, tests):\n\tfor test in tests:\n\t\tmy_sol = solve_tests([test])[0]\n\t\ttrue_sol = slow_solve(test[0], test[1])\n\t\tprint(test[0], my_sol, true_sol)\n\t\tassert my_sol == true_sol\n\n\ndef main():\n\tt, tests = parse_input()\n\n\t# t = 10 ** 3\n\t# tests = [(random.randint(10 ** 4, 10 ** 5), random.randint(1,11)) for _ in range(1, t)]\n\t# tests = [(random.randint(9 * 10 ** 8 + 10 ** 7, 10 ** 9), 2) for _ in range(1, t)]\n\n\t# t = 1\n\t# tests = [[102,1]]\n\n\t# if DEB: print_test(t, tests)\n\t# s = time.time()\n\t# solve_tests(tests)\n\tprint_sol(solve_tests(tests))\n\t# print(time.time() - s)\n\t# if DEB: print(slow_solve(tests[0][0], tests[0][1]))\n\n\t# checker(t, tests)\n\nif __name__ == \"__main__\":\n\tmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    string n;\n    cin >> n;\n    int k;\n    cin >> k;\n    map<char, int> used;\n    int l = (int)n.size();\n    if (l == 1) {\n      cout << n << \"\\n\";\n      continue;\n    }\n    int cnt = 1;\n    int pos = 0;\n    used[n[0]] = 1;\n    char curmx = n[0];\n    for (int i = 1; i < l; i++) {\n      if (cnt > k) {\n        break;\n      }\n      if (n[i] != '9') {\n        if (!used[n[i] + 1] && cnt == k && curmx < n[i] + 1) {\n        } else {\n          pos = i;\n        }\n      }\n      if (!used[n[i]]) {\n        cnt++;\n        used[n[i]] = 1;\n      }\n      curmx = max(curmx, n[i]);\n    }\n    if (cnt <= k) {\n      cout << n << '\\n';\n      continue;\n    }\n    set<char> st;\n    for (int i = 0; i < pos; i++) {\n      cout << n[i];\n      st.insert(n[i]);\n    }\n    if ((int)st.size() == k) {\n      cout << *st.lower_bound(n[pos] + 1);\n    } else {\n      st.insert(n[pos] + 1);\n      cout << (char)(n[pos] + 1);\n    }\n    if ((int)st.size() < k) {\n      for (int i = pos + 1; i < l; i++) {\n        cout << 0;\n      }\n    } else {\n      for (int i = pos + 1; i < l; i++) {\n        cout << *st.begin();\n      }\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint count(int n) {\n  int mask = 0;\n  while (n != 0) {\n    mask |= 1 << (n % 10);\n    n /= 10;\n  }\n  return __builtin_popcount(mask);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, k;\n    cin >> n >> k;\n    while (count(n) > k) {\n      int r = 1, tmp = n;\n      while (count(tmp) > k) {\n        tmp /= 10;\n        r *= 10;\n      }\n      r /= 10;\n      n = (n / r + 1) * r;\n    }\n    cout << n << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    arr=[i for i in str(n)]\n    l=len(arr)\n    if len(set(arr))<=k:\n        print(n)\n        continue\n    ans=-1\n    for i in range(0,l):\n        s=set()\n        vals=[]\n        for j in arr[:i]:\n            s.add(j)\n            vals.append(j)\n        p=len(s)\n        if p>k or arr[i]=='9':\n            continue\n        if p<k:\n            vals.append(str(int(arr[i])+1))\n            s.add(str(int(arr[i])+1))\n        else:\n            mi=float('inf')\n            for j in s:\n                if int(j)>int(arr[i]):\n                    mi=min(mi,int(j))\n            if mi==float('inf'):\n                continue\n            vals.append(str(mi))\n        mi=0\n        p=len(s)\n        if p==k:\n            mi=float('inf')\n            for j in s:\n                mi=min(mi,int(j))\n        mi=str(mi)\n        # print(mi)\n        for j in arr[i+1:]:\n            vals.append(str(mi))\n        ans=''.join(vals)\n        # print(i,ans)\n    try:\n        ans=int(ans)\n        print(ans)\n    except:\n        print(n,k,ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Map.Entry;\n\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputReader in = new InputReader(System.in);\n\t\t// Scanner in = new Scanner(System.in);\n\t\t// Scanner in = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// InputReader in = new InputReader(new\n\t\t// File(\"ethan_traverses_a_tree.txt\"));\n\t\t// PrintWriter out = new PrintWriter(new\n\t\t// File(\"ethan_traverses_a_tree-output.txt\"));\n\n\t\tint pi = in.nextInt();\n\t\tfor (int qi = 0; qi < pi; qi++) {\n\t\t\tlong n = in.nextLong();\n\t\t\tint k = in.nextInt();\n\n\t\t\tint m = getnsize(n);\n\t\t\tint[] a = new int[m];\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (set.size() < k || set.contains(j) == true) {\n\t\t\t\t\t\ta[i] = j;\n\t\t\t\t\t\tif (getmax(a, k, i) >= n) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tset.add(a[i]);\n\t\t\t}\n\n\t\t\tlong ans = getn(a);\n\t\t\tout.printf(\"%d\\n\", ans);\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tpublic static int getnsize(long k) {\n\t\tint count = 0;\n\t\twhile (k != 0) {\n\t\t\tk = k / 10;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static long getmax(int[] tmpa, int k, int fixm) {\n\t\tint m = tmpa.length;\n\t\tint[] a = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ta[i] = tmpa[i];\n\t\t}\n\n\t\tSet<Integer> set = new HashSet<Integer>();\n\n\t\tint maxdigit = 0;\n\t\tfor (int i = 0; i <= fixm; i++) {\n\t\t\tset.add(a[i]);\n\t\t\tmaxdigit = Math.max(maxdigit, a[i]);\n\t\t}\n\n\t\tif (set.size() == k) {\n\t\t\tfor (int i = fixm + 1; i < m; i++) {\n\t\t\t\ta[i] = maxdigit;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = fixm + 1; i < m; i++) {\n\t\t\t\ta[i] = 9;\n\t\t\t}\n\t\t}\n\n\t\treturn getn(a);\n\t}\n\n\tpublic static long getn(int[] a) {\n\t\tint m = a.length;\n\t\tlong res = 0;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tres = res * 10 + a[i];\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic InputReader(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nvector<int> lim;\ni64 dp[13][1 << 10][2][11];\ni64 solve(int p, int mask, int k, int s, int tight) {\n  if (__builtin_popcount(mask) > k) return 0;\n  if (p < 0) return 1;\n  i64& res = dp[p][mask][s][k];\n  if (tight && ~res) return res;\n  i64 cnt = 0;\n  for (int i = 0; i <= (tight ? 9 : lim[p]); i++) {\n    if (!s && i == 0)\n      cnt += solve(p - 1, 0, k, 0, 1);\n    else\n      cnt += solve(p - 1, mask | (1 << i), k, 1, tight | (i < lim[p]));\n  }\n  return (tight ? res = cnt : cnt);\n}\ni64 getSolve(i64 n, int k) {\n  lim.clear();\n  while (n) {\n    lim.emplace_back(n % 10);\n    n /= 10;\n  }\n  return solve((int)lim.size() - 1, 0, k, 0, 0);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  memset(dp, -1, sizeof(dp));\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    i64 def = getSolve(n - 1, k);\n    i64 lo = n, hi = 1e12;\n    while (lo < hi) {\n      const i64 mid = lo + (hi - lo) / 2;\n      if (getSolve(mid, k) > def)\n        hi = mid;\n      else\n        lo = mid + 1;\n    }\n    cout << hi << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 26;\ntemplate <typename T>\ninline bool scan_d(T& ret) {\n  char c;\n  int sgn;\n  if (c = getchar(), c == EOF) return 0;\n  while (c != '-' && (c < '0' || c > '9')) {\n    if ((c = getchar()) == EOF) return 0;\n  }\n  sgn = (c == '-') ? -1 : 1;\n  ret = (c == '-') ? 0 : (c - '0');\n  while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n  ret *= sgn;\n  return 1;\n}\ntemplate <typename T>\nvoid print(T x) {\n  static char s[33], *s1;\n  s1 = s;\n  if (!x) *s1++ = '0';\n  if (x < 0) putchar('-'), x = -x;\n  while (x) *s1++ = (x % 10 + '0'), x /= 10;\n  while (s1-- != s) putchar(*s1);\n}\ntemplate <typename T>\nvoid println(T x) {\n  print(x);\n  putchar('\\n');\n}\nint n, k;\nset<int> num2set(int val) {\n  set<int> mset;\n  while (val) {\n    mset.insert(val % 10);\n    val /= 10;\n  }\n  return mset;\n}\nint solve(int val) {\n  while (true) {\n    set<int> mset = num2set(val);\n    if (mset.size() <= k) return val;\n    if (val % 10 == 0) {\n      int pre = val / 10;\n      int spre = solve(pre);\n      mset = num2set(spre);\n      return spre * 10 + *mset.begin();\n    }\n    val++;\n  }\n  return 0;\n}\nint main() {\n  int T;\n  scan_d(T);\n  for (int t = (0); t < (T); ++t) {\n    scan_d(n), scan_d(k);\n    println(solve(n));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#------------------------------------------ BEGIN FASTIO ------------------------------------------#\n \nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n \n#------------------------------------------ END FASTIO ------------------------------------------#\ndef solve(n, k, cur, cur_set):\n    if len(cur) > len(str(n)) or len(cur_set) > k or cur < str(n)[: len(cur)]:\n        return None\n    if len(cur) == len(str(n)) and cur >= str(n):\n        return cur\n    \n    for i in range(10):\n        if i not in cur_set:\n            cur_set.add(i)\n            ans = solve(n, k, cur + str(i), cur_set)\n            cur_set ^= {i}\n        else:\n            ans = solve(n, k, cur + str(i), cur_set)\n        if ans != None:\n            return ans\n \nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(solve(n, k, '', set()))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, MAXN = 5e5 + 5;\nconst long long LINF = 0x3f3f3f3f3f3f3f3f, MOD = 998244353;\nconst double Pi = acos(-1), EPS = 1e-6;\nvoid test() { cerr << \"\\n\"; }\ntemplate <typename T, typename... Args>\nvoid test(T x, Args... args) {\n  cerr << x << \" \";\n  test(args...);\n}\ninline long long qpow(long long a, long long b) {\n  return b ? ((b & 1) ? a * qpow(a * a % MOD, b >> 1) % MOD\n                      : qpow(a * a % MOD, b >> 1)) %\n                 MOD\n           : 1;\n}\ninline long long qpow(long long a, long long b, long long c) {\n  return b ? ((b & 1) ? a * qpow(a * a % c, b >> 1, c) % c\n                      : qpow(a * a % c, b >> 1, c)) %\n                 c\n           : 1;\n}\ninline long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ninline long long lcm(long long a, long long b) { return a * b / gcd(a, b); }\ninline long long cede(long long a, long long b) {\n  if (b < 0) return cede(-a, -b);\n  if (a < 0) return a / b;\n  return (a + b - 1) / b;\n}\ninline long long flde(long long a, long long b) {\n  if (b < 0) return flde(-a, -b);\n  if (a < 0) return (a - b + 1) / b;\n  return a / b;\n}\ninline int sign(double x) { return x < -EPS ? -1 : x > EPS; }\ninline int dbcmp(double l, double r) { return sign(l - r); }\nnamespace Fast_IO {\nconst int MAXL((1 << 18) + 1);\nint iof, iotp;\nchar ioif[MAXL], *ioiS, *ioiT, ioof[MAXL],\n    *iooS = ioof, *iooT = ioof + MAXL - 1, ioc, iost[55];\nchar Getchar() {\n  if (ioiS == ioiT) {\n    ioiS = ioif;\n    ioiT = ioiS + fread(ioif, 1, MAXL, stdin);\n    return (ioiS == ioiT ? EOF : *ioiS++);\n  } else\n    return (*ioiS++);\n}\nvoid Write() {\n  fwrite(ioof, 1, iooS - ioof, stdout);\n  iooS = ioof;\n}\nvoid Putchar(char x) {\n  *iooS++ = x;\n  if (iooS == iooT) Write();\n}\ninline int rd() {\n  int x = 0;\n  for (iof = 1, ioc = Getchar(); (ioc < '0' || ioc > '9') && ioc != EOF;)\n    iof = ioc == '-' ? -1 : 1, ioc = Getchar();\n  if (ioc == EOF) Write(), exit(0);\n  for (x = 0; ioc <= '9' && ioc >= '0'; ioc = Getchar())\n    x = (x << 3) + (x << 1) + (ioc ^ 48);\n  return x * iof;\n}\ninline long long read_ll() {\n  long long x = 0;\n  for (iof = 1, ioc = Getchar(); (ioc < '0' || ioc > '9') && ioc != EOF;)\n    iof = ioc == '-' ? -1 : 1, ioc = Getchar();\n  if (ioc == EOF) Write(), exit(0);\n  for (x = 0; ioc <= '9' && ioc >= '0'; ioc = Getchar())\n    x = (x << 3) + (x << 1) + (ioc ^ 48);\n  return x * iof;\n}\nvoid Getstr(char *s, int &l) {\n  for (ioc = Getchar(); ioc != EOF && !isgraph(ioc);) ioc = Getchar();\n  if (ioc == EOF) Write(), exit(0);\n  for (l = 0; isgraph(ioc); ioc = Getchar()) s[l++] = ioc;\n  s[l] = 0;\n}\ntemplate <class Int>\nvoid Print(Int x, char ch = '\\0') {\n  if (!x) Putchar('0');\n  if (x < 0) Putchar('-'), x = -x;\n  while (x) iost[++iotp] = x % 10 + '0', x /= 10;\n  while (iotp) Putchar(iost[iotp--]);\n  if (ch) Putchar(ch);\n}\nvoid Putstr(const char *s) {\n  for (int i = 0; s[i]; ++i) Putchar(s[i]);\n}\n}  // namespace Fast_IO\nusing namespace Fast_IO;\nint vis[20], vis1[20];\nvoid run() {\n  memset(vis, 0, sizeof vis);\n  memset(vis1, 0, sizeof vis1);\n  int n, k;\n  cin >> n >> k;\n  set<int> st;\n  string s = to_string(n);\n  for (int i = 0; i < s.size(); ++i) {\n    if (!vis[s[i] - '0']) st.insert(s[i] - '0');\n    vis[s[i] - '0']++;\n    if (st.size() == k) break;\n  }\n  int tmp = 0, ff = 0;\n  for (int i = 0; i < s.size(); ++i) {\n    if (!ff && !vis[s[i] - '0']) {\n      auto pos = st.lower_bound(s[i] - '0');\n      if (pos == st.end()) {\n        int j;\n        for (j = i - 1; j >= 0; --j) {\n          vis1[s[j] - '0']--;\n          auto pos = st.lower_bound(s[j] - '0' + 1);\n          if (vis1[s[j] - '0'] == 0) {\n            tmp /= 10;\n            st.erase(s[j] - '0');\n            st.insert(s[j] - '0' + 1);\n            tmp = tmp * 10 + (s[j] - '0' + 1);\n            if ((int)st.size() < k) st.insert(0);\n            break;\n          }\n          if (pos != st.end()) {\n            tmp /= 10;\n            tmp = tmp * 10 + (*pos);\n            break;\n          }\n          tmp /= 10;\n        }\n        for (; j < i; ++j) tmp = tmp * 10 + (*st.begin());\n      } else {\n        tmp = tmp * 10 + *(pos);\n      }\n      ff = 1;\n      continue;\n    }\n    if (!ff)\n      tmp = tmp * 10 + s[i] - '0';\n    else\n      tmp = tmp * 10 + (*st.begin());\n    vis1[s[i] - '0']++;\n  }\n  cout << tmp << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int _;\n  cin >> _;\n  while (_--) run();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nbits = [[] for _ in range(11)]\nfor bit in range(1 << 10):\n    se = set()\n    for i in range(10):\n        if bit >> i & 1:\n            se.add(i)\n    bits[len(se)].append(se)\n\ndef main():\n    n, k = input().strip().split()\n    k = int(k)\n    l = len(n)\n    times = (10 ** l - 1) // 9\n    min_ = 10 ** 20\n    N = int(n)\n    se_ = set()\n    ans_ = []\n    for s in n:\n        if len(se_) >= k - 2:\n            break\n        s = int(s)\n        se_.add(s)\n        ans_.append(s)\n    if len(ans_) == l:\n        print(n)\n        return\n    n = n[len(ans_):]\n    l = len(n)\n    \n    for se2 in bits[min(k, 2)]:\n        se = se2 | se_\n        if max(se) * times < N:\n            continue\n        tmp = -1\n        nex = [-1] * 10\n        for i in range(9, -1, -1):\n            if i in se:\n                tmp = i\n            nex[i] = tmp\n        \n        ans = ans_.copy()\n        flg = False\n        for i in range(l):\n            if flg:\n                ans.append(nex[0])\n                continue\n            s = int(n[i])\n            t = nex[s]\n            if t == s:\n                ans.append(s)\n            elif t != -1:\n                ans.append(t)\n                flg = True\n            else:\n                cnt = 1\n                while 1:\n                    s = ans[-1]\n                    ans.pop()\n                    if nex[s + 1] != -1:\n                        ans.append(nex[s + 1])\n                        break\n                    cnt += 1\n                for _ in range(cnt):\n                    ans.append(nex[0])\n                flg = True\n        min_ = min(min_, int(\"\".join(map(str, ans))))\n    print(min_)\n    \nfor _ in range(int(input())):\n    main()"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom functools import lru_cache\n\n\nfor t in range(int(input())):\n    n, k = map(int, input().split())\n    s = str(n)\n    m = len(s)\n    p = [0] * 12\n    p[0] = 1\n    for i in range(1, 12): p[i] = 10 * p[i - 1]\n\n    @lru_cache(None)\n    def dp(i, tight, mask):\n        if i == m: return 0\n        ans = float(\"inf\")\n        for j in range(10):\n            mask2 = mask | 1 << j\n            if bin(mask2).count('1') > k: continue\n            if tight and j < int(s[i]): continue\n            tight2 = tight and j == int(s[i])\n            cur = p[m - 1 - i] * j + dp(i + 1, tight2, mask2)\n            if cur < ans:\n                ans = cur\n                break\n        return ans\n\n    ans = dp(0, 1, 0)\n    print(ans)"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: dtype(input().strip())\ninp_d = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp_d(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp_d(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp_d(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nget_bit = lambda x, i: (x >> i) & 1\n\nfor _ in range(inp(int)):\n    n, k = inp_d(int)\n    n1 = str(n)\n    nums, ans, ln = [int(str(i) * len(n1)) for i in range(1, 10)], 0, len(n1)\n\n    for i in range(9):\n        if nums[i] >= n:\n            ans = nums[i]\n            break\n\n    if k == 1:\n        print(ans)\n        continue\n\n    digs = set()\n    for i in n1:\n        if len(digs) == k - 1:\n            break\n        digs.add(i)\n\n    digs = list(digs)\n    for i in range(10):\n        cur, lst, flag = [], -1, 0\n\n        if str(i) not in digs:\n            digs.append(str(i))\n            flag = 1\n\n        digs.sort()\n\n        for j in n1:\n            for dig in digs[:-1]:\n                if j <= dig:\n                    cur.append(dig)\n                    if j < dig:\n                        cur.extend([digs[0]] * (ln - len(cur)))\n\n                    lst = len(cur) - 1\n                    break\n            else:\n\n                if j <= digs[-1]:\n                    cur.append(digs[-1])\n                    if j < digs[-1]:\n                        cur.extend([digs[0]] * (ln - len(cur)))\n                        break\n\n                elif lst == -1:\n                    cur = ['9'] * 10\n                    break\n                else:\n                    cur = cur[:lst + 1]\n                    for dig in digs:\n                        if cur[lst] < dig:\n                            cur[lst] = dig\n                            break\n\n                    cur.extend([digs[0]] * (ln - len(cur)))\n                    break\n\n            if len(cur) == len(n1):\n                break\n\n        # print(i, cur, ans)\n        if flag:\n            digs.remove(str(i))\n        ans = min(ans, int(''.join(cur)))\n\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  string n, v;\n  int k;\n  cin >> n >> k;\n  while (true) {\n    set<char> s;\n    int len = n.length();\n    for (int i = 0; i < len; i++) {\n      s.insert(n[i]);\n      if (s.size() > k) {\n        while (n[i] == '9') i--;\n        n[i]++;\n        for (int j = i + 1; j < n.size(); j++) n[j] = '0';\n        break;\n      }\n      if (i == len - 1) {\n        cout << n << endl;\n        return;\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int T;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import com.sun.source.tree.Tree;\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class G {\n\n    static final int MAX_N = 1000010;\n    static final int INF = 0x3f3f3f3f;\n\n    public static void main(String[] args) throws IOException {\n\n        initReader(System.in);\n\n\n        int T = nextInt();\n        for (int i = 1; i <= T; i++)\n        solve();\n\n\n        pw.flush();\n    }\n\n    /*******************************************************************************************************************************/\n\n\n\n    public static void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n\n        char[] num = String.valueOf(n).toCharArray();\n\n        TreeSet<Integer> set = new TreeSet<>();\n\n        for (char i : num) set.add(i - '0');\n\n        if (set.size() <= k) {\n            pw.println(n);\n            return ;\n        }\n\n        set.clear();\n        for (char i : num) {\n            if (set.size() == k - 1) break;\n            set.add(i - '0');\n        }\n\n\n\n        long ans = Long.MAX_VALUE;\n        for (int i = 0; i < 10; i++) {\n            TreeSet<Integer> set1 = new TreeSet<>(set);\n            set1.add(i);\n            ans = Math.min(ans, fun(set1, num, n, 0));\n        }\n\n        pw.println(ans);\n    }\n\n    public static long fun(TreeSet<Integer> set, char[] num, int n, int step) {\n        if (step == num.length) return Long.MAX_VALUE;\n\n        long res = Long.MAX_VALUE;\n\n        char[] ans = new char[num.length];\n        System.arraycopy(num, 0, ans, 0, step);\n\n        if (set.higher(num[step] - '0') != null) {\n            ans[step] = (char) (set.higher(num[step] - '0') + '0');\n            for (int i = step + 1; i < num.length; i++)  ans[i] = (char) (set.first() + '0');\n\n            long re = Long.parseLong(String.valueOf(ans));\n            if (re >= n) res = Math.min(res, re);\n        }\n\n        if (set.contains(num[step] - '0')) res = Math.min(res, fun(set, num, n, step + 1));\n\n\n        return res;\n    }\n\n\n\n    /*******************************************************************************************************************************/\n\n\n\n    /*******************************************************************************************************************************/\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    static PrintWriter pw;\n\n    public static void initReader(InputStream input) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n//        reader = new BufferedReader(new FileReader(\"test.in\"));\n//        tokenizer = new StringTokenizer(\"\");\n//        pw = new PrintWriter(new BufferedWriter(new FileWriter(\"test1.out\")));\n    }\n\n    public static boolean hasNext() {\n        try {\n            while (!tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static char nextChar() throws IOException {\n        return next().charAt(0);\n    }\n\n    public static short nextShort() throws IOException {\n        return Short.parseShort(next());\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 200010;\nlong long n, a[N];\nsigned main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long T;\n  cin >> T;\n  while (T--) {\n    string n;\n    long long k;\n    cin >> n >> k;\n    while (true) {\n      set<char> s;\n      for (long long i = 0; i < n.size(); i++) s.insert(n[i]);\n      if (s.size() <= k) {\n        cout << n << endl;\n        break;\n      } else {\n        s.clear();\n        long long pos = 0;\n        while (true) {\n          s.insert(n[pos]);\n          if (s.size() > k) {\n            while (n[pos] == '9') pos--;\n            n[pos]++;\n            for (long long i = pos + 1; i < n.size(); i++) n[i] = '0';\n            break;\n          }\n          pos++;\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint pos;\nvector<int> num;\nvoid init() {\n  int _n = n;\n  while (_n > 0) {\n    num.push_back(_n % 10);\n    _n /= 10;\n  }\n  reverse(num.begin(), num.end());\n}\nlong long ans;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    num.clear();\n    cin >> n >> k;\n    init();\n    int msk = 0;\n    for (int i = 0; i < (int)num.size(); i++) msk |= (1 << num[i]);\n    if (__builtin_popcount(msk) <= k) {\n      printf(\"%d\\n\", n);\n      continue;\n    }\n    ans = 1e10;\n    n = (int)num.size();\n    for (int i = 0; i < n; i++) {\n      bool flag = 0;\n      int now = 0;\n      for (int j = 0; j < i; j++) now |= (1 << num[j]);\n      if (__builtin_popcount(now) > k) break;\n      int lft = k - __builtin_popcount(now);\n      long long nans = 0;\n      for (int j = 0; j < i; j++) nans = nans * 10 + num[j];\n      for (int j = num[i] + 1; j <= 9; j++)\n        if (now & (1 << j) || lft) {\n          nans = nans * 10 + j;\n          if ((now & (1 << j)) == 0) {\n            now |= (1 << j);\n            lft--;\n          }\n          flag = 1;\n          break;\n        }\n      if (!flag) continue;\n      if (!lft && (now & 1) == 0) {\n        for (int j = 1; j <= 9; j++)\n          if (now & (1 << j)) {\n            for (int l = i + 1; l < n; l++) nans = nans * 10 + j;\n            break;\n          }\n      } else {\n        for (int l = i + 1; l < n; l++) nans = nans * 10;\n      }\n      ans = min(ans, nans);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, size_t sz>\nusing ar = array<T, sz>;\ntemplate <typename TOStream, typename T1, typename T2>\ninline TOStream &operator<<(TOStream &s, const pair<T1, T2> &p) {\n  s << \"[\" << p.first << \", \" << p.second << \"]\";\n  return s;\n}\ntemplate <typename TOStream, typename TContainer>\ninline TOStream &operator<<(TOStream &s, const TContainer &container) {\n  s << \"[\";\n  bool first = true;\n  for (const auto &val : container) {\n    if (!first) {\n      s << \", \";\n    } else {\n      first = false;\n    }\n    s << val;\n  }\n  s << \"]\";\n  return s;\n}\ntemplate <typename TIStream, typename T1, typename T2>\ninline TIStream &operator>>(TIStream &s, pair<T1, T2> &p) {\n  s >> p.first >> p.second;\n  return s;\n}\ntemplate <typename TOStream>\ninline TOStream &operator<<(TOStream &s, const pair<int, int> &p) {\n  s << \"(\" << p.first << \", \" << p.second << \")\";\n  return s;\n}\nbool search(int k, int i, const string &s, const set<char> &digs, string &r,\n            set<char> &taken) {\n  if (i >= int(s.size())) {\n    return true;\n  }\n  if (k == taken.size()) {\n    auto iter = taken.lower_bound(s[i]);\n    if (*iter == s[i]) {\n      r.push_back(*iter);\n      if (search(k, i + 1, s, digs, r, taken)) {\n        return true;\n      }\n      r.pop_back();\n      iter++;\n    }\n    if (iter != taken.end()) {\n      r.push_back(*iter);\n      for (int j = i + 1; j < int(s.size()); j++) {\n        r.push_back(*taken.begin());\n      }\n      return true;\n    }\n    return false;\n  }\n  r.push_back(s[i]);\n  taken.insert(s[i]);\n  if (search(k, i + 1, s, digs, r, taken)) {\n    return true;\n  }\n  r.pop_back();\n  taken.erase(s[i]);\n  if (s[i] < '9') {\n    r.push_back(s[i] + 1);\n    taken.insert(s[i] + 1);\n    for (int j = i + 1; j < int(s.size()); j++) {\n      r.push_back(taken.size() == k ? *taken.begin() : '0');\n    }\n    return true;\n  }\n  return false;\n}\nvoid solve() {\n  string s;\n  int k;\n  cin >> s >> k;\n  string r;\n  set<char> digs(s.begin(), s.end());\n  set<char> taken;\n  search(k, 0, s, digs, r, taken);\n  cout << r << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def _measure_k(x: int):\n    assert x >= 1\n    return len(set(str(x)))\n\n\ntests_n = int(input())\nfor i_test in range(tests_n):\n    n, k = map(int, input().split())\n    \n    prefix = n\n    while _measure_k(prefix) > k:\n        if prefix % 10 == 0:\n            prefix //= 10  # the dropped digit can be any digit\n        else:\n            prefix += 1\n    \n    zeros_n = len(str(n)) - len(str(prefix))\n    tail_digit = '0' if _measure_k(prefix) < k else min(str(prefix))\n    tail = int(tail_digit * zeros_n) if zeros_n > 0 else 0\n    \n    result = prefix * 10**zeros_n + tail\n    print(result)\n"
        },
        {
            "language": 3,
            "solution": "# cook your dish here\nimport sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n#sys.setrecursionlimit(10**7)\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs2(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\n        \nans=0\nb=[]\nvis=[]\ntot=0\ntime=[]\ntime1=[]\nadj=[]\nmx=-1\neps=0.0000001\ndef dfs(a,b,p,c):\n    if a==b:\n        return c\n    for i,j in adj[a]:\n        if i==p:continue\n        temp=dfs(i,b,a,c+j)\n        if dfs(i,b,a):\n            mx=max(i,mx)\n            return 1\n    return tot\nans=0\ndig={}\ns=0\nk=0\ndef recur_dp(i,tight):\n    global s,ans,k,dig\n    if i==len(s):\n        return ans\n    t=0\n    for j in range(10):\n        if tight and j<int(s[i]):continue\n        if t>=2:continue\n        if len(dig)==k and dig.get(j) is None:continue\n        ans*=10\n        ans+=j\n        abe=0\n        if dig.get(j) is None:\n            abe=1\n        dig[j]=1\n        fl=recur_dp(i+1,tight&(j==int(s[i])))\n        if fl!=-1:\n            return fl\n        if abe:\n            del dig[j]\n        ans//=10\n    return -1\n        \ndef hnbhai(tc):\n    global s,n,k,ans,dig\n    n,k=sd()\n    s=str(n)\n    ans=0\n    dig={}\n    print(recur_dp(0,1))\nfor _ in range(sb()):\n    hnbhai(_+1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<vector<char>, bool> solve(set<char> useddigits, int k, string n) {\n  if (n.length() == 0) {\n    return {{}, true};\n  }\n  if (useddigits.find(n[0]) != useddigits.end()) {\n    pair<vector<char>, bool> remainder =\n        solve(useddigits, k, n.substr(1, n.size() - 1));\n    if (remainder.second) {\n      remainder.first.insert(remainder.first.begin(), n[0]);\n      return remainder;\n    }\n  }\n  if (k == 0) {\n    for (char d : useddigits) {\n      if (d == n[0]) {\n        pair<vector<char>, bool> remainder =\n            solve(useddigits, k, n.substr(1, n.size() - 1));\n        if (remainder.second) {\n          remainder.first.insert(remainder.first.begin(), d);\n          return remainder;\n        }\n      } else if (d > n[0]) {\n        char small = *min_element(useddigits.begin(), useddigits.end());\n        vector<char> ans(n.size(), small);\n        ans[0] = d;\n        return {ans, true};\n      }\n    }\n  } else if (k == 1) {\n    set<char> copy = useddigits;\n    copy.insert(n[0]);\n    pair<vector<char>, bool> remainder = solve(copy, k - 1, n);\n    if (remainder.second && remainder.first[0] == n[0]) return remainder;\n    char small;\n    if (useddigits.find(n[0] + 1) == useddigits.end()) {\n      useddigits.insert(n[0] + 1);\n      small = *min_element(useddigits.begin(), useddigits.end());\n    } else\n      small = '0';\n    vector<char> ans(n.size(), small);\n    ans[0] = n[0] + 1;\n    return {ans, true};\n  }\n  return {{}, false};\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    string n;\n    int k;\n    cin >> n >> k;\n    vector<char> digits;\n    set<char> useddigits;\n    int i = 0;\n    while (useddigits.size() < k - 1 && i < n.size()) {\n      digits.push_back(n[i]);\n      useddigits.insert(n[i]);\n      i++;\n    }\n    if (i >= n.size()) {\n      for (char j : digits) {\n        cout << j;\n      }\n      cout << endl;\n    } else {\n      vector<char> remainder =\n          solve(useddigits, 1, n.substr(i, n.size() - i)).first;\n      for (char j : digits) {\n        cout << j;\n      }\n      for (char j : remainder) {\n        cout << j;\n      }\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr double EPS = 1e-8;\nconstexpr int MOD = 1000000007;\nconstexpr int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconstexpr int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1},\n              dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U>\ninline bool chmax(T &a, U b) {\n  return a < b ? (a = b, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool chmin(T &a, U b) {\n  return a > b ? (a = b, true) : false;\n}\nstruct IOSetup {\n  IOSetup() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::cout << fixed << setprecision(20);\n  }\n} iosetup;\nconstexpr int D = 10;\nvoid solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  ll N = stoll(n);\n  const int l = n.length();\n  vector<ll> w(l, 1);\n  for (int i = l - 2; i >= 0; --i) w[i] = w[i + 1] * 10;\n  vector<ll> sum = w;\n  for (int i = l - 2; i >= 0; --i) sum[i] += sum[i + 1];\n  int lb = 0, ub = l + 1;\n  while (ub - lb > 1) {\n    int mid = (lb + ub) / 2;\n    set<int> digit;\n    ll num = 0;\n    for (int i = (0); i < (mid); ++i) {\n      num += w[i] * (n[i] - '0');\n      digit.emplace(n[i] - '0');\n    }\n    if (digit.size() > k) {\n      ub = mid;\n      continue;\n    } else if (digit.size() == k) {\n      if (mid < l) num += sum[mid] * *digit.rbegin();\n    } else {\n      if (mid < l) num += sum[mid] * 9;\n    }\n    (num >= N ? lb : ub) = mid;\n  }\n  if (lb == l) {\n    cout << N << '\\n';\n    return;\n  }\n  ll ans = 0;\n  set<int> digit;\n  for (int i = (0); i < (lb); ++i) {\n    ans += w[i] * (n[i] - '0');\n    digit.emplace(n[i] - '0');\n  }\n  for (int lb_d = (n[lb] - '0' + 1); lb_d < (D); ++lb_d) {\n    set<int> tmp_digit = digit;\n    tmp_digit.emplace(lb_d);\n    if (tmp_digit.size() > k) continue;\n    ll tmp_ans = ans + w[lb] * lb_d;\n    if (lb + 1 < l)\n      tmp_ans +=\n          sum[lb + 1] * (tmp_digit.size() == k ? *tmp_digit.rbegin() : 9);\n    if (tmp_ans >= N) {\n      ans += w[lb] * lb_d;\n      digit.emplace(lb_d);\n      break;\n    }\n  }\n  if (lb + 1 < l && digit.size() == k) ans += sum[lb + 1] * *digit.begin();\n  cout << ans << '\\n';\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class NearestBeautifulNumberHardVersion {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = readInt();\n\t\t\n\t\touter: while (t-- > 0) {\n\t\t\tint n = readInt(), k = readInt();\n\t\t\tString s = String.valueOf(n);\n\t\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\t\t\n\t\t\tfor (int i = 0; i < s.length(); i ++) {\n\t\t\t\tint x = Character.getNumericValue(s.charAt(i));\n\t\t\t\tif (!map.containsKey(x) && map.size() == k) {\n\t\t\t\t\tif (map.ceilingKey(x) == null) {\n\t\t\t\t\t\tint idx = -1, val = 0, mx = map.lastKey(), min = map.firstKey();\n\t\t\t\t\t\tfor (int j = i - 1; j >= 0; j --) {\n\t\t\t\t\t\t\tint d = Character.getNumericValue(s.charAt(j));\n\t\t\t\t\t\t\tif (d != mx && j > map.get(mx)) { val = d; idx = j; break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (idx == -1) {\n\t\t\t\t\t\t\tif (k == 1) for (int j = 0; j < s.length(); j ++) System.out.print(mx + 1);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < map.get(mx); j ++) System.out.print(s.charAt(j));\n\t\t\t\t\t\t\t\tSystem.out.print(mx + 1);\n\t\t\t\t\t\t\t\tfor (int j = map.get(mx) + 1; j < s.length(); j ++) System.out.print(min);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (map.get(val) != idx) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < idx; j ++) System.out.print(s.charAt(j));\n\t\t\t\t\t\t\t\tSystem.out.print(map.higherKey(val));\n\t\t\t\t\t\t\t\tfor (int j = idx + 1; j < s.length(); j ++) System.out.print(min);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < idx; j ++) System.out.print(s.charAt(j));\n\t\t\t\t\t\t\t\tSystem.out.print(val + 1);\n\t\t\t\t\t\t\t\tif (!map.containsKey(val + 1)) {\n\t\t\t\t\t\t\t\t\tif (min == val) for (int j = idx + 1; j < s.length(); j ++) System.out.print(val + 1);\n\t\t\t\t\t\t\t\t\telse for (int j = idx + 1; j < s.length(); j ++) System.out.print(min);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (int j = idx + 1; j < s.length(); j ++) System.out.print(0);\n\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint c = map.ceilingKey(x), min = map.firstKey();\n\t\t\t\t\t\tfor (int j = 0; j < i; j ++) System.out.print(s.charAt(j));\n\t\t\t\t\t\tSystem.out.print(c);\n\t\t\t\t\t\tfor (int j = i + 1; j < s.length(); j ++) System.out.print(min);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if (!map.containsKey(x)) map.put(x, i);\n\t\t\t}\n\t\t\tSystem.out.println(n);\n\t\t}\n\t}\n \n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\treturn st.nextToken();\n\t}\n\tstatic long readLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic double readDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tstatic char readCharacter() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tstatic String readLine() throws IOException {\n\t\treturn br.readLine().trim();\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n                      \n            \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n        \nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n \n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        depth = (stop - start).bit_length() - 1\n        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])\n \n    def __getitem__(self, idx):\n        return self._data[0][idx]\n \n \ndef check(st, n, k):\n    for i in range(n-k+1):\n        g = st.query(i, i+k)\n        if(g > 1):\n            return True \n    return False\n \n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfrom collections import defaultdict,deque\nfrom math import ceil,floor,sqrt,log2,gcd,pi\nfrom heapq import heappush,heappop\nfrom fractions import Fraction\nfrom bisect import bisect_left,bisect,bisect_right\nfrom itertools import combinations_with_replacement,permutations\nimport sys\nabc='abcdefghijklmnopqrstuvwxyz'\nABC=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    arr=[int(i) for i in str(n)]\n    s=set()\n    l=len(arr)\n    pre=0\n    for _ in range(1000):\n        pre=0\n        # print(n)\n        arr=[int(i) for i in str(n)]\n        s=set()\n        l=len(arr)\n        le=0\n        for i in arr:\n            if i in s:\n                le+=1\n                pre=pre*10+i\n            elif len(s)<k:\n                s.add(i)\n                le+=1\n                pre=pre*10+i\n            else:\n                pre=pre*10+i\n                pre+=1\n                # print(pre)\n                lp=len(str(pre))\n                pre=pre*(10**(l-lp))\n                n=pre\n                break\n        if le==l:\n            print(pre)\n            break"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class Main\n{\n    static String go(int i,int n,int dist,String nw,int k,String ori){\n        if(dist>k){\n            return \"\";\n        }\n        if((nw.substring(0,i)).compareTo(ori.substring(0,i))<0){\n            return \"\";\n        }\n        if(i>=n){\n            return nw;\n        }\n        for(char val='0';val<='9';++val){\n            nw = nw.substring(0,i)+val+nw.substring(i+1);//replacing val at index i in string nw\n            boolean found=false;\n            for(int j=0;j<i;++j){\n                if(nw.charAt(j)==val){\n                    found=true;\n                    break;\n                }\n            }\n            String chk;\n            if(found==false){\n                chk=go(i+1,n,dist+1,nw,k,ori);\n            }else{\n                chk=go(i+1,n,dist,nw,k,ori);\n            }\n            if(chk.length()!=0){\n                return chk;\n            }\n        }\n        return \"\";\n    }\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint test=sc.nextInt();\n\t\tsc.nextLine();\n\t\twhile((test--)>0){\n\t\t    int n=sc.nextInt();\n\t\t    int k=sc.nextInt();\n\t\t    String s=String.valueOf(n);\n\t\t    String str=\"\";\n\t\t    for(int i=0;i<s.length();i++){\n\t\t        str=str+\"0\";\n\t\t    }\n\t\t    String ans=go(0,s.length(),0,str,k,s);\n\t\t    System.out.println(ans);\n\t\t}\n\t}\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1>\nvoid dbg_pr(vector<T1> V, int add = 0, int start = -1, int end = -1) {\n  cout << \"{\";\n  if (start < 0) start = 0;\n  if (end < 0) end = V.size() - 1;\n  for (int i = start; i <= end; i++) {\n    cout << V[i] + add << ((i == end) ? \"}\" : \" \");\n  }\n}\nvoid dbg_pr(string V) { cout << \"\\\"\" << V << \"\\\"\"; }\ntemplate <typename T1>\nvoid dbg_pr(T1 V) {\n  cout << V;\n}\ntemplate <typename T1, typename T2>\nvoid dbg_pr(map<T1, T2> M) {\n  cout << \"{\";\n  for (const auto m : M) {\n    dbg_pr(m.first);\n    cout << \":\";\n    dbg_pr(m.second);\n    cout << \",\";\n  }\n  cout << \"}\";\n}\nvoid debug_out() { cout << \"\\033[0m\\n\"; }\ntemplate <typename T1, typename... T2>\nvoid debug_out(T1 A, T2... B) {\n  cout << \" \";\n  dbg_pr(A);\n  debug_out(B...);\n}\nint test = 1;\nvoid setupFastCin() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n}\ntemplate <typename T1>\nT1 chmin(T1 &x, const T1 v) {\n  return x = min(x, v);\n}\ntemplate <typename T1>\nT1 chmax(T1 &x, const T1 v) {\n  return x = max(x, v);\n}\ntemplate <typename T1>\nvoid pr(vector<T1> V, int add = 0, int start = -1, int end = -1) {\n  if (start < 0) start = 0;\n  if (end < 0) end = V.size() - 1;\n  for (int i = start; i <= end; i++) {\n    cout << V[i] + add << ((i == end) ? \"\\n\" : \" \");\n  }\n}\ntemplate <typename T1>\nT1 gcd(const T1 &a, const T1 &b) {\n  if (a == 0 || b == 0) return a + b;\n  return gcd(b, a % b);\n}\nint K;\nstring S;\nlong long DP[11][2000][2];\nlong long dp(int i, int mask, int k, int comp, long long p) {\n  if (k > K) return LLONG_MAX;\n  if (i == S.size()) {\n    return 0;\n  }\n  if (DP[i][mask][comp] != -1) return DP[i][mask][comp];\n  int md = S[i] - '0';\n  long long sol = LLONG_MAX;\n  for (int d = 0; d < 10; d++) {\n    if (comp == 0 && d < md) continue;\n    int newMask = mask;\n    int newK = k;\n    if ((mask & (1 << d)) == 0) {\n      newMask += (1 << d);\n      newK++;\n    }\n    if (newK > K) continue;\n    int newC = comp;\n    if (comp == 0) newC = d > md ? 1 : 0;\n    long long s = dp(i + 1, newMask, newK, newC, p / 10);\n    if (s == LLONG_MAX) continue;\n    chmin(sol, d * p + s);\n    break;\n  }\n  return DP[i][mask][comp] = sol;\n}\nvoid solve() {\n  for (int i = 0; i < 11; i++)\n    for (int j = 0; j < 1025; j++) DP[i][j][0] = DP[i][j][1] = -1;\n  cin >> S >> K;\n  long long p = pow(10ll, S.size() - 1);\n  {\n    cout << dp(0, 0, 0, 0, p) << \"\\n\";\n    return;\n  };\n}\nint main() {\n  setupFastCin();\n  int T = 1;\n  cin >> T;\n  for (int t = 0; t < T; t++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys as _sys\n\n\ndef _main():\n    [tests_n] = _read_ints()\n    for i_test in range(tests_n):\n        [n, k] = _read_ints()\n        result = find_nearest_beautiful_number(lower_bound=n, k_parameter=k)\n        print(result)\n\n\ndef find_nearest_beautiful_number(lower_bound: int, k_parameter: int):\n    prefix = lower_bound\n    while not _is_beautiful(prefix, k_parameter):\n        if prefix % 10 == 0:\n            prefix //= 10  # the dropped digit can be any digit\n        else:\n            prefix += 1\n    \n    zeros_n = len(str(lower_bound)) - len(str(prefix))\n    tail_digit = '0' if _measure_k(prefix) < k_parameter else min(str(prefix))\n    tail = int(tail_digit * zeros_n) if zeros_n > 0 else 0\n    \n    return prefix * 10**zeros_n + tail\n\n\ndef _is_beautiful(x: int, k_parameter: int):\n    return _measure_k(x) <= k_parameter\n\n\ndef _measure_k(x: int):\n    assert x >= 1\n    return len(set(str(x)))\n\n\ndef _read_ints():\n    return map(int, _sys.stdin.readline().split())\n\n\nif __name__ == '__main__':\n    _main()\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = map(int, input().split())\n    s = str(n)\n    if k == 1:\n        if int(s[0] * len(s)) >= n:\n            print(s[0] * len(s))\n        else:\n            print(str(int(s[0]) + 1) * len(s))\n        continue\n\n    dg, prob = set(), False\n    for i, v in enumerate(s):\n        if v not in dg:\n            if len(dg) < k:\n                dg.add(v)\n            else:\n                prob = i\n                break\n\n    if not prob:\n        print(n)\n    else:\n        res, g = s[prob:], max(dg)\n        if int(str(g) * len(res)) >= int(res):\n            ans = s[:prob]\n            for i in range(prob, len(s)):\n                if s[i] in dg:\n                    ans += s[i]\n                else:\n                    ans += min(d for d in dg if d > s[i])\n                    omp = len(s) - len(ans)\n                    ans += min(dg) * omp\n                    break\n            print(ans)\n        else:\n            for i in range(prob-1, -1, -1):\n                if s[i] < g:\n                    prob = i\n                    break\n            if s[prob] in s[:prob]:\n                ans = s[:prob]\n                ans += min(d for d in dg if d > s[prob])\n                omp = len(s) - len(ans)\n                ans += min(dg) * omp\n\n            else:\n                dg.remove(s[prob])\n                ans = s[:prob]\n                nou = str(int(s[prob]) + 1)\n                ans += nou\n\n                if nou in dg:\n                    dg.add('0')\n                omp = len(s) - len(ans)\n                ans += min(dg) * omp\n\n            dg, k = set(), k - 1\n            for i, v in enumerate(s):\n                if v not in dg:\n                    if len(dg) < k:\n                        dg.add(v)\n                    else:\n                        prob = i\n                        break\n\n            ans2 = s[:prob]\n            nou = str(int(s[prob]) + 1)\n            ans2 += nou\n\n            dg.add(nou)\n            omp = len(s) - len(ans2)\n            ans2 += min(dg) * omp\n            print(min(ans, ans2))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chkMax(T &first, T second) {\n  if (second > first) first = second;\n}\ntemplate <typename T>\nvoid chkMin(T &first, T second) {\n  if (second < first) first = second;\n}\ntemplate <typename T>\ninline void read(T &f) {\n  f = 0;\n  T fu = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') {\n      fu = -1;\n    }\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    f = (f << 3) + (f << 1) + (c & 15);\n    c = getchar();\n  }\n  f *= fu;\n}\nconst int MAX_N = 2e5 + 10, MAX_M = 1e6 + 10;\nbool ok(string first, int k) {\n  sort(first.begin(), first.end());\n  int d = unique(first.begin(), first.end()) - first.begin();\n  return d <= k;\n}\nvoid solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  if (ok(n, k)) {\n    cout << n << '\\n';\n    return;\n  }\n  for (int i = n.size() - 1; i >= 0; i--) {\n    for (n[i]++; n[i] <= '9'; n[i]++) {\n      for (char j = '0'; j <= '9'; j++) {\n        for (int k = i + 1; k < n.size(); k++) {\n          n[k] = j;\n        }\n        if (ok(n, k)) {\n          cout << n << '\\n';\n          goto nex;\n        }\n      }\n    }\n  }\nnex:;\n  return;\n}\nint main() {\n  int T = 1;\n  read(T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class ACMIND\n{\n    static FastReader scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 2_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null,null,\"_\",1<<27)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n    static int min[][];\n    static void solve() throws IOException {\n        scan = new FastReader();\n        pw = new PrintWriter(System.out, true);\n        StringBuilder sb = new StringBuilder();\n\n        min = new int[1024][11];\n        for(int i=0;i<1024;i++) {\n            for(int j=0;j<=10;j++) {\n                min[i][j] = -1;\n                for(int k=j;k<10;k++) {\n                    if((i&(1<<k))!=0) {\n                        min[i][j] = k;\n                        break;\n                    }\n                }\n            }\n        }\n        int t = ni();\n        while (t-->0) {\n            int n = ni();\n            int k = ni();\n            long ans = Integer.MAX_VALUE;\n            for(int mask=2;mask<1024;++mask) {\n                if(Integer.bitCount(mask) == k) {\n                    // pl(\"mask: \"+mask+\" \"+get(n, mask));\n                    ans = min(ans, get(n, mask));\n\n                    long res = 0;\n                    int len = Integer.toString(n).length();\n                    while (len-->=0) {\n                        res = res*10 + min[mask][1];\n                    }\n                    ans = min(ans, res);\n                }\n            }\n            pl(ans);\n//            int actual = brute(n,k);\n//            if(ans!=actual) {\n//                pl(\"ERRRRR n: \"+n+\" k: \"+k+\" your: \"+ans+\" actu: \"+actual);\n//                System.exit(1);\n//            }\n        }\n\n        pw.flush();\n        pw.close();\n    }\n\n    static int brute(int n, int k) {\n        for(int i=n;;i++) {\n            int mask = 0;\n            int x = i;\n            while (x>0) {\n                mask |= (1<<(x%10));\n                x /= 10;\n            }\n\n            if(Integer.bitCount(mask) <= k) {\n                return i;\n            }\n        }\n    }\n\n    static long get(int n, int mask) {\n        String s = Integer.toString(n);\n        int len = s.length();\n        boolean as = false;\n        long res = 0;\n        for(int i=0;i<len;i++) {\n            if(as) {\n                res = res * 10 + min[mask][0];\n            }\n            else {\n                int d = min[mask][s.charAt(i) - '0'];\n                if(d==-1) {\n                    int idx = -1;\n                    for(int j=i-1;j>=0;--j) {\n                        if(min[mask][s.charAt(j) - '0' + 1]!=-1) {\n                            idx = j;\n                            break;\n                        }\n                    }\n\n                    if(idx==-1) {\n                        return Integer.MAX_VALUE;\n                    }\n                    else {\n                        long ans = 0;\n                        for(int j=0;j<idx;j++) {\n                            ans = (ans * 10 + (s.charAt(j) - '0'));\n                        }\n                        ans = ans * 10 + min[mask][s.charAt(idx) - '0' + 1];\n                        for(int j=idx+1;j<len;j++) {\n                            ans = (ans * 10 + min[mask][0]);\n                        }\n                        return ans;\n                    }\n                }\n                else {\n                    if(d>(s.charAt(i) - '0')) {\n                        as = true;\n                    }\n                    res = res * 10 + d;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    static void assert_in_range(String varName, int n, int l, int r) {\n        if (n >=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n    static void assert_in_range(String varName, long n, long l, long r) {\n        if (n>=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Set<Object> set)\n    {\n        pl(arrayName+\" : \");\n        for(Object o : set)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class FastReader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[1000000];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class NearestBeautifulNumberHardVersion {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = readInt();\n\t\t\n\t\twhile (t-- > 0) {\n\t\t\tint n = readInt(), k = readInt();\n\t\t\tSystem.out.println(solve(n, k));\n\t\t}\n\t}\n\t\n\tstatic int solve(int n, int k) {\n\t\tchar[] a = String.valueOf(n).toCharArray();\n\n\t\tHashSet<Character> s = new HashSet<Character>();\n\t\tfor (char c: a) s.add(c);\n\t\tif (s.size() <= k) return n;\n\t\t\n\t\ts.clear();\n\t\tint ptr = 0;\n\t\tfor (; ; ptr ++) {\n\t\t\ts.add(a[ptr]);\n\t\t\tif (s.size() > k) {\n\t\t\t\tif (a[ptr] == '9') ptr --;\n\t\t\t\ta[ptr] ++;\n\t\t\t\tfor (int i = ptr + 1; i < a.length; i ++) a[i] = '0';\n\t\t\t\tint val = 0;\n\t\t\t\tfor (int i = a.length - 1; i >= 0; i --) val += Math.pow(10, a.length - i - 1) * Character.getNumericValue(a[i]);\n\t\t\t\treturn solve(val, k);\n\t\t\t}\n\t\t}\n\t}\n \n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\treturn st.nextToken();\n\t}\n\tstatic long readLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic double readDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tstatic char readCharacter() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tstatic String readLine() throws IOException {\n\t\treturn br.readLine().trim();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long vis[10];\nvector<char> ans;\nstring f;\nlong long mx = -1;\nvoid go() {\n  string res = \"\";\n  vis[f[0] - '0']++;\n  string ff = f;\n  mx = max(mx, f[0] - '0' + 0ll);\n  for (int i = 0; i < f.size(); i++) {\n    if (f[i] - '0' > mx) {\n      bool flag = 0;\n      for (int j = res.size() - 1; j >= 1; j--) {\n        if (res[j] - '0' < mx) {\n          for (int k = 0; k <= 9; k++) {\n            if (k > res[j] - '0' && vis[k] > 0) {\n              res[j] = '0' + k;\n              flag = 1;\n              break;\n            }\n          }\n          if (flag == 0) break;\n          for (int k = 0; k <= j; k++) cout << res[k];\n          for (int k = j + 1; k < f.size(); k++) {\n            for (int z = 0; z <= 9; z++) {\n              if (vis[z] > 0) {\n                cout << z;\n                break;\n              }\n            }\n          }\n          return;\n        }\n      }\n      if (flag) return;\n      vis[ff[0] - '0']--;\n      if (vis[ff[0] - '0' + 1] == 0)\n        vis[ff[0] - '0' + 1]++;\n      else\n        vis[0]++;\n      ff[0]++;\n      cout << ff[0];\n      for (int j = 0; j < ff.size() - 1; j++) {\n        for (int z = 0; z <= 9; z++) {\n          if (vis[z] > 0) {\n            cout << z;\n            break;\n          }\n        }\n      }\n      return;\n    }\n    if (f[i] - '0' <= mx) {\n      for (int z = 0; z <= 9; z++) {\n        if (z >= f[i] - '0' && vis[z] > 0) {\n          res += ('0' + z);\n          if (z > f[i] - '0') {\n            mx = 1000;\n            if (i + 1 < f.size()) {\n              f[i + 1] = '0';\n              f[i + 1]--;\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n  cout << res;\n  return;\n}\nint main() {\n  long long Q;\n  cin >> Q;\n  while (Q--) {\n    mx = -1;\n    memset(vis, 0, sizeof vis);\n    ans.clear();\n    long long n, k;\n    cin >> n >> k;\n    string s = \"\";\n    while (n != 0) {\n      s += '0' + n % 10;\n      n /= 10;\n    }\n    reverse(s.begin(), s.end());\n    int i = 0;\n    for (i = 0; i < s.size(); i++) {\n      if (k == 1 && i == 0) break;\n      if (k == 1) {\n        while (i < s.size() && vis[s[i] - '0'] > 0) {\n          ans.push_back(s[i]);\n          i++;\n        }\n        break;\n      }\n      if (vis[s[i] - '0'] == 0) {\n        vis[s[i] - '0']++;\n        k--;\n        mx = max(mx, s[i] - '0' + 0ll);\n      }\n      ans.push_back(s[i]);\n    }\n    f = \"\";\n    for (int j = i; j < s.size(); j++) {\n      f += s[j];\n    }\n    for (int i = 0; i < ans.size(); i++) cout << ans[i];\n    if (f.size() > 0) go();\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  while (true) {\n    set<char> s;\n    for (auto c : n) s.insert(c);\n    if (s.size() <= k) return n;\n    s.clear();\n    int ptr = 0;\n    for (;; ptr++) {\n      s.insert(n[ptr]);\n      if (s.size() > k) {\n        while (n[ptr] == '9') ptr--;\n        n[ptr]++;\n        for (int i = ptr + 1; i < n.size(); i++) n[i] = '0';\n        break;\n      }\n    }\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) cout << solve() << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef findnext(c,dic):\n    for d in range(int(c)+1,10):\n        if str(d) in dic:  return str(d)\n\n\ndef nextdigit(c):\n    return str(int(c)+1)\n\ndef main(t):\n\n\n    n,k = map(int,input().split())\n    s = list(str(n))\n    m = len(s)\n    dic = {}\n    for c in s:  \n        if c not in dic: dic[c] = 0\n        dic[c] += 1\n\n    if len(dic)<=k:  \n        print(\"\".join(s))\n        return \n\n   \n    while len(dic)>k:\n#        print(s,dic) \n        dic[s[-1]] -= 1\n        if dic[s[-1]] == 0:  del dic[s[-1]]\n\n        while s[-1]=='9': \n            s.pop()\n            dic[s[-1]] -= 1\n            if dic[s[-1]]==0:  del dic[s[-1]]\n\n         \n        s[-1] = str(int(s[-1])+1)\n        if s[-1] not in dic:  dic[s[-1]] = 0\n        dic[s[-1]] += 1\n\n    if len(dic)<k:  ans = \"\".join(s) + \"0\"*(m-len(s))\n    else:  ans = \"\".join(s) + min(dic)*(m-len(s))\n\n\n    print(ans) \n\n\n\n\n\n\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = INT_MAX;\nlong long t, n, k, cnt, a[100005], b[100005], fr[100005];\nlong long build(long long poz) {\n  long long auxcnt = cnt;\n  if (cnt > k) {\n    return oo;\n  }\n  for (long long i = poz + 1; i <= a[0]; i++) {\n    b[i] = -1;\n    for (long long c = 0; c <= 9; c++) {\n      if (i == poz + 1 && c <= a[i]) {\n        continue;\n      }\n      if (fr[c] || (!fr[c] && cnt < k)) {\n        ++fr[c];\n        b[i] = c;\n        if (fr[c] == 1) {\n          ++cnt;\n        }\n        break;\n      }\n    }\n  }\n  for (long long i = poz + 1; i <= a[0]; i++) {\n    if (b[i] == -1) {\n      continue;\n    }\n    --fr[b[i]];\n  }\n  cnt = auxcnt;\n  long long val = 0;\n  for (long long i = 1; i <= poz; i++) {\n    val = val * 10 + a[i];\n  }\n  for (long long i = poz + 1; i <= a[0]; i++) {\n    if (b[i] == -1) {\n      return oo;\n    }\n    val = val * 10 + b[i];\n  }\n  return val;\n}\nvoid solve_test() {\n  cin >> n >> k;\n  for (long long i = 0; i <= 9; i++) {\n    fr[i] = 0;\n  }\n  cnt = 0;\n  long long aux = n;\n  a[0] = 0;\n  while (n) {\n    a[++a[0]] = n % 10;\n    b[a[0]] = n % 10;\n    n /= 10;\n  }\n  reverse(a + 1, a + a[0] + 1);\n  long long Min = build(0);\n  for (long long i = 1; i <= a[0]; i++) {\n    ++fr[a[i]];\n    if (fr[a[i]] == 1) {\n      ++cnt;\n    }\n    Min = min(Min, build(i));\n  }\n  cout << Min << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> t;\n  for (long long test = 1; test <= t; test++) {\n    solve_test();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Solution {\n    public static  boolean validate(int[] res, int len, int k) {\n        Set<Integer> chose = new HashSet<>();\n        for (int i = 0; i <= len; ++i) {\n            chose.add(res[i]);\n        }\n        return chose.size() <= k;\n    }\n\n    // 1771890\n    public static String analyze(int n, int k) {\n        String result = \"\";\n        String s = \"\" + n;\n        Set<Integer> choose = new HashSet<>();\n        int len = s.length();\n        int[] res = new int[len];\n        for (int i = 0; i < len; ++i) {\n            res[i] = s.charAt(i) - '0';\n            if (!validate(res, i, k)) {\n                do {\n                    if (res[i] == 9) {\n                        i--;\n                    }\n                    res[i]++;\n                } while (!validate(res, i, k));\n                // fill the rest by the min value\n                int min = Integer.MAX_VALUE;\n                for (int j = 0; j <= i; ++j) {\n                    if (res[j] < min) {\n                        min = res[j];\n                    }\n                    choose.add(res[j]);\n                }\n                min = choose.size() < k ? 0 : min;\n                for (int j = i+1; j < len; ++j) {\n                    res[j] = min;\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < len; ++i) {\n            result += res[i];\n        }\n        return result;\n    }\n\n    public static List<Integer> number = new ArrayList<>();\n    public static Set<Integer> used = new HashSet<>();\n    public static int solve(int n, int k) {\n        res = 0;\n        number.clear();\n        used.clear();\n        while (n > 0) {\n            number.add(0, n % 10);\n            n /= 10;\n        }\n        return getResult(0, k, true);\n    }\n\n    public static int res = 0;\n    public static int getResult(int idx, int k, boolean match) {\n        if (idx >= number.size()) {\n            return res;\n        }\n        int curr = number.get(idx);\n        for (int i = 0; i < 10; ++i) {\n            if (match && i < curr) continue;\n            if (used.size() == k && !used.contains(i)) continue;\n            boolean isExist = used.contains(i);\n            used.add(i);\n            res = res * 10 + i;\n            int tmp = getResult(idx + 1, k , match && i == curr);\n            if (!isExist) used.remove(i);\n            if (tmp != -1) {\n                return res;\n            }\n            res /= 10;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCase = scanner.nextInt();\n        while (testCase-- > 0) {\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            System.out.println(solve(n, k));\n        }\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys;t = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split();n = n.lstrip(\"000000000\");k = int(k);L = []\n    for s in n:\n        if int(s) not in L:L.append(int(s))\n    if len(L) <= k:print(n)\n    else:\n        L = L[:k];Num = list(map(int, n));ind = Num.index(L[-1]);maxL = max(L);bada = False;i = 0\n        while i < len(n):\n            if bada:Num[i] = 0\n            else:\n                if Num[i] > maxL:\n                    bada = True\n                    while Num[i] + 1 > maxL and i > ind:i -= 1\n                    Num[i] += 1\n                    if i == ind:\n                        L[-1] += 1\n                        if L[-1] in L[:-1]:L[-1] = 0\n                elif Num[i] not in L:bada = True\n            i += 1\n        L.sort();Go = dict();ind = 0\n        for i in range(L[-1] + 1):\n            while i > L[ind]:ind += 1\n            Go[i] = str(L[ind])\n        minL = str(L[0]);bada = False\n        for i in range(len(Num)):\n            if bada == True:Num[i] = minL\n            else:\n                if Num[i] not in L:bada = True\n                Num[i] = Go[Num[i]]\n        print(int(''.join(Num)))"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\n\n\n\npublic class cc {\n\t\n\tprivate class Pair{\n\t\tArrayList<String> a = new ArrayList<>();\n\t\t\n\t}\n\t\n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\t\n\tprivate static FastReader sc =new FastReader();\n\t\n\tpublic static void main(String[] args) {\n\t\tint t = sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tprivate static void solve() {\n\t\tchar n[] = (sc.next()).toCharArray();\n\t\tint k = sc.nextInt();\n\t\twhile(true) {\n//\t\t\tSystem.out.println(k+\" \"+new String(n));\n\t\t\tSet<Character> s = new HashSet<>();\n\t\t\tfor(int i=0; i<n.length; i++) {\n\t\t\t\ts.add(n[i]);\n\t\t\t}\n\t\t\tif(s.size()<=k) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ts = new HashSet<>();\n\t\t\tfor(int ptr = 0; ptr<n.length; ptr++){\n\t\t\t\ts.add(n[ptr]);\n//\t\t\t\tSystem.out.println(s.size());\n\t\t\t\tif(s.size() > k) {\n\t\t\t\t\twhile(n[ptr]=='9') {\n\t\t\t\t\t\tptr--;\n\t\t\t\t\t}\n\t\t\t\t\tn[ptr]++;\n\t\t\t\t\tfor(int j=ptr+1; j<n.length; j++) {\n\t\t\t\t\t\tn[j] = '0';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic final class Main {\n\n    static PrintWriter out = new PrintWriter(System.out);\n    static FastReader in = new FastReader();\n    static Pair[] moves = new Pair[]{new Pair(-1, 0), new Pair(1, 0), new Pair(0, -1), new Pair(0, 1)};\n\n    public static void main(String[] args) {\n        int tt = i();\n        int mod = (int) (1e9 + 7);\n\n        loop:\n        while (tt-- > 0) {\n            int n = i();\n            int k = i();\n            char[] chars = String.valueOf(n).toCharArray();\n\n            out:\n            while (true){\n                Set<Character> s = new HashSet<>();\n                for (char c : chars) {\n                    s.add(c);\n                }\n                if (s.size() <= k) {\n                    break;\n                }\n                s.clear();\n\n                int ptr = 0;\n                for (; ; ptr++) {\n                    s.add(chars[ptr]);\n                    if (s.size() > k) {\n                        while (chars[ptr] == '9') {\n                            ptr--;\n                        }\n                        chars[ptr]++;\n                        for (int i = ptr + 1; i < chars.length; i++) {\n                            chars[i] = '0';\n                        }\n                        break;\n                    }\n                }\n            }\n            out.println(new String(chars));\n        }\n        out.flush();\n    }\n\n    static int[] pre(int[] a) {\n        int[] pre = new int[a.length];\n        pre[0] = a[0];\n        for (int i = 1; i < a.length; i++) {\n            pre[i] = pre[i - 1] + a[i];\n        }\n        return pre;\n    }\n\n    static int[] preRev(int[] a) {\n        int[] pre = new int[a.length];\n        pre[a.length - 1] = a[a.length - 1];\n        for (int i = a.length - 2; i >= 0; i--) {\n            pre[i] = pre[i + 1] + a[i];\n        }\n        return pre;\n    }\n\n    static void print(char A[]) {\n        for (char c : A) {\n            out.print(c);\n        }\n        out.println();\n    }\n\n    static void print(boolean A[]) {\n        for (boolean c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(int A[]) {\n        for (int c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(long A[]) {\n        for (long i : A) {\n            out.print(i + \" \");\n        }\n        out.println();\n    }\n\n    static void print(List<Integer> A) {\n        for (int a : A) {\n            out.print(a + \" \");\n        }\n    }\n\n    static void printYes() {\n        out.println(\"YES\");\n    }\n\n    static void printNo() {\n        out.println(\"NO\");\n    }\n\n    static int i() {\n        return in.nextInt();\n    }\n\n    static long l() {\n        return in.nextLong();\n    }\n\n    static String s() {\n        return in.nextLine();\n    }\n\n    static int[][] inputWithIdx(int N) {\n        int A[][] = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            A[i] = new int[]{i, in.nextInt()};\n        }\n        return A;\n    }\n\n    static int[] input(int N) {\n        int A[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        return A;\n    }\n\n    static long[] inputLong(int N) {\n        long A[] = new long[N];\n        for (int i = 0; i < A.length; i++) {\n            A[i] = in.nextLong();\n        }\n        return A;\n    }\n\n    static int GCD(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long LCM(int a, int b) {\n        return (long) a / GCD(a, b) * b;\n    }\n\n    static long LCM(long a, long b) {\n        return a / GCD(a, b) * b;\n    }\n\n    static void shuffleAndSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static void shuffleAndSort(int[][] arr, Comparator<? super int[]> comparator) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int[] temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr, comparator);\n    }\n\n    static void shuffleAndSort(long[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            long temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static boolean isPerfectSquare(double number) {\n        double sqrt = Math.sqrt(number);\n        return ((sqrt - Math.floor(sqrt)) == 0);\n    }\n\n    static void swap(int A[], int a, int b) {\n        int t = A[a];\n        A[a] = A[b];\n        A[b] = t;\n    }\n\n    static long pow(long a, long b, int mod) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow = (pow * x) % mod;\n            }\n            x = (x * x) % mod;\n            b /= 2;\n        }\n        return pow;\n    }\n\n    static long pow(long a, long b) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow *= x;\n            }\n            x = x * x;\n            b /= 2;\n        }\n        return pow;\n    }\n\n    static long modInverse(long x, int mod) {\n        return pow(x, mod - 2, mod);\n    }\n\n    static boolean isPrime(long N) {\n        if (N <= 1) {\n            return false;\n        }\n        if (N <= 3) {\n            return true;\n        }\n        if (N % 2 == 0 || N % 3 == 0) {\n            return false;\n        }\n        for (int i = 5; i * i <= N; i = i + 6) {\n            if (N % i == 0 || N % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    public static String repeat(char ch, int repeat) {\n        if (repeat <= 0) {\n            return \"\";\n        }\n        final char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    public static int[] manacher(String s) {\n        char[] chars = s.toCharArray();\n        int n = s.length();\n        int[] d1 = new int[n];\n        for (int i = 0, l = 0, r = -1; i < n; i++) {\n            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);\n            while (0 <= i - k && i + k < n && chars[i - k] == chars[i + k]) {\n                k++;\n            }\n            d1[i] = k--;\n            if (i + k > r) {\n                l = i - k;\n                r = i + k;\n            }\n        }\n        return d1;\n    }\n}\n\nclass Pair {\n\n    int i, j;\n\n    Pair(int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n}\n\nclass FastReader {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//Created by Aminul on 18/8/21.\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class F2 {\n    static long pow[];\n    static int[] arr;\n    static long[][][][][] dp = new long[11][2][2][11][1025];\n    static int[][][][][] vis = new int[11][2][2][11][1025];\n    static int tc;\n\n    public static void main(String[] args) throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        pow = new long[12];\n        pow[0] = 1;\n        for (int i = 1; i < pow.length; i++) {\n            pow[i] = pow[i - 1] * 10;\n        }\n\n        int test = in.nextInt();\n        for (int t = 1; t <= test; t++) {\n            tc = t;\n            int n = in.nextInt();\n            int k = in.nextInt();\n            String s = String.valueOf(n);\n            arr = new int[11];\n            for (int i = 0, j = s.length() - 1; j >= 0; j--, i++) {\n                arr[i] = s.charAt(j) - '0';\n            }\n\n            long res = solve(10, 0, 0, k, 0);\n            pw.println(res);\n        }\n\n        pw.close();\n    }\n\n    static long solve(int i, int isLarge, int isNonZero, int rem, int mask) {\n        if (i < 0) {\n            return 0;\n        }\n        if (isLarge == 1) {\n            if (vis[i][isLarge][isNonZero][rem][mask] != 0) {\n                return dp[i][isLarge][isNonZero][rem][mask];\n            }\n        }\n\n        if (vis[i][isLarge][isNonZero][rem][mask] == tc) {\n            return dp[i][isLarge][isNonZero][rem][mask];\n        }\n\n        vis[i][isLarge][isNonZero][rem][mask] = tc;\n\n        long res = Integer.MAX_VALUE;\n        int x = arr[i];\n        for (int d = 0; d < 10; d++) {\n            if (isLarge == 0 && d < x) {\n                continue;\n            }\n            if (rem == 0 && !check(mask, d)) {\n                continue;\n            }\n            int nextIsLarge = isLarge | ((d > x) ? 1 : 0);\n            int nextNonZero = isNonZero | ((d != 0) ? 1 : 0);\n            int nextMask = nextNonZero == 0 ? mask : set(mask, d);\n            int nextRem = nextNonZero == 0 ? rem : (check(mask, d) ? rem : rem - 1);\n\n            res = min(res, (d * pow[i]) + solve(i - 1, nextIsLarge, nextNonZero, nextRem, nextMask));\n        }\n\n        //debug(i, res);\n        dp[i][isLarge][isNonZero][rem][mask] = res;\n        return res;\n    }\n\n\n    static boolean check(int N, int pos) {\n        return (N & (1 << pos)) != 0;\n    }\n\n    static int set(int N, int pos) {\n        return N = N | (1 << pos);\n    }\n\n    static int reset(int N, int pos) {\n        return N = N & ~(1 << pos);\n    }\n\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens())\n                    tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                return null;\n            }\n\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst int MAX = 1e3 + 5;\nconst long long MOD = 998244353;\nconst long long MOD2 = 2010405347;\nconst long long INF = 2e18;\nconst int dr[] = {1, 0, -1, 0, 1, 1, -1, -1, 0};\nconst int dc[] = {0, 1, 0, -1, 1, -1, 1, -1, 0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 315;\ninline long long pw(long long x, long long y, long long md = MOD) {\n  long long ret = 1;\n  x %= md;\n  while (y) {\n    if (y & 1) ret = ret * x % md;\n    x = x * x % md, y >>= 1;\n  }\n  return ret;\n}\ninline void add(int &a, int b, int md = MOD) {\n  a = a + b >= md ? a + b - md : a + b;\n}\nint tc, n, k, dp[10][1024][2], pre[1024], x[15];\nstring s;\nbool f(int nw, int mask, bool st) {\n  if (pre[mask] > k) return false;\n  if (nw == n) return true;\n  int &ret = dp[nw][mask][st];\n  if (ret != -1) return ret;\n  if (st) {\n    for (int i = (0); i <= (9); ++i)\n      if (f(nw + 1, mask | (1 << i), 1)) return ret = true;\n  } else {\n    if (f(nw + 1, mask | (1 << x[nw]), 0)) return ret = true;\n    for (int i = (x[nw] + 1); i <= (9); ++i)\n      if (f(nw + 1, mask | (1 << i), 1)) return ret = true;\n  }\n  return ret = false;\n}\nvoid bt(int nw, int mask, bool st) {\n  if (nw == n) return;\n  if (st) {\n    for (int i = (0); i <= (9); ++i)\n      if (f(nw + 1, mask | (1 << i), 1)) {\n        cout << i;\n        bt(nw + 1, mask | (1 << i), 1);\n        return;\n      }\n  } else {\n    if (f(nw + 1, mask | (1 << x[nw]), 0)) {\n      cout << x[nw];\n      bt(nw + 1, mask | (1 << x[nw]), 0);\n      return;\n    }\n    for (int i = (x[nw] + 1); i <= (9); ++i)\n      if (f(nw + 1, mask | (1 << i), 1)) {\n        cout << i;\n        bt(nw + 1, mask | (1 << i), 1);\n        return;\n      }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  for (int i = (0); i <= (1023); ++i) pre[i] = __builtin_popcount(i);\n  cin >> tc;\n  for (int ntc = (1); ntc <= (tc); ++ntc) {\n    cin >> s >> k;\n    n = s.size();\n    if (k == 10) {\n      cout << s << '\\n';\n      continue;\n    }\n    for (int i = (0); i < (n); ++i) x[i] = s[i] - '0';\n    memset(&dp, -1, sizeof dp);\n    f(0, 0, 0);\n    bt(0, 0, 0);\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport copy\n\nINF = 10**10\n\ndef digs(n):\n    ans = []\n    while n > 0:\n        ans.append(n % 10)\n        n //= 10\n    return list(reversed(ans))\n\ndef find_ans(n, k):\n    n_digs = digs(n)\n    if k == 1:\n        base = (10**len(n_digs)-1)//9\n        for d in range(1, 10):\n            if d*base >= n:\n                return d*base\n            \n        print(\"ANS NOT FOUND\")\n        sys.exit(1)\n\n    ans = INF\n    nums_found = set()\n    bad = False\n    prefix = 0\n    for i, d in enumerate(n_digs):\n        realLen = i\n\n        next_dig = d+1\n        while len(nums_found)+int(next_dig not in nums_found) > k:\n            next_dig += 1\n            if next_dig > 9:\n                break\n            \n        if next_dig <= 9:\n            new_prefix = prefix*10+next_dig\n            test_ans = new_prefix*10**(len(n_digs)-i-1)\n\n            new_nums_found = copy.deepcopy(nums_found)\n            new_nums_found.add(next_dig)\n            if len(new_nums_found) == k:\n                test_ans += min(new_nums_found)*(10**(len(n_digs)-i-1)-1)//9\n            ans = min(test_ans, ans)\n        \n        prefix *= 10\n        prefix += d\n        nums_found.add(d)\n        \n    if len(nums_found) <= k:\n        return n\n    return ans\n\n\nnums = (int(tok) for tok in sys.stdin.read().split())\nT = next(nums)\nfor _ in range(T):\n    n = next(nums)\n    k = next(nums)\n    \n    print(find_ans(n, k))\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Sol{\n \n/*   \n->check n=1, int overflow , array bounds , all possibilites(dont stuck on 1 approach)\n->Problem = Observation(constraints(m<=n/3 or k<=min(100,n)) \n           + Thinking + Technique (seg_tree,binary lift,rmq,bipart,dp,connected comp etc)\n->solve or leave it (- tutorial improves you in minimal way -)\n*/\n \npublic static void main (String []args) {\n//precomp();\n \nint times=ni();while(times-->0){solve();}out.close();}\n \nstatic void solve() {\n int n=ni();int k=ni();\n\n int len=length(n);\n int a[]=new int[len];\n int cn=n;\n\n for(int i=len-1;i>=0;i--){a[i]=cn%10;cn/=10;}\n //edge case \n \n if(valid(n,k)){out.println(n);return;}\n\n for(int i=len-1;i>=0;i--){\n    int ans=get(a,i,k,n);\n    if(ans==0){}\n    else{out.println(ans);return;}\n }\n \n return;}\nstatic boolean valid (int n,int k){\n   HashSet<Integer> hs=new HashSet<>();while(n>0){hs.add(n%10);n/=10;}return hs.size()<=k;\n }\nstatic int length(int n){int c=0;while(n>0){n/=10;c++;}return c;} \n\n//1 5 7 8 9 k=3 => 1 5 7 1 1 => 1 5 8 1 1\n//1 5 7 2 2 k=3 > 1 5 7 5 1\n\nstatic int get(int a[],int p,int k,int n){\n   \n    int len=a.length; \n    a[p]++;\n   \n    while(a[p]<=9){\n      HashSet<Integer> hs=new HashSet<>();int input=0;int min=10;\n      for(int i=0;i<=p;i++){input=10*input+a[i];min=Math.min(a[i],min);hs.add(a[i]);}\n     \n      int size=hs.size();\n      int rem=len-p-1;\n      \n      if( k >= size ){ \n         \n         if(!hs.contains(0)&&k>=size+1){min=0;}\n         while(rem>0){input=10*input+min;rem--;}\n         return input;\n      }\n      else{}\n\n    a[p]++;}\n \n    return 0;\n }\n//-----------------Utility--------------------------------------------\n \nstatic class Pair{int id,last;Pair(int id,int last){this.id=id;this.last=last;}}\n \nstatic long gcd(long a,long b){if(b==0)return a; return gcd(b,a%b);}\n \nstatic int Max=Integer.MAX_VALUE; static long mod=1000000007;\n \n//static int v(char c){return (int)(c-'a');}\n \npublic static long power(long x, long y )\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%mod;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y >>= 1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n \n/*static class Pair implements Comparable<Pair>{\n        int id;int value;Pair next;\n        public Pair(int id,int value) {\n         \n          this.id=id;this.value=value;next=null;\n        }\n        @Override\n        public int compareTo(Pair p){return Long.compare(value,p.value);}\n    }\n*/\n \n//----------------------I/O---------------------------------------------\n \nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n \nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = \"\"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\n/*static int ni() {\n        try {\n            boolean in = false;\n            int res = 0;\n            for (;;) {\n                int b = System.in.read() - '0';\n                if (b >= 0) {\n                    in = true;\n                    res = 10 * res + b;\n                }\n                else if (in)\n                    return res;\n            }\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n    }*/\nstatic int ni(){return in.nextInt();}\nstatic long nl(){return in.nextLong();}\nstatic double nd(){return in.nextDouble();}\nstatic String ns(){return in.nextLine();}\n}"
        },
        {
            "language": 3,
            "solution": "def naiveSolve():\n    \n\n    \n    return\n\ndef solve(n,k):\n    narr=[]\n    n2=n\n    while n2>0:\n        narr.append(n2%10)\n        n2//=10\n    narr.reverse()\n    \n    ansarr=narr.copy()\n    while len(set(ansarr))>k:\n        ansarr[-1]+=1\n        while ansarr[-1]==10:\n            ansarr.pop()\n            ansarr[-1]+=1\n    if len(set(ansarr))<k:\n        append=0\n    else:\n        append=min(ansarr)\n    while len(ansarr)<len(narr):\n        ansarr.append(append)\n        \n        \n    ans=0\n    for x in ansarr:\n        ans*=10\n        ans+=x\n    return ans\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,k=readIntArr()\n        ans=solve(n,k)\n        allans.append(ans)\n    multiLineArrayPrint(allans)\n    \n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 4,
            "solution": "// Don't place your source in a package\n\n\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        //reading /writing file\n        //Scanner sc=new Scanner(new File(\"input.txt\"));\n        //PrintWriter pr=new PrintWriter(\"output.txt\");\n\n\n\n        int T=Int();\n        for(int t=0;t<T;t++){\n            int n=Int();\n            int k=Int();\n\n            Solution sol1=new Solution(out);\n            sol1.solution(n,k);\n        }\n        out.close();\n\n    }\n\n\n    public static int[] Arr(int n){\n        int A[]=new int[n];\n        for(int i=0;i<n;i++)A[i]=Int();\n        return A;\n    }\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\n\n\nclass Solution {\n    PrintWriter out;\n    int INF = Integer.MAX_VALUE;\n    int MOD = 1000000007;\n    long mod = 1000000007;\n\n    public Solution(PrintWriter out) {\n        this.out = out;\n    }\n\n\n    public void solution(int n,int k) {\n        long res=Long.MAX_VALUE;\n        String s= n+\"\";\n        char A[]=s.toCharArray();\n\n        Set<Character>set=new HashSet<>();\n        for(char c:A)set.add(c);\n        if(set.size()<=k){\n            out.println(n);\n            return;\n        }\n\n        int bit= 0 ;\n        long cur = 0;\n        for(int i=0;i<A.length;i++){\n            int d = A[i]-'0';\n            int cnt = Integer.bitCount(bit);\n            if(cnt>k)break;\n\n            for(int j = d+1;j<=9;j++){\n                int newb=bit|(1<<j);\n                if(Integer.bitCount(newb)<=k){\n                    if(Integer.bitCount(newb)<k){\n                        long temp=cur*10+j;\n                        for(int x=i+1;x<A.length;x++){\n                            temp=temp*10+0;\n                        }\n                        res=Math.min(res,temp);\n                    }\n                    else{\n\n                        int mn = 100;\n                        for(int x=0;x<10;x++){\n                            if((newb&(1<<x))!=0){\n                                mn=x;\n                                break;\n                            }\n                        }\n\n                        long temp=cur*10+j;\n                        for(int x=i+1;x<A.length;x++){\n                            temp=temp*10+mn;\n                        }\n                        res=Math.min(res,temp);\n                    }\n                }\n            }\n\n            bit=bit|(1<<d);\n            cur=cur*10+d;\n        }\n\n\n        out.println(res);\n    }\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Fread {\nconst int SIZE = 1 << 26;\nchar buf[SIZE], *S, *T;\ninline char getchar() {\n  if (S == T) {\n    T = (S = buf) + fread(buf, 1, SIZE, stdin);\n    if (S == T) return '\\n';\n  }\n  return *S++;\n}\n}  // namespace Fread\nnamespace Fwrite {\nconst int SIZE = 1 << 26;\nchar buf[SIZE], *S = buf, *T = buf + SIZE;\ninline void flush() {\n  fwrite(buf, 1, S - buf, stdout);\n  S = buf;\n}\ninline void putchar(char c) {\n  *S++ = c;\n  if (S == T) flush();\n}\nstruct NTR {\n  ~NTR() { flush(); }\n} ztr;\n}  // namespace Fwrite\nnamespace Fastio {\nstruct Reader {\n  template <typename T>\n  Reader& operator>>(T& x) {\n    char c = Fread ::getchar();\n    T f = 1;\n    while (c < '0' || c > '9') {\n      if (c == '-') f = -1;\n      c = Fread ::getchar();\n    }\n    x = 0;\n    while (c >= '0' && c <= '9') {\n      x = x * 10 + (c - '0');\n      c = Fread ::getchar();\n    }\n    x *= f;\n    return *this;\n  }\n  Reader& operator>>(char& c) {\n    c = Fread ::getchar();\n    while (c == '\\n' || c == ' ') c = Fread ::getchar();\n    return *this;\n  }\n  Reader& operator>>(char* str) {\n    int len = 0;\n    char c = Fread ::getchar();\n    while (c == '\\n' || c == ' ') c = Fread ::getchar();\n    while (c != '\\n' && c != ' ') {\n      str[len++] = c;\n      c = Fread ::getchar();\n    }\n    str[len] = '\\0';\n    return *this;\n  }\n  Reader() {}\n} cin;\nconst char endl = '\\n';\nstruct Writer {\n  template <typename T>\n  Writer& operator<<(T x) {\n    if (x == 0) {\n      Fwrite ::putchar('0');\n      return *this;\n    }\n    if (x < 0) {\n      Fwrite ::putchar('-');\n      x = -x;\n    }\n    static int sta[45];\n    int top = 0;\n    while (x) {\n      sta[++top] = x % 10;\n      x /= 10;\n    }\n    while (top) {\n      Fwrite ::putchar(sta[top] + '0');\n      --top;\n    }\n    return *this;\n  }\n  Writer& operator<<(char c) {\n    Fwrite ::putchar(c);\n    return *this;\n  }\n  Writer& operator<<(char* str) {\n    int cur = 0;\n    while (str[cur]) Fwrite ::putchar(str[cur++]);\n    return *this;\n  }\n  Writer& operator<<(const char* str) {\n    int cur = 0;\n    while (str[cur]) Fwrite ::putchar(str[cur++]);\n    return *this;\n  }\n  Writer() {}\n} cout;\n}  // namespace Fastio\nint n, T, k;\nbitset<10> b;\nbool B(int n) {\n  b.reset();\n  while (n) {\n    b[n % 10] = 1;\n    n /= 10;\n  }\n  return b.count() <= k;\n}\nsigned main() {\n  for (Fastio ::cin >> T; T; T--) {\n    Fastio ::cin >> n >> k;\n    while (!B(n)) {\n      int l = 1, r = n;\n      while (!B(r)) l *= 10, r /= 10;\n      l /= 10;\n      n = (n / l + 1) * l;\n    }\n    Fastio ::cout << n << Fastio ::endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def f(n,k):\n    dig_set = set()\n    pre = ''\n    for x in n:\n        dig_set.add(x)\n        if len(dig_set)>int(k): \n            post_head = x\n            dig_set.remove(x)\n            break\n        pre += x\n        post_head=\"\"\n\n    post = n[len(pre):] \n\n    if post_head:\n        min_dig = min(dig_set)\n        poss_digs = {i for i in dig_set if i>x}\n        if poss_digs:\n            min_poss_dig = min(poss_digs)\n            ans = pre+min_poss_dig+min_dig*(len(post)-1)\n        else:\n            pre = str(int(pre)+1)\n            if len(set(pre))==int(k):\n                ans = pre+min(set(pre))*(len(post))\n            elif len(set(pre))<int(k):\n                ans = pre+\"0\"*(len(post))\n            else:\n                ans = f(pre+\"0\"*(len(post)),k)\n    else:\n        ans = pre\n    \n    return ans\n\nfor i in range(int(input())):\n    n,k = input().split()\n    print(f(n,k))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nint ans, ans1, fix[100], n1, n, k, raodd, cnt, t, pw[20], bo, cur, cntt, ff,\n    fi[20];\nvector<int> v, vv;\nsigned main() {\n  std::ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> t;\n  pw[0] = 1;\n  ans = 1e9;\n  for (int i = 1; i <= 10; i++) {\n    pw[i] = pw[i - 1] * 10;\n  }\n  while (t--) {\n    cin >> n >> k;\n    if (n == 1000000000) {\n      if (k == 1) {\n        cout << 1111111111 << endl;\n      } else\n        cout << 1000000000 << endl;\n      continue;\n    }\n    n1 = n;\n    for (int i = 0; i <= 9; i++) {\n      fix[i] = 0;\n    }\n    raodd = 0;\n    cntt = 0;\n    ans = 1e9;\n    while (n1) {\n      v.push_back(n1 % 10);\n      if (!fix[n1 % 10]) raodd++, fix[n1 % 10] = 1;\n      n1 /= 10;\n      cntt++;\n    }\n    reverse(v.begin(), v.end());\n    if (raodd <= k) {\n      cout << n << \" \";\n      continue;\n    }\n    for (int i = 1; i < (1 << 10); i++) {\n      vv.clear();\n      cnt = 0;\n      ans1 = 0;\n      for (int j = 0; j <= 9; j++) {\n        if ((1 << j) & i) {\n          vv.push_back(j);\n          cnt++;\n        }\n      }\n      for (int kk = 0; kk <= 9; kk++) fi[kk] = 0;\n      for (int kk = 0; kk < vv.size(); kk++) {\n        fi[vv[kk]] = 1;\n      }\n      if (cnt > k) continue;\n      for (int idx = 0; idx < cntt; idx++) {\n        bo = 0;\n        ans1 = 0;\n        ff = 0;\n        for (int jj = 0; jj < idx; jj++) {\n          if (fi[v[jj]])\n            ans1 += pw[cntt - jj - 1] * v[jj];\n          else {\n            bo = 1;\n            break;\n          }\n        }\n        if (bo) break;\n        ff = 0;\n        for (int kk = 0; kk < vv.size(); kk++) {\n          if (vv[kk] > v[idx]) {\n            ff = 1;\n            ans1 += pw[cntt - idx - 1] * vv[kk];\n            break;\n          }\n        }\n        if (!ff) continue;\n        for (int jj = idx + 1; jj < cntt; jj++) {\n          ans1 += pw[cntt - jj - 1] * vv[0];\n        }\n        if (ans1 < 0) continue;\n        ans = min(ans, ans1);\n      }\n    }\n    cout << ans << \" \";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# set vim: fdm=marker sw=4 ts=4 et\n\nfrom collections import defaultdict\nfrom collections import deque\nfrom sys import stdout\n\ndef get_digits(n):\n    digits = deque()\n    while n > 0:\n        digits.appendleft(n % 10)\n        n //= 10\n    return digits\n\ndef get_tail(s, k, n):\n    avail_digits = 10 - len(s)\n\n\ndef get_number(digits, left_unchanged, k):\n    s = set()\n    for i in range(left_unchanged):\n        s.add(digits[i])\n\n    if len(digits) == left_unchanged:\n        if len(s) <= k:\n            return int(''.join([str(i) for i in digits]))\n        else:\n            return -1\n\n    if len(s) > k:\n        return -1\n\n    for i in range(digits[left_unchanged] + 1, 10):\n        remove = i not in s\n        s.add(i)\n\n        j = 0\n        d = deque()\n        while j < 10 and len(s) + len(d) < k:\n            d.append(j)\n\n        if len(s) + len(d) != k or left_unchanged + 1 + len(d) > len(digits):\n            if remove:\n                s.remove(i)\n            continue\n\n        # min_s_d = min(list(s) + list(d))\n        min_s_d = None\n        for s_i in s:\n            if min_s_d is None or min_s_d > s_i:\n                min_s_d = s_i\n        for d_i in d:\n            if min_s_d is None or min_s_d > d_i:\n                min_s_d = d_i\n\n        while left_unchanged + 1 + len(d) < len(digits):\n            d.appendleft(min_s_d)\n\n        d2 = []\n        for j in range(left_unchanged):\n            d2.append(digits[j])\n        d2.append(i)\n        d2 += d\n        return int(''.join([str(i) for i in d2]))\n\n    return -1\n\n\ndef get_min_number(digits_count, k):\n    digits_count = max(digits_count, k)\n    digits = deque(range(2, k))\n    while len(digits) < digits_count - 1:\n        digits.appendleft(0)\n    digits.appendleft(1)\n    return ''.join([str(i) for i in digits])\n\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    digits = get_digits(n)\n\n    for i in range(len(digits), -1, -1):\n        ans = get_number(digits, i, k)\n        if ans >= n:\n            break\n\n    if ans < n:\n        ans = get_min_number(len(digits) + 1, k)\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "\ndef brute(n, k):\n    for i in range(int(n),  10 ** len(n)):\n        if len(set(str(i))) <= k:\n            return i\n\ndef strange(n, k):\n    if len(set(n)) <= k:\n        return int(n)\n    str_n = n\n    n = list(map(int, list(n)))\n    minn = float(\"inf\")\n\n    for i in range(len(n) - 1, -1, -1):\n        #firstvar = str_n[:(i+1)] + str(min(n[:(i+1)])) * (  (len(n) - 1) - i )\n        #boeti = min(filter(lambda x: x >= n[i], n[:i]))\n        #secondvar = str_n[:i] + str(n[i] + j) + str(min(n[:i] + [n[i] + j])) * (  (len(n) - 1) - i )\n        # lp = a[0:i], m = a[i], rp = a[i+1:n]\n        # if len(set(a[0:i])) > k: continue\n        # if len(set(a[0:i])) == k: check(lp, min(lp[lp >= m]), min(lp) )\n        # if len(set(a[0:i])) == (k - 1): check(lp, m, min(lp + [m])) and check(lp, min(lp[lp >= m]), 0 * len(rp)) and check(lp, m + 1, min(lp, m + 1))\n        # if len(set(a[0:i])) < (k - 1): check(lp, m, 0 * len(rp))\n        rp = len(n) - 1 - i\n        if len(set(n[0:i])) > k: \n            continue\n        if len(set(n[0:i])) == k:\n            ll = list(filter(lambda x: x > n[i], n[0:i]))\n            if  len(ll):\n                v1 = int( str_n[0:i] + str(min(ll)) + str(min(n[0:i])) * (len(n) - 1 - i) )\n                if v1 >= int(str_n) and v1 < minn:\n                    minn = v1\n        elif len(set(n[0:i])) == (k - 1):\n            v1 = int( str_n[0:i] + str(n[i]) + str(min(n[0:(i + 1)])) * (len(n) - 1 - i) )\n            ll = list(filter(lambda x: x > n[i], n[0:i]))\n            v2 = None\n            if len(ll):\n                v2 = int( str_n[0:i] + str(min( ll )) + \"0\" * (len(n) - 1 - i) )\n            v3 = int( str_n[0:i] + str(n[i] + 1) + str(min(n[0:i] + [ n[i] + 1 ])) * (len(n) - 1 - i) )\n            for v in [v1, v2, v3]:\n                if not v:\n                    continue\n                if v >= int(str_n) and v < minn:\n                    minn = v\n        else:\n            v1 = int( str_n[0:i] + str(n[i]) + str(min(n[0:(i + 1)])) * (len(n) - 1 - i) )\n            ll = list(filter(lambda x: x > n[i], n[0:i]))\n            v2 = None\n            if len(ll):\n                v2 = int( str_n[0:i] + str(min( ll )) + \"0\" * (len(n) - 1 - i) )\n            v3 = int( str_n[0:i] + str(n[i] + 1) + str(min(n[0:i] + [ n[i] + 1 ])) * (len(n) - 1 - i) )\n            v4 = int( str_n[0:i] + str(n[i]) + \"0\" * (len(n) - 1 - i) )\n            v5 = int( str_n[0:i] + str(n[i] + 1) + \"0\" * (len(n) - 1 - i) )\n            for v in [v1, v2, v3, v4, v5]:\n                if not v:\n                    continue\n                if v >= int(str_n) and v < minn:\n                    minn = v\n\n    return minn\n\n\n\n\n\n\nt = int(input())\nfor _ in range(t):\n    # x >= n; x has no more than k unique digits\n    # 9249429 -> 7922324\n    # if k == 1 we either xi + 1, and remaining fill with smallest we got before\n    # \n\n    n, k = input().split(\" \")\n    print(strange(n, int(k)))\n\n'''\ntests = [\n    (\"252258861\", 2),\n    (\"402143038\", 5),\n    (\"34215184\", 5),\n    (\"544627347\", 2),\n    (\"167346669\", 5),\n    (\"238084491\", 5)\n\n]\nfor nnn, k in tests:\n    s, b = strange(nnn, k), brute(nnn, k)\n    if s != b:\n        print(nnn, k, s, b)\n\n'''\n\n\"\"\"\n\nfor nnn in range(1, 10**9 + 1):\n    for k in range(1, 11):\n        s, b = strange(str(nnn), k), brute(str(nnn), k)\n        if s != b:\n            print(nnn, k, s, b)\n\"\"\""
        },
        {
            "language": 3,
            "solution": "for nt in range(int(input())):\n    n, k = map(int,input().split())\n    m = n\n    while len(set(str(n))) > k:\n        if n%10==0:\n            n = n//10\n        else:\n            n += 1\n    end = str(min(str(n))) * (len(str(m))-len(str(n)))\n    print (int(str(n)+end))"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\n\nt=int(input())\nfor tests in range(t):\n    n,k=map(int,input().split())\n\n    S=str(n)\n\n    x=\"\"\n    ANS=int(str(min(9,int(S[0])+1))*len(S))\n\n    for i in range(len(S)):\n        x+=S[i]\n\n        if len(set(x))>k:\n            break\n\n        #print(x)\n\n        if i==len(S)-1:\n            ANS=n\n\n        if i!=len(S)-1:\n            j=S[i+1]\n\n            for t in sorted(x):\n                if t>j:\n                    break\n            if t>j:\n\n                y=x+t\n\n                #print(x,t,y)\n\n                if len(set(y))==k:\n                    u=min(y)\n                else:\n                    u=\"0\"\n\n                ANS=min(ANS,int(y+u*(len(S)-len(y))))\n            \n        if i!=len(S)-1:\n            j=S[i+1]\n\n            if j==\"9\":\n                continue\n\n            y=x+str(int(j)+1)\n\n            if len(set(y))>k:\n                continue\n\n            if len(set(y))==k:\n                u=min(y)\n            else:\n                u=\"0\"\n\n            ANS=min(ANS,int(y+u*(len(S)-len(y))))\n\n        #print(x)\n\n\n\n    print(ANS)\n            \n\n    \n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {new Main().run();}\n\n    FastReader in = new FastReader();\n    PrintWriter out = new PrintWriter(System.out);\n    void run() {\n        for(int q=ni();q>0;q--){\n            work();\n        }\n        out.flush();\n    }\n    long mod=998244353;\n    long gcd(long a,long b) {\n        return a==0?b:gcd(b%a,a);\n    }\n    long inf=Long.MAX_VALUE/3;\n    void work() {\n        long n=nl();\n        int k=ni();\n        List<Integer> list=new ArrayList<>();\n        for(long v=n;v>0;v/=10){\n            list.add((int)(v%10));\n        }\n        int len=list.size();\n        int[] A=new int[list.size()];\n        for(int i=0;i<list.size();i++){\n            A[i]=list.get(list.size()-i-1);\n        }\n        int cnt=0;\n        int[] count=new int[10];\n        for(int i=0;i<len;i++){\n            count[A[i]]++;\n            if(count[A[i]]==1){\n                cnt++;\n            }\n        }\n        if(cnt<=k){\n            out.println(n);\n            return;\n        }\n        for(int i=len-1;i>=0;i--){\n            count[A[i]]--;\n            if(count[A[i]]==0){\n                cnt--;\n            }\n            if(cnt==k){\n                int min=10;\n                for(int j=0;j<i;j++){\n                    if(count[A[j]]>0){\n                        min=Math.min(min,A[j]);\n                    }\n                }\n                for(int j=1;j<=9;j++){\n                    if(count[j]>0&&j>A[i]){\n                        StringBuilder sb = new StringBuilder();\n                        for(int p=0;p<i;p++){\n                            sb.append(A[p]);\n                        }\n                        sb.append(j);\n                        for(int p=i+1;p<len;p++){\n                            sb.append(min);\n                        }\n                        out.println(sb.toString());\n                        return;\n                    }\n                }\n            }else if(cnt<k){\n                StringBuilder sb = new StringBuilder();\n                for(int j=0;j<i;j++){\n                    sb.append(A[j]);\n                }\n                sb.append(A[i]+1);\n                int min=0;\n                if(count[A[i]+1]==0){\n                    min=A[i]+1;\n                    for(int j=0;j<i;j++){\n                        if(count[A[j]]>0){\n                            min=Math.min(min,A[j]);\n                        }\n                    }\n                }\n                for(int j=i+1;j<len;j++){\n                    sb.append(min);\n                }\n                out.println(sb.toString());\n                return;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private ArrayList<Integer>[] ng(int n, int m) {\n        ArrayList<Integer>[] graph=(ArrayList<Integer>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            int s=in.nextInt()-1,e=in.nextInt()-1;\n            graph[s].add(e);\n            graph[e].add(s);\n        }\n        return graph;\n    }\n\n    private ArrayList<long[]>[] ngw(int n, int m) {\n        ArrayList<long[]>[] graph=(ArrayList<long[]>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            long s=in.nextLong()-1,e=in.nextLong()-1,w=in.nextLong();\n            graph[(int)s].add(new long[] {e,w});\n            graph[(int)e].add(new long[] {s,w});\n        }\n        return graph;\n    }\n\n    private int ni() {\n        return in.nextInt();\n    }\n\n    private long nl() {\n        return in.nextLong();\n    }\n    private double nd() {\n        return in.nextDouble();\n    }\n    private String ns() {\n        return in.next();\n    }\n\n    private long[] na(int n) {\n        long[] A=new long[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextLong();\n        }\n        return A;\n    }\n\n    private int[] nia(int n) {\n        int[] A=new int[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextInt();\n        }\n        return A;\n    }\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n    InputStreamReader input;//no buffer\n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public FastReader(boolean isBuffer)\n    {\n        if(!isBuffer){\n            input=new InputStreamReader(System.in);\n        }else{\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n    }\n\n    public boolean hasNext(){\n        try{\n            String s=br.readLine();\n            if(s==null){\n                return  false;\n            }\n            st=new StringTokenizer(s);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    public String next()\n    {   \n        if(input!=null){\n            try {\n                StringBuilder sb=new StringBuilder();\n                int ch=input.read();\n                while(ch=='\\n'||ch=='\\r'||ch==32){\n                    ch=input.read();\n                }\n                while(ch!='\\n'&&ch!='\\r'&&ch!=32){\n                    sb.append((char)ch);\n                    ch=input.read();\n                }\n                return sb.toString();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n        while(st==null || !st.hasMoreElements())//\u56de\u8f66\uff0c\u7a7a\u884c\u60c5\u51b5\n        {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt()\n    {\n        return (int)nextLong();\n    }\n\n    public long nextLong() {\n        try {\n            if(input!=null){\n                long ret=0;\n                int b=input.read();\n                while(b<'0'||b>'9'){\n                    b=input.read();\n                }\n                while(b>='0'&&b<='9'){\n                    ret=ret*10+(b-'0');\n                    b=input.read();\n                }\n                return ret;\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    vector<int> a(10, 0);\n    int k1 = k;\n    int pos = s.size();\n    for (int i = 0; i < s.size(); ++i) {\n      a[s[i] - '0']++;\n      if (a[s[i] - '0'] == 1) {\n        --k1;\n      }\n      if (k1 == -1) {\n        a[s[i] - '0']--;\n        pos = i;\n        break;\n      }\n    }\n    if (pos == s.size()) {\n      cout << s << '\\n';\n      continue;\n    }\n    int ch = -1;\n    char smth;\n    int zero = 0;\n    bool ok = 0;\n    for (int i = s[pos] - '0' + 1; i <= 9; ++i) {\n      if (a[i] > 0) {\n        ch = pos;\n        smth = i + '0';\n        ok = 1;\n        break;\n      }\n    }\n    if (!ok) {\n      for (int i = pos - 1; i >= 0; --i) {\n        if (a[s[i] - '0'] == 1 && s[i] != '9') {\n          ch = i;\n          a[s[i] - '0' + 1]++;\n          smth = s[i] + 1;\n          ok = 1;\n        } else\n          for (int j = s[i] - '0' + 1; j <= 9; ++j) {\n            if (a[j] > 0) {\n              ch = i;\n              smth = j + '0';\n              ok = 1;\n              break;\n            }\n          }\n        a[s[i] - '0']--;\n        if (ok) break;\n      }\n    }\n    if (ch != -1) {\n      char minn;\n      s[ch] = smth;\n      int cnt = 0;\n      for (int i = 0; i < 10; ++i) {\n        if (a[i] > 0) ++cnt;\n      }\n      for (int i = 0; i < 10; ++i) {\n        if (a[i] > 0) {\n          minn = i + '0';\n          break;\n        }\n      }\n      if (cnt < k) minn = '0';\n      for (int i = ch + 1; i < s.size(); ++i) {\n        s[i] = minn;\n      }\n      cout << s << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class F2 {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    static TreeSet<Integer> ts1,ts2;\n    \n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder ans=new StringBuilder(\"\");\n        \n        ts1=new TreeSet<>();\n        ts2=new TreeSet<>();\n        for(int i=0;i<10;i++) {\n            for(int j=0;j<10;j++) {\n                per(i,j,0);\n            }\n        }\n        \n        int test=input.scanInt();\n        for(int tt=1;tt<=test;tt++) {\n            int n=input.scanInt();\n            int k=input.scanInt();\n            \n//            int n=(int)(Math.random()*100000);\n//            int k=3;\n            \n            if(k==1) {\n                if(ts1.contains(n)) {\n                    ans.append(n+\"\\n\");\n                    continue;\n                }\n                ans.append(ts1.higher(n)+\"\\n\");\n                continue;\n            }\n            if(k==2) {\n                if(ts2.contains(n)) {\n                    ans.append(n+\"\\n\");\n                    continue;\n                }\n                ans.append(ts2.higher(n)+\"\\n\");\n                continue;\n            }\n            \n//            if(!(\"\"+solve(n,k)).equals(\"\"+check(n,k))) {\n//                System.out.println(n+\" \"+k+\" \"+solve(n,k)+\" \"+check(n,k));\n//            }\n            \n            ans.append(solve(n,k)+\"\\n\");\n        }\n        System.out.println(ans);\n    }\n    \n    public static StringBuilder solve(int n,int k) {\n        StringBuilder val=new StringBuilder(\"\");\n        String num=\"\"+n;\n        boolean dig[]=new boolean[10];\n        int indx=0,dig_cnt=0;\n        int gr[]=new int[num.length()];\n        boolean fst[]=new boolean[num.length()];\n        Arrays.fill(gr, -1);\n        while(dig_cnt<=k && indx<num.length()) {\n            \n            \n            if(dig[num.charAt(indx)-'0']) {\n                gr[indx]=0;\n                val.append(num.charAt(indx));\n                indx++;\n                continue;\n            }\n            if(dig_cnt==k) {\n                break;\n            }\n            fst[indx]=true;\n            gr[indx]=0;\n            val.append(num.charAt(indx));\n            dig[num.charAt(indx)-'0']=true;\n            dig_cnt++;\n            indx++;\n        }\n        if(indx==num.length()) {\n            return val;\n        }\n        \n        for(int i=indx;i<num.length();i++) {\n            for(int j=0;j<dig.length;j++) {\n                if(dig[j] && j==num.charAt(i)-'0') {\n                    gr[i]=0;\n                }\n                if(dig[j] && j>num.charAt(i)-'0') {\n                    gr[i]=1;\n                } \n            }\n        }\n        \n        int lst_indx=indx-1;\n        \n        for(int i=indx;i<num.length();i++) {\n            if(gr[i]==-1) {\n                break;\n            }\n            if(gr[i]==1) {\n                lst_indx=i;\n            }\n        }\n        \n        if(lst_indx>indx-1) {\n            boolean gre=false;\n            for(int i=indx;i<lst_indx;i++) {\n                for(int j=0;j<dig.length;j++) {\n                    if(dig[j] && j==num.charAt(i)-'0') {\n                        val.append(j);\n                        break;\n                    }\n                    if(dig[j] && j>num.charAt(i)-'0') {\n                        val.append(j);\n                        gre=true;\n                        break;\n                    }\n                }\n                if(gre) {\n                    break;\n                }\n            }\n            \n            if(gre) {\n                while(val.length()<num.length()) {\n                    for(int j=0;j<dig.length;j++) {\n                        if(dig[j]) {\n                            val.append(j);\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                for(int j=0;j<dig.length;j++) {\n                    if(dig[j] && j>num.charAt(lst_indx)-'0') {\n                        val.append(j);\n                        break;\n                    }\n                }\n                while(val.length()<num.length()) {\n                    for(int j=0;j<dig.length;j++) {\n                        if(dig[j]) {\n                            val.append(j);\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            \n            return val;\n        }\n        \n        \n        for(int i=val.length()-1;i>=0;i--) {\n            if(!fst[i]) {\n                boolean br=false;\n                for(int j=0;j<dig.length;j++) {\n                    if(dig[j] && j>(val.charAt(val.length()-1))-'0') {\n                        br=true;\n                        break;\n                    }\n                }\n                if(br) {\n                    break;\n                }\n            }\n\n            if(!fst[i]) {\n                val.deleteCharAt(val.length()-1);\n            }\n            else {\n                break;\n            }\n        }\n        \n        if(!fst[val.length()-1]) {\n            for(int j=0;j<dig.length;j++) {\n                if(dig[j] && j>(val.charAt(val.length()-1))-'0') {\n                    val.replace(val.length()-1, val.length(), \"\"+j);\n                    break;\n                }\n            }\n        }\n        else {\n            val.replace(val.length()-1, val.length(), \"\"+(char)(val.charAt(val.length()-1)+1));\n        }\n        \n        \n        dig=new boolean[10];\n        dig_cnt=0;\n        \n        indx=0;\n        while(indx<val.length()) {\n            if(dig[val.charAt(indx)-'0']) {\n                indx++;\n                continue;\n            }\n            dig[val.charAt(indx)-'0']=true;\n            dig_cnt++;\n            indx++;\n        }\n        \n        if(dig_cnt<k) {\n            dig[0]=true;\n        }\n        \n        while(val.length()<num.length()) {\n            for(int j=0;j<dig.length;j++) {\n                if(dig[j]) {\n                    val.append(j);\n                    break;\n                }\n            }\n        }\n        \n        return val;\n    }\n    \n    \n    public static void per(int a,int b,long val) {\n        if(val>Integer.MAX_VALUE) {\n            return;\n        }\n        if(val!=0) {\n            if(a==b) {\n                ts1.add((int)val);\n            }\n            ts2.add((int)val);\n        }\n        if(a!=0 || val!=0) {\n            per(a,b,(val*10)+a);\n        }\n        if(b!=0 || val!=0) {\n            per(a,b,(val*10)+b);\n        }\n    }\n    \n    public static int check(int n,int k) {\n        for(int i=n;i<=100000000;i++) {\n            if(distinct(i)<=k) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    public static int distinct(int n) {\n        boolean dig[]=new boolean[10];\n        while(n!=0) {\n            dig[n%10]=true;\n            n/=10;\n        }\n        int cnt=0;\n        for(int i=0;i<dig.length;i++) {\n            if(dig[i]) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n    \n}\n"
        },
        {
            "language": 3,
            "solution": "def main(t):\n \n \n    n,k = map(int, input().split())\n    s = str(n)\n    m = len(s)\n \n \n    dic = {}\n \n    ans = \"\"\n \n    for i in range(m):\n \n        if s[i] in dic:\n            dic[s[i]] += 1\n        else:\n            dic[s[i]] = 1\n      \n \n \n \n        if len(dic)==k and i<m-1:\n            if s[i+1:] >  max(dic)*(m-i-1):\n                dic[s[i]] -= 1\n                if dic[s[i]]==0:  del dic[s[i]] \n                if str(int(s[i])+1) in dic and len(dic)<k:\n                    ans += str(int(s[i])+1)\n                    ans += '0'*(m-i-1)\n                else:\n                    dic[str(int(s[i])+1)] = 1\n                    ans += str(int(s[i])+1)\n                    ans += min(dic)*(m-i-1)\n                break\n \n            else:\n                ans += s[i]\n                j = i + 1\n                while j<m and s[j] in dic: \n                    if j+1<m and s[j+1:]>max(dic)*(m-i-1):  break\n                    ans += s[j]\n                    j += 1\n \n                if j==m: break\n                for d in range(int(s[j])+1,10):\n                    if str(d) in dic: break\n                dic[str(d)] = 1\n                ans += str(d)\n                ans += min(dic)*(m-len(ans))\n                break\n \n                  \n \n        ans += s[i] \n \n    print(ans)\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1 \n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CF1560F2 extends PrintWriter {\n\tCF1560F2() { super(System.out); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1560F2 o = new CF1560F2(); o.main(); o.flush();\n\t}\n\n\tstatic final int A = 10;\n\tboolean[] used = new boolean[A];\n\tint count(byte[] cc, int n) {\n\t\tArrays.fill(used, false);\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = cc[i] - '0';\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid main() {\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tbyte[] cc = sc.next().getBytes();\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = cc.length;\n\t\t\tint cnt = count(cc, n);\n\t\t\tif (cnt > m)\n\t\t\t\tout: for (int i = n - 1; i >= 0; i--) {\n\t\t\t\t\tcnt = count(cc, i);\n\t\t\t\t\tif (cnt > m)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int a = cc[i] - '0' + 1; a < A; a++)\n\t\t\t\t\t\tif (cnt < m || cnt == m && used[a]) {\n\t\t\t\t\t\t\tif (!used[a]) {\n\t\t\t\t\t\t\t\tused[a] = true;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcc[i] = (byte) (a + '0');\n\t\t\t\t\t\t\tfor (a = 0; a < A && cnt < m; a++)\n\t\t\t\t\t\t\t\tif (!used[a]) {\n\t\t\t\t\t\t\t\t\tused[a] = true;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\t\twhile (!used[a])\n\t\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t\tArrays.fill(cc, i + 1, n, (byte) (a + '0'));\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tprintln(new String(cc));\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n// 1900\npublic class NearestBeautifulNumberEasy {\n\n    static ArrayList<Character> getDigits(int x) {\n        var xs = (\"\"+x).toCharArray();\n        var digits = new ArrayList<Character>();\n        for (int i = 0; i < xs.length; i++){\n            var c = xs[i];\n            if (!digits.contains(c)) {\n                digits.add(c);\n            }\n        }\n        Collections.sort(digits);\n        return digits;\n    }\n\n    static int charArrayToInt(char[] xs) {\n        int result = 0;\n        for (int i = 0; i < xs.length; i++) {\n            int digit = (int)xs[i] - (int)'0';\n            result *= 10;\n            result += digit;\n        }\n        return result;\n    }\n\n    static int getPrefix(char[] xs, int k) {\n        var digits = new ArrayList<Character>();\n        var sizeCount = 0;\n        int result = 0;\n        for (int i = 0; i < xs.length; i++){\n            var c = xs[i];\n            int digit = (int)c - (int)'0';\n            result *= 10;\n            result += digit;\n            if (!digits.contains(c)) {\n                digits.add(c);\n                sizeCount++;\n            }\n            if (sizeCount == k) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    static char[] makePaddedCharArray(int x, int size) {\n        if (x <= 0) {\n            var ys = new char[size];\n            for (int i = 0; i < size; i++) {\n                ys[i] = '0';\n            }\n            return ys;\n        }\n\n        var zs = (\"\"+x).toCharArray();\n        var ys = new char[size];\n        for (int i = 0; i < size - zs.length; i++) {\n            ys[i] = '0';\n        }\n        for (int i = size - zs.length; i < size; i++) {\n            ys[i] = zs [zs.length - size + i];\n        }\n        return ys;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int t = sc.nextInt();\n        for (int tc = 0; tc < t; tc++) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            var xs = (\"\"+n).toCharArray();\n            \n            int result = 0;\n\n            int prefix = getPrefix(xs, k);\n            int prefixSize = (\"\"+prefix).length();\n\n            var prefixDigits = getDigits(prefix);\n            var resultDigits = getDigits(n);\n            \n            int remSize = xs.length - prefixSize;\n            int paddedPrefix = prefix;\n            for (int i = 0; i < remSize; i++) {\n                paddedPrefix *= 10;\n            }\n            int rem = n - paddedPrefix; \n            var ys = makePaddedCharArray(rem, remSize);\n\n            boolean trivial = resultDigits.size() <= k;\n            if (trivial) {\n                result = n;\n            } else {\n                while (result < n || resultDigits.size() > k) {\n                    // System.out.println(\"Prefix: \" + prefix);\n                    // System.out.println(\"Padded Prefix: \" + paddedPrefix);\n                    // System.out.println(\"Prefix Digits: \" + prefixDigits);\n                    if (!(resultDigits.size() <= k)) {\n                        result = paddedPrefix;\n                        boolean failed = false;\n                        int minDigit = Collections.min(prefixDigits) - (int)'0';\n                        int maxDigitChar = Collections.max(prefixDigits);\n                        \n                        boolean smallestWillSuffice = (paddedPrefix >= n);\n                        for (int i = 0; i < remSize; i++) {\n                            // System.out.println(\"Result is currently \" + result);\n                            if (smallestWillSuffice) {\n                                result += (minDigit * Math.pow(10, remSize - 1 - i));\n                            } else {\n                                boolean foundSufficientDigit = false;\n                                for (char c : prefixDigits) {\n                                    // System.out.println(\"Considering \" + c);\n                                    boolean digitWillSuffice = (c >= ys[i]);\n                                    if (c > ys[i]) {\n                                        smallestWillSuffice = true;\n                                    } else if (c == ys[i]) {\n                                        for (int j = i+1; j < remSize; j++) {\n                                            if (maxDigitChar > ys[j]) {\n                                                break;\n                                            }\n                                            if (maxDigitChar < ys[j]) {\n                                                digitWillSuffice = false;\n                                                if (maxDigitChar == 9) return;\n                                            }\n                                        } \n                                    }\n                                    if (digitWillSuffice) {\n                                        int digit = (int)c - (int)'0';\n                                        result += (digit * Math.pow(10, remSize - 1 - i));\n                                        foundSufficientDigit = true;\n                                        break;\n                                    }\n                                }\n                                if (!foundSufficientDigit) {\n                                    failed = true;\n                                    break;\n                                }\n                            }\n                        }\n    \n                        if (failed) {\n                            prefix++;\n                            paddedPrefix += Math.pow(10, remSize);\n                            result = paddedPrefix;\n                            rem = n - paddedPrefix;\n                            ys = makePaddedCharArray(rem, remSize);\n                            prefixDigits = getDigits(prefix);\n                            resultDigits = getDigits(paddedPrefix);\n                            prefixSize = (\"\"+prefix).length();\n                            remSize = xs.length - prefixSize;\n                        } else {\n                            resultDigits = getDigits(result);\n                        }\n                    }\n                }\n            }\n\n            \n            System.out.println(result);\n        }\n\n        sc.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long INF = LLONG_MAX;\nconst long long NINF = LLONG_MIN;\nvoid solve() {\n  long long num, k;\n  cin >> num >> k;\n  vector<long long> d;\n  while (num) {\n    d.push_back(num % 10);\n    num /= 10;\n  }\n  reverse(d.begin(), d.end());\n  long long n = d.size();\n  while (1) {\n    set<long long> s;\n    long long in;\n    for (long long i = 0; i < n; i++) {\n      s.insert(d[i]);\n      if (s.size() > k) {\n        in = i;\n        break;\n      }\n    }\n    if (s.size() <= k) break;\n    while (d[in] == 9) in--;\n    d[in]++;\n    for (long long i = in + 1; i < n; i++) d[i] = 0;\n  }\n  for (long long i = 0; i < n; i++) cout << d[i];\n  cout << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  while (t-- > 0) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 10;\nlong long n, k, dp[12][(1 << 10)][3][12], a[12], cnt, res = 0;\nbool check(long long msk, long long cur) {\n  long long cnt = 0;\n  while (msk) {\n    cnt += (msk & 1);\n    msk >>= 1;\n  }\n  return (cnt <= cur);\n}\nvoid calc(long long i, long long msk, long long c, long long cur) {\n  dp[i][msk][c][cur] = 0;\n  if (i == 0) {\n    dp[i][msk][c][cur] = check(msk, cur);\n    return;\n  }\n  for (long long j = 0; j <= 9; j++) {\n    long long msk2;\n    if (msk == 0 && j == 0)\n      msk2 = 0;\n    else\n      msk2 = msk | (1 << j);\n    if (dp[i - 1][msk2][c][cur] == -1) calc(i - 1, msk2, c, cur);\n    dp[i][msk][c][cur] |= dp[i - 1][msk2][c][cur];\n  }\n}\nvoid calc2(long long i, long long msk, long long c, long long cur) {\n  dp[i][msk][c][cur] = 0;\n  if (i == 0) {\n    dp[i][msk][c][cur] = check(msk, cur);\n    return;\n  }\n  for (long long j = a[i]; j <= 9; j++) {\n    long long msk2;\n    if (msk == 0 && j == 0)\n      msk2 = 0;\n    else\n      msk2 = msk | (1 << j);\n    if (a[i] == j && dp[i - 1][msk2][c & (a[i] == j)][cur] == -1) {\n      calc2(i - 1, msk2, c & (a[i] == j), cur);\n    }\n    dp[i][msk][c][cur] |= dp[i - 1][msk2][c & (a[i] == j)][cur];\n  }\n}\nvoid print_result(long long i, long long msk, long long c) {\n  if (i == 0) {\n    return;\n  }\n  if (c == 0)\n    for (long long j = 0; j <= 9; j++) {\n      long long msk2;\n      if (msk == 0 && j == 0)\n        msk2 = 0;\n      else\n        msk2 = msk | (1 << j);\n      if (dp[i - 1][msk2][c][k] == 1) {\n        res *= 10;\n        res += j;\n        print_result(i - 1, msk2, c);\n        break;\n      }\n    }\n  else\n    for (long long j = a[i]; j <= 9; j++) {\n      long long msk2;\n      if (msk == 0 && j == 0)\n        msk2 = 0;\n      else\n        msk2 = msk | (1 << j);\n      if (dp[i - 1][msk2][c & (a[i] == j)][k] == 1) {\n        res *= 10;\n        res += j;\n        print_result(i - 1, msk2, c & (a[i] == j));\n        break;\n      }\n    }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (long long i = 1; i <= 10; i++) a[i] = 0;\n  long long j = 0;\n  while (n > 0) {\n    a[++j] = n % 10;\n    n /= 10;\n  }\n  calc2(j + 1, 0LL, 1LL, k);\n  print_result(j + 1, 0LL, 1LL);\n  cout << res << \"\\n\";\n  res = 0;\n  for (long long i = 0; i <= j + 1; i++)\n    for (long long msk = 0; msk <= (1 << 10); msk++) dp[i][msk][1][k] = -1;\n}\nint main() {\n  memset(dp, -1, sizeof(dp));\n  ios_base::sync_with_stdio(NULL);\n  cin.tie(0);\n  cout.tie(0);\n  for (long long i = 1; i <= 10; i++) calc(10LL, 0LL, 0LL, i);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n  cerr << \"\\n\" << (float)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}\n"
        },
        {
            "language": 3,
            "solution": "def find_lsb(mask):\n\tif mask == 0:\n\t\treturn -1\n\tlsb = 0\n\twhile True:\n\t\tif mask & (1 << lsb):\n\t\t\tbreak\n\t\tlsb += 1\n\treturn lsb\n\ndef solve(n, k):\n\tmask = 0\n\tcnt = 0\n\tfor c in n:\n\t\tif mask & (1 << int(c)):\n\t\t\tcontinue\n\t\tcnt += 1\n\t\tmask |= (1 << int(c))\n\tif cnt <= k:\n\t\treturn True\n\telse:\n\t\treturn False\n\t\ndef main():\n\tt = int(input())\n\tfor tc in range(t):\n\t\tn, k = map(int, input().split())\n\t\tn = str(n)\n\t\tbackup_k = k\n\n\t\tif k == 1:\n\t\t\tres = \"1\" * (len(n) + 1)\n\t\t\tfor i in range(10):\n\t\t\t\tcur = str(i) * len(n)\n\t\t\t\tif int(cur) >= int(n):\n\t\t\t\t\tres = cur\n\t\t\t\t\tbreak\n\t\t\tprint(res)\n\t\t\tcontinue\n\n\t\tres = \"1\" + \"0\" * len(n)\n\t\tmask = 0\n\t\tcur = \"\"\n\n\t\tfor i in range(len(n)):\n\t\t\tc = int(n[i])\n\n\t\t\tfor j in range(c + 1, 10):\n\t\t\t\trem_k = k\n\t\t\t\tif (mask & (1 << j)) == 0:\n\t\t\t\t\trem_k -= 1\n\t\t\t\tif rem_k < 0:\n\t\t\t\t\tcontinue\n\n\t\t\t\tnmask = mask | (1 << j)\n\t\t\t\tif rem_k > 0:\n\t\t\t\t\tnmask |= (1 << 0)\n\t\t\t\ttemp = cur + str(j)\n\t\t\t\ttemp = temp + str(find_lsb(nmask)) * (len(n) - len(temp))\n\t\t\t\tif int(temp) >= int(n) and int(temp) <= int(res):\n\t\t\t\t\tres = temp\n\n\t\t\tif mask & (1 << c):\n\t\t\t\tcur = cur + n[i]\n\t\t\t\tcontinue\n\n\t\t\tif k > 0:\n\t\t\t\tk -= 1\n\t\t\t\tmask = mask | (1 << c)\n\t\t\t\tcur = cur + n[i]\n\t\t\telse:\n\t\t\t\tfor i in range(c + 1, 10):\n\t\t\t\t\tif mask & (1 << i):\n\t\t\t\t\t\tcur = cur + str(i)\n\t\t\t\t\t\tcur = cur + str(find_lsb(mask)) * (len(n) - len(cur))\n\t\t\t\t\t\tif int(cur) >= int(n) and int(cur) <= int(res):\n\t\t\t\t\t\t\tres = cur\n\t\t\t\t\t\tbreak\n\n\t\tif int(cur) >= int(n) and int(cur) <= int(res):\n\t\t\tres = cur\n\n\t\t# res2 = res\n\t\t# cur = int(n)\n\t\t# while True:\n\t\t# \tif solve(str(cur), backup_k) == True:\n\t\t# \t\tres2 = str(cur)\n\t\t# \t\tbreak\n\t\t# \tcur += 1\n\n\t\t# if res != res2:\n\t\t# \tprint(\"ERROR!\")\n\t\t# \tprint(res, res2)\n\t\t# \tbreak\n\t\t\n\t\tprint(res)\n\n\nif __name__ == \"__main__\":\n\tmain()"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n// import java.lang.*;\nimport java.io.*;\n\n//           THIS TEMPLATE MADE BY AKSH BANSAL.\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    private static boolean[] isPrime;\n    private static void primes(){\n        int num = (int)1e6; // PRIMES FROM 1 TO NUM\n        isPrime = new boolean[num];\n     \n        for (int i = 2; i< isPrime.length; i++) {\n           isPrime[i] = true;\n        }\n        for (int i = 2; i< Math.sqrt(num); i++) {\n           if(isPrime[i] == true) {\n              for(int j = (i*i); j<num; j = j+i) {\n                 isPrime[j] = false;\n              }\n           }\n        }\n    }\n    static void sort(int a[]){ // int -> long\n        ArrayList<Integer> arr=new ArrayList<>(); // Integer -> Long\n        for(int i=0;i<a.length;i++)\n        arr.add(a[i]);\n        Collections.sort(arr);\n        for(int i=0;i<a.length;i++)\n        a[i]=arr.get(i);\n        \n    }\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    private static long pow(long x,long y){\n        if(y==0)return 1;\n        long temp = pow(x, y/2);\n        if(y%2==1){\n            return x*temp*temp;\n        }\n        else{\n            return temp*temp;\n        }\n    }\n    // static ArrayList<Integer>[] adj;\n    // static void getAdj(int n,int q, FastReader sc){\n    //     adj = new ArrayList[n+1];\n    //     for(int i=1;i<=n;i++){\n    //         adj[i] = new ArrayList<>();\n    //     }\n    //     for(int i=0;i<q;i++){\n    //         int a = sc.nextInt();\n    //         int b = sc.nextInt();\n\n    //         adj[a].add(b);\n    //         adj[b].add(a);\n    //     }\n    // }\n    static PrintWriter out;\n    static FastReader sc ;\n    public static void main(String[] args) throws IOException {\n        sc = new FastReader();\n        out = new PrintWriter(System.out);\n        // primes();\n        // ________________________________\n\n        int test = sc.nextInt();\n        StringBuilder output = new StringBuilder();\n\n        while (test-- > 0) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            // output.append().append(\"\\n\");\n            solver(n, k);\n        }\n\n        out.println(output);\n        // _______________________________\n\n        // int n = sc.nextInt();\n        // out.println(solver());\n        // ________________________________\n        out.flush();\n    }\n\n    public static void solver(int s, int k) {\n        char[] arr = (s+\"\").toCharArray();\n        int n = arr.length;\n        \n        while(true){\n            HashSet<Character> set = new HashSet<>();\n\n            for(int i=0;i<n;i++){\n                set.add(arr[i]);\n                if(set.size()>k){\n                    while(arr[i]=='9'){\n                        i--;\n                    }\n                    arr[i] = (char)(arr[i]+1);\n                    i++;\n                    while(i<n){\n                        arr[i++] = '0';\n                    }\n                    break;\n                }\n            }\n\n            if(set.size()<=k){\n                break;\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            out.print(arr[i]);\n        }\n        out.println();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 105;\nlong long ans, ans1, n1, n, k, pw[N], t, ff[N], fix[N], cntt, cnt, mn, cnt1, xx;\nvector<long long> v, vv;\nsigned main() {\n  std::ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> t;\n  pw[0] = 1;\n  ans = 1e9;\n  for (long long i = 1; i <= 10; i++) {\n    pw[i] = pw[i - 1] * 10;\n  }\n  long long bb = 0;\n  while (t--) {\n    bb++;\n    cin >> n >> k;\n    n1 = n;\n    cntt = 0;\n    ans = 1e11;\n    for (long long i = 0; i <= 9; i++) ff[i] = 0;\n    v.clear();\n    while (n1) {\n      if (!ff[n1 % 10]) ff[n1 % 10] = 1, cntt++;\n      v.push_back(n1 % 10);\n      n1 /= 10;\n    }\n    if (cntt <= k) {\n      cout << n << endl;\n      continue;\n    }\n    reverse(v.begin(), v.end());\n    cnt = v.size();\n    for (long long idx = 0; idx < cnt; idx++) {\n      if (v[idx] == 9) continue;\n      mn = 1e9;\n      cnt1 = 0;\n      ans1 = 0;\n      for (long long j = 0; j <= 9; j++) fix[j] = 0;\n      for (long long j = 0; j < idx; j++) {\n        if (!fix[v[j]]) cnt1++, fix[v[j]] = 1, mn = min(mn, v[j]);\n        ans1 += pw[cnt - j - 1] * v[j];\n      }\n      if (cnt1 > k) {\n        continue;\n      }\n      if (cnt1 + 2 <= k || (fix[v[idx] + 1] && cnt1 + 1 <= k) ||\n          (fix[0] && cnt1 + 1 <= k)) {\n        ans1 += pw[cnt - idx - 1] * (v[idx] + 1);\n        ans = min(ans, ans1);\n        continue;\n      }\n      if (cnt1 + 1 <= k) {\n        ans1 += pw[cnt - idx - 1] * (v[idx] + 1);\n        mn = min(mn, v[idx] + 1);\n        for (long long j = idx + 1; j < cnt; j++) {\n          ans1 += pw[cnt - j - 1] * mn;\n        }\n        ans = min(ans, ans1);\n      }\n      if (cnt1 == k) {\n        xx = 0;\n        for (long long j = v[idx] + 1; j <= 9; j++) {\n          if (fix[j]) {\n            xx = j;\n            break;\n          }\n        }\n        if (!xx) continue;\n        ans1 += xx * pw[cnt - idx - 1];\n        for (long long j = idx + 1; j < cnt; j++) {\n          ans1 += pw[cnt - j - 1] * mn;\n        }\n        ans = min(ans, ans1);\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    map<long long, long long> found;\n    cin >> n >> k;\n    string s = to_string(n);\n    long long cnt = 0;\n    long long lasttochange = -1;\n    long long firstforoccur = -1;\n    long long change = -1;\n    char min = '9';\n    char f = '*';\n    for (long long i = 0; i < s.size(); i++) {\n      if (!found[s[i]]) {\n        cnt++;\n        if (cnt == k) firstforoccur = i;\n        if (cnt > k) {\n          change = i;\n          break;\n        }\n        if (s[i] < min) min = s[i];\n      }\n      char assign = s[i] + 1;\n      while (assign > s[i]) {\n        if (found[assign]) {\n          lasttochange = i;\n          f = assign;\n          break;\n        }\n        if (assign >= '9') {\n          break;\n        }\n        assign++;\n      }\n      found[s[i]]++;\n    }\n    if (change == -1)\n      cout << s << '\\n';\n    else {\n      char assign = s[change] + 1;\n      bool can = false;\n      while (assign > s[change]) {\n        if (found[assign]) {\n          s[change] = assign;\n          can = true;\n          for (long long i = change + 1; i < s.size(); i++) s[i] = min;\n          break;\n        }\n        if (assign >= '9') {\n          break;\n        }\n        assign++;\n      }\n      if (!can) {\n        if (firstforoccur >= lasttochange) {\n          if (s[firstforoccur] == min) min = s[firstforoccur] + 1;\n          if (found[s[firstforoccur] + 1]) min = '0';\n          s[firstforoccur]++;\n          for (long long i = firstforoccur + 1; i < s.size(); i++) {\n            s[i] = min;\n          }\n        } else {\n          if (found[s[lasttochange]] == 1) {\n            min = '0';\n          }\n          s[lasttochange] = f;\n          for (long long i = lasttochange + 1; i < s.size(); i++) {\n            s[i] = min;\n          }\n        }\n      }\n      cout << s << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nvector<int> ans;\nset<int> st;\nunordered_map<int, int> um;\nbool f(int idx, int k, bool great) {\n  if (idx == s.size()) return true;\n  int angka = s[idx] - '0';\n  if (great) {\n    ans.push_back(*st.begin());\n    if (f(idx + 1, k, true)) return true;\n    return false;\n  }\n  if (k == 0) {\n    auto it = st.begin();\n    while (it != st.end()) {\n      int val = *it;\n      if (val >= angka) {\n        ans.push_back(val);\n        if (val > angka) {\n          if (f(idx + 1, k, true)) return true;\n        } else {\n          if (f(idx + 1, k, false)) return true;\n        }\n        ans.pop_back();\n      }\n      it++;\n    }\n    return false;\n  }\n  bool e = st.find(angka) != st.end();\n  ans.push_back(angka);\n  st.insert(angka);\n  um[angka]++;\n  if (e) {\n    if (f(idx + 1, k, false)) return true;\n  } else {\n    if (f(idx + 1, k - 1, false)) return true;\n  }\n  ans.pop_back();\n  um[angka]--;\n  if (um[angka] == 0) st.erase(angka);\n  angka++;\n  e = st.find(angka) != st.end();\n  ans.push_back(angka);\n  st.insert(angka);\n  um[angka]++;\n  if (e) {\n    st.insert(0);\n    if (f(idx + 1, k, true)) return true;\n  } else {\n    if (f(idx + 1, k - 1, true)) return true;\n  }\n  ans.pop_back();\n  um[angka]--;\n  if (um[angka] == 0) st.erase(angka);\n  return false;\n}\nvoid solve() {\n  int k;\n  cin >> s >> k;\n  ans.clear();\n  st.clear();\n  um.clear();\n  f(0, k, false);\n  for (auto x : ans) cout << x;\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t = 1;\n  cin >> t;\n  for (int tt = 0; tt < t; tt++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint64_t n, k, i;\nstd::string s, y;\nstd::set<char> st;\nstd::string solve() {\n  st.clear();\n  n = s.length();\n  y = \"\";\n  for (i = 0; i < n && st.size() <= k; ++i) {\n    y += s[i];\n    st.insert(s[i]);\n  }\n  if (i == n && st.size() <= k) return y;\n  s = std::to_string(std::stoi(y) + 1) + std::string(n - y.size(), '0');\n  return solve();\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  int t;\n  std::cin >> t;\n  while (t--) {\n    std::cin >> s >> k;\n    std::cout << solve() << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def one(n: str, lili: dict):\n  \n  sel = n[0]\n  def have_greater_in_lili_or_sel(digit: str) -> bool:\n    for li, exists in lili.items():\n      if exists and li > digit:\n        return True\n    return sel > digit\n  \n  for digit in n[1:]:\n    # if the digit is less than sel or we already have a greater digit.\n    if have_greater_in_lili_or_sel(digit):\n      # we have a safe tight choice.\n      break\n    # if we already have that digit, continue.\n    if digit in [d for d in lili if lili[d]]:\n      continue\n    # if the digit is greater than sel and we don't have the digit or a greater one.\n    if digit > sel:\n      sel = str(int(sel) + 1)\n      # if we already has dat digit(sel+1), we still got a spare k.\n      if lili[sel]:\n        # Set the lowest value to true then.\n        lili['0'] = True\n      break\n  lili[sel] = True\n\ndef run(n: str, k: int, lili: dict):\n  if not n or not k:\n    return\n  elif lili[n[0]]:\n    run(n[1:], k, lili)\n  elif k == 1:\n    one(n, lili)\n  else:\n    lili[n[0]] = True\n    run(n[1:], k - 1, lili)\n\ndef clean(n: str, lili: dict) -> str:\n  \n  def least_greater(n_dig: str, res_dig: str) -> str:\n    best = res_dig\n    for digit, exists in lili.items():\n      if exists and digit > n_dig:\n        best = min(best, digit)\n    return best\n  \n  maybe_a_better_resut = ''\n  min_dig = min(digit for digit in '0123456789' if lili[digit])\n  max_dig = max(digit for digit in '0123456789' if lili[digit])\n  for curr_index, n_dig in enumerate(n):\n    best = least_greater(str(int(n_dig) - 1) , max_dig)\n    if best > n_dig:\n      # If the best is bigger than the number itself,\n      # add it and fill the rest with the min_val we have.\n      maybe_a_better_resut += best\n      for _ in range(len(n) - curr_index - 1):\n        maybe_a_better_resut += min_dig\n      break\n    elif best < n_dig:\n      parent = maybe_a_better_resut[curr_index - 1]\n      # If the best was smaller than the number itslef,\n      # then we have to set our parent to a greater value\n      # and fill the rest with min_val.\n      maybe_a_better_resut = (\n          # for the record, this is just doing:\n          # maybe_a_better_result[curr_index - 1] = least_greater(maybe_a_better_resut[curr_index - 1],  max_dig)\n          maybe_a_better_resut[:curr_index - 1]\n          +\n          least_greater(\n              maybe_a_better_resut[curr_index - 1],\n              max_dig)\n        )\n      if parent == maybe_a_better_resut[curr_index - 1]:\n        n = (\n            n[:curr_index - 1]\n            +\n            str(int(parent) + 1) #lets hope parent != '9' :(\n            +\n            n[curr_index:]\n        )\n        return clean(n, lili)\n      for _ in range(len(n) - curr_index):\n        maybe_a_better_resut += min_dig\n      break\n    # if best == n_dig\n    else:\n      maybe_a_better_resut += best\n      \n  return maybe_a_better_resut\n\nt = int(input())\nfor i in range(1, t + 1):\n  n, k = input().split()\n  lili = {digit: False for digit in '0123456789'}\n  if len(set(n)) == int(k):\n    print(n)\n    continue\n  run(n, int(k), lili)\n  result = clean(n, lili)\n  # if result == '101000000' and i == 1703:\n  #   print(n+'-'+k)\n  #   continue\n  print(result)\n  "
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF2 solver = new TaskF2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF2 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            var tc = in.nextInt();\n            for (int i = 0; i < tc; i++) {\n                solution(i, in, out);\n            }\n        }\n\n        void solution(int testNumber, InputReader in, OutputWriter out) {\n            int kk = in.nextInt();\n            char[] k = String.valueOf(kk).toCharArray();\n            int limit = in.nextInt();\n            var currentDigits = new EzCharHashSet(k).size();\n            if (limit >= currentDigits) {\n                out.println(k);\n                return;\n            }\n            char[] stt = bruteForce(k, limit);\n            out.println(stt);\n\n        }\n\n        int getBit(int n, int k) {\n            return (n >> k) & 1;\n        }\n\n        private char[] bruteForce(char[] k, int limit) {\n            char[] minc = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n\n            for (int zz = 0; Integer.bitCount(zz) <= 10; zz++) {\n                if (Integer.bitCount(zz) == limit) {\n                    char[] res = makeSmallest(k, zz);\n                    if (compareArrays(res, minc) < 0) {\n                        minc = res;\n                    }\n                }\n            }\n            return minc;\n        }\n\n        private int nextCharSet(int bitmask, int idx) {\n            for (; idx < 10; idx++) {\n                if (getBit(bitmask, idx) > 0) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n\n        private char[] makeSmallest(char[] ooo, int t) {\n            // makes the smallest one using this set of characters\n            // lets try the simplest way, make everything set to k or higher,\n            char[] z = ArrayUtils.clone(ooo);\n            int firstCharI = Integer.numberOfTrailingZeros(t);\n            for (int i = 0; i < z.length; i++) {\n                char best = (char) (nextCharSet(t, z[i] - '0') + '0');\n                if (best == -1 + '0') {\n                    // can't replace this one\n                    // see if we can bump previous\n\n                    // we're at an index of i that cannot be bumped up\n                    char nnh = best;\n                    for (; i >= 0 && nnh == -1 + '0'; i--) {\n                        nnh = (char) (nextCharSet(t, z[i] - '0' + 1) + '0');\n                    }\n\n                    // can't bump up any of the previous ones, whoops\n                    if (nnh == -1 + '0') {\n                        // return an array 1 longer, but filled with the lowest char\n                        var retArr = new char[z.length + 1];\n                        // problem, char can be 0\n                        Arrays.fill(retArr, (char) (firstCharI + '0'));\n                        char firstChar = (char) (firstCharI + '0');\n                        if (firstChar != -1) {\n                            retArr[0] = firstChar;\n                        } else {\n                            Arrays.fill(retArr, 'z');\n                        }\n                        return retArr;\n                        // just return\n                    }\n\n                    // can bump up a previous one.\n                    // lets do it and fill it up\n                    i++;\n                    z[i] = nnh;\n                    char ff = (char) (firstCharI + '0');\n                    for (int zv = i + 1; zv < z.length; zv++) {\n                        z[zv] = ff;\n                    }\n                    return z;\n                }\n\n                //what if we can leave it as is? continue\n                if (best == z[i]) {\n                    continue;\n                }\n\n                if (best > z[i]) {\n                    // bumpable\n                    z[i] = best;\n                    char zz = (char) (firstCharI + '0');\n                    for (int zv = i + 1; zv < z.length; zv++) {\n                        z[zv] = zz;\n                    }\n                    return z;\n                }\n            }\n            return z;\n        }\n\n        private int compareArrays(char[] a, char[] b) {\n            if (a.length != b.length) {\n                return Integer.compare(a.length, b.length);\n            }\n            return Arrays.compare(a, b);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface EzCharCollection {\n        int size();\n\n        EzCharIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n\n    static final class EzCharSort {\n        private static final double HEAPSORT_DEPTH_COEFFICIENT = 2.0;\n        private static final Random rnd = new Random();\n\n        private EzCharSort() {\n        }\n\n        private static int maxQuickSortDepth(int length) {\n            if (length <= 1) {\n                return 0;\n            }\n            int log = Integer.numberOfTrailingZeros(Integer.highestOneBit(length - 1)) + 1;\n            return (int) (HEAPSORT_DEPTH_COEFFICIENT * log);\n        }\n\n        public static void sort(char[] a) {\n            quickSort(a, 0, a.length, 0, maxQuickSortDepth(a.length));\n        }\n\n        private static void quickSort(char[] a, int left, int right, int depth, int maxDepth) {\n            if (right - left <= 1) {\n                return;\n            }\n            if (depth > maxDepth) {\n                heapSort(a, left, right - left);\n                return;\n            }\n            final char pivot = a[left + rnd.nextInt(right - left)];\n            int i = left;\n            int j = right - 1;\n            do {\n                while (a[i] < pivot) i++;\n                while (pivot < a[j]) j--;\n                if (i <= j) {\n                    char tmp = a[i];\n                    a[i++] = a[j];\n                    a[j--] = tmp;\n                }\n            } while (i <= j);\n            quickSort(a, left, j + 1, depth + 1, maxDepth);\n            quickSort(a, i, right, depth + 1, maxDepth);\n        }\n\n        private static void heapSort(char[] a, int offset, int size) {\n            // If size <= 1, nothing is executed\n            for (int i = (size >>> 1) - 1; i >= 0; i--) {\n                down(a, i, offset, size);\n            }\n            for (int i = size - 1; i > 0; i--) {\n                char tmp = a[offset];\n                a[offset] = a[offset + i];\n                a[offset + i] = tmp;\n                down(a, 0, offset, i);\n            }\n        }\n\n        private static void down(char[] a, int index, int offset, int size) {\n            final char element = a[offset + index];\n            final int firstLeaf = (size >>> 1);\n            while (index < firstLeaf) {\n                int largestChild = (index << 1) + 1;\n                if (largestChild + 1 < size && a[offset + largestChild + 1] > a[offset + largestChild]) {\n                    largestChild++;\n                }\n                if (a[offset + largestChild] <= element) {\n                    break;\n                }\n                a[offset + index] = a[offset + largestChild];\n                index = largestChild;\n            }\n            a[offset + index] = element;\n        }\n\n    }\n\n    static final class PrimitiveHashCalculator {\n        private PrimitiveHashCalculator() {\n        }\n\n        public static int getHash(char x) {\n            return x;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(char[] array) {\n            writer.println(array);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static interface EzCharIterator {\n        boolean hasNext();\n\n        char next();\n\n    }\n\n    static class EzCharHashSet implements EzCharSet {\n        private static final int DEFAULT_CAPACITY = 8;\n        private static final int HASHCODE_INITIAL_VALUE = 0x811c9dc5;\n        private static final int HASHCODE_MULTIPLIER = 0x01000193;\n        private static final byte FREE = 0;\n        private static final byte FILLED = 2;\n        private static final Random rnd = new Random();\n        private static final int POS_RANDOM_SHIFT_1;\n        private static final int POS_RANDOM_SHIFT_2;\n        private static final int STEP_RANDOM_SHIFT_1;\n        private static final int STEP_RANDOM_SHIFT_2;\n        private char[] table;\n        private byte[] status;\n        private int size;\n        private int removedCount;\n        private int mask;\n        private final int hashSeed;\n\n        static {\n            POS_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;\n            POS_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;\n            STEP_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;\n            STEP_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;\n        }\n\n        public EzCharHashSet() {\n            this(DEFAULT_CAPACITY);\n        }\n\n        public EzCharHashSet(int capacity) {\n            if (capacity < 0) {\n                throw new IllegalArgumentException(\"Capacity must be non-negative\");\n            }\n            // Actually we need 4x more memory\n            int length = 4 * Math.max(1, capacity);\n            if ((length & (length - 1)) != 0) {\n                length = Integer.highestOneBit(length) << 1;\n            }\n            // Length is a power of 2 now\n            initEmptyTable(length);\n            hashSeed = rnd.nextInt();\n        }\n\n        public EzCharHashSet(EzCharCollection collection) {\n            this(collection.size());\n            for (EzCharIterator iterator = collection.iterator(); iterator.hasNext(); ) {\n                add(iterator.next());\n            }\n        }\n\n        public EzCharHashSet(char[] srcArray) {\n            this(srcArray.length);\n            for (char element : srcArray) {\n                add(element);\n            }\n        }\n\n        public EzCharHashSet(Collection<Character> javaCollection) {\n            this(javaCollection.size());\n            for (char element : javaCollection) {\n                add(element);\n            }\n        }\n\n        private int getStartPos(int h) {\n            h ^= hashSeed;\n            h ^= (h >>> POS_RANDOM_SHIFT_1) ^ (h >>> POS_RANDOM_SHIFT_2);\n            return h & mask;\n        }\n\n        private int getStep(int h) {\n            h ^= hashSeed;\n            h ^= (h >>> STEP_RANDOM_SHIFT_1) ^ (h >>> STEP_RANDOM_SHIFT_2);\n            return ((h << 1) | 1) & mask;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public boolean contains(char element) {\n            final int elementHash = PrimitiveHashCalculator.getHash(element);\n            int pos = getStartPos(elementHash);\n            final int step = getStep(elementHash);\n            for (; status[pos] != FREE; pos = (pos + step) & mask) {\n                if (status[pos] == FILLED && table[pos] == element) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public EzCharIterator iterator() {\n            return new EzCharHashSetIterator();\n        }\n\n        public char[] toArray() {\n            char[] result = new char[size];\n            for (int i = 0, j = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    result[j++] = table[i];\n                }\n            }\n            return result;\n        }\n\n        public boolean add(char element) {\n            final int elementHash = PrimitiveHashCalculator.getHash(element);\n            int pos = getStartPos(elementHash);\n            final int step = getStep(elementHash);\n            for (; status[pos] == FILLED; pos = (pos + step) & mask) {\n                if (table[pos] == element) {\n                    return false;\n                }\n            }\n            if (status[pos] == FREE) {\n                status[pos] = FILLED;\n                table[pos] = element;\n                size++;\n                if ((size + removedCount) * 2 > table.length) {\n                    rebuild(table.length * 2); // enlarge the table\n                }\n                return true;\n            }\n            final int removedPos = pos;\n            for (pos = (pos + step) & mask; status[pos] != FREE; pos = (pos + step) & mask) {\n                if (status[pos] == FILLED && table[pos] == element) {\n                    return false;\n                }\n            }\n            status[removedPos] = FILLED;\n            table[removedPos] = element;\n            size++;\n            removedCount--;\n            return true;\n        }\n\n        private void rebuild(int newLength) {\n            char[] oldTable = table;\n            byte[] oldStatus = status;\n            initEmptyTable(newLength);\n            for (int i = 0; i < oldTable.length; i++) {\n                if (oldStatus[i] == FILLED) {\n                    add(oldTable[i]);\n                }\n            }\n        }\n\n        private void initEmptyTable(int length) {\n            table = new char[length];\n            status = new byte[length];\n            size = 0;\n            removedCount = 0;\n            mask = length - 1;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            EzCharHashSet that = (EzCharHashSet) o;\n\n            if (size != that.size) {\n                return false;\n            }\n            for (int i = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    if (!that.contains(table[i])) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public int hashCode() {\n            char[] array = toArray();\n            EzCharSort.sort(array);\n            int hash = HASHCODE_INITIAL_VALUE;\n            for (int i = 0; i < size; i++) {\n                hash = (hash ^ PrimitiveHashCalculator.getHash(array[i])) * HASHCODE_MULTIPLIER;\n            }\n            return hash;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append('[');\n            for (int i = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    if (sb.length() > 1) {\n                        sb.append(\", \");\n                    }\n                    sb.append(table[i]);\n                }\n            }\n            sb.append(']');\n            return sb.toString();\n        }\n\n        private class EzCharHashSetIterator implements EzCharIterator {\n            private int curIndex = 0;\n\n            public boolean hasNext() {\n                while (curIndex < table.length && status[curIndex] != FILLED) {\n                    curIndex++;\n                }\n                return curIndex < table.length;\n            }\n\n            public char next() {\n                while (curIndex < table.length && status[curIndex] != FILLED) {\n                    curIndex++;\n                }\n                if (curIndex == table.length) {\n                    throw new NoSuchElementException(\"Iterator doesn't have more elements\");\n                }\n                return table[curIndex++];\n            }\n\n        }\n\n    }\n\n    static interface EzCharSet extends EzCharCollection {\n        int size();\n\n        EzCharIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n\n    static class ArrayUtils {\n        public static char[] clone(final char[] array) {\n            if (array == null) {\n                return null;\n            }\n            return array.clone();\n        }\n\n        public ArrayUtils() {\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t;\nint count(string a) {\n  int vis[10], cnt = 0;\n  memset(vis, 0, sizeof(vis));\n  for (int i = 0; i < a.size(); i++) {\n    int x = a[i] - '0';\n    if (!vis[x]) {\n      cnt++;\n      vis[x] = 1;\n    }\n  }\n  return cnt;\n}\nlong long to_int(string s) {\n  long long ans = 0;\n  for (int i = 0; i < s.size(); i++) {\n    ans = ans * 10 + s[i] - '0';\n  }\n  return ans;\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    string s;\n    int k;\n    cin >> s >> k;\n    long long ans = 0x3f3f3f3f3f3f3f3f;\n    if (count(s) <= k) {\n      cout << s << '\\n';\n      continue;\n    }\n    for (int i = 0; i < s.size(); i++) {\n      for (char j = s[i] + 1; j <= '9'; j++) {\n        string ss = s;\n        ss[i] = j;\n        for (int kk = i + 1; kk <= s.size(); kk++) {\n          ss[kk] = ss[i];\n        }\n        if (count(ss) > k) continue;\n        for (int kk = i + 1; kk < s.size(); kk++) {\n          for (char r = '0'; r <= '9'; r++) {\n            string sss = ss;\n            sss[kk] = r;\n            if (count(sss) <= k) {\n              ss[kk] = r;\n              break;\n            }\n          }\n        }\n        ans = min(ans, to_int(ss));\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class JaiShreeRam{\n\tstatic Scanner in=new Scanner();\n\tstatic long mod = 1000000007;\n\tstatic ArrayList<ArrayList<Integer>> adj;\n\tstatic long ans;\n\tpublic static void main(String[] args) throws Exception{\n\t\tint z=in.readInt();\n\t\twhile(z-->0) {\n\t\t\tchar[] s=in.readString().toCharArray();\n\t\t\tint k=in.readInt();\n\t\t\tans=k;\n\t\t\tchar c[]=new char[s.length];\n\t\t\tArrays.fill(c,'0');\n\t\t\tans(0,s.length,k,c,s);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic boolean ans(int ind,int n,int k,char c[],char[] s) {\n\t\tint dist=calDist(c,ind);\n\t\tif(ind==n) {\n\t\t\tif(dist<=k) {\n\t\t\t\tans=Integer.parseInt(new String(c));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfor(int j=0;j<10;j++) {\n\t\t\tc[ind]+=j;\n\t\t\tif(c[ind]>=s[ind]) {\n\t\t\t\tdist=calDist(c,ind+1);\n\t\t\t\tif(dist<=k) {\n\t\t\t\t\tif(ans(ind+1,n,k,c,s))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfor(int l=ind+1;l<n;l++)\n\t\t\t\t\ts[l]='0';\n\t\t\t}\n\t\t\tc[ind]-=j;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic int calDist(char c[],int n) {\n\t\tSet<Character> st=new HashSet<>();\n\t\tfor(int i=0;i<n;i++)\n\t\t\tst.add(c[i]);\n\t\treturn st.size();\n\t}\n\tstatic int[] nextIntArray(int n){\n\t\tint[] arr= new int[n];\n\t\tint i=0;\n\t\twhile(i<n){\n\t\t\tarr[i++]=in.readInt();\n\t\t}\n\t\treturn arr;\n\t}\n\tstatic int[] nextIntArray1(int n){\n\t\tint[] arr= new int[n+1];\n\t\tint i=1;\n\t\twhile(i<=n){\n\t\t\tarr[i++]=in.readInt();\n\t\t}\n\t\treturn arr;\n\t}\n\tstatic long gcd(long a, long b) {\n\t\tif (b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n\tstatic class Scanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString readString() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tdouble readDouble() {\n\t\t\treturn Double.parseDouble(readString());\n\t\t}\n\t\tint readInt() {\n\t\t\treturn Integer.parseInt(readString());\n\t\t}\n\t\tlong readLong() {\n\t\t\treturn Long.parseLong(readString());\n\t\t}\n\t}\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dadsadasda;\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 1e16;\nconst int MAXN = 1e5;\nstring N;\nint K;\nint count_bits(int k) {\n  int cnt = 0;\n  while (k > 0) {\n    cnt += k & 1;\n    k >>= 1;\n  }\n  return cnt;\n}\nlong long tenP[12];\nlong long go(vector<bool> digits) {\n  bool cover_all = true;\n  for (auto d : N) cover_all &= digits[d - '0'];\n  if (cover_all) return stol(N);\n  int smallest = 69;\n  for (int i = 0; i < 10; i++)\n    if (digits[i]) smallest = min(smallest, i);\n  vector<int> nxt(12, 69);\n  for (int i = 0; i < 10; i++)\n    if (digits[i]) nxt[i] = i;\n  for (int i = 8; i >= 0; --i) nxt[i] = min(nxt[i], nxt[i + 1]);\n  vector<int> R((int)N.size() + 2);\n  R[(int)N.size() - 1] = smallest;\n  for (int i = (int)N.size() - 2; i >= 0; --i) R[i] = 10 * R[i + 1] + smallest;\n  long long ans = LLINF;\n  long long l = 0;\n  for (int mid = 0; mid < (int)N.size(); ++mid) {\n    if (nxt[N[mid] - '0' + 1] != 69)\n      ans = min(ans, l + nxt[N[mid] - '0' + 1] * tenP[(int)N.size() - 1 - mid] +\n                         R[mid + 1]);\n    if (nxt[N[mid] - '0'] != 69)\n      l = l + nxt[N[mid] - '0'] * tenP[(int)N.size() - 1 - mid];\n    else\n      break;\n  }\n  return ans;\n}\nmap<pair<string, int>, long long> DP;\nvoid solve() {\n  cin >> N >> K;\n  if (DP.find({N, K}) != DP.end()) {\n    printf(\"%lld\\n\", DP[{N, K}]);\n    return;\n  }\n  long long ans = LLINF;\n  for (int i = 1; i < (1 << 10); i++)\n    if (count_bits(i) == K) {\n      vector<bool> can_use(10);\n      for (int b = 0; b < 10; b++)\n        if ((i >> b) & 1) can_use[b] = 1;\n      ans = min(ans, go(can_use));\n    }\n  DP[{N, K}] = ans;\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  tenP[0] = 1;\n  for (int i = 1; i < 12; i++) tenP[i] = 10 * tenP[i - 1];\n  int t;\n  dadsadasda = scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    //static final long mod=(long)1e9+7;\n    static final long mod=998244353L;\n    public static long pow(long a,long p)\n    {\n        long res=1;\n        while(p>0)\n        {\n            if(p%2==1)\n            {\n                p--;\n                res*=a;\n                res%=mod;\n            }\n            else\n            {\n                a*=a;\n                a%=mod;\n                p/=2;\n            }\n        }\n        return res;\n    }\n    /*static class Pair\n    {\n        int u,v;\n        Pair(int u,int v)\n        {\n            this.u=u;\n            this.v=v;\n        }\n    }*/\n    /*static class Pair implements Comparable<Pair>\n    {\n        int v,l;\n        Pair(int v,int l)\n        {\n            this.v=v;\n            this.l=l;\n        }\n        public int compareTo(Pair p)\n        {\n            return l-p.l; \n        }\n    }*/\n    static long gcd(long a,long b)\n    {\n        if(b%a==0)\n        return a;\n        return gcd(b%a,a);\n    }\n    public static void dfs(int u,ArrayList<Integer> edge[],boolean vis[])\n    {\n        vis[u]=true;\n        for(int v:edge[u])\n        {\n            if(!vis[v])\n            dfs(v,edge,vis);\n        }\n    }\n    static class DSU\n    {\n        int par[],rank[],n;\n        DSU(int n)\n        {\n            this.n=n;\n            par=new int[n+1];\n            rank=new int[n+1];\n            for(int i=1;i<=n;i++)\n            par[i]=i;\n        }\n        public void union(int u,int v)\n        {\n            u=find(u);\n            v=find(v);\n            if(u==v)\n            return;\n            if(rank[u]>rank[v])\n            par[v]=u;\n            else if(rank[u]<rank[v])\n            par[u]=v;\n            else\n            {\n                rank[v]++;\n                par[u]=v;\n            }\n        }\n        public int find(int u)\n        {\n            if(u==par[u])\n            return u;\n            return par[u]=find(par[u]);\n        }\n    }\n    static class Edge \n    {\n        int v,ind;\n        long w;\n        Edge(int v,int w,int ind)\n        {\n            this.ind=ind;\n            this.v=v;\n            this.w=1L*w;\n        }\n    }\n    static class Pair implements Comparable<Pair>\n    {\n        Edge e;\n        long d;\n        Pair(Edge e,long d)\n        {\n            this.e=e;\n            this.d=d;\n        }\n        public int compareTo(Pair p)\n        {\n            if(this.d!=p.d)\n            {\n                if(this.d<=p.d)\n                return -1;\n                return 1;\n            }\n            if(this.e.w<=p.e.w)\n            return -1;\n            return 1;\n        }\n    }\n    public static void main(String args[])throws Exception\n    {\n        FastReader fs=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int tc=fs.nextInt();\n        while(tc-->0)\n        {\n            int num=fs.nextInt();\n            int k=fs.nextInt();\n            char c[]=Integer.toString(num).toCharArray();\n            int n=c.length;\n            TreeSet<Integer> ts=new TreeSet<>();\n            int i,last=-1;\n            int cnt[]=new int[10];\n            for(i=0;i<n;i++)\n            {\n                if(ts.size()==k)break;\n                if(!ts.contains(c[i]-'a'))\n                last=i;\n                cnt[c[i]-'0']++;\n                ts.add(c[i]-'0');\n            }\n            while(i<n&&ts.contains(c[i]-'0'))\n            {\n                cnt[c[i]-'0']++;\n                i++;\n            }\n            int tot[]=new int[10];\n            for(int j=0;j<10;j++)\n            tot[j]=cnt[j];\n            if(i==n)\n            pw.println(num);\n            else\n            {\n                int ind=-1;\n                int tt=c[i]-'0';\n                if(ts.ceiling(tt+1)!=null)\n                {\n                    int ceil=ts.ceiling(tt+1);\n                    c[i]=(char)(ceil+'0');\n                    ceil=ts.first();\n                    i++;\n                    while(i<n)\n                    {\n                        c[i]=(char)(ceil+'0');\n                        i++;\n                    }\n                }\n                else\n                {\n                    --i;\n                    while(i>=0)\n                    {\n                        if(cnt[c[i]-'0']==1)\n                        {\n                            ts.remove(c[i]-'0');\n                            c[i]=(char)(c[i]+1);\n                            ts.add(c[i]-'0');\n                            ++i;\n                            break;\n                        }\n                        if(ts.ceiling((c[i]-'0')+1)!=null)\n                        {\n                            int nn=ts.ceiling((c[i]-'0')+1);\n                            if(tot[c[i]-'0']==1)\n                            ts.remove(c[i]-'0');\n                            c[i]=(char)(nn+'0');\n                            ++i;\n                            break;\n                        }\n                        cnt[c[i]-'0']--;\n                        --i;\n                    }\n                    if(ts.size()!=k)\n                    ts.add(0);\n                    while(i<n)\n                    {\n                        c[i]=(char)(ts.first()+'0');\n                        i++;\n                    }\n                }\n                pw.println(new String(c));\n            }\n        }\n        pw.flush();\n        pw.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\nint T, K;\nstring n;\nbool use[10];\nbool smaller(const string &s, const string &t) {\n  if (t.empty()) return 1;\n  for (int i = (0); i <= (((int)(s).size()) - 1); ++i)\n    if (s[i] < t[i])\n      return 1;\n    else if (t[i] < s[i])\n      return 0;\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> T;\n  while (T--) {\n    cin >> n >> K;\n    for (int i = (0); i <= (9); ++i) use[i] = 0;\n    int num = 0;\n    string ans = \"\", cur = \"\";\n    for (int i = (0); i <= (((int)(n).size()) - 1); ++i) {\n      int mn = n[i] - '0' + 1;\n      if (num == K) {\n        mn = 10;\n        for (int j = (n[i] - '0' + 1); j <= (9); ++j)\n          if (use[j]) {\n            mn = j;\n            break;\n          }\n      }\n      if (mn <= 9) {\n        int add = !use[mn];\n        if (num + add < K) {\n          string tem = cur;\n          tem += (mn + '0');\n          while (((int)(tem).size()) < ((int)(n).size())) tem += '0';\n          if (smaller(tem, ans)) ans = tem;\n        } else {\n          int mn1 = mn;\n          for (int j = (0); j <= (mn - 1); ++j)\n            if (use[j]) {\n              mn1 = j;\n              break;\n            }\n          string tem = cur;\n          tem += (mn + '0');\n          while (((int)(tem).size()) < ((int)(n).size()))\n            tem += (char)(mn1 + '0');\n          if (smaller(tem, ans)) ans = tem;\n        }\n      }\n      if (!use[n[i] - '0']) num++, use[n[i] - '0'] = 1;\n      if (num > K) break;\n      cur += n[i];\n    }\n    if (num <= K) ans = cur;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int inf = 2e9;\nint T, n, k, n2, cnt, m, a[12], b[12], v[12];\nlong long ans;\ninline long long min(long long x, long long y) { return x < y ? x : y; }\nlong long dfs(int x) {\n  if (x == 0) return 0;\n  int t = std::lower_bound(b + 1, b + m + 1, a[x]) - b;\n  if (t > m) return inf;\n  if (b[t] == a[x]) {\n    int t2 = dfs(x - 1);\n    if (t2 != inf) return 1ll * b[t] * v[x] + t2;\n    if (t == m) return inf;\n    return 1ll * b[t + 1] * v[x] + 1ll * b[1] * (v[x] - 1) / 9;\n  }\n  return 1ll * b[t] * v[x] + 1ll * b[1] * (v[x] - 1) / 9;\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &k), ans = inf;\n    n2 = n / 10, a[cnt = 1] = n % 10, v[1] = 1;\n    while (n2) a[++cnt] = n2 % 10, v[cnt] = v[cnt - 1] * 10, n2 /= 10;\n    for (int i = 1, j; i < 1024; ++i)\n      if (__builtin_popcount(i) == k) {\n        m = 0, j = i;\n        while (j) b[++m] = __builtin_ctz(j), j ^= (1 << b[m]);\n        ans = min(ans, dfs(cnt));\n      }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nimport heapq\nfrom collections import deque\nfrom bisect import bisect_left\n\nDIGITS = [str(i) for i in range(10)]\n\n\ndef solve():\n    str_n, k = stdin.readline().split()\n    n = int(str_n)\n    k = int(k)\n    L = len(str_n)\n\n    best = '9' * L\n    for i in range(9):\n        foo = str(i) * L\n        if foo >= str_n:\n            best = min(best, foo)\n\n    if k == '1' or n < 10:\n        print(best)\n        return\n\n    remaining = k\n    ans = []\n    used = {str(i): 0 for i in range(10)}\n    idx = 0\n    ignore = False\n    while idx < L:\n        digit = str_n[idx]\n        if ignore:\n            if remaining > 0:\n                ans.append('0')\n                used['0'] += 1\n\n            else:\n                minimum = '9'\n                for x in DIGITS:\n                    if used[x] > 0:\n                        minimum = min(minimum, x)\n                ans.append(minimum)\n\n        elif used[digit]:\n            ans.append(digit)\n            used[digit] += 1\n\n        elif remaining >= 1:\n            used[digit] = 1\n            remaining -= 1\n            ans.append(digit)\n\n        # if remaining==0 and digit was not used before\n        else:\n            flag = True\n            for i in used.keys():\n                if used[i] and digit < i:\n                    flag = False  # can keep going\n                    ignore = True\n                    ans.append(i)\n                    break\n\n            if flag:  # should backtrack\n                while ans:\n                    curr = ans.pop(-1)\n                    idx -= 1\n                    used[curr] -= 1\n\n                    if used[curr] == 0:\n                        ignore = True\n                        foo = str(int(curr) + 1)\n                        ans.append(foo)\n                        used[foo] += 1\n                        if used[foo] > 1:\n                            remaining += 1\n                        break\n\n                    for j in DIGITS:\n                        if used[j] and j > curr:\n                            ans.append(j)\n                            used[j] += 1\n                            ignore = True\n                            break\n\n                    if ignore:\n                        break\n\n        idx += 1\n    print(''.join(ans))\n\n\nt = int(stdin.readline().strip())\n\nfor _ in range(t):\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint countDigits(int i) {\n  int z = 0, c = i;\n  while (c) {\n    z |= (1 << (c % 10)), c /= 10;\n  }\n  return __builtin_popcount(z);\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  while (countDigits(n) > k) {\n    int r = 1, l = n;\n    while (countDigits(l) > k) l /= 10, r *= 10;\n    r /= 10;\n    n = ((n / r) + 1) * r;\n  }\n  cout << n << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr);\n  int T;\n  cin >> T;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "// Oh boy this is gonna be fun\n\nimport com.sun.source.tree.Tree;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class F {\n\n    static FastScanner fs=new FastScanner();\n    static TreeSet<Long> one = new TreeSet<>(), two = new TreeSet<>();\n    public static void main(String[] args) {\n        int tt = 1;\n\n        for(int a = 0; a < 10; a++) {\n            for(int b = 0; b < 10; b++) {\n                for(int len = 1; len <= 10; len++) {\n                    for (int mask = 0; mask < (1 << len); mask++) {\n                        long x = 0;\n                        for (int i = 0; i < len; i++) {\n                            x = 10 * x;\n                            if ((mask >> i & 1) == 0) {\n                                x += a;\n                            } else {\n                                x += b;\n                            }\n                        }\n                        if (a == b) one.add(x);\n                        two.add(x);\n                    }\n                }\n            }\n        }\n\n        tt = fs.nextInt();\n        for(int w = 0; w < tt; w++) {\n            solve();\n        }\n    }\n\n    private static void solve() {\n        long n = fs.nextLong(), k = fs.nextLong();\n        if(k == 1) {\n            if(one.contains(n)) {\n                System.out.println(n);\n            } else {\n                System.out.println(one.higher(n));\n            }\n            return;\n        } else if(k == 2) {\n            if(two.contains(n)) {\n                System.out.println(n);\n            } else {\n                System.out.println(two.higher(n));\n            }\n            return;\n        }\n\n        char[] s = Long.toString(n).toCharArray();\n        int len = s.length;\n//        System.out.println(\"S: \" + new String(s));\n        int mask = 0;\n        for(int i = 0; i < len; i++) {\n            mask |= 1 << (s[i] - '0');\n        }\n        if(Integer.bitCount(mask) <= k) {\n            System.out.println(n);\n            return;\n        }\n        // take a big prefix\n        mask = 0;\n        long ans = 1;\n        for(int rep = 0; rep < len; rep++) {\n            ans = 10 * ans + 1;\n        }\n        for(int i = 0; i < len; i++) {\n            if(Integer.bitCount(mask) <= k) {\n                char[] t = new char[len];\n                for(int j = 0; j < len; j++) {\n                    t[j] = s[j];\n                }\n                for(int here = s[i] - '0' + 1; here < 10; here++) {\n                    t[i] = '0';\n                    t[i] += here;\n                    int new_mask = mask | (1 << here);\n                    // we are bigger for sure now\n                    if (Integer.bitCount(new_mask) <= k) {\n                        int smallest = Integer.numberOfTrailingZeros(new_mask);\n                        if(Integer.bitCount(new_mask) < k) smallest = 0;\n                        for(int j = i+1; j < len; j++) {\n                            t[j] = '0';\n                            t[j] += smallest;\n                        }\n//                        System.out.println(\"T: \" + new String(t));\n                        ans = Math.min(ans, Long.parseLong(new String(t)));\n                    }\n                }\n            }\n            mask |= 1 << (s[i] - '0');\n        }\n        System.out.println(ans);\n    }\n\n    private static void mySort(int[] a) {\n        int n = a.length;\n        Random rd = new Random(420);\n        for (int i = 0; i < n; i++) {\n            int j = rd.nextInt(i+1);\n            int tmp = a[j];\n            a[j] = a[i];\n            a[i] = tmp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n\n        int nextInt () {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef diff_digits(x):\n    \n    a=[0]*10\n    \n    n=x\n    \n    while 1:\n        if(n==0):\n            break\n        else:\n            a[n%10]+=1\n            n=n//10\n    \n    count=0\n    for i in a:\n        if(i>0):\n            count+=1\n    return [count,a]\n\n\ndef check(string,k,n):\n    #print('check string is: ',string)\n    temp=''\n    for i in string:\n        temp=temp+str(i)\n    \n    if(diff_digits(int(temp))[0]<=k):\n        return True\n    else:\n        return False\n\ndef print_output(t_arr):\n        temps=''\n        for klp in t_arr:\n    \n            temps=temps+str(klp)\n        return temps\n    \n\ndef strong(n_arr,t_arr,k,n,digits,i,flag):\n    \n    if(i>=digits):\n        return True\n        \n\n    \n    pl=int(n_arr[i])\n    \n\n        \n    if(flag):\n        for j in range(0,10):\n            t_arr[i]=j\n            if(check(t_arr[0:i+1],k,n)):\n                if(strong(n_arr,t_arr,k,n,digits,i+1,flag)):\n                    return print_output(t_arr)\n                \n    \n    else:\n        #print('iam here')\n        for j in range(pl,10):\n            t_arr[i]=j\n            if(check(t_arr[0:i+1],k,n)):\n                if(strong(n_arr,t_arr,k,n,digits,i+1,flag)):\n                    return print_output(t_arr)\n                \n                    \n            flag=True\n    \n    #print('t_arr is: ',t_arr)\n    return False\n        \n    \n    \n\n\ndef solver(t):\n    #print('inside solver')\n    n=int(t[0])\n    \n    k=int(t[1])\n    \n    get=diff_digits(n)\n    \n    if(get[0]<=k):\n        return n\n    \n    digits=int(math.log(n,10)) +1\n    \n    \n    n_str=t[0]\n    \n    t_arr=[0]*digits\n    \n    return strong(n_str,t_arr,k,n,digits,0,False)\n    \n    \n    \n    \n    \n\nif __name__==\"__main__\":\n    t=int(input())\n    \n    z=[None]*t\n    \n    for i in range(t):\n        z[i]=input().split(' ')\n    \n    for i in range(t):\n        print(solver(z[i]))"
        },
        {
            "language": 3,
            "solution": "def naiveSolve(n,k):\n    \n    i=n\n    while True:\n        i2=i\n        u=set()\n        while i2>0:\n            u.add(i2%10)\n            i2//=10\n        if len(u)<=k:\n            return i\n        i+=1\n    \n    return\n\ndef solve(n,k):\n    narr=[]\n    n2=n\n    while n2>0:\n        narr.append(n2%10)\n        n2//=10\n    narr.reverse()\n    \n    ansarr=[]\n    unique=set()\n    stoppingIndex=-1\n    for i,x in enumerate(narr):\n        if x in unique or len(unique)+1<=k:\n            ansarr.append(x)\n            unique.add(x)\n        else:\n            stoppingIndex=i\n            break\n    # print(unique,stoppingIndex,ansarr)\n    if stoppingIndex!=-1: # stopped\n        seen=sorted(unique)\n        if narr[stoppingIndex]<max(seen): # put a larger seen number\n            for x in seen:\n                if x>narr[stoppingIndex]:\n                    ansarr.append(x)\n                    break\n            while len(ansarr)<len(narr): # put smallest seen number\n                ansarr.append(min(seen))\n        else:\n            # narr[stoppingIndex]>max(seen). must increase some prev. number\n            i=stoppingIndex-1\n            while True:\n                ansarr[i]+=1\n                if ansarr[i]==10: # cannot\n                    ansarr.pop()\n                    i-=1\n                    continue\n                if len(set(ansarr))<=k: # ok\n                    break\n            \n            unique=set(ansarr)\n            if len(unique)==k-1: # place 0s\n                remaining=0\n            else: # place minimum previous\n                remaining=min(unique)\n            while len(ansarr)<len(narr):\n                ansarr.append(remaining)\n    ans=0\n    for x in ansarr:\n        ans*=10\n        ans+=x\n    return ans\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,k=readIntArr()\n        ans=solve(n,k)\n        allans.append(ans)\n    multiLineArrayPrint(allans)\n    \n    # for n in range(4000,5000):\n    #     for k in range(1,11):\n    #         ans=solve(n,k)\n    #         ans2=naiveSolve(n,k)\n    #         if ans!=ans2:\n    #             print('n:{} k:{} ans:{} actualAns:{}'.format(n,k,ans,ans2))\n    # print(solve(4889,2))\n    \n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int64_t maxn = 1e5 + 1;\nvoid solve() {\n  int64_t n, k;\n  cin >> n >> k;\n  int64_t m = n;\n  int64_t ans = 1;\n  int64_t pw = 1;\n  vector<int64_t> d, p, rp;\n  set<int64_t> st;\n  for (; n; n /= 10) {\n    d.push_back(n % 10);\n    p.push_back(pw);\n    rp.push_back(ans);\n    st.insert(n % 10);\n    pw *= 10;\n    ans += pw;\n  }\n  if (st.size() <= k) {\n    cout << m << '\\n';\n    return;\n  }\n  st.clear();\n  reverse(d.begin(), d.end());\n  reverse(p.begin(), p.end());\n  reverse(rp.begin(), rp.end());\n  int64_t x = 0;\n  for (int64_t i = 0; i < d.size(); i++) {\n    for (int64_t cd = d[i] + 1; cd <= 9; cd++) {\n      if (st.size() == k && !st.count(cd)) continue;\n      int64_t nx = x + p[i] * cd;\n      if (st.size() + (!st.count(cd)) + (!st.count(0)) > k)\n        nx += (rp[i] / 10) * min(cd, st.empty() ? cd : *st.begin());\n      ans = min(ans, nx);\n      break;\n    }\n    st.insert(d[i]);\n    if (st.size() > k) break;\n    x += p[i] * d[i];\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int64_t t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic Boolean[][][]memo;\n\tstatic char[]in;\n\tstatic int k;\n\tstatic boolean dp(int bigger,int i,int msk) {\n\t\tif(Integer.bitCount(msk)>k)return false;\n\t\tif(i==in.length)return true;\n\t\tif(memo[bigger][i][msk]!=null)return memo[bigger][i][msk];\n\t\tif(bigger==1) {\n\t\t\tboolean ans=false;\n\t\t\tfor(int c=0;c<10 && !ans;c++) {\n\t\t\t\tans|=dp(bigger, i+1, msk|(1<<c));\n\t\t\t}\n\t\t\treturn memo[bigger][i][msk]=ans;\n\t\t}\n\t\tboolean ans=dp(0, i+1, msk|(1<<(in[i]-'0')));\n\t\tfor(int c=(in[i]-'0')+1;c<10 && !ans;c++) {\n\t\t\tans|=dp(1, i+1, msk|(1<<c));\n\t\t}\n\t\treturn memo[bigger][i][msk]=ans;\n\t}\n\tstatic void trace(int bigger,int i,int msk) {\n\t\tif(i==in.length)return;\n\t\tif(bigger==1) {\n\t\t\tfor(int c=0;c<10;c++) {\n\t\t\t\tif(dp(bigger, i+1, msk|(1<<c))) {\n\t\t\t\t\tpw.print(c);\n\t\t\t\t\ttrace(bigger, i+1, msk|(1<<c));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(dp(0, i+1, msk|(1<<(in[i]-'0')))) {\n\t\t\tpw.print(in[i]);\n\t\t\ttrace(0, i+1, msk|(1<<(in[i]-'0')));\n\t\t\treturn;\n\t\t}\n\t\tfor(int c=(in[i]-'0')+1;c<10;c++) {\n\t\t\tif(dp(1, i+1, msk|(1<<c))) {\n\t\t\t\tpw.print(c);\n\t\t\t\ttrace(1, i+1, msk|(1<<c));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tstatic void main() throws Exception{\n\t\tin=sc.next().toCharArray();\n\t\tk=sc.nextInt();\n\t\tmemo=new Boolean[2][in.length][1<<10];\n\t\tif(!dp(0, 0, 0)) {\n\t\t\tif(k==1) {\n\t\t\t\tfor(int i=0;i<=in.length;i++)pw.print(1);\n\t\t\t\tpw.println();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpw.print(1);\n\t\t\tfor(int i=0;i<in.length;i++)pw.print(0);\n\t\t\tpw.println();\n\t\t\treturn;\n\t\t}\n\t\ttrace(0, 0, 0);\n\t\tpw.println();\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tsc=new MScanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tint tc=1;\n        tc=sc.nextInt();\n\t\tfor(int i=1;i<=tc;i++) {\n//\t\t\tpw.printf(\"Case #%d: \", i);\n\t\t\tmain();\n\t\t}\n\t\tpw.flush();\n\t}\n\tstatic PrintWriter pw;\n\tstatic MScanner sc;\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\t \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\t \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t\t\n\t}\n\tstatic void dbg(int[]in) {\n\t\tSystem.out.println(Arrays.toString(in));\n\t}\n\tstatic void dbg(long[]in) {\n\t\tSystem.out.println(Arrays.toString(in));\n\t}\n\tstatic void sort(int[]in) {\n\t\tshuffle(in);\n\t\tArrays.sort(in);\n\t}\n\tstatic void sort(long[]in) {\n\t\tshuffle(in);\n\t\tArrays.sort(in);\n\t}\n\tstatic void shuffle(int[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tint tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tlong tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import sys;t = int(input())\nfor i in range(t):\n    n,k = sys.stdin.readline().split();n = n.lstrip(\"000000000\");k = int(k);L = []\n    for s in n:\n        if int(s) not in L:L.append(int(s))\n    if len(L) <= k:print(n)\n    else:\n        L = L[:k];Num = list(map(int, n));ind = Num.index(L[-1]);maxL = max(L);bada = False;i = 0\n        while i < len(n):\n            if bada:Num[i] = 0\n            else:\n                if Num[i] > maxL:\n                    bada = True\n                    while Num[i] + 1 > maxL and i > ind:i -= 1\n                    Num[i] += 1\n                    if i == ind:\n                        L[-1] += 1\n                        if L[-1] in L[:-1]:L[-1] = 0\n                elif Num[i] not in L:bada = True\n            i += 1\n        L.sort();Go = dict();ind = 0\n        for i in range(L[-1]+1):\n            while i>L[ind]:ind+=1\n            Go[i] = str(L[ind])\n\n        minL = str(L[0])\n        bada = False\n        for i in range(len(Num)):\n            if bada == True: Num[i] = minL\n            else:\n                if (Num[i] not in L):\n                    bada = True\n                Num[i] = Go[Num[i]]\n        print(int(''.join(Num)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 5;\nconst int mod = 1e9 + 7;\nint digit[maxn];\nint dp[10][2][1 << 10];\nint n, k;\nint g[1 << 10];\nint dfs(int len, bool lim, int s) {\n  if (len == 0) return g[s] <= k;\n  int &x = dp[len][lim][s];\n  if (~x) return x;\n  int low = lim ? digit[len] : 0;\n  int ans = false;\n  for (int i = low; i <= 9; i++) {\n    ans |= dfs(len - 1, lim && i == low, s | (1 << i));\n    if (ans) break;\n  }\n  return x = ans;\n}\nlong long ksm(long long a, long long b) {\n  long long ans = 1, base = a;\n  while (b) {\n    if (b & 1) ans = ans * base % mod;\n    b >>= 1;\n    base = base * base % mod;\n  }\n  return ans;\n}\nlong long getans(int len, int lim, int s) {\n  if (len == 0) return 0;\n  int low = lim ? digit[len] : 0;\n  for (int i = low; i <= 9; i++) {\n    bool ok = dfs(len - 1, lim && i == low, s | (1 << i));\n    if (ok) {\n      return i * ksm(10, len - 1) +\n             getans(len - 1, lim && i == low, s | (1 << i));\n    }\n  }\n  return -1;\n}\nlong long solve() {\n  int k = 0;\n  while (n) {\n    digit[++k] = n % 10;\n    n /= 10;\n  }\n  memset(dp, -1, sizeof dp);\n  dfs(k, true, 0);\n  return getans(k, true, 0);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  g[0] = 0;\n  for (int i = 1; i < 1 << 10; i++) {\n    g[i] = g[i >> 1] + (i & 1);\n  }\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fun(long long n, long long k) {\n  string s = to_string(n);\n  long long sz = s.size();\n  vector<long long> mini(sz);\n  long long minimum = s[0] - '0';\n  set<char> st;\n  vector<long long> f(sz);\n  for (long long i = 0; i < sz; i++) {\n    mini[i] = min(minimum, (long long)(s[i] - '0'));\n    st.insert(s[i]);\n    f[i] = st.size();\n  }\n  if (st.size() <= k) return n;\n  long long x = 10000000000007;\n  long long c = 0;\n  for (long long i = sz - 2; i >= 0; i--) {\n    c++;\n    if (f[i] == k) {\n      set<long long> digits;\n      for (long long j = 0; j <= i; j++) {\n        st.insert(s[j] - '0');\n      }\n      long long d = s[i + 1] - '0';\n      if (digits.lower_bound(d) != digits.end()) {\n        d = *(digits.lower_bound(d));\n        for (long long j = i + 1; j < sz; j++) {\n          s[j] = d + '0';\n        }\n      } else {\n        long long z = pow(10, c - 1);\n        n = n / z;\n        n++;\n        n *= z;\n        long long p = fun(n, k);\n        return p;\n      }\n    }\n  }\n  return -1;\n}\nvoid solve(long long cc) {\n  long long n, k;\n  cin >> n >> k;\n  long long x = fun(n, k);\n  string s1 = to_string(x);\n  string s2 = to_string(n);\n  cout << x;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t = 1;\n  cin >> t;\n  long long c = 1;\n  while (t--) {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ;\n    solve(c);\n    c++;\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid write(vector<int> &v) {\n  for (auto i : v) cout << i << \" \";\n  cout << \"\\n\";\n}\nvoid read(vector<int> &v) {\n  for (auto &i : v) cin >> i;\n}\nconst int INF = 1e9;\nconst int64_t INFF = 1e18;\nconst int N = 1e6 + 69;\nint k;\nstring s;\nstring calc(int index, string ans) {\n  set<char> st((ans).begin(), (ans).end());\n  if ((int)(st).size() > k) return \"\";\n  if (ans.substr(0, index) < s.substr(0, index)) return \"\";\n  if (index >= s.length()) {\n    return ans;\n  }\n  for (char c = '0'; c <= '9'; c++) {\n    ans.push_back(c);\n    string pos = calc(index + 1, ans);\n    ans.pop_back();\n    if (pos.length() == s.length()) return pos;\n  }\n}\nvoid solve() {\n  cin >> s;\n  cin >> k;\n  cout << calc(0, \"\") << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\n\ndef comp(arr1,arr2):\n    # arr1 = ans\n    if len(arr1) > len(arr2):\n        return 1\n    if len(arr1) < len(arr2):\n        return 0\n    for i,j in zip(arr1,arr2):\n        if i > j:\n            return 1\n        if i < j:\n            return 0\n\ndef main():\n    for _ in range(int(input())):\n        n,k = input().split()\n        k = int(k)\n        n = list(map(int,n))\n        if len(Counter(n)) <= k:\n            print(''.join(map(str,n)))\n            continue\n        le = len(n)\n        ans = [1]+[0]*le if k >= 2 else [1]*(le+1)\n        curr = []\n        mini = float(\"inf\")\n        uni = Counter()\n        for idx,i in enumerate(n):\n            if len(uni) > k:\n                break\n            for j in range(i+1,10):\n                uni[j] += 1\n                if len(uni) < k:\n                    poss = curr + [j] + [0]*(le-idx-1)\n                    if comp(ans,poss):\n                        ans = poss\n                elif len(uni) == k:\n                    mini1 = min(mini,j)\n                    poss = curr + [j] + [mini1]*(le-idx-1)\n                    if comp(ans,poss):\n                        ans = poss\n                uni[j] -= 1\n                if not uni[j]:\n                    del uni[j]\n            mini = min(mini,i)\n            curr += [i]\n            uni[i] += 1\n        print(''.join(map(str,ans)))\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 3,
            "solution": "import sys\n#import random\nfrom bisect import bisect_right as lb\nfrom collections import deque\n#sys.setrecursionlimit(10**8)\nfrom queue import PriorityQueue as pq\n#from math import *\ninput_ = lambda: sys.stdin.readline().strip(\"\\r\\n\")\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab,bc,cd : ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x : print(x)\nprinT = lambda x : print(x)\nf = lambda : sys.stdout.flush()\ninv =lambda x:pow(x,mod-2,mod)\nmod = 10**9 + 7\n\ndig = {}\nans = 0\ns = \"\"\nk = 0\n\ndef dp (i,t) :\n    global dig,s,k,ans\n\n    if (i == len(s)) :\n        return ans\n\n    tot = 0\n\n    for j in range (10) :\n        if (t and j < int(s[i])) :\n            continue\n        if (tot >= 2) :\n            continue\n        if (len(dig) == k and (not dig.get(j))) :\n            continue\n\n        ans *= 10\n        ans += j\n\n        flag = dig.get(j,0)\n\n        if (not flag) :\n            dig[j] = 1\n\n        temp = dp(i+1,t and (j == int(s[i])))\n\n        if (temp!= -1) :\n            return temp\n\n        if (not flag) :\n            del dig[j]\n\n        ans //= 10\n\n    return -1\n\nfor _ in range (ii()) :\n    n,k = il()\n\n    s = str(n)\n    ans = 0\n    dig = {}\n\n    print(dp(0,1))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)5e+3 + 8;\nstring cal(int j, const string &n, int dist, const int &k, string nw) {\n  if (dist > k) {\n    return \"\";\n  }\n  if ((nw.substr(0, j)) < (n.substr(0, j))) {\n    return \"\";\n  }\n  if (j >= ((int)(n).size())) {\n    return nw;\n  }\n  for (char c = '0'; c <= '9'; c++) {\n    bool found = false;\n    nw[j] = c;\n    for (int i = 0; i < j; i++) {\n      if (nw[i] == c) {\n        found = true;\n        break;\n      }\n    }\n    string ch = cal(j + 1, n, dist + (found == false), k, nw);\n    if (((int)(ch).size())) return ch;\n  }\n  return \"\";\n}\nvoid MAIN(long long tc) {\n  string n;\n  long long k;\n  cin >> n >> k;\n  string ans = cal(0, n, 0, k, string(((int)(n).size()), '0'));\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << fixed;\n  cout << setprecision(10);\n  int test__cases = 1;\n  cin >> test__cases;\n  for (int i = 1; i <= test__cases; i++) {\n    MAIN(i);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 26;\ntemplate <typename T>\ninline bool scan_d(T& ret) {\n  char c;\n  int sgn;\n  if (c = getchar(), c == EOF) return 0;\n  while (c != '-' && (c < '0' || c > '9')) {\n    if ((c = getchar()) == EOF) return 0;\n  }\n  sgn = (c == '-') ? -1 : 1;\n  ret = (c == '-') ? 0 : (c - '0');\n  while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');\n  ret *= sgn;\n  return 1;\n}\ntemplate <typename T>\nvoid print(T x) {\n  static char s[33], *s1;\n  s1 = s;\n  if (!x) *s1++ = '0';\n  if (x < 0) putchar('-'), x = -x;\n  while (x) *s1++ = (x % 10 + '0'), x /= 10;\n  while (s1-- != s) putchar(*s1);\n}\ntemplate <typename T>\nvoid println(T x) {\n  print(x);\n  putchar('\\n');\n}\nint n, k;\nset<int> num2set(int val) {\n  set<int> mset;\n  while (val) {\n    mset.insert(val % 10);\n    val /= 10;\n  }\n  return mset;\n}\nint solve(int val) {\n  while (true) {\n    set<int> mset = num2set(val);\n    if (mset.size() <= k) return val;\n    if (val % 10 == 0) {\n      int pre = val / 10;\n      int spre = solve(pre);\n      mset = num2set(spre);\n      return spre * 10 + *mset.begin();\n    }\n    val++;\n  }\n  return 0;\n}\nint main() {\n  int T;\n  scan_d(T);\n  for (int t = (0); t < (T); ++t) {\n    scan_d(n), scan_d(k);\n    println(solve(n));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool run(int i, string &s, string &ans, int k, unordered_map<int, int> &m,\n         bool greater) {\n  int n = s.length();\n  if (i == n) return true;\n  int d = greater ? 0 : s[i] - '0';\n  while (d < 10) {\n    if (m.find(d) != m.end() || m.size() < k) {\n      m[d]++;\n      ans[i] = d + '0';\n      bool f = run(i + 1, s, ans, k, m, greater || (s[i] - '0' < d));\n      if (f) return true;\n      m[d]--;\n      if (m[d] == 0) m.erase(d);\n    }\n    d++;\n  }\n  return false;\n}\nint solve(int n, int k) {\n  unordered_map<int, int> m;\n  int x = log10(n);\n  x = pow(10, x);\n  string s = to_string(n);\n  string ans = to_string(x);\n  run(0, s, ans, k, m, false);\n  return stoi(ans);\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    cout << solve(n, k) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def lower_bound(nums,x):\n    for i in range(len(nums)):\n        if nums[i]>=x:\n            return i\n    return -1\n\ndef check(n,k,num,pos,_n,wid):\n    x=num\n    nums=dict()\n    while x>0:\n        nums.setdefault(x%10,0)\n        x//=10\n    nums=list(nums.keys())\n    nums.sort()\n    flag=0\n    for i in range(pos,wid):\n        tmp=int(_n[i])\n        x=lower_bound(nums,tmp) if flag==0 else 0\n        if x==-1:\n            return -1\n        if flag==0 and nums[x]>tmp:\n            flag=1\n        num=num*10+nums[x]\n    return num\n\ndef work(n,k):\n    res=10**11\n    _n=str(n)\n    wid=len(_n)\n    vis=dict()\n    tmp=0\n    cnt=0\n    for i in range(wid):\n        num=int(_n[i])\n        vis.setdefault(num,0)\n        if vis[num]==1:\n            tmp=tmp*10+num\n            continue\n        if cnt==k:\n            res=check(n,k,tmp,i,_n,wid)\n            if res==-1:\n                return work((tmp+1)*(10**(wid-i)),k)\n            return res\n        cnt+=1\n        vis[num]=1\n        tmp=tmp*10+num\n    return tmp\n\n_t=int(input())\nfor _c in range(_t):\n    n,k=map(int,input().split())\n    print(work(n,k))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[12];\nint len, ans, k;\nint cal(int mask) { return __builtin_popcount(mask); }\nvoid dfs(int lim, int pos, int mask, int sum) {\n  if (pos == len + 1) {\n    ans = sum;\n    return;\n  }\n  int start = 0;\n  if (lim) {\n    start = s[pos];\n  }\n  for (int i = start; i <= 9; i++) {\n    if (ans == 0 && cal(mask | (1 << i)) <= k) {\n      dfs(lim && i == start, pos + 1, mask | (1 << i), sum * 10 + i);\n    }\n  }\n}\nint main() {\n  int t;\n  int n;\n  cin >> t;\n  while (t--) {\n    scanf(\"%s\", s + 1);\n    cin >> k;\n    len = strlen(s + 1);\n    for (int i = 1; i <= len; i++) {\n      s[i] -= '0';\n    }\n    ans = 0;\n    dfs(1, 1, 0, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class F {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(br.readLine());\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (t-- > 0) {\n\t\t\tString[] scn = (br.readLine()).trim().split(\" \");\n\t\t\tString str = scn[0];\n\t\t\tint k = Integer.parseInt(scn[1]);\n\t\t\tint n = str.length();\n\t\t\tint[] orig = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\torig[i] = str.charAt(i) - '0';\n\t\t\t}\n\t\t\tint[] myans = new int[n];\n\t\t\tfun(myans, orig, 0, n, k, 0);\n\t\t\tfor (int ele : myans) {\n\t\t\t\tsb.append(ele);\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t\treturn;\n\n\t}\n\n\tpublic static int fun(int[] myans, int[] orig, int i, int n, int k, int myk) {\n\t\tif (myk > k) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!check(myans, orig, i)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (i >= n) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (int dig = 0; dig < 10; dig++) {\n\t\t\tif (i == 0 && dig == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmyans[i] = dig;\n\t\t\tboolean present = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (myans[j] == dig)\n\t\t\t\t\tpresent = true;\n\t\t\t}\n\t\t\tint recans = fun(myans, orig, i + 1, n, k, myk + (present ? 0 : 1));\n\t\t\tif (recans != -1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\n\t}\n\n\tpublic static boolean check(int[] myans, int[] orig, int n) {\n\t\tboolean equal = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (myans[i] > orig[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ((myans[i] < orig[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\tpublic static void sort(long[] arr) {\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = (int) (Math.random() * n);\n\t\t\tlong temp = arr[i];\n\t\t\tarr[i] = arr[idx];\n\t\t\tarr[idx] = temp;\n\t\t}\n\t\tArrays.sort(arr);\n\t}\n\n\tpublic static void sort(int[] arr) {\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = (int) (Math.random() * n);\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[idx];\n\t\t\tarr[idx] = temp;\n\t\t}\n\t\tArrays.sort(arr);\n\t}\n\n\tpublic static void print(long[][] dp) {\n\t\tfor (long[] a : dp) {\n\t\t\tfor (long ele : a) {\n\t\t\t\tSystem.out.print(ele + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void print(int[][] dp) {\n\t\tfor (int[] a : dp) {\n\t\t\tfor (int ele : a) {\n\t\t\t\tSystem.out.print(ele + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void print(int[] dp) {\n\t\tfor (int ele : dp) {\n\t\t\tSystem.out.print(ele + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void print(long[] dp) {\n\t\tfor (long ele : dp) {\n\t\t\tSystem.out.print(ele + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = ' ';\n  while (!isdigit(ch)) {\n    ch = getchar();\n    if (ch == '-') f = -1;\n  }\n  while (isdigit(ch)) x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  return x * f;\n}\nset<int> st;\nvoid solve() {\n  string n;\n  int k;\n  cin >> n >> k;\n  while (1) {\n    set<char> s;\n    for (auto c : n) s.insert(c);\n    if (s.size() <= k) break;\n    s.clear();\n    int cnt = 0;\n    while (1) {\n      s.insert(n[cnt]);\n      if (s.size() > k) {\n        while (n[cnt] == '9') cnt--;\n        n[cnt]++;\n        for (int i = cnt + 1; i < n[i]; i++) n[i] = '0';\n        break;\n      }\n      cnt++;\n    }\n  }\n  cout << n << endl;\n}\nint main() {\n  int t = read();\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\nusing namespace std;\nconst long long N = 1e5 + 1, mod = 1e9 + 7;\nlong long itos(long long n, long long ch[]) {\n  long long j = n, l = 0;\n  while (j) {\n    j /= 10;\n    l++;\n  }\n  for (long long i = l - 1; i >= 0; i -= 1) {\n    ch[i] = n % 10;\n    n /= 10;\n  }\n  return l;\n}\nlong long stoi(long long ch[], long long l) {\n  long long n = 0;\n  for (long long i = 0; i < l; i += 1) {\n    n *= 10;\n    n += ch[i];\n    ;\n  }\n  return n;\n}\nvoid solve() {\n  string n;\n  long long k;\n  cin >> n >> k;\n  while (true) {\n    set<char> s;\n    for (auto x : n) {\n      s.insert(x);\n    }\n    if (s.size() <= k) {\n      cout << n << \"\\n\";\n      return;\n    }\n    s.clear();\n    for (long long i = 0; i < n.size(); i += 1) {\n      s.insert(n[i]);\n      if (s.size() > k) {\n        while (n[i] == '9') i--;\n        n[i]++;\n        i++;\n        for (; i < n.size(); i += 1) {\n          n[i] = '0';\n        }\n      }\n    }\n  }\n  return;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200009;\nvector<int> a;\nstring in;\nint k;\nstring build(string s, vector<char> ch, int ind, bool bigger) {\n  char nw = s[ind];\n  if (ind == s.size()) return s;\n  string tmp;\n  if (bigger) {\n    for (char c = '0'; c <= '9'; ++c) {\n      bool check = true;\n      for (int i = 0; i < ch.size() && check; ++i)\n        if (ch[i] == c) check = false;\n      if (check == false) {\n        s[ind] = c;\n        tmp = build(s, ch, ind + 1, 1);\n        if (tmp != \"-1\") return tmp;\n        s[ind] = nw;\n      } else {\n        if (ch.size() == k) continue;\n        ch.push_back(c);\n        s[ind] = c;\n        tmp = build(s, ch, ind + 1, 1);\n        s[ind] = nw;\n        if (tmp != \"-1\") return tmp;\n        ch.pop_back();\n      }\n    }\n  } else {\n    for (char c = nw; c <= '9'; ++c) {\n      bool check = true;\n      for (int i = 0; i < ch.size() && check; ++i)\n        if (ch[i] == c) check = false;\n      if (check == true) {\n        if (ch.size() == k) continue;\n        ch.push_back(c);\n        s[ind] = c;\n        if (c == nw)\n          tmp = build(s, ch, ind + 1, 0);\n        else\n          tmp = build(s, ch, ind + 1, 1);\n        if (tmp != \"-1\") return tmp;\n        s[ind] = nw;\n        ch.pop_back();\n      } else {\n        s[ind] = c;\n        if (c == nw)\n          tmp = build(s, ch, ind + 1, 0);\n        else\n          tmp = build(s, ch, ind + 1, 1);\n        s[ind] = nw;\n        if (tmp != \"-1\") return tmp;\n      }\n    }\n  }\n  return \"-1\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> in >> k;\n    vector<char> v;\n    cout << build(in, v, 0, 0) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\nimport os\nimport math\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict,Counter,deque\nimport bisect\n# input=sys.stdin.readline\n# def print(x):\n#     sys.stdout.write(str(x)+\"\\n\")\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\n# sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# sys.stdout=open(\"CP1/output.txt\",'w')\n# sys.stdin=open(\"CP1/input.txt\",'r')\n\n# mod=pow(10,9)+7\n\nt=int(input())\nfor i in range(t):\n\tn,k=input().split()\n\tk=int(k)\n\tn1=list(map(int,n))\n\t# a=list(map(int,input().split()))\n\t# n=input()\n\ts1=set()\n\tl=len(n1)\n\tans=[]\n\tfor j in range(l):\n\t\tif n1[j] in s1:\n\t\t\tans.append(n1[j])\n\t\telif len(s1)<k:\n\t\t\ts1.add(n1[j])\n\t\t\tans.append(n1[j])\n\t\telse:\n\t\t\tma=10\n\t\t\tfor kk in s1:\n\t\t\t\tif kk>n1[j]:\n\t\t\t\t\tma=min(ma,kk)\n\n\t\t\tif ma!=10:\n\t\t\t\tans.append(ma)\n\t\t\t\tans.extend([min(s1)]*(l-len(ans)))\n\t\t\tbreak\n\n\n\tif len(ans)==l:\n\t\tans=''.join(map(str,ans))\n\t\tprint(ans)\n\telse:\n\t\tif k==1:\n\t\t\tprint(str(ans[0]+1)*l)\n\t\t\tcontinue\n\n\t\tfinal=sorted(s1)\n\t\tl1=len(final)\n\t\tans1=10**10\n\n\t\tfor j in range(1,len(ans)):\n\t\t\ts=set(ans[:j])\n\t\t\tmi=min(s)\n\t\t\tif len(s)==k:\n\t\t\t\tind=bisect.bisect_right(final,ans[j])\n\t\t\t\tif ind!=l1:\n\t\t\t\t\tcur=ans[:j]+[final[ind]]\n\t\t\t\telse:\n\t\t\t\t\tcur=[]\n\t\t\t\t\tfor kk in range(j+1):\n\t\t\t\t\t\tif ans[kk]==final[-1]:\n\t\t\t\t\t\t\tcur.append(ans[kk]+1)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcur.append(ans[kk])\n\n\t\t\t\tcur.extend([mi]*(l-j-1))\n\n\t\t\telse:\n\t\t\t\tcur=ans[:j]+[ans[j]+1]\n\t\t\t\ts.add(ans[j]+1)\n\t\t\t\tif len(s)==k:\n\t\t\t\t\tcur.extend([min(s)]*(l-j-1))\n\t\t\t\telse:\n\t\t\t\t\tcur.extend([0]*(l-j-1))\n\n\n\t\t\t# print(cur)\n\t\t\tans1=min(ans1,int(''.join(map(str,cur))))\n\n\n\t\tprint(ans1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid SolveF();\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  SolveF();\n  return 0;\n}\nvoid SolveF() {\n  int T;\n  cin >> T;\n  while (T--) {\n    long long n;\n    int k;\n    cin >> n >> k;\n    int currk[11];\n    int minInt[11];\n    int a[10];\n    memset(a, 0, sizeof(a));\n    string s = to_string(n);\n    int lens = s.length();\n    ++a[s[0] - '0'];\n    currk[0] = 1;\n    minInt[0] = s[0] - '0';\n    for (int i = 1; i < lens; ++i) {\n      if (a[s[i] - '0'] == 0) {\n        currk[i] = currk[i - 1] + 1;\n        minInt[i] =\n            ((minInt[i - 1]) < (s[i] - '0') ? (minInt[i - 1]) : (s[i] - '0'));\n      } else {\n        currk[i] = currk[i - 1];\n        minInt[i] = minInt[i - 1];\n      }\n      ++a[s[i] - '0'];\n    }\n    if (k == currk[lens - 1]) {\n      cout << s << endl;\n      continue;\n    } else if (k > lens) {\n      cout << s << endl;\n    } else if (k > currk[lens - 1]) {\n      cout << s << endl;\n    } else {\n      while (1) {\n        int pos = 0;\n        for (int i = 0; i < 10; ++i) {\n          a[i] = 0;\n          currk[i] = 0;\n        }\n        currk[0] = 1;\n        a[s[0] - '0'] = 1;\n        for (int i = 1; i < lens; ++i) {\n          if (a[s[i] - '0'] == 0)\n            currk[i] = currk[i - 1] + 1;\n          else\n            currk[i] = currk[i - 1];\n          ++a[s[i] - '0'];\n        }\n        if (k >= currk[lens - 1]) break;\n        for (int i = 0; i < lens; ++i) {\n          if (currk[i] == k + 1) {\n            pos = i;\n            break;\n          }\n        }\n        while (s[pos] == 9 + '0') --pos;\n        ++s[pos];\n        for (int i = pos + 1; i < lens; ++i) s[i] = '0';\n      }\n      cout << s << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "# \u3067\u3064oO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)\nimport sys\ndef main(N, K):\n    S = str(N)\n    d = len(S)\n\n    if d <= K:\n        return N\n    if len(set(S)) <= K:\n        return N\n\n    for i in range(d - 1, -1, -1):\n        up = set(S[:i])\n        if len(up) > K:\n            continue\n        if len(up) == K:\n            n = int(S[i])\n            for m in sorted(up):\n                if int(m) > n: break\n            else: continue\n            res = S[:i] + m\n            mn = min(up)\n            for _ in range(i + 1, d):\n                res += mn\n            return int(res)\n        n = int(S[i])\n        if n == 9: continue\n        m = str(n + 1)\n        res = S[:i] + m\n        up.add(m)\n        if len(up) == K:\n            mn = min(up)\n            for _ in range(i + 1, d):\n                res += mn\n            return int(res)\n        for _ in range(i + 1, d):\n            res += '0'\n        return int(res)\n\nif __name__ == '__main__':\n    input = sys.stdin.readline\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        print(main(N, K))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nbool check(int32_t n, int32_t k) {\n  int32_t mask = 0;\n  while (n > 0) {\n    mask |= 1 << (n % 10);\n    n /= 10;\n  }\n  return __builtin_popcount(mask) <= k;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  int32_t num_tests;\n  std::cin >> num_tests;\n  for (int32_t t = 0; t < num_tests; t++) {\n    int32_t n, k;\n    std::cin >> n >> k;\n    std::vector<int32_t> digits;\n    int32_t n2 = n;\n    while (n2 > 0) {\n      digits.push_back(n2 % 10);\n      n2 /= 10;\n    }\n    std::reverse(digits.begin(), digits.end());\n    int64_t answer = 1;\n    while (answer < n) answer = answer * 10 + 1;\n    int64_t pref = 0;\n    for (int32_t i = 0; i <= digits.size(); i++) {\n      for (int32_t p1 = 0; p1 <= 10; p1++)\n        for (int32_t p2 = 0; p2 <= 10; p2++) {\n          int64_t new_num = pref;\n          if (i == 0 && p1 == 0) continue;\n          if (new_num >= n && check(new_num, k))\n            answer = std::min(answer, new_num);\n          new_num = new_num * 10 + p1;\n          while (new_num < n) {\n            new_num = new_num * 10 + p2;\n          }\n          if (new_num >= n && check(new_num, k))\n            answer = std::min(answer, new_num);\n        }\n      pref *= 10;\n      pref += digits[i];\n    }\n    std::cout << answer << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    a,k=input().split()\n    k=int(k)\n    k0=k\n    b=[0]*10\n    a=[int(i) for i in a]\n    j=0\n    m=9\n    mx=0\n    for i in a:\n        if b[i]==0:\n            k-=1\n        if k<0:\n            break\n        j+=1\n        b[i]+=1\n        m=min(m,i)\n        mx=max(mx,i)\n    if j==len(a): \n        print(*a,sep='')\n        continue\n    for i in range(a[j]+1,10):\n        if b[i]:\n            a[j]=i\n            for k in range(j+1,len(a)):\n                a[k]=m\n            break\n    else:\n        b1=[0]*10\n        j1=j\n        for i in range(j1):\n            if b1[a[i]]==0 or a[i]!=mx:\n                j=i+1\n                b1[a[i]]=1\n        if b[a[j-1]]==1 or a[j-1]==mx:\n            a[j-1]+=1\n        else:\n            while b[a[j-1]+1]==0:\n                a[j-1]+=1\n            a[j-1]+=1\n        b=[0]*10\n        for i in range(j):\n            b[a[i]]+=1\n        if 10-b.count(0)<k0:\n            for i in range(j,len(a)):\n                a[i]=0\n        else:\n            m=9\n            for i in range(10):\n                if b[i]: m=min(m,i)\n            for i in range(j,len(a)):\n                a[i]=m\n    print(*a,sep='')"
        },
        {
            "language": 4,
            "solution": "// \"static void main\" must be defined in a public class.\n\n//System.out.println();\n// System.out.print();\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \n    \n    static boolean isPrime(int n)\n    {\n        // Corner cases\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n         \n        // This is checked so that we can skip\n        // middle five numbers in below loop\n        if (n % 2 == 0 || n % 3 == 0) return false;\n         \n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n         \n        return true;\n    }\n     \n    // Function to return the smallest\n    // prime number greater than N\n    static int nextPrime(int N)\n    {\n     \n        // Base case\n        if (N <= 1)\n            return 2;\n     \n        int prime = N;\n        boolean found = false;\n     \n        // Loop continuously until isPrime returns\n        // true for a number greater than n\n        while (!found)\n        {\n            prime++;\n     \n            if (isPrime(prime))\n                found = true;\n        }\n     \n        return prime;\n    }\n    \n    \n    public static int findXorSum(int arr[], int n)\n    {\n        // variable to store\n        // the final sum\n        long sum = 0;\n     \n        // multiplier\n        long mul = 1;\n     \n        for (int i = 0; i < 30; i++)\n        {\n     \n            // variable to store number of\n            // sub-arrays with odd number of elements\n            // with ith bits starting from the first\n            // element to the end of the array\n            long c_odd = 0;\n     \n            // variable to check the status\n            // of the odd-even count while\n            // calculating c_odd\n            boolean odd = false;\n     \n            // loop to calculate initial\n            // value of c_odd\n            for (int j = 0; j < n; j++)\n            {\n                if ((arr[j] & (1 << i)) > 0)\n                    odd = (!odd);\n                if (odd)\n                    c_odd++;\n            }\n     \n            // loop to iterate through\n            // all the elements of the\n            // array and update sum\n            for (int j = 0; j < n; j++)\n            {\n                sum += (mul%1000000007 * c_odd%1000000007)%1000000007;\n     \n                if ((arr[j] & (1 << i)) > 0)\n                    c_odd = (n - j - c_odd);\n            }\n     \n            // updating the multiplier\n            mul = (mul%1000000007 * 2)%1000000007;\n        }\n     \n        // returning the sum\n        return (int)sum;\n    }\n    \n    \n    public static long fact(long n)\n    {\n        return (n == 1 || n == 0) ? 1 : n * fact(n - 1);\n    }\n    \n    public static long nCr(long n, long r){\n        return fact(n) / (fact(r) * fact(n - r));\n    }\n    \n    public static long nPr(long n, long r){\n        return fact(n) / fact(n - r);\n    }\n    \n    public static long gcd(long a , long b){\n        if(b==0){\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n    \n    public static long lcm(long a, long b){return (a*b)/gcd(a,b);}\n    \n    public static long fPow(long x, long y, long p){\n        long res = 1; // Initialize result\n\n        x = x % p; // Update x if it is more than or\n        // equal to p\n\n        if (x == 0)\n          return 0; // In case x is divisible by p;\n\n        while (y > 0)\n        {\n\n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n\n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n    }\n    \n    public static int binS(int[] sortedArray, int key, int low, int high) {\n    int index = Integer.MAX_VALUE;\n    \n    while (low <= high) {\n        int mid = low  + ((high - low) / 2);\n        if (sortedArray[mid] < key) {\n            low = mid + 1;\n        } else if (sortedArray[mid] >= key) {\n            high = mid - 1;\n        }\n        // else if (sortedArray[mid] == key) {\n        //     low = mid;\n        //     break;\n        // }\n    }\n    return low;\n}\n    \n    public static int binS1(int[] sortedArray, int key, int low, int high) {\n    int index = Integer.MAX_VALUE;\n    \n    while (low <= high) {\n        int mid = low  + ((high - low) / 2);\n        if (sortedArray[mid] <= key) {\n            low = mid + 1;\n        } else if (sortedArray[mid] > key) {\n            high = mid - 1;\n        }\n        // else if (sortedArray[mid] == key) {\n        //     low = mid;\n        //     break;\n        // }\n    }\n    return high;\n}\n        \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        for(int q=0;q<t;q++){\n            // int n = Integer.parseInt(br.readLine());\n            String s1[] = br.readLine().split(\" \");\n            // int n = Integer.parseInt(s[0]);\n            String s = s1[0];\n            int k = Integer.parseInt(s1[1]);\n            // int c = Integer.parseInt(s[2]);\n            // String s1[] = br.readLine().split(\" \");\n            // int a[] = new int[n];\n            // for(int i=0;i<n;i++){\n            //     a[i] = Integer.parseInt(s1[i]);\n            // }\n            HashMap<Integer,Integer> hm = new HashMap<>();\n            int n = s.length();\n            int min=Integer.MAX_VALUE;\n            for(int i=0;i<n;i++){\n                int num = (int)s.charAt(i)-48;\n                \n                // System.out.println(num);\n                if(hm.containsKey(num)){\n                    hm.replace(num,hm.get(num)+1);\n                }\n                else if(!hm.containsKey(num) && hm.size()<k){\n                    hm.put(num,1);\n                }\n                else{\n                    int num1 = (int)s.charAt(i-1)-48;\n                    if(num<num1){\n                        int tmp1=0;\n                        for(int ii=0;ii<10;ii++){\n                            if(hm.containsKey(ii)){\n                                num1=ii;\n                                break;\n                            }\n                        }\n                        int last=0;\n                        for(int ii=num;ii<10;ii++){\n                            if(hm.containsKey(ii)){\n                                last=ii;\n                                break;\n                            }\n                        }\n                        // if(hm.containsKey(last)){\n                        //         num1=0;\n                        //     }\n                        if(min>last){\n                            min=last;\n                        }\n                        String str = (last)+\"\";\n                        for(int ii=0;ii<(n-i-1);ii++){\n                            str = str.concat(num1+\"\");\n                        }\n                        s = s.substring(0,i)+str;\n                        break;\n                    }\n                    else{\n                        int ind=i-1;\n                        int big = -1;\n                        int num11=-1;\n                        for(int ii=0;ii<10;ii++){\n                            if(hm.containsKey(ii)){\n                                num11=ii;\n                                break;\n                            }\n                        }\n                        min = num11;\n                        \n                        for(int ii=num;ii<10;ii++){\n                            if(hm.containsKey(ii)){\n                                big=ii;\n                                break;\n                            }\n                        }\n                        if(min>big){\n                            min=big;\n                        }\n                        \n                        // System.out.println(big);\n                        if(big==-1){\n                            int temp=-2;\n                        while(hm.size()>=k){\n                            int num2 = (int)s.charAt(ind)-48;\n                            hm.replace(num2,hm.get(num2)-1);\n                            if(hm.get(num2)==0){\n                                temp=num2;\n                                hm.remove(num2);\n                            }\n                            if(temp==-2){\n                            for(int ii=num2+1;ii<10;ii++){\n                            if(hm.containsKey(ii)){\n                                big=ii;\n                                break;\n                            }\n                        }\n                            if(big!=-1){\n                                ind--;\n                                hm.remove(big);\n                                break;\n                            }\n                            }\n                            ind--;\n                        }\n                            \n                         if(temp!=-2)\n                         big = temp+1;\n                            min=big;\n                            for(int ii=0;ii<10;ii++){\n                            if(hm.containsKey(ii) && min>ii){\n                                min=ii;\n                                break;\n                            }\n                        }\n                            if(hm.containsKey(big)){\n                                min=0;\n                            }\n                        }\n                        \n                        ind++;\n                        String str = big+\"\";\n                        for(int ii=0;ii<(n-ind-1);ii++){\n                            str = str.concat(min+\"\");\n                        }\n                        s = s.substring(0,ind)+str;\n                        // System.out.println(s);\n                        break;\n                    }\n                }\n            }\n            System.out.println(s);\n        }\n    }\n}\n//1116776899 3"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    public static void test() {\n        int t = 10_000;\n        Random r = new Random();\n\n        long start = System.currentTimeMillis();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < t; i++) {\n            int n = r.nextInt(1_000_000_000) + 1;\n            n = 127654389;\n            int k = r.nextInt(10) + 1;\n            k = 8;\n            int x = findNext(n, k);\n//            int y = findNextBrute(n, 2);\n//            if (x != y) {\n//                System.out.println(n + \" 2\\n\" + x + \" ? \" + y);\n//            }\n            sb.append(x).append('\\n');\n        }\n//        System.out.println(sb.toString());\n        System.out.println(\"Done: \" + (System.currentTimeMillis() - start));\n    }\n\n    private static final int[][] bitDigits = new int[1025][];\n\n    static {\n        for (int i = 0; i < bitDigits.length; i++) {\n            bitDigits[i] = new int[Integer.bitCount(i)];\n            int pos = 0;\n            for (int bit = 0; bit < 10; bit++) {\n                if ((i & (1 << bit)) != 0) {\n                    bitDigits[i][pos++] = bit;\n                }\n            }\n        }\n        Arrays.sort(bitDigits, Comparator.comparingInt(o -> o.length));\n    }\n\n    private static Map<Long, Integer> cache = new HashMap<>();\n\n    public static void main(String[] args) throws IOException {\n\n        // test();\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1024 * 1024 * 2);\n        // br = new BufferedReader(new FileReader(\"src/codeforces/div3/_739/input.txt\"), 1024 * 1024 * 2);\n\n\n        int t = Integer.parseInt(br.readLine());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int[] v = readArrayLine(br.readLine(), 2);\n            sb.append(findNext(v[0], v[1])).append(\"\\n\");\n        }\n\n        System.out.println(sb.toString());\n    }\n\n    private static int numOfDigits(long n) {\n        int i = 0;\n        while (n > 0) {\n            n /= 10;\n            i++;\n        }\n        return i;\n    }\n\n    private static int getFirstDigit(long n) {\n        int d = 0;\n        while (n > 0) {\n            d = (int) (n % 10);\n            n /= 10;\n        }\n        return d;\n    }\n\n    private static int getRepet(int digit, int n) {\n        int value = 0;\n        while (n-- > 0) {\n            value *= 10;\n            value += digit;\n        }\n\n        return value;\n    }\n\n    public static int findNext(int n, int k) {\n        if (ok(n, k)) {\n            return n;\n        }\n\n        int digits = numOfDigits(n);\n        int firstDig = getFirstDigit(n);\n        if (k == 1) {\n            int ret = getRepet(firstDig, digits);\n            if (ret < n) {\n                ret = getRepet(firstDig + 1, digits);\n            }\n            return ret;\n        }\n\n        int[] targetDigits = new int[digits];\n        int p = n;\n        for (int i = digits - 1; i >= 0; i--) {\n            targetDigits[i] = p % 10;\n            p /= 10;\n        }\n\n        int[] temp = new int[digits];\n        long min = getRepet(9, digits);\n        int bestFirstDigit = 9;\n        for (int i = 1; i < bitDigits.length; i++) {\n            int[] toUseDigits = bitDigits[i];\n            if (toUseDigits.length > k) {\n                break;\n            }\n            if (toUseDigits[0] > bestFirstDigit) {\n                continue;\n            }\n\n            long solution = getSolution(targetDigits, toUseDigits, temp);\n            if (solution < min) {\n                min = solution;\n                bestFirstDigit = getFirstDigit(min);\n            }\n        }\n        return (int) min;\n    }\n\n    private static long getSolution(int[] target, int[] digits, int[] tmp) {\n        solution = -1;\n        getNextWithGiven(target, tmp, digits, 0);\n        if (solution == -1) {\n            return Integer.MAX_VALUE;\n        }\n        return solution;\n    }\n\n    private static long parse(int[] num) {\n        long p = 0;\n        for (int j : num) {\n            p = p * 10 + j;\n        }\n        return p;\n    }\n\n    private static int solution = -1;\n\n    private static void getNextWithGiven(int[] target, int[] v, int[] digits, int pos) {\n        if (pos == target.length) {\n            solution = (int) parse(v);\n            return;\n        }\n\n        for (int digit : digits) {\n            if (digit == target[pos]) {\n                v[pos] = digit;\n                getNextWithGiven(target, v, digits, pos + 1);\n                if (solution != -1) {\n                    break;\n                }\n            } else if (digit > target[pos]){\n                v[pos++] = digit;\n                while (pos < target.length) {\n                    v[pos++] = digits[0];\n                }\n                solution = (int) parse(v);\n                break;\n            }\n\n        }\n    }\n\n    private static int getNextSmart(int n, int k, int mask) {\n        int digits = numOfDigits(n);\n        int firstDig = getFirstDigit(n);\n        int digitMask = 1 << firstDig;\n        int newMask = mask | digitMask;\n\n        if (Integer.bitCount(newMask) <= k) {\n            int elem = (int) (firstDig * Math.pow(10, digits - 1));\n            return elem + getNextSmart(n - elem, k, newMask);\n        } else {\n            return 0;\n        }\n    }\n\n    public static int findNextBrute(int n, int k) {\n        while (!ok(n, k)) {\n            n++;\n        }\n        return n;\n    }\n\n    public static boolean ok(int n, int k) {\n        int digitsMask = 0;\n        int digitsUsed = 0;\n\n        while (n > 0) {\n            int digit = n % 10;\n            int mask = 1 << digit;\n            if ((digitsMask & mask) == 0) {\n                digitsMask |= mask;\n                digitsUsed++;\n                if (digitsUsed > k) {\n                    return false;\n                }\n            }\n            n /= 10;\n        }\n        return true;\n    }\n\n    public static int[] readArrayLine(String line, int n) {\n        return readArrayLine(line, n, null, 0);\n    }\n\n    private static int[] readArrayLine(String line, int n, int array[], int pos) {\n        int[] ret = array == null ? new int[n] : array;\n        int start = 0;\n        int end = line.indexOf(' ', start);\n        for (int i = pos; i < pos + n; i++) {\n            if (end > 0)\n                ret[i] = Integer.parseInt(line.substring(start, end));\n            else\n                ret[i] = Integer.parseInt(line.substring(start));\n            start = end + 1;\n            end = line.indexOf(' ', start);\n        }\n        return ret;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mul[10];\nint bit(int mask, int i) { return (mask / mul[i]) % 10; }\nint t, t1;\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  if (n == 1e9) {\n    if (k == 1) {\n      cout << 1111111111;\n    } else {\n      cout << 1000000000;\n    }\n    cout << '\\n';\n    return;\n  }\n  bool c[10] = {0};\n  int cnt = 0;\n  int j = 8;\n  while (bit(n, j) == 0) {\n    j--;\n  }\n  int cur = 0;\n  int mincs = 10;\n  int res = 0;\n  for (int i = 0; i <= j; i++) {\n    res += mul[i] * (bit(n, j) + 1);\n  }\n  for (int i = j; i >= 0; i--) {\n    if (!c[bit(n, i)]) {\n      c[bit(n, i)] = 1;\n      cnt++;\n      mincs = min(mincs, bit(n, i));\n    }\n    cur *= 10;\n    cur += bit(n, i);\n    if (i > 0 && bit(n, i - 1) == 9) continue;\n    if (cnt <= k) {\n      if (i == 0) {\n        res = n;\n      } else {\n        if (cnt < k) {\n          if (cnt < k - 1) {\n            res = min(res, cur * mul[i] + (bit(n, i - 1) + 1) * mul[i - 1]);\n          } else {\n            int tmp = cur * mul[i] + (bit(n, i - 1) + 1) * mul[i - 1];\n            for (int z = 0; z < i - 1; z++) {\n              tmp += mul[z] * min(mincs, bit(n, i - 1) + 1);\n            }\n            res = min(res, tmp);\n          }\n        }\n        int z;\n        for (z = bit(n, i - 1) + 1; z < 10; z++) {\n          if (c[z]) {\n            break;\n          }\n        }\n        if (z < 10) {\n          if (cnt < k) {\n            res = min(res, cur * mul[i] + z * mul[i - 1]);\n          } else {\n            int tmp = cur * mul[i] + z * mul[i - 1];\n            for (int y = 0; y < i - 1; y++) {\n              tmp += mul[y] * mincs;\n            }\n            res = min(res, tmp);\n          }\n        }\n      }\n    }\n  }\n  cout << res << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  mul[0] = 1;\n  for (int i = 1; i < 10; i++) {\n    mul[i] = mul[i - 1] * 10;\n  }\n  cin >> t;\n  for (t1 = 1; t1 <= t; t1++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nconst int maxm = 26e3 + 7;\nconst long long mod = 998244353;\nint n, k;\nint flag[12];\nvector<int> v;\nstring s;\nint check(int pos) {\n  set<int> second;\n  for (int i = (0); i <= (pos); ++i) {\n    second.insert(s[i] - '0');\n  }\n  return (second.size() < k);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> s >> k;\n    memset(flag, 0, sizeof(flag));\n    v.clear();\n    int pos = -1;\n    for (int i = (0), __ = (s.size()); i < __; ++i) {\n      if (!flag[s[i] - '0']) {\n        if (v.size() == k) {\n          pos = i;\n          break;\n        } else\n          flag[s[i] - '0']++, v.push_back(s[i] - '0');\n      }\n    }\n    if (pos == -1) {\n      cout << s << '\\n';\n      continue;\n    }\n    sort(v.begin(), v.end());\n    int tb = 0;\n    for (int i = pos; i >= 0; i--) {\n      int p = upper_bound(v.begin(), v.end(), s[i] - '0') - v.begin();\n      if (check(i - 1) && s[i] != '9') {\n        int fd = 0;\n        for (int j = 0; j < v.size(); j++) {\n          if (s[i] - '0' == v[j])\n            v.erase(v.begin() + j), j--;\n          else if (s[i] - '0' + 1 == v[j])\n            fd = 1;\n        }\n        if (!fd) {\n          v.push_back(s[i] - '0' + 1);\n          sort(v.begin(), v.end());\n        }\n        s[i] = char(s[i] + 1);\n        pos = i;\n        break;\n      } else if (p != v.size()) {\n        s[i] = char(v[p] + '0');\n        pos = i;\n        break;\n      }\n      if (!i) tb = 1;\n    }\n    if (v.size() < k) v[0] = 0;\n    if (tb) {\n      if (k == 1) {\n        for (int i = (1); i <= (s.size() + 1); ++i) cout << 1;\n      } else {\n        cout << 1;\n        for (int i = (1); i <= (s.size()); ++i) cout << 0;\n      }\n    } else {\n      for (int i = (0); i <= (pos); ++i) cout << s[i];\n      for (int i = (pos + 1), __ = (s.size()); i < __; ++i) cout << v[0];\n    }\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 0x3f3f3f3f;\nlong long LINF = 0x3f3f3f3f3f3f3f3f;\nint dy[]{-1, 1, 0, 0};\nint dx[]{0, 0, -1, 1};\nint k;\nstring n;\nstring solve1() {\n  string ret = string(n.length(), '9');\n  for (char a = '8'; a >= '0'; a--) {\n    string t = string(n.length(), a);\n    if (t >= n) ret = t;\n  }\n  return ret;\n}\nstring solve2() {\n  string ret = solve1();\n  for (char a = '0'; a <= '8'; a++) {\n    for (char b = a + 1; b <= '9'; b++) {\n      bool flag = true;\n      for (int i = (0); i < (n.length()); ++i) {\n        if (n[i] < b) {\n          string t = n;\n          if (t[i] < a)\n            t[i] = a;\n          else\n            t[i] = b;\n          for (int j = (i + 1); j < (n.length()); ++j) t[j] = a;\n          if (t < ret) ret = t;\n        }\n        if (n[i] != a && n[i] != b) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        return n;\n      }\n    }\n  }\n  return ret;\n}\nstring solve3() {\n  while (1) {\n    set<char> s;\n    for (auto& e : n) {\n      s.insert(e);\n    }\n    if (s.size() <= k) return n;\n    s.clear();\n    for (int i = 0;; i++) {\n      s.insert(n[i]);\n      if (s.size() > k) {\n        int p = i;\n        while (n[p] == '9') --p;\n        n[p]++;\n        for (int j = (p + 1); j < (n.length()); ++j) n[j] = '0';\n        break;\n      }\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  if (k == 1)\n    cout << solve1() << '\\n';\n  else if (k == 2)\n    cout << solve2() << '\\n';\n  else\n    cout << solve3() << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  int TC;\n  cin >> TC;\n  while (TC--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "times = int(input())\nfor _ in range(times):\n    n, k = map(int, input().split())\n    num = n\n    while len(set(str(num))) > k:\n        if num % 10 == 0:\n            num = num // 10\n        else:\n            num += 1\n    last = str(min(str(num))) * (len(str(n)) - len((str(num))))\n    print(str(num) + last)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> used;\nint k;\nstring digs;\nint pre;\nint go(int rem, bool match) {\n  if (rem == 0) return pre;\n  int p = digs.length() - rem;\n  int tried = 0;\n  for (int i = 0; i < 10; i++) {\n    if (match and i < (int)digs[p] - '0') continue;\n    if (used.size() == k and used.count(i) == 0) continue;\n    if (tried >= 2) continue;\n    tried++;\n    pre = 10 * pre, pre += i;\n    bool curin = used.count(i);\n    if (!curin) used.insert(i);\n    int res = go(rem - 1, (match and i == digs[p] - '0'));\n    if (!curin) used.erase(i);\n    pre /= 10;\n    if (res != -1) {\n      return res;\n    }\n  }\n  return -1;\n}\nvoid solve() {\n  int n;\n  cin >> n >> k;\n  used.clear();\n  pre = 0;\n  digs = to_string(n);\n  int res = go(digs.length(), true);\n  cout << res << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t) {\n    solve();\n    t--;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n    static int t;\n    static long n,k;\n    static String N;\n    static TreeSet<Integer> d;\n    public static void main(String[] args) throws IOException {\n        String[]data;\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        t = Integer.valueOf(f.readLine());\n        while((t--)!=0){\n            data = f.readLine().split(\" \");\n            n = Long.valueOf(data[0]);\n            k = Long.valueOf(data[1]);\n            N = n+\"\";\n            int dec = N.length();\n            d = new TreeSet<>();\n            int[]res = new int[dec];\n            int[]obj = new int[dec];\n            for(int i = 0 ; i < dec ; ++i){\n                obj[i] = Integer.parseInt(N.charAt(i) + \"\");\n            }\n            solve(0, res, obj);\n            System.out.println(gn(res));\n        }\n        \n    }\n    public static boolean solve(int in, int[] res, int[] obj){\n        //System.out.println(Arrays.toString(res));\n        if(res.length == in){\n            int R = res[0], O = obj[0];\n            for(int i = 1 ; i < res.length ; i++){\n                R = R*10 + res[i];\n                O = O*10 + obj[i];\n            }\n            \n            return R >= O;\n        }else{\n            for(int i = 0 ; i < 10 ; ++i){\n                if(i < obj[in] && gn(res) < gn(obj) ){\n                    continue;\n                }else{\n                    if(d.contains(i)){\n                        res[in] = i;\n                        if(solve(in+1, res, obj))\n                            return true;\n                        res[in] = 0;\n                    }else{\n                        if(d.size() != k){\n                            d.add(i);\n                            res[in] = i;\n                            if(solve(in+1, res, obj))\n                                return true;\n                            res[in] = 0;\n                            d.remove(i);\n                        }\n                        \n                    }\n                }\n            }\n\n            return false;\n        }\n    }\n    public static int gn(int[] num){\n        int R = num[0];\n            for(int i = 1 ; i < num.length ; i++){\n                R = R*10 + num[i];\n                \n            }\n        return R;\n    }\n    \n\n}"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom bisect import *\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass dict(dict):\n    def __missing__(self, key):\n        return 0\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: dtype(input().strip())\ninp_d = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp_d(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp_d(dtype))]\ninp_enus = lambda dtype, n: [[i] + [inp_d(dtype)] for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\nget_bit = lambda x, i: (x >> i) & 1\n\nfor _ in range(inp(int)):\n    n, k = inp_d(int)\n    n1 = str(n)\n    ans, ln = float('inf'), len(n1)\n\n    digs = []\n    for i in n1:\n        if len(digs) == k - 1:\n            break\n        if i not in digs:\n            digs.append(i)\n\n    for i in range(10):\n        cur, lst, flag = [], [-1, 0], 0\n\n        if str(i) not in digs:\n            digs.append(str(i))\n            flag = 1\n\n        digs.sort()\n\n        for j in n1:\n            ix = bisect_left(digs, j)\n\n            if ix < len(digs):\n                cur.append(digs[ix])\n\n                if j < digs[ix]:\n                    cur.extend([digs[0]] * (ln - len(cur)))\n\n                if ix != len(digs) - 1:\n                    lst = [len(cur) - 1, ix + 1]\n\n            else:\n                if lst[0] == -1:\n                    cur = ['9'] * 10\n                    break\n\n                cur[lst[0]] = digs[lst[1]]\n                cur = cur[:lst[0] + 1] + [digs[0]] * (ln - lst[0] - 1)\n                break\n\n            if len(cur) == len(n1):\n                break\n\n        if flag:\n            digs.remove(str(i))\n        ans = min(ans, int(''.join(cur)))\n\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "#for p in [(x, 5) for x in range(344660200, 344660300)]:\nfor _ in range(int(input())):\n    #n, k = p[0], p[1]\n    #n = str(n)\n    n, k = input().split()\n    k = int(k)\n    a = []\n    ans = 0\n    it = False\n    for i in range(len(n)):\n        if it:\n            if k:\n                ans = ans * 10\n            else:\n                ans = ans * 10 + min(a)\n            continue\n        #if n[i] == max(n[i:]) or k > 1 or k > 0 and n[i] in a or a and max(a) >= int(max(n[i:])):\n        j = i\n        while j < len(n):\n            if n[j] > n[i]:\n                j += 1\n                break\n            j += 1\n        j -= 1\n        kk = j\n        while kk < len(n):\n            if n[kk] < n[j]:\n                kk += 1\n                break\n            kk += 1\n        kk -= 1\n        if n[i] == max(n[i:]) or k > 1 or (k > 0 and (int(n[i]) in a)) or a and max(a) >= int(max(n[j:kk + 1])) or i == len(n) - 1 or a and min([int(n[x]) for x in range(i + 1, j + 1)]) < max(a) or min([int(n[x]) for x in range(i + 1, j + 1)]) < int(n[i]):\n            d = int(n[i])\n        else:\n            d = int(n[i]) + 1\n        if d not in a and k:\n            k -= 1\n            a.append(d)\n            a.sort()\n            ans = ans * 10 + d\n        else:\n            for x in a:\n                if x >= d:\n                    ans = ans * 10 + x\n                    break\n        if ans % 10 > int(n[i]):\n            it = True\n    print(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1560_F2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader in = new Reader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = in.nextInt();\n\t\twhile(t-- > 0) {\t\n            int n = in.nextInt();\n            String strn = Integer.toString(n);\n            int k = in.nextInt();\n            TreeSet<Long> candidates = new TreeSet<Long>();\n            for(int i = 0; i < strn.length(); i++) {\n                TreeSet<Integer> digits = new TreeSet<Integer>();\n                for(int j = 0; j < i; j++) {\n                    digits.add(Character.getNumericValue(strn.charAt(j)));\n                }\n                int digit = Character.getNumericValue(strn.charAt(i));\n                if(digit == 9) {\n                    continue;\n                }\n                int size = digits.size();\n                if(size > k) {\n                    break;\n                }\n                if(!digits.contains(digit + 1)) {\n                    size++;\n                }\n                if(size > k) {\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    Integer higher = digits.higher(digit);\n                    if(higher != null) {\n\t\t\t\t\t\tcur.append(higher);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = i + 1; j < strn.length(); j++) {\n                        cur.append(digits.first());\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }else if(size == k) {\n                    digits.add(digit + 1);\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    cur.append(digit + 1);\n                    for(int j = i + 1; j < strn.length(); j++) {\n                        cur.append(digits.first());\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }else {\n                    StringBuilder cur = new StringBuilder(strn.substring(0, i));\n                    cur.append(digit + 1);\n                    for(int j = i + 1; j < strn.length(); j++) {\n                        cur.append(0);\n                    }\n                    candidates.add(Long.parseLong(cur.toString()));\n                }\n            }\n            TreeSet<Integer> digits = new TreeSet<Integer>();\n            for(int j = 0; j < strn.length(); j++) {\n                digits.add(Character.getNumericValue(strn.charAt(j)));\n            }\n            if(digits.size() <= k) {\n                candidates.add((long)n);\n            }\n            out.println(candidates.first());\n\t\t}\n\t\tin.close();\n\t\tout.close();\n\t}\n\tstatic class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile((c = read()) != -1) {\n\t\t\t\tif(c == '\\n') {\n\t\t\t\t\tif(cnt != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile(c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}while((c = read()) >= '0' && c <= '9');\n\t\t\tif(c == '.') {\n\t\t\t\twhile((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif(bytesRead == -1) {\n\t\t\t\tbuffer[0] = -1;\n\t\t\t}\n\t\t}\n\t\tprivate byte read() throws IOException {\n\t\t\tif(bufferPointer == bytesRead) {\n\t\t\t\tfillBuffer();\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\t\tpublic void close() throws IOException {\n\t\t\tif(din == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdin.close();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class NearestBeautifulNumberHardVersion {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = readInt();\n\t\t\n\t\twhile (t-- > 0) {\n\t\t\tint n = readInt(), k = readInt();\n\t\t\tchar[] a = String.valueOf(n).toCharArray();\n\t\t\tSystem.out.println(solve(a, k));\n\t\t}\n\t}\n\t\n\tstatic String solve(char[] a, int k) {\n\t\tHashSet<Character> s = new HashSet<Character>();\n\t\tfor (char c: a) s.add(c);\n\t\tif (s.size() <= k) {\n\t\t\tString str = \"\";\n\t\t\tfor (char c: a) str += c;\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\ts.clear();\n\t\tint ptr = 0;\n\t\tfor (; ; ptr ++) {\n\t\t\ts.add(a[ptr]);\n\t\t\tif (s.size() > k) {\n\t\t\t\tif (a[ptr] == '9') ptr --;\n\t\t\t\ta[ptr] ++;\n\t\t\t\tfor (int i = ptr + 1; i < a.length; i ++) a[i] = '0';\n\t\t\t\treturn solve(a, k);\n\t\t\t}\n\t\t}\n\t}\n \n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\treturn st.nextToken();\n\t}\n\tstatic long readLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic double readDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tstatic char readCharacter() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tstatic String readLine() throws IOException {\n\t\treturn br.readLine().trim();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class lasttask {\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint tt = in.nextInt();\n\t\tfor (int tc = 0; tc < tt; tc++) {\n\t\t\tString s = in.next();\n\t\t\tint k = in.nextInt();\n\t\t\tint d[] = new int[10];\n\t\t\tint map_sz = 0;\n\t\t\tint p = 0;\n\t\t\tStringBuilder ans = new StringBuilder(s);\n\t\t\twhile (p < ans.length()) {\n\t\t\t\td[ans.charAt(p) - '0']++;\n\t\t\t\tif (d[ans.charAt(p) - '0'] == 1) map_sz++;\n\t\t\t\tif (map_sz > k) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (p == ans.length()) {\n\t\t\t\tout.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ans.charAt(p) - '0']--;\n\t\t\tif (d[ans.charAt(p) - '0'] == 0) {\n\t\t\t\tmap_sz--;\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (ans.charAt(p) == '9') {\n\t\t\t\t\tp--;\n\t\t\t\t\td[ans.charAt(p) - '0']--;\n\t\t\t\t\tif (d[ans.charAt(p) - '0'] == 0) {\n\t\t\t\t\t\tmap_sz--;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map_sz < k) {\n\t\t\t\t\tans.setCharAt(p, (char) (ans.charAt(p) + 1));\n\t\t\t\t\td[ans.charAt(p) - '0']++;\n\t\t\t\t\tif (d[ans.charAt(p) - '0'] == 1) map_sz++;\n\t\t\t\t\tif (map_sz < k) {\n\t\t\t\t\t\tfilling(ans, '0', p + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar c = '0';\n\t\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\t\tif (d[i] > 0) {\n\t\t\t\t\t\t\t\tc = (char) (i + '0');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfilling(ans, c, p + 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint it = -1;\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (d[i] > 0 && i > ans.charAt(p) - '0') {\n\t\t\t\t\t\tit = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (it == -1) {\n\t\t\t\t\tp--;\n\t\t\t\t\td[ans.charAt(p) - '0']--;\n\t\t\t\t\tif (d[ans.charAt(p) - '0'] == 0) {\n\t\t\t\t\t\tmap_sz--;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tans.setCharAt(p, (char) (it + '0'));\n\t\t\t\t\tchar c = '0';\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tif (d[i] > 0) {\n\t\t\t\t\t\t\tc = (char) (i + '0');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilling(ans, c, p + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic void filling(StringBuilder s, char c, int f) {\n\t\tfor (int i = f; i < s.length(); i++) {\n\t\t\ts.setCharAt(i, c);\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile(!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class NearestBeautifulNumberHardVersion {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = readInt();\n\t\t\n\t\touter: while (t-- > 0) {\n\t\t\tint n = readInt(), k = readInt();\n\t\t\tString s = String.valueOf(n);\n\t\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\t\t\n\t\t\tfor (int i = 0; i < s.length(); i ++) {\n\t\t\t\tint x = Character.getNumericValue(s.charAt(i));\n\t\t\t\tif (!map.containsKey(x) && map.size() == k) {\n\t\t\t\t\tif (map.ceilingKey(x) == null) {\n\t\t\t\t\t\tint val1 = Integer.MAX_VALUE, val2 = 0;\n\t\t\t\t\t\tString str1 = \"\", str2 = \"\";\n\t\t\t\t\t\tif (map.size() > 1) {\n\t\t\t\t\t\t\tint idx = 0;\n\t\t\t\t\t\t\tfor (int j = i - 1; j >= 0; j --) if (Character.getNumericValue(s.charAt(j)) < map.lastKey()) { idx = j; break; }\n\t\t\t\t\t\t\tfor (int j = 0; j < idx; j ++) str1 += s.charAt(j);\n\t\t\t\t\t\t\tstr1 += map.higherKey(Character.getNumericValue(s.charAt(idx)));\n\t\t\t\t\t\t\tfor (int j = idx + 1; j < s.length(); j ++) str1 += map.firstKey();\n\t\t\t\t\t\t\tval1 = Integer.parseInt(str1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tint mx = -1, v = 0;\n\t\t\t\t\t\tfor (int val: map.keySet()) {\n\t\t\t\t\t\t\tif (map.get(val) > mx) {\n\t\t\t\t\t\t\t\tmx = map.get(val);\n\t\t\t\t\t\t\t\tv = val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint idx = i, min = map.firstKey();\n\t\t\t\t\t\tfor (int j = 0; j < i; j ++) {\n\t\t\t\t\t\t\tif (Character.getNumericValue(s.charAt(j)) == v) { str2 += (v + 1); idx = j + 1; break; }\n\t\t\t\t\t\t\telse str2 += s.charAt(j);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tif (min == v) min ++;\n\t\t\t\t\t\tif (map.containsKey(v + 1)) min = 0;\n\t\t\t\t\t\tfor (int j = idx; j < s.length(); j ++) str2 += min;\n\t\t\t\t\t\tval2 = Integer.parseInt(str2);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.print(Math.min(val1, val2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint c = map.ceilingKey(x), min = map.firstKey();\n\t\t\t\t\t\tfor (int j = 0; j < i; j ++) System.out.print(s.charAt(j));\n\t\t\t\t\t\tSystem.out.print(c);\n\t\t\t\t\t\tfor (int j = i + 1; j < s.length(); j ++) System.out.print(min);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tcontinue outer;\n\t\t\t\t} else if (!map.containsKey(x)) map.put(x, i);\n\t\t\t}\n\t\t\tSystem.out.println(n);\n\t\t}\n\t}\n \n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\treturn st.nextToken();\n\t}\n\tstatic long readLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic double readDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tstatic char readCharacter() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tstatic String readLine() throws IOException {\n\t\treturn br.readLine().trim();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring ans, a;\nint n, k;\nbool go(int i, int n, int k, set<int> &s, int gr) {\n  if (i == n) return true;\n  int val = a[i] - '0';\n  if (gr == 1) {\n    int x = 0;\n    if (s.size() == k) {\n      x = (*s.begin());\n    }\n    ans.push_back((char)(x + '0'));\n    int flag = 0;\n    if (s.empty() == true || s.find(x) == s.end()) {\n      s.insert(x);\n    } else {\n      flag = 1;\n    }\n    if (go(i + 1, n, k, s, gr) == true)\n      return true;\n    else {\n      if (flag == 0) {\n        s.erase(x);\n      }\n      ans.pop_back();\n      return false;\n    }\n  }\n  if (s.size() == k) {\n    if (s.lower_bound(val) == s.end()) {\n      return false;\n    }\n    int ins = (*s.lower_bound(val)) + '0';\n    int nextgr = 0;\n    nextgr = ((ins - '0') == val) ? 0 : 1;\n    ans.push_back(ins);\n    if (go(i + 1, n, k, s, nextgr) == true)\n      return true;\n    else {\n      ans.pop_back();\n      if (s.upper_bound(val) == s.end())\n        return false;\n      else {\n        ans.push_back((*s.upper_bound(val)) + '0');\n        if (go(i + 1, n, k, s, 1) == true)\n          return true;\n        else {\n          ans.pop_back();\n          return false;\n        }\n      }\n    }\n  }\n  int flag = 0;\n  ans.push_back(a[i]);\n  if (s.empty() == true || s.find(val) == s.end())\n    s.insert(val);\n  else\n    flag = 1;\n  if (go(i + 1, n, k, s, gr) == true)\n    return true;\n  else {\n    ans.pop_back();\n    if (flag == 0) s.erase(val);\n    int flag2 = 0;\n    if (s.empty() == true || s.find((val + 1) % 10) == s.end())\n      s.insert((val + 1) % 10);\n    else\n      flag2 = 1;\n    ans.push_back((char)((val + 1) % 10 + '0'));\n    if (go(i + 1, n, k, s, 1) == true)\n      return true;\n    else {\n      ans.pop_back();\n      if (flag2 == 0) s.erase((val + 1) % 10);\n      return false;\n    }\n  }\n}\nvoid solve() {\n  ans = \"\", a = \"\";\n  cin >> n >> k;\n  a = to_string(n);\n  set<int> s;\n  go(0, a.size(), k, s, 0);\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout << fixed << setprecision(10);\n  int t = 1;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid __print(int x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << x; }\nvoid __print(const char *x) { cerr << x; }\nvoid __print(const string &x) { cerr << x; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) {\n    cerr << (f++ ? \", \" : \"\");\n    __print(i);\n  }\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) {\n    cerr << \", \";\n  }\n  _print(v...);\n}\nstring go(long long i, long long n, long long dist, string nw, long long k,\n          string ori) {\n  ;\n  if (dist > k) {\n    return \"\";\n  }\n  if (nw.substr(0, i) < ori.substr(0, i)) {\n    return \"\";\n  }\n  if (i >= n) {\n    return nw;\n  }\n  for (char val = '0'; val <= '9'; ++val) {\n    nw[i] = val;\n    bool found = false;\n    for (long long j = 0; j < i; ++j) {\n      if (nw[j] == val) {\n        found = true;\n        break;\n      }\n    }\n    string chk = go(i + 1, n, dist + (found == false), nw, k, ori);\n    if ((long long)chk.size()) {\n      return chk;\n    }\n  }\n  return \"\";\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  string s = to_string(n);\n  long long dist = 0;\n  map<char, long long> g;\n  for (auto ch : s) {\n    g[ch]++;\n  }\n  string ans =\n      go(0, (long long)s.size(), 0, string((long long)s.size(), '0'), k, s);\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.beans.VetoableChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\nimport javafx.util.Pair;\n\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.copyOfRange;\nimport static java.util.Arrays.fill;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass Task {\n\n    long ans = Long.MAX_VALUE;\n    long inf = Long.MAX_VALUE;\n    int[] cnt = new int[1 << 10];\n    int[] min = new int[1 << 10];\n    long[] pre;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int T = in.nextInt();\n        init();\n        for (int tc = 1; tc <= T; tc++) {\n            ans = Long.MAX_VALUE;\n            String s = in.next();\n            int k = in.nextInt();\n            pre = new long[s.length() + 1];\n            pre[0] = 0;\n            for (int i = 0; i < s.length(); i++) {\n                pre[i + 1] = pre[i] * 10 + s.charAt(i) - '0';\n            }\n            cal(s, k, 0, 0, 0);\n            out.println(ans);\n        }\n    }\n\n    private void init() {\n        cnt[0] = 0;\n        for (int i = 1; i < (1 << 10); i++) {\n            cnt[i] = cnt[i - (i & -i)] + 1;\n            for (int j = 0; j <= 9; j++) {\n                if (((i >> j) & 1) != 0) {\n                    min[i] = j;\n                    break;\n                }\n            }\n        }\n    }\n\n    private void cal(String s, int K, int st, long n, int c) {\n        if (cnt[st] > K) {\n            return;\n        }\n        if (c == s.length()) {\n            ans = Math.min(ans, n);\n            return;\n        }\n        if (n > pre[c]) {\n            long nn = n;\n            if (cnt[st] == K) {\n                int mn = min[st];\n                for (int i = c; i < s.length(); i++) {\n                    nn = nn * 10 + mn;\n                }\n            } else {\n                for (int i = c; i < s.length(); i++) {\n                    nn = nn * 10;\n                }\n            }\n            ans = Math.min(ans, nn);\n            return;\n        }\n        int nn = s.charAt(c) - '0';\n        for (int i = nn; i <= 9; i++) {\n            cal(s, K, st | (1 << i), n * 10 + i, c + 1);\n        }\n    }\n}\n\nclass InputReader {\n\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[20];\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    vector<int> v;\n    int y = n;\n    while (y) {\n      v.push_back(y % 10);\n      y /= 10;\n    }\n    reverse(v.begin(), v.end());\n    int sz = v.size();\n    if (k == 1) {\n      bool les = 0, bg = 0;\n      for (int i = 1; i < sz; i++) {\n        if (v[i] < v[0])\n          les = 1;\n        else if (v[i] > v[0]) {\n          bg = 1;\n          break;\n        }\n      }\n      if (!les && bg)\n        for (int i = 0; i < sz; i++) a[i] = v[0] + 1;\n      else\n        for (int i = 0; i < sz; i++) a[i] = v[0];\n      for (int i = 0; i < sz; i++) cout << a[i];\n      cout << '\\n';\n      continue;\n    }\n    int cnt[11] = {0};\n    int cc = 0;\n    for (auto i : v)\n      if (!cnt[i]) cc++, cnt[i]++;\n    if (cc <= k) {\n      cout << n << '\\n';\n      continue;\n    }\n    for (int i = 0; i < 10; i++) cnt[i] = 0;\n    cc = 0;\n    int mn = 10, mx = -1;\n    for (int i = 0; i < sz; i++) {\n      int x = v[i];\n      if (!cnt[x]) {\n        cc++;\n      }\n      if (cc > k) {\n        if (x > mx) {\n          int sum = 0;\n          for (int j = i - 1; j >= 0; j--) {\n            if (v[j] != mx) break;\n            sum++;\n          }\n          if (sum == cnt[mx]) {\n            for (int j = i - 1; j >= 0; j--) {\n              if (v[j] == mx)\n                a[j] = mn;\n              else {\n                a[j + 1] = mx + 1;\n                break;\n              }\n            }\n            for (int j = i; j < sz; j++) a[j] = mn;\n          } else {\n            for (int j = i - 1; j >= 0; j--) {\n              if (v[j] != mx) {\n                int y, nx;\n                if (cnt[v[j]] == 1) {\n                  y = v[j] + 1, nx;\n                  if (cnt[y]) {\n                    nx = 0;\n                  } else {\n                    if (v[j] == mn)\n                      nx = y;\n                    else\n                      nx = mn;\n                  }\n                } else {\n                  for (y = v[j] + 1; y < 10; y++) {\n                    if (cnt[y]) break;\n                  }\n                  nx = mn;\n                }\n                a[j] = y;\n                for (int q = j + 1; q < sz; q++) {\n                  a[q] = nx;\n                }\n                break;\n              }\n            }\n          }\n        } else {\n          for (int j = x + 1; j < 10; j++) {\n            if (cnt[j]) {\n              a[i] = j;\n              break;\n            }\n          }\n          for (int j = i + 1; j < sz; j++) a[j] = mn;\n        }\n        break;\n      }\n      a[i] = x;\n      cnt[x]++;\n      mn = min(mn, x), mx = max(mx, x);\n    }\n    for (int i = 0; i < sz; i++) cout << a[i];\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.HashSet;\n\npublic class f2 {\n    static class InputReader {\n        private static final int DEFAULT_BUFFER_SIZE = 1 << 16; // Change this to increase your input size //\n        private static final InputStream DEFAULT_STREAM = System.in;\n        private static final int MAX_DECIMAL_PRECISION = 21;\n        private int c;\n        private byte[] buf;\n        private int bufferSize, bufIndex, numBytesRead;\n        private InputStream stream;\n        private static final byte EOF = -1;\n        private static final byte NEW_LINE = 10;\n        private static final byte CARRIAGE_RETURN = 13;\n        private static final byte SPACE = 32;\n        private static final byte DASH = 45;\n        private static final byte DOT = 46;\n        private char[] charBuffer;\n        private static byte[] bytes = new byte[58];\n        private static int[] ints = new int[58];\n        private static char[] chars = new char[128];\n\n        static {\n            char ch = ' ';\n            int value = 0;\n            byte _byte = 0;\n            for (int i = 48; i < 58; i++) bytes[i] = _byte++;\n            for (int i = 48; i < 58; i++) ints[i] = value++;\n            for (int i = 32; i < 128; i++) chars[i] = ch++;\n        }\n\n        public InputReader() {\n            this(DEFAULT_STREAM, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(int bufferSize) {\n            this(DEFAULT_STREAM, bufferSize);\n        }\n\n        public InputReader(InputStream stream) {\n            this(stream, DEFAULT_BUFFER_SIZE);\n        }\n\n        public InputReader(InputStream stream, int bufferSize) {\n            if (stream == null || bufferSize <= 0) throw new IllegalArgumentException();\n            buf = new byte[bufferSize];\n            charBuffer = new char[128];\n            this.bufferSize = bufferSize;\n            this.stream = stream;\n        }\n\n        private byte read() throws IOException {\n            if (numBytesRead == EOF) throw new IOException();\n            if (bufIndex >= numBytesRead) {\n                bufIndex = 0;\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return EOF;\n            }\n            return buf[bufIndex++];\n        }\n\n        private int readJunk(int token) throws IOException {\n            if (numBytesRead == EOF) return EOF;\n            do {\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > token) return 0;\n                    bufIndex++;\n                }\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return EOF;\n                bufIndex = 0;\n            } while (true);\n        }\n\n        public byte nextByte() throws IOException {\n            return (byte) ni();\n        }\n\n        public int ni() throws IOException {\n            if (readJunk(DASH - 1) == EOF) throw new IOException();\n            int sgn = 1, res = 0;\n            c = buf[bufIndex];\n            if (c == DASH) {\n                sgn = -1;\n                bufIndex++;\n            }\n            do {\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > SPACE) {\n                        res = (res << 3) + (res << 1);\n                        res += ints[buf[bufIndex++]];\n                    } else {\n                        bufIndex++;\n                        return res * sgn;\n                    }\n                }\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return res * sgn;\n                bufIndex = 0;\n            } while (true);\n        }\n\n        public long nl() throws IOException {\n            if (readJunk(DASH - 1) == EOF) throw new IOException();\n            int sgn = 1;\n            long res = 0L;\n            c = buf[bufIndex];\n            if (c == DASH) {\n                sgn = -1;\n                bufIndex++;\n            }\n            do {\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > SPACE) {\n                        res = (res << 3) + (res << 1);\n                        res += ints[buf[bufIndex++]];\n                    } else {\n                        bufIndex++;\n                        return res * sgn;\n                    }\n                }\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return res * sgn;\n                bufIndex = 0;\n            } while (true);\n        }\n\n        private void doubleCharBufferSize() {\n            char[] newBuffer = new char[charBuffer.length << 1];\n            for (int i = 0; i < charBuffer.length; i++) newBuffer[i] = charBuffer[i];\n            charBuffer = newBuffer;\n        }\n\n        public String nli() throws IOException {\n            try {\n                c = read();\n            } catch (IOException e) {\n                return null;\n            }\n            if (c == NEW_LINE) return \"\";\n            if (c == EOF) return null;\n            int i = 0;\n            charBuffer[i++] = (char) c;\n            do {\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] != NEW_LINE && buf[bufIndex] != CARRIAGE_RETURN) {\n                        if (i == charBuffer.length) doubleCharBufferSize();\n                        charBuffer[i++] = (char) buf[bufIndex++];\n                    } else {\n                        if (buf[bufIndex] == CARRIAGE_RETURN) bufIndex++;\n                        bufIndex++;\n                        return new String(charBuffer, 0, i);\n                    }\n                }\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return new String(charBuffer, 0, i);\n                bufIndex = 0;\n            } while (true);\n        }\n\n        public String ns() throws IOException {\n            if (numBytesRead == EOF) return null;\n            if (readJunk(SPACE) == EOF) return null;\n            for (int i = 0; ; ) {\n                while (bufIndex < numBytesRead) {\n                    if (buf[bufIndex] > SPACE) {\n                        if (i == charBuffer.length) doubleCharBufferSize();\n                        charBuffer[i++] = (char) buf[bufIndex++];\n                    } else {\n                        bufIndex++;\n                        return new String(charBuffer, 0, i);\n                    }\n                }\n                numBytesRead = stream.read(buf);\n                if (numBytesRead == EOF) return new String(charBuffer, 0, i);\n                bufIndex = 0;\n            }\n        }\n\n        public double nd() throws IOException {\n            String doubleVal = ns();\n            if (doubleVal == null) throw new IOException();\n            return Double.valueOf(doubleVal);\n        }\n\n        public void close() throws IOException {\n            stream.close();\n        }\n    }\n\n    // region variables\n    static InputReader sc = new InputReader();\n    static OutputStream outputStream = System.out;\n    static PrintWriter w = new PrintWriter(outputStream);\n    // endregion\n\n    private static void initiateIO()\n            throws IOException {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            try {\n                w = new PrintWriter(\"output.txt\");\n                sc = new InputReader(new FileInputStream(\"input.txt\"));\n            } catch (Exception e) {\n                throw new IOException();\n            }\n        }\n    }\n\n    public static void main(String[] args)\n            throws IOException {\n\n        initiateIO();\n\n        int t = sc.ni();\n        while (t-- > 0)\n            solve();\n\n        w.close();\n\n    }\n\n    static boolean check(int[] arr, int k) {\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i = 0; i < arr.length; i++) {\n            hs.add(arr[i]);\n        }\n        return hs.size()<=k;\n    }\n\n    static void solve() throws IOException {\n        char[] str = sc.ns().toCharArray();\n        int k = sc.ni();\n        int[] arr = new int[str.length];\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i = 0; i < str.length; i++) {\n            hs.add(Integer.parseInt(str[i] + \"\"));\n            arr[i] = Integer.parseInt(str[i]+\"\");\n        }\n        if (hs.size() <= k) {\n            for (int i = 0; i < str.length; i++) {\n                w.print(str[i]);\n            }\n            w.println();\n            return;\n        }\n        while (!check(arr, k)) {\n            HashSet<Integer> currh = new HashSet<>();\n            for (int i = 0; i < arr.length; i++) {\n                currh.add(arr[i]);\n                if(currh.size() > k) {\n                    if(i < arr.length-1 && arr[i+1] == arr[i]) continue;\n                    while(i >= 0) {\n                        if(arr[i] != 9) {\n                            arr[i]++;\n                            break;\n                        }else i--;\n                    }\n                    for (int j = i+1; j < arr.length; j++) {\n                        arr[j] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr.length; i++) {\n            w.print(arr[i]);\n        }\n        w.println();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "t = int(input())\n\nwhile t:\n    num, k = [int(tok) for tok in input().split()]\n    ans = 111111111111111\n    num = str(num)\n    n = len(num)\n    s=set()\n    for ch in num:\n        s.add(ch)\n    \n    if (len(s) <= k):\n        print(int(num))\n    else:\n\n        for ind in range(0, n):\n            if(num[ind] == '9'):\n                continue\n            \n            done = set()\n            for i in range(0, ind):\n                done.add(num[i])\n                \n            if (len(done) > k):\n                continue\n            \n            elif (len(done) == k):\n                to_fill = None\n                mi = '9'\n                for el in done:\n                    mi = min(mi, el)\n                    if(el > num[ind]):\n                        if to_fill is None:\n                            to_fill = el\n                        else:\n                            to_fill = min(to_fill, el)\n                            \n                if(to_fill is not None):\n                    ans = min(ans, int(num[:ind] + to_fill + mi*(n-ind-1)))\n                        \n            else:\n                mi = '9'\n                for i in range(0, 9):\n                    if(str(i) > num[ind]):\n                        mi = str(i)\n                        break\n                    \n                done.add(mi)\n                if(len(done) == k):\n            \n                    ans = min(ans, int(num[:ind] + mi + min(done)*(n-ind-1)))\n                else:\n                    ans = min(ans, int(num[:ind] + mi + '0'*(n-ind-1)))\n                    \n            # print(ind, ans)    \n                \n        print(ans)\n    \n    \n    t-=1"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF2 solver = new TaskF2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF2 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            var tc = in.nextInt();\n            for (int i = 0; i < tc; i++) {\n                solution(i, in, out);\n            }\n        }\n\n        void solution(int testNumber, InputReader in, OutputWriter out) {\n            int kk = in.nextInt();\n            char[] k = String.valueOf(kk).toCharArray();\n            int limit = in.nextInt();\n            var currentDigits = new EzCharHashSet(k).size();\n            if (limit >= currentDigits) {\n                out.println(k);\n                return;\n            }\n            char[] stt = bruteForce(k, limit);\n            out.println(stt);\n\n        }\n\n        int getBit(int n, int k) {\n            return (n >> k) & 1;\n        }\n\n        private char[] bruteForce(char[] k, int limit) {\n            char[] minc = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n\n            for (int zz = 0; Integer.bitCount(zz) <= 10; zz++) {\n                if (Integer.bitCount(zz) == limit) {\n                    char[] res = makeSmallest(k, zz);\n                    if (compareArrays(res, minc) < 0) {\n                        minc = res;\n                    }\n                }\n            }\n            return minc;\n        }\n\n        private int nextCharSet(int bitmask, int idx) {\n            for (; idx < 10; idx++) {\n                if (getBit(bitmask, idx) > 0) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n\n        private char[] makeSmallest(char[] ooo, int t) {\n            // makes the smallest one using this set of characters\n            // lets try the simplest way, make everything set to k or higher,\n            char[] z = ArrayUtils.clone(ooo);\n            for (int i = 0; i < z.length; i++) {\n                char best = (char) (nextCharSet(t, z[i] - '0') + '0');\n                if (best == -1 + '0') {\n                    // can't replace this one\n                    // see if we can bump previous\n\n                    // we're at an index of i that cannot be bumped up\n                    char nnh = best;\n                    for (; i >= 0 && nnh == -1 + '0'; i--) {\n                        nnh = (char) (nextCharSet(t, z[i] - '0' + 1) + '0');\n                    }\n\n                    // can't bump up any of the previous ones, whoops\n                    if (nnh == -1 + '0') {\n                        // return an array 1 longer, but filled with the lowest char\n                        var retArr = new char[z.length + 1];\n                        // problem, char can be 0\n                        Arrays.fill(retArr, (char) (nextCharSet(t, 0) + '0'));\n                        char firstChar = (char) (nextCharSet(t, 0) + '0');\n                        if (firstChar != -1) {\n                            retArr[0] = firstChar;\n                        } else {\n                            Arrays.fill(retArr, 'z');\n                        }\n                        return retArr;\n                        // just return\n                    }\n\n                    // can bump up a previous one.\n                    // lets do it and fill it up\n                    i++;\n                    z[i] = nnh;\n                    char ff = (char) (nextCharSet(t, 0) + '0');\n                    for (int zv = i + 1; zv < z.length; zv++) {\n                        z[zv] = ff;\n                    }\n                    return z;\n                }\n\n                //what if we can leave it as is? continue\n                if (best == z[i]) {\n                    continue;\n                }\n\n                if (best > z[i]) {\n                    // bumpable\n                    z[i] = best;\n                    char zz = (char) (nextCharSet(t, 0) + '0');\n                    for (int zv = i + 1; zv < z.length; zv++) {\n                        z[zv] = zz;\n                    }\n                    return z;\n                }\n            }\n            return z;\n\n\n        }\n\n        private int compareArrays(char[] a, char[] b) {\n            if (a.length != b.length) {\n                return Integer.compare(a.length, b.length);\n            }\n            return Arrays.compare(a, b);\n        }\n\n    }\n\n    static class EzCharHashSet implements EzCharSet {\n        private static final int DEFAULT_CAPACITY = 8;\n        private static final int HASHCODE_INITIAL_VALUE = 0x811c9dc5;\n        private static final int HASHCODE_MULTIPLIER = 0x01000193;\n        private static final byte FREE = 0;\n        private static final byte FILLED = 2;\n        private static final Random rnd = new Random();\n        private static final int POS_RANDOM_SHIFT_1;\n        private static final int POS_RANDOM_SHIFT_2;\n        private static final int STEP_RANDOM_SHIFT_1;\n        private static final int STEP_RANDOM_SHIFT_2;\n        private char[] table;\n        private byte[] status;\n        private int size;\n        private int removedCount;\n        private int mask;\n        private final int hashSeed;\n\n        static {\n            POS_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;\n            POS_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;\n            STEP_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;\n            STEP_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;\n        }\n\n        public EzCharHashSet() {\n            this(DEFAULT_CAPACITY);\n        }\n\n        public EzCharHashSet(int capacity) {\n            if (capacity < 0) {\n                throw new IllegalArgumentException(\"Capacity must be non-negative\");\n            }\n            // Actually we need 4x more memory\n            int length = 4 * Math.max(1, capacity);\n            if ((length & (length - 1)) != 0) {\n                length = Integer.highestOneBit(length) << 1;\n            }\n            // Length is a power of 2 now\n            initEmptyTable(length);\n            hashSeed = rnd.nextInt();\n        }\n\n        public EzCharHashSet(EzCharCollection collection) {\n            this(collection.size());\n            for (EzCharIterator iterator = collection.iterator(); iterator.hasNext(); ) {\n                add(iterator.next());\n            }\n        }\n\n        public EzCharHashSet(char[] srcArray) {\n            this(srcArray.length);\n            for (char element : srcArray) {\n                add(element);\n            }\n        }\n\n        public EzCharHashSet(Collection<Character> javaCollection) {\n            this(javaCollection.size());\n            for (char element : javaCollection) {\n                add(element);\n            }\n        }\n\n        private int getStartPos(int h) {\n            h ^= hashSeed;\n            h ^= (h >>> POS_RANDOM_SHIFT_1) ^ (h >>> POS_RANDOM_SHIFT_2);\n            return h & mask;\n        }\n\n        private int getStep(int h) {\n            h ^= hashSeed;\n            h ^= (h >>> STEP_RANDOM_SHIFT_1) ^ (h >>> STEP_RANDOM_SHIFT_2);\n            return ((h << 1) | 1) & mask;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public boolean contains(char element) {\n            final int elementHash = PrimitiveHashCalculator.getHash(element);\n            int pos = getStartPos(elementHash);\n            final int step = getStep(elementHash);\n            for (; status[pos] != FREE; pos = (pos + step) & mask) {\n                if (status[pos] == FILLED && table[pos] == element) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public EzCharIterator iterator() {\n            return new EzCharHashSetIterator();\n        }\n\n        public char[] toArray() {\n            char[] result = new char[size];\n            for (int i = 0, j = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    result[j++] = table[i];\n                }\n            }\n            return result;\n        }\n\n        public boolean add(char element) {\n            final int elementHash = PrimitiveHashCalculator.getHash(element);\n            int pos = getStartPos(elementHash);\n            final int step = getStep(elementHash);\n            for (; status[pos] == FILLED; pos = (pos + step) & mask) {\n                if (table[pos] == element) {\n                    return false;\n                }\n            }\n            if (status[pos] == FREE) {\n                status[pos] = FILLED;\n                table[pos] = element;\n                size++;\n                if ((size + removedCount) * 2 > table.length) {\n                    rebuild(table.length * 2); // enlarge the table\n                }\n                return true;\n            }\n            final int removedPos = pos;\n            for (pos = (pos + step) & mask; status[pos] != FREE; pos = (pos + step) & mask) {\n                if (status[pos] == FILLED && table[pos] == element) {\n                    return false;\n                }\n            }\n            status[removedPos] = FILLED;\n            table[removedPos] = element;\n            size++;\n            removedCount--;\n            return true;\n        }\n\n        private void rebuild(int newLength) {\n            char[] oldTable = table;\n            byte[] oldStatus = status;\n            initEmptyTable(newLength);\n            for (int i = 0; i < oldTable.length; i++) {\n                if (oldStatus[i] == FILLED) {\n                    add(oldTable[i]);\n                }\n            }\n        }\n\n        private void initEmptyTable(int length) {\n            table = new char[length];\n            status = new byte[length];\n            size = 0;\n            removedCount = 0;\n            mask = length - 1;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            EzCharHashSet that = (EzCharHashSet) o;\n\n            if (size != that.size) {\n                return false;\n            }\n            for (int i = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    if (!that.contains(table[i])) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public int hashCode() {\n            char[] array = toArray();\n            EzCharSort.sort(array);\n            int hash = HASHCODE_INITIAL_VALUE;\n            for (int i = 0; i < size; i++) {\n                hash = (hash ^ PrimitiveHashCalculator.getHash(array[i])) * HASHCODE_MULTIPLIER;\n            }\n            return hash;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append('[');\n            for (int i = 0; i < table.length; i++) {\n                if (status[i] == FILLED) {\n                    if (sb.length() > 1) {\n                        sb.append(\", \");\n                    }\n                    sb.append(table[i]);\n                }\n            }\n            sb.append(']');\n            return sb.toString();\n        }\n\n        private class EzCharHashSetIterator implements EzCharIterator {\n            private int curIndex = 0;\n\n            public boolean hasNext() {\n                while (curIndex < table.length && status[curIndex] != FILLED) {\n                    curIndex++;\n                }\n                return curIndex < table.length;\n            }\n\n            public char next() {\n                while (curIndex < table.length && status[curIndex] != FILLED) {\n                    curIndex++;\n                }\n                if (curIndex == table.length) {\n                    throw new NoSuchElementException(\"Iterator doesn't have more elements\");\n                }\n                return table[curIndex++];\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static final class PrimitiveHashCalculator {\n        private PrimitiveHashCalculator() {\n        }\n\n        public static int getHash(char x) {\n            return x;\n        }\n\n    }\n\n    static interface EzCharCollection {\n        int size();\n\n        EzCharIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n\n    static final class EzCharSort {\n        private static final double HEAPSORT_DEPTH_COEFFICIENT = 2.0;\n        private static final Random rnd = new Random();\n\n        private EzCharSort() {\n        }\n\n        private static int maxQuickSortDepth(int length) {\n            if (length <= 1) {\n                return 0;\n            }\n            int log = Integer.numberOfTrailingZeros(Integer.highestOneBit(length - 1)) + 1;\n            return (int) (HEAPSORT_DEPTH_COEFFICIENT * log);\n        }\n\n        public static void sort(char[] a) {\n            quickSort(a, 0, a.length, 0, maxQuickSortDepth(a.length));\n        }\n\n        private static void quickSort(char[] a, int left, int right, int depth, int maxDepth) {\n            if (right - left <= 1) {\n                return;\n            }\n            if (depth > maxDepth) {\n                heapSort(a, left, right - left);\n                return;\n            }\n            final char pivot = a[left + rnd.nextInt(right - left)];\n            int i = left;\n            int j = right - 1;\n            do {\n                while (a[i] < pivot) i++;\n                while (pivot < a[j]) j--;\n                if (i <= j) {\n                    char tmp = a[i];\n                    a[i++] = a[j];\n                    a[j--] = tmp;\n                }\n            } while (i <= j);\n            quickSort(a, left, j + 1, depth + 1, maxDepth);\n            quickSort(a, i, right, depth + 1, maxDepth);\n        }\n\n        private static void heapSort(char[] a, int offset, int size) {\n            // If size <= 1, nothing is executed\n            for (int i = (size >>> 1) - 1; i >= 0; i--) {\n                down(a, i, offset, size);\n            }\n            for (int i = size - 1; i > 0; i--) {\n                char tmp = a[offset];\n                a[offset] = a[offset + i];\n                a[offset + i] = tmp;\n                down(a, 0, offset, i);\n            }\n        }\n\n        private static void down(char[] a, int index, int offset, int size) {\n            final char element = a[offset + index];\n            final int firstLeaf = (size >>> 1);\n            while (index < firstLeaf) {\n                int largestChild = (index << 1) + 1;\n                if (largestChild + 1 < size && a[offset + largestChild + 1] > a[offset + largestChild]) {\n                    largestChild++;\n                }\n                if (a[offset + largestChild] <= element) {\n                    break;\n                }\n                a[offset + index] = a[offset + largestChild];\n                index = largestChild;\n            }\n            a[offset + index] = element;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(char[] array) {\n            writer.println(array);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static interface EzCharSet extends EzCharCollection {\n        int size();\n\n        EzCharIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n\n    static interface EzCharIterator {\n        boolean hasNext();\n\n        char next();\n\n    }\n\n    static class ArrayUtils {\n        public static char[] clone(final char[] array) {\n            if (array == null) {\n                return null;\n            }\n            return array.clone();\n        }\n\n        public ArrayUtils() {\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\ninput = raw_input\n\ndef first_bad(A, k):\n    seen = [0] * 10\n    for i,a in enumerate(A):\n        if seen[a] == 0:\n            k -= 1\n            seen[a] = 1\n        if k < 0:\n            return i\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n,k = [int(x) for x in input().split()]\n\n    A = [ord(c) - ord('0') for c in str(n)]\n    \n    while True:\n        i = first_bad(A, k)\n        if i == -1:\n            break\n        A[i] += 1\n        while i and A[i] == 10:\n            i -= 1\n            A[i] += 1\n        for j in range(i + 1, len(A)):\n            A[j] = 0\n\n    print ''.join(str(x) for x in A)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\t\tint t = Integer.parseInt(br.readLine());\n        while(t-- > 0){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            StringBuilder res = new StringBuilder();\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n            findResult(n + \"\", k, res, 0, map);\n            sb.append(res);\n            sb.append(\"\\n\");\n        }\n\t\tSystem.out.print(sb);\n\t}\n\tpublic static boolean findResult(String s, int k, StringBuilder result, int index, HashMap<Integer, Integer> map){\n\t    if(result.length() > 0 && Integer.parseInt(s.substring(0, index)) > Integer.parseInt(result.toString()))\n\t        return false;\n\t    if(map.size() <= k && result.length() > 0){\n\t        if(s.charAt(s.length() - 1) == ' ')\n\t            s = s.substring(0, s.length() - 1);\n\t       // System.out.println(s);\n\t        if(Integer.parseInt(result.toString()) >= Integer.parseInt(s))\n\t            return true;\n\t    }\n\t    for(int i = 0; i < 10; i++){\n\t        if(index == 0 && i == 0)\n\t            continue;\n\t        if(map.size() == k && !map.containsKey(i))\n\t            continue;\n\t        map.put(i, map.getOrDefault(i, 0) + 1);\n\t        result.append(i);\n\t       // if(s.equals(\"177890\")){\n\t       //    // System.out.println(\"size \" + set.size() + \" \" + map);\n\t       //     System.out.println(result);\n\t       // }\n\t        if(findResult(s, k, result, index + 1, map))\n\t            return true;\n\t        result.deleteCharAt(result.length() - 1);\n\t        map.put(i, map.get(i) - 1);\n\t        if(map.get(i) == 0)\n\t            map.remove(i);\n\t    }\n\t    return false;\n\t}\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid file_i_o();\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s = to_string(n);\n  string check = s;\n  int m = s.length();\n  while (true) {\n    int i = 0;\n    set<char> mark;\n    while (i < m) {\n      mark.insert(s[i]);\n      if (mark.size() > k) {\n        while (s[i] == '9') i--;\n        s[i]++;\n        break;\n      } else if (s[i] > check[i]) {\n        string ans = s.substr(0, i + 1);\n        if (mark.size() < k) mark.insert('0');\n        for (int j = i + 1; j < m; j++) {\n          ans += *mark.begin();\n        }\n        cout << ans << \"\\n\";\n        return;\n      }\n      i++;\n    }\n    if (i == m) {\n      cout << s << \"\\n\";\n      return;\n    }\n  }\n}\nvoid solve2() {\n  int n, k;\n  cin >> n >> k;\n  string s = to_string(n);\n  int m = s.length();\n  map<char, int> mark;\n  set<char> keep;\n  int i = 0;\n  while (i < m) {\n    keep.insert(s[i]);\n    mark[s[i]]++;\n    if (keep.size() > k) {\n      cout << \"i\"\n           << \" = \" << i << endl;\n      while (s[i] == '9') {\n        mark[s[i]]--;\n        if (mark[s[i]] == 0) mark.erase(s[i]);\n        i--;\n      }\n      mark[s[i]]--;\n      if (mark[s[i]] == 0) mark.erase(s[i]);\n      s[i]++;\n      mark[s[i]]++;\n      keep.insert(s[i]);\n      if (keep.size() < k) keep.insert('0');\n      string ans = s.substr(0, i + 1);\n      for (int j = i + 1; j < m; j++) {\n        ans += *keep.begin();\n      }\n      cout << ans << \"\\n\";\n      return;\n    }\n    i++;\n  }\n  cout << n << \"\\n\";\n}\nint32_t main(int32_t argc, char const *argv[]) {\n  clock_t begin = clock();\n  file_i_o();\n  int tt = 1;\n  cin >> tt;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\nvoid file_i_o() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\n"
        },
        {
            "language": 3,
            "solution": "def main(t):\n \n \n    n,k = map(int, input().split())\n    s = str(n)\n    m = len(s)\n \n \n    dic = {}\n \n    ans = \"\"\n \n    for i in range(m):\n \n        if s[i] in dic:\n            dic[s[i]] += 1\n        else:\n            dic[s[i]] = 1\n      \n \n \n \n        if len(dic)==k and i<m-1:\n            if s[i+1:] >  max(dic)*(m-i-1):\n                dic[s[i]] -= 1\n                if dic[s[i]]==0:  del dic[s[i]] \n                if str(int(s[i])+1) in dic and len(dic)<k:\n                    ans += str(int(s[i])+1)\n                    ans += '0'*(m-i-1)\n                else:\n                    dic[str(int(s[i])+1)] = 1\n                    ans += str(int(s[i])+1)\n                    ans += min(dic)*(m-i-1)\n                break\n \n            else:\n                ans += s[i]\n                broken = i+1\n                flag = True\n                for j in range(i+1,m):\n                    if s[j] < max(dic): broken = j\n                    if s[j] not in dic:  \n                        flag = False\n                        break\n                if flag:  broken=m \n                ans += s[i+1:broken]\n                if broken==m:  break\n \n                for d in range(int(s[broken])+1,10):\n                    if str(d) in dic: break\n                dic[str(d)] = 1\n                ans += str(d)\n                ans += min(dic)*(m-len(ans))\n                break\n \n                  \n \n        ans += s[i] \n \n    print(ans)\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1 \n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=input.nextInt();\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int k=input.nextInt();\n            String s=String.valueOf(n);\n            int arr[]=new int[10];\n            for(int i=0;i<s.length();i++)\n            {\n                int v=s.charAt(i)-'0';\n                arr[v]++;\n            }\n            if(fun(arr,k))\n            {\n                out.println(n);\n            }\n            else\n            {\n                int x=0,y=0,z=0;\n                for(int i=s.length()-1;i>=0;i--)\n                {\n                    int v=s.charAt(i)-'0';\n                    arr[v]--;\n                    int f=0;\n                    for(int j=v+1;j<10;j++)\n                    {\n                        arr[j]++;\n                        if(i+1<s.length())\n                        {\n                            for(int l=0;l<10;l++)\n                            {\n                                arr[l]++;\n                                if(fun(arr,k))\n                                {\n                                    x=i;y=j;z=l;\n                                    f=1;\n                                    break;\n                                }\n                                arr[l]--;\n                            }\n                        }\n                        else\n                        {\n                            if(fun(arr,k))\n                            {\n                                x=i;y=j;\n                                f=1;\n                                break;\n                            }\n                        }\n                        if(f==1) break;\n                        arr[j]--;\n                    }\n                    if(f==1) break;\n                }\n                String ans=\"\";\n                for(int i=0;i<x;i++)\n                {\n                    ans+=s.charAt(i);\n                }\n                ans+=y;\n                for(int i=x+1;i<s.length();i++)\n                {\n                    ans+=z;\n                }\n                out.println(ans);\n            }\n        }\n        out.close();\n    }\n    public static boolean fun(int arr[],int k)\n    {\n        int c=0;\n        for(int i=0;i<10;i++)\n        {\n            if(arr[i]>0)\n            {\n                c++;\n            }\n        }\n        if(c<=k)\n        {\n            return true;\n        }\n        return false;\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint funcK(int v) {\n  int num[10];\n  for (int i = 0; i < 10; ++i) num[i] = 0;\n  while (v > 0) {\n    num[v % 10] = 1;\n    v /= 10;\n  }\n  int x = 0;\n  for (int i = 0; i < 10; ++i) x += num[i];\n  return x;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    while (funcK(n) > k) {\n      int o = n;\n      while (funcK(o) > k) o /= 10;\n      int p = 1;\n      while (n / p != o) p *= 10;\n      p /= 10;\n      n = (n / p) * p + p;\n    }\n    printf(\"%d\\n\", n);\n  }\n}\n"
        }
    ]
}