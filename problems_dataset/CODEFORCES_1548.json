{
    "name": "1548_E. Gregor and the Two Painters",
    "source": "CODEFORCES",
    "description": "Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n \u00d7 m grid.\n\nFor each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.\n\nGregor considers the cell (i,j) to be badly painted if a_i+b_j \u2264 x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.\n\nGregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.\n\nInput\n\nThe first line contains three integers n, m and x (1 \u2264 n,m \u2264 2\u22c5 10^5, 1 \u2264 x \u2264 2\u22c5 10^5) \u2014 the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 2\u22c5 10^5), the number of paint layers Amin applies to each row.\n\nThe third line contains m integers b_1, b_2, \u2026, b_m (1 \u2264 b_j \u2264 2\u22c5 10^5), the number of paint layers Benj applies to each column.\n\nOutput\n\nPrint a single integer, the number of badly painted regions.\n\nExamples\n\nInput\n\n\n3 4 11\n9 8 5\n10 6 7 2\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n3 4 12\n9 8 5\n10 6 7 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n3 3 2\n1 2 1\n1 2 1\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5\n\n\nOutput\n\n\n6\n\nNote\n\nThe diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.\n\nThe colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.\n\n<image>",
    "difficulty": "E",
    "tags": [
        "data structures",
        "divide and conquer",
        "graphs",
        "greedy",
        "math"
    ],
    "rating": 3400,
    "public_test": [
        {
            "input": "3 4 12\n9 8 5\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "3 4 11\n9 8 5\n10 6 7 2\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 3 2\n1 2 1\n1 2 1\n",
            "output": "4\n"
        }
    ],
    "generated_test": [
        {
            "input": "3 3 4\n2 3 2\n3 1 2\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n9 8 5\n10 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 4 11\n9 8 5\n10 6 7 4\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 8 5\n",
            "output": "8\n"
        },
        {
            "input": "5 23 5\n1 4 3 1 2\n1 6 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "4\n"
        },
        {
            "input": "5 23 6\n1 4 3 6 2\n2 3 1 4 1 5 5 6 1 3 2 6 2 4 1 6 1 4 1 6 1 5 3\n",
            "output": "12\n"
        },
        {
            "input": "5 23 4\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 3 5\n",
            "output": "14\n"
        },
        {
            "input": "5 23 7\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 12 5\n",
            "output": "3\n"
        },
        {
            "input": "5 23 6\n1 4 6 2 2\n1 10 2 6 1 4 8 6 1 4 2 9 5 3 1 6 2 4 1 6 1 8 5\n",
            "output": "15\n"
        },
        {
            "input": "5 23 6\n1 4 3 8 2\n1 3 1 1 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "9\n"
        },
        {
            "input": "3 3 7\n3 4 4\n3 4 3\n",
            "output": "1\n"
        },
        {
            "input": "3 3 2\n1 2 1\n1 1 1\n",
            "output": "2\n"
        },
        {
            "input": "3 3 4\n2 3 2\n2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n9 8 9\n10 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 11\n9 8 5\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n1 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n2 3 2\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n9 1 9\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n9 8 5\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n1 3 1 6 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n2 4 2\n2 1 4\n",
            "output": "2\n"
        },
        {
            "input": "3 3 14\n9 8 5\n10 1 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 3 1 6 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n2 4 2\n3 1 4\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 3 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n2 2 2\n3 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 4\n2 2 2\n3 1 1\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 11 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 1 4\n2 2 2\n3 1 1\n",
            "output": "0\n"
        },
        {
            "input": "4 1 4\n2 2 2\n3 1 1\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n2 2 2\n3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n2 2 2\n3 2 0\n",
            "output": "1\n"
        },
        {
            "input": "1 1 2\n1\n2\n",
            "output": "0\n"
        },
        {
            "input": "5 5 6\n2 2 3 4 5\n5 4 3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "3 4 12\n9 8 1\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 4 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 1 2\n9 8 5\n10 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 4 11\n9 8 4\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 2\n1 2 2\n1 1 1\n",
            "output": "1\n"
        },
        {
            "input": "3 3 2\n2 3 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "3 1 22\n9 8 9\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 11\n3 8 5\n10 6 7 4\n",
            "output": "2\n"
        },
        {
            "input": "3 1 4\n2 3 2\n2 1 4\n",
            "output": "2\n"
        },
        {
            "input": "3 1 12\n9 1 9\n10 6 2 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n7 8 5\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 18 6\n1 4 3 5 2\n1 3 1 6 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "4\n"
        },
        {
            "input": "3 3 4\n4 4 2\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n9 11 5\n10 1 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n3 2 2\n3 1 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 10 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 11 1 5 5 6 1 4 2 5 3 3 1 9 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 1 4\n2 2 2\n3 1 0\n",
            "output": "0\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 10 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 8 5\n",
            "output": "8\n"
        },
        {
            "input": "4 1 4\n2 2 2\n3 3 0\n",
            "output": "0\n"
        },
        {
            "input": "1 1 2\n1\n3\n",
            "output": "0\n"
        },
        {
            "input": "5 5 6\n2 2 3 4 5\n5 2 3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 4 1 6 1 4 1 6 1 5 3\n",
            "output": "8\n"
        },
        {
            "input": "3 1 1\n9 8 5\n10 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 11\n9 8 4\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 12 1 5 5\n",
            "output": "4\n"
        },
        {
            "input": "1 1 22\n9 8 9\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 11\n3 8 5\n10 6 7 0\n",
            "output": "2\n"
        },
        {
            "input": "4 1 4\n2 3 2\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n9 2 9\n10 6 2 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n7 8 3\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 18 6\n1 4 3 5 2\n1 3 1 6 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "3 3 4\n4 2 2\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n12 11 5\n10 1 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 1 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n3 3 2\n3 1 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 11 1 5 5 6 1 4 2 5 3 3 1 9 1 4 1 6 2 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 1 4\n1 2 2\n3 1 0\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 10 1 6 1 5 5 6 1 4 2 5 3 3 1 6 2 4 1 6 1 8 5\n",
            "output": "8\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 4 1 5 5 6 1 3 2 6 2 4 1 6 1 4 1 6 1 5 3\n",
            "output": "7\n"
        },
        {
            "input": "3 3 11\n9 8 3\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 1 22\n9 8 9\n10 6 0 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 11\n3 8 5\n10 6 10 0\n",
            "output": "2\n"
        },
        {
            "input": "4 1 4\n2 3 2\n4 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n9 2 9\n20 6 2 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 4\n4 2 4\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 4 14\n12 11 5\n10 1 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "4 1 4\n1 2 2\n3 1 0\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 1 6 1 5 5 6 1 4 2 5 3 3 1 6 2 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "3 3 22\n9 8 3\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 5 3 3 1 6 1 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 1 22\n9 8 9\n10 6 0 0\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n1 3 2\n4 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n1 2 9\n20 6 2 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 4\n4 3 4\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 3 5\n",
            "output": "5\n"
        },
        {
            "input": "4 1 4\n1 2 4\n3 1 0\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 5 5 6 1 4 2 5 3 3 1 6 2 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "3 3 22\n9 12 3\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 1 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 1 22\n9 8 13\n10 6 0 0\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n1 3 4\n4 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 12\n2 2 9\n20 6 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4 1 4\n1 2 4\n3 1 -1\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 5 8 6 1 4 2 5 3 3 1 6 2 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "3 3 22\n9 12 3\n10 6 6 4\n",
            "output": "1\n"
        },
        {
            "input": "2 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 1 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 1 22\n9 8 13\n10 0 0 0\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n2 3 4\n4 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 2 12\n2 2 9\n20 6 2 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 7\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 3 5\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n1 2 4\n3 2 -1\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 5 8 6 1 4 2 5 5 3 1 6 2 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "3 3 22\n9 14 3\n10 6 6 4\n",
            "output": "1\n"
        },
        {
            "input": "2 23 6\n1 2 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 1 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 2 22\n9 8 13\n10 0 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 1 4\n2 3 4\n4 1 4\n",
            "output": "0\n"
        },
        {
            "input": "3 2 12\n2 2 9\n20 2 2 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 7\n1 4 3 1 3\n1 3 1 6 1 5 5 6 1 4 2 5 3 1 1 6 1 1 1 6 1 6 5\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n1 2 4\n3 2 0\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 2 5 5 3 1 6 2 4 1 6 1 8 5\n",
            "output": "7\n"
        },
        {
            "input": "3 3 22\n9 14 1\n10 6 6 4\n",
            "output": "1\n"
        },
        {
            "input": "2 23 6\n1 2 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 2 4 1 12 1 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 2 22\n9 12 13\n10 0 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 1 4\n2 3 4\n4 1 0\n",
            "output": "0\n"
        },
        {
            "input": "3 2 12\n2 2 9\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 2 9 5 3 1 6 2 4 1 6 1 8 5\n",
            "output": "8\n"
        },
        {
            "input": "3 3 22\n9 14 1\n10 12 6 4\n",
            "output": "1\n"
        },
        {
            "input": "2 23 6\n1 2 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 2 4 1 12 2 1 5\n",
            "output": "4\n"
        },
        {
            "input": "1 2 22\n9 14 13\n10 0 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 1 4\n2 3 8\n4 1 0\n",
            "output": "0\n"
        },
        {
            "input": "3 2 12\n2 1 9\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 2 9 5 3 1 6 2 4 1 6 2 8 5\n",
            "output": "8\n"
        },
        {
            "input": "3 3 22\n9 14 1\n10 20 6 4\n",
            "output": "2\n"
        },
        {
            "input": "3 23 6\n1 2 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 2 4 1 12 2 1 5\n",
            "output": "5\n"
        },
        {
            "input": "1 2 22\n5 14 13\n10 0 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 2 12\n2 1 13\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 10\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 2 9 5 3 1 6 2 4 1 6 2 8 5\n",
            "output": "2\n"
        },
        {
            "input": "3 3 22\n9 18 1\n10 20 6 4\n",
            "output": "3\n"
        },
        {
            "input": "3 23 6\n1 2 3 5 2\n2 3 1 6 1 5 5 6 1 3 1 5 3 3 1 6 2 8 1 12 2 1 5\n",
            "output": "6\n"
        },
        {
            "input": "1 2 22\n5 14 13\n10 -1 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 2 22\n2 1 13\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 10\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 2 9 5 3 1 2 2 4 1 6 2 8 5\n",
            "output": "2\n"
        },
        {
            "input": "1 3 22\n5 14 13\n10 -1 0 0\n",
            "output": "1\n"
        },
        {
            "input": "3 3 22\n2 1 13\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "5 23 10\n1 4 3 2 2\n1 10 2 6 1 4 8 6 1 4 1 9 5 3 1 2 2 4 1 6 2 8 5\n",
            "output": "2\n"
        },
        {
            "input": "3 3 22\n3 1 13\n20 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 22\n3 1 13\n17 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "1 1 2\n2\n1\n",
            "output": "0\n"
        },
        {
            "input": "3 3 4\n1 3 2\n3 2 2\n",
            "output": "2\n"
        },
        {
            "input": "5 4 6\n1 2 3 4 5\n5 4 3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "3 3 2\n3 4 3\n3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "3 4 11\n9 8 5\n10 1 7 2\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 2 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "2 3 2\n1 2 1\n1 2 1\n",
            "output": "1\n"
        },
        {
            "input": "3 3 7\n3 4 8\n3 4 3\n",
            "output": "1\n"
        },
        {
            "input": "6 1 12\n9 8 5\n10 6 7 2\n",
            "output": "1\n"
        },
        {
            "input": "3 3 11\n12 8 4\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n4 3 1 6 1 5 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n2 5 2\n2 1 2\n",
            "output": "2\n"
        },
        {
            "input": "3 1 12\n9 8 9\n10 6 8 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 11\n9 8 5\n10 6 10 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n1 3 1 6 2 5 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "3 3 8\n2 3 2\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 14\n9 8 5\n10 6 9 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n1 3 1 1 1 5 5 6 1 4 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "4\n"
        },
        {
            "input": "3 3 4\n2 4 2\n2 2 4\n",
            "output": "2\n"
        },
        {
            "input": "3 3 14\n9 16 5\n10 1 7 4\n",
            "output": "2\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 3 1 6 1 5 5 6 1 4 2 5 1 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 6\n2 4 2\n3 1 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 3 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 6 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 6 1 5 5 6 1 4 2 5 3 3 1 1 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 4\n4 2 2\n3 1 1\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 6 1 11 1 5 5 6 1 4 2 5 3 3 1 6 1 2 1 6 1 5 5\n",
            "output": "6\n"
        },
        {
            "input": "1 1 4\n2 2 2\n3 1 0\n",
            "output": "1\n"
        },
        {
            "input": "4 1 4\n2 2 2\n6 1 1\n",
            "output": "1\n"
        },
        {
            "input": "4 1 3\n2 2 2\n3 2 1\n",
            "output": "0\n"
        },
        {
            "input": "4 1 4\n2 2 2\n6 2 0\n",
            "output": "1\n"
        },
        {
            "input": "1 1 2\n1\n6\n",
            "output": "0\n"
        },
        {
            "input": "5 5 6\n2 2 3 4 5\n5 7 3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "3 1 2\n9 8 9\n10 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 4 11\n9 8 4\n10 3 7 4\n",
            "output": "1\n"
        },
        {
            "input": "1 23 6\n1 4 3 5 2\n2 3 1 6 1 6 5 6 1 3 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "3 3 2\n4 3 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 11\n3 8 5\n10 10 7 4\n",
            "output": "1\n"
        },
        {
            "input": "3 1 1\n2 3 2\n2 1 4\n",
            "output": "0\n"
        },
        {
            "input": "3 1 12\n9 1 9\n10 6 2 4\n",
            "output": "1\n"
        },
        {
            "input": "3 3 11\n7 8 5\n10 6 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 18 6\n1 4 3 5 2\n1 3 1 6 1 5 5 6 1 2 2 5 2 3 1 6 1 4 1 6 1 5 5\n",
            "output": "4\n"
        },
        {
            "input": "3 3 14\n8 11 5\n10 1 7 4\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 5 1 10 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 5 5\n",
            "output": "5\n"
        },
        {
            "input": "5 23 6\n1 7 3 1 2\n1 6 1 11 1 5 5 6 1 4 2 5 3 3 1 9 1 4 1 6 1 5 5\n",
            "output": "12\n"
        },
        {
            "input": "3 1 4\n2 4 2\n3 1 1\n",
            "output": "0\n"
        },
        {
            "input": "5 23 6\n1 4 3 1 2\n1 10 1 6 1 5 5 6 1 4 2 5 3 3 1 6 1 4 1 6 1 7 5\n",
            "output": "8\n"
        },
        {
            "input": "4 1 4\n2 2 2\n1 3 0\n",
            "output": "1\n"
        },
        {
            "input": "1 1 2\n2\n3\n",
            "output": "0\n"
        },
        {
            "input": "5 5 9\n2 2 3 4 5\n5 2 3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 4 1 6 1 4 1 8 1 5 3\n",
            "output": "8\n"
        },
        {
            "input": "3 1 1\n9 8 5\n17 6 7 2\n",
            "output": "0\n"
        },
        {
            "input": "3 3 11\n9 8 4\n3 6 7 4\n",
            "output": "1\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n  fenwick(int _n) : n(_n) { fenw.resize(n); }\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i] = min(a[i], x);\n  }\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    b[i] = min(b[i], x);\n  }\n  long long V = 0;\n  long long E = 0;\n  long long F = 0;\n  {\n    auto sa = a;\n    sort(sa.begin(), sa.end());\n    auto sb = b;\n    sort(sb.begin(), sb.end());\n    int j = m;\n    for (int i = 0; i < n; i++) {\n      while (j > 0 && sb[j - 1] + sa[i] > x) {\n        --j;\n      }\n      V += j;\n    }\n  }\n  {{vector<int> sa(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    sa[i] = max(a[i], a[i + 1]);\n  }\n  sort(sa.begin(), sa.end());\n  auto sb = b;\n  sort(sb.begin(), sb.end());\n  int j = m;\n  for (int i = 0; i < n - 1; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n{\n  auto sa = a;\n  sort(sa.begin(), sa.end());\n  vector<int> sb(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    sb[i] = max(b[i], b[i + 1]);\n  }\n  sort(sb.begin(), sb.end());\n  int j = m - 1;\n  for (int i = 0; i < n; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n}\n{\n  auto Make = [&](const vector<int>& v) {\n    int sz = (int)v.size();\n    vector<int> pr(sz), ne(sz);\n    for (int i = 0; i < sz; i++) {\n      pr[i] = i - 1;\n      ne[i] = i + 1;\n    }\n    vector<int> order(sz);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) { return v[i] > v[j]; });\n    SparseTable<int> st(v, [&](int i, int j) { return max(i, j); });\n    vector<tuple<int, int, int>> ret;\n    for (int i = 0; i < sz - 1; i++) {\n      ret.emplace_back(max(v[i], v[i + 1]), x, max(v[i], v[i + 1]));\n    }\n    for (int i : order) {\n      if (pr[i] >= 0 && ne[i] < sz) {\n        int v0 = max(v[pr[i]], v[ne[i]]);\n        int v1 = v[i];\n        int v2 = st.get(pr[i], ne[i]);\n        if (v0 < v1) {\n          ret.emplace_back(v0, v1, v2);\n        }\n      }\n      if (pr[i] != -1) {\n        ne[pr[i]] = ne[i];\n      }\n      if (ne[i] != sz) {\n        pr[ne[i]] = pr[i];\n      }\n    }\n    return ret;\n  };\n  vector<tuple<int, int, int>> r = Make(a);\n  vector<tuple<int, int, int>> c = Make(b);\n  42;\n  42;\n  vector<vector<pair<int, int>>> qs(x + 1);\n  for (auto& q : c) {\n    qs[x - get<2>(q)].emplace_back(x - get<1>(q) + 1, x - get<0>(q));\n  }\n  vector<vector<int>> ev(x + 1);\n  for (auto& p : r) {\n    ev[get<0>(p)].push_back(get<2>(p));\n    ev[get<1>(p)].push_back(~get<2>(p));\n  }\n  fenwick<int> fenw(x + 1);\n  for (int i = 1; i <= x; i++) {\n    for (int e : ev[i]) {\n      if (e >= 1) {\n        fenw.modify(e, +1);\n      } else {\n        fenw.modify(~e, -1);\n      }\n    }\n    for (auto& q : qs[i]) {\n      F += fenw.get(q.second) - fenw.get(q.first - 1);\n    }\n  }\n}\ncout << V - E + F << '\\n';\nreturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint as[200005];\nint bs[200005];\nint N, M;\nint stk[200005];\nint stk_size = 0;\nstd::vector<int> queries[400005];\nvoid query(int low, int high) { queries[high].push_back(low); }\nvoid append(int x) {\n  int& l = stk_size;\n  while (true) {\n    if ((l >= 2 && stk[l - 2] <= stk[l - 1] && stk[l - 1] <= x) ||\n        (l >= 2 && stk[l - 2] >= stk[l - 1] && stk[l - 1] >= x)) {\n      l--;\n    } else if (l >= 3 && stk[l - 3] <= stk[l - 1] && stk[l - 1] <= stk[l - 2] &&\n               stk[l - 2] <= x) {\n      query(stk[l - 1], stk[l - 2]);\n      l -= 2;\n    } else if (l >= 3 && stk[l - 3] >= stk[l - 1] && stk[l - 1] >= stk[l - 2] &&\n               stk[l - 2] >= x) {\n      query(stk[l - 2], stk[l - 1]);\n      l -= 2;\n    } else {\n      break;\n    }\n  }\n  stk[l++] = x;\n}\nint ft[400005];\nvoid ft_update(int i, int v) {\n  for (i++; i > 0; i -= (i & -i)) {\n    ft[i] += v;\n  }\n}\nint ft_query(int i) {\n  int res = 0;\n  for (i++; i <= 400001; i += (i & -i)) {\n    res += ft[i];\n  }\n  return res;\n}\nint uf[200005];\nint find(int a) { return (a == uf[a]) ? a : (uf[a] = find(uf[a])); }\nvoid merge(int x, int y) {\n  if (bs[x] > bs[y]) std::swap(x, y);\n  uf[x] = y;\n  ft_update(N + M - bs[x], -1);\n}\nint main() {\n  int X;\n  scanf(\"%d %d %d\", &N, &M, &X);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &as[i]);\n  }\n  for (int i = 0; i < M; i++) {\n    scanf(\"%d\", &bs[i]);\n  }\n  {\n    std::vector<int> asort(as, as + N);\n    std::vector<int> bsort(bs, bs + M);\n    std::vector<int> acps = asort, bcps = bsort;\n    std::sort(asort.begin(), asort.end());\n    std::sort(bsort.begin(), bsort.end());\n    int i = 0, j = M - 1;\n    for (int shift = N + M; shift > 0; shift--) {\n      if (i == N || (j >= 0 && asort[i] + bsort[j] > X)) {\n        bcps[j--] = N + M - shift;\n      } else {\n        acps[i++] = shift;\n      }\n    }\n    assert(i == N && j == -1);\n    for (int i = 0; i < N; i++) {\n      as[i] = acps[std::lower_bound(asort.begin(), asort.end(), as[i]) -\n                   asort.begin()];\n    }\n    for (int i = 0; i < M; i++) {\n      bs[i] = bcps[std::lower_bound(bsort.begin(), bsort.end(), bs[i]) -\n                   bsort.begin()];\n    }\n  }\n  append(0);\n  for (int i = 0; i < N; i++) {\n    append(as[i]);\n  }\n  append(0);\n  assert(stk_size == 3);\n  queries[stk[1]].push_back(0);\n  std::vector<std::vector<int> > where(N + M + 1);\n  for (int i = 0; i < M; i++) {\n    where[bs[i]].push_back(i);\n  }\n  for (int i = 0; i < M; i++) {\n    uf[i] = i;\n  }\n  long long ans = 0;\n  for (int a = 0; a <= N + M; a++) {\n    for (int i : where[N + M - a]) {\n      ft_update(a, 1);\n      if (i > 0 && bs[i - 1] >= bs[i]) {\n        merge(find(i - 1), find(i));\n      }\n      if (i < M - 1 && bs[i + 1] > bs[i]) {\n        merge(find(i), find(i + 1));\n      }\n    }\n    for (int q : queries[a]) {\n      ans += ft_query(q);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, inf = 0x3f3f3f3f;\nint n, m, x, c[N], d[N], stk[N], top, mx[N];\nint t[N], V[N], tot, ida[N], idb[N];\npair<int, int> a[N], b[N];\nlong long ans;\nbool cmpa_(int u, int v) { return a[u] < a[v]; }\nbool cmpb_(int u, int v) { return d[u] > d[v]; }\nvoid upd_(int x, int k) {\n  for (; x <= tot; x += x & -x) t[x] += k;\n}\nint ask_(int x, int res = 0) {\n  for (; x; x -= x & -x) res += t[x];\n  return res;\n}\nvoid work_() {\n  for (int i = 1; i <= m; i++) V[i] = b[i].first, idb[i] = i;\n  for (int i = 1; i <= n; i++) ida[i] = i;\n  sort(ida + 1, ida + n + 1, cmpa_);\n  sort(idb + 1, idb + m + 1, cmpb_);\n  sort(V + 1, V + m + 1), tot = unique(V + 1, V + m + 1) - V - 1;\n  for (int i = 1; i <= m; i++)\n    b[i].first = lower_bound(V + 1, V + tot + 1, b[i].first) - V;\n  for (int i = 1, j = 0; i <= n; i++) {\n    int u = ida[i], v, l, r;\n    while (j < m && d[idb[j + 1]] + a[u].first > x) {\n      v = idb[++j];\n      upd_(b[v].first, 1);\n    }\n    l = upper_bound(V + 1, V + tot + 1, x - c[u]) - V;\n    r = upper_bound(V + 1, V + tot + 1, x - a[u].first) - V - 1;\n    if (l <= r) ans += ask_(r) - ask_(l - 1);\n  }\n  printf(\"%lld\\n\", ans);\n}\nvoid init_(int n, pair<int, int> *a, int *b) {\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d\", &a[i].first), a[i].second = i, b[i] = inf;\n  stk[top = 0] = 0, mx[0] = inf;\n  for (int i = 1; i <= n; i++) {\n    while (top && a[stk[top]] > a[i]) {\n      mx[stk[top - 1]] = max(mx[stk[top - 1]], mx[stk[top]]);\n      top--;\n    }\n    b[i] = min(b[i], max(a[i].first, mx[stk[top]]));\n    mx[stk[++top] = i] = a[i].first;\n  }\n  stk[top = 0] = n + 1, mx[n + 1] = inf;\n  for (int i = n; i; i--) {\n    while (top && a[stk[top]] > a[i]) {\n      mx[stk[top - 1]] = max(mx[stk[top - 1]], mx[stk[top]]);\n      top--;\n    }\n    b[i] = min(b[i], max(a[i].first, mx[stk[top]]));\n    mx[stk[++top] = i] = a[i].first;\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &x);\n  init_(n, a, c);\n  init_(m, b, d);\n  work_();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans;\nint n, m, i, j, lg[200005], lim, al[200005], ar[200005];\nint a[200005], b[200005];\nint f[200005][19], g[200005][19];\nint fmi(int x, int y) { return a[x] > a[y] ? x : y; }\nint gmi(int x, int y) { return b[x] < b[y] ? x : y; }\nint qryf(int l, int r) {\n  int t = lg[r - l + 1];\n  return fmi(f[l][t], f[r - (1 << t) + 1][t]);\n}\nint qryg(int l, int r) {\n  int t = lg[r - l + 1];\n  return gmi(g[l][t], g[r - (1 << t) + 1][t]);\n}\npriority_queue<pair<int, int> > pq;\nint ord[200005];\nbool cmp(int x, int y) {\n  if (a[x] == a[y]) return x > y;\n  return a[x] < a[y];\n}\nset<pair<int, int> > s;\nvector<int> all;\nint c[200005];\nvoid add(int x, int y) {\n  while (x <= m) {\n    c[x] += y;\n    x += (x & -x);\n  }\n}\nint query(int x) {\n  int s = 0;\n  while (x) {\n    s += c[x];\n    x -= (x & -x);\n  }\n  return s;\n}\nvoid add_rng(int l, int r, int y) {\n  int x = qryg(l, r);\n  add(upper_bound(all.begin(), all.end(), b[x]) - all.begin(), y);\n}\nvoid del(int x) {\n  set<pair<int, int> >::iterator it = s.upper_bound(make_pair(x, 123456789));\n  it--;\n  int l = it->first, r = it->second;\n  s.erase(it);\n  add_rng(l, r, -1);\n  if (l < x) {\n    s.insert(make_pair(l, x - 1));\n    add_rng(l, x - 1, 1);\n  }\n  if (x < r) {\n    s.insert(make_pair(x + 1, r));\n    add_rng(x + 1, r, 1);\n  }\n}\nint solve(int x) {\n  return query(upper_bound(all.begin(), all.end(), x) - all.begin());\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &lim);\n  for (i = 2; i <= 200002; i++) lg[i] = lg[i / 2] + 1;\n  for (i = 1; i <= (n); i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= (m); i++) scanf(\"%d\", &b[i]);\n  for (i = 1; i <= (m); i++) all.push_back(b[i]);\n  sort(all.begin(), all.end());\n  all.resize(unique(all.begin(), all.end()) - all.begin());\n  for (i = 1; i <= (n); i++) f[i][0] = i;\n  for (i = 1; i <= (m); i++) g[i][0] = i;\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (n - (1 << j) + 1); i++)\n      f[i][j] = fmi(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (m - (1 << j) + 1); i++)\n      g[i][j] = gmi(g[i][j - 1], g[i + (1 << (j - 1))][j - 1]);\n  for (i = 1; i <= (m); i++) {\n    pq.push(make_pair(b[i], i));\n  }\n  for (i = 1; i <= (n); i++) ord[i] = i;\n  sort(ord + 1, ord + n + 1, cmp);\n  vector<int> stk;\n  for (i = 1; i <= (n); i++) {\n    while (!stk.empty() && a[stk.back()] >= a[i]) {\n      ar[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  for (i = n; i >= 1; i--) {\n    while (!stk.empty() && a[stk.back()] > a[i]) {\n      al[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  s.insert(make_pair(1, m));\n  add_rng(1, m, 1);\n  for (i = 1; i <= (n); i++) {\n    int x = ord[i];\n    while (!pq.empty() && pq.top().first + a[x] > lim) {\n      del(pq.top().second);\n      pq.pop();\n    }\n    int limr = lim - a[x];\n    int liml = 0;\n    if (al[x]) {\n      int t = qryf(al[x], x);\n      liml = max(liml, lim - a[t]);\n    }\n    if (ar[x]) {\n      int t = qryf(x, ar[x]);\n      liml = max(liml, lim - a[t]);\n    }\n    if (liml <= limr) {\n      ans += solve(limr);\n      ans -= solve(liml);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long P = 1e9 + 7;\nusing namespace std;\ntemplate <typename T>\ninline void ckmax(T &a, T b) {\n  (a < b) && (a = b);\n}\ntemplate <typename T>\ninline void ckmin(T &a, T b) {\n  (a > b) && (a = b);\n}\ninline long long mul(long long a, long long b) { return 1ull * a * b % P; }\ninline long long add(long long a, long long b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline long long sub(long long a, long long b) {\n  return a - b >= 0 ? a - b : a - b + P;\n}\ninline void mulmod(long long &a, long long b) { a = mul(a, b); }\ninline void addmod(long long &a, long long b) { ((a += b) >= P) && (a -= P); }\ninline void submod(long long &a, long long b) { ((a -= b) < 0) && (a += P); }\ninline long long ksm(long long a, long long b) {\n  long long ans = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) ans = 1ll * ans * a % P;\n    a = 1ll * a * a % P;\n  }\n  return ans;\n}\ninline void fprint(const long long &x, char c = ' ') {\n  fprintf(stderr, \"%d%c\", x, c);\n}\ninline void fprint(const pair<long long, long long> &x, char c = '\\n') {\n  fprintf(stderr, \"%d %d%c\", x.first, x.second, c);\n}\ninline void fprint(const long long *f, const long long &n, char c = '\\n') {\n  for (long long i = 1; i <= n; i++) fprint(f[i]);\n  fprintf(stderr, \"%c\", c);\n}\ninline void fprint(const vector<long long> &f, char c = '\\n') {\n  for (long long i = 0; i < (long long)f.size(); i++) fprint(f[i]);\n  fprintf(stderr, \"%c\", c);\n}\ninline long long inv(long long a) { return ksm(a, P - 2); }\nnamespace FastIO {\nconst long long SIZE = 1 << 16;\nchar buf[SIZE], obuf[SIZE], str[64];\nlong long bi = SIZE, bn = SIZE, opt;\nlong long read(char *s) {\n  while (bn) {\n    for (; bi < bn && buf[bi] <= ' '; bi++)\n      ;\n    if (bi < bn) break;\n    bn = fread(buf, 1, SIZE, stdin), bi = 0;\n  }\n  long long sn = 0;\n  while (bn) {\n    for (; bi < bn && buf[bi] > ' '; bi++) s[sn++] = buf[bi];\n    if (bi < bn) break;\n    bn = fread(buf, 1, SIZE, stdin), bi = 0;\n  }\n  s[sn] = 0;\n  return sn;\n}\nbool read(long long &x) {\n  if (x) x = 0;\n  long long bf = 0, n = read(str);\n  if (!n) return 0;\n  long long i = 0;\n  if (str[i] == '-') bf = 1, i = 1;\n  for (x = 0; i < n; i++) x = x * 10 + str[i] - '0';\n  if (bf) x = -x;\n  return 1;\n}\nvoid write(long long x) {\n  if (!x)\n    obuf[opt++] = '0';\n  else {\n    if (x < 0) obuf[opt++] = '-', x = -x;\n    long long sn = 0;\n    while (x) str[sn++] = x % 10 + '0', x /= 10;\n    for (long long i = sn - 1; i >= 0; i--) obuf[opt++] = str[i];\n  }\n  if (opt >= (SIZE >> 1)) {\n    fwrite(obuf, 1, opt, stdout);\n    opt = 0;\n  }\n}\nvoid write(char x) {\n  obuf[opt++] = x;\n  if (opt >= (SIZE >> 1)) {\n    fwrite(obuf, 1, opt, stdout);\n    opt = 0;\n  }\n}\nvoid Fflush() {\n  if (opt) fwrite(obuf, 1, opt, stdout);\n  opt = 0;\n}\n};  // namespace FastIO\ninline long long read() {\n  long long x;\n  FastIO::read(x);\n  return x;\n}\nconst long long MN = 2e5 + 5;\nlong long n, a[MN], b[MN], m, x, p[MN], q[MN], T = 2e5 + 1;\nlong long s[MN], top, mx[MN];\nvoid solve(long long *a, long long n, long long *ans) {\n  for (long long i = (1); i <= (n); i++) ans[i] = T;\n  top = 0;\n  reverse(a + 1, a + 1 + n);\n  for (long long i = (1); i <= (n); i++) {\n    long long nmx = a[i];\n    while (top && a[s[top]] >= a[i]) {\n      ckmax(nmx, mx[top]);\n      top--;\n    }\n    if (top) ckmin(ans[n - i + 1], nmx);\n    mx[++top] = nmx, s[top] = i;\n  }\n  top = 0;\n  reverse(a + 1, a + 1 + n);\n  for (long long i = (1); i <= (n); i++) {\n    long long nmx = a[i];\n    while (top && a[s[top]] > a[i]) {\n      ckmax(nmx, mx[top]);\n      top--;\n    }\n    if (top) ckmin(ans[i], nmx);\n    mx[++top] = nmx, s[top] = i;\n  }\n}\npair<long long, long long> A[MN], B[MN];\nstruct BIT {\n  static const long long N = MN;\n  long long c[N];\n  void upd(long long x, long long v) {\n    x++;\n    for (; x <= T + 1; x += x & -x) c[x] += v;\n  }\n  long long qry(long long x) {\n    x++;\n    long long ans = 0;\n    for (; x; x -= x & -x) ans += c[x];\n    return ans;\n  }\n} tr;\nbool cmp(pair<long long, long long> x, pair<long long, long long> y) {\n  if (y.second != x.second) return x.second > y.second;\n  return x.first < y.first;\n}\nvoid works() {\n  n = read(), m = read(), x = read();\n  for (long long i = (1); i <= (n); i++) a[i] = read();\n  for (long long i = (1); i <= (m); i++) b[i] = read();\n  solve(a, n, p);\n  solve(b, m, q);\n  for (long long i = (1); i <= (n); i++) A[i] = make_pair(a[i], p[i]);\n  for (long long i = (1); i <= (m); i++) B[i] = make_pair(b[i], q[i]);\n  sort(A + 1, A + 1 + n);\n  sort(B + 1, B + 1 + m, cmp);\n  long long ans = 0;\n  long long now = 1;\n  for (long long i = (1); i <= (n); i++) {\n    if (A[i].first > x) continue;\n    while (now <= m && B[now].second > x - A[i].first) {\n      tr.upd(B[now].first, 1);\n      now++;\n    }\n    ans += tr.qry(x - A[i].first) - tr.qry(max(x - A[i].second, 0ll));\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  long long T = 1;\n  while (T--) {\n    works();\n  }\n  return FastIO::Fflush(), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace io {\nconst int N = 1 << 20;\nchar buf[N], *t1 = buf, *t2 = buf;\ninline int read() {\n  static int an, f;\n  an = 0, f = 1;\n  static char ch;\n  ch = t1 == t2 && (t2 = (t1 = buf) + fread(buf, 1, N, stdin), t1 == t2)\n           ? EOF\n           : *t1++;\n  while (ch < 48 || ch > 57)\n    ch == '-' ? f = -1 : 0,\n                ch = t1 == t2 && (t2 = (t1 = buf) + fread(buf, 1, N, stdin),\n                                  t1 == t2)\n                         ? EOF\n                         : *t1++;\n  while (ch >= 48 && ch <= 57)\n    an = (an << 3) + (an << 1) + (ch ^ 48),\n    ch = t1 == t2 && (t2 = (t1 = buf) + fread(buf, 1, N, stdin), t1 == t2)\n             ? EOF\n             : *t1++;\n  return an * f;\n}\nchar buff[N], *T = buff;\ninline void flush() {\n  fwrite(buff, 1, T - buff, stdout);\n  T = buff;\n}\ninline void putc(char ch) {\n  if (T == buff + N) flush();\n  *T++ = ch;\n}\ntemplate <typename T>\ninline void print(T x) {\n  if (!x) {\n    putc('0');\n    return;\n  }\n  if (x < 0) putc('-'), x = -x;\n  static int st[30], tp;\n  while (x) st[++tp] = x % 10, x /= 10;\n  while (tp) putc(st[tp--] ^ 48);\n}\n}  // namespace io\nusing io::flush;\nusing io::print;\nusing io::putc;\nusing io::read;\nint n, m, x, a[200020], b[200020], c[200020], d[200020], p[200020], q[200020];\nvoid work(int f[], int mi[], int len) {\n  static int posup[200020], valup[200020], tpup, posdn[200020], valdn[200020],\n      tpdn;\n  for (int i = 1; i <= len; ++i) mi[i] = x + 1;\n  tpup = tpdn = 0;\n  posup[0] = posdn[0] = 0;\n  for (int i = 1; i <= len; ++i) {\n    while (tpup && f[i] < valup[tpup]) --tpup;\n    ++tpup, posup[tpup] = i, valup[tpup] = f[i];\n    while (tpdn && f[i] >= valdn[tpdn]) --tpdn;\n    ++tpdn, posdn[tpdn] = i, valdn[tpdn] = f[i];\n    if (tpup != 1)\n      mi[i] = min(\n          mi[i],\n          valdn[lower_bound(posdn + 1, posdn + 1 + tpdn, posup[tpup - 1] + 1) -\n                posdn]);\n  }\n  tpup = 0, tpdn = 0;\n  posup[0] = posdn[0] = len + 1;\n  for (int i = len; i; --i) {\n    while (tpup && f[i] <= valup[tpup]) --tpup;\n    ++tpup, posup[tpup] = i, valup[tpup] = f[i];\n    while (tpdn && f[i] >= valdn[tpdn]) --tpdn;\n    ++tpdn, posdn[tpdn] = i, valdn[tpdn] = f[i];\n    if (tpup != 1)\n      mi[i] =\n          min(mi[i], valdn[lower_bound(posdn + 1, posdn + 1 + tpdn,\n                                       posup[tpup - 1] - 1, greater<int>()) -\n                           posdn]);\n  }\n}\nnamespace BIT {\nint sum[200020];\nvoid add(int p) {\n  while (p <= 200000) ++sum[p], p += p & -p;\n}\nint qry(int p) {\n  if (p <= 0) return 0;\n  int res = 0;\n  while (p) res += sum[p], p -= p & -p;\n  return res;\n}\n}  // namespace BIT\nint main() {\n  n = read(), m = read(), x = read();\n  for (int i = 1; i <= n; ++i) a[i] = read();\n  for (int i = 1; i <= m; ++i) b[i] = read();\n  work(a, c, n);\n  work(b, d, m);\n  for (int i = 1; i <= n; ++i) p[i] = i;\n  sort(p + 1, p + 1 + n, [&](int x, int y) { return a[x] < a[y]; });\n  for (int i = 1; i <= m; ++i) q[i] = i;\n  sort(q + 1, q + 1 + m, [&](int x, int y) { return d[x] > d[y]; });\n  long long ans = 0;\n  for (int i = 1, last = 1; i <= n; ++i) {\n    while (last <= m && d[q[last]] > x - a[p[i]]) BIT::add(b[q[last]]), ++last;\n    ans += BIT::qry(x - a[p[i]]) - BIT::qry(x - c[p[i]]);\n  }\n  printf(\"%lld\\n\", ans);\n  flush();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void up(int &x, int y) { x < y ? x = y : 0; }\ninline void down(int &x, int y) { x > y ? x = y : 0; }\nconst int N = 2e5 + 5, K = 18;\nint n, m, X, a[N], b[N], lg[N], stk[N], c[N];\nvector<pair<int, int> > mdf[N];\npair<int, int> x[N], y[N];\nlong long ans;\nstruct ST {\n  int st[K][N];\n  void build(int *a, int n) {\n    for (int i = 0; i <= n; ++i) st[0][i] = a[i];\n    for (int k = 1; k < K; ++k)\n      for (int i = 0; i + (1 << k) - 1 <= n; ++i)\n        st[k][i] = max(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);\n  }\n  inline int query(int l, int r) {\n    int k = lg[r - l + 1];\n    return max(st[k][l], st[k][r - (1 << k) + 1]);\n  }\n} A, B;\ninline void modify(int p, int x) {\n  for (; p < N; p += p & -p) c[p] += x;\n}\ninline int query(int p) {\n  if (p <= 0) return 0;\n  int res = 0;\n  for (; p; p -= p & -p) res += c[p];\n  return res;\n}\ninline int query(int l, int r) { return query(r) - query(l - 1); }\nvoid solve(int l, int r) {\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  solve(l, mid), solve(mid + 1, r);\n  vector<pair<int, int> > cur;\n  for (int i = mid + 1; i <= r; ++i)\n    for (auto p : mdf[i]) cur.emplace_back(p);\n  sort(x + l, x + mid + 1,\n       [&](pair<int, int> x, pair<int, int> y) { return x.second < y.second; });\n  int j = 0;\n  for (int i = l; i <= mid; ++i) {\n    while (j < cur.size() && x[i].second + cur[j].first > X)\n      modify(cur[j++].second, 1);\n    ans += query(X - x[i].first + 1, N - 1);\n  }\n  for (--j; ~j; --j) modify(cur[j].second, -1);\n}\nint main() {\n  for (int i = 2; i < N; ++i) lg[i] = lg[i >> 1] + 1;\n  scanf(\"%d%d%d\", &n, &m, &X);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    x[i].first = a[i], x[i].second = 1e9;\n  }\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d\", &b[i]);\n    y[i].first = b[i], y[i].second = 1e9;\n  }\n  a[0] = a[n + 1] = b[0] = b[m + 1] = X;\n  A.build(a, n + 1), B.build(b, m + 1);\n  int top = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (top && a[stk[top]] > a[i]) --top;\n    down(x[i].second, A.query(stk[top], i));\n    stk[++top] = i;\n  }\n  stk[top = 0] = n + 1;\n  for (int i = n; i; --i) {\n    while (top && a[stk[top]] >= a[i]) --top;\n    down(x[i].second, A.query(i, stk[top]));\n    stk[++top] = i;\n  }\n  stk[top = 0] = 0;\n  for (int i = 1; i <= m; ++i) {\n    while (top && b[stk[top]] > b[i]) --top;\n    down(y[i].second, B.query(stk[top], i));\n    stk[++top] = i;\n  }\n  stk[top = 0] = m + 1;\n  for (int i = m; i; --i) {\n    while (top && b[stk[top]] >= b[i]) --top;\n    down(y[i].second, B.query(i, stk[top]));\n    stk[++top] = i;\n  }\n  sort(x + 1, x + n + 1), sort(y + 1, y + m + 1);\n  for (int i = n, j = 1; i; --i)\n    while (j <= m && x[i].first + y[j].first <= X)\n      mdf[i + 1].emplace_back(y[j++]);\n  solve(1, n + 1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, L, i, j, k, a[200005], b[200005], id[200005], p[200005];\nint cmp(int i, int j) { return b[i] < b[j] || b[i] == b[j] && i < j; }\nint f[200005], d[200005], d0[200005];\nvector<int> D[200005];\nvoid prepare() {\n  int w = 1;\n  d[1] = 0, d0[1] = 0;\n  for (i = 1; i <= m; i++) f[i] = m + 1;\n  for (i = 1; i <= m; i++) {\n    while (id[i] < id[d[w]]) d0[w - 1] = max(d0[w - 1], d0[w]), w--;\n    if (w > 1) f[i] = min(f[i], d0[w]);\n    w++, d[w] = i, d0[w] = id[i];\n  }\n  w = 1, d[1] = m + 1, d0[1] = 0;\n  for (i = m; i >= 1; i--) {\n    while (id[i] < id[d[w]]) d0[w - 1] = max(d0[w - 1], d0[w]), w--;\n    if (w > 1) f[i] = min(f[i], d0[w]);\n    w++, d[w] = i, d0[w] = id[i];\n  }\n  for (i = 1; i <= m; i++) D[f[i]].push_back(i);\n}\nstruct arr {\n  int l, r, v;\n} A[200005 * 2];\nint tot;\nvoid add(int l, int r, int v) { A[++tot] = (arr){l, r, v}; }\nint cmp2(arr a, arr b) { return a.v < b.v; }\nvoid doit() {\n  int w = 1, now = 0;\n  d[1] = 0, d0[1] = 0;\n  for (i = 1; i <= n + 1; i++) {\n    int l = 1, r = m, mid, v = 0;\n    if (i <= n)\n      while (l <= r) {\n        mid = (l + r) >> 1;\n        if (a[i] + b[p[mid]] <= L)\n          v = mid, l = mid + 1;\n        else\n          r = mid - 1;\n      }\n    if (v == now) continue;\n    if (v > now) {\n      int st = now + 1;\n      while (w && d0[w] <= v) st = d[w], w--;\n      w++, d[w] = st, d0[w] = v, now = v;\n    } else {\n      while (d[w] > v) add(d[w], now, d0[w]), now = d[w] - 1, w--;\n      if (v + 1 <= now) add(v + 1, now, d0[w]);\n      now = v;\n    }\n  }\n}\nstruct Treearray {\n  int s[200005];\n  void add(int x, int d) {\n    for (; x <= m; x += x & -x) s[x] += d;\n  }\n  int sum(int x, int S = 0) {\n    for (; x; x -= x & -x) S += s[x];\n    return S;\n  }\n  int query(int l, int r) { return sum(r) - sum(l - 1); }\n} t;\nvoid cal() {\n  sort(A + 1, A + 1 + tot, cmp2);\n  long long ans = 0;\n  for (i = 0, j = 1; i <= m; i++) {\n    for (k = 0; k < D[i].size(); k++) t.add(id[D[i][k]], 1);\n    while (j <= tot && A[j].v == i)\n      ans += A[j].r - A[j].l + 1 - t.query(A[j].l, A[j].r), j++;\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &L);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= m; i++) scanf(\"%d\", &b[i]), p[i] = i;\n  sort(p + 1, p + 1 + m, cmp);\n  for (i = 1; i <= m; i++) id[p[i]] = i;\n  prepare();\n  doit();\n  cal();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::vector;\nconst int N = 200054;\nint R, C, X;\nint r[N], c[N];\nvector<int> ins[N], del[N];\nvector<std::pair<int, int> > qry[N];\nstruct data {\n  int u, v, w;\n  inline bool accept(const data &B) const {\n    return B.v <= u && u <= B.w && v <= B.u && B.u <= w;\n  }\n  inline void shrink(int x) { u -= x, v -= x, w -= x; }\n} A[N], B[N];\ninline void down(int &x, const int y) { x > y ? x = y : 0; }\nnamespace Cartesian {\nint n, *a, root;\nint stack[N], lc[N], rc[N];\ndata b[N];\ninline void init(int n_, int *a_) { n = n_, a = a_; }\nint dfs(int n, int L, int R) {\n  b[n].w = std::min(a[L - 1], a[R + 1]) - 1;\n  b[n].u = b[n].v = a[n];\n  if (~lc[n]) down(b[n].u, dfs(lc[n], L, n - 1));\n  if (~rc[n]) down(b[n].u, dfs(rc[n], n + 1, R));\n  return b[n].u;\n}\nvoid build() {\n  int i, top = 0;\n  memset(lc, -1, (n + 2) << 2), memset(rc, -1, (n + 2) << 2);\n  for (i = 0; i <= n + 1; ++i) {\n    for (; top && a[stack[top]] <= a[i]; --top) lc[i] = stack[top];\n    if (top) rc[stack[top]] = i;\n    stack[++top] = i;\n  }\n}\nvoid work(data *ret) {\n  int i;\n  build(), dfs(rc[0], 1, n);\n  for (i = 1; i <= n; ++i) ret[i] = b[i], ret[i].u = X - ret[i].u;\n}\n}  // namespace Cartesian\nnamespace BIT {\nconst int N = 400054;\nint x[N];\ninline int sum(int h) {\n  int s = 0;\n  for (; h >= 0; h &= h + 1, --h) s += x[h];\n  return s;\n}\ninline void add(int h, int v) {\n  for (; h < N; h |= h + 1) x[h] += v;\n}\ninline int range(int l, int r) { return sum(r) - sum(l - 1); }\n}  // namespace BIT\nint main() {\n  int i, j, t, min = 0;\n  long long ans = 0;\n  std::ios::sync_with_stdio(false), cin.tie(nullptr);\n  cin >> R >> C >> X, r[0] = r[R + 1] = c[0] = c[C + 1] = X + 2;\n  for (i = 1; i <= R; ++i) cin >> r[i], down(r[i], X + 1);\n  for (j = 1; j <= C; ++j) cin >> c[j], down(c[j], X + 1);\n  Cartesian::init(R, r), Cartesian::work(A), Cartesian::init(C, c),\n      Cartesian::work(B);\n  for (i = 1; i <= R; ++i) down(min, A[i].u);\n  for (j = 1; j <= C; ++j) down(min, B[j].u);\n  for (i = 1; i <= R; ++i) A[i].shrink(min);\n  for (j = 1; j <= C; ++j) B[j].shrink(min);\n  for (i = 1; i <= R; ++i)\n    ins[A[i].v].emplace_back(A[i].u), del[A[i].w + 1].emplace_back(A[i].u);\n  for (j = 1; j <= C; ++j) qry[B[j].u].emplace_back(B[j].v, B[j].w);\n  for (t = 0; t < N; ++t) {\n    for (int x : ins[t]) BIT::add(x, 1);\n    for (int x : del[t]) BIT::add(x, -1);\n    for (const std::pair<int, int> &e : qry[t])\n      ans += BIT::range(e.first, e.second);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  int op = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') op = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = getchar();\n  }\n  x *= op;\n}\ninline void swap(int &x, int &y) { x ^= y ^= x ^= y; }\ninline int min(int x, int y) { return x < y ? x : y; }\ninline int max(int x, int y) { return x > y ? x : y; }\nconst int L = 200000;\nconst int MN = L + 10;\nint n, m, X;\nstruct item {\n  int v, mx;\n} A[MN], B[MN];\nbool cmp1(item a, item b) { return a.v < b.v; }\nbool cmp2(item a, item b) { return a.mx > b.mx; }\nint stk[MN], top, mx[MN];\nlong long ans;\nstruct BITS {\n  int c[MN];\n  inline int lwb(int x) { return x & (-x); }\n  void Add(int x, int v) {\n    for (; x <= L; x += lwb(x)) c[x] += v;\n  }\n  int Ask(int x) {\n    int s = 0;\n    for (; x; x -= lwb(x)) s += c[x];\n    return s;\n  }\n  int Qur(int l, int r) {\n    l = max(l, 1);\n    r = min(r, L);\n    return l > r ? 0 : Ask(r) - Ask(l - 1);\n  }\n} tr;\nint main() {\n  read(n);\n  read(m);\n  read(X);\n  for (int i = 1; i <= n; ++i) read(A[i].v);\n  for (int i = 1; i <= m; ++i) read(B[i].v);\n  mx[0] = L;\n  for (int i = 1; i <= n; ++i) {\n    while (top && A[stk[top]].v > A[i].v)\n      mx[top - 1] = max(mx[top - 1], mx[top]), top--;\n    A[i].mx = mx[top];\n    stk[++top] = i;\n    mx[top] = A[i].v;\n  }\n  top = 0;\n  for (int i = 1; i <= m; ++i) {\n    while (top && B[stk[top]].v > B[i].v)\n      mx[top - 1] = max(mx[top - 1], mx[top]), top--;\n    B[i].mx = mx[top];\n    stk[++top] = i;\n    mx[top] = B[i].v;\n  }\n  top = 0;\n  for (int i = n; i >= 1; --i) {\n    while (top && A[stk[top]].v >= A[i].v)\n      mx[top - 1] = max(mx[top - 1], mx[top]), top--;\n    A[i].mx = min(A[i].mx, mx[top]);\n    stk[++top] = i;\n    mx[top] = A[i].v;\n  }\n  top = 0;\n  for (int i = m; i >= 1; --i) {\n    while (top && B[stk[top]].v >= B[i].v)\n      mx[top - 1] = max(mx[top - 1], mx[top]), top--;\n    B[i].mx = min(B[i].mx, mx[top]);\n    stk[++top] = i;\n    mx[top] = B[i].v;\n  }\n  sort(A + 1, A + n + 1, cmp1);\n  sort(B + 1, B + m + 1, cmp2);\n  for (int i = 1, j = 0; i <= n; ++i) {\n    while (j < m && B[j + 1].mx > X - A[i].v) j++, tr.Add(B[j].v, 1);\n    ans += tr.Qur(X - A[i].mx + 1, X - A[i].v);\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFi = 2e9 + 5;\nconst int maxN = 2e5 + 5;\nconst int md = 998244353;\nconst long long INF = 2e18;\ndouble getTime() { return clock() / (double)CLOCKS_PER_SEC; }\nvector<pair<int, int>> solve(vector<int> &a) {\n  int n = a.size();\n  vector<pair<int, int>> stk = {{-INFi, -INFi}};\n  vector<pair<int, int>> result(n);\n  for (int i = 0; i < (n); ++i) {\n    int mx = stk.back().second;\n    while (!stk.empty() && stk.back().first >= a[i]) {\n      stk.pop_back();\n      mx = max(mx, stk.back().second);\n    }\n    stk.back().second = max(mx, a[i]);\n    if (stk.size() == 1) mx = INFi;\n    result[i] = {a[i], mx};\n    stk.emplace_back(a[i], -INFi);\n  }\n  stk = {{-INFi, -INFi}};\n  for (int i = n - 1; i >= 0; --i) {\n    int mx = stk.back().second;\n    while (!stk.empty() && stk.back().first > a[i]) {\n      stk.pop_back();\n      mx = max(mx, stk.back().second);\n    }\n    stk.back().second = max(mx, a[i]);\n    if (stk.size() == 1) mx = INFi;\n    result[i].second = min(result[i].second, mx);\n    stk.emplace_back(a[i], -INFi);\n  }\n  return result;\n}\nstruct fenwick {\n  int n{};\n  vector<long long> fenw{};\n  void build(int k) {\n    n = k;\n    fenw.resize(n);\n  }\n  void upd(int i, long long x) {\n    for (; i < n; i = i | (i + 1)) fenw[i] += x;\n  }\n  long long get(int i) {\n    long long res = 0;\n    for (; i >= 0; i = (i & (i + 1)) - 1) res += fenw[i];\n    return res;\n  }\n  long long get(int l, int r) {\n    if (l > r) return 0;\n    return get(r) - get(l - 1);\n  }\n};\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  int x;\n  cin >> x;\n  vector<int> a(n), b(m);\n  for (int i = 0; i < (n); ++i) cin >> a[i];\n  for (int i = 0; i < (m); ++i) cin >> b[i];\n  auto p1 = solve(a), p2 = solve(b);\n  sort((p1).begin(), (p1).end());\n  sort((p2).rbegin(), (p2).rend());\n  int j = 0;\n  multiset<pair<int, int>> have;\n  fenwick f;\n  f.build(maxN);\n  long long ans = 0;\n  for (auto &[c, ct] : p2) {\n    while (j < n && p1[j].first + c <= x) {\n      have.insert({p1[j].second, p1[j].first});\n      f.upd(p1[j].first, 1);\n      j++;\n    }\n    while (!have.empty() && have.begin()->first + c <= x) {\n      f.upd(have.begin()->second, -1);\n      have.erase(have.begin());\n    }\n    if (ct == -INFi) continue;\n    ans += f.get(x - ct + 1, maxN - 1);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tests = 1;\n  for (int _ = 0; _ < (tests); ++_) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T& a) {\n  char c = getchar();\n  int f = 1;\n  a = 0;\n  for (; c > '9' || c < '0'; c = getchar())\n    if (c == '-') f = -1;\n  for (; c <= '9' && c >= '0'; c = getchar()) a = a * 10 + c - 48;\n  a *= f;\n}\ninline int Max(int a, int b) { return a > b ? a : b; }\ninline int Min(int a, int b) { return a < b ? a : b; }\ninline int lowbit(int x) { return x & -x; }\nconst int o = 2e5 + 10, inf = 1e8;\nint n, m, x, lg[o], a[o], b[o], na[o], nb[o], st[2][o][20], st2[2][o][20],\n    lo[o], hi[o], ft[o];\npair<int, int> p1[o], p2[o];\nlong long ans;\ninline int query(int id, int l, int r) {\n  int t = lg[r - l + 1];\n  return Min(st[id][l][t], st[id][r - (1 << t) + 1][t]);\n}\nint query2(int id, int l, int r) {\n  if (!l || r > (id ? m : n)) return inf;\n  int t = lg[r - l + 1];\n  return Max(st2[id][l][t], st2[id][r - (1 << t) + 1][t]);\n}\ninline bool cmp1(pair<int, int> A, pair<int, int> B) {\n  return A.second < B.second;\n}\ninline bool cmp2(pair<int, int> A, pair<int, int> B) {\n  return A.first > B.first;\n}\ninline void modify(int pos) {\n  for (++pos; pos < o; pos += lowbit(pos)) ++ft[pos];\n}\ninline int ask(int pos) {\n  if (++pos < 0) return 0;\n  int res = 0;\n  for (; pos; pos -= lowbit(pos)) res += ft[pos];\n  return res;\n}\nint main() {\n  read(n);\n  read(m);\n  read(x);\n  lg[0] = -1;\n  for (int i = 1; i <= n; ++i)\n    read(a[i]), st[0][i][0] = st2[0][i][0] = a[i], lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= m; ++i)\n    read(b[i]), st[1][i][0] = st2[1][i][0] = b[i], lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i < 20; ++i)\n    for (int j = 1; j <= n; ++j)\n      st[0][j][i] = Min(\n          st[0][j][i - 1],\n          (j + (1 << (i - 1)) > n) ? inf : st[0][j + (1 << (i - 1))][i - 1]),\n      st2[0][j][i] =\n          Max(st2[0][j][i - 1],\n              (j + (1 << (i - 1)) > n) ? 0 : st2[0][j + (1 << (i - 1))][i - 1]);\n  for (int i = 1; i < 20; ++i)\n    for (int j = 1; j <= m; ++j)\n      st[1][j][i] = Min(\n          st[1][j][i - 1],\n          (j + (1 << (i - 1)) > m) ? inf : st[1][j + (1 << (i - 1))][i - 1]),\n      st2[1][j][i] =\n          Max(st2[1][j][i - 1],\n              (j + (1 << (i - 1)) > m) ? 0 : st2[1][j + (1 << (i - 1))][i - 1]);\n  for (int i = 1, l, r, md; i <= n; lo[i++] = l)\n    for (l = 0, r = i - 1; l < r;)\n      if (query(0, md = (l + r >> 1) + 1, i) < a[i])\n        l = md;\n      else\n        r = md - 1;\n  for (int i = 1, l, r, md; i <= n; hi[i++] = l)\n    for (l = i + 1, r = n + 1; l < r;)\n      if (query(0, i + 1, md = l + r >> 1) <= a[i])\n        r = md;\n      else\n        l = md + 1;\n  for (int i = 1; i <= n; ++i)\n    na[i] = Min(query2(0, lo[i], i), query2(0, i, hi[i]));\n  for (int i = 1, l, r, md; i <= m; lo[i++] = l)\n    for (l = 0, r = i - 1; l < r;)\n      if (query(1, md = (l + r >> 1) + 1, i) < b[i])\n        l = md;\n      else\n        r = md - 1;\n  for (int i = 1, l, r, md; i <= m; hi[i++] = l)\n    for (l = i + 1, r = m + 1; l < r;)\n      if (query(1, i + 1, md = l + r >> 1) <= b[i])\n        r = md;\n      else\n        l = md + 1;\n  for (int i = 1; i <= m; ++i)\n    nb[i] = Min(query2(1, lo[i], i), query2(1, i, hi[i]));\n  for (int i = 1; i <= n; ++i) p1[i] = make_pair(na[i], a[i]);\n  for (int i = 1; i <= m; ++i) p2[i] = make_pair(nb[i], b[i]);\n  sort(p1 + 1, p1 + 1 + n, cmp1);\n  sort(p2 + 1, p2 + 1 + m, cmp2);\n  for (int i = 1, j = 1; i <= n;\n       ans += ask(x - p1[i].second) - ask(x - p1[i].first), ++i)\n    for (; j <= m && p1[i].second + p2[j].first > x; modify(p2[j++].second))\n      ;\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans;\nint n, m, i, j, lg[200005], lim, al[200005], ar[200005];\nint a[200005], b[200005];\nint f[200005][19], g[200005][19];\nint fmi(int x, int y) { return a[x] > a[y] ? x : y; }\nint gmi(int x, int y) { return b[x] < b[y] ? x : y; }\nint qryf(int l, int r) {\n  int t = lg[r - l + 1];\n  return fmi(f[l][t], f[r - (1 << t) + 1][t]);\n}\nint qryg(int l, int r) {\n  int t = lg[r - l + 1];\n  return gmi(g[l][t], g[r - (1 << t) + 1][t]);\n}\npriority_queue<pair<int, int> > pq;\nint ord[200005];\nset<pair<int, int> > s;\nvector<int> all;\nint c[200005];\nbool cmp(int x, int y) {\n  if (a[x] == a[y]) return x > y;\n  return a[x] < a[y];\n}\nvoid add(int x, int y) {\n  while (x <= m) {\n    c[x] += y;\n    x += (x & -x);\n  }\n}\nint query(int x) {\n  int s = 0;\n  while (x) {\n    s += c[x];\n    x -= (x & -x);\n  }\n  return s;\n}\nvoid add_rng(int l, int r, int y) {\n  int x = qryg(l, r);\n  add(upper_bound(all.begin(), all.end(), b[x]) - all.begin(), y);\n}\nvoid del(int x) {\n  set<pair<int, int> >::iterator it = s.upper_bound(make_pair(x, 123456789));\n  it--;\n  int l = it->first, r = it->second;\n  s.erase(it);\n  add_rng(l, r, -1);\n  if (l < x) {\n    s.insert(make_pair(l, x - 1));\n    add_rng(l, x - 1, 1);\n  }\n  if (x < r) {\n    s.insert(make_pair(x + 1, r));\n    add_rng(x + 1, r, 1);\n  }\n}\nint solve(int x) {\n  return query(upper_bound(all.begin(), all.end(), x) - all.begin());\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &lim);\n  for (i = 2; i <= 200002; i++) lg[i] = lg[i / 2] + 1;\n  for (i = 1; i <= (n); i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= (m); i++) scanf(\"%d\", &b[i]);\n  for (i = 1; i <= (m); i++) all.push_back(b[i]);\n  sort(all.begin(), all.end());\n  all.resize(unique(all.begin(), all.end()) - all.begin());\n  for (i = 1; i <= (n); i++) f[i][0] = i;\n  for (i = 1; i <= (m); i++) g[i][0] = i;\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (n - (1 << j) + 1); i++)\n      f[i][j] = fmi(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (m - (1 << j) + 1); i++)\n      g[i][j] = gmi(g[i][j - 1], g[i + (1 << (j - 1))][j - 1]);\n  for (i = 1; i <= (m); i++) pq.push(make_pair(b[i], i));\n  for (i = 1; i <= (n); i++) ord[i] = i;\n  sort(ord + 1, ord + n + 1, cmp);\n  vector<int> stk;\n  for (i = 1; i <= (n); i++) {\n    while (!stk.empty() && a[stk.back()] >= a[i]) {\n      ar[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  for (i = n; i >= 1; i--) {\n    while (!stk.empty() && a[stk.back()] > a[i]) {\n      al[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  s.insert(make_pair(1, m));\n  add_rng(1, m, 1);\n  for (i = 1; i <= (n); i++) {\n    int x = ord[i];\n    while (!pq.empty() && pq.top().first + a[x] > lim) {\n      del(pq.top().second);\n      pq.pop();\n    }\n    int limr = lim - a[x];\n    int liml = 0;\n    if (al[x]) {\n      int t = qryf(al[x], x);\n      liml = max(liml, lim - a[t]);\n    }\n    if (ar[x]) {\n      int t = qryf(x, ar[x]);\n      liml = max(liml, lim - a[t]);\n    }\n    if (liml <= limr) {\n      ans += solve(limr);\n      ans -= solve(liml);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000, C = 19, INF = (1 << 30) - 1;\nint n, m, sk, a[N + 9], b[N + 9];\nvoid into() {\n  scanf(\"%d%d%d\", &n, &m, &sk);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", &b[i]);\n}\nint lg[N + 9], mx[C][N + 9];\nvoid Get_mx(int n, int *a) {\n  for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= n; ++i) mx[0][i] = a[i];\n  for (int i = 1; i < C; ++i)\n    for (int j = 1; j + (1 << i) - 1 <= n; ++j)\n      mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << i - 1)]);\n}\nint Query_max(int l, int r) {\n  int t = lg[r - l + 1];\n  return max(mx[t][l], mx[t][r - (1 << t) + 1]);\n}\nstruct question {\n  int x, y, id;\n  question(int X = 0, int Y = 0, int Id = 0) {\n    x = X;\n    y = Y;\n    id = Id;\n  }\n} q[N * 2 + 9];\nint cq;\nint sta[N + 9], cst;\nvoid Get_d(int n, int *a, int id) {\n  Get_mx(n, a);\n  static int tmp[N + 9];\n  cst = 0;\n  for (int i = 1; i <= n; ++i) {\n    tmp[i] = INF;\n    for (; cst && a[i] <= a[sta[cst]]; --cst)\n      ;\n    if (cst) tmp[i] = min(tmp[i], Query_max(sta[cst] + 1, i));\n    sta[++cst] = i;\n  }\n  cst = 0;\n  for (int i = n; i >= 1; --i) {\n    for (; cst && a[i] < a[sta[cst]]; --cst)\n      ;\n    if (cst) tmp[i] = min(tmp[i], Query_max(i, sta[cst] - 1));\n    sta[++cst] = i;\n  }\n  for (int i = 1; i <= n; ++i) q[++cq] = question(a[i], tmp[i], id);\n}\nint c[2][N + 9];\nvoid Add(int id, int p) {\n  for (; p <= N; p += p & -p) ++c[id][p];\n}\nint Query(int id, int p) {\n  int res = 0;\n  for (; p; p -= p & -p) res += c[id][p];\n  return res;\n}\nint Query(int id, int l, int r) { return Query(id, r) - Query(id, l - 1); }\nlong long ans;\nvoid Get_ans() {\n  sort(q + 1, q + cq + 1, [&](const question &a, const question &b) {\n    return a.y - a.x > b.y - b.x;\n  });\n  for (int i = 1; i <= cq; ++i) {\n    auto [x, y, id] = q[i];\n    if (x <= y && x <= sk) ans += Query(id ^ 1, max(sk - y + 1, 1), sk - x);\n    Add(id, x);\n  }\n}\nvoid work() {\n  Get_d(n, a, 0);\n  Get_d(m, b, 1);\n  Get_ans();\n}\nvoid outo() { printf(\"%lld\\n\", ans); }\nint main() {\n  int T = 1;\n  for (; T--;) {\n    into();\n    work();\n    outo();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n  fenwick(int _n) : n(_n) { fenw.resize(n); }\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i] = min(a[i], x);\n  }\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    b[i] = min(b[i], x);\n  }\n  long long V = 0;\n  long long E = 0;\n  long long F = 0;\n  {\n    auto sa = a;\n    sort(sa.begin(), sa.end());\n    auto sb = b;\n    sort(sb.begin(), sb.end());\n    int j = m;\n    for (int i = 0; i < n; i++) {\n      while (j > 0 && sb[j - 1] + sa[i] > x) {\n        --j;\n      }\n      V += j;\n    }\n  }\n  {{vector<int> sa(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    sa[i] = max(a[i], a[i + 1]);\n  }\n  sort(sa.begin(), sa.end());\n  auto sb = b;\n  sort(sb.begin(), sb.end());\n  int j = m;\n  for (int i = 0; i < n - 1; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n{\n  auto sa = a;\n  sort(sa.begin(), sa.end());\n  vector<int> sb(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    sb[i] = max(b[i], b[i + 1]);\n  }\n  sort(sb.begin(), sb.end());\n  int j = m - 1;\n  for (int i = 0; i < n; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n}\n{\n  auto Make = [&](const vector<int>& v) {\n    int sz = (int)v.size();\n    vector<int> pr(sz), ne(sz);\n    for (int i = 0; i < sz; i++) {\n      pr[i] = i - 1;\n      ne[i] = i + 1;\n    }\n    vector<int> order(sz);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) { return v[i] > v[j]; });\n    SparseTable<int> st(v, [&](int i, int j) { return max(i, j); });\n    vector<tuple<int, int, int>> ret;\n    for (int i = 0; i < sz - 1; i++) {\n      ret.emplace_back(max(v[i], v[i + 1]), x, max(v[i], v[i + 1]));\n    }\n    for (int i : order) {\n      if (pr[i] >= 0 && ne[i] < sz) {\n        int v0 = max(v[pr[i]], v[ne[i]]);\n        int v1 = v[i];\n        int v2 = st.get(pr[i], ne[i]);\n        if (v0 < v1) {\n          ret.emplace_back(v0, v1, v2);\n        }\n      }\n      if (pr[i] != -1) {\n        ne[pr[i]] = ne[i];\n      }\n      if (ne[i] != sz) {\n        pr[ne[i]] = pr[i];\n      }\n    }\n    return ret;\n  };\n  vector<tuple<int, int, int>> r = Make(a);\n  vector<tuple<int, int, int>> c = Make(b);\n  42;\n  42;\n  vector<vector<pair<int, int>>> qs(x + 1);\n  for (auto& q : c) {\n    qs[x - get<2>(q)].emplace_back(x - get<1>(q) + 1, x - get<0>(q));\n  }\n  vector<vector<int>> ev(x + 1);\n  for (auto& p : r) {\n    ev[get<0>(p)].push_back(get<2>(p));\n    ev[get<1>(p)].push_back(~get<2>(p));\n  }\n  fenwick<int> fenw(x + 1);\n  for (int i = 1; i <= x; i++) {\n    for (int e : ev[i]) {\n      if (e >= 0) {\n        fenw.modify(e, +1);\n      } else {\n        fenw.modify(~e, -1);\n      }\n    }\n    for (auto& q : qs[i]) {\n      F += fenw.get(q.second) - fenw.get(q.first - 1);\n    }\n  }\n}\ncout << V - E + F << '\\n';\nreturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, m, x, a[N], b[N], c[N], d[N];\nint stk[N], top, st[20][N], lg[N];\ninline int getmx(int l, int r) {\n  if (l > r) return 0x3f3f3f3f;\n  int len = lg[r - l + 1];\n  return max(st[len][l], st[len][r - (1 << len) + 1]);\n}\ninline void init(int n, int *a, int *c) {\n  for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= n; ++i) st[0][i] = a[i];\n  for (int j = 1; (1 << j) <= n; ++j)\n    for (int i = 1; i + (1 << j) - 1 <= n; ++i)\n      st[j][i] = max(st[j - 1][i], st[j - 1][i + (1 << j - 1)]);\n  top = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (top && a[stk[top]] >= a[i]) --top;\n    c[i] = 0x3f3f3f3f;\n    if (top) c[i] = getmx(stk[top] + 1, i);\n    stk[++top] = i;\n  }\n  top = 0;\n  for (int i = n; i >= 1; --i) {\n    while (top && a[stk[top]] > a[i]) --top;\n    if (top) c[i] = min(c[i], getmx(i, stk[top] - 1));\n    stk[++top] = i;\n  }\n}\nstruct node {\n  int x, y, tp;\n} p[N << 1];\ninline bool cmp(const node &a, const node &b) { return a.y - a.x > b.y - b.x; }\nstruct BIT {\n  int c[N];\n  inline int lowbit(int x) { return x & (-x); }\n  inline void add(int a, int v) {\n    for (; a <= x; a += lowbit(a)) c[a] += v;\n  }\n  inline int query(int l, int r) {\n    if (l > r) return 0;\n    int ret = 0;\n    for (int i = r; i > 0; i -= lowbit(i)) ret += c[i];\n    for (int i = l - 1; i > 0; i -= lowbit(i)) ret -= c[i];\n    return ret;\n  }\n} A, B;\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &x);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", &b[i]);\n  init(n, a, c);\n  init(m, b, d);\n  int tot = 0;\n  for (int i = 1; i <= n; ++i) p[++tot] = (node){a[i], c[i], 0};\n  for (int i = 1; i <= m; ++i) p[++tot] = (node){b[i], d[i], 1};\n  sort(p + 1, p + tot + 1, cmp);\n  long long ans = 0;\n  for (int i = 1; i <= tot; ++i) {\n    int a = p[i].x, c = p[i].y;\n    if (p[i].tp == 0)\n      ans += B.query(x - c + 1, x - a), A.add(a, 1);\n    else\n      ans += A.query(x - c + 1, x - a), B.add(a, 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int N = 2e5 + 10;\ntemplate <typename T>\nstruct Fenwick {\n  int n;\n  std::vector<T> a;\n  Fenwick(int n) : n(n), a(n) {}\n  void add(int x, T v) {\n    for (int i = x + 1; i <= n; i += i & -i) {\n      a[i - 1] += v;\n    }\n  }\n  T sum(int x) {\n    T ans = 0;\n    for (int i = x; i > 0; i -= i & -i) {\n      ans += a[i - 1];\n    }\n    return ans;\n  }\n  T rangeSum(int l, int r) { return sum(r) - sum(l); }\n};\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  int n, m, x;\n  std::cin >> n >> m >> x;\n  x++;\n  std::vector<int> a(n), b(m);\n  for (int i = 0; i < n; i++) {\n    std::cin >> a[i];\n  }\n  for (int i = 0; i < m; i++) {\n    std::cin >> b[i];\n  }\n  i64 ans = 0;\n  std::vector<int> c(n, x + 1), d(m, x + 1);\n  std::vector<int> s, v;\n  for (int i = 0; i < n; i++) {\n    int u = 0;\n    while (!s.empty() && a[i] < a[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, a[i]);\n    if (!s.empty()) {\n      c[i] = std::min(c[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = n - 1; i >= 0; i--) {\n    int u = 0;\n    while (!s.empty() && a[i] <= a[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, a[i]);\n    if (!s.empty()) {\n      c[i] = std::min(c[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = 0; i < m; i++) {\n    int u = 0;\n    while (!s.empty() && b[i] < b[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, b[i]);\n    if (!s.empty()) {\n      d[i] = std::min(d[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = m - 1; i >= 0; i--) {\n    int u = 0;\n    while (!s.empty() && b[i] <= b[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, b[i]);\n    if (!s.empty()) {\n      d[i] = std::min(d[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  Fenwick<int> fen(N);\n  std::vector<int> p(n), q(m);\n  std::iota(p.begin(), p.end(), 0);\n  std::iota(q.begin(), q.end(), 0);\n  std::sort(p.begin(), p.end(), [&](int i, int j) { return a[i] < a[j]; });\n  std::sort(q.begin(), q.end(), [&](int i, int j) { return d[i] > d[j]; });\n  for (int i = 0, j = 0; i < n; i++) {\n    while (j < m && a[p[i]] + d[q[j]] >= x) {\n      fen.add(b[q[j]], 1);\n      j++;\n    }\n    ans += fen.rangeSum(std::max(0, x - c[p[i]]), std::max(0, x - a[p[i]]));\n  }\n  std::cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nstruct BIT {\n  vector<T> a;\n  int n;\n  BIT() {}\n  BIT(int _n) {\n    n = _n + 1;\n    a.resize(n + 1);\n  }\n  void init(int _n) {\n    n = _n + 1;\n    a.resize(n + 1);\n  }\n  void add(int x, T v) {\n    ++x;\n    for (; x <= n; x += x & -x) a[x] += v;\n  }\n  T sum(int x) {\n    ++x;\n    x = min(x, n);\n    T ret = 0;\n    for (; x; x -= x & -x) ret += a[x];\n    return ret;\n  }\n};\nstruct node {\n  int a, b, t;\n  bool operator<(const node &n) const {\n    return a < n.a || (a == n.a && t < n.t);\n  }\n};\nint main() {\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n), b(m);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  for (int i = 0; i < m; ++i) cin >> b[i];\n  for (auto &i : a) i = min(i, x);\n  for (auto &i : b) i = min(i, x);\n  auto calc = [](vector<int> a) {\n    int n = a.size();\n    vector<int> b(n, -1), c(n, -1);\n    vector<int> stk(n);\n    int tp = 0;\n    for (int i = 0; i < n; ++i) {\n      int mx = -1;\n      while (tp && a[stk[tp - 1]] > a[i]) {\n        mx = max(mx, a[stk[tp - 1]]);\n        mx = max(mx, b[stk[tp - 1]]);\n        --tp;\n      }\n      if (tp)\n        b[i] = mx;\n      else\n        b[i] = 1e9;\n      stk[tp++] = i;\n    }\n    tp = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      int mx = -1;\n      while (tp && a[stk[tp - 1]] >= a[i]) {\n        mx = max(mx, a[stk[tp - 1]]);\n        mx = max(mx, c[stk[tp - 1]]);\n        --tp;\n      }\n      if (tp)\n        c[i] = mx;\n      else\n        c[i] = 1e9;\n      stk[tp++] = i;\n    }\n    for (int i = 0; i < n; ++i) b[i] = min(b[i], c[i]);\n    return b;\n  };\n  vector<int> c = calc(a), d = calc(b);\n  vector<node> vec;\n  for (int i = 0; i < n; ++i) {\n    if (c[i] > a[i]) vec.push_back({a[i], c[i], 0});\n  }\n  for (int i = 0; i < m; ++i) {\n    if (d[i] > b[i]) vec.push_back({x - d[i], x - b[i], 1});\n  }\n  long long ans = 0;\n  sort(vec.begin(), vec.end());\n  BIT<int> bit(200005);\n  for (auto &p : vec) {\n    if (p.t == 0) {\n      ans += bit.sum(p.b - 1) - bit.sum(p.a - 1);\n    } else {\n      bit.add(p.b, 1);\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nconst int maxn = 2e5 + 10;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, x, wa, wb, mxa[maxn], mxb[maxn], a[maxn], b[maxn], tr[maxn];\nstack<int> st;\nint mx[maxn];\ninline void add(int x, int y) {\n  for (int i = x; i <= N; i += i & (-i)) tr[i] += y;\n}\ninline int query(int x) {\n  int res = 0;\n  for (int i = x; i >= 1; i -= i & (-i)) res += tr[i];\n  return res;\n}\ninline void work(int *A, int *MXA, int len, int tag) {\n  memset(mx, 0, sizeof(mx));\n  while (!st.empty()) st.pop();\n  for (int i = 1; i <= len; i++) {\n    while (!st.empty() && A[st.top()] >= A[i] + 1 - tag)\n      mx[i] = max(mx[i], mx[st.top()]), st.pop();\n    st.push(i);\n    mx[i] = max(mx[i], A[i]);\n    if (tag)\n      MXA[i] = (st.size() > 1 ? mx[i] : x);\n    else if (st.size() > 1)\n      MXA[len - i + 1] = min(MXA[len - i + 1], mx[i]);\n  }\n}\nvector<int> I[maxn], D[maxn];\nvector<pair<int, int> > p[maxn];\nint main() {\n  n = read(), m = read(), x = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), wa = max(wa, a[i]);\n  for (int i = 1; i <= m; i++) b[i] = read(), wb = max(wb, b[i]);\n  work(a, mxa, n, 1);\n  reverse(a + 1, a + 1 + n);\n  work(a, mxa, n, 0);\n  reverse(a + 1, a + 1 + n);\n  work(b, mxb, m, 1);\n  reverse(b + 1, b + 1 + m);\n  work(b, mxb, m, 0);\n  reverse(b + 1, b + 1 + m);\n  for (int i = 1; i <= m; i++) {\n    if (b[i] >= x) continue;\n    p[b[i]].push_back(make_pair(x - mxb[i], x - b[i]));\n  }\n  for (int i = 1; i <= n; i++) {\n    int u = max(x - mxa[i] + 1, 1), v = x - a[i];\n    if (a[i] >= x || u > v) continue;\n    I[u].push_back(a[i]), D[v].push_back(a[i]);\n  }\n  long long res = 0;\n  for (int i = 1; i <= wb; i++) {\n    for (int j = 0; j < I[i].size(); j++) add(I[i][j], 1);\n    for (int j = 0; j < p[i].size(); j++)\n      res += query(p[i][j].second) - query(p[i][j].first);\n    for (int j = 0; j < D[i].size(); j++) add(D[i][j], -1);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint as[200005];\nint bs[200005];\nint N, M;\nint stk[200005];\nint stk_size = 0;\nstd::vector<int> queries[400005];\nvoid query(int low, int high) { queries[high].push_back(low); }\nvoid append(int x) {\n  int& l = stk_size;\n  stk[l++] = x;\n  while (true) {\n    if ((l >= 3 && stk[l - 3] <= stk[l - 2] && stk[l - 2] <= stk[l - 1]) ||\n        (l >= 3 && stk[l - 3] >= stk[l - 2] && stk[l - 2] >= stk[l - 1])) {\n      stk[l - 2] = stk[l - 1];\n      l--;\n    } else if (l >= 4 && stk[l - 4] <= stk[l - 2] && stk[l - 2] <= stk[l - 3] &&\n               stk[l - 3] <= stk[l - 1]) {\n      query(stk[l - 2], stk[l - 3]);\n      stk[l - 3] = stk[l - 1];\n      l -= 2;\n    } else if (l >= 4 && stk[l - 4] >= stk[l - 2] && stk[l - 2] >= stk[l - 3] &&\n               stk[l - 3] >= stk[l - 1]) {\n      query(stk[l - 3], stk[l - 2]);\n      stk[l - 3] = stk[l - 1];\n      l -= 2;\n    } else {\n      break;\n    }\n  }\n}\nint ft[400005];\nvoid ft_update(int i, int v) {\n  for (i++; i > 0; i -= (i & -i)) {\n    ft[i] += v;\n  }\n}\nint ft_query(int i) {\n  int res = 0;\n  for (i++; i <= 400001; i += (i & -i)) {\n    res += ft[i];\n  }\n  return res;\n}\nint uf[200005];\nint find(int a) { return (a == uf[a]) ? a : (uf[a] = find(uf[a])); }\nvoid merge(int x, int y) {\n  if (bs[x] > bs[y]) std::swap(x, y);\n  uf[x] = y;\n  ft_update(N + M - bs[x], -1);\n}\nint main() {\n  int X;\n  scanf(\"%d %d %d\", &N, &M, &X);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &as[i]);\n  }\n  for (int i = 0; i < M; i++) {\n    scanf(\"%d\", &bs[i]);\n  }\n  {\n    std::vector<int> asort(as, as + N);\n    std::vector<int> bsort(bs, bs + M);\n    std::vector<int> acps = asort, bcps = bsort;\n    std::sort(asort.begin(), asort.end());\n    std::sort(bsort.begin(), bsort.end());\n    int i = 0, j = M - 1;\n    for (int shift = N + M; shift > 0; shift--) {\n      if (i == N || (j >= 0 && asort[i] + bsort[j] > X)) {\n        bcps[j--] = N + M - shift;\n      } else {\n        acps[i++] = shift;\n      }\n    }\n    assert(i == N && j == -1);\n    for (int i = 0; i < N; i++) {\n      as[i] = acps[std::lower_bound(asort.begin(), asort.end(), as[i]) -\n                   asort.begin()];\n    }\n    for (int i = 0; i < M; i++) {\n      bs[i] = bcps[std::lower_bound(bsort.begin(), bsort.end(), bs[i]) -\n                   bsort.begin()];\n    }\n  }\n  append(0);\n  for (int i = 0; i < N; i++) {\n    append(as[i]);\n  }\n  append(0);\n  assert(stk_size == 3);\n  queries[stk[1]].push_back(0);\n  std::vector<std::vector<int> > where(N + M + 1);\n  for (int i = 0; i < M; i++) {\n    where[bs[i]].push_back(i);\n  }\n  for (int i = 0; i < M; i++) {\n    uf[i] = i;\n  }\n  long long ans = 0;\n  for (int a = 0; a <= N + M; a++) {\n    for (int i : where[N + M - a]) {\n      ft_update(a, 1);\n      if (i > 0 && bs[i - 1] >= bs[i]) {\n        merge(find(i - 1), find(i));\n      }\n      if (i < M - 1 && bs[i + 1] > bs[i]) {\n        merge(find(i), find(i + 1));\n      }\n    }\n    for (int q : queries[a]) {\n      ans += ft_query(q);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, V = 2e5;\nint n, m, x;\nint a[N], b[N];\nint stk[N], top = 0;\nint lson[N], rson[N], mxa[N], mxb[N], mna[N], mnb[N];\nint t[N];\nvector<int> q[N], g[N];\nvoid add(int x, int v) {\n  for (int i = x; i <= V; i += i & (-i)) t[i] += v;\n  return;\n}\nint sum(int x) {\n  x = min(x, V);\n  int res = 0;\n  for (int i = x; i > 0; i -= i & (-i)) res += t[i];\n  return res;\n}\nvoid dfs(int x, int mx[], int a[]) {\n  if (x == -1) return;\n  mx[x] = a[x];\n  dfs(lson[x], mx, a), dfs(rson[x], mx, a);\n  mx[x] = max(mx[x], mx[lson[x]]);\n  mx[x] = max(mx[x], mx[rson[x]]);\n  return;\n}\nint main() {\n  cin >> n >> m >> x;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  a[0] = a[n + 1] = V + 1;\n  for (int i = 0; i <= n + 1; i++) {\n    lson[i] = rson[i] = -1;\n    while (top && a[stk[top]] > a[i]) {\n      rson[stk[top]] = lson[i];\n      lson[i] = stk[top];\n      top--;\n    }\n    stk[++top] = i;\n  }\n  while (top > 1) rson[stk[top - 1]] = stk[top], top--;\n  dfs(stk[1], mxa, a);\n  for (int i = 1; i <= n; i++) {\n    mna[i] = a[i];\n    mna[i] = max(mna[i], min(mxa[lson[i]], mxa[rson[i]]));\n  }\n  top = 0;\n  b[0] = b[m + 1] = V + 1;\n  for (int i = 1; i <= m; i++) {\n    cin >> b[i];\n  }\n  for (int i = 0; i <= m + 1; i++) {\n    lson[i] = rson[i] = -1;\n    while (top && b[stk[top]] > b[i]) {\n      rson[stk[top]] = lson[i];\n      lson[i] = stk[top];\n      top--;\n    }\n    stk[++top] = i;\n  }\n  while (top > 1) rson[stk[top - 1]] = stk[top], top--;\n  dfs(stk[1], mxb, b);\n  for (int i = 1; i <= m; i++) {\n    mnb[i] = b[i];\n    mnb[i] = max(mnb[i], min(mxb[lson[i]], mxb[rson[i]]));\n  }\n  for (int i = 1; i <= m; i++) {\n    int l = max(1, x - mnb[i] + 1), r = min(V, x - b[i]) + 1;\n    if (l < r) {\n      q[l].push_back(i), q[r].push_back(-i);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    g[a[i]].push_back(i);\n  }\n  long long ans = 0;\n  for (int i = 1; i <= V; i++) {\n    for (int &v : q[i]) {\n      if (v > 0) {\n        add(b[v], 1);\n      } else {\n        add(b[-v], -1);\n      }\n    }\n    for (int &v : g[i]) {\n      ans += sum(V) - sum(x - mna[v]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m, x, a[200010], b[200010], ord[200010];\nint st1[200010][21], st2[200010][21], Log[200010];\nint cmp1(int l, int r) { return a[l] < a[r] ? l : r; }\nint cmp2(int l, int r) { return a[l] > a[r] ? l : r; }\nint cmp4(int l, int r) { return b[l] > b[r] ? l : r; }\nbool cmp3(int l, int r) { return b[l] > b[r]; }\nint query1(int l, int r) {\n  int k = Log[r - l + 1];\n  return cmp1(st1[l][k], st1[r - (1 << k) + 1][k]);\n}\nint query2(int l, int r) {\n  int k = Log[r - l + 1];\n  return cmp2(st2[l][k], st2[r - (1 << k) + 1][k]);\n}\nint query4(int l, int r) {\n  if (l > r) return 0;\n  int k = Log[r - l + 1];\n  return cmp4(st2[l][k], st2[r - (1 << k) + 1][k]);\n}\nstd::vector<std::pair<int, int> > que[200100];\nlong long ans;\nvoid addquery(int l, int r, int v) {\n  if (l > r || r <= 0) return;\n  l = std::max(l, 1);\n  r = std::min(r, 200000);\n  que[l].push_back(std::make_pair(v, 1));\n  que[r + 1].push_back(std::make_pair(v, -1));\n}\nvoid solve(int l, int r) {\n  if (l > r) return;\n  int o = 0x7f7f7f7f;\n  if (l > 1) o = std::min(o, a[l - 1]);\n  if (r < n) o = std::min(o, a[r + 1]);\n  int mid = query2(l, r), mn = query1(l, r);\n  solve(l, mid - 1);\n  solve(mid + 1, r);\n  addquery(x - o + 1, x - a[mid], x - a[mn]);\n}\nint num[200010], c[200100];\nvoid update(int ind, int num) {\n  for (; ind; ind -= ind & -ind) c[ind] += num;\n}\nint query(int ind) {\n  ind = std::max(ind, 0);\n  ++ind;\n  int tot = 0;\n  for (; ind <= 200010; ind += ind & -ind) tot += c[ind];\n  return tot;\n}\nint B[200010];\nint stk[200010], top;\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &x);\n  for (int i = 2; i <= n || i <= m; ++i) Log[i] = Log[i >> 1] + 1;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  for (int j = 1; j <= m; ++j) scanf(\"%d\", b + j);\n  for (int i = 1; i <= n; ++i) st1[i][0] = i, st2[i][0] = i;\n  for (int j = 1; (1 << j) <= n; ++j)\n    for (int i = 1; i + (1 << j) - 1 <= n; ++i)\n      st1[i][j] = cmp1(st1[i][j - 1], st1[i + (1 << (j - 1))][j - 1]);\n  for (int j = 1; (1 << j) <= n; ++j)\n    for (int i = 1; i + (1 << j) - 1 <= n; ++i)\n      st2[i][j] = cmp2(st2[i][j - 1], st2[i + (1 << (j - 1))][j - 1]);\n  solve(1, n);\n  for (int i = 1; i <= m; ++i) num[i] = i;\n  std::sort(num + 1, num + m + 1, cmp3);\n  for (int i = 1; i <= m; ++i) ord[num[i]] = i;\n  for (int i = 1; i <= m; ++i) st2[i][0] = i;\n  for (int j = 1; (1 << j) <= m; ++j)\n    for (int i = 1; i + (1 << j) - 1 <= m; ++i)\n      st2[i][j] = cmp4(st2[i][j - 1], st2[i + (1 << (j - 1))][j - 1]);\n  for (int i = 1; i <= m; ++i) B[i] = 200010;\n  for (int i = 1; i <= m; ++i) {\n    while (top && b[stk[top]] >= b[i]) --top;\n    if (top) {\n      B[i] = std::min(B[i], b[query4(stk[top] + 1, i - 1)]);\n    }\n    stk[++top] = i;\n  }\n  top = 0;\n  for (int i = m; i; --i) {\n    while (top && b[stk[top]] > b[i]) --top;\n    if (top) {\n      B[i] = std::min(B[i], b[query4(i + 1, stk[top] - 1)]);\n    }\n    stk[++top] = i;\n  }\n  for (int i = 200000, now = 1; i; --i) {\n    while (now <= m && b[num[now]] == i) {\n      int u = num[now];\n      update(B[u], 1);\n      ++now;\n    }\n    for (int j = 0; j < que[i].size(); ++j) {\n      ans += que[i][j].second * query(que[i][j].first);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int N = 2e5 + 10;\ntemplate <typename T>\nstruct Fenwick {\n  int n;\n  std::vector<T> a;\n  Fenwick(int n) : n(n), a(n) {}\n  void add(int x, T v) {\n    for (int i = x + 1; i <= n; i += i & -i) {\n      a[i - 1] += v;\n    }\n  }\n  T sum(int x) {\n    T ans = 0;\n    for (int i = x; i > 0; i -= i & -i) {\n      ans += a[i - 1];\n    }\n    return ans;\n  }\n  T rangeSum(int l, int r) { return sum(r) - sum(l); }\n};\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  int n, m, x;\n  std::cin >> n >> m >> x;\n  x++;\n  std::vector<int> a(n), b(m);\n  for (int i = 0; i < n; i++) {\n    std::cin >> a[i];\n  }\n  for (int i = 0; i < m; i++) {\n    std::cin >> b[i];\n  }\n  i64 ans = 0;\n  std::vector<int> c(n, x + 1), d(m, x + 1);\n  std::vector<int> s, v;\n  for (int i = 0; i < n; i++) {\n    int u = 0;\n    while (!s.empty() && a[i] < a[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, a[i]);\n    if (!s.empty()) {\n      c[i] = std::min(c[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = n - 1; i >= 0; i--) {\n    int u = 0;\n    while (!s.empty() && a[i] <= a[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, a[i]);\n    if (!s.empty()) {\n      c[i] = std::min(c[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = 0; i < m; i++) {\n    int u = 0;\n    while (!s.empty() && b[i] < b[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, b[i]);\n    if (!s.empty()) {\n      d[i] = std::min(d[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  s = v = {};\n  for (int i = m - 1; i >= 0; i--) {\n    int u = 0;\n    while (!s.empty() && b[i] <= b[s.back()]) {\n      u = std::max(u, v.back());\n      s.pop_back();\n      v.pop_back();\n    }\n    u = std::max(u, b[i]);\n    if (!s.empty()) {\n      d[i] = std::min(d[i], u);\n    }\n    s.push_back(i);\n    v.push_back(u);\n  }\n  Fenwick<int> fen(N);\n  std::vector<int> p(n), q(m);\n  std::iota(p.begin(), p.end(), 0);\n  std::iota(q.begin(), q.end(), 0);\n  std::sort(p.begin(), p.end(), [&](int i, int j) { return a[i] < a[j]; });\n  std::sort(q.begin(), q.end(), [&](int i, int j) { return d[i] > d[j]; });\n  for (int i = 0, j = 0; i < n; i++) {\n    while (j < m && a[p[i]] + d[q[j]] >= x) {\n      fen.add(b[q[j]], 1);\n      j++;\n    }\n    ans += fen.rangeSum(std::max(0, x - c[p[i]]), std::max(0, x - a[p[i]]));\n  }\n  std::cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fenwick_tree {\n  int n;\n  vector<int> f;\n  fenwick_tree(int n = 0) : n(n), f(n + 1) {}\n  fenwick_tree(vector<int> &a) : fenwick_tree(a.size()) {\n    for (int i = 0; i < n; i++) changeValue(i, a[i]);\n  }\n  void changeValue(int i, int d) {\n    for (i++; i <= n; i += i & -i) f[i] += d;\n  }\n  int getSum(int i) {\n    int s = 0;\n    for (i++; i; i -= i & -i) s += f[i];\n    return s;\n  }\n  int getSum(int l, int r) { return getSum(r - 1) - getSum(l - 1); }\n};\nstruct sparse_table {\n  int n;\n  vector<int> a;\n  vector<vector<int>> st;\n  int combine(int dl, int dr) {\n    return a[dl] < a[dr] || a[dl] == a[dr] && dl < dr ? dl : dr;\n  }\n  sparse_table() {}\n  sparse_table(vector<int> &a)\n      : n(a.size()), a(a), st((31 - __builtin_clz(n)) + 1, vector<int>(n)) {\n    for (int i = 0; i < n; i++) st[0][i] = i;\n    for (int j = 1; 1 << j <= n; j++)\n      for (int i = 0; i + (1 << j) <= n; i++)\n        st[j][i] = combine(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);\n  }\n  int query(int l, int r) {\n    int s = (31 - __builtin_clz(r - l));\n    return combine(st[s][l], st[s][r - (1 << s)]);\n  }\n};\nint n, m, x, a[200100], ia[200100], b[200100], ib[200100];\nbool ua[200100], ub[200100];\nint ar[200100], ra[200100], ru[200100], rl[200100], bta[200100];\nfenwick_tree ft(200100);\nvoid merge(int i, int j) {\n  ft.changeValue(max(ra[i], ra[j]), -1);\n  ra[i] = min(ra[i], ra[j]);\n  ar[ru[j]] = i;\n  ar[rl[j]] = i;\n  ru[i] = max(ru[i], ru[j]);\n  rl[i] = min(rl[i], rl[j]);\n}\nvoid create(int i) {\n  ft.changeValue(a[i], 1);\n  ar[i] = i, ra[i] = a[i];\n  ru[i] = rl[i] = i;\n  ua[i] = true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n >> m >> x;\n  for (int i = 0; i < n; i++) cin >> a[i], ia[i] = i;\n  a[n] = x + 1;\n  ia[n] = n;\n  n++;\n  sort(ia, ia + n, [&](int i, int j) { return a[i] < a[j]; });\n  vector<int> bs;\n  for (int i = 0; i < m; i++) cin >> b[i], ib[i] = i, bs.push_back(b[i]);\n  sort(ib, ib + m, [&](int i, int j) { return b[i] > b[j]; });\n  sparse_table st(bs);\n  set<pair<int, int>> brs;\n  brs.emplace(0, m);\n  bta[st.query(0, m)] = a[ia[0]];\n  for (int ca = 0, cb = 0; ca < n; ca++) {\n    int i = ia[ca];\n    while (cb < m && a[i] + b[ib[cb]] > x) {\n      int j = ib[cb];\n      auto it = --brs.lower_bound({j + 1, j + 1});\n      int l = it->first, r = it->second;\n      brs.erase(it);\n      int cbi = st.query(l, r);\n      if (l < j) {\n        int obi = st.query(l, j);\n        brs.emplace(l, j);\n        if (obi != cbi) bta[obi] = a[i];\n      }\n      if (j + 1 < r) {\n        int obi = st.query(j + 1, r);\n        brs.emplace(j + 1, r);\n        if (obi != cbi) bta[obi] = a[i];\n      }\n      cb++;\n    }\n  }\n  long long res = 0;\n  for (int ca = 0, cb = 0; ca < n; ca++) {\n    int i = ia[ca];\n    while (cb < m && a[i] + b[ib[cb]] > x) {\n      int j = ib[cb];\n      if (bta[j]) res += ft.getSum(bta[j], x + 1);\n      cb++;\n    }\n    create(i);\n    if (i > 0 && ua[i - 1]) merge(ar[i - 1], ar[i]);\n    if (i < n - 1 && ua[i + 1]) merge(ar[i], ar[i + 1]);\n  }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans;\nint n, m, i, j, lg[200005], lim, al[200005], ar[200005];\nint a[200005], b[200005];\nint f[200005][19], g[200005][19];\nint fmi(int x, int y) { return a[x] > a[y] ? x : y; }\nint gmi(int x, int y) { return b[x] < b[y] ? x : y; }\nint qryf(int l, int r) {\n  int t = lg[r - l + 1];\n  return fmi(f[l][t], f[r - (1 << t) + 1][t]);\n}\nint qryg(int l, int r) {\n  int t = lg[r - l + 1];\n  return gmi(g[l][t], g[r - (1 << t) + 1][t]);\n}\npriority_queue<pair<int, int> > pq;\nint ord[200005];\nset<pair<int, int> > s;\nvector<int> all;\nint c[200005];\nbool cmp(int x, int y) {\n  if (a[x] == a[y]) return x > y;\n  return a[x] < a[y];\n}\nvoid add(int x, int y) {\n  while (x <= m) {\n    c[x] += y;\n    x += (x & -x);\n  }\n}\nint query(int x) {\n  int s = 0;\n  while (x) {\n    s += c[x];\n    x -= (x & -x);\n  }\n  return s;\n}\nvoid add_rng(int l, int r, int y) {\n  int x = qryg(l, r);\n  add(upper_bound(all.begin(), all.end(), b[x]) - all.begin(), y);\n}\nvoid del(int x) {\n  set<pair<int, int> >::iterator it = s.upper_bound(make_pair(x, 123456789));\n  it--;\n  int l = it->first, r = it->second;\n  s.erase(it);\n  add_rng(l, r, -1);\n  if (l < x) {\n    s.insert(make_pair(l, x - 1));\n    add_rng(l, x - 1, 1);\n  }\n  if (x < r) {\n    s.insert(make_pair(x + 1, r));\n    add_rng(x + 1, r, 1);\n  }\n}\nint solve(int x) {\n  return query(upper_bound(all.begin(), all.end(), x) - all.begin());\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &lim);\n  for (i = 2; i <= 200002; i++) lg[i] = lg[i / 2] + 1;\n  for (i = 1; i <= (n); i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= (m); i++) scanf(\"%d\", &b[i]);\n  for (i = 1; i <= (m); i++) all.push_back(b[i]);\n  sort(all.begin(), all.end());\n  all.resize(unique(all.begin(), all.end()) - all.begin());\n  for (i = 1; i <= (n); i++) f[i][0] = i;\n  for (i = 1; i <= (m); i++) g[i][0] = i;\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (n - (1 << j) + 1); i++)\n      f[i][j] = fmi(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n  for (j = 1; j <= (18); j++)\n    for (i = 1; i <= (m - (1 << j) + 1); i++)\n      g[i][j] = gmi(g[i][j - 1], g[i + (1 << (j - 1))][j - 1]);\n  for (i = 1; i <= (m); i++) {\n    pq.push(make_pair(b[i], i));\n  }\n  for (i = 1; i <= (n); i++) ord[i] = i;\n  sort(ord + 1, ord + n + 1, cmp);\n  vector<int> stk;\n  for (i = 1; i <= (n); i++) {\n    while (!stk.empty() && a[stk.back()] >= a[i]) {\n      ar[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  for (i = n; i >= 1; i--) {\n    while (!stk.empty() && a[stk.back()] > a[i]) {\n      al[stk.back()] = i;\n      stk.pop_back();\n    }\n    stk.push_back(i);\n  }\n  stk.clear();\n  s.insert(make_pair(1, m));\n  add_rng(1, m, 1);\n  for (i = 1; i <= (n); i++) {\n    int x = ord[i];\n    while (!pq.empty() && pq.top().first + a[x] > lim) {\n      del(pq.top().second);\n      pq.pop();\n    }\n    int limr = lim - a[x];\n    int liml = 0;\n    if (al[x]) {\n      int t = qryf(al[x], x);\n      liml = max(liml, lim - a[t]);\n    }\n    if (ar[x]) {\n      int t = qryf(x, ar[x]);\n      liml = max(liml, lim - a[t]);\n    }\n    if (liml <= limr) {\n      ans += solve(limr);\n      ans -= solve(liml);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int c = 200005, k = 20;\nint n, m, sum, f[c], t[c][2], ert[c][2], lg[c], po[k], maxi[c][k][2];\nlong long ans = 0;\nvector<int> sz;\nvector<pair<int, pair<int, int> > > p;\nint calc(int a, int b, int id) {\n  if (b < a) {\n    return c;\n  }\n  int s = lg[b - a + 1];\n  return sum + 1 - max(maxi[a][s][id], maxi[b + 1 - po[s]][s][id]);\n}\nvoid pb(int a, int b, int c) { p.push_back({a, {b, c}}); }\nint lsb(int a) { return (a & (-a)); }\nvoid add(int a, int b) {\n  while (a < c) {\n    f[a] += b;\n    a += lsb(a);\n  }\n}\nint ask(int a) {\n  int ans = 0;\n  while (a) {\n    ans += f[a];\n    a -= lsb(a);\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m >> sum;\n  t[0][0] = n, t[0][1] = m;\n  for (int i = 2; i < c; i++) {\n    lg[i] = lg[i / 2] + 1;\n  }\n  for (int i = 0; i < k; i++) {\n    po[i] = (1 << i);\n  }\n  for (int id = 0; id < 2; id++) {\n    int s = t[0][id];\n    for (int i = 1; i <= s; i++) {\n      cin >> t[i][id];\n      maxi[i][0][id] = t[i][id];\n    }\n    for (int j = 1; j < k; j++) {\n      for (int i = 1; i + po[j] <= s + 1; i++) {\n        maxi[i][j][id] =\n            max(maxi[i][j - 1][id], maxi[i + po[j - 1]][j - 1][id]);\n      }\n    }\n    for (int i = 1; i <= s; i++) {\n      ert[i][id] = 1;\n      while (sz.size() > 0 && t[i][id] < t[sz.back()][id]) {\n        sz.pop_back();\n      }\n      if (sz.size() > 0) {\n        ert[i][id] = max(ert[i][id], calc(sz.back() + 1, i - 1, id));\n      }\n      sz.push_back(i);\n    }\n    sz.clear();\n    for (int i = s; i >= 1; i--) {\n      while (sz.size() > 0 && t[i][id] <= t[sz.back()][id]) {\n        sz.pop_back();\n      }\n      if (sz.size() > 0) {\n        ert[i][id] = max(ert[i][id], calc(i + 1, sz.back() - 1, id));\n      }\n      sz.push_back(i);\n    }\n    sz.clear();\n    for (int i = 1; i <= s; i++) {\n      int a = sum - t[i][id], b = ert[i][id];\n      if (b <= a) {\n        if (id == 0) {\n          pb(b, 0, t[i][0]), pb(a + 1, 0, -t[i][0]);\n        } else {\n          pb(t[i][id], 1, i);\n        }\n      }\n    }\n  }\n  sort(p.begin(), p.end());\n  for (auto x : p) {\n    int val = x.first, q = x.second.first, id = x.second.second;\n    if (q == 0) {\n      add(abs(id), (id > 0 ? 1 : -1));\n    } else {\n      int a = sum - t[id][1], b = ert[id][1];\n      ans += ask(a) - ask(b - 1);\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 2e5 + 2;\nint n, m, x;\nint a[MAXN], b[MAXN];\nint l[MAXN], r[MAXN];\nint bit[MAXN];\nint rnk[MAXN];\nint ord[MAXN];\nbool vis[MAXN];\nvoid add(int pos, int val) {\n  while (pos < MAXN) {\n    bit[pos] += val;\n    pos += pos & -pos;\n  }\n}\nint query(int pos) {\n  int s = 0;\n  while (pos) {\n    s += bit[pos];\n    pos -= pos & -pos;\n  }\n  return s;\n}\nbool cmp(int A, int B) {\n  if (a[A] == a[B]) return A > B;\n  return a[A] > a[B];\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &x);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", &b[i]);\n  set<pair<int, int> > s;\n  for (int i = 1; i <= n; ++i) ord[i] = i;\n  sort(ord + 1, ord + 1 + n, cmp);\n  for (int i = 1; i <= n; ++i) rnk[ord[i]] = i;\n  vector<pair<int, int> > col;\n  for (int i = 1; i <= m; ++i) col.push_back(make_pair(b[i], i));\n  sort(col.begin(), col.end());\n  int pt = 0;\n  for (int i = 1; i <= m; ++i) l[i] = r[i] = n + 1;\n  for (int i_ = 1; i_ <= n; ++i_) {\n    int I = ord[i_];\n    while (pt < col.size() && col[pt].first + a[I] <= x) {\n      int i = col[pt++].second;\n      if (!vis[i - 1] && !vis[i + 1]) {\n        s.insert(make_pair(i, b[i]));\n        l[i] = i_;\n      } else if (vis[i - 1] && !vis[i + 1])\n        ;\n      else if (!vis[i - 1] && vis[i + 1])\n        ;\n      else if (vis[i - 1] && vis[i + 1]) {\n        auto ite = s.upper_bound(make_pair(i, 0));\n        auto pr = prev(ite);\n        pair<int, int> nd;\n        if (pr->second > ite->second)\n          nd = *ite, r[pr->first] = i_;\n        else\n          nd = *pr, r[ite->first] = i_;\n        s.erase(ite);\n        s.erase(pr);\n        s.insert(nd);\n      }\n      vis[i] = 1;\n    }\n  }\n  long long ans = 0;\n  reverse(col.begin(), col.end());\n  reverse(ord + 1, ord + 1 + n);\n  pt = 1;\n  s.clear();\n  memset(vis, 0, sizeof(vis));\n  for (auto it : col) {\n    int j = it.second;\n    while (pt <= n && a[ord[pt]] + it.first <= x) {\n      int i = ord[pt++];\n      if (!vis[i - 1] && !vis[i + 1]) {\n        s.insert(make_pair(i, a[i]));\n        add(rnk[i], 1);\n      }\n      if (vis[i - 1] && vis[i + 1]) {\n        auto ite = s.upper_bound(make_pair(i, 0));\n        auto pr = prev(ite);\n        if (pr->second > ite->second) {\n          add(rnk[pr->first], -1);\n          s.erase(pr);\n        } else {\n          add(rnk[ite->first], -1);\n          s.erase(ite);\n        }\n      }\n      vis[i] = 1;\n    }\n    if (r[j] > l[j]) {\n      ans += query(r[j] - 1) - query(l[j] - 1);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxn = 200005;\nint d[maxn];\nint lb(int x) { return x & -x; }\nvoid ins(int pl, int x) {\n  while (pl < maxn) {\n    d[pl] += x;\n    pl += lb(pl);\n  }\n}\nint q(int a) {\n  int ans = 0;\n  while (a) {\n    ans += d[a];\n    a -= lb(a);\n  }\n  return ans;\n}\nvector<int> u, v;\nstruct rg {\n  int p;\n  int l, r;\n  rg() {}\n};\nvector<pair<int, int> > act[maxn], ask[maxn];\nlong long wk(vector<rg> a, vector<rg> b) {\n  for (auto v : a) act[v.p].push_back(make_pair(v.l, v.r));\n  for (auto v : b) {\n    ask[v.l - 1].push_back(make_pair(v.p, -1));\n    ask[v.r].push_back(make_pair(v.p, 1));\n  }\n  long long ans = 0;\n  for (int i = 1; i < maxn; i++) {\n    for (auto v : act[i]) ins(v.first, 1), ins(v.second + 1, -1);\n    for (auto v : ask[i]) ans += q(v.first) * v.second;\n  }\n  return ans;\n}\nint mx[maxn][20];\nint mb[maxn];\nint qmx(int l, int r) {\n  int len = r - l + 1;\n  int j = mb[len];\n  return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nint st[maxn], top = 0;\nint n, m, x;\nvector<rg> gt(vector<int> a) {\n  int n = a.size();\n  vector<array<int, 3> > tot;\n  for (int i = 0; i < maxn; i++)\n    for (int j = 0; j < 20; j++)\n      if ((1 << j) <= i) mb[i] = j;\n  for (int i = 0; i < 20; i++)\n    for (int j = 0; j < n - (1 << i) + 1; j++) {\n      if (i == 0)\n        mx[j][i] = a[j];\n      else {\n        mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n      }\n    }\n  for (int s = 0; s < 2; s++) {\n    int top = 0;\n    for (int i = 0; i < n; i++) {\n      int cr = maxn;\n      while (top && a[st[top - 1]] > a[i]) chkmin(cr, a[st[top - 1]]), top -= 1;\n      if (top) {\n        int fl = 1;\n        if (s == 1 && a[st[top - 1]] == a[i]) fl = 0;\n        if (fl) {\n          if (s == 0)\n            tot.push_back((array<int, 3>){st[top - 1], i, cr});\n          else\n            tot.push_back((array<int, 3>){n - 1 - i, n - 1 - st[top - 1], cr});\n        }\n      }\n      st[top++] = i;\n    }\n    reverse(a.begin(), a.end());\n  }\n  vector<rg> res;\n  for (auto v : tot) {\n    int l = v[0], r = v[1], sc = v[2];\n    rg fn;\n    fn.l = max(1, x + 1 - sc);\n    fn.r = min(maxn - 1, x - max(a[l], a[r]));\n    fn.p = qmx(l, r);\n    if (fn.l > fn.r) continue;\n    res.push_back(fn);\n  }\n  return res;\n}\nint fl[maxn];\nint sum = 0, s1 = 0;\nvoid inc(int x) {\n  fl[x] = 1;\n  if (fl[x - 1]) s1 += 1;\n  if (fl[x + 1]) s1 += 1;\n  sum += 1;\n}\nint main() {\n  cin >> n >> m >> x;\n  vector<int> u[2];\n  vector<pair<int, int> > s[2];\n  u[0].resize(n), u[1].resize(m);\n  for (int t = 0; t < 2; t++) {\n    for (int i = 0; i < u[t].size(); i++) {\n      scanf(\"%d\", &u[t][i]);\n      s[t].push_back(make_pair(u[t][i], i + 1));\n    }\n    sort(s[t].begin(), s[t].end());\n  }\n  long long ans = wk(gt(u[0]), gt(u[1]));\n  int pl = 0;\n  for (int g = 0; g < 2; g++) {\n    sum = s1 = 0;\n    memset(fl, 0, sizeof(fl));\n    int p = 0;\n    for (int i = s[0].size() - 1; i >= 0; i--) {\n      while (p < s[1].size() && s[1][p].first + s[0][i].first <= x) {\n        inc(s[1][p].second);\n        p += 1;\n      }\n      ans -= s1;\n      if (g == 0) ans += sum;\n    }\n    swap(s[0], s[1]);\n  }\n  cout << ans << endl;\n  return (0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005, K = 20, INF = 0X3F3F3F3F;\nint n, m, x, a[N], b[N], lg[N];\nlong long ans;\nstruct ST {\n  int *a, n, f[N][K], op;\n  int max_(int k1, int k2) {\n    if (op == 0) {\n      return a[k1] < a[k2] ? k1 : k2;\n    } else {\n      return a[k1] < a[k2] ? k2 : k1;\n    }\n  }\n  void init(int *a_, int n_, int op_) {\n    a = a_, n = n_, op = op_;\n    for (int i = (1); i <= (n); ++i) f[i][0] = i;\n    for (int j = (1); j <= (K - 1); ++j) {\n      for (int i = (1); i <= (n - (1 << j) + 1); ++i) {\n        f[i][j] = max_(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n  int askp(int l, int r) {\n    int x = lg[r - l + 1];\n    return max_(f[l][x], f[r - (1 << x) + 1][x]);\n  }\n  int askv(int l, int r) { return a[askp(l, r)]; }\n} st1, st2;\nstruct node {\n  int l, r, w;\n  node(int l, int r) : l(l), r(r), w(st1.askv(l, r)) {}\n  bool operator<(const node &k) const { return w > k.w; }\n};\nvector<node> rgs;\nvoid bud(int l, int r) {\n  if (l > r) return;\n  rgs.emplace_back(l, r);\n  int mid = st2.askp(l, r);\n  bud(l, mid - 1);\n  bud(mid + 1, r);\n}\nint id[N];\nbool vis[N];\nstruct ufs {\n  int fa[N], val[N];\n  int fd(int k1) { return fa[k1] == k1 ? k1 : fa[k1] = fd(fa[k1]); }\n  void mer(int k1, int k2) {\n    val[k1] = min(val[k1], val[k2]);\n    fa[k2] = k1;\n  }\n} o;\nstruct BIT {\n  int t[N];\n  void upd(int k1, int k2) {\n    for (int i = k1; i < N; i += i & -i) t[i] += k2;\n  }\n  int qry(int k1) {\n    int k2 = 0;\n    for (int i = k1; i; i &= i - 1) k2 += t[i];\n    return k2;\n  }\n} t;\nint main() {\n  for (int i = (2); i <= (N - 1); ++i) lg[i] = lg[i >> 1] + 1;\n  scanf(\"%d%d%d\", &n, &m, &x);\n  for (int i = (1); i <= (n); ++i) scanf(\"%d\", &a[i]);\n  for (int i = (1); i <= (m); ++i) scanf(\"%d\", &b[i]), id[i] = i;\n  sort(id + 1, id + 1 + m, [&](int x, int y) { return b[x] < b[y]; });\n  st1.init(a, n, 0);\n  st2.init(a, n, 1);\n  a[0] = INF, a[n + 1] = INF;\n  bud(1, n);\n  sort(rgs.begin(), rgs.end());\n  int pos = 1;\n  auto pop = [&](int x) { t.upd(o.val[x], -1); };\n  auto put = [&](int x) { t.upd(o.val[x], 1); };\n  auto ps = [&](int x) {\n    if (vis[x - 1]) {\n      pop(o.fd(x - 1));\n    }\n    if (vis[x + 1]) {\n      pop(o.fd(x + 1));\n    }\n    o.fa[x] = x, o.val[x] = b[x], vis[x] = 1;\n    if (vis[x - 1]) {\n      o.mer(o.fd(x - 1), o.fd(x));\n    }\n    if (vis[x + 1]) {\n      o.mer(o.fd(x + 1), o.fd(x));\n    }\n    put(o.fd(x));\n  };\n  for (auto cur : rgs) {\n    while (pos <= m && b[id[pos]] <= x - cur.w) ps(id[pos++]);\n    int lb = max(0, x - min(a[cur.l - 1], a[cur.r + 1])) + 1;\n    int rb = min(N - 1, x - st2.askv(cur.l, cur.r));\n    if (lb <= rb) ans += t.qry(rb) - t.qry(lb - 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<std::pair<int, int>> init(std::vector<int> a) {\n  int n = a.size();\n  std::vector<int> c(n, 1000000000);\n  std::vector<std::pair<int, int>> sta;\n  sta.emplace_back(0, 0);\n  for (int i = 0; i < n; ++i) {\n    sta.back().second = std::max(sta.back().second, a[i]);\n    while ((int)sta.size() > 1 && sta.back().first >= a[i]) {\n      int v = sta.back().second;\n      sta.pop_back();\n      sta.back().second = std::max(sta.back().second, v);\n    }\n    if (sta.back().first) {\n      c[i] = std::min(c[i], sta.back().second);\n    }\n    sta.emplace_back(a[i], 0);\n  }\n  sta.clear();\n  sta.emplace_back(0, 0);\n  for (int i = n - 1; i >= 0; --i) {\n    sta.back().second = std::max(sta.back().second, a[i]);\n    while ((int)sta.size() > 1 && sta.back().first > a[i]) {\n      int v = sta.back().second;\n      sta.pop_back();\n      sta.back().second = std::max(sta.back().second, v);\n    }\n    if (sta.back().first) {\n      c[i] = std::min(c[i], sta.back().second);\n    }\n    sta.emplace_back(a[i], 0);\n  }\n  std::vector<std::pair<int, int>> res(n);\n  for (int i = 0; i < n; ++i) {\n    res[i] = std::make_pair(c[i] - a[i], a[i]);\n  }\n  return res;\n}\nclass BIT {\n  int n;\n  std::vector<int> c;\n\n public:\n  BIT(int _n) : n(_n), c(n + 1) {}\n  void add(int x, int v) {\n    for (++x; x <= n; x += x & -x) {\n      c[x] += v;\n    }\n  }\n  int query(int x) {\n    int s = 0;\n    for (; x; x ^= x & -x) {\n      s += c[x];\n    }\n    return s;\n  }\n  int query(int l, int r) {\n    l = std::max(l, 0);\n    r = std::min(r, n);\n    if (l >= r) {\n      return 0;\n    }\n    return query(r) - query(l);\n  }\n};\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, m, x;\n  std::cin >> n >> m >> x;\n  int mx = x;\n  std::vector<int> a(n), b(m);\n  for (int i = 0; i < n; ++i) {\n    std::cin >> a[i];\n    mx = std::max(mx, a[i]);\n  }\n  for (int i = 0; i < m; ++i) {\n    std::cin >> b[i];\n    mx = std::max(mx, b[i]);\n  }\n  auto c = init(a), d = init(b);\n  std::sort(c.begin(), c.end());\n  std::sort(d.begin(), d.end());\n  std::reverse(c.begin(), c.end());\n  std::reverse(d.begin(), d.end());\n  BIT Ta(mx), Tb(mx);\n  long long ans = 0;\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < m && d[j].first >= c[i].first) {\n      Tb.add(d[j].second - 1, 1);\n      ++j;\n    }\n    ans += Tb.query(x - c[i].first - c[i].second, x - c[i].second);\n  }\n  for (int i = 0, j = 0; i < m; ++i) {\n    while (j < n && c[j].first > d[i].first) {\n      Ta.add(c[j].second - 1, 1);\n      ++j;\n    }\n    ans += Ta.query(x - d[i].first - d[i].second, x - d[i].second);\n  }\n  std::cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAX_VALEURS = (200 * 1000 + 2);\nlong long Tree[2 * MAX_VALEURS];\nlong long Fenwick[MAX_VALEURS];\npair<long long, long long> Order[MAX_VALEURS];\npair<long long, long long> Inter[2 * MAX_VALEURS];\nlong long Lignes[MAX_VALEURS];\nlong long Colonnes[MAX_VALEURS];\nlong long BornesLignes[MAX_VALEURS];\nlong long BornesColonnes[MAX_VALEURS];\npair<long long, long long> Pile[MAX_VALEURS];\nlong long fin = 0;\nlong long nbLignes, nbColonnes, target;\nlong long GetMax(long long gauche, long long droite, long long val) {\n  long long ans = 0;\n  for (gauche += val, droite += val; gauche < droite;\n       gauche >>= 1, droite >>= 1) {\n    if (gauche & 1) ans = max(ans, Tree[gauche++]);\n    if (droite & 1) ans = max(ans, Tree[--droite]);\n  }\n  return ans;\n}\nvoid Add(long long i) {\n  long long d = i & 1 ? -1 : 1;\n  i >>= 1;\n  for (long long a = Colonnes[i]; a < MAX_VALEURS; a |= (a + 1))\n    Fenwick[a] += d;\n  return;\n}\nlong long GetSum(long long i) {\n  long long ans = 0;\n  for (++i; i > 0; i &= (i - 1)) ans += Fenwick[i - 1];\n  return ans;\n}\nvoid Read() {\n  scanf(\"%lld %lld %lld\", &nbLignes, &nbColonnes, &target);\n  for (long long i = 1; i <= nbLignes; i++) {\n    scanf(\"%lld\", &Lignes[i]);\n  }\n  Lignes[0] = Lignes[nbLignes + 1] = 1 << 30;\n  nbLignes += 2;\n  for (long long i = 1; i <= nbColonnes; i++) {\n    scanf(\"%lld\", &Colonnes[i]);\n  }\n  Colonnes[0] = Colonnes[nbColonnes + 1] = 1 << 30;\n  nbColonnes += 2;\n  for (long long i = 0; i < nbLignes; i++) {\n    Tree[i + nbLignes] = Lignes[i];\n    Order[i] = {Lignes[i], i};\n  }\n  sort(Order, Order + nbLignes);\n  for (long long i = nbLignes - 1; i > 0; i--) {\n    Tree[i] = max(Tree[2 * i], Tree[2 * i + 1]);\n  }\n  Pile[fin++] = {-1, 0};\n  for (long long i = 0; i < nbLignes; i++) {\n    while (Pile[fin - 1].first > Lignes[i]) fin--;\n    BornesLignes[i] = GetMax(Pile[fin - 1].second, i, nbLignes);\n    Pile[fin++] = {Lignes[i], i + 1};\n  }\n  fin = 0;\n  Pile[fin++] = {-1, nbLignes};\n  for (long long i = nbLignes - 1; i >= 0; i--) {\n    while (Pile[fin - 1].first >= Lignes[i]) fin--;\n    BornesLignes[i] =\n        min(BornesLignes[i], GetMax(i, Pile[fin - 1].second, nbLignes));\n    Pile[fin++] = {Lignes[i], i};\n  }\n  for (long long i = 0; i < nbColonnes; i++) {\n    Tree[i + nbColonnes] = Colonnes[i];\n  }\n  for (long long i = nbColonnes - 1; i > 0; i--) {\n    Tree[i] = max(Tree[2 * i], Tree[2 * i + 1]);\n  }\n  fin = 0;\n  Pile[fin++] = {-1, 0};\n  for (long long i = 0; i < nbColonnes; i++) {\n    while (Pile[fin - 1].first > Colonnes[i]) fin--;\n    BornesColonnes[i] = GetMax(Pile[fin - 1].second, i, nbColonnes);\n    Pile[fin++] = {Colonnes[i], i + 1};\n  }\n  fin = 0;\n  Pile[fin++] = {-1, nbColonnes};\n  for (long long i = nbColonnes - 1; i >= 0; i--) {\n    while (Pile[fin - 1].first >= Colonnes[i]) fin--;\n    BornesColonnes[i] =\n        min(BornesColonnes[i], GetMax(i, Pile[fin - 1].second, nbColonnes));\n    Pile[fin++] = {Colonnes[i], i};\n  }\n  for (long long i = 0; i < nbLignes; i++) {\n    BornesLignes[i] = max(BornesLignes[i], Lignes[i]);\n  }\n  for (long long i = 0; i < nbColonnes; i++) {\n    BornesColonnes[i] = max(BornesColonnes[i], Colonnes[i]);\n    Inter[2 * i] = {target - BornesColonnes[i], 2 * i};\n    Inter[2 * i + 1] = {target - Colonnes[i], 2 * i + 1};\n  }\n  sort(Inter, Inter + 2 * nbColonnes);\n  long long cur = 0;\n  long long ans = 0;\n  for (long long i = 0; i < nbLignes; i++) {\n    while (cur < 2 * nbColonnes && Inter[cur].first < Order[i].first)\n      Add(Inter[cur++].second);\n    ans += GetSum(target - Order[i].first) -\n           GetSum(target - BornesLignes[Order[i].second]);\n  }\n  printf(\"%lld\\n\", ans);\n  return;\n}\nsigned main() {\n  Read();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MaxLen = 200000 + 5, Bit = 18, Null = 0;\nconstexpr long long Infinity = (1LL << 60) - 1;\nstruct SparseTable_List {\n  int Log2[MaxLen];\n  long long Min[Bit + 1][MaxLen], Max[Bit + 1][MaxLen];\n  inline void Initalize(const int n) {\n    Log2[0] = (-1);\n    for (register int i = (1); i <= (n); ++i) Log2[i] = (Log2[i >> 1] + 1);\n    for (register int lv = (1); lv <= (Bit); ++lv)\n      for (register int i = (1); i <= (n - (1 << lv) + 1); ++i) {\n        Min[lv][i] = min(Min[lv - 1][i], Min[lv - 1][i + (1 << (lv - 1))]);\n        Max[lv][i] = max(Max[lv - 1][i], Max[lv - 1][i + (1 << (lv - 1))]);\n      }\n  }\n  inline long long Query_Min(const int lef, const int rig) {\n    const int lv = Log2[rig - lef + 1];\n    return min(Min[lv][lef], Min[lv][rig - (1 << lv) + 1]);\n  }\n  inline long long Query_Max(const int lef, const int rig) {\n    const int lv = Log2[rig - lef + 1];\n    return max(Max[lv][lef], Max[lv][rig - (1 << lv) + 1]);\n  }\n};\nSparseTable_List St;\nlong long a[MaxLen], b[MaxLen];\nlong long A[MaxLen], B[MaxLen];\nint idx[MaxLen << 1];\nstruct Compare {\n  inline bool operator()(const int u, const int v) {\n    const long long tag_u = ((u >= 0) ? (a[u] + 1) : B[-u]);\n    const long long tag_v = ((v >= 0) ? (a[v] + 1) : B[-v]);\n    return (tag_u < tag_v);\n  }\n};\nstd::mt19937 Rand(Null);\nstruct Vertex {\n  long long val;\n  unsigned pri;\n  int siz;\n  int lch, rch;\n};\nVertex vt[MaxLen << 3];\nint Overall_Tot;\ninline int Create_Vertex(const long long val) {\n  const int idx = (++Overall_Tot);\n  vt[idx].val = val;\n  vt[idx].pri = Rand();\n  vt[idx].siz = 1;\n  return idx;\n}\ninline int push_up(const int idx) {\n  vt[idx].siz = (vt[vt[idx].lch].siz + vt[vt[idx].rch].siz) + 1;\n  return idx;\n}\ninline int Merge(const int tu, const int tv) {\n  if (!tu) return tv;\n  if (!tv) return tu;\n  if (vt[tu].pri <= vt[tv].pri) {\n    vt[tu].rch = Merge(vt[tu].rch, tv);\n    return push_up(tu);\n  } else {\n    vt[tv].lch = Merge(tu, vt[tv].lch);\n    return push_up(tv);\n  }\n}\ninline void Split(const int idx, const long long val, int& tu, int& tv) {\n  if (!idx) {\n    tu = tv = Null;\n    return;\n  }\n  if (vt[idx].val <= val)\n    tu = idx, Split(vt[idx].rch, val, vt[idx].rch, tv);\n  else\n    tv = idx, Split(vt[idx].lch, val, tu, vt[idx].lch);\n  push_up(idx);\n}\ninline void Insert(int& Root, const long long val) {\n  int tx, ty;\n  Split(Root, val, tx, ty);\n  Root = Merge(Merge(tx, Create_Vertex(val)), ty);\n}\ninline int Query(int& Root, const long long stt, const long long ter) {\n  int tx, ty, tz, temp;\n  Split(Root, ter, tx, tz), Split(tx, stt, tx, ty);\n  temp = vt[ty].siz, Root = Merge(Merge(tx, ty), tz);\n  return temp;\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int n, m;\n  long long k;\n  cin >> n >> m >> k, k = ((k + 1) << 40) - 1;\n  for (register int i = (1); i <= (n); ++i) {\n    cin >> a[i], a[i] = (a[i] << 40) | ((long long)i << 20),\n                 idx[++idx[0]] = (+i);\n    St.Min[0][i] = a[i], St.Max[0][i] = a[i], A[i] = (+Infinity);\n  }\n  St.Initalize(n);\n  for (register int i = (1); i <= (n); ++i) {\n    int beg, end, mid;\n    if ((i != 1) && St.Query_Min(1, i - 1) <= a[i]) {\n      beg = 1, end = i;\n      while (beg < end) {\n        mid = (beg + end) >> 1;\n        if (St.Query_Min(mid, i) == a[i])\n          end = mid;\n        else\n          beg = mid + 1;\n      }\n      if (beg == i)\n        A[i] = (-(Infinity << 1));\n      else\n        A[i] = min(A[i], St.Query_Max(beg, i - 1));\n    }\n    if ((i != n) && St.Query_Min(i + 1, n) <= a[i]) {\n      beg = i, end = n;\n      while (beg < end) {\n        mid = (beg + end + 1) >> 1;\n        if (St.Query_Min(i, mid) == a[i])\n          beg = mid;\n        else\n          end = mid - 1;\n      }\n      if (beg == i)\n        A[i] = (-(Infinity << 1));\n      else\n        A[i] = min(A[i], St.Query_Max(i + 1, beg));\n    }\n  }\n  for (register int i = (1); i <= (n); ++i)\n    a[i] = (k - a[i]), A[i] = (k - A[i]);\n  for (register int i = (1); i <= (m); ++i) {\n    cin >> b[i], b[i] = (b[i] << 40) | i, idx[++idx[0]] = (-i);\n    St.Min[0][i] = b[i], St.Max[0][i] = b[i], B[i] = (+Infinity);\n  }\n  St.Initalize(m);\n  for (register int i = (1); i <= (m); ++i) {\n    int beg, end, mid;\n    if ((i != 1) && St.Query_Min(1, i - 1) <= b[i]) {\n      beg = 1, end = i;\n      while (beg < end) {\n        mid = (beg + end) >> 1;\n        if (St.Query_Min(mid, i) == b[i])\n          end = mid;\n        else\n          beg = mid + 1;\n      }\n      if (beg == i)\n        B[i] = (-(Infinity << 1));\n      else\n        B[i] = min(B[i], St.Query_Max(beg, i - 1));\n    }\n    if ((i != m) && St.Query_Min(i + 1, m) <= b[i]) {\n      beg = i, end = m;\n      while (beg < end) {\n        mid = (beg + end + 1) >> 1;\n        if (St.Query_Min(i, mid) == b[i])\n          beg = mid;\n        else\n          end = mid - 1;\n      }\n      if (beg == i)\n        B[i] = (-(Infinity << 1));\n      else\n        B[i] = min(B[i], St.Query_Max(i + 1, beg));\n    }\n  }\n  sort(idx + 1, idx + idx[0] + 1, Compare());\n  long long Answer = 0;\n  int Root = 0;\n  for (register int i = (idx[0]); i >= (1); --i) {\n    if (idx[i] >= 0) {\n      const int u = (+idx[i]);\n      Answer += Query(Root, A[u], a[u]);\n    } else {\n      const int u = (-idx[i]);\n      Insert(Root, b[u]);\n    }\n  }\n  cout << Answer << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string &s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T, class F = function<T(const T &, const T &)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n  SparseTable(const vector<T> &a, const F &f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n  fenwick(int _n) : n(_n) { fenw.resize(n); }\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i] = min(a[i], x);\n  }\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    b[i] = min(b[i], x);\n  }\n  long long V = 0;\n  long long E = 0;\n  long long F = 0;\n  {\n    auto sa = a;\n    sort(sa.begin(), sa.end());\n    auto sb = b;\n    sort(sb.begin(), sb.end());\n    int j = m;\n    for (int i = 0; i < n; i++) {\n      while (j > 0 && sb[j - 1] + sa[i] > x) {\n        --j;\n      }\n      V += j;\n    }\n  }\n  {{vector<int> sa(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    sa[i] = max(a[i], a[i + 1]);\n  }\n  sort(sa.begin(), sa.end());\n  auto sb = b;\n  sort(sb.begin(), sb.end());\n  int j = m;\n  for (int i = 0; i < n - 1; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n{\n  auto sa = a;\n  sort(sa.begin(), sa.end());\n  vector<int> sb(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    sb[i] = max(b[i], b[i + 1]);\n  }\n  sort(sb.begin(), sb.end());\n  int j = m - 1;\n  for (int i = 0; i < n; i++) {\n    while (j > 0 && sb[j - 1] + sa[i] > x) {\n      --j;\n    }\n    E += j;\n  }\n}\n}\n{\n  auto Make = [&](const vector<int> &v) {\n    int sz = (int)v.size();\n    vector<int> pr(sz), ne(sz);\n    for (int i = 0; i < sz; i++) {\n      pr[i] = i - 1;\n      ne[i] = i + 1;\n    }\n    vector<int> order(sz);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) { return v[i] > v[j]; });\n    SparseTable<int> st(v, [&](int i, int j) { return max(i, j); });\n    vector<tuple<int, int, int>> ret;\n    for (int i = 0; i < sz - 1; i++) {\n      ret.emplace_back(max(v[i], v[i + 1]), x, max(v[i], v[i + 1]));\n    }\n    for (int i : order) {\n      if (pr[i] >= 0 && ne[i] < sz) {\n        int v0 = max(v[pr[i]], v[ne[i]]);\n        int v1 = v[i];\n        int v2 = st.get(pr[i], ne[i]);\n        if (v0 < v1) {\n          ret.emplace_back(v0, v1, v2);\n        }\n      }\n      if (pr[i] != -1) {\n        ne[pr[i]] = ne[i];\n      }\n      if (ne[i] != sz) {\n        pr[ne[i]] = pr[i];\n      }\n    }\n    return ret;\n  };\n  vector<tuple<int, int, int>> r = Make(a);\n  vector<tuple<int, int, int>> c = Make(b);\n  42;\n  42;\n  vector<vector<pair<int, int>>> qs(x + 1);\n  for (auto &q : c) {\n    qs[x - get<2>(q)].emplace_back(x - get<1>(q) + 1, x - get<0>(q));\n  }\n  vector<vector<int>> ev(x + 1);\n  for (auto &p : r) {\n    ev[get<0>(p)].push_back(get<2>(p));\n    ev[get<1>(p)].push_back(~get<2>(p));\n  }\n  fenwick<int> fenw(x + 1);\n  for (int i = 1; i <= x; i++) {\n    for (int e : ev[i]) {\n      if (e >= 0) {\n        fenw.modify(e, +1);\n      } else {\n        fenw.modify(~e, -1);\n      }\n    }\n    for (auto &q : qs[i]) {\n      F += fenw.get(q.second) - fenw.get(q.first - 1);\n    }\n  }\n}\ncout << V - E + F << '\\n';\nreturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f = ch == '-', ch = getchar();\n  while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n  return f ? -x : x;\n}\ntemplate <class T>\nvoid ckmax(T &x, const T y) {\n  if (x < y) x = y;\n}\ntemplate <class T>\nvoid ckmin(T &x, const T y) {\n  if (x > y) x = y;\n}\nconst int N = 200005;\nint n, m, x;\nint a[N], b[N], alim[N], blim[N];\nvoid get_lim(int n, int *a, int *alim) {\n  for (int i = (1); i <= (n); i++) a[i] = read(), alim[i] = x;\n  vector<pair<int, int> > st = {make_pair(0, 0)};\n  for (int i = (1); i <= (n); i++) {\n    pair<int, int> t = make_pair(i, a[i]);\n    while (a[i] < a[st.back().first]) {\n      ckmin(alim[st.back().first], t.second);\n      ckmax(t.second, st.back().second);\n      st.pop_back();\n    }\n    if (st.size() > 1) ckmin(alim[i], t.second);\n    st.push_back(t);\n  }\n}\nint _c0[N], _c1[N];\nvoid add(int *c, int x) {\n  for (; x < N; x += x & -x) c[x]++;\n}\nint ask(int *c, int x) {\n  int ans = 0;\n  for (; x; x -= x & -x) ans += c[x];\n  return ans;\n}\nint main() {\n  n = read(), m = read(), x = read();\n  get_lim(n, a, alim);\n  get_lim(m, b, blim);\n  vector<pair<int, int> > v;\n  for (int i = (1); i <= (n); i++)\n    if (a[i] < alim[i]) v.push_back(make_pair(a[i], alim[i]));\n  for (int i = (1); i <= (m); i++)\n    if (b[i] < blim[i]) v.push_back(make_pair(-b[i], blim[i]));\n  sort(v.begin(), v.end(), [&](pair<int, int> a, pair<int, int> b) {\n    return a.second - abs(a.first) > b.second - abs(b.first);\n  });\n  long long ans = 0;\n  for (auto p : v) {\n    int v = abs(p.first), lim = p.second;\n    int *c0 = _c0, *c1 = _c1;\n    if (p.first < 0) swap(c0, c1);\n    ans += ask(c1, x - v) - ask(c1, x - lim);\n    add(c0, v);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nint n, m, X, a[N], b[N], ra[N], rb[N], id[N], id1[N], mx[N], mx1[N], stk[N],\n    val[N], top;\nint rk[N], rk1[N];\nlong long ans;\nvoid proc(int n, int *a, int *mx) {\n  top = 0;\n  val[0] = 0x3f3f3f3f;\n  for (int i = 1; i <= n; ++i) {\n    while (top && a[stk[top]] > a[i]) {\n      mx[stk[top]] = std::min(val[top - 1], val[top]), --top;\n      val[top] = std::max(a[stk[top + 1]], std::max(val[top], val[top + 1]));\n    }\n    stk[++top] = i;\n    val[top] = 0;\n  }\n  while (top) mx[stk[top]] = val[top - 1], --top;\n}\nint sum[N], sum1[N];\ninline void add(int p) {\n  while (p <= n) ++sum[p], p += p & (-p);\n}\ninline int ask(int p) {\n  int ret = 0;\n  while (p) ret += sum[p], p -= p & (-p);\n  return ret;\n}\ninline void add1(int p) {\n  while (p <= m) ++sum1[p], p += p & (-p);\n}\ninline int ask1(int p) {\n  int ret = 0;\n  while (p) ret += sum1[p], p -= p & (-p);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &X);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i), mx[i] = a[i], id[i] = i;\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", b + i), mx1[i] = b[i], id1[i] = i;\n  proc(n, a, mx);\n  proc(m, b, mx1);\n  std::sort(id + 1, id + n + 1, [](int x, int y) { return a[x] < a[y]; });\n  for (int i = 1; i <= n; ++i) rk[id[i]] = i, ra[i] = a[id[i]];\n  std::sort(id1 + 1, id1 + m + 1, [](int x, int y) { return b[x] < b[y]; });\n  for (int i = 1; i <= m; ++i) rk1[id1[i]] = i, rb[i] = b[id1[i]];\n  for (int i = 1; i <= n; ++i) mx[i] -= a[i];\n  for (int i = 1; i <= m; ++i) mx1[i] -= b[i];\n  std::sort(id + 1, id + n + 1, [](int x, int y) { return mx[x] > mx[y]; });\n  std::sort(id1 + 1, id1 + m + 1, [](int x, int y) { return mx1[x] > mx1[y]; });\n  int l = 0, r = 0;\n  while (l < n || r < m) {\n    int x = id[l + 1], y = id1[r + 1];\n    if (l < n && (r == m || mx[x] > mx1[y])) {\n      int lw = X - mx[x] - a[x] + 1, up = X - a[x];\n      if (lw <= up) {\n        int l = std::lower_bound(rb + 1, rb + m + 1, lw) - rb,\n            r = std::upper_bound(rb + 1, rb + m + 1, up) - rb - 1;\n        ans += ask1(r) - ask1(l - 1);\n      }\n      add(rk[x]);\n      ++l;\n    } else {\n      int lw = X - mx1[y] - b[y] + 1, up = X - b[y];\n      if (lw <= up) {\n        int l = std::lower_bound(ra + 1, ra + n + 1, lw) - ra,\n            r = std::upper_bound(ra + 1, ra + n + 1, up) - ra - 1;\n        ans += ask(r) - ask(l - 1);\n      }\n      add1(rk1[y]);\n      ++r;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nclass Scanner {\n private:\n  static const int BUFFER_SIZE = 1 << 18;\n  char buff[BUFFER_SIZE];\n  char *buffPos, *buffLim;\n  FILE* file;\n\n public:\n  Scanner(FILE* file) {\n    this->file = file;\n    buffLim = buff + fread(buff, 1, BUFFER_SIZE, file);\n    buffPos = buff;\n  }\n\n private:\n  inline void flushBuff() {\n    buffLim = buff + fread(buff, 1, BUFFER_SIZE, file);\n    if (buffLim == buff) {\n      *buffLim++ = '\\n';\n    }\n    buffPos = buff;\n  }\n  inline bool isWS(char t) { return t <= ' '; }\n  inline bool isDig(char t) { return t >= '0' && t <= '9'; }\n  inline void nextPos() {\n    buffPos++;\n    if (buffPos == buffLim) {\n      flushBuff();\n    }\n  }\n\n public:\n  inline char getchar() {\n    char ch = *buffPos;\n    nextPos();\n    return ch;\n  }\n  inline void next(char* s) {\n    while (isWS(*buffPos)) {\n      nextPos();\n    }\n    while (!isWS(*buffPos)) {\n      *s = *buffPos;\n      s++;\n      nextPos();\n    }\n    *s = '\\0';\n  }\n  inline void nextLine(char* s) {\n    while (*buffPos != '\\n') {\n      nextPos();\n    }\n    if (*buffPos == '\\n') {\n      nextPos();\n    }\n    while (*buffPos != '\\n') {\n      *s++ = *buffPos;\n      nextPos();\n    }\n    *s = '\\0';\n  }\n  inline int nextInt() {\n    while (!isDig(*buffPos) && *buffPos != '-') {\n      nextPos();\n    }\n    int sign = (*buffPos == '-') ? nextPos(), -1 : 1;\n    int res = 0;\n    while (isDig(*buffPos)) {\n      res = res * 10 + *buffPos - '0';\n      nextPos();\n    }\n    return res * sign;\n  }\n  inline long long nextLong() {\n    while (!isDig(*buffPos) && *buffPos != '-') {\n      nextPos();\n    }\n    long long sign = (*buffPos == '-') ? nextPos(), -1 : 1;\n    long long res = 0;\n    while (isDig(*buffPos)) {\n      res = res * 10 + *buffPos - '0';\n      nextPos();\n    }\n    return res * sign;\n  }\n  inline int n() {\n    while (*buffPos < '0' || *buffPos > '9') {\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    int res = 0;\n    while (*buffPos >= '0' && *buffPos <= '9') {\n      res = res * 10 + (*buffPos - '0');\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    return res;\n  }\n  inline long long nl() {\n    while (*buffPos < '0' || *buffPos > '9') {\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    long long res = 0;\n    while (*buffPos >= '0' && *buffPos <= '9') {\n      res = res * 10 + (*buffPos - '0');\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    return res;\n  }\n  inline long long nlm(const int MOD) {\n    while (*buffPos < '0' || *buffPos > '9') {\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    long long res = 0;\n    while (*buffPos >= '0' && *buffPos <= '9') {\n      res = (res * 10 + (*buffPos - '0')) % MOD;\n      buffPos++;\n      if (buffPos == buffLim) {\n        flushBuff();\n      }\n    }\n    return res;\n  }\n  inline double nextDouble() {\n    while (isWS(*buffPos)) {\n      nextPos();\n    }\n    int sign = (*buffPos == '-') ? nextPos(), -1 : 1;\n    double res = 0;\n    while (isDig(*buffPos)) {\n      res = res * 10 + *buffPos - '0';\n      nextPos();\n    }\n    if (*buffPos == '.') {\n      nextPos();\n      double ep = 1;\n      while (isDig(*buffPos)) {\n        ep *= 0.1;\n        res += ep * (*buffPos - '0');\n        nextPos();\n      }\n    }\n    return sign * res;\n  }\n  inline char nextChar() {\n    while (isWS(*buffPos)) nextPos();\n    char res = *buffPos;\n    nextPos();\n    return res;\n  }\n  ~Scanner() { fclose(file); }\n};\nScanner sc(stdin);\ntemplate <class __TyFirst, class __TySecond>\nstd::ostream& operator<<(std::ostream& out,\n                         const std::pair<__TyFirst, __TySecond>& o);\nstatic std::string cout_list_sep = \" \";\ntemplate <\n    class IterateType, typename = decltype(std::declval<IterateType>().begin()),\n    typename = decltype(std::declval<IterateType>().end()),\n    typename = typename std::enable_if<std::is_convertible<\n        typename std::iterator_traits<\n            typename IterateType::iterator>::iterator_category,\n        std::input_iterator_tag>::value>::type,\n    typename = typename std::enable_if<!std::is_base_of<\n        std::string, typename std::decay<IterateType>::type>::value>::type,\n    typename value_type = typename IterateType::value_type>\nstd::ostream& operator<<(std::ostream& out, const IterateType& a) {\n  for (const auto& i : a) out << i << cout_list_sep;\n  return out;\n}\ntemplate <class __TyFirst, class __TySecond>\nstd::ostream& operator<<(std::ostream& out,\n                         const std::pair<__TyFirst, __TySecond>& o) {\n  out << \"(\" << o.first << \",\" << o.second << \")\";\n  return out;\n}\ntemplate <typename _ForwardIterator>\nvoid logArray(_ForwardIterator, _ForwardIterator, const char* = 0) {}\nnamespace Temps {\ntemplate <typename _IntType>\nclass RangeInt {\n  static_assert(std::is_integral<_IntType>::value,\n                \"RangeInt object must have integral value type\");\n\n public:\n  class iterator : public std::iterator<std::input_iterator_tag, _IntType,\n                                        _IntType, const _IntType*, _IntType> {\n    _IntType val, step;\n\n   public:\n    using typename std::iterator<std::input_iterator_tag, _IntType, _IntType,\n                                 const _IntType*, _IntType>::reference;\n    explicit constexpr iterator(int val, int step) noexcept\n        : val(val), step(step) {}\n    constexpr iterator& operator++() noexcept {\n      val += step;\n      return *this;\n    }\n    constexpr iterator operator++(int) noexcept {\n      iterator ret = *this;\n      val += step;\n      return ret;\n    }\n    constexpr bool operator==(const iterator& rhs) const noexcept {\n      return val == rhs.val;\n    }\n    constexpr bool operator!=(const iterator& rhs) const noexcept {\n      return val != rhs.val;\n    }\n    constexpr reference operator*() const { return val; }\n  };\n  const _IntType _begin, _step, _end;\n  explicit constexpr RangeInt(const _IntType end) noexcept\n      : _begin(0), _step(1), _end(end > 0 ? end : 0) {}\n  explicit constexpr RangeInt(const _IntType begin, const _IntType end) noexcept\n      : _begin(begin), _step(1), _end(end > begin ? end : begin) {}\n  explicit constexpr RangeInt(const _IntType begin, const _IntType end,\n                              const _IntType step)\n      : _begin(begin),\n        _step(step),\n        _end(((step > 0 && end <= begin) || (step < 0 && end >= begin))\n                 ? begin\n                 : (step > 0\n                        ? begin + (end - begin + step - 1) / step * step\n                        : begin + (begin - end - step - 1) / (-step) * step)) {}\n  constexpr iterator begin() const noexcept { return iterator(_begin, _step); }\n  constexpr iterator end() const noexcept { return iterator(_end, _step); }\n  constexpr _IntType size() const noexcept { return (_end - _begin) / _step; }\n};\ntemplate <class IntType, typename = typename std::enable_if<\n                             std::is_integral<IntType>::value>::type>\ninline constexpr RangeInt<IntType> range(IntType arg1) {\n  return RangeInt<IntType>(arg1);\n}\ntemplate <class IntType, typename = typename std::enable_if<\n                             std::is_integral<IntType>::value>::type>\ninline constexpr RangeInt<IntType> range(IntType arg1, IntType arg2) {\n  return RangeInt<IntType>(arg1, arg2);\n}\ntemplate <class IntType, typename = typename std::enable_if<\n                             std::is_integral<IntType>::value>::type>\ninline constexpr RangeInt<IntType> range(IntType arg1, IntType arg2,\n                                         IntType arg3) {\n  return RangeInt<IntType>(arg1, arg2, arg3);\n}\n}  // namespace Temps\nusing Temps::range;\nnamespace Temps {\ntemplate <class T>\ninline bool checkMin(T& a, T b) {\n  return (b < a ? a = b, 1 : 0);\n}\ntemplate <class T>\ninline bool checkMax(T& a, T b) {\n  return (a < b ? a = b, 1 : 0);\n}\ntemplate <class IntType, typename = typename std::enable_if<\n                             std::is_integral<IntType>::value>::type>\nIntType gcd(const IntType a, const IntType b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\ntemplate <class IntType, typename = typename std::enable_if<\n                             std::is_integral<IntType>::value>::type>\nIntType lcm(const IntType a, const IntType b) {\n  return a / gcd(a, b) * b;\n}\ntemplate <class ForwardIterator, class OutputIterator>\nvoid dissociate(ForwardIterator __begin, ForwardIterator __end,\n                OutputIterator __dest) {\n  std::vector<typename std::iterator_traits<ForwardIterator>::_IntType> values(\n      __begin, __end);\n  std::sort(values.begin(), values.end());\n  std::unique(values.begin(), values.end());\n  while (__begin != __end) {\n    *__dest =\n        static_cast<typename std::iterator_traits<OutputIterator>::_IntType>(\n            std::distance(\n                values.begin(),\n                std::lower_bound(values.begin(), values.end(), *__begin)));\n    __dest++;\n    __begin++;\n  }\n}\n}  // namespace Temps\nusing Temps::checkMax;\nusing Temps::checkMin;\nvoid preInit();\nvoid init();\nvoid solve();\nint32_t main() {\n  preInit();\n  init();\n  solve();\n  return 0;\n}\ntemplate <typename T>\nstruct FTree {\n  size_t n;\n  std::vector<T> a;\n  FTree() {}\n  FTree(size_t n) : n(n + 1), a(n + 2) {}\n  void init(int _n) {\n    n = _n + 1;\n    a.resize(n + 1);\n  }\n  void add(size_t x, T v) {\n    ++x;\n    for (; x <= n; x += x & -x) a[x] += v;\n  }\n  T sum(size_t x) {\n    ++x;\n    x = std::min(x, n);\n    T ret = 0;\n    for (; x; x -= (x & -x)) ret += a[x];\n    return ret;\n  }\n};\nstruct node_t {\n  int a, b, t;\n  bool operator<(const node_t& n) const {\n    return a < n.a || (a == n.a && t < n.t);\n  }\n};\nstd::vector<int> calc(std::vector<int> a) {\n  size_t n = a.size();\n  std::vector<int> b(n, -1), c(n, -1);\n  std::vector<size_t> stk(n);\n  size_t tp = 0;\n  for (size_t i = 0; i < n; ++i) {\n    int mx = -1;\n    while (tp && a[stk[tp - 1]] > a[i]) {\n      mx = std::max(mx, a[stk[tp - 1]]);\n      mx = std::max(mx, b[stk[tp - 1]]);\n      --tp;\n    }\n    if (tp)\n      b[i] = mx;\n    else\n      b[i] = 1e9;\n    stk[tp++] = i;\n  }\n  tp = 0;\n  for (size_t i = n - 1; i < n; --i) {\n    int mx = -1;\n    while (tp && a[stk[tp - 1]] >= a[i]) {\n      mx = std::max(mx, a[stk[tp - 1]]);\n      mx = std::max(mx, c[stk[tp - 1]]);\n      --tp;\n    }\n    if (tp)\n      c[i] = mx;\n    else\n      c[i] = 1e9;\n    stk[tp++] = i;\n  }\n  for (size_t i = 0; i < n; ++i) checkMin(b[i], c[i]);\n  return b;\n};\nstd::vector<int> a, b;\nsize_t n, m;\nint x;\nvoid preInit() {}\nvoid init() {\n  n = (size_t)sc.n();\n  m = (size_t)sc.n();\n  x = sc.n();\n  a.resize(n);\n  b.resize(m);\n  for (size_t i = 0; i < n; ++i) a[i] = std::min(sc.n(), x);\n  for (size_t i = 0; i < m; ++i) b[i] = std::min(sc.n(), x);\n}\nvoid solve() {\n  std::vector<int> c = calc(a), d = calc(b);\n  std::vector<node_t> vec;\n  for (size_t i = 0; i < n; ++i)\n    if (c[i] > a[i]) vec.push_back({a[i], c[i], 0});\n  for (size_t i = 0; i < m; ++i)\n    if (d[i] > b[i]) vec.push_back({x - d[i], x - b[i], 1});\n  std::sort(vec.begin(), vec.end());\n  long long ans = 0;\n  FTree<int> st(200005);\n  for (auto& p : vec)\n    if (p.t == 0) {\n      ans += st.sum((size_t)p.b - 1) - st.sum((size_t)p.a - 1);\n    } else {\n      st.add((size_t)p.b, 1);\n    }\n  std::cout << ans << std::endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010, LG = 18, Inf = 1e9;\nint n, m, k, a[N], b[N], c[N], d[N], lg[N], st[N][LG + 1];\nlong long ans;\npair<int, pair<int, int> > qry[N * 2];\nstack<int> s;\nvoid buildst(int n, int *a) {\n  for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= n; i++) st[i][0] = a[i];\n  for (int i = n; i >= 1; i--)\n    for (int j = 1; i + (1 << j) - 1 <= n; j++)\n      st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n}\nint query(int l, int r) {\n  int k = lg[r - l + 1];\n  return max(st[l][k], st[r - (1 << k) + 1][k]);\n}\nvoid work(int n, int *a, int *c) {\n  for (int i = 1; i <= n; i++) {\n    c[i] = Inf;\n    while (s.size() && a[s.top()] >= a[i]) s.pop();\n    if (s.size()) c[i] = query(s.top() + 1, i);\n    s.push(i);\n  }\n  while (s.size()) s.pop();\n  for (int i = n; i >= 1; i--) {\n    while (s.size() && a[s.top()] > a[i]) s.pop();\n    if (s.size()) c[i] = min(c[i], query(i, s.top() - 1));\n    s.push(i);\n  }\n  while (s.size()) s.pop();\n}\nstruct BIT {\n  int c[N];\n  void add(int x, int v) {\n    for (int i = x; i < N; i += i & -i) c[i] += v;\n  }\n  int query(int x) {\n    int ans = 0;\n    for (int i = x; i > 0; i -= i & -i) ans += c[i];\n    return ans;\n  }\n} bit[2];\nbool cmp(pair<int, pair<int, int> > x, pair<int, pair<int, int> > y) {\n  return x.second.first - x.first > y.second.first - y.first;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i++) scanf(\"%d\", &b[i]);\n  buildst(n, a);\n  work(n, a, c);\n  buildst(m, b);\n  work(m, b, d);\n  for (int i = 1; i <= n; i++) qry[i] = make_pair(a[i], make_pair(c[i], 0));\n  for (int i = 1; i <= m; i++) qry[i + n] = make_pair(b[i], make_pair(d[i], 1));\n  sort(qry + 1, qry + 1 + n + m, cmp);\n  for (int i = 1; i <= n + m; i++) {\n    int x = qry[i].first, y = qry[i].second.first, typ = qry[i].second.second;\n    if (x <= y) ans += bit[typ ^ 1].query(k - x) - bit[typ ^ 1].query(k - y);\n    bit[typ].add(x, 1);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rnd(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXDIM = 200000;\nint na, nb, lim;\nint a[MAXDIM];\nint b[MAXDIM];\nvector<int> calc(const vector<int>& x, bool lftlower) {\n  int n = ((int)(x).size());\n  vector<pair<int, int>> stck;\n  auto cmp = [&](int a, int b) { return a < b || a == b && lftlower; };\n  vector<int> ret(n);\n  for (int i = (0); i < (n); ++i) {\n    while (((int)(stck).size()) >= 1 &&\n           !cmp(stck[((int)(stck).size()) - 1].first, x[i])) {\n      if (((int)(stck).size()) >= 2)\n        stck[((int)(stck).size()) - 2].second =\n            max(stck[((int)(stck).size()) - 2].second,\n                stck[((int)(stck).size()) - 1].second);\n      stck.pop_back();\n    }\n    ret[i] = ((int)(stck).size()) == 0\n                 ? INT_MAX\n                 : max(stck[((int)(stck).size()) - 1].second, x[i]);\n    stck.push_back(make_pair(x[i], x[i]));\n  }\n  return ret;\n}\nint aslack[MAXDIM];\nint bslack[MAXDIM];\nstruct BIT {\n  int n;\n  vector<int> val;\n  void init(int _n) {\n    n = _n;\n    val = vector<int>(n + 1, 0);\n  }\n  void mod(int idx, int by) {\n    ++idx;\n    while (idx <= n) {\n      val[idx] += by;\n      idx += idx & -idx;\n    }\n  }\n  int get(int idx) {\n    ++idx;\n    idx = max(0, min(idx, n));\n    int ret = 0;\n    while (idx > 0) {\n      ret += val[idx];\n      idx -= idx & -idx;\n    }\n    return ret;\n  }\n  int get(int lidx, int ridx) { return get(ridx) - get(lidx - 1); }\n};\nBIT abit, bbit;\nlong long solve() {\n  for (int i = (0); i < (na); ++i) aslack[i] = INT_MAX;\n  for (int i = (0); i < (nb); ++i) bslack[i] = INT_MAX;\n  {\n    vector<int> x(a, a + na);\n    x = calc(x, true);\n    for (int i = (0); i < (na); ++i) aslack[i] = min(aslack[i], x[i] - a[i]);\n  }\n  {\n    vector<int> x(a, a + na);\n    reverse(x.begin(), x.end());\n    x = calc(x, false);\n    reverse(x.begin(), x.end());\n    for (int i = (0); i < (na); ++i) aslack[i] = min(aslack[i], x[i] - a[i]);\n  }\n  {\n    vector<int> x(b, b + nb);\n    x = calc(x, true);\n    for (int i = (0); i < (nb); ++i) bslack[i] = min(bslack[i], x[i] - b[i]);\n  }\n  {\n    vector<int> x(b, b + nb);\n    reverse(x.begin(), x.end());\n    x = calc(x, false);\n    reverse(x.begin(), x.end());\n    for (int i = (0); i < (nb); ++i) bslack[i] = min(bslack[i], x[i] - b[i]);\n  }\n  vector<pair<int, int>> ord;\n  for (int i = (0); i < (na); ++i) ord.push_back(make_pair(0, i));\n  for (int i = (0); i < (nb); ++i) ord.push_back(make_pair(1, i));\n  sort(ord.begin(), ord.end(),\n       [&](const pair<int, int>& p, const pair<int, int>& q) {\n         int pp = p.first == 0 ? aslack[p.second] : bslack[p.second],\n             qq = q.first == 0 ? aslack[q.second] : bslack[q.second];\n         return pp > qq;\n       });\n  int alim = a[0];\n  for (int i = (1); i < (na); ++i) alim = max(alim, a[i]);\n  int blim = b[0];\n  for (int i = (1); i < (nb); ++i) blim = max(blim, b[i]);\n  abit.init(alim + 1);\n  bbit.init(blim + 1);\n  long long ret = 0;\n  for (auto z : ord) {\n    if (z.first == 0) {\n      int i = z.second;\n      int lo = aslack[i] == INT_MAX ? 0 : max(0, lim - aslack[i] - a[i] + 1),\n          hi = lim - a[i];\n      if (lo <= hi) ret += bbit.get(lo, hi);\n      abit.mod(a[i], +1);\n    } else {\n      int j = z.second;\n      int lo = bslack[j] == INT_MAX ? 0 : max(0, lim - bslack[j] - b[j] + 1),\n          hi = lim - b[j];\n      if (lo <= hi) ret += abit.get(lo, hi);\n      bbit.mod(b[j], +1);\n    }\n  }\n  return ret;\n}\nvoid run() {\n  scanf(\"%d%d%d\", &na, &nb, &lim);\n  for (int i = (0); i < (na); ++i) scanf(\"%d\", &a[i]);\n  for (int i = (0); i < (nb); ++i) scanf(\"%d\", &b[i]);\n  printf(\"%lld\\n\", solve());\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint S[200005], S2[200005];\nvoid add(int first, int k, int *S) {\n  for (int i = first; i < 200005; i += i & -i) {\n    S[i] += k;\n  }\n}\nint query(int first, int *S) {\n  if (first <= 0) return 0;\n  int res = 0;\n  for (int i = first; i > 0; i -= i & -i) {\n    res += S[i];\n  }\n  return res;\n}\nvoid solve() {\n  int n, m, X;\n  scanf(\"%d %d %d\", &n, &m, &X);\n  int a[200005];\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  vector<pair<int, int> > v;\n  int lx[200005], rx[200005];\n  memset(lx, 0, sizeof(lx));\n  memset(rx, 0, sizeof(rx));\n  for (int i = 1; i <= n; i++) {\n    while (v.size() && v.back().first > a[i]) {\n      lx[i] = max(lx[i], v.back().first);\n      lx[i] = max(lx[i], lx[v.back().second]);\n      v.pop_back();\n    }\n    if (v.empty()) lx[i] = 1e9;\n    v.push_back(make_pair(a[i], i));\n  }\n  v.clear();\n  for (int i = n; i >= 1; i--) {\n    while (v.size() && v.back().first >= a[i]) {\n      rx[i] = max(rx[i], v.back().first);\n      rx[i] = max(rx[i], rx[v.back().second]);\n      v.pop_back();\n    }\n    if (v.empty()) rx[i] = 1e9;\n    v.push_back(make_pair(a[i], i));\n  }\n  v.clear();\n  int b[200005];\n  for (int i = 1; i <= m; i++) scanf(\"%d\", &b[i]);\n  int ly[200005], ry[200005];\n  memset(ly, 0, sizeof(ly));\n  memset(ry, 0, sizeof(ry));\n  for (int i = 1; i <= m; i++) {\n    while (v.size() && v.back().first > b[i]) {\n      ly[i] = max(ly[i], v.back().first);\n      ly[i] = max(ly[i], ly[v.back().second]);\n      v.pop_back();\n    }\n    if (v.empty()) ly[i] = 1e9;\n    v.push_back(make_pair(b[i], i));\n  }\n  v.clear();\n  for (int i = m; i >= 1; i--) {\n    while (v.size() && v.back().first >= b[i]) {\n      ry[i] = max(ry[i], v.back().first);\n      ry[i] = max(ry[i], ry[v.back().second]);\n      v.pop_back();\n    }\n    if (v.empty()) ry[i] = 1e9;\n    v.push_back(make_pair(b[i], i));\n  }\n  v.clear();\n  vector<pair<pair<int, int>, int> > vv;\n  for (int i = 1; i <= n; i++) {\n    vv.push_back(make_pair(make_pair(min(lx[i], rx[i]) - a[i], a[i]), 0));\n  }\n  for (int i = 1; i <= m; i++) {\n    vv.push_back(make_pair(make_pair(min(ly[i], ry[i]) - b[i], b[i]), 1));\n  }\n  sort(vv.begin(), vv.end());\n  long long ans = 0;\n  reverse(vv.begin(), vv.end());\n  for (auto it : vv) {\n    int ax = it.first.first + it.first.second;\n    if (it.second == 0) {\n      add(it.first.second, 1, S);\n      if (X - it.first.second > X - ax)\n        ans += query(X - it.first.second, S2) - query(X - ax, S2);\n    } else {\n      add(it.first.second, 1, S2);\n      if (X - it.first.second > X - ax)\n        ans += query(X - it.first.second, S) - query(X - ax, S);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1 << 18;\nstruct Fenwick {\n  int dt[maxn];\n  void inline add(int a, int x) {\n    while (a < maxn) {\n      dt[a] += x;\n      a += a & -a;\n    }\n  }\n  int inline sum(int a) {\n    if (a < 0) return 0;\n    int res = 0;\n    while (a) {\n      res += dt[a];\n      a -= a & -a;\n    }\n    return res;\n  }\n} t1, t2;\nstruct ZkwSeg {\n  int dt[maxn << 1];\n  void inline init() { memset(dt, 0, sizeof(dt)); }\n  void inline add(int a, int x) {\n    dt[a += maxn] += x;\n    while (a >>= 1) dt[a] = max(dt[a << 1], dt[a << 1 | 1]);\n  }\n  int inline get(int l, int r) {\n    int res = 0;\n    for (l += maxn, r += maxn + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) res = max(res, dt[l++]);\n      if (r & 1) res = max(res, dt[--r]);\n    }\n    return res;\n  }\n} seg;\nint N, M, X;\nint a[maxn], b[maxn];\nint mxa[maxn], mxb[maxn];\nvector<pair<int, int> > stk;\nvoid inline getmx(int a[], int mxa[], int N) {\n  seg.init();\n  for (int i = 1; i <= (N); ++i) seg.add(i, a[i]);\n  for (int i = 1; i <= (N); ++i) mxa[i] = 0x3f3f3f3f;\n  stk.clear();\n  for (int i = N; i; --i) {\n    while (((int)(stk).size()) && stk.back().second >= a[i]) {\n      int id = stk.back().first;\n      mxa[id] = seg.get(i, id);\n      stk.pop_back();\n    }\n    stk.emplace_back(i, a[i]);\n  }\n  stk.clear();\n  for (int i = 1; i <= (N); ++i) {\n    while (((int)(stk).size()) && stk.back().second > a[i]) {\n      int id = stk.back().first;\n      mxa[id] = min(mxa[id], seg.get(id, i));\n      stk.pop_back();\n    }\n    stk.emplace_back(i, a[i]);\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &N, &M, &X);\n  for (int i = 1; i <= (N); ++i) scanf(\"%d\", a + i);\n  for (int i = 1; i <= (M); ++i) scanf(\"%d\", b + i);\n  getmx(a, mxa, N);\n  getmx(b, mxb, M);\n  vector<tuple<int, int, int> > pos;\n  for (int i = 1; i <= (N); ++i) pos.emplace_back(a[i] - mxa[i], a[i], 0);\n  for (int i = 1; i <= (M); ++i) pos.emplace_back(b[i] - mxb[i], b[i], 1);\n  sort(pos.begin(), pos.end());\n  long long ans = 0;\n  for (auto &it : pos) {\n    int mode = get<2>(it), val = get<1>(it);\n    int mx = val - get<0>(it);\n    if (!mode) {\n      ans += t2.sum(X - val) - t2.sum(X - mx);\n      t1.add(val, 1);\n    } else {\n      ans += t1.sum(X - val) - t1.sum(X - mx);\n      t2.add(val, 1);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &t) {\n  t = 0;\n  char ch = getchar();\n  int f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  do {\n    (t *= 10) += ch - '0';\n    ch = getchar();\n  } while ('0' <= ch && ch <= '9');\n  t *= f;\n}\ntemplate <typename T>\nvoid write(T t) {\n  if (t < 0) {\n    putchar('-');\n    write(-t);\n    return;\n  }\n  if (t > 9) write(t / 10);\n  putchar('0' + t % 10);\n}\ntemplate <typename T>\nvoid writeln(T t) {\n  write(t);\n  puts(\"\");\n}\nconst int INF = 1e9;\nconst int maxn = (2e5) + 10;\nint n, m, X;\nlong long ans;\nint a[maxn], b[maxn], na[maxn], nb[maxn];\nint s[maxn], tot, L[maxn], R[maxn];\nint st[maxn][20], lg[maxn];\nint query(int l, int r) {\n  int j = lg[r - l + 1];\n  return max(st[l][j], st[r - (1 << j) + 1][j]);\n}\nvoid solve(int n, int *a, int *na) {\n  for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= n; i++) st[i][0] = a[i];\n  for (int i = 1; i <= 19; i++)\n    for (int j = 1; j + (1 << i) - 1 <= n; j++)\n      st[j][i] = max(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);\n  tot = 0;\n  for (int i = 1; i <= n; i++) {\n    while (tot && a[s[tot]] > a[i]) tot--;\n    L[i] = s[tot];\n    s[++tot] = i;\n  }\n  tot = 0;\n  for (int i = n; i >= 1; i--) {\n    while (tot && a[s[tot]] >= a[i]) tot--;\n    R[i] = s[tot];\n    s[++tot] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    na[i] = INF;\n    if (L[i]) na[i] = query(L[i], i);\n    if (R[i]) na[i] = min(na[i], query(i, R[i]));\n  }\n}\nint id[maxn], id2[maxn];\nbool cmp(int x, int y) { return a[x] < a[y]; }\nbool cmp2(int x, int y) { return nb[x] < nb[y]; }\nnamespace Seg {\nint tr[maxn];\nvoid add(int x) {\n  for (; x < maxn; x += x & (-x)) tr[x]++;\n}\nint query(int x) {\n  int res = 0;\n  for (; x; x -= x & (-x)) res += tr[x];\n  return res;\n}\nint query(int l, int r) { return query(r) - query(l - 1); }\n};  // namespace Seg\nint main() {\n  read(n), read(m), read(X);\n  for (int i = 1; i <= n; i++) read(a[i]);\n  for (int i = 1; i <= m; i++) read(b[i]);\n  solve(n, a, na);\n  solve(m, b, nb);\n  for (int i = 1; i <= n; i++) id[i] = i;\n  sort(id + 1, id + n + 1, cmp);\n  for (int i = 1; i <= m; i++) id2[i] = i;\n  sort(id2 + 1, id2 + m + 1, cmp2);\n  int pos = m + 1;\n  for (int I = 1; I <= n; I++) {\n    int i = id[I];\n    while (pos > 1 && nb[id2[pos - 1]] > X - a[i]) {\n      pos--;\n      Seg::add(b[id2[pos]]);\n    }\n    int L = max(1, X - na[i] + 1), R = min(200000, X - a[i]);\n    if (L <= R) ans += Seg::query(L, R);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T1, class T2>\ninline bool cmin(T1 &a, const T2 &b) {\n  return b < a ? (a = b, true) : false;\n}\ntemplate <class T1, class T2>\ninline bool cmax(T1 &a, const T2 &b) {\n  return a < b ? (a = b, true) : false;\n}\ntemplate <class Type>\nType read() {\n  Type a;\n  bool b;\n  unsigned char c;\n  while (c = getchar() - 48, (c > 9) & (c != 253))\n    ;\n  for (a = (b = c == 253) ? 0 : c; (c = getchar() - 48) <= 9; a = a * 10 + c)\n    ;\n  return b ? -a : a;\n}\nint (*rd)() = read<int>;\nstruct Group {\n  std::vector<int> x, y, min[18], max[18];\n  int query_min(int l, int r) {\n    int lv = __builtin_clz(r - l) ^ 31;\n    l = min[lv][l];\n    r = min[lv][r - (1 << lv)];\n    return x[l] < x[r] ? l : r;\n  }\n  int query_max(int l, int r) {\n    int lv = __builtin_clz(r - l) ^ 31;\n    return std::max(max[lv][l], max[lv][r - (1 << lv)]);\n  }\n  void dfs(int l, int r) {\n    if (l == r) return;\n    int mid = query_min(l, r);\n    dfs(l, mid);\n    dfs(mid + 1, r);\n    if (l != 0) y[mid] = std::min(y[mid], query_max(l, mid + 1));\n    if (r < (int)x.size()) y[mid] = std::min(y[mid], query_max(mid, r));\n  }\n  Group(int n) {\n    x.resize(n);\n    y.resize(n, 1e9);\n    std::generate(x.begin(), x.end(), rd);\n    max[0] = x;\n    min[0].resize(n);\n    for (int i = 0; i < n; ++i) min[0][i] = i;\n    for (int i = 0; (2 << i) <= n; ++i) {\n      int m = n - (2 << i) + 1;\n      min[i + 1].resize(m);\n      max[i + 1].resize(m);\n      for (int j = 0; j < m; ++j) {\n        int u = min[i][j], v = min[i][j + (1 << i)];\n        min[i + 1][j] = x[u] < x[v] ? u : v;\n        max[i + 1][j] = std::max(max[i][j], max[i][j + (1 << i)]);\n      }\n    }\n    dfs(0, n);\n  }\n};\nstruct Point {\n  int type, x, y;\n  bool operator<(const Point &o) const {\n    return x < o.x || (x == o.x && type < o.type);\n  }\n};\nint x;\nlong long ans;\nstd::vector<Point> p;\nvoid dc(int l, int r) {\n  if (r - l == 1) return;\n  int mid = (l + r) / 2;\n  dc(l, mid);\n  dc(mid, r);\n  std::vector<Point> q;\n  q.reserve(r - l);\n  int i = l, j = mid, cnt = 0;\n  while (i < mid && j < r) {\n    if (p[i].y < p[j].y || (p[i].y == p[j].y && p[i].type < p[j].type)) {\n      if (!p[i].type) ++cnt;\n      q.push_back(p[i++]);\n    } else {\n      if (p[j].type) ans += cnt;\n      q.push_back(p[j++]);\n    }\n  }\n  while (i < mid) q.push_back(p[i++]);\n  for (; j < r; q.push_back(p[j++])) {\n    if (p[j].type) ans += cnt;\n  }\n  std::copy(q.begin(), q.end(), p.begin() + l);\n}\nint main() {\n  int n = rd(), m = rd();\n  x = rd();\n  Group ver(n), hor(m);\n  p.resize(n + m);\n  for (int i = 0; i < n; ++i) p[i] = {0, x - ver.y[i] + 1, x - ver.x[i] + 1};\n  for (int i = 0; i < m; ++i) p[n + i] = {1, hor.x[i], hor.y[i]};\n  std::sort(p.begin(), p.end());\n  dc(0, n + m);\n  std::sort(ver.x.begin(), ver.x.end());\n  std::sort(hor.x.begin(), hor.x.end());\n  int j = m;\n  for (int i : ver.x) {\n    while (j > 0 && i + hor.x[j - 1] > x) --j;\n    ans -= m - j;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid enable_comma() {}\nstring tostring(char c) {\n  string s = \"\";\n  s += c;\n  return s;\n}\nstring tostring(string s) { return \"\\\"\" + s + \"\\\"\"; }\nstring tostring(const char *c) { return tostring((string)c); }\nstring tostring(long long x) {\n  if (x < 0) return \"-\" + tostring(-x);\n  if (x > 9)\n    return tostring(x / 10) + tostring(char('0' + x % 10));\n  else\n    return tostring(char('0' + x));\n}\nstring tostring(int x) { return tostring((long long)x); }\nstring tostring(unsigned long long x) {\n  if (x > 9)\n    return tostring((long long)(x / 10)) + tostring(char('0' + x % 10));\n  else\n    return tostring(char('0' + x));\n}\nstring tostring(unsigned x) { return tostring((long long)x); }\nstring tostring(double x) {\n  static char res[114];\n  sprintf(res, \"%lf\", x);\n  string s = tostring(res);\n  return s.substr(1, (int)s.size() - 2);\n}\nstring tostring(long double x) { return tostring((double)x); }\ntemplate <class A, class B>\nstring tostring(pair<A, B> p) {\n  return \"(\" + tostring(p.first) + \",\" + tostring(p.second) + \")\";\n}\ntemplate <class T>\nstring tostring(T v) {\n  string res = \"\";\n  for (auto p : v) res += (res.size() ? \",\" : \"{\") + tostring(p);\n  return res.size() ? res + \"}\" : \"{}\";\n}\ntemplate <class A>\nstring tostring(A *a, int L, int R) {\n  return tostring(vector<A>(a + L, a + R + 1));\n};\ntemplate <class A>\nstring tostring(A a, int L, int R) {\n  return tostring(a.data(), L, R);\n}\nstring tostrings() { return \"\"; }\ntemplate <typename Head, typename... Tail>\nstring tostrings(Head H, Tail... T) {\n  return tostring(H) + \" \" + tostrings(T...);\n}\nlong long read() {\n  long long x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f = ch == '-', ch = getchar();\n  while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n  return f ? -x : x;\n}\ntemplate <class T>\nvoid ckmax(T &x, const T y) {\n  if (x < y) x = y;\n}\ntemplate <class T>\nvoid ckmin(T &x, const T y) {\n  if (x > y) x = y;\n}\nconst int N = 200005;\nint n, m, x;\nint a[N], b[N], alim[N], blim[N];\nvoid get_lim(int n, int *a, int *alim) {\n  for (int i = (1); i <= (n); i++) a[i] = read(), alim[i] = x;\n  vector<pair<int, int> > st = {make_pair(0, 0)};\n  for (int i = (1); i <= (n); i++) {\n    pair<int, int> t = make_pair(i, a[i]);\n    while (a[i] < a[st.back().first]) {\n      ckmin(alim[st.back().first], t.second);\n      ckmax(t.second, st.back().second);\n      st.pop_back();\n    }\n    if (st.size() > 1) ckmin(alim[i], t.second);\n    st.push_back(t);\n  }\n}\nint _c0[N], _c1[N];\nvoid add(int *c, int x) {\n  for (; x < N; x += x & -x) c[x]++;\n}\nint ask(int *c, int x) {\n  int ans = 0;\n  for (; x; x -= x & -x) ans += c[x];\n  return ans;\n}\nint main() {\n  n = read(), m = read(), x = read();\n  get_lim(n, a, alim);\n  get_lim(m, b, blim);\n  enable_comma();\n  enable_comma();\n  vector<pair<int, int> > v;\n  for (int i = (1); i <= (n); i++)\n    if (a[i] < alim[i]) v.push_back(make_pair(a[i], alim[i]));\n  for (int i = (1); i <= (m); i++)\n    if (b[i] < blim[i]) v.push_back(make_pair(-b[i], blim[i]));\n  enable_comma();\n  sort(v.begin(), v.end(), [&](pair<int, int> a, pair<int, int> b) {\n    return a.second - abs(a.first) > b.second - abs(b.first);\n  });\n  long long ans = 0;\n  for (auto p : v) {\n    int v = abs(p.first), lim = p.second;\n    int *c0 = _c0, *c1 = _c1;\n    if (p.first < 0) swap(c0, c1);\n    ans += ask(c1, x - v) - ask(c1, x - lim);\n    add(c0, v);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint a[N], b[N], na[N], nb[N], t1[N], t2[N], c[N], tp, q[N], mx[N], x, n, m, i,\n    j;\nlong long ans;\nvoid init(int* a, int* ans, int n) {\n  memset(ans, 0x3f, (n + 3) << 2);\n  tp = 0;\n  for (i = 1; i <= n; ++i) {\n    j = a[i];\n    while (tp && a[i] < a[q[tp]]) j = max(j, mx[tp--]);\n    if (tp) ans[i] = min(ans[i], j);\n    q[++tp] = i;\n    mx[tp] = j;\n  }\n  tp = 0;\n  for (i = n; i; --i) {\n    j = a[i];\n    while (tp && a[i] <= a[q[tp]]) j = max(j, mx[tp--]);\n    if (tp) ans[i] = min(ans[i], j);\n    q[++tp] = i;\n    mx[tp] = j;\n  }\n}\nvoid A(int x, int C) {\n  while (x < N) {\n    c[x] += C;\n    x += x & -x;\n  }\n}\nint Q(int x, int C = 0) {\n  while (x > 0) {\n    C += c[x];\n    x -= x & -x;\n  }\n  return C;\n}\nint main() {\n  cin >> n >> m >> x;\n  for (i = 1; i <= n; ++i) {\n    cin >> a[i];\n    t1[i] = i;\n  }\n  for (i = 1; i <= m; ++i) {\n    cin >> b[i];\n    t2[i] = i;\n  }\n  init(a, na, n);\n  init(b, nb, m);\n  sort(t1 + 1, t1 + n + 1, [&](int x, int y) { return a[x] < a[y]; });\n  sort(t2 + 1, t2 + m + 1, [&](int x, int y) { return nb[x] < nb[y]; });\n  for (i = 1, j = m; i <= n; ++i) {\n    while (j && a[t1[i]] + nb[t2[j]] > x) A(b[t2[j--]], 1);\n    ans += Q(x - a[t1[i]]) - Q(x - na[t1[i]]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200010;\nint n, m, X, a[maxn], b[maxn], c[maxn], d[maxn], tr[maxn];\nlong long ans;\nvector<int> M[maxn];\nvector<pair<int, int>> Q[maxn];\nvoid add(int p) {\n  for (; p <= X; p += p & -p) tr[p]++;\n}\nint sum(int p) {\n  int s = 0;\n  for (; p; p -= p & -p) s += tr[p];\n  return s;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &X);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]), a[i] = min(a[i], X);\n  }\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d\", &b[i]), b[i] = min(b[i], X);\n  }\n  auto init = [&](int n, int *a, int *c) {\n    static int mx[20][maxn], lb[maxn], rb[maxn];\n    for (int i = 1; i <= n; i++) {\n      mx[0][i] = a[i], lb[i] = rb[i] = 0;\n    }\n    for (int i = 1; i < 20; i++) {\n      for (int j = 1; j + (1 << i) - 1 <= n; j++) {\n        mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n    auto query = [&](int l, int r) {\n      int k = log2(r - l + 1);\n      return max(mx[k][l], mx[k][r - (1 << k) + 1]);\n    };\n    stack<int> st;\n    for (int i = 1; i <= n; i++) {\n      while (!st.empty() && a[st.top()] > a[i]) rb[st.top()] = i, st.pop();\n      if (!st.empty()) lb[i] = st.top();\n      st.push(i);\n    }\n    for (int i = 1; i <= n; i++) {\n      c[i] = min(!lb[i] ? X : query(lb[i], i), !rb[i] ? X : query(i, rb[i]));\n    }\n  };\n  init(n, a, c), init(m, b, d);\n  for (int i = 1; i <= n; i++) {\n    Q[X - c[i]].emplace_back(a[i], -1);\n    Q[X - a[i]].emplace_back(a[i], 1);\n  }\n  for (int i = 1; i <= m; i++) {\n    M[b[i]].push_back(X - d[i] + 1);\n  }\n  for (int i = 0; i < X; i++) {\n    for (int d : M[i]) add(d);\n    for (auto p : Q[i]) ans += p.second * sum(p.first);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &f) {\n  f = 0;\n  T fu = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') {\n      fu = -1;\n    }\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    f = (f << 3) + (f << 1) + (c & 15);\n    c = getchar();\n  }\n  f *= fu;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + 48);\n  else\n    print(x / 10), putchar(x % 10 + 48);\n}\ntemplate <typename T>\nvoid print(T x, char t) {\n  print(x);\n  putchar(t);\n}\nconst int N = 2e5 + 5;\nstruct seg {\n  int l, r, mn;\n  seg(int a = 0, int b = 0, int c = 0) : l(a), r(b), mn(c) {}\n  bool operator<(const seg A) const { return mn < A.mn; }\n} se[N];\nset<int> all;\nset<int>::iterator it;\nint a[N], b[N], id[N], mx[N][20], mn[N][20], mnb[N][20], lg[N], f[N];\nint n, m, x, len;\nlong long ans;\nvoid add(int x, int y) {\n  while (x <= 200000) {\n    f[x] += y;\n    x += (x & -x);\n  }\n}\nint query(int x) {\n  int ans = 0;\n  while (x) {\n    ans += f[x];\n    x &= (x - 1);\n  }\n  return ans;\n}\nbool cmp(int i, int j) { return b[i] > b[j]; }\nint qmax(int l, int r) {\n  int k = lg[r - l + 1];\n  if (a[mx[l][k]] > a[mx[r - (1 << k) + 1][k]]) return mx[l][k];\n  return mx[r - (1 << k) + 1][k];\n}\nint qmin(int l, int r) {\n  int k = lg[r - l + 1];\n  if (a[mn[l][k]] < a[mn[r - (1 << k) + 1][k]]) return mn[l][k];\n  return mn[r - (1 << k) + 1][k];\n}\nint qminb(int l, int r) {\n  int k = lg[r - l + 1];\n  if (b[mnb[l][k]] < b[mnb[r - (1 << k) + 1][k]]) return mnb[l][k];\n  return mnb[r - (1 << k) + 1][k];\n}\nvoid solve(int l, int r) {\n  if (l > r) return;\n  se[++len] = seg(l, r, a[qmin(l, r)]);\n  int pos = qmax(l, r);\n  solve(l, pos - 1);\n  solve(pos + 1, r);\n}\nvoid gao(int l, int r, int opt) {\n  if (l > r) return;\n  int val = b[qminb(l, r)];\n  add(val, opt);\n}\nint main() {\n  read(n);\n  read(m);\n  read(x);\n  for (int i = 1; i <= n; i++) read(a[i]), mx[i][0] = mn[i][0] = i;\n  for (int i = 1; i <= m; i++) read(b[i]), mnb[i][0] = i, id[i] = i;\n  sort(id + 1, id + m + 1, cmp);\n  lg[0] = -1;\n  for (int i = 1; i <= 200000; i++) lg[i] = lg[i >> 1] + 1;\n  for (int j = 1; j <= 19; j++) {\n    for (int i = 1; i <= n - (1 << j) + 1; i++) {\n      if (a[mx[i][j - 1]] > a[mx[i + (1 << (j - 1))][j - 1]])\n        mx[i][j] = mx[i][j - 1];\n      else\n        mx[i][j] = mx[i + (1 << (j - 1))][j - 1];\n      if (a[mn[i][j - 1]] < a[mn[i + (1 << (j - 1))][j - 1]])\n        mn[i][j] = mn[i][j - 1];\n      else\n        mn[i][j] = mn[i + (1 << (j - 1))][j - 1];\n    }\n    for (int i = 1; i <= m - (1 << j) + 1; i++) {\n      if (b[mnb[i][j - 1]] < b[mnb[i + (1 << (j - 1))][j - 1]])\n        mnb[i][j] = mnb[i][j - 1];\n      else\n        mnb[i][j] = mnb[i + (1 << (j - 1))][j - 1];\n    }\n  }\n  solve(1, n);\n  sort(se + 1, se + len + 1);\n  all.insert(0);\n  all.insert(m + 1);\n  gao(1, m, 1);\n  for (int i = 1, j = 1; i <= len; i++) {\n    while (j <= m && b[id[j]] + se[i].mn > x) {\n      it = all.lower_bound(id[j]);\n      int r = *it;\n      --it;\n      int l = *it;\n      gao(l + 1, r - 1, -1);\n      gao(l + 1, id[j] - 1, 1);\n      gao(id[j] + 1, r - 1, 1);\n      all.insert(id[j]);\n      ++j;\n    }\n    int lim = N;\n    if (se[i].l != 1) lim = min(lim, a[se[i].l - 1]);\n    if (se[i].r != n) lim = min(lim, a[se[i].r + 1]);\n    int l = max(1, x - lim + 1), r = x - a[qmax(se[i].l, se[i].r)];\n    if (l <= r) ans += query(r) - query(l - 1);\n  }\n  print(ans, '\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconstexpr long long mod = 1000000007;\nconst long long INF = mod * mod;\nconst long double eps = 1e-12;\nconst long double pi = acosl(-1.0);\nlong long mod_pow(long long x, long long n, long long m = mod) {\n  if (n < 0) {\n    long long res = mod_pow(x, -n, m);\n    return mod_pow(res, m - 2, m);\n  }\n  if (abs(x) >= m) x %= m;\n  if (x < 0) x += m;\n  long long res = 1;\n  while (n) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\nstruct modint {\n  long long n;\n  modint() : n(0) { ; }\n  modint(long long m) : n(m) {\n    if (n >= mod)\n      n %= mod;\n    else if (n < 0)\n      n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) {\n  a.n += b.n;\n  if (a.n >= mod) a.n -= mod;\n  return a;\n}\nmodint operator-=(modint& a, modint b) {\n  a.n -= b.n;\n  if (a.n < 0) a.n += mod;\n  return a;\n}\nmodint operator*=(modint& a, modint b) {\n  a.n = ((long long)a.n * b.n) % mod;\n  return a;\n}\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, long long n) {\n  if (n == 0) return modint(1);\n  modint res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\nlong long inv(long long a, long long p) {\n  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) {\n  a = a / b;\n  return a;\n}\nconst int max_n = 1 << 2;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n  fact[0] = modint(1);\n  for (int i = 0; i < max_n - 1; i++) {\n    fact[i + 1] = fact[i] * modint(i + 1);\n  }\n  factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n  for (int i = max_n - 2; i >= 0; i--) {\n    factinv[i] = factinv[i + 1] * modint(i + 1);\n  }\n}\nmodint comb(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[a - b];\n}\nstruct BIT {\n private:\n  vector<int> node;\n  int n;\n\n public:\n  int f(int a, int b) { return a + b; }\n  void init(int n_) {\n    n = n_;\n    node.resize(n, 0);\n  }\n  int query(int a) {\n    int ret = 0;\n    for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1) ret = f(ret, node[i]);\n    return ret;\n  }\n  int query(int a, int b) { return query(b) - query(a); }\n  void update(int a, int b) {\n    for (int i = a; i < n; i |= i + 1) node[i] = f(node[i], b);\n  }\n};\nstruct BIT2 {\n private:\n  vector<BIT> node;\n  int sz;\n  vector<vector<int>> vy;\n\n public:\n  int f(int a, int b) { return a + b; }\n  void init(int n) {\n    sz = n;\n    node.resize(n);\n    vy.resize(n);\n  }\n  void add(int x, int y) {\n    for (int i = x; i < sz; i |= i + 1) {\n      vy[i].push_back(y);\n    }\n  }\n  void complete() {\n    for (int i = 0; i < sz; i++) {\n      sort(vy[i].begin(), vy[i].end());\n      vector<int> cop = vy[i];\n      vy[i].erase(unique(vy[i].begin(), vy[i].end()), vy[i].end());\n      int siz = vy[i].size();\n      node[i].init(siz);\n    }\n  }\n  int query(int x, int y) {\n    int ret = 0;\n    for (int i = x - 1; i >= 0; i = (i & (i + 1)) - 1) {\n      int idy = lower_bound(vy[i].begin(), vy[i].end(), y) - vy[i].begin();\n      ret = f(ret, node[i].query(idy));\n    }\n    return ret;\n  }\n  int query(int lx, int rx, int y) { return query(rx, y) - query(lx, y); }\n  void update(int x, int y, int k) {\n    for (int i = x; i < sz; i |= i + 1) {\n      int idy = lower_bound(vy[i].begin(), vy[i].end(), y) - vy[i].begin();\n      node[i].update(idy, k);\n    }\n  }\n};\ntemplate <typename T>\nstruct SegT {\n private:\n  int sz;\n  vector<T> node;\n  T init_c;\n  function<T(T, T)> f;\n\n public:\n  SegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n    init_c = _init_c;\n    f = _f;\n    int n = v.size();\n    sz = 1;\n    while (sz < n) sz *= 2;\n    node.resize(2 * sz - 1, init_c);\n    for (int i = 0; i < n; i++) {\n      node[i + sz - 1] = v[i];\n    }\n    for (int i = sz - 1 - 1; i >= 0; i--) {\n      node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n    }\n  }\n  SegT(int n, T _init_c, function<T(T, T)> _f) {\n    init_c = _init_c;\n    f = _f;\n    sz = 1;\n    while (sz < n) sz *= 2;\n    node.resize(2 * sz - 1, init_c);\n  }\n  void update(int k, T a) {\n    k += sz - 1;\n    node[k] = a;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      node[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n    }\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = sz;\n    if (r <= a || b <= l)\n      return init_c;\n    else if (a <= l && r <= b)\n      return node[k];\n    else {\n      T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return f(vl, vr);\n    }\n  }\n};\nusing ar = array<int, 3>;\nvector<ar> mk(vector<int> a, int x) {\n  vector<ar> res;\n  vector<pair<int, int>> ori;\n  for (int i = 0; i < a.size(); i++) ori.push_back({a[i], i});\n  auto f = [&](pair<int, int> a, pair<int, int> b) { return max(a, b); };\n  SegT<pair<int, int>> st(ori, {-mod, -1}, f);\n  auto g = [&](int a, int b) { return min(a, b); };\n  SegT<int> stmi(a, {mod}, g);\n  function<void(int, int)> yaru = [&](int l, int r) {\n    if (l >= r) return;\n    pair<int, int> p = st.query(l, r);\n    ar z;\n    z[0] = stmi.query(l, r);\n    z[1] = p.first;\n    int mi = x + 1;\n    if (l > 0) mi = min(mi, a[l - 1]);\n    if (r < a.size()) mi = min(mi, a[r]);\n    z[2] = mi;\n    res.push_back(z);\n    int id = p.second;\n    yaru(l, id);\n    yaru(id + 1, r);\n  };\n  yaru(0, a.size());\n  return res;\n}\nvoid solve() {\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) cin >> b[i];\n  auto va = mk(a, x);\n  auto vb = mk(b, x);\n  vector<pair<int, int>> qa, qb;\n  for (int i = 0; i < va.size(); i++) {\n    qa.push_back({x - va[i][0], i});\n  }\n  for (int i = 0; i < vb.size(); i++) {\n    qb.push_back({vb[i][2], i});\n  }\n  sort((qa).begin(), (qa).end(), greater<pair<int, int>>());\n  sort((qb).begin(), (qb).end(), greater<pair<int, int>>());\n  BIT2 bt;\n  bt.init(1 << 19);\n  for (int i = 0; i < vb.size(); i++) {\n    bt.add(vb[i][0], vb[i][1]);\n  }\n  bt.complete();\n  int loc = 0;\n  long long ans = 0;\n  for (int i = 0; i < qa.size(); i++) {\n    while (loc < qb.size() && qb[loc].first > qa[i].first) {\n      int id = qb[loc].second;\n      loc++;\n      bt.update(vb[id][0], vb[id][1], 1);\n    }\n    int id = qa[i].second;\n    int l = x - va[id][2] + 1;\n    if (l < 0) l = 0;\n    int r = x - va[id][1] + 1;\n    if (l < r) {\n      int num = bt.query(l, r, x - va[id][0] + 1);\n      ans += num;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint read() {\n  int r = 0, t = 1, c = getchar();\n  while (c < '0' || c > '9') {\n    t = c == '-' ? -1 : 1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    r = (r << 3) + (r << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return r * t;\n}\nconst int N = 400010, M = 200000;\nint n, m, t;\nint a[N], b[N];\nint A[N], B[N];\nstd::vector<int> q[N], Q[N];\nvoid solve(int *a, int n, int *A, int d) {\n  static int s[N], m[N], t;\n  t = 0;\n  for (int i = (1), end_i = (n); i <= end_i; i++) {\n    int M = a[i];\n    while (t && a[i] > a[s[t]]) {\n      M = std::min(M, m[t]);\n      t--;\n    }\n    if (t && d == 0) A[i] = std::min(A[i], ::t - M);\n    while (t && a[i] == a[s[t]]) {\n      M = std::min(M, m[t]);\n      t--;\n    }\n    if (t && d == 1) A[i] = std::min(A[i], ::t - M);\n    t++;\n    s[t] = i;\n    m[t] = M;\n  }\n}\nint s[N];\nvoid Modify(int p, int v) {\n  for (; p <= M; p += p & (-p)) s[p] += v;\n}\nint query(int p) {\n  int ans = 0;\n  p++;\n  for (; p; p &= p - 1) ans += s[p];\n  return ans;\n}\nvoid modify(int l, int r) {\n  l++;\n  r++;\n  Modify(l, 1);\n  Modify(r, -1);\n}\nint main() {\n  n = read();\n  m = read();\n  t = M + M - read();\n  for (int i = (1), end_i = (n); i <= end_i; i++) {\n    a[i] = M - read();\n    A[i] = M + 1;\n  }\n  for (int i = (1), end_i = (m); i <= end_i; i++) {\n    b[i] = M - read();\n    B[i] = M + 1;\n  }\n  solve(a, n, A, 1);\n  std::reverse(a + 1, a + n + 1);\n  std::reverse(A + 1, A + n + 1);\n  solve(a, n, A, 0);\n  std::reverse(a + 1, a + n + 1);\n  std::reverse(A + 1, A + n + 1);\n  solve(b, m, B, 1);\n  std::reverse(b + 1, b + m + 1);\n  std::reverse(B + 1, B + m + 1);\n  solve(b, m, B, 0);\n  std::reverse(b + 1, b + m + 1);\n  std::reverse(B + 1, B + m + 1);\n  for (int i = (1), end_i = (n); i <= end_i; i++) {\n    int l = std::max(t - a[i], 0), r = A[i];\n    if (l < r) {\n      q[l].push_back(a[i]);\n      q[r].push_back(-a[i]);\n    }\n  }\n  for (int i = (1), end_i = (m); i <= end_i; i++) Q[b[i]].push_back(i);\n  long long ans = 0;\n  for (int i = (M + M), end_i = (0); i >= end_i; i--) {\n    for (auto j : Q[i]) {\n      int l = std::max(t - b[j], 0), r = B[j];\n      if (l < r) {\n        modify(l, r);\n      }\n    }\n    for (auto j : q[i]) {\n      int x, y;\n      if (j > 0) {\n        x = 1;\n        y = j;\n      } else {\n        x = -1;\n        y = -j;\n      }\n      ans += x * query(y);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nclass RMQ {\n public:\n  RMQ(int _n) {\n    n = _n;\n    logn = log2(n) + 1;\n    x = vector<int>(n);\n    f = vector<vector<int>>(n, vector<int>(logn));\n  }\n  void Build() {\n    for (int i = 0; i < n; ++i) f[i][0] = i;\n    for (int j = 1; (1 << j) <= n; ++j) {\n      for (int i = 0; i + (1 << j) - 1 < n; ++i) {\n        if (x[f[i][j - 1]] > x[f[i + (1 << (j - 1))][j - 1]]) {\n          f[i][j] = f[i][j - 1];\n        } else {\n          f[i][j] = f[i + (1 << (j - 1))][j - 1];\n        }\n      }\n    }\n  }\n  int Query(int a, int b) {\n    if (a > b) swap(a, b);\n    int k = log2(b - a + 1);\n    if (x[f[a][k]] > x[f[b + 1 - (1 << k)][k]]) {\n      return x[f[a][k]];\n    } else {\n      return x[f[b + 1 - (1 << k)][k]];\n    }\n  }\n  int n, logn;\n  vector<int> x;\n  vector<vector<int>> f;\n};\nclass BIT {\n public:\n  BIT(int _n) : n(_n) { x = vector<int>(_n); }\n  void Insert(int a) {\n    for (int i = a; i < n; i += (i & -i)) x[i] += 1;\n  }\n  int Query(int a) {\n    if (a < 0) return 0;\n    if (a >= n) a = n - 1;\n    int ans = 0;\n    for (int i = a; i > 0; i -= (i & -i)) ans += x[i];\n    return ans;\n  }\n  int n;\n  vector<int> x;\n};\nvector<int> Solve(const vector<int>& x) {\n  int n = x.size();\n  RMQ rmq(n);\n  for (int i = 0; i < n; ++i) rmq.x[i] = x[i];\n  rmq.Build();\n  vector<pair<int, int>> e;\n  for (int i = 0; i < n; ++i) e.push_back({x[i], i});\n  sort(e.begin(), e.end());\n  vector<int> ans(n);\n  set<int> s;\n  for (auto& [xi, i] : e) {\n    auto iter = s.upper_bound(i);\n    ans[i] = 100000000;\n    if (iter != s.end()) {\n      ans[i] = min(ans[i], rmq.Query(i, *iter));\n    }\n    if (iter != s.begin()) {\n      --iter;\n      ans[i] = min(ans[i], rmq.Query(*iter, i));\n    }\n    s.insert(i);\n  }\n  return ans;\n}\nstruct Event {\n  int d, na, a;\n  bool isa;\n  bool operator<(const Event& e) const { return d > e.d; }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, X;\n  cin >> n >> m >> X;\n  vector<int> a(n), b(m);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  for (int i = 0; i < m; ++i) cin >> b[i];\n  vector<int> na = Solve(a);\n  vector<int> nb = Solve(b);\n  BIT ta(200010), tb(200010);\n  vector<Event> e;\n  for (int i = 0; i < n; ++i) {\n    e.push_back({na[i] - a[i], na[i], a[i], true});\n  }\n  for (int i = 0; i < m; ++i) {\n    e.push_back({nb[i] - b[i], nb[i], b[i], false});\n  }\n  sort(e.begin(), e.end());\n  LL ans = 0;\n  for (auto& [d, na, a, isa] : e) {\n    if (isa) {\n      ans += tb.Query(X - a) - tb.Query(X - na);\n      ta.Insert(a);\n    } else {\n      ans += ta.Query(X - a) - ta.Query(X - na);\n      tb.Insert(a);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nconst int maxn = 2e5 + 10;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, x, wa, wb, mxa[maxn], mxb[maxn], a[maxn], b[maxn], tr[maxn];\nstack<int> st;\nint mx[maxn];\ninline void add(int x, int y) {\n  for (int i = x; i <= N; i += i & (-i)) tr[i] += y;\n}\ninline int query(int x) {\n  int res = 0;\n  for (int i = x; i >= 1; i -= i & (-i)) res += tr[i];\n  return res;\n}\ninline void work(int *A, int *MXA, int len, int tag) {\n  memset(mx, 0, sizeof(mx));\n  while (!st.empty()) st.pop();\n  for (int i = 1; i <= len; i++) {\n    while (!st.empty() && A[st.top()] >= A[i] + 1 - tag)\n      mx[i] = max(mx[i], mx[st.top()]), st.pop();\n    st.push(i);\n    mx[i] = max(mx[i], A[i]);\n    if (tag)\n      MXA[i] = (st.size() > 1 ? mx[i] : x);\n    else if (st.size() > 1)\n      MXA[len - i + 1] = min(MXA[len - i + 1], mx[i]);\n  }\n}\nvector<int> I[maxn], D[maxn];\nvector<pair<int, int> > p[maxn];\nint main() {\n  n = read(), m = read(), x = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), wa = max(wa, a[i]);\n  for (int i = 1; i <= m; i++) b[i] = read(), wb = max(wb, b[i]);\n  work(a, mxa, n, 1);\n  reverse(a + 1, a + 1 + n);\n  work(a, mxa, n, 0);\n  reverse(a + 1, a + 1 + n);\n  work(b, mxb, m, 1);\n  reverse(b + 1, b + 1 + m);\n  work(b, mxb, m, 0);\n  reverse(b + 1, b + 1 + m);\n  for (int i = 1; i <= m; i++) {\n    if (b[i] >= x) continue;\n    p[b[i]].push_back(make_pair(x - mxb[i], x - b[i]));\n  }\n  for (int i = 1; i <= n; i++) {\n    int u = max(x - mxa[i] + 1, 1), v = x - a[i];\n    if (a[i] >= x || u > v) continue;\n    I[u].push_back(a[i]), D[v].push_back(a[i]);\n  }\n  long long res = 0;\n  for (int i = 1; i <= wb; i++) {\n    for (int j = 0; j < I[i].size(); j++) add(I[i][j], 1);\n    for (int j = 0; j < p[i].size(); j++)\n      res += query(p[i][j].second) - query(p[i][j].first);\n    for (int j = 0; j < D[i].size(); j++) add(D[i][j], -1);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e5 + 5;\nint n, m, x, a[N], b[N], p[N], L[N], R[N];\nint A[N], B[N], vs[N], fa[N], c[N];\nint find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }\nvoid add(int i, int v) {\n  for (i = 200001 - i; i <= 200000; i += i & -i) c[i] += v;\n}\nint qry(int i, int r = 0) {\n  for (i = 200000 - max(i, 0); i; i &= i - 1) r += c[i];\n  return r;\n}\nint main() {\n  cin >> n >> m >> x;\n  for (int i = (1); i <= (n); i++)\n    scanf(\"%d\", &a[i]), L[i] = R[i] = a[i], A[i] = i;\n  for (int i = (1); i <= (m); i++) scanf(\"%d\", &b[i]), B[i] = i;\n  for (int i = (1); i <= (n); i++) {\n    int& j = p[i] = i - 1;\n    while (j && a[j] > a[i]) L[i] = max(L[i], L[j]), j = p[j];\n    if (!j) L[i] = x;\n  }\n  for (int i = (n); i >= (1); i--) {\n    int& j = p[i] = i + 1;\n    while (j <= n && a[j] >= a[i]) R[i] = max(R[i], R[j]), j = p[j];\n    if (j > n) R[i] = x;\n  }\n  sort(A + 1, A + n + 1,\n       [](int x, int y) { return a[x] ^ a[y] ? a[x] > a[y] : x > y; });\n  sort(B + 1, B + m + 1, [](int x, int y) { return b[x] < b[y]; });\n  int j = 1;\n  ll as = 0;\n  for (int i = (1); i <= (n); i++) {\n    while (j <= m && b[B[j]] + a[A[i]] <= x) {\n      auto mrg = [](int x, int y) {\n        if (!vs[y]) return;\n        x = find(x), y = find(y);\n        if (b[x] > b[y]) swap(x, y);\n        add(b[y], -1), fa[y] = x;\n      };\n      mrg(B[j], B[j] - 1), mrg(B[j], B[j] + 1);\n      add(b[B[j]], 1), vs[B[j++]] = 1;\n    }\n    as += qry(x - min(L[A[i]], R[A[i]]));\n  }\n  cout << as;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint n, m, X, q[N], l[N], r[N];\nint a[N], na[N], b[N], nb[N];\nstruct ZKW {\n  int nn, t[N * 4];\n  void init(int *a, int n) {\n    for (nn = 1; nn <= n; nn <<= 1)\n      ;\n    for (int i = 1; i <= n; i++) t[i + nn] = a[i];\n    for (int i = nn - 1; i >= 1; i--) t[i] = max(t[i * 2], t[i * 2 + 1]);\n  }\n  int ask(int l, int r) {\n    int ans = 0;\n    l += nn - 1;\n    r += nn + 1;\n    for (; l ^ r ^ 1; l >>= 1, r >>= 1) {\n      if (!(l & 1)) ans = max(ans, t[l ^ 1]);\n      if (r & 1) ans = max(ans, t[r ^ 1]);\n    }\n    return ans;\n  }\n} T1;\nvoid init(int *a, int *na, int n) {\n  int t = q[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    for (; t && a[i] <= a[q[t]]; --t) r[q[t]] = i;\n    l[i] = q[t];\n    q[++t] = i;\n  }\n  for (; t; --t) r[q[t]] = n + 1;\n  T1.init(a, n);\n  for (int i = 1; i <= n; i++) {\n    int v1, v2;\n    if (l[i] == 1 - 1)\n      v1 = N;\n    else\n      v1 = (l[i] == i - 1 ? a[i] : T1.ask(l[i] + 1, i - 1));\n    if (r[i] == n + 1)\n      v2 = N;\n    else\n      v2 = (r[i] == i + 1 ? a[i] : T1.ask(i + 1, r[i] - 1));\n    na[i] = min(v1, v2);\n  }\n}\npair<int, int> qa[N], qb[N];\nint t[N * 2];\nvoid change(int x) {\n  for (; x < N * 2; x += x & (-x)) t[x]++;\n}\nint ask(int x) {\n  int s = 0;\n  for (; x; x -= x & (-x)) s += t[x];\n  return s;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &X);\n  ++X;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= m; i++) scanf(\"%d\", &b[i]);\n  init(a, na, n);\n  init(b, nb, m);\n  for (int i = 1; i <= n; i++) qa[i] = pair<int, int>(na[i] - a[i], a[i]);\n  for (int i = 1; i <= m; i++) qb[i] = pair<int, int>(nb[i] - b[i], b[i]);\n  sort(qa + 1, qa + n + 1);\n  sort(qb + 1, qb + m + 1);\n  long long ans = 0;\n  int pa = n, pb = m;\n  for (; pa >= 1 || pb >= 1;)\n    if (pb < 1 || (pa >= 1 && qa[pa].first > qb[pb].first)) {\n      int r = X - qa[pa].second - 1;\n      int l = r + 1 - qa[pa].first;\n      if (r >= 1) ans += ask(r);\n      if (l >= 1) ans -= ask(l - 1);\n      pa--;\n    } else {\n      change(qb[pb].second);\n      pb--;\n    }\n  memset(t, 0, sizeof(t));\n  pa = n;\n  pb = m;\n  for (; pa >= 1 || pb >= 1;)\n    if (pa < 1 || (pb >= 1 && qb[pb].first >= qa[pa].first)) {\n      int r = X - qb[pb].second - 1;\n      int l = r + 1 - qb[pb].first;\n      if (r >= 1) ans += ask(r);\n      if (l >= 1) ans -= ask(l - 1);\n      pb--;\n    } else {\n      change(qa[pa].second);\n      pa--;\n    }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T>\nvoid read(T &x) {\n  char ch;\n  x = 0;\n  int f = 1;\n  while (isspace(ch = getchar_unlocked()))\n    ;\n  if (ch == '-') ch = getchar_unlocked(), f = -1;\n  do x = x * 10 + (ch - '0');\n  while (isdigit(ch = getchar_unlocked()));\n  x *= f;\n}\ntemplate <class T, class... A>\nvoid read(T &x, A &...args) {\n  read(x);\n  read(args...);\n}\nconst int N = 200005;\nint a[N], b[N];\nstruct stack_elem {\n  int val, mx;\n  stack_elem() = default;\n  stack_elem(int _v, int _m) : val(_v), mx(_m) {}\n};\nvector<stack_elem> S;\nint bound[N];\nstruct suffix_bit {\n  int t[N];\n  void insert(int p, int v) {\n    for (; p; p ^= p & -p) t[p] += v;\n  }\n  int query(int p) {\n    int s = 0;\n    for (; p < N; p += p & -p) s += t[p];\n    return s;\n  }\n} T;\nint fa[N], mn[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid join(int x, int y) {\n  x = find(x);\n  y = find(y);\n  fa[x] = y;\n  if (mn[x] <= mn[y])\n    T.insert(mn[y], -1);\n  else\n    T.insert(mn[x], -1);\n  mn[y] = min(mn[y], mn[x]);\n}\nint main() {\n  int n, m, lim;\n  read(n, m, lim);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  for (int i = 1; i <= m; ++i) read(b[i]);\n  memset(bound, 0x3f, sizeof(bound));\n  for (int i = 1; i <= n; ++i) {\n    S.emplace_back(a[i], a[i]);\n    while (S.size() > 1 && S.back().val < end(S)[-2].val) {\n      int mx = max(S.back().mx, end(S)[-2].mx);\n      S.pop_back();\n      S.back().val = a[i];\n      S.back().mx = mx;\n    }\n    if (S.size() > 1) bound[i] = min(bound[i], S.back().mx);\n  }\n  S.clear();\n  for (int i = n; i >= 1; --i) {\n    S.emplace_back(a[i], a[i]);\n    while (S.size() > 1 && S.back().val <= end(S)[-2].val) {\n      int mx = max(S.back().mx, end(S)[-2].mx);\n      S.pop_back();\n      S.back().val = a[i];\n      S.back().mx = mx;\n    }\n    if (S.size() > 1) bound[i] = min(bound[i], S.back().mx);\n  }\n  vector<int> P(n), Q(m);\n  iota(begin(P), end(P), 1);\n  sort(begin(P), end(P), [](int x, int y) { return a[x] > a[y]; });\n  iota(begin(Q), end(Q), 1);\n  sort(begin(Q), end(Q), [](int x, int y) { return b[x] < b[y]; });\n  auto it = begin(Q);\n  ll res = 0;\n  for (int i : P) {\n    for (; it != end(Q) && a[i] + b[*it] <= lim; ++it) {\n      fa[*it] = *it;\n      mn[*it] = b[*it];\n      T.insert(b[*it], 1);\n      if (fa[*it - 1]) join(*it, *it - 1);\n      if (fa[*it + 1]) join(*it, *it + 1);\n    }\n    int L = max(lim - bound[i], 0);\n    res += T.query(L + 1);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int IINF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = numeric_limits<double>::infinity();\nconst double DNAN = numeric_limits<double>::quiet_NaN();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos((double)-1.0);\nconst int DX[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int DY[] = {0, 1, 0, -1, 1, -1, -1, 1};\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long sqr(long long x) { return x * x; }\nlong long sqr(int x) { return (long long)x * x; }\ndouble sqr(double x) { return x * x; }\nmt19937 mmtw(960172);\nlong long rnd(long long x, long long y) {\n  static uniform_int_distribution<long long> d;\n  return d(mmtw) % (y - x + 1) + x;\n}\ntemplate <typename T>\nT& updMin(T& a, T const& b) {\n  if (b < a) a = b;\n  return a;\n}\ntemplate <typename T>\nT& updMax(T& a, T const& b) {\n  if (a < b) a = b;\n  return a;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, vector<T>& a) {\n  for (T& x : a) in >> x;\n  return in;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, vector<T> const& a) {\n  bool f = true;\n  for (T const& x : a) {\n    if (!f) out << \" \";\n    f = false;\n    out << x;\n  }\n  return out;\n}\ntemplate <typename T>\nbool isZero(T const& x) {\n  return x == T(0);\n}\nbool isZero(float x) { return abs(x) < EPS; }\nbool isZero(double x) { return abs(x) < EPS; }\nbool isZero(long double x) { return abs(x) < EPS; }\ntemplate <typename A, typename B>\nistream& operator>>(istream& in, pair<A, B>& p) {\n  return in >> p.first >> p.second;\n}\ntemplate <typename A, typename B>\nostream& operator<<(ostream& out, pair<A, B> const& p) {\n  return out << p.first << \" \" << p.second;\n}\ntemplate <typename T>\nstruct Fen {\n  vector<T> t;\n  Fen(int n) : t(n, T(0)) {}\n  void add(int p, T x) {\n    for (; p < ((int)((t).size())); p |= p + 1) t[p] += x;\n  }\n  T sum(int p) {\n    T s = 0;\n    for (p = min(p, ((int)((t).size()))) - 1; p >= 0; p = (p & (p + 1)) - 1)\n      s += t[p];\n    return s;\n  }\n  T sum(int l, int r) { return l < r ? sum(r) - sum(l) : T(0); }\n};\nstruct DSU {\n  vector<int> p;\n  DSU() = default;\n  DSU(int n) : p(n, -1) {}\n  int get(int v) { return p[v] == -1 ? v : p[v] = get(p[v]); }\n  bool merge(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y) return false;\n    p[y] = x;\n    return true;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  int n, m, x;\n  cin >> n >> m >> x;\n  vector<int> a(n), b(m);\n  cin >> a >> b;\n  vector<int> order(n);\n  iota((order).begin(), (order).end(), 0);\n  sort((order).begin(), (order).end(),\n       [&](int x, int y) { return a[x] < a[y]; });\n  DSU dsu(n);\n  vector<int> w(n, -1);\n  struct Query {\n    int x, y;\n    int w;\n  };\n  vector<Query> qs;\n  for (int i : order) {\n    int j1 = (i == 0 ? -1 : w[dsu.get(i - 1)]);\n    int j2 = (i == n - 1 ? -1 : w[dsu.get(i + 1)]);\n    if (j1 == -1 && j2 == -1) {\n      qs.push_back({a[i], a[i], 1});\n    } else if (j1 != -1 && j2 != -1) {\n      int x = a[j1], y = a[j2];\n      if (x > y) swap(x, y);\n      qs.push_back({y, a[i], -1});\n    }\n    w[i] = i;\n    if (j1 != -1 && a[j1] < a[w[i]]) w[i] = j1;\n    if (j2 != -1 && a[j2] < a[w[i]]) w[i] = j2;\n    if (j1 != -1) dsu.merge(i, j1);\n    if (j2 != -1) dsu.merge(i, j2);\n  }\n  long long ans = 0;\n  order.resize(m);\n  iota((order).begin(), (order).end(), 0);\n  sort((order).begin(), (order).end(),\n       [&](int x, int y) { return b[x] < b[y]; });\n  sort((qs).begin(), (qs).end(),\n       [](Query const& a, Query const& b) { return a.x > b.x; });\n  DSU dsu2(m);\n  vector<int> w2(m, -1);\n  Fen<int> fen(200111);\n  int k = 0;\n  for (int ii = 0; ii < m; ++ii) {\n    int i = order[ii];\n    while (k < ((int)((qs).size())) && qs[k].x + b[i] > x) {\n      ans += qs[k].w * fen.sum(x - qs[k].y + 1);\n      ++k;\n    }\n    int j1 = (i == 0 ? -1 : w2[dsu2.get(i - 1)]);\n    int j2 = (i == m - 1 ? -1 : w2[dsu2.get(i + 1)]);\n    w2[i] = i;\n    if (j1 != -1) {\n      fen.add(b[j1], -1);\n      if (b[j1] < b[w2[i]]) w2[i] = j1;\n    }\n    if (j2 != -1) {\n      fen.add(b[j2], -1);\n      if (b[j2] < b[w2[i]]) w2[i] = j2;\n    }\n    if (j1 != -1) dsu2.merge(i, j1);\n    if (j2 != -1) dsu2.merge(i, j2);\n    fen.add(b[w2[i]], 1);\n  }\n  while (k < ((int)((qs).size()))) {\n    ans += qs[k].w * fen.sum(x - qs[k].y + 1);\n    ++k;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int w = 0, flg = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      flg = -1;\n    }\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') {\n    w = w * 10 + ch - '0', ch = getchar();\n  }\n  return w * flg;\n}\nint lg[200010];\nstruct st_list {\n  int mx[200010][20];\n  void init(int *a, int n) {\n    for (int i = (1); i <= (n); i++) mx[i][0] = a[i];\n    for (int j = (1); j <= (19); j++)\n      for (int i = (1); i <= (n + 1 - (1 << j)); i++)\n        mx[i][j] = max(mx[i][j - 1], mx[i + (1 << (j - 1))][j - 1]);\n  }\n  int query(int ql, int qr) {\n    int base = lg[qr - ql + 1];\n    return max(mx[ql][base], mx[qr - (1 << base) + 1][base]);\n  }\n} Ta, Tb;\nint sta[200010], tpf;\nvoid stawork(int *a, int *l, int *r, int n) {\n  tpf = 0;\n  for (int i = (1); i <= (n); i++) {\n    while (tpf && a[sta[tpf]] > a[i]) r[sta[tpf]] = i - 1, tpf--;\n    l[i] = sta[tpf] + 1, sta[++tpf] = i;\n  }\n  while (tpf) r[sta[tpf]] = n, tpf--;\n}\nint tot;\nstruct Query {\n  int opt, pos, x, y;\n} que[200010 * 8];\nbool cmp(Query x, Query y) {\n  if (x.pos < y.pos) return true;\n  if (x.pos > y.pos) return false;\n  if (x.opt < y.opt) return true;\n  return false;\n}\nint n, m, X, a[200010], b[200010], La[200010], Lb[200010], Ra[200010],\n    Rb[200010];\nlong long ans;\nint fw[200010];\nint lbt(int x) { return x & (-x); }\nvoid update(int x, int d) {\n  for (; x <= X; x += lbt(x)) fw[x] += d;\n}\nint query(int x) {\n  int ret = 0;\n  for (; x; x -= lbt(x)) ret += fw[x];\n  return ret;\n}\nint main() {\n  n = read() + 2, m = read() + 2, X = read(), lg[0] = -1,\n  a[1] = a[n] = b[1] = b[m] = 0x3f3f3f3f;\n  for (int i = (1); i <= (max(n, m)); i++) lg[i] = lg[i >> 1] + 1;\n  for (int i = (2); i <= (n - 1); i++) a[i] = read();\n  for (int i = (2); i <= (m - 1); i++) b[i] = read();\n  Ta.init(a, n), Tb.init(b, m);\n  stawork(a, La, Ra, n), stawork(b, Lb, Rb, m);\n  for (int i = (2); i <= (n - 1); i++) {\n    La[i] = max(0, X - min(Ta.query(La[i], i), Ta.query(i, Ra[i])));\n    Ra[i] = max(0, X - a[i]);\n    que[++tot].opt = 1, que[tot].pos = a[i], que[tot].x = La[i],\n    que[tot].y = Ra[i];\n  }\n  for (int i = (2); i <= (m - 1); i++) {\n    Lb[i] = max(0, X - min(Tb.query(Lb[i], i), Tb.query(i, Rb[i])));\n    Rb[i] = max(0, X - b[i]);\n    que[++tot].opt = 2, que[tot].pos = Lb[i], que[tot].x = b[i], que[tot].y = 1;\n    que[++tot].opt = 2, que[tot].pos = Rb[i], que[tot].x = b[i],\n    que[tot].y = -1;\n  }\n  sort(que + 1, que + tot + 1, cmp);\n  for (int i = (1); i <= (tot); i++) {\n    Query p = que[i];\n    if (p.opt == 1)\n      ans += query(p.y) - query(p.x);\n    else\n      update(p.x, p.y);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint a[N], b[N], na[N], nb[N], t1[N], t2[N], c[N], tp, q[N], mx[N], x, n, m, i,\n    j;\nlong long ans;\nvoid init(int* a, int* ans, int n) {\n  for (memset(ans, 0x3f, (n + 3) << 2), tp = 0, i = 1; i <= n; ++i) {\n    j = a[i];\n    while (tp && a[i] < a[q[tp]]) j = max(j, mx[tp--]);\n    if (tp) ans[i] = min(ans[i], j);\n    q[++tp] = i;\n    mx[tp] = j;\n  }\n  for (tp = 0, i = n; i; --i) {\n    j = a[i];\n    while (tp && a[i] <= a[q[tp]]) j = max(j, mx[tp--]);\n    if (tp) ans[i] = min(ans[i], j);\n    q[++tp] = i;\n    mx[tp] = j;\n  }\n}\nvoid A(int x, int C) {\n  while (x < N) c[x] += C, x += x & -x;\n}\nint Q(int x, int C = 0) {\n  while (x > 0) C += c[x], x -= x & -x;\n  return C;\n}\nint main() {\n  for (scanf(\"%d%d%d\", &n, &m, &x), i = 1; i <= n; ++i)\n    scanf(\"%d\", a + i), t1[i] = i;\n  for (i = 1; i <= m; ++i) scanf(\"%d\", b + i), t2[i] = i;\n  init(a, na, n);\n  init(b, nb, m);\n  sort(t1 + 1, t1 + n + 1, [&](int x, int y) { return a[x] < a[y]; });\n  sort(t2 + 1, t2 + m + 1, [&](int x, int y) { return nb[x] < nb[y]; });\n  for (i = 1, j = m; i <= n; ++i) {\n    while (j && a[t1[i]] + nb[t2[j]] > x) A(b[t2[j--]], 1);\n    ans += Q(x - a[t1[i]]) - Q(x - na[t1[i]]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nint n, m, X, a[N], b[N], ra[N], rb[N], id[N], id1[N], mx[N], mx1[N], stk[N],\n    val[N], top;\nint rk[N], rk1[N];\nlong long ans;\nvoid proc(int n, int *a, int *mx) {\n  top = 0;\n  val[0] = 0x3f3f3f3f;\n  for (int i = 1; i <= n; ++i) {\n    while (top && a[stk[top]] > a[i]) {\n      mx[stk[top]] = std::min(val[top - 1], val[top]), --top;\n      val[top] = std::max(a[stk[top + 1]], std::max(val[top], val[top + 1]));\n    }\n    stk[++top] = i;\n    val[top] = 0;\n  }\n  while (top) mx[stk[top]] = val[top - 1], --top;\n}\nint sum[N], sum1[N];\ninline void add(int p) {\n  while (p <= n) ++sum[p], p += p & (-p);\n}\ninline int ask(int p) {\n  int ret = 0;\n  while (p) ret += sum[p], p -= p & (-p);\n  return ret;\n}\ninline void add1(int p) {\n  while (p <= m) ++sum1[p], p += p & (-p);\n}\ninline int ask1(int p) {\n  int ret = 0;\n  while (p) ret += sum1[p], p -= p & (-p);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &X);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i), mx[i] = a[i], id[i] = i;\n  for (int i = 1; i <= m; ++i) scanf(\"%d\", b + i), mx1[i] = b[i], id1[i] = i;\n  proc(n, a, mx);\n  proc(m, b, mx1);\n  std::sort(id + 1, id + n + 1, [](int x, int y) { return a[x] < a[y]; });\n  for (int i = 1; i <= n; ++i) rk[id[i]] = i, ra[i] = a[id[i]];\n  std::sort(id1 + 1, id1 + m + 1, [](int x, int y) { return b[x] < b[y]; });\n  for (int i = 1; i <= m; ++i) rk1[id1[i]] = i, rb[i] = b[id1[i]];\n  for (int i = 1; i <= n; ++i) mx[i] -= a[i];\n  for (int i = 1; i <= m; ++i) mx1[i] -= b[i];\n  std::sort(id + 1, id + n + 1, [](int x, int y) { return mx[x] > mx[y]; });\n  std::sort(id1 + 1, id1 + m + 1, [](int x, int y) { return mx1[x] > mx1[y]; });\n  int l = 0, r = 0;\n  while (l < n || r < m) {\n    int x = id[l + 1], y = id1[r + 1];\n    if (l < n && (r == m || mx[x] > mx1[y])) {\n      int lw = X - mx[x] - a[x] + 1, up = X - a[x];\n      if (lw <= up) {\n        int l = std::lower_bound(rb + 1, rb + m + 1, lw) - rb,\n            r = std::upper_bound(rb + 1, rb + m + 1, up) - rb - 1;\n        ans += ask1(r) - ask1(l - 1);\n      }\n      add(rk[x]);\n      ++l;\n    } else {\n      int lw = X - mx1[y] - b[y] + 1, up = X - b[y];\n      if (lw <= up) {\n        int l = std::lower_bound(ra + 1, ra + n + 1, lw) - ra,\n            r = std::upper_bound(ra + 1, ra + n + 1, up) - ra - 1;\n        ans += ask(r) - ask(l - 1);\n      }\n      add1(rk1[y]);\n      ++r;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\ntemplate <typename _Tp>\ninline void chmax(_Tp &a, const _Tp &b) {\n  a = a < b ? b : a;\n}\ntemplate <typename _Tp>\ninline void chmin(_Tp &a, const _Tp &b) {\n  a = a < b ? a : b;\n}\nconst int N = 200005;\nint st[N], mx[N], a[N], b[N], na[N], nb[N], t1[N], t2[N];\nvoid init(int *a, int *ans, int n) {\n  memset(ans, 63, (n + 3) << 2);\n  for (int i = 1, top = 0; i <= n; ++i) {\n    int o = a[i];\n    while (top && a[i] < a[st[top]]) chmax(o, mx[top--]);\n    if (top) chmin(ans[i], o);\n    st[++top] = i, mx[top] = o;\n  }\n  for (int i = n, top = 0; i >= 1; --i) {\n    int o = a[i];\n    while (top && a[i] <= a[st[top]]) chmax(o, mx[top--]);\n    if (top) chmin(ans[i], o);\n    st[++top] = i, mx[top] = o;\n  }\n}\nint c[N];\nvoid add(int x, int C) {\n  for (; x < N; x += ((x) & (-(x)))) c[x] += C;\n}\nint ask(int x) {\n  int ans = 0;\n  for (; x > 0; x -= ((x) & (-(x)))) ans += c[x];\n  return ans;\n}\nint main() {\n  int n, m, x;\n  read(n, m, x);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  for (int i = 1; i <= m; ++i) read(b[i]);\n  init(a, na, n), init(b, nb, m), std::iota(t1 + 1, t1 + n + 1, 1),\n      std::iota(t2 + 1, t2 + m + 1, 1);\n  std::sort(t1 + 1, t1 + n + 1, [&](int x, int y) { return a[x] < a[y]; }),\n      std::sort(t2 + 1, t2 + m + 1,\n                [&](int x, int y) { return nb[x] < nb[y]; });\n  long long ans = 0;\n  for (int i = 1, cur = m; i <= n; ++i) {\n    while (cur && a[t1[i]] + nb[t2[cur]] > x) add(b[t2[cur--]], 1);\n    ans += ask(x - a[t1[i]]) - ask(x - na[t1[i]]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readint() {\n  int x = 0;\n  bool f = 0;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') {\n    f = 1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return f ? -x : x;\n}\nconst int maxn = 2e5 + 5;\nint n, m, x, a[maxn], b[maxn], s[maxn], tp = 1, mx[maxn];\nint prea[maxn], suca[maxn], preb[maxn], sucb[maxn];\ninline int lowbit(int x) { return x & -x; }\nint c[maxn];\nvoid modify(int x, int k) {\n  while (x < maxn) {\n    c[x] += k;\n    x += lowbit(x);\n  }\n}\nint query(int x) {\n  int s = 0;\n  while (x) {\n    s += c[x];\n    x -= lowbit(x);\n  }\n  return s;\n}\nvector<int> qa[maxn], qb[maxn];\nint main() {\n  n = readint();\n  m = readint();\n  x = readint();\n  for (int i = 1; i <= n; i++) a[i] = readint();\n  for (int i = 1; i <= m; i++) b[i] = readint();\n  mx[0] = maxn - 1;\n  for (int i = 1; i <= n; i++) {\n    while (a[i] < a[s[tp - 1]]) {\n      mx[tp - 2] = max(mx[tp - 2], mx[tp - 1]);\n      tp--;\n    }\n    prea[i] = max(mx[tp - 1], a[i]);\n    s[tp] = i;\n    mx[tp++] = a[i];\n  }\n  tp = 1;\n  for (int i = 1; i <= m; i++) {\n    while (b[i] < b[s[tp - 1]]) {\n      mx[tp - 2] = max(mx[tp - 2], mx[tp - 1]);\n      tp--;\n    }\n    preb[i] = max(mx[tp - 1], b[i]);\n    s[tp] = i;\n    mx[tp++] = b[i];\n  }\n  s[0] = n + 1;\n  tp = 1;\n  for (int i = n; i > 0; i--) {\n    while (a[i] <= a[s[tp - 1]]) {\n      mx[tp - 2] = max(mx[tp - 2], mx[tp - 1]);\n      tp--;\n    }\n    suca[i] = max(mx[tp - 1], a[i]);\n    s[tp] = i;\n    mx[tp++] = a[i];\n  }\n  s[0] = m + 1;\n  tp = 1;\n  for (int i = m; i > 0; i--) {\n    while (b[i] <= b[s[tp - 1]]) {\n      mx[tp - 2] = max(mx[tp - 2], mx[tp - 1]);\n      tp--;\n    }\n    sucb[i] = max(mx[tp - 1], b[i]);\n    s[tp] = i;\n    mx[tp++] = b[i];\n  }\n  for (int i = 1; i <= n; i++)\n    if (a[i] <= x) qa[x - a[i]].push_back(i);\n  for (int i = 1; i <= m; i++) qb[min(preb[i], sucb[i])].push_back(i);\n  long long ans = 0;\n  for (int i = maxn - 1; i > 0; i--) {\n    for (int j : qa[i])\n      ans += query(x - a[j]) - query(max(x - min(prea[j], suca[j]), 0));\n    for (int j : qb[i]) modify(b[j], 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        }
    ]
}