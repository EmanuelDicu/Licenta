{
    "name": "1552_I. Organizing a Music Festival",
    "source": "CODEFORCES",
    "description": "You are the organizer of the famous \"Zurich Music Festival\". There will be n singers who will perform at the festival, identified by the integers 1, 2, ..., n. You must choose in which order they are going to perform on stage. \n\nYou have m friends and each of them has a set of favourite singers. More precisely, for each 1\u2264 i\u2264 m, the i-th friend likes singers s_{i,1},   s_{i, 2},   ..., \\,s_{i, q_i}.\n\nA friend of yours is happy if the singers he likes perform consecutively (in an arbitrary order). An ordering of the singers is valid if it makes all your friends happy.\n\nCompute the number of valid orderings modulo 998 244 353.\n\nInput\n\nThe first line contains two integers n and m (1\u2264 n,\\,m\u2264 100) \u2014 the number of singers and the number of friends correspondingly.\n\nThe i-th of the next m lines contains the integer q_i (1\u2264 q_i\u2264 n) \u2014 the number of favorite singers of the i-th friend \u2013 followed by the q_i integers s_{i,1},   s_{i, 2},   ..., \\,s_{i, q_i} (1\u2264 s_{i,1}<s_{i,2}<\u22c5\u22c5\u22c5<s_{i,q_i}\u2264 n) \u2014 the indexes of his favorite singers.\n\nOutput\n\nPrint the number of valid orderings of the singers modulo 998 244 353.\n\nExamples\n\nInput\n\n\n3 1\n2 1 3\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n5 5\n2 1 2\n2 2 3\n2 3 4\n2 4 5\n2 1 5\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n100 1\n1 50\n\n\nOutput\n\n\n35305197\n\n\nInput\n\n\n5 1\n5 1 2 3 4 5\n\n\nOutput\n\n\n120\n\n\nInput\n\n\n2 5\n1 2\n1 2\n1 2\n1 1\n1 1\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n11 4\n5 4 5 7 9 11\n2 2 10\n2 9 11\n7 1 2 3 5 8 10 11\n\n\nOutput\n\n\n384\n\nNote\n\nExplanation of the first sample: There are 3 singers and only 1 friend. The friend likes the two singers 1 and 3. Thus, the 4 valid orderings are: \n\n  * 1 3 2\n  * 2 1 3\n  * 2 3 1\n  * 3 1 2\n\n\n\nExplanation of the second sample: There are 5 singers and 5 friends. One can show that no ordering is valid.\n\nExplanation of the third sample: There are 100 singers and only 1 friend. The friend likes only singer 50, hence all the 100! possible orderings are valid.\n\nExplanation of the fourth sample: There are 5 singers and only 1 friend. The friend likes all the singers, hence all the 5!=120 possible orderings are valid.",
    "difficulty": "I",
    "tags": [
        "dfs and similar",
        "math"
    ],
    "rating": 3400,
    "public_test": [
        {
            "input": "5 1\n5 1 2 3 4 5\n",
            "output": "120\n"
        },
        {
            "input": "11 4\n5 4 5 7 9 11\n2 2 10\n2 9 11\n7 1 2 3 5 8 10 11\n",
            "output": "384\n"
        },
        {
            "input": "3 1\n2 1 3\n",
            "output": "4\n"
        },
        {
            "input": "100 1\n1 50\n",
            "output": "35305197\n"
        },
        {
            "input": "2 5\n1 2\n1 2\n1 2\n1 1\n1 1\n",
            "output": "2\n"
        },
        {
            "input": "5 5\n2 1 2\n2 2 3\n2 3 4\n2 4 5\n2 1 5\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "98 10\n2 74 97\n6 1 16 29 75 78 96\n3 67 68 91\n18 12 17 30 33 38 46 50 59 62 64 70 76 82 49 90 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 5 37 45\n",
            "output": "341885784\n"
        },
        {
            "input": "99 20\n5 6 23 84 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 58 76\n1 28\n2 54 71\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "769647115\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 12 13 16 17 19 20 21 23 24 25 26 27 32 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 77 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 12 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "11178854\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 51\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 40\n2 69 82\n1 15\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "724918041\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 42 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 51 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "587364425\n"
        },
        {
            "input": "100 1\n1 95\n",
            "output": "35305197\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "145795764\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 67\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 64 72 76 79 95\n5 31 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "449064000\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 44 50 75 77 82 97\n4 15 20 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "554141469\n"
        },
        {
            "input": "99 20\n5 6 23 60 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 58 76\n1 28\n2 54 35\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "83855401\n"
        },
        {
            "input": "99 20\n1 41\n1 10\n1 7\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "98 30\n2 5 43\n2 74 75\n2 25 75\n2 25 75\n17 9 16 14 15 17 20 21 22 27 29 37 51 59 63 81 84 90\n2 25 75\n2 25 75\n2 25 75\n4 25 60 74 75\n2 25 75\n2 25 75\n2 25 75\n2 25 75\n2 5 43\n2 18 57\n2 25 75\n3 18 33 57\n2 25 75\n2 25 75\n2 25 75\n2 74 75\n2 25 75\n2 25 43\n2 25 75\n2 25 75\n2 25 75\n3 25 74 75\n2 25 75\n7 5 25 43 54 60 74 75\n2 25 75\n",
            "output": "164760027\n"
        },
        {
            "input": "6 1\n5 1 2 3 4 5\n",
            "output": "240\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "969209701\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 3 86 91\n4 8 11 53 71\n",
            "output": "175128372\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 24 62 67\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "506419192\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 20 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "776192911\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 11 92\n5 9 31 56 88 97\n",
            "output": "397546235\n"
        },
        {
            "input": "98 30\n2 5 43\n2 74 75\n2 25 75\n2 25 75\n17 9 16 14 15 17 20 21 22 27 29 37 51 59 63 81 84 90\n2 25 75\n2 25 75\n2 25 75\n4 25 60 74 75\n2 25 75\n2 25 75\n2 25 75\n2 25 75\n2 5 43\n2 28 57\n2 25 75\n3 18 33 57\n2 25 75\n2 25 75\n2 25 75\n2 74 75\n2 25 75\n2 25 43\n2 25 75\n2 25 75\n2 25 75\n3 25 74 75\n2 25 75\n7 5 25 43 54 60 74 75\n2 25 75\n",
            "output": "663226126\n"
        },
        {
            "input": "99 20\n5 6 23 84 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 74 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 1 76\n1 28\n2 54 71\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "869116915\n"
        },
        {
            "input": "99 10\n4 8 43 48 54\n3 31 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 41 91\n4 8 11 53 71\n",
            "output": "551616474\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 77\n5 5 12 24 62 67\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "705101287\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "738855292\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 19 38\n",
            "output": "597136303\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 5 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "990222192\n"
        },
        {
            "input": "98 10\n4 37 47 54 18\n3 11 21 30\n2 44 30\n5 5 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 60 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "247555548\n"
        },
        {
            "input": "99 20\n3 32 40 48\n1 79\n2 34 87\n5 6 16 23 78 92\n2 28 34\n3 41 51 54\n1 57\n3 57 72 79\n3 17 27 93\n5 41 51 54 72 79\n4 8 52 61 94\n5 7 9 38 43 64\n5 44 59 60 69 97\n1 34\n1 54\n2 6 78\n2 19 30\n5 3 42 86 87 98\n2 10 26\n4 25 46 57 72\n",
            "output": "849261363\n"
        },
        {
            "input": "99 20\n5 6 23 60 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 58 76\n1 28\n2 54 71\n2 9 65\n3 42 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "904431583\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 24 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "809712555\n"
        },
        {
            "input": "99 10\n1 28\n1 53\n2 40 43\n1 1\n1 56\n1 9\n2 22 63\n2 65 94\n2 56 74\n2 15 81\n",
            "output": "563870854\n"
        },
        {
            "input": "98 10\n29 10 12 13 15 19 27 32 35 36 37 38 44 45 47 50 57 59 64 65 67 74 77 78 82 85 91 92 93 97\n12 1 12 26 28 48 55 56 61 66 68 69 95\n5 20 39 40 81 88\n4 3 22 51 79\n29 2 5 6 7 8 17 20 23 24 25 29 33 34 39 40 42 43 49 52 70 71 73 76 81 84 88 94 96 98\n11 14 18 41 46 54 58 60 61 83 87 89\n17 4 6 9 11 16 21 30 31 53 62 63 72 75 79 80 86 90\n10 18 41 46 54 58 60 61 83 87 89\n25 2 5 6 7 8 17 20 23 24 25 29 33 34 42 43 49 52 70 71 73 76 84 94 96 98\n5 3 22 51 79 85\n",
            "output": "415234133\n"
        },
        {
            "input": "98 30\n2 5 43\n2 74 75\n2 25 75\n2 25 75\n17 9 10 14 15 17 20 21 22 27 29 37 51 59 63 81 84 90\n2 25 75\n2 25 75\n2 25 75\n4 9 60 74 75\n2 25 75\n2 25 75\n2 25 75\n2 25 75\n2 5 43\n2 18 57\n2 25 75\n3 18 33 57\n2 25 75\n2 25 75\n2 25 75\n2 74 75\n2 25 75\n2 25 43\n2 25 75\n2 25 75\n2 25 75\n3 25 74 75\n2 25 75\n7 5 25 43 54 60 74 75\n2 25 75\n",
            "output": "254387675\n"
        },
        {
            "input": "11 4\n5 4 5 7 9 11\n2 1 10\n2 9 11\n7 1 2 3 5 8 10 11\n",
            "output": "384\n"
        },
        {
            "input": "98 10\n2 74 97\n6 1 21 29 75 78 96\n3 67 68 91\n18 12 17 30 33 38 46 50 59 62 64 70 76 82 49 90 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 5 37 45\n",
            "output": "266893275\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 51\n2 23 32\n2 41 1\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 40\n2 69 82\n1 15\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "333626484\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 7\n5 9 31 56 88 97\n",
            "output": "583183056\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 44 50 75 77 82 97\n4 15 20 25 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "796558885\n"
        },
        {
            "input": "99 20\n5 6 23 60 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 58 76\n1 28\n2 54 35\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 33 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "411105265\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 3\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 15\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "342015520\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 42 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "577752550\n"
        },
        {
            "input": "98 10\n4 35 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 20 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "377092597\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 46 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 19\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "336261583\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 99 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 11 92\n5 9 31 56 88 97\n",
            "output": "168399000\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 55 80 81\n2 33 38\n",
            "output": "196028253\n"
        },
        {
            "input": "99 20\n3 32 40 48\n1 79\n2 34 87\n5 6 16 23 78 92\n2 28 34\n3 41 51 54\n1 57\n3 57 72 79\n3 17 27 93\n5 41 24 54 72 79\n4 8 52 61 94\n5 7 9 38 43 64\n5 44 59 60 69 97\n1 34\n1 54\n2 6 78\n2 19 30\n5 3 42 86 87 98\n2 10 26\n4 25 46 57 72\n",
            "output": "664732220\n"
        },
        {
            "input": "99 10\n4 24 43 48 14\n3 31 66 82\n2 4 91\n5 5 12 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 75 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "902798127\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 44 50 75 77 82 97\n4 11 20 25 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 33 38\n",
            "output": "199422582\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 42 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 21 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "470259921\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 4 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 3 41 91\n4 8 11 53 71\n",
            "output": "521013223\n"
        },
        {
            "input": "99 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 5 38 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "492848210\n"
        },
        {
            "input": "99 10\n1 24\n6 36 28 32 48 92 94\n9 11 61 43 46 64 72 76 79 95\n5 31 95 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 90 77 86 99\n2 11 92\n5 9 31 56 88 97\n",
            "output": "809581986\n"
        },
        {
            "input": "99 20\n1 25\n1 10\n1 7\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 44 92\n2 42 69\n2 2 54\n2 57 79\n1 97\n1 15\n1 52 56\n",
            "output": "773023715\n"
        },
        {
            "input": "99 20\n3 32 40 48\n1 79\n2 34 87\n5 6 16 23 78 92\n2 28 34\n3 41 51 54\n1 57\n3 57 72 79\n3 17 27 93\n5 41 51 54 72 79\n4 8 52 61 94\n5 7 9 38 43 64\n5 33 59 60 69 97\n1 34\n1 54\n2 6 78\n2 19 30\n5 3 42 86 87 98\n2 10 26\n4 25 46 57 16\n",
            "output": "997098330\n"
        },
        {
            "input": "99 20\n5 6 23 60 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 58 76\n1 28\n2 52 71\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "49538505\n"
        },
        {
            "input": "99 20\n1 41\n1 10\n1 7\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 42 56\n",
            "output": "64047172\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 17 20 23 25 26 30 31 41 43 47 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "129056457\n"
        },
        {
            "input": "98 10\n2 74 97\n6 1 16 29 75 78 96\n3 67 68 91\n18 12 20 30 33 38 46 50 59 62 64 70 76 82 49 90 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 4 37 45\n",
            "output": "948853221\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 64 72 76 79 95\n5 31 98 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "97197176\n"
        },
        {
            "input": "6 1\n1 1 3\n",
            "output": "720\n"
        },
        {
            "input": "98 10\n29 10 12 13 15 19 27 32 35 36 20 38 44 45 47 50 57 59 64 65 67 74 77 78 82 85 91 92 93 97\n12 1 13 26 28 48 55 56 61 66 68 69 95\n5 20 39 40 81 88\n4 3 22 51 79\n29 2 5 6 7 8 17 20 23 24 25 29 33 34 39 40 42 43 49 52 70 71 73 76 81 84 88 94 96 98\n11 14 18 41 46 54 58 60 61 83 87 89\n17 4 6 9 11 16 21 30 31 53 62 63 72 75 79 80 86 90\n10 18 41 46 54 58 60 61 83 87 89\n25 2 5 6 7 8 17 20 23 24 25 29 33 34 42 43 49 52 70 71 73 76 84 94 96 98\n5 3 22 51 79 85\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 5 43\n2 74 75\n2 25 75\n2 25 75\n17 9 10 14 15 17 20 21 22 27 29 37 51 59 63 81 84 90\n2 25 75\n2 25 75\n2 25 75\n4 25 60 74 75\n2 25 75\n2 25 75\n2 25 75\n2 25 75\n2 5 43\n2 18 57\n2 25 75\n3 18 33 57\n2 25 75\n2 25 75\n2 25 75\n2 74 75\n2 34 75\n2 25 43\n2 25 75\n2 25 75\n2 25 75\n3 25 74 75\n2 25 75\n7 5 25 43 54 60 74 75\n2 25 75\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 56\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 74 97\n6 1 16 29 75 78 96\n3 67 68 91\n18 12 20 30 33 38 46 50 59 62 64 70 76 82 49 90 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 5 37 45\n",
            "output": "341885784\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 16\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 64 72 76 79 95\n5 31 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 11 31 56 88 97\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 36 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 30\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "98 30\n2 1 36\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 13 51 76\n4 4 30 46 55\n33 1 7 12 13 16 19 25 28 29 34 35 41 42 43 51 56 57 60 62 64 65 79 67 68 70 76 77 82 83 84 87 90 97\n49 2 4 7 9 11 13 16 17 18 19 22 25 28 29 30 32 34 35 38 39 44 45 46 48 49 50 55 56 58 59 61 64 65 67 68 69 72 73 77 82 83 86 88 90 93 95 97 98 99\n2 7 29\n5 42 43 57 66 87\n5 60 62 70 78 80\n4 6 27 79 94\n2 58 69\n1 39\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 33 43 48 54\n3 31 66 82\n2 4 91\n5 6 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 15\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "724918041\n"
        },
        {
            "input": "98 10\n29 10 12 13 15 19 27 32 35 36 37 38 44 45 47 50 57 59 64 65 67 74 77 78 82 85 91 92 93 97\n12 1 13 26 28 48 55 56 61 66 68 69 95\n5 20 39 40 81 88\n4 3 22 51 79\n29 2 5 6 7 8 17 20 23 24 25 29 33 34 39 40 42 43 49 52 70 71 73 76 81 84 88 94 96 98\n11 14 18 41 46 54 16 60 61 83 87 89\n17 4 6 9 11 16 21 30 31 53 62 63 72 75 79 80 86 90\n10 18 41 46 54 58 60 61 83 87 89\n25 2 5 6 7 8 17 20 23 24 25 29 33 34 42 43 49 52 70 71 73 76 84 94 96 98\n5 3 22 51 79 85\n",
            "output": "0\n"
        },
        {
            "input": "6 1\n2 1 3\n",
            "output": "240\n"
        },
        {
            "input": "9 5\n2 1 2\n2 2 3\n2 3 4\n2 4 5\n2 1 5\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n5 6 23 84 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 1 76\n1 28\n2 54 71\n2 9 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "769647115\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 12 13 16 17 19 20 21 23 24 25 26 27 32 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 61 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 12 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 41 91\n4 8 11 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 88\n5 9 31 56 88 97\n",
            "output": "145795764\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 51 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 4 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 74 97\n6 1 16 29 75 78 96\n3 67 68 91\n18 12 20 30 33 38 46 50 59 62 64 70 76 82 49 45 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 5 37 45\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 36\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 32 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 20 72 76 79 95\n5 31 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 11 31 56 88 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n3 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 3 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 30\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 22 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 13 51 76\n4 4 30 46 55\n33 1 7 12 13 16 19 25 28 29 34 2 41 42 43 51 56 57 60 62 64 65 79 67 68 70 76 77 82 83 84 87 90 97\n49 2 4 7 9 11 13 16 17 18 19 22 25 28 29 30 32 34 35 38 39 44 45 46 48 49 50 55 56 58 59 61 64 65 67 68 69 72 73 77 82 83 86 88 90 93 95 97 98 99\n2 7 29\n5 42 43 57 66 87\n5 60 62 70 78 80\n4 6 27 79 94\n2 58 69\n1 39\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 7\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 19\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "98 10\n29 10 12 13 15 19 27 32 35 36 37 38 44 45 47 50 57 59 64 65 67 74 77 78 82 85 91 92 93 97\n12 1 13 26 28 48 55 56 61 66 68 69 95\n5 20 39 40 81 88\n4 3 22 51 79\n29 2 5 6 7 8 17 20 23 24 27 29 33 34 39 40 42 43 49 52 70 71 73 76 81 84 88 94 96 98\n11 14 18 41 46 54 16 60 61 83 87 89\n17 4 6 9 11 16 21 30 31 53 62 63 72 75 79 80 86 90\n10 18 41 46 54 58 60 61 83 87 89\n25 2 5 6 7 8 17 20 23 24 25 29 33 34 42 43 49 52 70 71 73 76 84 94 96 98\n5 3 22 51 79 85\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 12 13 16 17 19 20 21 23 24 25 26 27 61 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 61 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 12 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 4 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 2 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 23\n2 47 51\n2 47 36\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 2 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 32 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 20 72 76 79 95\n5 31 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 12 77 86 99\n2 32 92\n5 11 31 56 88 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 43 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n3 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 13 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 22 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 13 51 76\n4 4 30 46 55\n33 1 7 12 13 16 19 25 28 29 34 2 41 42 43 51 56 57 60 62 64 65 79 67 68 70 76 77 82 83 84 87 90 97\n49 2 4 7 9 11 13 16 17 18 19 22 25 28 29 30 32 34 35 38 39 44 45 46 48 49 50 55 56 58 59 61 64 65 67 68 69 72 73 77 82 83 86 88 90 93 95 97 98 99\n2 7 29\n5 42 43 57 66 87\n5 60 62 70 78 80\n4 6 27 79 37\n2 58 69\n1 39\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 9\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 58 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 19\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "99 10\n1 24\n6 36 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 11 92\n5 9 31 56 88 97\n",
            "output": "397546235\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 15 13 16 17 19 20 21 23 24 25 26 27 61 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 61 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 12 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 8 43 48 54\n3 23 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 41 91\n4 8 11 53 71\n",
            "output": "551616474\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 2 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 62\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 19 38\n",
            "output": "738855292\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 13 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 22 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 42 86\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 9\n1 4\n2 14 96\n2 16 97\n2 4 59\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 15 13 16 17 19 20 21 23 24 25 26 27 61 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 61 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 8 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 45 46 68\n4 8 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 2 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 4 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 13\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 15 1 16 17 19 20 21 23 24 25 26 27 61 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 61 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 8 20 27 50\n9 4 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 45 46 68\n4 8 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 54 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 76\n2 2 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 4 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 78 90 94\n3 29 80 81\n2 32 38\n",
            "output": "597136303\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 45 46 68\n4 8 10 64 92\n4 44 47 50 66\n2 29 42\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 54 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 21 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 66 90 94\n3 29 80 81\n2 32 38\n",
            "output": "597136303\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 85 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 21 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 83\n3 11 21 30\n2 44 51\n5 3 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "597136303\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 85 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 61 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 21 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 85 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 18 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 61 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 21 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 18\n3 11 21 30\n2 44 51\n5 5 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 69 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "990222192\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 85 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 18 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 61 93 97\n19 6 7 10 15 12 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 21 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n4 37 47 54 18\n3 11 21 30\n2 44 51\n5 5 34 35 64 9\n4 2 8 76 91\n8 4 6 20 50 75 77 82 97\n4 15 11 56 90\n11 5 25 31 48 55 60 70 74 66 90 94\n3 29 80 81\n2 32 39\n",
            "output": "990222192\n"
        },
        {
            "input": "99 10\n29 2 6 12 5 19 25 28 32 33 36 37 38 43 48 54 10 57 59 60 68 69 85 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 18 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 61 93 97\n19 6 7 10 15 12 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 16 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 74 97\n6 2 16 29 75 78 96\n3 67 68 91\n18 12 17 30 33 38 46 50 59 62 64 70 76 82 85 90 92 93 98\n2 74 97\n4 5 24 45 47\n6 16 67 75 81 91 96\n2 37 45\n3 5 45 47\n3 5 37 45\n",
            "output": "341885784\n"
        },
        {
            "input": "99 20\n2 43 94\n10 14 35 39 40 54 55 65 82 90 95\n2 38 49\n5 11 17 38 49 52\n1 86\n54 2 3 4 5 6 7 8 9 11 12 13 16 17 19 20 21 23 24 25 26 27 32 33 34 36 37 38 42 43 46 47 49 50 52 53 56 66 68 69 70 71 75 76 77 78 80 83 84 85 87 93 94 97 99\n8 18 37 45 51 64 72 81 93\n2 46 68\n1 29\n10 3 22 25 30 34 48 60 62 67 81\n6 5 8 56 66 69 99\n13 4 5 8 13 24 46 56 66 68 69 89 97 99\n1 98\n2 61 63\n1 98\n8 4 24 46 68 70 76 77 97\n8 16 17 26 32 33 36 42 52\n1 99\n5 6 12 20 27 50\n9 7 8 24 46 68 70 76 77 97\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 6 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 22 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "99 20\n1 41\n1 10\n1 7\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 44 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 56\n",
            "output": "128094344\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 64\n2 19 77\n1 10\n1 77\n1 11\n2 37 51\n2 23 32\n2 41 99\n2 26 68\n2 48 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 37\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 15\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 32 92\n5 9 31 79 88 97\n",
            "output": "397546235\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 52 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 42 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 48 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 51 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "100 1\n1 9\n",
            "output": "35305197\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 7\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 42 45 47 54 10 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 51 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 41\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 5 43\n2 74 75\n2 25 75\n2 25 75\n17 9 10 14 15 17 20 21 22 27 29 37 51 59 63 81 84 90\n2 25 75\n2 25 75\n2 25 75\n4 25 60 74 75\n2 29 75\n2 25 75\n2 25 75\n2 25 75\n2 5 43\n2 18 57\n2 25 75\n3 18 33 57\n2 25 75\n2 25 75\n2 25 75\n2 74 75\n2 34 75\n2 25 43\n2 25 75\n2 25 75\n2 25 75\n3 25 74 75\n2 25 75\n7 5 25 43 54 60 74 75\n2 25 75\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 7\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 56\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "100 1\n1 86\n",
            "output": "35305197\n"
        },
        {
            "input": "99 10\n4 24 43 48 14\n3 31 66 82\n2 4 91\n5 5 12 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 62 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 84\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 64 72 76 79 95\n5 31 52 63 69 97\n2 68 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "449064000\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 79 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 1 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 30\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 65 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "99 10\n4 33 43 48 54\n3 31 66 82\n2 3 91\n5 6 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "175128372\n"
        },
        {
            "input": "99 20\n1 41\n1 10\n1 7\n1 4\n2 14 96\n2 16 25\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 7 92 94\n9 11 38 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 32 92\n5 9 31 56 88 97\n",
            "output": "724918041\n"
        },
        {
            "input": "98 10\n29 10 12 13 15 19 27 32 35 36 37 38 44 45 47 50 57 59 64 65 67 74 77 78 82 85 91 92 93 97\n12 1 13 26 28 48 55 56 61 66 68 69 95\n5 20 39 40 81 88\n4 3 22 51 79\n29 2 5 6 7 8 17 20 23 24 25 29 33 34 39 40 42 43 49 52 70 71 73 44 81 84 88 94 96 98\n11 14 18 41 46 54 16 60 61 83 87 89\n17 4 6 9 11 16 21 30 31 53 62 63 72 75 79 80 86 90\n10 18 41 46 54 58 60 61 83 87 89\n25 2 5 6 7 8 17 20 23 24 25 29 33 34 42 43 49 52 70 71 73 76 84 94 96 98\n5 3 22 51 79 85\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n5 6 23 84 83 95\n7 20 24 54 63 67 68 93\n5 5 14 42 81 97\n3 15 76 88\n9 9 22 34 38 40 44 46 64 65\n3 15 1 76\n1 28\n2 54 71\n2 17 65\n3 26 45 53\n9 9 11 38 40 44 46 49 64 65\n7 11 27 48 49 57 59 82\n2 19 82\n10 5 14 33 41 42 55 69 80 81 97\n6 8 17 25 86 92 98\n3 17 25 86\n8 22 34 38 40 44 46 50 78\n3 9 49 65\n4 13 66 71 72\n7 19 27 32 37 52 82 96\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 3 41 91\n4 8 11 53 71\n",
            "output": "175128372\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 71 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 51 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 98\n2 47 51\n2 47 51\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 4 6 7 8 9 11 14 17 35 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 75 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 13 14 15 19 20 23 25 26 30 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 69 48 54\n3 31 66 82\n2 4 91\n5 5 12 24 62 67\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "506419192\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 46 85\n3 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 3 43 48 54\n3 31 66 82\n2 4 91\n5 5 12 34 62 30\n2 60 76\n4 29 62 92 93\n3 41 48 54\n1 96\n3 4 86 91\n4 8 11 53 71\n",
            "output": "116752248\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 36\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 22 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 13 51 76\n4 4 30 46 55\n33 1 7 12 13 16 19 25 28 29 34 2 41 42 43 51 56 57 60 62 64 65 79 67 68 70 76 77 82 83 84 87 90 97\n49 2 4 7 9 11 13 16 17 18 19 22 25 28 29 30 32 34 35 38 39 44 45 46 48 49 50 55 56 58 59 61 64 65 67 68 69 72 73 77 82 83 86 88 90 93 95 97 98 99\n2 7 29\n5 42 43 57 66 87\n5 60 62 70 78 80\n4 6 31 79 94\n2 58 69\n1 39\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 7\n1 8\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 6 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 43 48 54\n3 31 66 82\n2 4 91\n5 5 15 34 62 67\n2 60 76\n4 28 62 92 93\n3 43 48 54\n1 96\n3 4 41 91\n4 8 11 53 71\n",
            "output": "209977190\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 40 36 37 43 49 51 61 63 68 78 81 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 77 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 1 44\n2 1 32\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 37\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 24 43 48 54\n3 31 66 82\n2 4 77\n5 5 12 24 62 67\n2 60 76\n4 28 62 92 93\n3 41 48 54\n1 99\n3 4 86 91\n4 8 11 53 71\n",
            "output": "705101287\n"
        },
        {
            "input": "98 10\n2 47 51\n17 1 3 10 16 29 38 40 46 49 50 59 64 65 77 81 86 23\n2 47 51\n2 47 36\n25 1 4 5 12 13 20 23 27 31 40 43 47 48 51 53 63 67 68 73 77 78 82 84 93 98\n55 2 6 7 8 9 11 14 17 18 21 22 24 26 28 30 32 33 34 36 37 39 41 42 44 45 52 54 55 56 57 58 60 61 62 66 69 70 71 72 74 43 76 79 80 85 87 88 89 90 91 92 94 95 96 97\n32 2 4 5 12 10 14 15 19 20 23 25 26 47 31 41 43 50 48 52 53 63 67 68 73 78 79 82 83 84 85 93 94\n3 1 77 98\n3 27 47 51\n2 47 51\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n1 24\n6 20 28 32 48 92 94\n9 11 17 43 46 20 72 76 79 95\n5 32 52 63 69 97\n2 34 82\n4 2 14 17 52\n6 41 65 83 84 89 1\n4 12 77 86 99\n2 32 92\n5 11 31 56 88 97\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 22 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 43 80\n2 1 44\n2 1 44\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 4 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 69 85\n3 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 6\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 82\n2 82 86\n2 46 68\n3 10 64 92\n4 27 29 55 82\n2 9 92\n4 27 29 44 66\n6 4 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 64 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 13 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 15 63 74\n2 27 55\n2 27 55\n7 4 22 33 56 59 61 97\n8 1 2 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n4 12 13 51 76\n4 4 30 46 55\n33 1 7 12 13 14 19 25 28 29 34 2 41 42 43 51 56 57 60 62 64 65 79 67 68 70 76 77 82 83 84 87 90 97\n49 2 4 7 9 11 13 16 17 18 19 22 25 28 29 30 32 34 35 38 39 44 45 46 48 49 50 55 56 58 59 61 64 65 67 68 69 72 73 77 82 83 86 88 90 93 95 97 98 99\n2 7 29\n5 42 43 57 66 87\n5 60 62 70 78 80\n4 6 27 79 37\n2 58 69\n1 39\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 9\n1 4\n2 14 96\n2 16 97\n2 4 46\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 37 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "99 50\n2 28 96\n2 36 77\n1 23\n2 10 28\n1 79\n2 16 73\n1 40\n2 19 77\n1 10\n1 77\n1 11\n2 37 27\n2 23 32\n2 41 99\n2 26 68\n2 58 84\n2 7 73\n1 66\n2 52 66\n2 44 93\n1 2\n2 25 26\n1 1\n2 44 93\n2 61 76\n2 6 24\n2 5 17\n2 36 92\n2 69 82\n2 20 69\n1 27\n2 1 7\n2 61 76\n1 20\n2 40 50\n1 38\n2 30 70\n2 18 80\n1 66\n2 1 7\n1 91\n2 9 54\n1 50\n2 69 82\n1 19\n2 31 42\n2 64 97\n2 69 82\n1 80\n2 19 77\n",
            "output": "667252968\n"
        },
        {
            "input": "99 10\n1 24\n6 36 28 32 48 92 94\n9 11 61 43 46 64 72 76 79 95\n5 31 56 63 69 97\n2 34 82\n4 2 14 17 60\n6 41 65 83 84 89 96\n4 75 77 86 99\n2 11 92\n5 9 31 56 88 97\n",
            "output": "397546235\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 45 46 68\n4 9 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 35 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        },
        {
            "input": "99 10\n29 2 6 12 16 19 25 28 32 33 36 37 38 43 48 50 10 57 59 60 68 69 73 74 75 77 82 90 94 96\n18 3 5 8 22 24 35 40 41 58 45 47 54 65 72 79 93 97 98\n6 2 28 60 69 73 75\n9 12 19 33 38 48 50 57 59 90\n12 14 20 21 26 28 44 60 62 69 70 73 75\n10 13 30 31 34 56 58 66 86 91 92\n13 3 8 22 24 40 41 42 54 65 72 79 93 97\n19 6 7 10 15 25 36 37 43 49 51 61 63 68 78 17 82 83 85 89\n9 5 35 40 47 49 61 89 97 98\n30 5 6 7 10 12 15 25 35 36 37 40 43 47 49 13 59 61 63 68 99 78 81 82 83 85 89 90 94 97 98\n",
            "output": "0\n"
        },
        {
            "input": "98 30\n2 1 44\n2 1 44\n2 33 69\n2 1 56\n2 1 44\n2 1 44\n3 1 44 56\n5 15 31 62 71 80\n2 2 44\n2 1 53\n2 1 44\n2 1 11\n2 1 44\n2 75 95\n2 75 83\n2 1 44\n9 3 8 9 10 16 26 43 63 64\n2 1 44\n2 54 73\n2 70 85\n2 1 44\n2 1 44\n8 7 19 34 37 41 52 58 94\n2 1 44\n2 1 44\n2 1 90\n2 1 44\n2 1 44\n2 54 73\n2 1 44\n",
            "output": "0\n"
        },
        {
            "input": "99 20\n1 41\n1 9\n1 9\n1 4\n2 14 96\n2 9 97\n2 4 59\n2 14 62\n1 2\n2 22 94\n1 93\n1 96\n1 82\n2 80 92\n2 42 69\n2 1 54\n2 57 79\n1 97\n1 15\n2 52 85\n",
            "output": "128094344\n"
        },
        {
            "input": "98 30\n2 47 50\n2 46 68\n2 46 68\n2 31 45\n2 82 86\n2 46 68\n3 10 64 92\n4 27 35 55 82\n2 9 92\n4 27 29 44 66\n6 7 11 33 56 77 94\n2 27 55\n2 55 82\n2 46 68\n2 27 29\n4 9 90 76 92\n3 62 46 68\n4 8 10 64 92\n4 44 47 50 66\n2 29 44\n3 31 45 46\n4 15 47 50 63\n2 46 68\n3 43 59 97\n3 7 63 74\n2 27 55\n2 27 55\n7 4 11 33 56 59 61 97\n8 1 13 16 35 37 72 79 87\n3 55 82 86\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, fac[1010];\nclass PQ_Tree {\n private:\n  int n;\n\n public:\n  struct node {\n    vector<int> son;\n    int type, op, siz, cnt;\n  } t[1010 << 1];\n  int tot, rt;\n  bool OK;\n  bitset<1010> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; ++i) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n)\n      return (void)(t[u].cnt = vis[u], t[u].siz = 1, t[u].op = vis[u] ? 2 : 1);\n    t[u].op = t[u].siz = t[u].cnt = 0;\n    for (auto v : t[u].son) {\n      dfs1(v);\n      t[u].cnt += t[v].cnt, t[u].siz += t[v].siz, t[u].op |= t[v].op;\n    }\n  }\n  inline int GT(int u) { return t[u].cnt ? (t[u].cnt == t[u].siz ? 2 : 1) : 0; }\n  int dfs2(int u, int lim) {\n    if (!OK || t[u].op ^ 3) return u;\n    vector<int> a[3];\n    for (auto v : t[u].son) {\n      a[GT(v)].push_back(v);\n    }\n    if ((lim > 0) + a[1].size() >= 3) {\n      OK = false;\n    }\n    if (!lim) {\n      for (auto &v : t[u].son) {\n        if (t[v].cnt == t[u].cnt) {\n          v = dfs2(v, 0);\n          return u;\n        }\n      }\n    }\n    if (t[u].type) {\n      int now = 0;\n      vector<int> S;\n      if (GT(t[u].son[0]) == 2 || !GT(t[u].son.back())) {\n        reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (auto v : t[u].son) {\n        int Type = GT(v);\n        if (Type == 0) {\n          S.push_back(v);\n          now += now == 1;\n        } else if (Type == 1) {\n          if (now == 2) OK = false;\n          ++now;\n          int w = dfs2(v, 3 - now);\n          S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n        } else {\n          S.push_back(v);\n          now += !now;\n          if (now == 2) OK = false;\n        }\n      }\n      if (lim && now == 2) OK = false;\n      if (lim == 1) reverse(S.begin(), S.end());\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1)\n        z = a[2][0];\n      else if (a[2].size() > 1)\n        z = ++tot, t[z].type = 0, t[z].son = a[2];\n      vector<int> S;\n      if (!a[1].empty()) {\n        int w = dfs2(a[1][0], 2);\n        S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n      }\n      if (~z) S.push_back(z);\n      if (a[1].size() > 1) {\n        int w = dfs2(a[1][1], 1);\n        S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n      }\n      if (a[0].empty()) {\n        if (lim == 1) reverse(S.begin(), S.end());\n        t[u].type = 1, t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[0][0];\n          if (a[0].size() > 1) {\n            z = ++tot, t[z].type = 0, t[z].son = a[0];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = S[0];\n          if (S.size() > 1) z = ++tot, t[z].son = S, t[z].type = 1;\n          t[u].son = a[0], t[u].son.push_back(z);\n        }\n      }\n    }\n    return u;\n  }\n  bool Insert(const bitset<1010> &B) {\n    vis = B;\n    dfs1(rt);\n    OK = true;\n    rt = dfs2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (auto v : t[u].son) ans = 1LL * ans * calc(v) % mod;\n    return ans;\n  }\n} T;\nint main() {\n  n = read(), m = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  T.init(n);\n  while (m--) {\n    static bitset<1010> B;\n    B.reset();\n    int k = read();\n    while (k--) B[read()] = 1;\n    if (!T.Insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int MOD = 998244353;\nstruct Mint {\n  int val;\n  Mint() { val = 0; }\n  Mint(ll x) {\n    val = (-MOD <= x && x < MOD) ? x : x % MOD;\n    if (val < 0) val += MOD;\n  }\n  template <typename U>\n  explicit operator U() const {\n    return (U)val;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n  Mint& operator+=(const Mint& m) {\n    if ((val += m.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((val -= m.val) < 0) val += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    val = (ll)val * m.val % MOD;\n    return *this;\n  }\n  friend Mint modex(Mint a, ll p) {\n    assert(p >= 0);\n    Mint ans = 1;\n    for (; p; p >>= 1, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  Mint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  Mint operator++(int) {\n    Mint result(*this);\n    *this += 1;\n    return result;\n  }\n  Mint operator--(int) {\n    Mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  Mint operator-() const { return Mint(-val); }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n  friend string to_string(const Mint& b) { return to_string(b.val); }\n};\nvector<Mint> fac(1, 1), invfac(1, 1);\nMint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  while (fac.size() <= n) {\n    fac.push_back(fac.back() * fac.size());\n    invfac.push_back(1 / fac.back());\n  }\n  return fac[n] * invfac[k] * invfac[n - k];\n}\nstruct PqTree {\n  int n;\n  int fail = 0;\n  vector<vector<int>> G;\n  vector<int> ty, sz, szc;\n  vector<bool> s;\n  PqTree(int _n) : n(_n), G(n + 2), ty(n + 2), sz(n + 2), szc(n + 2), s(n + 1) {\n    assert(n >= 1);\n    for (int i = 1; i <= n; ++i) G[n + 1].push_back(i);\n  }\n  int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(const vector<int>& vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G.push_back(vec);\n    ty.push_back(0);\n    sz.push_back(0);\n    szc.push_back(0);\n    42;\n    assert(G.size() <= 2 * n + 1);\n    return G.size() - 1;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      }\n      ty[u] = 1;\n      G[u].clear();\n      addson(u, p2);\n      if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n      addson(u, mergeP(vec[0]));\n      if (t == 2) reverse(G[u].begin(), G[u].end());\n      return u;\n    }\n    if (getstate(G[u].front()) > getstate(G[u].back()))\n      reverse(G[u].begin(), G[u].end());\n    int flag = 0;\n    vector<int> tG;\n    for (auto v : G[u]) {\n      int sta = getstate(v);\n      if (sta == 0) {\n        if (flag == 1) flag = 2;\n        tG.push_back(v);\n      } else if (sta == 2) {\n        if (flag == 0)\n          flag = 1;\n        else if (flag == 2)\n          return fail = 2, 0;\n        tG.push_back(v);\n      } else {\n        if (flag == 0)\n          flag = 1, check(v, 2);\n        else if (flag == 1)\n          flag = 2, check(v, 1);\n        else\n          return fail = 3, 0;\n        for (auto x : G[v]) tG.push_back(x);\n      }\n    }\n    if (t && flag == 2) return fail = 4, 0;\n    if (t == 1) reverse(tG.begin(), tG.end());\n    G[u] = tG;\n    return u;\n  }\n  void dfsPermutation(int u, vector<int>& per) {\n    if (u <= n) per.push_back(u);\n    for (auto v : G[u]) dfsPermutation(v, per);\n  }\n  vector<int> getPermutation() {\n    if (fail) return {};\n    vector<int> res;\n    dfsPermutation(n + 1, res);\n    return res;\n  }\n  Mint dfsCount(int u) {\n    if (u <= n) return 1;\n    Mint ret = 1;\n    if (!ty[u]) {\n      ret *= fac[G[u].size()];\n    } else {\n      if (G[u].size() != 1) {\n        ret *= 2;\n      }\n    }\n    for (auto v : G[u]) ret *= dfsCount(v);\n    return ret;\n  }\n  Mint countPermutations() {\n    if (fail) return 0;\n    binom(n, 0);\n    return dfsCount(n + 1);\n  }\n  void restrict(const vector<int>& res) {\n    for (int i = 1; i <= n; ++i) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  PqTree pq(n);\n  for (int i = 0; i < m; ++i) {\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> res;\n    while (q--) {\n      int s;\n      scanf(\"%d\", &s);\n      res.push_back(s);\n    }\n    pq.restrict(res);\n  }\n  Mint ans = pq.countPermutations();\n  printf(\"%d\\n\", ans.val);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  static char _c;\n  static bool _f;\n  x = 0;\n  _f = 0;\n  _c = getchar();\n  while (_c < '0' || '9' < _c) {\n    if (_c == '-') _f = true;\n    _c = getchar();\n  }\n  while ('0' <= _c && _c <= '9') {\n    x = (x << 1) + (x << 3) + (_c & 15);\n    _c = getchar();\n  }\n  if (_f) x = -x;\n}\ntemplate <typename T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <typename T>\ninline void Max(T &x, T y) {\n  if (x < y) x = y;\n}\nconst int INF = 0x3f3f3f3f;\nconst double pi = (double)acos(-1.0);\nconst double eps = (double)1e-8;\nconst int e5 = (int)1e5 + 5;\nconst int MOD = (int)998244353;\ninline int sig(double x) { return x < -eps ? -1 : eps < x; }\nlong long fac[128];\nlong long fp(long long a, long long n, long long mod = MOD) {\n  if (n < 0) a = fp(a, mod - 2, mod), n = -n;\n  long long res = 1;\n  for (; n; n >>= 1, a = a * a % mod)\n    if (n & 1) res = res * a % mod;\n  return res;\n}\nstruct Mint {\n  int x;\n  Mint() { x = 0; }\n  Mint(int _x) : x(_x) {\n    if (x < 0 || x >= MOD) x = (x % MOD + MOD) % MOD;\n  }\n  Mint(long long _x) : x(_x) {\n    if (x < 0 || x >= MOD) x = (x % MOD + MOD) % MOD;\n  }\n  Mint operator-() const { return Mint(MOD - x); }\n  Mint operator+(const Mint &rhs) const {\n    return Mint(x + rhs.x >= MOD ? x + rhs.x - MOD : x + rhs.x);\n  }\n  Mint operator-(const Mint &rhs) const {\n    return Mint(x - rhs.x < 0 ? x - rhs.x + MOD : x - rhs.x);\n  }\n  Mint operator*(const Mint &rhs) const {\n    return Mint((long long)x * rhs.x % MOD);\n  }\n  Mint operator/(const Mint &rhs) const {\n    return Mint(x * fp(rhs.x, -1) % MOD);\n  }\n  Mint &operator+=(const Mint &rhs) {\n    x += rhs.x;\n    if (x >= MOD) x -= MOD;\n    return *this;\n  }\n  Mint &operator*=(const Mint &rhs) {\n    x = ((long long)x * rhs.x) % MOD;\n    return *this;\n  }\n  bool operator==(const Mint &rhs) const { return x == rhs.x; }\n  bool operator!=(const Mint &rhs) const { return x != rhs.x; }\n  friend ostream &operator<<(ostream &out, const Mint &rhs) {\n    return out << rhs.x;\n  }\n  friend istream &operator>>(istream &in, Mint &rhs) { return in >> rhs.x; }\n};\nconst int maxn = (int)2e5 + 20;\nconst int maxm = (int)1e6 + 20;\nconst int N = 500 + 5;\nstruct PQ_tree {\n  int n, tot;\n  int fail;\n  vector<int> G[N << 2];\n  int ty[N << 2];\n  int sz[N << 2];\n  int szc[N << 2];\n  bool s[N];\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(vector<int> &vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G[++tot] = vec;\n    return tot;\n  }\n  void init(int _n) {\n    n = _n;\n    tot = n + 1;\n    memset(ty, 0, sizeof(ty));\n    for (int i = 1; i <= n; i++) G[n + 1].push_back(i);\n    fail = 0;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      } else {\n        ty[u] = 1;\n        G[u].clear();\n        addson(u, p2);\n        if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n        addson(u, mergeP(vec[0]));\n        if (t == 2) reverse(G[u].begin(), G[u].end());\n      }\n      return u;\n    } else {\n      if (getstate(G[u].front()) > getstate(G[u].back()))\n        reverse(G[u].begin(), G[u].end());\n      int flag = 0;\n      vector<int> tG;\n      for (auto v : G[u]) {\n        int sta = getstate(v);\n        if (sta == 0) {\n          if (flag == 1) flag = 2;\n          tG.push_back(v);\n        } else if (sta == 2) {\n          if (flag == 0)\n            flag = 1;\n          else if (flag == 2)\n            return fail = 2, 0;\n          tG.push_back(v);\n        } else {\n          int p1;\n          if (flag == 0)\n            flag = 1, p1 = check(v, 2);\n          else if (flag == 1)\n            flag = 2, p1 = check(v, 1);\n          else\n            return fail = 3, 0;\n          for (auto x : G[v]) tG.push_back(x);\n        }\n      }\n      if (t && flag == 2) return fail = 4, 0;\n      if (t == 1) reverse(tG.begin(), tG.end());\n      G[u] = tG;\n      return u;\n    }\n  }\n  int res;\n  void dfs_permutation(int u) {\n    if (u <= n) {\n      return;\n    }\n    if (!ty[u]) {\n      res = (long long)res * fac[G[u].size()] % MOD;\n    } else if (G[u].size() != 1) {\n      res = (long long)res * 2 % MOD;\n    }\n    for (auto v : G[u]) {\n      dfs_permutation(v);\n    }\n  }\n  int get_permutation() {\n    res = 1;\n    dfs_permutation(n + 1);\n    return res;\n  }\n  void restrict(vector<int> res) {\n    for (int i = 1; i <= n; i++) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nvoid work() {\n  fac[0] = 1;\n  for (int i = 1; i < 128; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n  }\n  int n, m;\n  cin >> n >> m;\n  PQ_tree *pq = new PQ_tree;\n  pq->init(n);\n  for (int i = 0; i < m; i++) {\n    vector<int> res;\n    int num;\n    cin >> num;\n    while (num--) {\n      int x;\n      cin >> x;\n      res.push_back(x);\n    }\n    pq->restrict(res);\n  }\n  if (pq->fail) {\n    cout << 0 << endl;\n  } else {\n    cout << pq->get_permutation() << endl;\n  }\n  delete pq;\n}\nint main(int argc, char **argv) {\n  int tc = 1;\n  for (int ca = 1; ca <= tc; ca++) {\n    work();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fra[105];\nint MOD = 998244353;\nconst int N = 1005;\nstruct PQ_tree {\n  int fail, res, n, tot;\n  vector<int> G[N << 2];\n  int ty[N << 2], sz[N << 2], szc[N << 2];\n  bool s[N];\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int first, int second) {\n    if (second) G[first].push_back(second);\n  }\n  void join(int first, int second) {\n    for (auto v : G[second]) G[first].push_back(v);\n  }\n  int mergeP(vector<int> &vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G[++tot] = vec;\n    return tot;\n  }\n  void init(int _n) {\n    n = _n;\n    tot = n + 1;\n    memset(ty, 0, sizeof(ty));\n    for (int i = 1; i <= n; i++) G[n + 1].push_back(i);\n    fail = 0;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      } else {\n        ty[u] = 1;\n        G[u].clear();\n        addson(u, p2);\n        if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n        addson(u, mergeP(vec[0]));\n        if (t == 2) reverse(G[u].begin(), G[u].end());\n      }\n      return u;\n    } else {\n      if (getstate(G[u].front()) > getstate(G[u].back()))\n        reverse(G[u].begin(), G[u].end());\n      int flag = 0;\n      vector<int> tG;\n      for (auto v : G[u]) {\n        int sta = getstate(v);\n        if (sta == 0) {\n          if (flag == 1) flag = 2;\n          tG.push_back(v);\n        } else if (sta == 2) {\n          if (flag == 0)\n            flag = 1;\n          else if (flag == 2)\n            return fail = 2, 0;\n          tG.push_back(v);\n        } else {\n          int p1;\n          if (flag == 0)\n            flag = 1, p1 = check(v, 2);\n          else if (flag == 1)\n            flag = 2, p1 = check(v, 1);\n          else\n            return fail = 3, 0;\n          for (auto first : G[v]) tG.push_back(first);\n        }\n      }\n      if (t && flag == 2) return fail = 4, 0;\n      if (t == 1) reverse(tG.begin(), tG.end());\n      G[u] = tG;\n      return u;\n    }\n  }\n  void dfs_permutation(int u) {\n    if (u <= n) {\n      return;\n    }\n    if (!ty[u]) {\n      res = (long long)res * fra[G[u].size()] % MOD;\n    } else if (G[u].size() != 1) {\n      res = (long long)res * 2 % MOD;\n    }\n    for (auto v : G[u]) {\n      dfs_permutation(v);\n    }\n  }\n  int get_permutation() {\n    res = 1;\n    dfs_permutation(n + 1);\n    return res;\n  }\n  void restrict(vector<int> res) {\n    for (int i = 1; i <= n; i++) s[i] = 0;\n    for (auto first : res) s[first] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nvoid solve() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  PQ_tree pq;\n  fra[0] = 1;\n  for (int i = 1; i <= n; i++) fra[i] = fra[i - 1] * i % MOD;\n  pq.init(n);\n  for (int i = 0; i < m; i++) {\n    int first;\n    scanf(\"%d\", &first);\n    vector<int> v;\n    for (int i = 0; i < first; i++) {\n      int a;\n      scanf(\"%d\", &a);\n      v.push_back(a);\n    }\n    pq.restrict(v);\n  }\n  if (pq.fail)\n    printf(\"0\\n\");\n  else {\n    printf(\"%d\\n\", pq.get_permutation());\n  }\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1010, mod = 998244353;\nint n, m, pd[N], fac[N];\nnamespace PQtree {\nconst int M = N << 2;\nint op[M], tp[M], rt, tot;\nvector<int> son[M];\ninline void init() {\n  tot = n;\n  rt = ++tot;\n  tp[tot] = 0;\n  for (int i = 1; i <= n; ++i) tp[i] = 0, son[tot].push_back(i);\n}\ninline void dfs1(int p) {\n  if (p <= n) {\n    op[p] = pd[p];\n    return;\n  }\n  bool pd0 = 0, pd1 = 0;\n  for (int v : son[p]) {\n    dfs1(v);\n    pd0 |= (op[v] == 0 || op[v] == 2);\n    pd1 |= (op[v] == 1 || op[v] == 2);\n  }\n  if (!pd0)\n    op[p] = 1;\n  else if (!pd1)\n    op[p] = 0;\n  else\n    op[p] = 2;\n}\ninline void dfs2(int u, int lim) {\n  if (op[u] != 2) return;\n  vector<int> ve[3];\n  for (int v : son[u]) ve[op[v]].push_back(v);\n  if (!lim && ve[2].size() >= 3) {\n    puts(\"0\");\n    exit(0);\n  }\n  if (lim && ve[2].size() >= 2) {\n    puts(\"0\");\n    exit(0);\n  }\n  if (!lim && (ve[1].size() + ve[2].size()) <= 1) {\n    for (int v : ve[1]) dfs2(v, 0);\n    for (int v : ve[2]) dfs2(v, 0);\n    return;\n  }\n  if (tp[u] == 0) {\n    vector<int> nw;\n    int np = -1;\n    if (!ve[1].empty()) np = ve[1][0];\n    if (ve[1].size() > 1) np = ++tot, son[np] = ve[1], tp[np] = 0;\n    if (!ve[2].empty()) {\n      dfs2(ve[2][0], 2);\n      for (int t : son[ve[2][0]]) nw.push_back(t);\n    }\n    if (np != -1) nw.push_back(np);\n    if (ve[2].size() > 1) {\n      dfs2(ve[2][1], 1);\n      for (int t : son[ve[2][1]]) nw.push_back(t);\n    }\n    if (!ve[0].size()) {\n      tp[u] = 1;\n      son[u] = nw;\n      if (lim == 1) reverse(son[u].begin(), son[u].end());\n    } else {\n      if (lim) {\n        int nq = ve[0][0];\n        if (ve[0].size() > 1) nq = ++tot, son[nq] = ve[0], tp[nq] = 0;\n        son[u].clear();\n        son[u].push_back(nq);\n        for (int i : nw) son[u].push_back(i);\n        tp[u] = 1;\n        if (lim == 1) reverse(son[u].begin(), son[u].end());\n      } else {\n        int nq = nw[0];\n        if (nw.size() > 1) nq = ++tot, son[nq] = nw, tp[nq] = 1;\n        son[u] = ve[0];\n        son[u].push_back(nq);\n        tp[u] = 0;\n      }\n    }\n  } else {\n    int f = 0;\n    if (op[son[u][0]] == 1 || op[son[u].back()] == 0)\n      reverse(son[u].begin(), son[u].end());\n    vector<int> nw;\n    for (int v : son[u]) {\n      if (!op[v]) {\n        if (f == 1) f = 2;\n        nw.push_back(v);\n      } else if (op[v] == 1) {\n        if (f == 2) {\n          puts(\"0\");\n          exit(0);\n        }\n        if (f == 0) f = 1;\n        nw.push_back(v);\n      } else {\n        if (f == 2) {\n          puts(\"0\");\n          exit(0);\n        }\n        if (f == 1)\n          f = 2;\n        else\n          f = 1;\n        dfs2(v, (f == 1 ? 2 : 1));\n        for (int x : son[v]) nw.push_back(x);\n      }\n    }\n    if (lim && f == 2) {\n      puts(\"0\");\n      exit(0);\n    }\n    if (lim == 1) reverse(nw.begin(), nw.end());\n    son[u] = nw;\n  }\n}\ninline void insert() {\n  dfs1(rt);\n  dfs2(rt, 0);\n}\ninline int query(int u) {\n  int ans = 1;\n  for (int v : son[u]) ans = 1ll * ans * query(v) % mod;\n  if (u <= n) return ans;\n  if (tp[u] && son[u].size() > 1) ans = 2ll * ans % mod;\n  if (!tp[u]) ans = 1ll * ans * fac[son[u].size()] % mod;\n  return ans;\n}\n}  // namespace PQtree\nusing namespace PQtree;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n  init();\n  for (int i = 1; i <= m; ++i) {\n    memset(pd + 1, 0, sizeof(int) * (n));\n    int len;\n    scanf(\"%d\", &len);\n    for (int j = 1, x; j <= len; ++j) scanf(\"%d\", &x), pd[x] = 1;\n    insert();\n  }\n  printf(\"%d\\n\", query(rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1.01e9;\nconst long long infll = (long long)1.01e18;\nconst long double eps = 1e-9;\nconst long double pi = acos((long double)-1);\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int x) { return mrand() % x; }\nconst int mod = 998244353;\nint mul(int a, int b) { return (long long)a * b % mod; }\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\nconst int maxn = 105;\nint f[maxn];\nvoid precalc() {\n  f[0] = 1;\n  for (int i = 1; i < maxn; ++i) {\n    f[i] = mul(f[i - 1], i);\n  }\n}\nint n, m;\nbitset<maxn> s[maxn];\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return false;\n  }\n  for (int i = 0; i < m; ++i) {\n    int k;\n    scanf(\"%d\", &k);\n    s[i].reset();\n    for (int j = 0; j < k; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      s[i][x] = true;\n    }\n  }\n  return true;\n}\nint used[maxn];\nint curu;\nint rec(bitset<maxn> a) {\n  int res = 1;\n  int cs = 0;\n  bitset<maxn> a0 = a;\n  for (int i = 0; i < m; ++i) {\n    if ((s[i] & a) != s[i] || s[i] == a0) {\n      continue;\n    }\n    bool ok = true;\n    for (int j = 0; j < m; ++j) {\n      if (j == i || (s[j] & a) != s[j] || s[j] == a0) {\n        continue;\n      }\n      if ((s[i] & s[j]) == s[i]) {\n        ok = false;\n        break;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    vector<bitset<maxn>> b;\n    b.push_back(s[i]);\n    bitset<maxn> all = s[i];\n    ++curu;\n    used[i] = curu;\n    while (true) {\n      bool found = false;\n      for (int j = 0; j < m; ++j) {\n        if (used[j] == curu || (s[j] & a) != s[j] || s[j] == a0) {\n          continue;\n        }\n        if (!(s[j] & all).any()) {\n          continue;\n        }\n        bool bad = false;\n        int l = -1;\n        for (int k = 0; k < ((int)(b).size()); ++k) {\n          if ((s[j] & b[k]) == s[j]) {\n            bad = true;\n            break;\n          }\n          if ((s[j] & b[k]).any()) {\n            l = k;\n            break;\n          }\n        }\n        if (bad) {\n          continue;\n        }\n        int r = l + 1;\n        while (r < ((int)(b).size()) && (s[j] & b[r]).any()) {\n          ++r;\n        }\n        for (int k = r + 1; k < ((int)(b).size()); ++k) {\n          if ((s[j] & b[r]).any()) {\n            return 0;\n          }\n        }\n        if ((all & s[j]) != s[j]) {\n          bitset<maxn> add = (s[j] & ~all);\n          if (l == 0) {\n            b.insert(b.begin(), add);\n            ++r;\n          } else if (r == ((int)(b).size())) {\n            b.push_back(add);\n            ++r;\n          } else {\n            return 0;\n          }\n          all |= s[j];\n        }\n        if ((b[l] & s[j]) != b[l]) {\n          bitset<maxn> add = (b[l] & s[j]);\n          b[l] ^= add;\n          b.insert(b.begin() + l + 1, add);\n          ++l;\n          ++r;\n        }\n        --r;\n        if ((b[r] & s[j]) != b[r]) {\n          bitset<maxn> add = (b[r] & s[j]);\n          b[r] ^= add;\n          b.insert(b.begin() + r, add);\n        }\n        ++r;\n        bitset<maxn> x;\n        x.reset();\n        for (int k = l; k < r; ++k) {\n          if ((b[k] & s[j]) != b[k]) {\n            return 0;\n          }\n          x |= b[k];\n        }\n        if (x != s[j]) {\n          return 0;\n        }\n        used[j] = curu;\n        found = true;\n      }\n      if (!found) {\n        break;\n      }\n    }\n    if (((int)(b).size()) > 1) {\n      res = mul(res, 2);\n    }\n    for (int i = 0; i < ((int)(b).size()); ++i) {\n      res = mul(res, rec(b[i]));\n    }\n    ++cs;\n    a ^= all;\n  }\n  res = mul(res, f[cs + a.count()]);\n  return res;\n}\nvoid solve() {\n  {\n    int mm = 0;\n    for (int i = 0; i < m; ++i) {\n      bool ok = true;\n      for (int j = 0; j < mm; ++j) {\n        if (s[i] == s[j]) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        s[mm++] = s[i];\n      }\n    }\n    m = mm;\n  }\n  bitset<maxn> all;\n  all.reset();\n  for (int i = 0; i < n; ++i) {\n    all[i] = true;\n  }\n  printf(\"%d\\n\", rec(all));\n}\nint main() {\n  precalc();\n  while (read()) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct PQtree {\n  int type, father;\n  vector<int> child;\n} t[2010];\nint n, pd[2010], w[2010], size[2010], in[5010], B[2010],\n    W[3] = {0, 2, 1}, ans[2010], C[600][600], len, kk;\nvector<int> rem, A;\nchar getin() {\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  return ch;\n}\nint getnext() {\n  int k1 = rem[(rem.size()) - 1];\n  rem.pop_back();\n  t[k1].child.clear();\n  t[k1].type = 0;\n  t[k1].father = 0;\n  return k1;\n}\nvoid reverse(int k) {\n  vector<int> k1;\n  for (int i = 0; i < t[k].child.size(); i++) k1.push_back(t[k].child[i]);\n  t[k].child.clear();\n  for (int i = (k1.size()) - 1; i >= 0; i--) t[k].child.push_back(k1[i]);\n}\nvoid change(int k1, int k2, int k3) {\n  if (k1 == 0) return;\n  for (int i = 0; i < t[k1].child.size(); i++)\n    if (t[k1].child[i] == k2) {\n      t[k1].child[i] = k3;\n      return;\n    }\n}\nint reduce() {\n  memset(B, 0x00, sizeof B);\n  memset(size, 0x00, sizeof size);\n  memset(w, 0x00, sizeof w);\n  memset(pd, 0xff, sizeof pd);\n  queue<int> Q;\n  for (int i = 1; i <= n; i++) {\n    Q.push(i);\n    pd[i] = in[i];\n    w[i] = in[i];\n  }\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    int flag = 0;\n    if (w[k] == A.size()) flag = 1;\n    if (pd[k] == 2) {\n      vector<int> C[3];\n      for (int i = 0; i < t[k].child.size(); i++) {\n        int j = t[k].child[i];\n        C[pd[j]].push_back(j);\n      }\n      if (t[k].type == 1) {\n        if (C[2].size() == 0) {\n          if (flag == 1) {\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k1].father = k;\n              t[k].child.clear();\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k1);\n            }\n          } else {\n            t[k].type = 2;\n            t[k].child.clear();\n            if (C[0].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n            } else if (C[0].size())\n              t[k].child.push_back(C[0][0]);\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n            } else if (C[1].size())\n              t[k].child.push_back(C[1][0]);\n          }\n        } else if (C[2].size() == 1) {\n          if (flag == 1) {\n            t[k].child.clear();\n            if (C[1].size() == 1) {\n              t[C[2][0]].child.push_back(C[1][0]);\n              t[C[1][0]].father = C[2][0];\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(C[2][0]);\n            } else if (C[1].size()) {\n              int k1 = getnext(), k2 = C[2][0];\n              t[k1].type = 1;\n              t[k1].father = k2;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k2].child.push_back(k1);\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k2);\n            }\n            if (t[k].child.size() == 1) {\n              t[t[k].child[0]].father = t[k].father;\n              change(t[k].father, k, t[k].child[0]);\n              rem.push_back(k);\n            }\n          } else {\n            t[k].child.clear();\n            t[k].type = 2;\n            if (C[0].size() == 1)\n              t[k].child.push_back(C[0][0]);\n            else if (C[0].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            if (C[1].size() == 1)\n              t[k].child.push_back(C[1][0]);\n            else if (C[1].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            rem.push_back(k2);\n          }\n        } else if (C[2].size() == 2) {\n          if (flag == 0) return 0;\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k1 = getnext();\n          int k2 = C[2][0];\n          t[k1].type = 2;\n          t[k1].father = k;\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          pd[k1] = 2;\n          if (C[1].size() == 1) {\n            t[k1].child.push_back(C[1][0]);\n            t[C[1][0]].father = k1;\n          } else if (C[1].size()) {\n            int k3 = getnext();\n            t[k3].type = 1;\n            t[k3].father = k1;\n            pd[k3] = 1;\n            for (int i = 0; i < C[1].size(); i++) {\n              t[k3].child.push_back(C[1][i]);\n              t[C[1][i]].father = k3;\n            }\n            t[k1].child.push_back(k3);\n          }\n          t[k].child.push_back(k1);\n          k2 = C[2][1];\n          for (int i = (t[k2].child.size()) - 1; i >= 0; i--) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          if (t[k].child.size() == 1) {\n            t[k1].father = t[k].father;\n            change(t[k].father, k, k1);\n            rem.push_back(k);\n          }\n        } else\n          return 0;\n      } else {\n        int now = 0, flag2 = 0;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] < now) {\n            flag2 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        int flag3 = 0;\n        now = 2;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] > now) {\n            flag3 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        if ((flag2 == 0 || flag3 == 0) && C[2].size() == 1) {\n          if (flag3 == 0) {\n            reverse(k);\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n          }\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k2 = C[2][0];\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k;\n          }\n          rem.push_back(k2);\n          for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n        } else if (C[2].size() <= 2 && C[2].size() >= 1) {\n          if (flag == 0) return 0;\n          int two1 = -1, two2 = -1;\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int j = t[k].child[i];\n            if (pd[j] == 2) {\n              if (two1 != -1)\n                two2 = i;\n              else\n                two1 = i;\n            }\n          }\n          if (C[2].size() == 2) {\n            for (int i = 0; i < two1; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            for (int i = two1 + 1; i < two2; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 1) return 0;\n            }\n            for (int i = two2 + 1; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            reverse(C[2][1]);\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            k2 = C[2][1];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          } else {\n            int flag4 = 0;\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] == 1) {\n                flag4 = 1;\n                break;\n              }\n            }\n            if (flag4) {\n              reverse(k);\n              two1 = (t[k].child.size()) - two1 - 1;\n            }\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1]) return 0;\n            }\n            int now = 1;\n            for (int i = two1 + 1; i < t[k].child.size(); i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] > now) return 0;\n              now = pd[k1];\n            }\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          }\n        } else if (C[2].size() == 0) {\n          if (pd[t[k].child[0]] == 1) reverse(k);\n          int k1 = t[k].child.size();\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 1) {\n              k1 = i;\n              break;\n            }\n          }\n          int k3 = t[k].child.size();\n          for (int i = k1; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 0) {\n              k3 = i;\n              break;\n            }\n          }\n          if (flag == 0 && k3 != t[k].child.size()) return 0;\n          if (flag == 1)\n            for (int i = k3; i < t[k].child.size(); i++) {\n              int k2 = t[k].child[i];\n              if (pd[k2] == 1) return 0;\n            }\n        } else\n          return 0;\n      }\n    }\n    if (flag) return 1;\n    int k1 = t[k].father;\n    size[k1]++;\n    w[k1] += w[k];\n    if (pd[k1] == -1)\n      pd[k1] = pd[k];\n    else if (pd[k1] != pd[k])\n      pd[k1] = 2;\n    if (size[k1] == t[k1].child.size()) Q.push(k1);\n  }\n}\nconst int mod = 998244353;\nint Ans;\nvoid print(int k) {\n  if (t[k].type == 0) return;\n  if (t[k].type == 1) {\n    for (int i = 1; i <= t[k].child.size(); i++) Ans = 1ll * Ans * i % mod;\n  } else {\n    Ans = 2ll * Ans % mod;\n  }\n  for (int i = 0; i < t[k].child.size(); i++) print(t[k].child[i]);\n}\nint main() {\n  int m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    t[i].type = 0;\n    t[i].father = n + 1;\n    t[i].child.clear();\n    t[n + 1].child.push_back(i);\n  }\n  t[n + 1].type = 1;\n  for (int i = 2000; i > n + 1; i--) rem.push_back(i);\n  for (int i = 1; i <= m; i++) {\n    memset(in, 0x00, sizeof in);\n    A.clear();\n    int cnt, x;\n    scanf(\"%d\", &cnt);\n    for (int j = 1; j <= cnt; j++) {\n      scanf(\"%d\", &x), C[i][x] = 1;\n      A.push_back(x), in[x] = 1;\n    }\n    kk = i;\n    if (reduce() == 0) {\n      cout << \"0\" << endl;\n      return 0;\n    }\n  }\n  int root = 1;\n  while (t[root].father) root = t[root].father;\n  Ans = 1, print(root);\n  printf(\"%d\\n\", Ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long n, m;\nbitset<100> s[101];\nvector<long long> e[101];\nbool vis[100];\nset<long long> c;\nbitset<100> curb;\nunordered_set<bitset<100>> found;\nbool skip[100];\nlong long countt;\nlong long fac[101];\nvector<set<long long>> comp;\nvector<bitset<100>> compb;\nvector<vector<long long>> f;\nvoid dfs(long long u) {\n  if (vis[u]) return;\n  vis[u] = true;\n  c.insert(u);\n  curb |= s[u];\n  for (long long v : e[u]) dfs(v);\n}\nvoid dfs2(long long u, long long i, long long ex) {\n  if (vis[u] || comp[i].count(u) == 0) return;\n  vis[u] = true;\n  countt++;\n  for (long long v : e[u])\n    if (v != ex) dfs2(v, i, ex);\n}\nvoid bad(long long i) {\n  cout << \"0\\n\";\n  exit(0);\n}\nvoid _calc(long long i, vector<bitset<100>> &e, bitset<100> &b) {\n  if (comp[i].size() == 1) {\n    e.push_back(s[*comp[i].begin()]);\n    b = e[0];\n    comp[i].clear();\n    return;\n  }\n  for (long long a : comp[i]) {\n    for (long long x : comp[i]) vis[x] = false;\n    countt = 0;\n    auto it = comp[i].begin();\n    if (*it == a) ++it;\n    dfs2(*it, i, a);\n    if (countt != (long long)comp[i].size() - 1) continue;\n    comp[i].erase(a);\n    _calc(i, e, b);\n    long long l = -1, r = -1;\n    for (long long j = 0; j < (long long)e.size(); ++j) {\n      if ((s[a] & e[j]).count() && (s[a] | e[j]) != s[a]) {\n        if (l == -1)\n          l = j;\n        else if (r == -1)\n          r = j;\n        else\n          bad(1);\n      }\n    }\n    if (r != -1) {\n      if ((s[a] | b) != b) bad(2);\n      for (long long j = 0; j < (long long)e.size(); ++j) {\n        if (j < l || j > r) {\n          if ((e[j] & s[a]).count()) bad(3);\n        } else if (j > l && j < r) {\n          if ((e[j] | s[a]) != s[a]) bad(4);\n        }\n      }\n      bitset<100> x = e[r] & s[a];\n      bitset<100> y = e[r] ^ x;\n      e.insert(e.begin() + r + 1, y);\n      e[r] = x;\n      x = e[l] & s[a];\n      y = e[l] ^ x;\n      e.insert(e.begin() + l + 1, x);\n      e[l] = y;\n      b |= s[a];\n      return;\n    }\n    if (l == -1) {\n      long long l1 = 0, l2 = (long long)e.size() - 1;\n      while (l1 < (long long)e.size() && (e[l1] & s[a]).count() == 0) l1++;\n      while (l2 >= 0 && (e[l2] & s[a]).count() == 0) l2--;\n      for (long long j = l1 + 1; j < l2; ++j)\n        if ((e[j] & s[a]).count() == 0) bad(5);\n      assert(l1 <= l2 && (l1 > 0 || l2 < (long long)e.size() - 1));\n      if ((s[a] | b) == b) return;\n      if (l1 == 0)\n        e.insert(e.begin(), s[a] ^ (s[a] & b));\n      else if (l2 == (long long)e.size() - 1)\n        e.push_back(s[a] ^ (s[a] & b));\n      else\n        bad(6);\n      b |= s[a];\n      return;\n    }\n    long long l1 = l, l2 = l;\n    while (l1 > 0 && (e[l1 - 1] | s[a]) == s[a]) l1--;\n    while (l2 < (long long)e.size() - 1 && (e[l2 + 1] | s[a]) == s[a]) l2++;\n    if (l1 != l && l2 != l) bad(7);\n    if ((s[a] | b) != b && l1 > 0 && l2 < (long long)e.size() - 1) bad(8);\n    for (long long j = 0; j < l1; ++j)\n      if ((e[j] & s[a]).count()) bad(9);\n    for (long long j = l2 + 1; j < (long long)e.size(); ++j)\n      if ((e[j] & s[a]).count()) bad(10);\n    assert(l1 != l || l2 != l || (s[a] | b) != b);\n    bitset<100> x = e[l] & s[a];\n    bitset<100> y = e[l] ^ x;\n    if (l1 != l || (l1 == 0 && l2 == 0)) {\n      e.insert(e.begin() + l + 1, y);\n      e[l] = x;\n      if ((s[a] | b) != b) e.insert(e.begin(), s[a] ^ (s[a] & b));\n    } else {\n      e[l] = y;\n      e.insert(e.begin() + l + 1, x);\n      if ((s[a] | b) != b) e.push_back(s[a] ^ (s[a] & b));\n    }\n    b |= s[a];\n    return;\n  }\n}\nlong long calc(long long i) {\n  vector<bitset<100>> e;\n  bitset<100> b;\n  _calc(i, e, b);\n  long long res = 1;\n  for (auto g : e) {\n    long long r = g.count();\n    for (long long j : f[i])\n      if ((compb[j] & g) == compb[j]) {\n        r -= compb[j].count() - 1;\n      }\n    res = (res * fac[r]) % mod;\n  }\n  if (e.size() > 1) res = (res * 2) % mod;\n  return res;\n}\nint32_t main() {\n  fac[0] = 1;\n  for (long long i = 1; i <= 100; ++i) fac[i] = (fac[i - 1] * i) % mod;\n  cin >> n >> m;\n  for (long long i = 0; i < m; ++i) {\n    long long q;\n    cin >> q;\n    for (long long j = 0; j < q; ++j) {\n      long long x;\n      cin >> x;\n      x--;\n      s[i].set(x);\n    }\n  }\n  for (long long i = 0; i < n; ++i) s[m].set(i);\n  m++;\n  for (long long i = m - 1; i >= 0; --i) {\n    if (found.count(s[i])) {\n      skip[i] = true;\n      continue;\n    }\n    found.insert(s[i]);\n  }\n  for (long long i = 0; i < m; ++i)\n    for (long long j = i + 1; j < m; ++j)\n      if (!skip[i] && !skip[j]) {\n        bitset<100> b = s[i] & s[j];\n        if (b.count() == 0 || b == s[i] || b == s[j]) continue;\n        e[i].push_back(j);\n        e[j].push_back(i);\n      }\n  for (long long i = 0; i < m; ++i)\n    if (!skip[i]) {\n      if (vis[i]) continue;\n      c.clear();\n      curb.reset();\n      dfs(i);\n      comp.push_back(c);\n      compb.push_back(curb);\n      f.emplace_back();\n    }\n  for (long long i = 0; i < (long long)comp.size(); ++i) {\n    long long k = -1;\n    for (long long j = 0; j < (long long)comp.size(); ++j)\n      if (i != j) {\n        if (((compb[i] & compb[j]) == compb[i] &&\n             (compb[i] != compb[j] || comp[j].size() == 1)) &&\n            (k == -1 || compb[j].count() < compb[k].count() ||\n             (compb[j].count() == compb[k].count() && comp[j].size() > 1))) {\n          k = j;\n        }\n      }\n    if (k != -1) f[k].push_back(i);\n  }\n  long long res = 1;\n  for (long long i = 0; i < (long long)comp.size(); ++i)\n    res = (res * calc(i)) % mod;\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, fac[1010];\nclass PQ_Tree {\n private:\n  int n;\n\n public:\n  struct node {\n    vector<int> son;\n    int type, op, siz, cnt;\n  } t[1010 << 1];\n  int tot, rt;\n  bool OK;\n  bitset<1010> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; ++i) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n) {\n      return (void)(t[u].cnt = vis[u], t[u].siz = 1, t[u].op = vis[u] ? 2 : 1);\n    }\n    t[u].op = t[u].siz = t[u].cnt = 0;\n    for (auto v : t[u].son) {\n      dfs1(v);\n      t[u].cnt += t[v].cnt;\n      t[u].siz += t[v].siz;\n      t[u].op |= t[v].op;\n    }\n  }\n  inline int GT(int u) { return t[u].cnt ? (t[u].cnt == t[u].siz ? 2 : 1) : 0; }\n  int dfs2(int u, int lim) {\n    if (!OK || t[u].op ^ 3) return u;\n    vector<int> a[3];\n    for (auto v : t[u].son) {\n      a[GT(v)].push_back(v);\n    }\n    if ((lim > 0) + a[1].size() >= 3) {\n      OK = false;\n    }\n    if (!lim) {\n      for (auto &v : t[u].son) {\n        if (t[v].cnt == t[u].cnt) {\n          v = dfs2(v, 0);\n          return u;\n        }\n      }\n    }\n    if (t[u].type) {\n      int now = 0;\n      vector<int> S;\n      if (GT(t[u].son[0]) == 2 || !GT(t[u].son.back())) {\n        reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (auto v : t[u].son) {\n        int Type = GT(v);\n        if (Type == 0) {\n          S.push_back(v);\n          now += now == 1;\n        } else if (Type == 1) {\n          if (now == 2) OK = false;\n          ++now;\n          int w = dfs2(v, 3 - now);\n          S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n        } else {\n          S.push_back(v);\n          now += !now;\n          if (now == 2) OK = false;\n        }\n      }\n      if (lim && now == 2) OK = false;\n      if (lim == 1) reverse(S.begin(), S.end());\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1)\n        z = a[2][0];\n      else if (a[2].size() > 1)\n        z = ++tot, t[z].type = 0, t[z].son = a[2];\n      vector<int> S;\n      if (!a[1].empty()) {\n        int w = dfs2(a[1][0], 2);\n        S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n      }\n      if (~z) S.push_back(z);\n      if (a[1].size() > 1) {\n        int w = dfs2(a[1][1], 1);\n        S.insert(S.end(), t[w].son.begin(), t[w].son.end());\n      }\n      if (a[0].empty()) {\n        if (lim == 1) reverse(S.begin(), S.end());\n        t[u].type = 1, t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[0][0];\n          if (a[0].size() > 1) {\n            z = ++tot;\n            t[z].type = 0;\n            t[z].son = a[0];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = S[0];\n          if (S.size() > 1) z = ++tot, t[z].son = S, t[z].type = 1;\n          t[u].son = a[0];\n          t[u].son.push_back(z);\n        }\n      }\n    }\n    return u;\n  }\n  bool Insert(const bitset<1010> &B) {\n    vis = B;\n    dfs1(rt);\n    OK = true;\n    rt = dfs2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (auto v : t[u].son) ans = 1LL * ans * calc(v) % mod;\n    return ans;\n  }\n} T;\nint main() {\n  n = read(), m = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  T.init(n);\n  while (m--) {\n    static bitset<1010> B;\n    B.reset();\n    int k = read();\n    while (k--) B[read()] = 1;\n    if (!T.Insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 998244353;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int MOD = 998244353;\nstruct Mint {\n  int val;\n  Mint() { val = 0; }\n  Mint(ll x) {\n    val = (-MOD <= x && x < MOD) ? x : x % MOD;\n    if (val < 0) val += MOD;\n  }\n  template <typename U>\n  explicit operator U() const {\n    return (U)val;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n  Mint& operator+=(const Mint& m) {\n    if ((val += m.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((val -= m.val) < 0) val += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    val = (ll)val * m.val % MOD;\n    return *this;\n  }\n  friend Mint modex(Mint a, ll p) {\n    assert(p >= 0);\n    Mint ans = 1;\n    for (; p; p >>= 1, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  Mint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  Mint operator++(int) {\n    Mint result(*this);\n    *this += 1;\n    return result;\n  }\n  Mint operator--(int) {\n    Mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  Mint operator-() const { return Mint(-val); }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n  friend string to_string(const Mint& b) { return to_string(b.val); }\n};\nvector<Mint> fac(1, 1), invfac(1, 1);\nMint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  while (fac.size() <= n) {\n    fac.push_back(fac.back() * fac.size());\n    invfac.push_back(1 / fac.back());\n  }\n  return fac[n] * invfac[k] * invfac[n - k];\n}\nstruct PqTree {\n  int n;\n  int fail = 0;\n  vector<vector<int>> G;\n  vector<int> ty, sz, szc;\n  vector<bool> s;\n  PqTree(int _n) : n(_n), G(n + 2), ty(n + 2), sz(n + 2), szc(n + 2), s(n + 1) {\n    assert(n >= 1);\n    for (int i = 1; i <= n; ++i) G[n + 1].push_back(i);\n  }\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(const vector<int>& vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G.push_back(vec);\n    ty.push_back(0);\n    sz.push_back(0);\n    szc.push_back(0);\n    return G.size() - 1;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      }\n      ty[u] = 1;\n      G[u].clear();\n      addson(u, p2);\n      if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n      addson(u, mergeP(vec[0]));\n      if (t == 2) reverse(G[u].begin(), G[u].end());\n      return u;\n    }\n    if (getstate(G[u].front()) > getstate(G[u].back()))\n      reverse(G[u].begin(), G[u].end());\n    int flag = 0;\n    vector<int> tG;\n    for (auto v : G[u]) {\n      int sta = getstate(v);\n      if (sta == 0) {\n        if (flag == 1) flag = 2;\n        tG.push_back(v);\n      } else if (sta == 2) {\n        if (flag == 0)\n          flag = 1;\n        else if (flag == 2)\n          return fail = 2, 0;\n        tG.push_back(v);\n      } else {\n        if (flag == 0)\n          flag = 1, check(v, 2);\n        else if (flag == 1)\n          flag = 2, check(v, 1);\n        else\n          return fail = 3, 0;\n        for (auto x : G[v]) tG.push_back(x);\n      }\n    }\n    if (t && flag == 2) return fail = 4, 0;\n    if (t == 1) reverse(tG.begin(), tG.end());\n    G[u] = tG;\n    return u;\n  }\n  void dfsPermutation(int u, vector<int>& per) {\n    if (u <= n) per.push_back(u);\n    for (auto v : G[u]) dfsPermutation(v, per);\n  }\n  vector<int> getPermutation() {\n    vector<int> res;\n    dfsPermutation(n + 1, res);\n    return res;\n  }\n  Mint dfsCount(int u) {\n    if (u <= n) {\n      assert(G[u].empty());\n      return 1;\n    }\n    assert(!G[u].empty());\n    Mint ret = 1;\n    if (!ty[u]) {\n      ret *= fac[G[u].size()];\n    } else if (G[u].size() != 1) {\n      ret *= 2;\n    }\n    for (auto v : G[u]) ret *= dfsCount(v);\n    return ret;\n  }\n  Mint countPermutations() {\n    if (fail) return 0;\n    binom(n, 0);\n    return dfsCount(n + 1);\n  }\n  void restrict(const vector<int>& res) {\n    for (int i = 1; i <= n; ++i) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  PqTree pq(n);\n  for (int i = 0; i < m; ++i) {\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> res;\n    while (q--) {\n      int s;\n      scanf(\"%d\", &s);\n      res.push_back(s);\n    }\n    pq.restrict(res);\n  }\n  Mint ans = pq.countPermutations();\n  printf(\"%d\\n\", ans.val);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::vector;\nconst int N = 105, MOD = 998244353;\nint n, m, sz[N], fac[N], inv[N], id[N];\nbitset<N> q[N];\nvector<bitset<N> > v;\nbitset<N> U;\ninline void prt(bitset<N> x) {\n  for (int i = 1; i <= n; ++i)\n    if (x.test(i)) printf(\"%d \", i);\n  puts(\"\");\n}\ninline int solve(bitset<N> v, vector<bitset<N> > q, int cnt, int ok) {\n  if (!v.count()) return 1;\n  if (q.empty())\n    return ok ? 1ll * fac[v.count()] * (cnt + 1) % MOD\n              : 1ll * fac[v.count() + cnt] * inv[cnt] % MOD;\n  vector<bitset<N> > e;\n  e.push_back((*q.rbegin()) & v);\n  q.pop_back();\n  while (1) {\n    bool ok = 0;\n    vector<bitset<N> > buff;\n    for (auto &x : q) {\n      int l = 0;\n      while (l < e.size() && (e[l] & x).none()) ++l;\n      if (l == e.size()) continue;\n      if ((e[l] & x) == x) continue;\n      int r = l + 1;\n      bitset<N> tmp;\n      tmp = e[l];\n      while (r < e.size() && (e[r] & x) == e[r]) tmp |= e[r], ++r;\n      if (r != e.size()) tmp |= e[r];\n      tmp &= x;\n      if (l == r && (e[r] & x) == x) continue;\n      for (int i = r + 1; i < e.size(); ++i)\n        if ((e[i] & x).any()) puts(\"0\"), exit(0);\n      if (l && r != e.size() && tmp != x) puts(\"0\"), exit(0);\n      if (tmp != x) {\n        ok = 1;\n        if (!l)\n          e.insert(e.begin(), x ^ tmp), buff.push_back(x & tmp);\n        else if (r == e.size())\n          e.push_back(x ^ tmp), buff.push_back(x & tmp);\n        else\n          puts(\"0\"), exit(0);\n        break;\n      }\n      if (r < e.size() && (e[r] & x).any()) {\n        auto a = e[r] & x;\n        ok = 1;\n        e[r] ^= a;\n        assert(e.size() >= r);\n        e.insert(e.begin() + r, a);\n        break;\n      }\n      if (l < e.size() && (e[l] & x) != e[l]) {\n        auto a = e[l] & x;\n        ok = 1;\n        e[l] ^= a;\n        assert(e.size() >= l + 1);\n        e.insert(e.begin() + l + 1, a);\n        break;\n      }\n    }\n    for (auto &x : buff) q.push_back(x);\n    if (!ok) break;\n  }\n  auto debug = v;\n  for (auto &x : e) v ^= x;\n  int ret = 1;\n  for (auto &x : e) {\n    vector<bitset<N> > tmp;\n    for (auto &y : q)\n      if ((x & y).any() && (x & y) != x) tmp.push_back(y);\n    ret = 1ll * ret * solve(x, tmp, 0, 1) % MOD;\n  }\n  if (e.size() > 1) ret = 2ll * ret % MOD;\n  vector<bitset<N> > tmp;\n  int cok = 0;\n  for (auto &y : q)\n    if ((v & y).any()) {\n      if ((v & y) != v)\n        tmp.push_back(y);\n      else\n        cok = 1;\n    }\n  ret = 1ll * ret * solve(v, tmp, (ok ? 0 : cnt) + 1, cok) % MOD;\n  ret = 1ll * ret * (cnt + 1) % MOD;\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  inv[0] = inv[1] = fac[0] = 1;\n  for (int i = 2; i <= n; ++i)\n    inv[i] = MOD - 1ll * (MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= n; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % MOD,\n    inv[i] = 1ll * inv[i] * inv[i - 1] % MOD;\n  for (int i = 1; i <= n; ++i) U.set(i);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d\", sz + i);\n    for (int j = 1, x; j <= sz[i]; ++j) scanf(\"%d\", &x), q[i].set(x);\n    id[i] = i;\n  }\n  std::sort(id + 1, id + m + 1,\n            [](int x, int y) { return q[x].count() < q[y].count(); });\n  for (int i = 1; i <= m; ++i)\n    if (q[id[i]].count() < n) v.push_back(q[id[i]]);\n  printf(\"%d\\n\", solve(U, v, 0, 0));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct PQtree {\n  int type, father;\n  vector<int> child;\n} t[2010];\nint n, pd[2010], w[2010], size[2010], in[5010], B[2010],\n    W[3] = {0, 2, 1}, ans[2010], C[600][600], len, kk;\nvector<int> rem, A;\nchar getin() {\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  return ch;\n}\nint getnext() {\n  int k1 = rem[(rem.size()) - 1];\n  rem.pop_back();\n  t[k1].child.clear();\n  t[k1].type = 0;\n  t[k1].father = 0;\n  return k1;\n}\nvoid reverse(int k) {\n  vector<int> k1;\n  for (int i = 0; i < t[k].child.size(); i++) k1.push_back(t[k].child[i]);\n  t[k].child.clear();\n  for (int i = (k1.size()) - 1; i >= 0; i--) t[k].child.push_back(k1[i]);\n}\nvoid change(int k1, int k2, int k3) {\n  if (k1 == 0) return;\n  for (int i = 0; i < t[k1].child.size(); i++)\n    if (t[k1].child[i] == k2) {\n      t[k1].child[i] = k3;\n      return;\n    }\n}\nint reduce() {\n  memset(B, 0x00, sizeof B);\n  memset(size, 0x00, sizeof size);\n  memset(w, 0x00, sizeof w);\n  memset(pd, 0xff, sizeof pd);\n  queue<int> Q;\n  for (int i = 1; i <= n; i++) {\n    Q.push(i);\n    pd[i] = in[i];\n    w[i] = in[i];\n  }\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    int flag = 0;\n    if (w[k] == A.size()) flag = 1;\n    if (pd[k] == 2) {\n      vector<int> C[3];\n      for (int i = 0; i < t[k].child.size(); i++) {\n        int j = t[k].child[i];\n        C[pd[j]].push_back(j);\n      }\n      if (t[k].type == 1) {\n        if (C[2].size() == 0) {\n          if (flag == 1) {\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k1].father = k;\n              t[k].child.clear();\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k1);\n            }\n          } else {\n            t[k].type = 2;\n            t[k].child.clear();\n            if (C[0].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n            } else if (C[0].size())\n              t[k].child.push_back(C[0][0]);\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n            } else if (C[1].size())\n              t[k].child.push_back(C[1][0]);\n          }\n        } else if (C[2].size() == 1) {\n          if (flag == 1) {\n            t[k].child.clear();\n            if (C[1].size() == 1) {\n              t[C[2][0]].child.push_back(C[1][0]);\n              t[C[1][0]].father = C[2][0];\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(C[2][0]);\n            } else if (C[1].size()) {\n              int k1 = getnext(), k2 = C[2][0];\n              t[k1].type = 1;\n              t[k1].father = k2;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k2].child.push_back(k1);\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k2);\n            }\n            if (t[k].child.size() == 1) {\n              t[t[k].child[0]].father = t[k].father;\n              change(t[k].father, k, t[k].child[0]);\n              rem.push_back(k);\n            }\n          } else {\n            t[k].child.clear();\n            t[k].type = 2;\n            if (C[0].size() == 1)\n              t[k].child.push_back(C[0][0]);\n            else if (C[0].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            if (C[1].size() == 1)\n              t[k].child.push_back(C[1][0]);\n            else if (C[1].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            rem.push_back(k2);\n          }\n        } else if (C[2].size() == 2) {\n          if (flag == 0) return 0;\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k1 = getnext();\n          int k2 = C[2][0];\n          t[k1].type = 2;\n          t[k1].father = k;\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          pd[k1] = 2;\n          if (C[1].size() == 1) {\n            t[k1].child.push_back(C[1][0]);\n            t[C[1][0]].father = k1;\n          } else if (C[1].size()) {\n            int k3 = getnext();\n            t[k3].type = 1;\n            t[k3].father = k1;\n            pd[k3] = 1;\n            for (int i = 0; i < C[1].size(); i++) {\n              t[k3].child.push_back(C[1][i]);\n              t[C[1][i]].father = k3;\n            }\n            t[k1].child.push_back(k3);\n          }\n          t[k].child.push_back(k1);\n          k2 = C[2][1];\n          for (int i = (t[k2].child.size()) - 1; i >= 0; i--) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          if (t[k].child.size() == 1) {\n            t[k1].father = t[k].father;\n            change(t[k].father, k, k1);\n            rem.push_back(k);\n          }\n        } else\n          return 0;\n      } else {\n        int now = 0, flag2 = 0;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] < now) {\n            flag2 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        int flag3 = 0;\n        now = 2;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] > now) {\n            flag3 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        if ((flag2 == 0 || flag3 == 0) && C[2].size() == 1) {\n          if (flag3 == 0) {\n            reverse(k);\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n          }\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k2 = C[2][0];\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k;\n          }\n          rem.push_back(k2);\n          for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n        } else if (C[2].size() <= 2 && C[2].size() >= 1) {\n          if (flag == 0) return 0;\n          int two1 = -1, two2 = -1;\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int j = t[k].child[i];\n            if (pd[j] == 2) {\n              if (two1 != -1)\n                two2 = i;\n              else\n                two1 = i;\n            }\n          }\n          if (C[2].size() == 2) {\n            for (int i = 0; i < two1; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            for (int i = two1 + 1; i < two2; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 1) return 0;\n            }\n            for (int i = two2 + 1; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            reverse(C[2][1]);\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            k2 = C[2][1];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          } else {\n            int flag4 = 0;\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] == 1) {\n                flag4 = 1;\n                break;\n              }\n            }\n            if (flag4) {\n              reverse(k);\n              two1 = (t[k].child.size()) - two1 - 1;\n            }\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1]) return 0;\n            }\n            int now = 1;\n            for (int i = two1 + 1; i < t[k].child.size(); i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] > now) return 0;\n              now = pd[k1];\n            }\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          }\n        } else if (C[2].size() == 0) {\n          if (pd[t[k].child[0]] == 1) reverse(k);\n          int k1 = t[k].child.size();\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 1) {\n              k1 = i;\n              break;\n            }\n          }\n          int k3 = t[k].child.size();\n          for (int i = k1; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 0) {\n              k3 = i;\n              break;\n            }\n          }\n          if (flag == 0 && k3 != t[k].child.size()) return 0;\n          if (flag == 1)\n            for (int i = k3; i < t[k].child.size(); i++) {\n              int k2 = t[k].child[i];\n              if (pd[k2] == 1) return 0;\n            }\n        } else\n          return 0;\n      }\n    }\n    if (flag) return 1;\n    int k1 = t[k].father;\n    size[k1]++;\n    w[k1] += w[k];\n    if (pd[k1] == -1)\n      pd[k1] = pd[k];\n    else if (pd[k1] != pd[k])\n      pd[k1] = 2;\n    if (size[k1] == t[k1].child.size()) Q.push(k1);\n  }\n}\nint mod = 998244353;\nlong long aa = 1;\nvoid print(int k) {\n  int m = t[k].child.size();\n  if (t[k].type == 1) {\n    for (int i = 1; i <= m; i++) aa = aa * i % mod;\n  } else if (t[k].type == 2) {\n    aa = aa * 2 % mod;\n  }\n  if (t[k].type == 0) {\n    ans[++len] = k;\n    return;\n  }\n  for (int i = 0; i < t[k].child.size(); i++) print(t[k].child[i]);\n}\nint m;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    t[i].type = 0;\n    t[i].father = n + 1;\n    t[i].child.clear();\n    t[n + 1].child.push_back(i);\n  }\n  t[n + 1].type = 1;\n  for (int i = 2000; i > n + 1; i--) rem.push_back(i);\n  for (int i = 1; i <= m; i++) {\n    memset(in, 0x00, sizeof in);\n    A.clear();\n    int x;\n    scanf(\"%d\", &x);\n    for (int j = 1; j <= x; j++) {\n      int y;\n      scanf(\"%d\", &y);\n      C[i][y] = 1;\n      A.push_back(y);\n      in[y] = 1;\n    }\n    kk = i;\n    if (reduce() == 0) {\n      cout << \"0\" << endl;\n      return 0;\n    }\n  }\n  int root = 1;\n  while (t[root].father) root = t[root].father;\n  print(root);\n  printf(\"%lld\\n\", aa);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nint bic[1 << 16 | 5];\nvoid init() {\n  for (int i = 0; i < 1 << 16; i++) bic[i] = bic[i >> 1] + (i & 1);\n}\nstruct Bitset {\n  unsigned long long a[2];\n  Bitset() { a[0] = a[1] = 0; }\n  void clear() { a[0] = a[1] = 0; }\n  void set(int x) { a[x >> 6] |= (1ull << (x & 63)); }\n  bool get(int x) const { return (a[x >> 6] >> (x & 63)) & 1; }\n  Bitset operator|(const Bitset &b) const {\n    Bitset c;\n    c.a[0] = a[0] | b.a[0];\n    c.a[1] = a[1] | b.a[1];\n    return c;\n  }\n  Bitset operator^(const Bitset &b) const {\n    Bitset c;\n    c.a[0] = a[0] ^ b.a[0];\n    c.a[1] = a[1] ^ b.a[1];\n    return c;\n  }\n  Bitset operator&(const Bitset &b) const {\n    Bitset c;\n    c.a[0] = a[0] & b.a[0];\n    c.a[1] = a[1] & b.a[1];\n    return c;\n  }\n  int count() const {\n    int ans = 0;\n    ans += bic[a[0] & 65535] + bic[(a[0] >> 16) & 65535] +\n           bic[(a[0] >> 32) & 65535] + bic[a[0] >> 48];\n    ans += bic[a[1] & 65535] + bic[(a[1] >> 16) & 65535] +\n           bic[(a[1] >> 32) & 65535] + bic[a[1] >> 48];\n    return ans;\n  }\n  bool operator==(const Bitset &b) const {\n    return a[0] == b.a[0] && a[1] == b.a[1];\n  }\n  bool operator!=(const Bitset &b) const {\n    return a[0] != b.a[0] || a[1] != b.a[1];\n  }\n  operator bool() { return a[0] != 0 || a[1] != 0; }\n} B[N], C[N];\nint n, m, bad, ct;\nint vis[N], e[N][N];\nbool Judpre(int *mode) {\n  int s = 0;\n  for (int i = 1; i <= ct; i++)\n    if (mode[i] == 1) ++s;\n  if (s > 1) return 0;\n  for (int i = 1; i < ct; i++)\n    if (mode[i] < mode[i + 1]) return 0;\n  return 1;\n}\nbool Judsuf(int *mode) {\n  int s = 0;\n  for (int i = 1; i <= ct; i++)\n    if (mode[i] == 1) ++s;\n  if (s > 1) return 0;\n  for (int i = 1; i < ct; i++)\n    if (mode[i] > mode[i + 1]) return 0;\n  return 1;\n}\nbool Judinter(int *mode) {\n  int s1 = 0;\n  for (int i = 1; i <= ct; i++)\n    if (mode[i] == 1) ++s1;\n  if (s1 > 2) return 0;\n  int l = 1, r = ct;\n  for (; l != ct && mode[l] <= mode[l + 1]; ++l)\n    ;\n  for (; r != 1 && mode[r] <= mode[r - 1]; --r)\n    ;\n  if (s1 == 2 && mode[l] == 2) {\n    for (int i = 1; i <= l; i++)\n      if (mode[i] == 1) --s1;\n    if (s1 != 1) return 0;\n  }\n  return l >= r;\n}\nvoid Insert(int loc, Bitset A) {\n  ++ct;\n  for (int i = ct; i > loc; i--) C[i] = C[i - 1];\n  C[loc] = A;\n}\nvoid Insert(Bitset A) {\n  Bitset Copy_A = A;\n  static int mode[N];\n  for (int i = 1; i <= ct; i++) {\n    Bitset Int = A & C[i];\n    if (Int)\n      mode[i] = (Int != C[i] ? 1 : 2);\n    else\n      mode[i] = 0;\n    A = A ^ Int;\n  }\n  bool pre = 0, suf = 0, inter = 0;\n  pre = Judpre(mode);\n  suf = Judsuf(mode);\n  inter = Judinter(mode);\n  if (!inter) return bad = 1, void(0);\n  if (!pre && !suf && A) return bad = 1, void(0);\n  if (!suf && A) {\n    reverse(C + 1, C + ct + 1);\n    reverse(mode + 1, mode + ct + 1);\n  }\n  if (A) {\n    C[++ct] = A;\n    mode[ct] = 2;\n  }\n  for (int i = ct; i >= 1; i--)\n    if (mode[i] == 1) {\n      Bitset b1 = C[i] & Copy_A;\n      Bitset b2 = b1 ^ C[i];\n      if (i >= 2 && mode[i - 1] != 0)\n        C[i] = b1, Insert(i + 1, b2);\n      else if (i != ct && mode[i + 1] != 0)\n        C[i] = b2, Insert(i + 1, b1);\n      else\n        assert(0);\n    }\n}\nstruct Mynode {\n  Bitset fi;\n  vector<Bitset> se;\n  bool operator<(const Mynode &a) const {\n    if (fi.count() != a.fi.count()) return fi.count() > a.fi.count();\n    return se.size() < a.se.size();\n  }\n} node[N];\nint nodet;\nvoid update(int S) {\n  static int q[N];\n  int h = 0, t = 1;\n  ct = 1;\n  q[1] = S;\n  vis[S] = 1;\n  C[1] = B[S];\n  while (h != t && !bad) {\n    int x = q[++h];\n    for (int i = 1; i <= m; i++)\n      if (e[x][i] && !vis[i] && !bad) q[++t] = i, vis[i] = 1, Insert(B[i]);\n  }\n  if (bad) {\n    puts(\"0\");\n    exit(0);\n  }\n  ++nodet;\n  for (int i = 1; i <= ct; i++) {\n    node[nodet].fi = node[nodet].fi | C[i];\n    node[nodet].se.push_back(C[i]);\n  }\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d\", &x);\n    for (; x; --x) {\n      scanf(\"%d\", &y);\n      B[i].set(y);\n    }\n    bool flag = 0;\n    for (int j = 1; j < i; j++)\n      if (B[i] == B[j]) flag = 1;\n    if (flag) {\n      B[i].clear();\n      --i, --m;\n    }\n  }\n  for (int i = 1; i <= m; i++)\n    for (int j = i + 1; j <= m; j++)\n      if (B[i] & B[j])\n        if ((B[i] & B[j]) != B[i])\n          if ((B[i] & B[j]) != B[j]) e[i][j] = e[j][i] = 1;\n  for (int i = 1; i <= m; i++)\n    if (!vis[i]) update(i);\n  ++nodet;\n  Bitset ful;\n  for (int i = 1; i <= n; i++) ful.set(i);\n  node[nodet].fi = ful;\n  node[nodet].se.push_back(ful);\n  sort(node + 1, node + nodet + 1);\n  int ans = 1;\n  int mo = 998244353;\n  for (int i = 1; i <= nodet; i++) {\n    if (node[i].se.size() >= 2) ans = 2ll * ans % mo;\n    for (auto j : node[i].se) {\n      int cnt = j.count();\n      Bitset Copy_j = j;\n      for (int k = i + 1; k <= nodet; k++)\n        if ((node[k].fi & Copy_j) == node[k].fi) {\n          Copy_j = Copy_j ^ node[k].fi;\n          cnt -= node[k].fi.count() - 1;\n        }\n      for (; cnt; --cnt) ans = 1ll * cnt * ans % mo;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  T b = m, u = 0, v = 1;\n  while (a) {\n    T t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {}\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n  explicit operator int() const { return v; }\n  bool operator==(const modnum& o) const { return v == o.v; }\n  bool operator!=(const modnum& o) const { return v != o.v; }\n  modnum inverse() const { return modnum(::inverse(v, P)); }\n  modnum operator-() const { return modnum(v ? P - v : 0); }\n  modnum operator+() const { return *this; }\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n  modnum operator+(const modnum& o) const { return modnum(*this) += o; }\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n  modnum operator-(const modnum& o) const { return modnum(*this) -= o; }\n  modnum& operator*=(const modnum& o) {\n    v = (int)((long long)v * o.v % P);\n    return *this;\n  }\n  modnum operator*(const modnum& o) const { return modnum(*this) *= o; }\n  modnum& operator/=(const modnum& o) { return *this *= o.inverse(); }\n  modnum operator/(const modnum& o) const { return modnum(*this) /= o; }\n};\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\nusing num = modnum<998244353>;\nnum ways = 1;\nstruct PQtree {\n  int type, father;\n  vector<int> child;\n} t[2010];\nint n, pd[2010], w[2010], size[2010], in[5010], B[2010],\n    W[3] = {0, 2, 1}, ans[2010], C[600][600], len, kk;\nvector<int> rem, A;\nchar getin() {\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  return ch;\n}\nint getnext() {\n  int k1 = rem[(rem.size()) - 1];\n  rem.pop_back();\n  t[k1].child.clear();\n  t[k1].type = 0;\n  t[k1].father = 0;\n  return k1;\n}\nvoid reverse(int k) {\n  vector<int> k1;\n  for (int i = 0; i < t[k].child.size(); i++) k1.push_back(t[k].child[i]);\n  t[k].child.clear();\n  for (int i = (k1.size()) - 1; i >= 0; i--) t[k].child.push_back(k1[i]);\n}\nvoid change(int k1, int k2, int k3) {\n  if (k1 == 0) return;\n  for (int i = 0; i < t[k1].child.size(); i++)\n    if (t[k1].child[i] == k2) {\n      t[k1].child[i] = k3;\n      return;\n    }\n}\nint reduce() {\n  memset(B, 0x00, sizeof B);\n  memset(size, 0x00, sizeof size);\n  memset(w, 0x00, sizeof w);\n  memset(pd, 0xff, sizeof pd);\n  queue<int> Q;\n  for (int i = 1; i <= n; i++) {\n    Q.push(i);\n    pd[i] = in[i];\n    w[i] = in[i];\n  }\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    int flag = 0;\n    if (w[k] == A.size()) flag = 1;\n    if (pd[k] == 2) {\n      vector<int> C[3];\n      for (int i = 0; i < t[k].child.size(); i++) {\n        int j = t[k].child[i];\n        C[pd[j]].push_back(j);\n      }\n      if (t[k].type == 1) {\n        if (C[2].size() == 0) {\n          if (flag == 1) {\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k1].father = k;\n              t[k].child.clear();\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k1);\n            }\n          } else {\n            t[k].type = 2;\n            t[k].child.clear();\n            if (C[0].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n            } else if (C[0].size())\n              t[k].child.push_back(C[0][0]);\n            if (C[1].size() > 1) {\n              int k1 = getnext();\n              t[k1].father = k;\n              t[k].child.push_back(k1);\n              t[k1].type = 1;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n            } else if (C[1].size())\n              t[k].child.push_back(C[1][0]);\n          }\n        } else if (C[2].size() == 1) {\n          if (flag == 1) {\n            t[k].child.clear();\n            if (C[1].size() == 1) {\n              t[C[2][0]].child.push_back(C[1][0]);\n              t[C[1][0]].father = C[2][0];\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(C[2][0]);\n            } else if (C[1].size()) {\n              int k1 = getnext(), k2 = C[2][0];\n              t[k1].type = 1;\n              t[k1].father = k2;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k2].child.push_back(k1);\n              for (int i = 0; i < C[0].size(); i++)\n                t[k].child.push_back(C[0][i]);\n              t[k].child.push_back(k2);\n            }\n            if (t[k].child.size() == 1) {\n              t[t[k].child[0]].father = t[k].father;\n              change(t[k].father, k, t[k].child[0]);\n              rem.push_back(k);\n            }\n          } else {\n            t[k].child.clear();\n            t[k].type = 2;\n            if (C[0].size() == 1)\n              t[k].child.push_back(C[0][0]);\n            else if (C[0].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 0;\n              for (int i = 0; i < C[0].size(); i++) {\n                t[k1].child.push_back(C[0][i]);\n                t[C[0][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            if (C[1].size() == 1)\n              t[k].child.push_back(C[1][0]);\n            else if (C[1].size()) {\n              int k1 = getnext();\n              t[k1].type = 1;\n              t[k1].father = k;\n              pd[k1] = 1;\n              for (int i = 0; i < C[1].size(); i++) {\n                t[k1].child.push_back(C[1][i]);\n                t[C[1][i]].father = k1;\n              }\n              t[k].child.push_back(k1);\n            }\n            rem.push_back(k2);\n          }\n        } else if (C[2].size() == 2) {\n          if (flag == 0) return 0;\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k1 = getnext();\n          int k2 = C[2][0];\n          t[k1].type = 2;\n          t[k1].father = k;\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          pd[k1] = 2;\n          if (C[1].size() == 1) {\n            t[k1].child.push_back(C[1][0]);\n            t[C[1][0]].father = k1;\n          } else if (C[1].size()) {\n            int k3 = getnext();\n            t[k3].type = 1;\n            t[k3].father = k1;\n            pd[k3] = 1;\n            for (int i = 0; i < C[1].size(); i++) {\n              t[k3].child.push_back(C[1][i]);\n              t[C[1][i]].father = k3;\n            }\n            t[k1].child.push_back(k3);\n          }\n          t[k].child.push_back(k1);\n          k2 = C[2][1];\n          for (int i = (t[k2].child.size()) - 1; i >= 0; i--) {\n            t[k1].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k1;\n          }\n          rem.push_back(k2);\n          if (t[k].child.size() == 1) {\n            t[k1].father = t[k].father;\n            change(t[k].father, k, k1);\n            rem.push_back(k);\n          }\n        } else\n          return 0;\n      } else {\n        int now = 0, flag2 = 0;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] < now) {\n            flag2 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        int flag3 = 0;\n        now = 2;\n        for (int i = 0; i < t[k].child.size(); i++) {\n          int j = t[k].child[i];\n          if (W[pd[j]] > now) {\n            flag3 = 1;\n            break;\n          }\n          now = W[pd[j]];\n        }\n        if ((flag2 == 0 || flag3 == 0) && C[2].size() == 1) {\n          if (flag3 == 0) {\n            reverse(k);\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n          }\n          t[k].child.clear();\n          for (int i = 0; i < C[0].size(); i++) t[k].child.push_back(C[0][i]);\n          int k2 = C[2][0];\n          for (int i = 0; i < t[k2].child.size(); i++) {\n            t[k].child.push_back(t[k2].child[i]);\n            t[t[k2].child[i]].father = k;\n          }\n          rem.push_back(k2);\n          for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n        } else if (C[2].size() <= 2 && C[2].size() >= 1) {\n          if (flag == 0) return 0;\n          int two1 = -1, two2 = -1;\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int j = t[k].child[i];\n            if (pd[j] == 2) {\n              if (two1 != -1)\n                two2 = i;\n              else\n                two1 = i;\n            }\n          }\n          if (C[2].size() == 2) {\n            for (int i = 0; i < two1; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            for (int i = two1 + 1; i < two2; i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 1) return 0;\n            }\n            for (int i = two2 + 1; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              if (pd[j] != 0) return 0;\n            }\n            reverse(C[2][1]);\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            k2 = C[2][1];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          } else {\n            int flag4 = 0;\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] == 1) {\n                flag4 = 1;\n                break;\n              }\n            }\n            if (flag4) {\n              reverse(k);\n              two1 = (t[k].child.size()) - two1 - 1;\n            }\n            for (int i = 0; i < two1; i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1]) return 0;\n            }\n            int now = 1;\n            for (int i = two1 + 1; i < t[k].child.size(); i++) {\n              int k1 = t[k].child[i];\n              if (pd[k1] > now) return 0;\n              now = pd[k1];\n            }\n            C[0].clear();\n            C[1].clear();\n            C[2].clear();\n            for (int i = 0; i < t[k].child.size(); i++) {\n              int j = t[k].child[i];\n              C[pd[j]].push_back(j);\n            }\n            t[k].child.clear();\n            for (int i = 0; i < two1; i++) t[k].child.push_back(C[0][i]);\n            int k2 = C[2][0];\n            for (int i = 0; i < t[k2].child.size(); i++) {\n              t[k].child.push_back(t[k2].child[i]);\n              t[t[k2].child[i]].father = k;\n            }\n            rem.push_back(k2);\n            for (int i = 0; i < C[1].size(); i++) t[k].child.push_back(C[1][i]);\n            for (int i = two1; i < C[0].size(); i++)\n              t[k].child.push_back(C[0][i]);\n          }\n        } else if (C[2].size() == 0) {\n          if (pd[t[k].child[0]] == 1) reverse(k);\n          int k1 = t[k].child.size();\n          for (int i = 0; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 1) {\n              k1 = i;\n              break;\n            }\n          }\n          int k3 = t[k].child.size();\n          for (int i = k1; i < t[k].child.size(); i++) {\n            int k2 = t[k].child[i];\n            if (pd[k2] == 0) {\n              k3 = i;\n              break;\n            }\n          }\n          if (flag == 0 && k3 != t[k].child.size()) return 0;\n          if (flag == 1)\n            for (int i = k3; i < t[k].child.size(); i++) {\n              int k2 = t[k].child[i];\n              if (pd[k2] == 1) return 0;\n            }\n        } else\n          return 0;\n      }\n    }\n    if (flag) return 1;\n    int k1 = t[k].father;\n    size[k1]++;\n    w[k1] += w[k];\n    if (pd[k1] == -1)\n      pd[k1] = pd[k];\n    else if (pd[k1] != pd[k])\n      pd[k1] = 2;\n    if (size[k1] == t[k1].child.size()) Q.push(k1);\n  }\n}\nvoid print(int k) {\n  if (t[k].type == 0) {\n    ans[++len] = k;\n    return;\n  }\n  if (t[k].type == 1) {\n    for (int i = 1; i <= t[k].child.size(); i++) {\n      ways *= i;\n    }\n  } else {\n    ways *= 2;\n  }\n  for (int i = 0; i < t[k].child.size(); i++) print(t[k].child[i]);\n}\nint main() {\n  int m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    t[i].type = 0;\n    t[i].father = n + 1;\n    t[i].child.clear();\n    t[n + 1].child.push_back(i);\n  }\n  t[n + 1].type = 1;\n  for (int i = 2000; i > n + 1; i--) rem.push_back(i);\n  for (int i = 1; i <= m; i++) {\n    memset(in, 0x00, sizeof in);\n    A.clear();\n    int sz;\n    scanf(\"%d\", &sz);\n    while (sz--) {\n      int p;\n      scanf(\"%d\", &p);\n      A.push_back(p);\n      in[p] = 1;\n    }\n    kk = i;\n    if (reduce() == 0) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n  int root = 1;\n  while (t[root].father) root = t[root].father;\n  print(root);\n  cout << ways << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 110, P = 998244353;\nint n, m, vis[maxn];\nbitset<maxn> b[maxn];\nvector<int> G[maxn];\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1, q; i <= m; i++) {\n    scanf(\"%d\", &q);\n    while (q--) {\n      int p;\n      scanf(\"%d\", &p);\n      b[i][p] = 1;\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    for (int j = i + 1; j <= m; j++) {\n      auto o = b[i] & b[j];\n      if (o.any() && o != b[i] && o != b[j]) {\n        G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n  }\n  function<int(int, vector<bitset<maxn>> &)> solve =\n      [&](int v, vector<bitset<maxn>> &E) {\n        vis[v] = 1;\n        string inter(E.size(), ' ');\n        auto a = b[v];\n        for (int i = 0; i < E.size(); i++) {\n          auto o = a & E[i];\n          if (o.none())\n            inter[i] = '0';\n          else if (o != E[i])\n            inter[i] = '1';\n          else\n            inter[i] = '2';\n          a &= ~o;\n        }\n        bool pre = regex_match(inter, regex(\"2*1?0*\"));\n        bool suf = regex_match(inter, regex(\"0*1?2*\"));\n        bool interval = regex_match(inter, regex(\"0*1?2*1?0*\"));\n        if (!interval) return 0;\n        if (!pre && !suf && a.any()) return 0;\n        if (!suf && a.any()) {\n          reverse(inter.begin(), inter.end());\n          reverse(E.begin(), E.end());\n        }\n        if (a.any()) E.push_back(a), inter.push_back('2');\n        for (int i = E.size() - 1; ~i; i--)\n          if (inter[i] == '1') {\n            auto o1 = b[v] & E[i], o2 = ~b[v] & E[i];\n            E.erase(E.begin() + i);\n            if (i && inter[i - 1] ^ '0') swap(o1, o2);\n            E.insert(E.begin() + i, o1);\n            E.insert(E.begin() + i, o2);\n          }\n        for (int u : G[v])\n          if (!vis[u]) {\n            if (!solve(u, E)) return 0;\n          }\n        return 1;\n      };\n  vector<pair<bitset<maxn>, vector<bitset<maxn>>>> eq;\n  for (int i = 1; i <= m; i++)\n    if (!vis[i]) {\n      vector<bitset<maxn>> E;\n      if (!solve(i, E)) puts(\"0\"), exit(0);\n      bitset<maxn> o;\n      for (auto &e : E) o |= e;\n      eq.emplace_back(o, E);\n    }\n  bitset<maxn> all;\n  for (int i = 1; i <= n; i++) all[i] = 1;\n  eq.emplace_back(all, vector<bitset<maxn>>{all});\n  sort(eq.begin(), eq.end(),\n       [&](pair<bitset<maxn>, vector<bitset<maxn>>> a,\n           pair<bitset<maxn>, vector<bitset<maxn>>> b) {\n         return make_pair(-a.first.count(), a.second.size()) <\n                make_pair(-b.first.count(), b.second.size());\n       });\n  int ans = 1;\n  for (int i = 0; i < eq.size(); i++) {\n    if (eq[i].second.size() > 1) (ans *= 2) %= P;\n    for (auto o : eq[i].second) {\n      int cnt = o.count();\n      for (int j = i + 1; j < eq.size(); j++) {\n        auto p = eq[j].first;\n        if ((o & p) == p) cnt -= p.count() - 1, o &= ~p;\n      }\n      for (int j = 1; j <= cnt; j++) ans = 1LL * ans * j % P;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconstexpr long long mod = 998244353;\nconst long long INF = mod * mod;\nconst long double eps = 1e-12;\nconst long double pi = acosl(-1.0);\nlong long mod_pow(long long x, long long n, long long m = mod) {\n  if (n < 0) {\n    long long res = mod_pow(x, -n, m);\n    return mod_pow(res, m - 2, m);\n  }\n  if (abs(x) >= m) x %= m;\n  if (x < 0) x += m;\n  long long res = 1;\n  while (n) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\nstruct modint {\n  long long n;\n  modint() : n(0) { ; }\n  modint(long long m) : n(m) {\n    if (n >= mod)\n      n %= mod;\n    else if (n < 0)\n      n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) {\n  a.n += b.n;\n  if (a.n >= mod) a.n -= mod;\n  return a;\n}\nmodint operator-=(modint& a, modint b) {\n  a.n -= b.n;\n  if (a.n < 0) a.n += mod;\n  return a;\n}\nmodint operator*=(modint& a, modint b) {\n  a.n = ((long long)a.n * b.n) % mod;\n  return a;\n}\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, long long n) {\n  if (n == 0) return modint(1);\n  modint res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\nlong long inv(long long a, long long p) {\n  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) {\n  a = a / b;\n  return a;\n}\nconst int max_n = 1 << 10;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n  fact[0] = modint(1);\n  for (int i = 0; i < max_n - 1; i++) {\n    fact[i + 1] = fact[i] * modint(i + 1);\n  }\n  factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n  for (int i = max_n - 2; i >= 0; i--) {\n    factinv[i] = factinv[i + 1] * modint(i + 1);\n  }\n}\nmodint comb(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[a - b];\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> v(m);\n  for (int i = 0; i < m; i++) {\n    int len;\n    cin >> len;\n    v[i].resize(len);\n    for (int j = 0; j < len; j++) {\n      cin >> v[i][j];\n      v[i][j]--;\n    }\n  }\n  vector<vector<int>> ids(n);\n  for (int i = 0; i < m; i++)\n    for (int j = 0; j < v[i].size(); j++) ids[v[i][j]].push_back(i);\n  vector<bool> used(m);\n  modint pro = 1;\n  int cnt = 0;\n  vector<pair<int, int>> vv;\n  for (int i = 0; i < m; i++) {\n    vv.push_back({v[i].size(), i});\n  }\n  sort((vv).begin(), (vv).end(), greater<pair<int, int>>());\n  function<int(vector<int>)> dfs = [&](vector<int> vid) {\n    int cnt = 0;\n    for (int _ = 0; _ < vid.size(); _++) {\n      int i = vid[_];\n      if (used[i]) continue;\n      used[i] = true;\n      vector<vector<int>> vals;\n      vals.push_back(v[i]);\n      priority_queue<pair<int, int>> q;\n      for (int id : v[i])\n        for (int iid : ids[id]) {\n          if (!used[iid]) {\n            q.push({v[iid].size(), iid});\n            used[iid] = true;\n          }\n        }\n      cnt++;\n      if (q.empty()) {\n        pro *= fact[v[i].size()];\n        continue;\n      }\n      bool exiz = false;\n      auto merge = [&](int x) -> bool {\n        int l = mod, r = -mod;\n        bool exi = false;\n        vector<int> cnt(vals.size());\n        vector<int> trans(n, -1);\n        for (int i = 0; i < vals.size(); i++)\n          for (int j = 0; j < vals[i].size(); j++) trans[vals[i][j]] = i;\n        vector<bool> isin(n);\n        for (int id : v[x]) isin[id] = true;\n        for (int id : v[x]) {\n          if (trans[id] < 0) {\n            exi = true;\n            continue;\n          }\n          cnt[trans[id]]++;\n          l = min(l, trans[id]);\n          r = max(r, trans[id]);\n        }\n        if (r - l > 1) {\n          for (int j = l + 1; j < r; j++) {\n            if (cnt[j] != vals[j].size()) {\n              cout << 0 << \"\\n\";\n              exit(0);\n            }\n          }\n        }\n        if (exi) {\n          bool isleft = false;\n          bool isright = false;\n          if (l == 0) {\n            isleft = true;\n            if (r > 0 && vals[0].size() != cnt[0]) isleft = false;\n          }\n          if (r == vals.size() - 1) {\n            isright = true;\n            if (l < r && vals[r].size() != cnt[r]) isright = false;\n          }\n          if (!isleft && !isright) {\n            cout << 0 << \"\\n\";\n            exit(0);\n          }\n          if (isleft) {\n            if (vals[r].size() != cnt[r]) {\n              vector<int> cl, cr;\n              for (int id : vals[r]) {\n                if (isin[id])\n                  cl.push_back(id);\n                else\n                  cr.push_back(id);\n              }\n              vals.erase(vals.begin() + r);\n              vals.insert(vals.begin() + r, cr);\n              vals.insert(vals.begin() + r, cl);\n            }\n            vector<int> cl;\n            for (int id : v[x])\n              if (trans[id] < 0) cl.push_back(id);\n            vals.insert(vals.begin(), cl);\n          } else {\n            if (vals[l].size() != cnt[l]) {\n              vector<int> cl, cr;\n              for (int id : vals[l]) {\n                if (isin[id])\n                  cr.push_back(id);\n                else\n                  cl.push_back(id);\n              }\n              vals.erase(vals.begin() + l);\n              vals.insert(vals.begin() + l, cr);\n              vals.insert(vals.begin() + l, cl);\n            }\n            vector<int> cr;\n            for (int id : v[x])\n              if (trans[id] < 0) cr.push_back(id);\n            vals.push_back(cr);\n          }\n        } else {\n          if (l < r) {\n            if (vals[r].size() != cnt[r]) {\n              vector<int> cl, cr;\n              for (int id : vals[r]) {\n                if (isin[id])\n                  cl.push_back(id);\n                else\n                  cr.push_back(id);\n              }\n              vals.erase(vals.begin() + r);\n              vals.insert(vals.begin() + r, cr);\n              vals.insert(vals.begin() + r, cl);\n            }\n            if (vals[l].size() != cnt[l]) {\n              vector<int> cl, cr;\n              for (int id : vals[l]) {\n                if (isin[id])\n                  cr.push_back(id);\n                else\n                  cl.push_back(id);\n              }\n              vals.erase(vals.begin() + l);\n              vals.insert(vals.begin() + l, cr);\n              vals.insert(vals.begin() + l, cl);\n            }\n          } else {\n            return false;\n          }\n        }\n        exiz = true;\n        return true;\n      };\n      vector<int> zr;\n      while (!q.empty()) {\n        int x = q.top().second;\n        q.pop();\n        for (int id : v[x])\n          for (int iid : ids[id]) {\n            if (!used[iid]) {\n              q.push({v[iid].size(), iid});\n              used[iid] = true;\n            }\n          }\n        if (!merge(x)) {\n          zr.push_back(x);\n        }\n      }\n      while (zr.size()) {\n        bool fin = false;\n        for (int j = 0; j < zr.size(); j++) {\n          if (merge(zr[j])) {\n            zr.erase(zr.begin() + j);\n            fin = true;\n            break;\n          }\n        }\n        if (!fin) break;\n      }\n      for (int id : zr) {\n        used[id] = false;\n      }\n      vector<vector<int>> zid(vals.size());\n      vector<int> trans(n);\n      for (int i = 0; i < vals.size(); i++)\n        for (int j = 0; j < vals[i].size(); j++) trans[vals[i][j]] = i;\n      for (int id : zr) {\n        zid[trans[v[id][0]]].push_back(id);\n      }\n      vector<bool> aft(n);\n      for (int id : zr)\n        for (int iid : v[id]) aft[iid] = true;\n      for (int i = 0; i < vals.size(); i++) {\n        vector<pair<int, int>> nv;\n        for (int id : zid[i]) nv.push_back({v[id].size(), id});\n        sort((nv).begin(), (nv).end(), greater<pair<int, int>>());\n        for (int j = 0; j < nv.size(); j++) {\n          zid[i][j] = nv[j].second;\n        }\n        int c = dfs(zid[i]);\n        for (int id : vals[i])\n          if (!aft[id]) {\n            pro *= c + 1;\n            c++;\n          }\n      }\n      if (exiz) pro *= 2;\n    }\n    pro *= fact[cnt];\n    return cnt;\n  };\n  vector<int> ori(m);\n  for (int i = 0; i < m; i++) {\n    ori[i] = vv[i].second;\n  }\n  int c = dfs(ori);\n  vector<int> exi(n);\n  for (int i = 0; i < m; i++)\n    for (int j = 0; j < v[i].size(); j++) exi[v[i][j]] = true;\n  for (int i = 0; i < n; i++)\n    if (!exi[i]) {\n      pro *= c + 1;\n      c++;\n    }\n  cout << pro << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init_f();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111;\nconst int MO = 998244353;\nint mul(int x, int y) { return (long long)x * y % MO; }\nint fpow(int x, int y = MO - 2) {\n  int z = 1;\n  while (y) {\n    if (y & 1) z = mul(z, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return z;\n}\nint n, q, m, w, a[N], f[N], g[N], h[N];\nbitset<N> d[N], t, c[N];\npair<int, int> solve(bitset<N> u) {\n  int i, j, x, y, l, r;\n  bitset<N> b;\n  j = 0;\n  for (i = 1; i <= q; i++)\n    if (!a[i] && (d[i] & u) == d[i] && d[i].count() > d[j].count()) j = i;\n  if (!j) return make_pair(1, u.count());\n  a[j] = 1;\n  m = 1;\n  c[1] = d[j];\n  b = u ^ c[1];\n  while (1) {\n    x = 1;\n    for (i = 1; i <= q; i++) {\n      if (!a[i] && (d[i] & u) == d[i]) {\n        if ((d[i] & b) == d[i]) continue;\n        for (j = 1; j <= m; j++) {\n          t = d[i] & c[j];\n          h[j] = 0;\n          if (t == c[j])\n            h[j] = 2;\n          else if (t.count())\n            h[j] = 1;\n        }\n        l = m + 1, r = 0;\n        for (j = 1; j <= m; j++)\n          if (h[j]) l = min(l, j), r = max(r, j);\n        for (j = l + 1; j <= r - 1; j++)\n          if (h[j] != 2) return make_pair(0, 1);\n        if ((d[i] & b).count()) {\n          if (l == 1 && (h[l] == 2 || r == 1)) {\n            if (h[r] == 1) {\n              for (j = m; j > r; j--) c[j + 1] = c[j];\n              m++;\n              c[r + 1] = c[r] & (~d[i]);\n              c[r] &= d[i];\n            }\n            for (j = m; j >= 1; j--) c[j + 1] = c[j];\n            m++;\n            c[1] = b & d[i];\n            b &= ~d[i];\n          } else {\n            if (r == m && (h[r] == 2 || l == m)) {\n              m++;\n              c[m] = b & d[i];\n              b &= ~d[i];\n              if (h[l] == 1) {\n                for (j = m; j > l; j--) c[j + 1] = c[j];\n                m++;\n                c[l + 1] = c[l] & d[i];\n                c[l] &= ~d[i];\n              }\n            } else\n              return make_pair(0, 1);\n          }\n          a[i] = 1, x = 0;\n          break;\n        }\n        if (l == r) {\n          if (h[l] == 2) a[i] = 1;\n          continue;\n        }\n        if (h[r] == 1) {\n          for (j = m; j > r; j--) c[j + 1] = c[j];\n          m++;\n          c[r + 1] = c[r] & (~d[i]);\n          c[r] &= d[i];\n        }\n        if (h[l] == 1) {\n          for (j = m; j > l; j--) c[j + 1] = c[j];\n          m++;\n          c[l + 1] = c[l] & d[i];\n          c[l] &= ~d[i];\n        }\n        a[i] = 1, x = 0;\n        break;\n      }\n    }\n    if (x) break;\n  }\n  pair<int, int> p;\n  x = 1;\n  if (m > 1) x = 2;\n  bitset<N> cc[m + 1], bb = b;\n  int mm = m;\n  for (i = 1; i <= mm; i++) cc[i] = c[i];\n  for (i = 1; i <= mm; i++) {\n    p = solve(cc[i]);\n    x = mul(x, p.first);\n    x = mul(x, f[p.second]);\n  }\n  p = solve(bb);\n  x = mul(x, p.first);\n  return make_pair(x, p.second + 1);\n}\nint main() {\n  int i, j, k, x, y;\n  pair<int, int> p;\n  n = 105;\n  f[0] = 1;\n  for (i = 1; i <= n; i++) f[i] = mul(f[i - 1], i);\n  g[n] = fpow(f[n]);\n  for (i = n; i >= 1; i--) g[i - 1] = mul(g[i], i);\n  scanf(\"%d%d\", &n, &q);\n  for (i = 1; i <= q; i++) {\n    scanf(\"%d\", &x);\n    while (x--) {\n      scanf(\"%d\", &y);\n      d[i][y] = 1;\n    }\n  }\n  for (i = 1; i <= n; i++) t[i] = 1;\n  p = solve(t);\n  printf(\"%d\\n\", mul(p.first, f[p.second]));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void chkmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nusing ll = long long;\nusing ld = long double;\nconst string FILENAME = \"input\";\nconst int Mod = 998244353;\nint sum(int a, int b) { return (a + b >= Mod ? a + b - Mod : a + b); }\nint mul(int a, int b) { return ((ll)a * b) % Mod; }\nint powm(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nint inv(int a) { return powm(a, Mod - 2); }\nint ans = 1;\nconst int M = 100228;\nint type[M];\nvector<int> go[M];\nint tsz, root;\nint color[M];\nvoid init(int n) {\n  if (n == 1) {\n    root = tsz = 1;\n  } else {\n    root = tsz = n + 1;\n    type[root] = 1;\n    for (int i = 1; i <= n; i++) go[root].push_back(i);\n  }\n}\nchar *s;\nvoid Paint(int u) {\n  if (type[u] == 0) {\n    color[u] = s[u] == '1' ? 2 : 1;\n  } else {\n    color[u] = 0;\n    for (int v : go[u]) {\n      Paint(v);\n      color[u] |= color[v];\n    }\n  }\n}\nint Merge(vector<int> nodes) {\n  if (nodes.empty()) return 0;\n  if (nodes.size() == 1) return nodes[0];\n  int node = ++tsz;\n  type[node] = 1;\n  go[node] = nodes;\n  return node;\n}\nbool ok = true;\nint Solve(int u, int t) {\n  if (!ok) return 0;\n  if (color[u] != 3) return u;\n  vector<int> ch[3];\n  for (int v : go[u]) ch[color[v] - 1].push_back(v);\n  if (ch[2].size() > 2 || (t > 0 && ch[2].size() > 1)) {\n    ok = false;\n    return 0;\n  }\n  if (type[u] == 1) {\n    if (t == 0) {\n      go[u] = ch[0];\n      if (ch[2].size() == 2 || (ch[2].size() > 0 && ch[1].size() > 0)) {\n        int Q = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        int b = Merge(ch[1]);\n        if (b) go[Q].push_back(b);\n        if (ch[2].size() > 1) {\n          int q = Solve(ch[2][1], 2);\n          if (!ok) return 0;\n          for (int v : go[q]) go[Q].push_back(v);\n        }\n        go[u].push_back(Q);\n      } else if (ch[2].size() == 1) {\n        int Q = Solve(ch[2][0], 0);\n        if (!ok) return 0;\n        go[u].push_back(Q);\n      } else {\n        int b = Merge(ch[1]);\n        if (b) go[u].push_back(b);\n      }\n    } else {\n      type[u] = 2;\n      go[u].clear();\n      int w = Merge(ch[0]);\n      if (w) go[u].push_back(w);\n      if (ch[2].size()) {\n        int g = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        for (int v : go[g]) go[u].push_back(v);\n      }\n      int b = Merge(ch[1]);\n      if (b) go[u].push_back(b);\n      if (t == 2) reverse(go[u].begin(), go[u].end());\n    }\n    if (go[u].size() == 1) return go[u][0];\n    return u;\n  } else {\n    string pattern = t == 0 ? \"wgbgw\" : \"wgb\";\n    int ptr = 0;\n    if (color[go[u][0]] == 2 || color[go[u].back()] == 1)\n      reverse(go[u].begin(), go[u].end());\n    vector<int> ngo;\n    bool strict =\n        t != 0 || ch[2].size() > 1 || (ch[2].size() > 0 && ch[1].size() > 0);\n    for (int v : go[u]) {\n      char col = color[v] == 1 ? 'w' : color[v] == 2 ? 'b' : 'g';\n      while (ptr < pattern.size() && pattern[ptr] != col) ptr++;\n      if (ptr == pattern.size()) {\n        ok = false;\n        return 0;\n      }\n      if (color[v] != 3) {\n        ngo.push_back(v);\n      } else {\n        int Q;\n        if (!strict)\n          Q = Solve(v, 0);\n        else if (ptr == 1)\n          Q = Solve(v, 1);\n        else\n          Q = Solve(v, 2);\n        if (!ok) return 0;\n        if (!strict)\n          ngo.push_back(Q);\n        else\n          for (int h : go[Q]) ngo.push_back(h);\n        ptr++;\n      }\n    }\n    go[u] = ngo;\n    if (t == 2) reverse(go[u].begin(), go[u].end());\n    return u;\n  }\n}\nvoid AddSet(char *t) {\n  if (!ok) return;\n  s = t;\n  Paint(root);\n  root = Solve(root, 0);\n}\nvoid Print(int u) {\n  if (type[u] == 0) {\n    printf(\"%i \", u);\n  } else {\n    if (type[u] == 1) {\n      printf(\"P{ \");\n    } else\n      printf(\"Q[ \");\n    for (int v : go[u]) Print(v);\n    if (type[u] == 1) {\n      printf(\"} \");\n    } else\n      printf(\"] \");\n  }\n}\nvector<int> ord;\nint DFS(int u) {\n  if (type[u] == 0) {\n    ord.push_back(u);\n    return 1;\n  } else {\n    int cnt = 0;\n    for (int v : go[u]) {\n      cnt += DFS(v);\n    }\n    if (type[u] != 1) {\n      if (cnt > 1) {\n        ans = mul(ans, 2);\n      }\n    } else {\n      int cnt = 0;\n      for (int v : go[u]) {\n        cnt++;\n        ans = mul(ans, cnt);\n      }\n    }\n    return cnt;\n  }\n}\nchar mat[1005][1005];\nint main() {\n  int n;\n  cin >> n;\n  init(n);\n  int m;\n  cin >> m;\n  for (int i = 1; i <= m; i++) {\n    int k;\n    cin >> k;\n    string s;\n    for (int j = 0; j <= n; j++) {\n      s += '0';\n    }\n    for (int j = 0; j < k; j++) {\n      int id;\n      cin >> id;\n      s[id] = '1';\n    }\n    for (int j = 0; j <= n; j++) {\n      mat[i][j] = s[j];\n    }\n    AddSet(mat[i]);\n  }\n  if (ok) {\n    ans = 1;\n    DFS(root);\n    cout << ans << '\\n';\n  } else {\n    cout << 0 << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int md = 998244353;\ninline int mul(int a, int b) { return (long long)a * b % md; }\nconst int N = 105;\nint n, m, q[N], ind[N], start[N], prev[N], fact[N],\n    cmp = 1, ord[N], eq[N][N], ord_eq[N * 2], lmost[N], rmost[N], amt[N * N],\n    to[N * N], both[N][N], ans = 1;\nstd::bitset<N> s[N], all[N], other[N], cmp_mask[N];\nbool right[N], u[N], adj[N][N], inside[N][N];\nint in_t;\nvoid dfs(int v) {\n  u[v] = true;\n  ord[in_t++] = v;\n  for (int i = 0; i < m; ++i)\n    if (!u[i] && adj[v][i]) dfs(i);\n}\nint calc(int cur) {\n  u[cur] = true;\n  std::vector<std::pair<int, int> > a;\n  for (int i = 0; i < n; ++i)\n    if (!cur || inside[cur][i]) a.push_back(std::make_pair(eq[cur][i], i));\n  std::sort(a.begin(), a.end());\n  for (int i = 0; i < (int)a.size();) {\n    int j = i;\n    do {\n      ++i;\n    } while (i < (int)a.size() && a[i].first == a[j].first);\n    j = i - j;\n    for (int k = 1; k < cmp; ++k)\n      if ((all[a[i - 1].second] & cmp_mask[cur] | other[cur]) == other[k])\n        j -= calc(k);\n    ans = mul(ans, fact[j]);\n  }\n  return rmost[cur] - lmost[cur];\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N; ++i) fact[i] = mul(fact[i - 1], i);\n  scanf(\"%d%d\", &n, &m);\n  lmost[0] = 0;\n  rmost[0] = n - 1;\n  bool ok = true;\n  for (int i = 0; i < m && ok; ++i) {\n    scanf(\"%d\", q + i);\n    for (int j = 0; j < q[i]; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      s[i].set(x - 1);\n    }\n    bool was = false;\n    for (int j = 0; j < i && !was; ++j)\n      if (s[i] == s[j]) was = true;\n    if (was) {\n      s[i].reset();\n      --i;\n      --m;\n    } else\n      for (int j = 0; j < i; ++j) {\n        std::bitset<N> nd = s[i] & s[j];\n        both[i][j] = both[j][i] = nd.count();\n        if (nd != s[i] && nd != s[j] && nd.any()) adj[i][j] = adj[j][i] = true;\n      }\n  }\n  for (int i = 0; i < m && ok; ++i)\n    if (!u[i]) {\n      in_t = 0;\n      dfs(i);\n      lmost[cmp] = ~(1 << 31);\n      rmost[cmp] = 0;\n      int eq_amt = 1;\n      memset(to, 0, N * N << 2);\n      memset(ord_eq, 0, N << 3);\n      if (in_t > 1) ans = mul(ans, 2);\n      other[cmp].set();\n      for (int i = 0; i < in_t && ok; ++i) {\n        int cur = ord[i];\n        cmp_mask[cmp].set(cur);\n        ind[cur] = cmp;\n        if (!i)\n          start[cur] = N;\n        else {\n          prev[cur] = -1;\n          for (int j = 0; prev[cur] == -1; ++j)\n            if (adj[cur][ord[j]]) prev[cur] = ord[j];\n          if (i == 1) {\n            prev[ord[0]] = cur;\n            right[cur] = true;\n          } else\n            right[cur] = right[prev[cur]] !=\n                         (s[cur] & ~s[prev[cur]] & s[prev[prev[cur]]]).any();\n          if (right[cur])\n            start[cur] = start[prev[cur]] + q[prev[cur]] - both[cur][prev[cur]];\n          else\n            start[cur] = start[prev[cur]] - q[cur] + both[cur][prev[cur]];\n        }\n        for (int j = 0; j < n; ++j)\n          if (s[cur].test(j)) {\n            if (!amt[to[eq[cmp][j]]]) to[eq[cmp][j]] = eq_amt++;\n            eq[cmp][j] = to[eq[cmp][j]];\n            ++amt[eq[cmp][j]];\n            inside[cmp][j] = true;\n          }\n        if (start[cur] < 0 || start[cur] + q[cur] > 2 * N)\n          ok = false;\n        else\n          for (int j = start[cur]; j < start[cur] + q[cur]; ++j) {\n            ord_eq[j] = to[ord_eq[j]];\n            if (!amt[ord_eq[j]]) ok = false;\n            --amt[ord_eq[j]];\n            lmost[cmp] = std::min(lmost[cmp], j);\n            rmost[cmp] = std::max(rmost[cmp], j);\n          }\n      }\n      other[cmp].reset(i);\n      ++cmp;\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j)\n      if (s[j].test(i)) all[i].set(j);\n    for (int j = 0; j < m; ++j)\n      if (s[j].test(i)) other[ind[j]] &= all[i];\n  }\n  memset(u, 0, N);\n  if (ok) {\n    calc(0);\n    printf(\"%d\\n\", ans);\n  } else\n    printf(\"0\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, fac[1010];\nclass PQ_Tree {\n private:\n  int n;\n\n public:\n  struct node {\n    vector<int> son;\n    int type, op;\n  } t[1010 << 1];\n  int tot, rt;\n  bool OK;\n  bitset<1010> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; ++i) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n) return (void)(t[u].op = vis[u] ? 2 : 1);\n    t[u].op = 0;\n    for (auto v : t[u].son) {\n      dfs1(v);\n      t[u].op |= t[v].op;\n    }\n  }\n  void dfs2(int u, int lim) {\n    if (!OK || t[u].op ^ 3) return;\n    vector<int> a[4];\n    for (auto v : t[u].son) {\n      a[t[v].op].push_back(v);\n    }\n    if ((lim > 0) + a[3].size() >= 3) {\n      OK = false;\n    }\n    if (!lim && (a[2].size() + a[3].size()) <= 1) {\n      if (!a[2].empty()) dfs2(a[2][0], 0);\n      if (!a[3].empty()) dfs2(a[3][0], 0);\n      return;\n    }\n    if (t[u].type) {\n      int now = 0;\n      vector<int> S;\n      if (t[t[u].son[0]].op == 2 || t[t[u].son.back()].op == 1) {\n        reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (auto v : t[u].son) {\n        if (t[v].op == 1) {\n          S.push_back(v);\n          now += now == 1;\n        } else if (t[v].op == 2) {\n          S.push_back(v);\n          now += !now;\n          if (now == 2) OK = false;\n        } else {\n          if (now == 2) OK = false;\n          ++now;\n          dfs2(v, 3 - now);\n          S.insert(S.end(), t[v].son.begin(), t[v].son.end());\n        }\n      }\n      if (lim && now == 2) OK = false;\n      if (lim == 1) reverse(S.begin(), S.end());\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1)\n        z = a[2][0];\n      else if (a[2].size() > 1)\n        z = ++tot, t[z].type = 0, t[z].son = a[2];\n      vector<int> S;\n      if (!a[3].empty()) {\n        dfs2(a[3][0], 2);\n        S.insert(S.end(), t[a[3][0]].son.begin(), t[a[3][0]].son.end());\n      }\n      if (~z) S.push_back(z);\n      if (a[3].size() > 1) {\n        dfs2(a[3][1], 1);\n        S.insert(S.end(), t[a[3][1]].son.begin(), t[a[3][1]].son.end());\n      }\n      if (a[1].empty()) {\n        if (lim == 1) reverse(S.begin(), S.end());\n        t[u].type = 1, t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[1][0];\n          if (a[1].size() > 1) {\n            z = ++tot, t[z].type = 0, t[z].son = a[1];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = S[0];\n          if (S.size() > 1) z = ++tot, t[z].son = S, t[z].type = 1;\n          t[u].son = a[1], t[u].son.push_back(z);\n        }\n      }\n    }\n  }\n  bool Insert(const bitset<1010> &B) {\n    vis = B;\n    dfs1(rt);\n    OK = true;\n    dfs2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (auto v : t[u].son) ans = 1LL * ans * calc(v) % mod;\n    return ans;\n  }\n} T;\nint main() {\n  n = read(), m = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  T.init(n);\n  while (m--) {\n    static bitset<1010> B;\n    B.reset();\n    int k = read();\n    while (k--) B[read()] = 1;\n    if (!T.Insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T>\nvoid ckmn(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmx(T &a, T b) {\n  a = max(a, b);\n}\nvoid rd(int &x) { scanf(\"%i\", &x); }\nvoid rd(long long &x) { scanf(\"%lld\", &x); }\nvoid rd(char *x) { scanf(\"%s\", x); }\nvoid rd(double &x) { scanf(\"%lf\", &x); }\nvoid rd(string &x) { scanf(\"%s\", &x); }\ntemplate <typename T1, typename T2>\nvoid rd(pair<T1, T2> &x) {\n  rd(x.first);\n  rd(x.second);\n}\ntemplate <typename T>\nvoid rd(vector<T> &x) {\n  for (T &i : x) rd(i);\n}\ntemplate <typename T, typename... A>\nvoid rd(T &x, A &...args) {\n  rd(x);\n  rd(args...);\n}\ntemplate <typename T>\nvoid rd() {\n  T x;\n  rd(x);\n  return x;\n}\nint ri() {\n  int x;\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvector<T> rv(int n) {\n  vector<T> x(n);\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvoid ra(T a[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]);\n}\ntemplate <typename T1, typename T2>\nvoid ra(T1 a[], T2 b[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]);\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid ra(T1 a[], T2 b[], T3 c[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]), rd(c[st + i]);\n}\nvoid re(vector<int> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    rd(u, v);\n    E[u].push_back(v);\n    if (!dir) E[v].push_back(u);\n  }\n}\ntemplate <typename T>\nvoid re(vector<pair<int, T>> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    T w;\n    rd(u, v, w);\n    E[u].push_back({v, w});\n    if (!dir) E[v].push_back({u, w});\n  }\n}\nconst int N = 505;\nconst int M = N * N;\nint type[M];\nvector<int> go[M];\nint tsz, root;\nint color[M];\nvoid init(int n) {\n  if (n == 1) {\n    root = tsz = 1;\n  } else {\n    root = tsz = n + 1;\n    type[root] = 1;\n    for (int i = 1; i <= n; i++) go[root].push_back(i);\n  }\n}\nchar *s;\nvoid Paint(int u) {\n  if (type[u] == 0) {\n    color[u] = s[u] == '1' ? 2 : 1;\n  } else {\n    color[u] = 0;\n    for (int v : go[u]) {\n      Paint(v);\n      color[u] |= color[v];\n    }\n  }\n}\nint Merge(vector<int> nodes) {\n  if (nodes.empty()) return 0;\n  if (nodes.size() == 1) return nodes[0];\n  int node = ++tsz;\n  type[node] = 1;\n  go[node] = nodes;\n  return node;\n}\nbool ok = true;\nint Solve(int u, int t) {\n  if (!ok) return 0;\n  if (color[u] != 3) return u;\n  vector<int> ch[3];\n  for (int v : go[u]) ch[color[v] - 1].push_back(v);\n  if (ch[2].size() > 2 || (t > 0 && ch[2].size() > 1)) {\n    ok = false;\n    return 0;\n  }\n  if (type[u] == 1) {\n    if (t == 0) {\n      go[u] = ch[0];\n      if (ch[2].size() == 2 || (ch[2].size() > 0 && ch[1].size() > 0)) {\n        int Q = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        int b = Merge(ch[1]);\n        if (b) go[Q].push_back(b);\n        if (ch[2].size() > 1) {\n          int q = Solve(ch[2][1], 2);\n          if (!ok) return 0;\n          for (int v : go[q]) go[Q].push_back(v);\n        }\n        go[u].push_back(Q);\n      } else if (ch[2].size() == 1) {\n        int Q = Solve(ch[2][0], 0);\n        if (!ok) return 0;\n        go[u].push_back(Q);\n      } else {\n        int b = Merge(ch[1]);\n        if (b) go[u].push_back(b);\n      }\n    } else {\n      type[u] = 2;\n      go[u].clear();\n      int w = Merge(ch[0]);\n      if (w) go[u].push_back(w);\n      if (ch[2].size()) {\n        int g = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        for (int v : go[g]) go[u].push_back(v);\n      }\n      int b = Merge(ch[1]);\n      if (b) go[u].push_back(b);\n      if (t == 2) reverse(go[u].begin(), go[u].end());\n    }\n    if (go[u].size() == 1) return go[u][0];\n    return u;\n  } else {\n    string pattern = t == 0 ? \"wgbgw\" : \"wgb\";\n    int ptr = 0;\n    if (color[go[u][0]] == 2 || color[go[u].back()] == 1)\n      reverse(go[u].begin(), go[u].end());\n    vector<int> ngo;\n    bool strict =\n        t != 0 || ch[2].size() > 1 || (ch[2].size() > 0 && ch[1].size() > 0);\n    for (int v : go[u]) {\n      char col = color[v] == 1 ? 'w' : color[v] == 2 ? 'b' : 'g';\n      while (ptr < pattern.size() && pattern[ptr] != col) ptr++;\n      if (ptr == pattern.size()) {\n        ok = false;\n        return 0;\n      }\n      if (color[v] != 3) {\n        ngo.push_back(v);\n      } else {\n        int Q;\n        if (!strict)\n          Q = Solve(v, 0);\n        else if (ptr == 1)\n          Q = Solve(v, 1);\n        else\n          Q = Solve(v, 2);\n        if (!ok) return 0;\n        if (!strict)\n          ngo.push_back(Q);\n        else\n          for (int h : go[Q]) ngo.push_back(h);\n        ptr++;\n      }\n    }\n    go[u] = ngo;\n    if (t == 2) reverse(go[u].begin(), go[u].end());\n    return u;\n  }\n}\nvoid AddSet(char *t) {\n  if (!ok) return;\n  s = t;\n  Paint(root);\n  root = Solve(root, 0);\n}\nvoid Print(int u) {\n  if (type[u] == 0) {\n    printf(\"%i \", u);\n  } else {\n    if (type[u] == 1) {\n      printf(\"P{ \");\n    } else\n      printf(\"Q[ \");\n    for (int v : go[u]) Print(v);\n    if (type[u] == 1) {\n      printf(\"} \");\n    } else\n      printf(\"] \");\n  }\n}\nconst int mod = 998244353;\nint add(int a, int b) {\n  a += b;\n  return a >= mod ? a - mod : a;\n}\nvoid ckadd(int &a, int b) { a = add(a, b); }\nint sub(int a, int b) {\n  a -= b;\n  return a < 0 ? a + mod : a;\n}\nvoid cksub(int &a, int b) { a = sub(a, b); }\nint mul(int a, int b) { return (long long)a * b % mod; }\nvoid ckmul(int &a, int b) { a = mul(a, b); }\nint powmod(int x, int k) {\n  int ans = 1;\n  for (; k; k >>= 1, ckmul(x, x))\n    if (k & 1) ckmul(ans, x);\n  return ans;\n}\nint inv(int x) { return powmod(x, mod - 2); }\nint F[N];\nint ans = 1;\nvector<int> ord;\nvoid DFS(int u) {\n  if (type[u] == 0) {\n    ord.push_back(u);\n  } else {\n    if (type[u] == 1)\n      ans = mul(ans, F[go[u].size()]);\n    else\n      ans = mul(ans, 2);\n    for (int v : go[u]) DFS(v);\n  }\n}\nchar mask[N];\nint main() {\n  int n, m;\n  rd(n, m);\n  init(n);\n  F[0] = 1;\n  for (int i = 1; i < N; i++) F[i] = mul(F[i - 1], i);\n  for (int i = 1; i <= m; i++) {\n    int q = ri();\n    for (int j = 1; j <= n; j++) mask[j] = '0';\n    while (q--) {\n      int u = ri();\n      mask[u] = '1';\n    }\n    AddSet(mask);\n  }\n  if (!ok)\n    printf(\"0\\n\");\n  else {\n    DFS(root);\n    printf(\"%i\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass PQNode {\n  friend class PQTree;\n  friend class QNodeChildrenIterator;\n\n public:\n  enum PQNode_types { leaf, pnode, qnode };\n  enum PQNode_marks { unmarked, queued, blocked, unblocked };\n  enum PQNode_labels { empty, full, partial };\n  PQNode_types Type();\n  int LeafValue();\n  void Children(vector<PQNode*>* children);\n\n private:\n  list<PQNode*> circular_link_;\n  int ChildCount();\n  PQNode* CircularChildWithLabel(PQNode_labels label);\n  void MoveFullChildren(PQNode* new_node);\n  void ReplaceCircularLink(PQNode* old_child, PQNode* new_child);\n  PQNode* endmost_children_[2];\n  PQNode* pseudo_neighbors_[2];\n  bool pseudonode_, pseudochild_;\n  PQNode* EndmostChildWithLabel(PQNode_labels label);\n  PQNode* ImmediateSiblingWithLabel(PQNode_labels label);\n  PQNode* ImmediateSiblingWithoutLabel(PQNode_labels label);\n  void AddImmediateSibling(PQNode* sibling);\n  void RemoveImmediateSibling(PQNode* sibling);\n  void ClearImmediateSiblings();\n  int ImmediateSiblingCount() const;\n  void ReplaceEndmostChild(PQNode* old_child, PQNode* new_child);\n  void ReplaceImmediateSibling(PQNode* old_child, PQNode* new_child);\n  void ReplacePartialChild(PQNode* old_child, PQNode* new_child);\n  void ForgetChildren();\n  bool ConsecutiveFullPartialChildren();\n  set<PQNode*> full_children_;\n  set<PQNode*> partial_children_;\n  PQNode* immediate_siblings_[2];\n  enum PQNode_labels label_;\n  enum PQNode_marks mark_;\n  enum PQNode_types type_;\n  PQNode* parent_;\n  int pertinent_child_count;\n  int pertinent_leaf_count;\n  int leaf_value_;\n  PQNode* CopyAsChild(const PQNode& to_copy);\n  void Copy(const PQNode& copy);\n  PQNode& operator=(const PQNode& to_copy);\n  PQNode* QNextChild(PQNode* last) const;\n  void ReplaceChild(PQNode* old_child, PQNode* new_child);\n  void SwapQ(PQNode* toInsert);\n  PQNode* Parent() const;\n  PQNode(const PQNode& to_copy);\n  PQNode(int value);\n  PQNode();\n  ~PQNode();\n  void LabelAsFull();\n  void FindLeaves(map<int, PQNode*>& leafAddress);\n  void FindFrontier(list<int>& ordering);\n  void Reset();\n  void Print(string* out) const;\n  void Identify() const;\n};\nclass QNodeChildrenIterator {\n public:\n  QNodeChildrenIterator(PQNode* parent, PQNode* begin_side = NULL);\n  PQNode* Current();\n  void Next();\n  void Reset(PQNode* begin_side = NULL);\n  bool IsDone();\n\n private:\n  void NextPseudoNodeSibling();\n  PQNode* parent_;\n  PQNode* current_;\n  PQNode* next_;\n  PQNode* prev_;\n};\nPQNode::PQNode_types PQNode::Type() { return type_; }\nint PQNode::LeafValue() {\n  assert(type_ == leaf);\n  return leaf_value_;\n}\nvoid PQNode::Children(vector<PQNode*>* children) {\n  assert(children->empty());\n  if (type_ == pnode) {\n    for (list<PQNode*>::const_iterator i = circular_link_.begin();\n         i != circular_link_.end(); ++i)\n      children->push_back(*i);\n  } else if (type_ == qnode) {\n    for (QNodeChildrenIterator qit(this); !qit.IsDone(); qit.Next())\n      children->push_back(qit.Current());\n  }\n}\nint PQNode::ChildCount() { return circular_link_.size(); }\nPQNode* PQNode::CopyAsChild(const PQNode& to_copy) {\n  PQNode* temp = new PQNode(to_copy);\n  temp->parent_ = this;\n  return temp;\n}\nPQNode::PQNode(const PQNode& to_copy) { Copy(to_copy); }\nvoid PQNode::Copy(const PQNode& to_copy) {\n  leaf_value_ = to_copy.leaf_value_;\n  pertinent_leaf_count = to_copy.pertinent_leaf_count;\n  pertinent_child_count = to_copy.pertinent_child_count;\n  type_ = to_copy.type_;\n  mark_ = to_copy.mark_;\n  label_ = to_copy.label_;\n  pseudonode_ = to_copy.pseudonode_;\n  pseudochild_ = to_copy.pseudochild_;\n  parent_ = NULL;\n  partial_children_.clear();\n  full_children_.clear();\n  circular_link_.clear();\n  endmost_children_[0] = NULL;\n  endmost_children_[1] = NULL;\n  ClearImmediateSiblings();\n  ForgetChildren();\n  for (list<PQNode*>::const_iterator i = to_copy.circular_link_.begin();\n       i != to_copy.circular_link_.end(); i++)\n    circular_link_.push_back(CopyAsChild(**i));\n  if (type_ == qnode) {\n    PQNode *current, *last;\n    PQNode *curCopy, *lastCopy, *nextCopy;\n    endmost_children_[0] = CopyAsChild(*to_copy.endmost_children_[0]);\n    curCopy = to_copy.endmost_children_[0];\n    lastCopy = NULL;\n    last = endmost_children_[0];\n    nextCopy = curCopy->QNextChild(lastCopy);\n    while (nextCopy != NULL) {\n      lastCopy = curCopy;\n      curCopy = nextCopy;\n      current = CopyAsChild(*curCopy);\n      current->AddImmediateSibling(last);\n      last->AddImmediateSibling(current);\n      last = current;\n      nextCopy = curCopy->QNextChild(lastCopy);\n    }\n    endmost_children_[1] = current;\n  }\n}\nPQNode& PQNode::operator=(const PQNode& to_copy) {\n  if (&to_copy == this) return *this;\n  Copy(to_copy);\n  return *this;\n}\nvoid PQNode::LabelAsFull() {\n  label_ = full;\n  if (parent_) parent_->full_children_.insert(this);\n}\nPQNode* PQNode::QNextChild(PQNode* last) const {\n  if (immediate_siblings_[0] == last) {\n    return immediate_siblings_[1];\n  } else {\n    if (!last && 2 == ImmediateSiblingCount()) return immediate_siblings_[1];\n    return immediate_siblings_[0];\n  }\n}\nvoid PQNode::ReplaceChild(PQNode* old_child, PQNode* new_child) {\n  if (type_ == pnode) {\n    ReplaceCircularLink(old_child, new_child);\n  } else {\n    for (int i = 0; i < 2 && old_child->immediate_siblings_[i]; ++i) {\n      PQNode* sibling = old_child->immediate_siblings_[i];\n      sibling->ReplaceImmediateSibling(old_child, new_child);\n    }\n    ReplaceEndmostChild(old_child, new_child);\n  }\n  new_child->parent_ = old_child->parent_;\n  if (new_child->label_ == partial)\n    new_child->parent_->partial_children_.insert(new_child);\n  if (new_child->label_ == full)\n    new_child->parent_->full_children_.insert(new_child);\n}\nvoid PQNode::SwapQ(PQNode* toInsert) {\n  toInsert->pseudochild_ = pseudochild_;\n  toInsert->ClearImmediateSiblings();\n  for (int i = 0; i < 2; ++i) {\n    if (parent_->endmost_children_[i] == this)\n      parent_->endmost_children_[i] = toInsert;\n    if (immediate_siblings_[i])\n      immediate_siblings_[i]->ReplaceImmediateSibling(this, toInsert);\n  }\n  ClearImmediateSiblings();\n  parent_ = NULL;\n}\nPQNode* PQNode::Parent() const {\n  if (immediate_siblings_[0] == NULL || immediate_siblings_[1] == NULL)\n    return parent_;\n  return NULL;\n}\nPQNode::PQNode(int value) {\n  leaf_value_ = value;\n  type_ = leaf;\n  parent_ = NULL;\n  label_ = empty;\n  mark_ = unmarked;\n  pertinent_child_count = 0;\n  pertinent_leaf_count = 0;\n  endmost_children_[0] = NULL;\n  endmost_children_[1] = NULL;\n  ClearImmediateSiblings();\n  ForgetChildren();\n}\nPQNode::PQNode() {\n  pseudonode_ = false;\n  parent_ = NULL;\n  label_ = empty;\n  mark_ = unmarked;\n  pertinent_child_count = 0;\n  pertinent_leaf_count = 0;\n  endmost_children_[0] = NULL;\n  endmost_children_[1] = NULL;\n  ClearImmediateSiblings();\n  ForgetChildren();\n}\nPQNode::~PQNode() {\n  if (type_ == qnode) {\n    PQNode* last = NULL;\n    PQNode* current = endmost_children_[0];\n    while (current) {\n      PQNode* next = current->QNextChild(last);\n      delete last;\n      last = current;\n      current = next;\n    }\n    delete last;\n  } else if (type_ == pnode) {\n    for (list<PQNode*>::iterator i = circular_link_.begin();\n         i != circular_link_.end(); i++)\n      delete *i;\n    circular_link_.clear();\n  }\n}\nPQNode* PQNode::CircularChildWithLabel(PQNode_labels label) {\n  for (list<PQNode*>::iterator i = circular_link_.begin();\n       i != circular_link_.end(); i++) {\n    if ((*i)->label_ == label) return *i;\n  }\n  return NULL;\n}\nPQNode* PQNode::EndmostChildWithLabel(PQNode_labels label) {\n  for (int i = 0; i < 2; ++i)\n    if (endmost_children_[i] && endmost_children_[i]->label_ == label)\n      return endmost_children_[i];\n  return NULL;\n}\nPQNode* PQNode::ImmediateSiblingWithLabel(PQNode_labels label) {\n  for (int i = 0; i < 2 && immediate_siblings_[i]; ++i)\n    if (immediate_siblings_[i]->label_ == label) return immediate_siblings_[i];\n  return NULL;\n}\nPQNode* PQNode::ImmediateSiblingWithoutLabel(PQNode_labels label) {\n  for (int i = 0; i < 2 && immediate_siblings_[i]; ++i)\n    if (immediate_siblings_[i]->label_ != label) return immediate_siblings_[i];\n  return NULL;\n}\nvoid PQNode::AddImmediateSibling(PQNode* sibling) {\n  int null_idx = ImmediateSiblingCount();\n  assert(null_idx < 2);\n  immediate_siblings_[null_idx] = sibling;\n}\nvoid PQNode::RemoveImmediateSibling(PQNode* sibling) {\n  if (immediate_siblings_[0] == sibling) {\n    immediate_siblings_[0] = immediate_siblings_[1];\n    immediate_siblings_[1] = NULL;\n  } else if (immediate_siblings_[1] == sibling) {\n    immediate_siblings_[1] = NULL;\n  } else {\n    assert(false);\n  }\n}\nvoid PQNode::ClearImmediateSiblings() {\n  for (int i = 0; i < 2; ++i) immediate_siblings_[i] = NULL;\n}\nint PQNode::ImmediateSiblingCount() const {\n  int count = 0;\n  for (int i = 0; (i < 2) && immediate_siblings_[i]; ++i) ++count;\n  return count;\n}\nvoid PQNode::ReplaceEndmostChild(PQNode* old_child, PQNode* new_child) {\n  for (int i = 0; i < 2; ++i) {\n    if (endmost_children_[i] == old_child) {\n      endmost_children_[i] = new_child;\n      return;\n    }\n  }\n}\nvoid PQNode::ReplaceImmediateSibling(PQNode* old_child, PQNode* new_child) {\n  for (int i = 0; i < 2 && immediate_siblings_[i]; ++i)\n    if (immediate_siblings_[i] == old_child) immediate_siblings_[i] = new_child;\n  new_child->immediate_siblings_[new_child->ImmediateSiblingCount()] = this;\n}\nvoid PQNode::ReplacePartialChild(PQNode* old_child, PQNode* new_child) {\n  new_child->parent_ = this;\n  partial_children_.insert(new_child);\n  partial_children_.erase(old_child);\n  if (type_ == pnode) {\n    circular_link_.remove(old_child);\n    circular_link_.push_back(new_child);\n  } else {\n    old_child->SwapQ(new_child);\n  }\n}\nvoid PQNode::ForgetChildren() {\n  for (int i = 0; i < 2; ++i) endmost_children_[i] = NULL;\n}\nbool PQNode::ConsecutiveFullPartialChildren() {\n  if (full_children_.size() + partial_children_.size() <= 1) return true;\n  map<PQNode_labels, int> counts;\n  for (set<PQNode*>::iterator it = full_children_.begin();\n       it != full_children_.end(); ++it) {\n    for (int i = 0; i < 2 && (*it)->immediate_siblings_[i]; ++i)\n      counts[(*it)->immediate_siblings_[i]->label_]++;\n  }\n  for (set<PQNode*>::iterator it = partial_children_.begin();\n       it != partial_children_.end(); ++it) {\n    for (int i = 0; i < 2 && (*it)->immediate_siblings_[i]; ++i)\n      counts[(*it)->immediate_siblings_[i]->label_]++;\n  }\n  if (counts[partial] != partial_children_.size()) return false;\n  if (counts[full] != (full_children_.size() * 2) - (2 - counts[partial]))\n    return false;\n  return true;\n}\nvoid PQNode::MoveFullChildren(PQNode* new_node) {\n  for (set<PQNode*>::iterator i = full_children_.begin();\n       i != full_children_.end(); ++i) {\n    circular_link_.remove(*i);\n    new_node->circular_link_.push_back(*i);\n    (*i)->parent_ = new_node;\n  }\n}\nvoid PQNode::ReplaceCircularLink(PQNode* old_child, PQNode* new_child) {\n  circular_link_.remove(old_child);\n  circular_link_.push_back(new_child);\n}\nvoid PQNode::FindLeaves(map<int, PQNode*>& leafAddress) {\n  if (type_ == leaf) {\n    leafAddress[leaf_value_] = this;\n  } else if (type_ == pnode) {\n    for (list<PQNode*>::iterator i = circular_link_.begin();\n         i != circular_link_.end(); i++)\n      (*i)->FindLeaves(leafAddress);\n  } else if (type_ == qnode) {\n    PQNode* last = NULL;\n    PQNode* current = endmost_children_[0];\n    while (current) {\n      current->FindLeaves(leafAddress);\n      PQNode* next = current->QNextChild(last);\n      last = current;\n      current = next;\n    }\n  }\n}\nvoid PQNode::FindFrontier(list<int>& ordering) {\n  if (type_ == leaf) {\n    ordering.push_back(leaf_value_);\n  } else if (type_ == pnode) {\n    for (list<PQNode*>::iterator i = circular_link_.begin();\n         i != circular_link_.end(); i++)\n      (*i)->FindFrontier(ordering);\n  } else if (type_ == qnode) {\n    PQNode* last = NULL;\n    PQNode* current = endmost_children_[0];\n    while (current) {\n      current->FindFrontier(ordering);\n      PQNode* next = current->QNextChild(last);\n      last = current;\n      current = next;\n    }\n  }\n}\nvoid PQNode::Reset() {\n  if (type_ == pnode) {\n    for (list<PQNode*>::iterator i = circular_link_.begin();\n         i != circular_link_.end(); i++)\n      (*i)->Reset();\n  } else if (type_ == qnode) {\n    PQNode* last = NULL;\n    PQNode* current = endmost_children_[0];\n    while (current) {\n      current->Reset();\n      PQNode* next = current->QNextChild(last);\n      last = current;\n      current = next;\n    }\n  }\n  full_children_.clear();\n  partial_children_.clear();\n  label_ = empty;\n  mark_ = unmarked;\n  pertinent_child_count = 0;\n  pertinent_leaf_count = 0;\n  pseudochild_ = false;\n  pseudonode_ = false;\n}\nint answer = 1;\nconst int mod = 998244353;\nusing ll = long long;\nvoid PQNode::Print(string* out) const {\n  if (type_ == leaf) {\n    char value_str[10];\n    sprintf(value_str, \"%d\", leaf_value_);\n    *out += value_str;\n  } else if (type_ == pnode) {\n    *out += \"(\";\n    int cnt = 0;\n    for (list<PQNode*>::const_iterator i = circular_link_.begin();\n         i != circular_link_.end(); i++) {\n      (*i)->Print(out);\n      cnt++;\n      answer = (answer * (ll)cnt) % mod;\n      if (++i != circular_link_.end()) *out += \" \";\n      --i;\n    }\n    *out += \")\";\n  } else if (type_ == qnode) {\n    *out += \"[\";\n    PQNode* last = NULL;\n    PQNode* current = endmost_children_[0];\n    while (current) {\n      current->Print(out);\n      PQNode* next = current->QNextChild(last);\n      last = current;\n      current = next;\n      if (current) *out += \" \";\n    }\n    answer = (answer * (ll)2) % mod;\n    *out += \"]\";\n  }\n}\nvoid PQNode::Identify() const {\n  cout << \"Node: \" << this;\n  cout << \" Parent: \" << parent_ << endl;\n  if (type_ == leaf) {\n    cout << \"Type: leaf  Value: \" << leaf_value_ << endl;\n  } else {\n    string value;\n    Print(&value);\n    if (type_ == pnode) cout << \"Type: pnode Value: \" << value << endl;\n    if (type_ == qnode) cout << \"Type: qnode Value: \" << value << endl;\n  }\n}\nQNodeChildrenIterator::QNodeChildrenIterator(PQNode* parent,\n                                             PQNode* begin_side) {\n  parent_ = parent;\n  Reset(begin_side);\n}\nvoid QNodeChildrenIterator::Reset(PQNode* begin_side) {\n  current_ = parent_->endmost_children_[0];\n  if (begin_side) current_ = begin_side;\n  prev_ = NULL;\n  next_ = current_->immediate_siblings_[0];\n}\nPQNode* QNodeChildrenIterator::Current() { return current_; }\nvoid QNodeChildrenIterator::NextPseudoNodeSibling() {\n  prev_ = current_;\n  current_ = current_->ImmediateSiblingWithLabel(PQNode::full);\n  if (!current_)\n    current_ = current_->ImmediateSiblingWithLabel(PQNode::partial);\n}\nvoid QNodeChildrenIterator::Next() {\n  if (IsDone()) return;\n  if (prev_ == NULL && current_->ImmediateSiblingCount() == 2) {\n    NextPseudoNodeSibling();\n  } else {\n    prev_ = current_;\n    current_ = next_;\n  }\n  if (current_) {\n    next_ = current_->immediate_siblings_[0];\n    if (next_ == prev_) next_ = current_->immediate_siblings_[1];\n  }\n}\nbool QNodeChildrenIterator::IsDone() { return current_ == NULL; }\nclass PQTree {\n private:\n  PQNode* root_;\n  int block_count_;\n  int blocked_nodes_;\n  int off_the_top_;\n  list<set<int>> reductions_;\n  map<int, PQNode*> leaf_address_;\n  PQNode* pseudonode_;\n  bool invalid_;\n  int UnblockSiblings(PQNode* sibling);\n  bool TemplateL1(PQNode* candidate_node);\n  bool TemplateQ1(PQNode* candidate_node);\n  bool TemplateQ2(PQNode* candidate_node);\n  bool TemplateQ3(PQNode* candidate_node);\n  bool TemplateP1(PQNode* candidate_node, bool is_reduction_root);\n  bool TemplateP2(PQNode* candidate_node);\n  bool TemplateP3(PQNode* candidate_node);\n  bool TemplateP4(PQNode* candidate_node);\n  bool TemplateP5(PQNode* candidate_node);\n  bool TemplateP6(PQNode* candidate_node);\n  bool Bubble(set<int> S);\n  bool ReduceStep(set<int> S);\n\n public:\n  PQTree(set<int> S);\n  PQTree(const PQTree& to_copy);\n  ~PQTree();\n  PQNode* Root();\n  string Print() const;\n  void CleanPseudo();\n  bool SafeReduce(set<int>);\n  bool SafeReduceAll(list<set<int>>);\n  bool Reduce(set<int> S);\n  bool ReduceAll(list<set<int>> L);\n  list<int> Frontier();\n  PQTree& operator=(const PQTree& to_copy);\n  void CopyFrom(const PQTree& to_copy);\n  list<int> ReducedFrontier();\n  list<set<int>> GetReductions();\n  set<int> GetContained();\n};\nPQTree::PQTree(const PQTree& to_copy) { CopyFrom(to_copy); }\nPQTree& PQTree::operator=(const PQTree& to_copy) {\n  if (&to_copy != this) CopyFrom(to_copy);\n  return *this;\n}\nvoid PQTree::CopyFrom(const PQTree& to_copy) {\n  root_ = new PQNode(*to_copy.root_);\n  block_count_ = to_copy.block_count_;\n  blocked_nodes_ = to_copy.blocked_nodes_;\n  invalid_ = to_copy.invalid_;\n  off_the_top_ = to_copy.off_the_top_;\n  pseudonode_ = NULL;\n  reductions_ = to_copy.reductions_;\n  leaf_address_.clear();\n  root_->FindLeaves(leaf_address_);\n}\nint PQTree::UnblockSiblings(PQNode* candidate_node) {\n  assert(candidate_node->mark_ == PQNode::unblocked);\n  int unblocked_count = 0;\n  for (int i = 0; i < 2 && candidate_node->immediate_siblings_[i]; ++i) {\n    PQNode* sibling = candidate_node->immediate_siblings_[i];\n    if (sibling->mark_ == PQNode::blocked) {\n      sibling->parent_ = candidate_node->parent_;\n      sibling->mark_ = PQNode::unblocked;\n      unblocked_count++;\n      unblocked_count += UnblockSiblings(sibling);\n    }\n  }\n  return unblocked_count;\n}\nbool PQTree::TemplateL1(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::leaf) return false;\n  candidate_node->LabelAsFull();\n  return true;\n}\nbool PQTree::TemplateQ1(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::qnode) return false;\n  for (QNodeChildrenIterator it(candidate_node); !it.IsDone(); it.Next()) {\n    if (it.Current()->label_ != PQNode::full) return false;\n  }\n  candidate_node->LabelAsFull();\n  return true;\n}\nbool PQTree::TemplateQ2(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::qnode || candidate_node->pseudonode_ ||\n      candidate_node->partial_children_.size() > 1 ||\n      !candidate_node->ConsecutiveFullPartialChildren())\n    return false;\n  bool has_partial = candidate_node->partial_children_.size() > 0;\n  bool has_full = candidate_node->full_children_.size() > 0;\n  if (has_full && !candidate_node->EndmostChildWithLabel(PQNode::full))\n    return false;\n  if (!has_full && !candidate_node->EndmostChildWithLabel(PQNode::partial))\n    return false;\n  if (has_partial) {\n    PQNode* to_merge = *candidate_node->partial_children_.begin();\n    for (int i = 0; i < 2; ++i) {\n      PQNode* child = to_merge->endmost_children_[i];\n      PQNode* sibling = to_merge->ImmediateSiblingWithLabel(child->label_);\n      if (sibling) {\n        sibling->ReplaceImmediateSibling(to_merge, child);\n      } else {\n        candidate_node->ReplaceEndmostChild(to_merge, child);\n        child->parent_ = candidate_node;\n      }\n    }\n    to_merge->ForgetChildren();\n    delete to_merge;\n  }\n  candidate_node->label_ = PQNode::partial;\n  if (candidate_node->parent_)\n    candidate_node->parent_->partial_children_.insert(candidate_node);\n  return true;\n}\nbool PQTree::TemplateQ3(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::qnode ||\n      candidate_node->partial_children_.size() > 2 ||\n      !candidate_node->ConsecutiveFullPartialChildren())\n    return false;\n  for (set<PQNode*>::iterator j = candidate_node->partial_children_.begin();\n       j != candidate_node->partial_children_.end(); j++) {\n    PQNode* to_merge = *j;\n    for (int i = 0; i < 2; ++i) {\n      PQNode* sibling = to_merge->immediate_siblings_[i];\n      if (sibling) {\n        PQNode* child = to_merge->EndmostChildWithLabel(sibling->label_);\n        if (!child) child = to_merge->EndmostChildWithLabel(PQNode::full);\n        sibling->ReplaceImmediateSibling(to_merge, child);\n      } else {\n        PQNode* empty_child = to_merge->EndmostChildWithLabel(PQNode::empty);\n        empty_child->parent_ = candidate_node;\n        candidate_node->ReplaceEndmostChild(to_merge, empty_child);\n      }\n    }\n    to_merge->ForgetChildren();\n    delete to_merge;\n  }\n  return true;\n}\nbool PQTree::TemplateP1(PQNode* candidate_node, bool is_reduction_root) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      candidate_node->full_children_.size() != candidate_node->ChildCount())\n    return false;\n  candidate_node->label_ = PQNode::full;\n  if (!is_reduction_root)\n    candidate_node->parent_->full_children_.insert(candidate_node);\n  return true;\n}\nbool PQTree::TemplateP2(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      !candidate_node->partial_children_.empty())\n    return false;\n  if (candidate_node->full_children_.size() >= 2) {\n    PQNode* new_pnode = new PQNode;\n    new_pnode->type_ = PQNode::pnode;\n    new_pnode->parent_ = candidate_node;\n    candidate_node->MoveFullChildren(new_pnode);\n    candidate_node->circular_link_.push_back(new_pnode);\n  }\n  candidate_node->label_ = PQNode::partial;\n  return true;\n}\nbool PQTree::TemplateP3(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      !candidate_node->partial_children_.empty())\n    return false;\n  PQNode* new_qnode = new PQNode;\n  new_qnode->type_ = PQNode::qnode;\n  new_qnode->label_ = PQNode::partial;\n  candidate_node->parent_->ReplacePartialChild(candidate_node, new_qnode);\n  PQNode* full_child;\n  if (candidate_node->full_children_.size() == 1) {\n    full_child = *candidate_node->full_children_.begin();\n    candidate_node->circular_link_.remove(full_child);\n  } else {\n    full_child = new PQNode;\n    full_child->type_ = PQNode::pnode;\n    full_child->label_ = PQNode::full;\n    candidate_node->MoveFullChildren(full_child);\n  }\n  full_child->parent_ = new_qnode;\n  full_child->label_ = PQNode::full;\n  new_qnode->endmost_children_[0] = full_child;\n  new_qnode->full_children_.insert(full_child);\n  PQNode* empty_child;\n  if (candidate_node->circular_link_.size() == 1) {\n    empty_child = *candidate_node->circular_link_.begin();\n    candidate_node->circular_link_.clear();\n    delete candidate_node;\n  } else {\n    empty_child = candidate_node;\n  }\n  empty_child->parent_ = new_qnode;\n  empty_child->label_ = PQNode::empty;\n  new_qnode->endmost_children_[1] = empty_child;\n  empty_child->immediate_siblings_[0] = full_child;\n  full_child->immediate_siblings_[0] = empty_child;\n  return true;\n}\nbool PQTree::TemplateP4(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      candidate_node->partial_children_.size() != 1)\n    return false;\n  PQNode* partial_qnode = *candidate_node->partial_children_.begin();\n  PQNode* empty_child = partial_qnode->EndmostChildWithLabel(PQNode::empty);\n  PQNode* full_child = partial_qnode->EndmostChildWithLabel(PQNode::full);\n  if (!empty_child || !full_child) return false;\n  if (!candidate_node->full_children_.empty()) {\n    PQNode* full_children_root;\n    if (candidate_node->full_children_.size() == 1) {\n      full_children_root = *(candidate_node->full_children_.begin());\n      candidate_node->circular_link_.remove(full_children_root);\n    } else {\n      full_children_root = new PQNode;\n      full_children_root->type_ = PQNode::pnode;\n      full_children_root->label_ = PQNode::full;\n      candidate_node->MoveFullChildren(full_children_root);\n    }\n    full_children_root->parent_ = partial_qnode;\n    partial_qnode->ReplaceEndmostChild(full_child, full_children_root);\n    partial_qnode->full_children_.insert(full_children_root);\n    full_child->AddImmediateSibling(full_children_root);\n    full_children_root->AddImmediateSibling(full_child);\n  }\n  if (candidate_node->circular_link_.size() == 1) {\n    if (candidate_node->Parent()) {\n      candidate_node->parent_->ReplaceChild(candidate_node, partial_qnode);\n    } else {\n      partial_qnode->parent_ = NULL;\n      if (root_ == candidate_node) {\n        root_ = partial_qnode;\n      } else {\n        for (int i = 0; i < 2; ++i) {\n          PQNode* sibling = candidate_node->immediate_siblings_[i];\n          sibling->ReplaceImmediateSibling(candidate_node, partial_qnode);\n        }\n      }\n    }\n    candidate_node->circular_link_.clear();\n    delete candidate_node;\n  }\n  return true;\n}\nbool PQTree::TemplateP5(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      candidate_node->partial_children_.size() != 1)\n    return false;\n  PQNode* partial_qnode = *candidate_node->partial_children_.begin();\n  assert(partial_qnode->type_ == PQNode::qnode);\n  PQNode* empty_child = partial_qnode->EndmostChildWithLabel(PQNode::empty);\n  PQNode* full_child = partial_qnode->EndmostChildWithLabel(PQNode::full);\n  PQNode* empty_sibling = candidate_node->CircularChildWithLabel(PQNode::empty);\n  if (!empty_child || !full_child) return false;\n  candidate_node->parent_->ReplaceChild(candidate_node, partial_qnode);\n  partial_qnode->pertinent_leaf_count = candidate_node->pertinent_leaf_count;\n  candidate_node->circular_link_.remove(partial_qnode);\n  if (!candidate_node->full_children_.empty()) {\n    PQNode* full_children_root;\n    if (candidate_node->full_children_.size() == 1) {\n      full_children_root = *candidate_node->full_children_.begin();\n      candidate_node->circular_link_.remove(full_children_root);\n    } else {\n      full_children_root = new PQNode;\n      full_children_root->type_ = PQNode::pnode;\n      full_children_root->label_ = PQNode::full;\n      candidate_node->MoveFullChildren(full_children_root);\n    }\n    full_children_root->parent_ = partial_qnode;\n    full_child->AddImmediateSibling(full_children_root);\n    full_children_root->AddImmediateSibling(full_child);\n    partial_qnode->ReplaceEndmostChild(full_child, full_children_root);\n  }\n  if (candidate_node->ChildCount()) {\n    PQNode* empty_children_root;\n    if (candidate_node->ChildCount() == 1) {\n      empty_children_root = empty_sibling;\n    } else {\n      empty_children_root = candidate_node;\n      empty_children_root->label_ = PQNode::empty;\n      empty_children_root->ClearImmediateSiblings();\n    }\n    empty_children_root->parent_ = partial_qnode;\n    empty_child->AddImmediateSibling(empty_children_root);\n    empty_children_root->AddImmediateSibling(empty_child);\n    partial_qnode->ReplaceEndmostChild(empty_child, empty_children_root);\n  }\n  if (candidate_node->ChildCount() < 2) {\n    candidate_node->circular_link_.clear();\n    delete candidate_node;\n  }\n  return true;\n}\nbool PQTree::TemplateP6(PQNode* candidate_node) {\n  if (candidate_node->type_ != PQNode::pnode ||\n      candidate_node->partial_children_.size() != 2)\n    return false;\n  PQNode* partial_qnode1 = *candidate_node->partial_children_.begin();\n  PQNode* partial_qnode2 = *(++(candidate_node->partial_children_.begin()));\n  PQNode* empty_child1 = partial_qnode1->EndmostChildWithLabel(PQNode::empty);\n  PQNode* full_child1 = partial_qnode1->EndmostChildWithLabel(PQNode::full);\n  if (!empty_child1 || !full_child1) return false;\n  PQNode* empty_child2 = partial_qnode2->EndmostChildWithLabel(PQNode::empty);\n  PQNode* full_child2 = partial_qnode2->EndmostChildWithLabel(PQNode::full);\n  if (!empty_child2 || !full_child2) return false;\n  if (!candidate_node->full_children_.empty()) {\n    PQNode* full_children_root = NULL;\n    if (candidate_node->full_children_.size() == 1) {\n      full_children_root = *candidate_node->full_children_.begin();\n      candidate_node->circular_link_.remove(full_children_root);\n    } else {\n      full_children_root = new PQNode;\n      full_children_root->type_ = PQNode::pnode;\n      full_children_root->label_ = PQNode::full;\n      candidate_node->MoveFullChildren(full_children_root);\n    }\n    full_children_root->parent_ = partial_qnode1;\n    full_child2->parent_ = partial_qnode1;\n    full_child1->AddImmediateSibling(full_children_root);\n    full_child2->AddImmediateSibling(full_children_root);\n    full_children_root->AddImmediateSibling(full_child1);\n    full_children_root->AddImmediateSibling(full_child2);\n  } else {\n    full_child1->AddImmediateSibling(full_child2);\n    full_child2->AddImmediateSibling(full_child1);\n  }\n  partial_qnode1->ReplaceEndmostChild(full_child1, empty_child2);\n  empty_child2->parent_ = partial_qnode1;\n  candidate_node->circular_link_.remove(partial_qnode2);\n  partial_qnode2->ForgetChildren();\n  delete partial_qnode2;\n  if (candidate_node->circular_link_.size() == 1) {\n    partial_qnode1->parent_ = candidate_node->parent_;\n    partial_qnode1->pertinent_leaf_count = candidate_node->pertinent_leaf_count;\n    partial_qnode1->label_ = PQNode::partial;\n    if (candidate_node->parent_) {\n      candidate_node->parent_->partial_children_.insert(partial_qnode1);\n      if (candidate_node->parent_->type_ == PQNode::pnode) {\n        candidate_node->parent_->ReplaceCircularLink(candidate_node,\n                                                     partial_qnode1);\n      } else {\n        for (int i = 0; i < 2 && candidate_node->immediate_siblings_[i]; ++i) {\n          PQNode* sibling = candidate_node->immediate_siblings_[i];\n          sibling->ReplaceImmediateSibling(candidate_node, partial_qnode1);\n        }\n        candidate_node->parent_->ReplaceEndmostChild(candidate_node,\n                                                     partial_qnode1);\n      }\n    } else {\n      root_ = partial_qnode1;\n      partial_qnode1->parent_ = NULL;\n      candidate_node->circular_link_.clear();\n      delete candidate_node;\n    }\n  }\n  return true;\n}\nbool PQTree::Bubble(set<int> reduction_set) {\n  queue<PQNode*> q;\n  block_count_ = 0;\n  blocked_nodes_ = 0;\n  off_the_top_ = 0;\n  set<PQNode*> blocked_list;\n  for (set<int>::iterator i = reduction_set.begin(); i != reduction_set.end();\n       ++i) {\n    PQNode* temp = leaf_address_[*i];\n    assert(temp);\n    q.push(temp);\n  }\n  while (q.size() + block_count_ + off_the_top_ > 1) {\n    if (q.empty()) return false;\n    PQNode* candidate_node = q.front();\n    q.pop();\n    candidate_node->mark_ = PQNode::blocked;\n    set<PQNode*> unblocked_siblings;\n    set<PQNode*> blocked_siblings;\n    for (int i = 0; i < 2 && candidate_node->immediate_siblings_[i]; ++i) {\n      PQNode* sibling = candidate_node->immediate_siblings_[i];\n      if (sibling->mark_ == PQNode::blocked) {\n        blocked_siblings.insert(sibling);\n      } else if (sibling->mark_ == PQNode::unblocked) {\n        unblocked_siblings.insert(sibling);\n      }\n    }\n    if (!unblocked_siblings.empty()) {\n      candidate_node->parent_ = (*unblocked_siblings.begin())->parent_;\n      candidate_node->mark_ = PQNode::unblocked;\n    } else if (candidate_node->ImmediateSiblingCount() < 2) {\n      candidate_node->mark_ = PQNode::unblocked;\n    }\n    if (candidate_node->mark_ == PQNode::unblocked) {\n      if (!blocked_siblings.empty()) {\n        int list_size = UnblockSiblings(candidate_node);\n        candidate_node->parent_->pertinent_child_count += list_size;\n        blocked_nodes_ -= list_size;\n      }\n      if (!candidate_node->parent_) {\n        off_the_top_ = 1;\n      } else {\n        candidate_node->parent_->pertinent_child_count++;\n        if (candidate_node->parent_->mark_ == PQNode::unmarked) {\n          q.push(candidate_node->parent_);\n          candidate_node->parent_->mark_ = PQNode::queued;\n        }\n      }\n      block_count_ -= blocked_siblings.size();\n    } else {\n      block_count_ += 1 - blocked_siblings.size();\n      blocked_nodes_ += 1;\n      blocked_list.insert(candidate_node);\n    }\n  }\n  if (block_count_ > 1 || (off_the_top_ == 1 && block_count_ != 0))\n    return false;\n  if (block_count_ == 1 && blocked_nodes_ > 1) {\n    pseudonode_ = new PQNode;\n    pseudonode_->type_ = PQNode::qnode;\n    pseudonode_->pseudonode_ = true;\n    pseudonode_->pertinent_child_count = 0;\n    int side = 0;\n    for (set<PQNode*>::iterator i = blocked_list.begin();\n         i != blocked_list.end(); ++i) {\n      PQNode* blocked = *i;\n      if (blocked->mark_ == PQNode::blocked) {\n        pseudonode_->pertinent_child_count++;\n        pseudonode_->pertinent_leaf_count += blocked->pertinent_leaf_count;\n        for (int j = 0; j < 2; ++j) {\n          PQNode* sibling = blocked->immediate_siblings_[j];\n          if (sibling->mark_ == PQNode::unmarked) {\n            blocked->RemoveImmediateSibling(sibling);\n            sibling->RemoveImmediateSibling(blocked);\n            pseudonode_->pseudo_neighbors_[side] = sibling;\n            pseudonode_->endmost_children_[side++] = blocked;\n            break;\n          }\n        }\n        blocked->parent_ = pseudonode_;\n        blocked->pseudochild_ = true;\n      }\n    }\n    q.push(pseudonode_);\n  }\n  return true;\n}\nbool PQTree::ReduceStep(set<int> reduction_set) {\n  queue<PQNode*> q;\n  for (set<int>::iterator i = reduction_set.begin(); i != reduction_set.end();\n       i++) {\n    PQNode* candidate_node = leaf_address_[*i];\n    if (candidate_node == NULL) return false;\n    candidate_node->pertinent_leaf_count = 1;\n    q.push(candidate_node);\n  }\n  while (!q.empty()) {\n    PQNode* candidate_node = q.front();\n    q.pop();\n    if (candidate_node->pertinent_leaf_count < reduction_set.size()) {\n      PQNode* candidate_parent = candidate_node->parent_;\n      candidate_parent->pertinent_leaf_count +=\n          candidate_node->pertinent_leaf_count;\n      candidate_parent->pertinent_child_count--;\n      if (candidate_parent->pertinent_child_count == 0)\n        q.push(candidate_parent);\n      if (TemplateL1(candidate_node)) {\n      } else if (TemplateP1(candidate_node, false)) {\n      } else if (TemplateP3(candidate_node)) {\n      } else if (TemplateP5(candidate_node)) {\n      } else if (TemplateQ1(candidate_node)) {\n      } else if (TemplateQ2(candidate_node)) {\n      } else {\n        CleanPseudo();\n        return false;\n      }\n    } else {\n      if (TemplateL1(candidate_node)) {\n      } else if (TemplateP1(candidate_node, true)) {\n      } else if (TemplateP2(candidate_node)) {\n      } else if (TemplateP4(candidate_node)) {\n      } else if (TemplateP6(candidate_node)) {\n      } else if (TemplateQ1(candidate_node)) {\n      } else if (TemplateQ2(candidate_node)) {\n      } else if (TemplateQ3(candidate_node)) {\n      } else {\n        CleanPseudo();\n        return false;\n      }\n    }\n  }\n  CleanPseudo();\n  return true;\n}\nvoid PQTree::CleanPseudo() {\n  if (pseudonode_) {\n    PQNode* last = NULL;\n    PQNode* current = pseudonode_->endmost_children_[0];\n    while (current) {\n      current->parent_ = NULL;\n      PQNode* next = current->QNextChild(last);\n      last = current;\n      current = next;\n    }\n    for (int i = 0; i < 2; i++) {\n      pseudonode_->endmost_children_[i]->AddImmediateSibling(\n          pseudonode_->pseudo_neighbors_[i]);\n      pseudonode_->pseudo_neighbors_[i]->AddImmediateSibling(\n          pseudonode_->endmost_children_[i]);\n    }\n    pseudonode_->ForgetChildren();\n    delete pseudonode_;\n    pseudonode_ = NULL;\n  }\n}\nPQTree::PQTree(set<int> reduction_set) {\n  root_ = new PQNode;\n  root_->type_ = PQNode::pnode;\n  invalid_ = false;\n  pseudonode_ = NULL;\n  block_count_ = 0;\n  blocked_nodes_ = 0;\n  off_the_top_ = 0;\n  for (set<int>::iterator i = reduction_set.begin(); i != reduction_set.end();\n       i++) {\n    PQNode* new_node;\n    new_node = new PQNode(*i);\n    leaf_address_[*i] = new_node;\n    new_node->parent_ = root_;\n    new_node->type_ = PQNode::leaf;\n    root_->circular_link_.push_back(new_node);\n  }\n}\nPQNode* PQTree::Root() { return root_; }\nstring PQTree::Print() const {\n  string out;\n  root_->Print(&out);\n  return out;\n}\nbool PQTree::SafeReduce(set<int> S) {\n  PQTree toCopy(*this);\n  if (!Reduce(S)) {\n    root_ = new PQNode(*toCopy.root_);\n    block_count_ = toCopy.block_count_;\n    blocked_nodes_ = toCopy.blocked_nodes_;\n    off_the_top_ = toCopy.off_the_top_;\n    invalid_ = toCopy.invalid_;\n    leaf_address_.clear();\n    root_->FindLeaves(leaf_address_);\n    return false;\n  }\n  return true;\n}\nbool PQTree::SafeReduceAll(list<set<int>> L) {\n  PQTree toCopy(*this);\n  if (!ReduceAll(L)) {\n    root_ = new PQNode(*toCopy.root_);\n    block_count_ = toCopy.block_count_;\n    blocked_nodes_ = toCopy.blocked_nodes_;\n    off_the_top_ = toCopy.off_the_top_;\n    invalid_ = toCopy.invalid_;\n    leaf_address_.clear();\n    root_->FindLeaves(leaf_address_);\n    return false;\n  }\n  return true;\n}\nbool PQTree::Reduce(set<int> reduction_set) {\n  if (reduction_set.size() < 2) {\n    reductions_.push_back(reduction_set);\n    return true;\n  }\n  if (invalid_) return false;\n  if (!Bubble(reduction_set)) {\n    invalid_ = true;\n    return false;\n  }\n  if (!ReduceStep(reduction_set)) {\n    invalid_ = true;\n    return false;\n  }\n  root_->Reset();\n  reductions_.push_back(reduction_set);\n  return true;\n}\nbool PQTree::ReduceAll(list<set<int>> L) {\n  for (list<set<int>>::iterator S = L.begin(); S != L.end(); S++) {\n    if (!Reduce(*S)) return false;\n  }\n  return true;\n}\nlist<int> PQTree::Frontier() {\n  list<int> out;\n  root_->FindFrontier(out);\n  return out;\n}\nlist<set<int>> PQTree::GetReductions() { return reductions_; }\nPQTree::~PQTree() { delete root_; }\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> ddd;\n  for (size_t i = 0; i < m; ++i) {\n    vector<int> g;\n    int k;\n    cin >> k;\n    g.resize(k);\n    for (int& j : g) cin >> j;\n    ddd.push_back(g);\n  }\n  vector<int> o(n);\n  iota(o.begin(), o.end(), 1);\n  set<int> ST{o.begin(), o.end()};\n  PQTree tree(ST);\n  for (auto g : ddd) {\n    if (!tree.Reduce({g.begin(), g.end()})) {\n      cout << 0;\n      return 0;\n    }\n  }\n  answer = 1;\n  tree.Print();\n  cout << answer;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 7, mod = 998244353;\nint n, m;\nstruct pqt {\n  int op[N], siz[N], tot, rt;\n  vector<int> son[N];\n  void init(int x = -1) {\n    if (x != -1) n = x;\n    tot = n, rt = ++tot;\n    for (int i = (1); i <= (n); ++i) son[rt].push_back(i);\n  }\n  bool vis[N];\n  int count[N], ops[N];\n  int GV(int x) { return count[x] ? (count[x] == siz[x] ? 2 : 1) : 0; }\n  void dfs1(int x) {\n    if (x <= n)\n      return count[x] = vis[x], siz[x] = 1, ops[x] = vis[x] ? 2 : 1, void();\n    count[x] = siz[x] = ops[x] = 0;\n    for (int v : son[x])\n      dfs1(v), count[x] += count[v], siz[x] += siz[v], ops[x] |= ops[v];\n  }\n  bool isok;\n  int dfs2(int x, int lim) {\n    if (ops[x] != 3) return x;\n    vector<int> a[3];\n    for (int v : son[x]) a[GV(v)].push_back(v);\n    if (((int)a[1].size()) > 2 || (lim && ((int)a[1].size()) == 2))\n      isok = false;\n    if (!lim) {\n      for (int i = (0); i <= (((int)son[x].size()) - 1); ++i)\n        if (count[son[x][i]] == count[x])\n          return son[x][i] = dfs2(son[x][i], 0), x;\n    }\n    if (!op[x]) {\n      int ct = -1, rx = -1;\n      if (((int)a[2].size()) == 1)\n        ct = a[2][0];\n      else if (((int)a[2].size()) > 1)\n        ct = ++tot, op[ct] = 0, son[ct] = a[2];\n      vector<int> t;\n      if (((int)a[1].size())) {\n        rx = dfs2(a[1][0], 2);\n        for (int v : son[rx]) t.push_back(v);\n      }\n      if (~ct) t.push_back(ct);\n      if (((int)a[1].size()) > 1) {\n        rx = dfs2(a[1][1], 1);\n        for (int v : son[rx]) t.push_back(v);\n      }\n      if (!((int)a[0].size())) {\n        if (lim == 1) reverse(t.begin(), t.end());\n        op[x] = 1, son[x] = t;\n        return x;\n      }\n      int px = t[0];\n      if (((int)t.size()) > 1) px = ++tot, son[px] = t, op[px] = 1;\n      if (lim) {\n        son[x].clear(), op[x] = 1;\n        int zer = a[0][0];\n        if (((int)a[0].size()) > 1) zer = ++tot, op[zer] = 0, son[zer] = a[0];\n        son[x].push_back(zer);\n        for (int v : t) son[x].push_back(v);\n        if (lim == 1) reverse(son[x].begin(), son[x].end());\n      } else\n        son[x] = a[0], son[x].push_back(px);\n    } else {\n      int cnt = 0;\n      vector<int> t;\n      if (GV(son[x][0]) == 2 || GV(son[x][((int)son[x].size()) - 1]) == 0)\n        reverse(son[x].begin(), son[x].end());\n      for (int v : son[x]) {\n        int w = GV(v);\n        if (w == 1) {\n          if (cnt == 2) isok = false;\n          ++cnt;\n          int z = dfs2(v, 3 - cnt);\n          for (int p : son[z]) t.push_back(p);\n        } else if (w == 2) {\n          t.push_back(v);\n          if (cnt == 0) cnt = 1;\n          if (cnt == 2) isok = false;\n        } else {\n          t.push_back(v);\n          if (cnt == 1) cnt = 2;\n        }\n      }\n      if (lim && cnt == 2) isok = false;\n      if (lim == 1) reverse(t.begin(), t.end());\n      son[x] = t;\n    }\n    return x;\n  }\n  bool insert(vector<int> r) {\n    for (int i = (1); i <= (n); ++i) vis[i] = false;\n    for (const int &x : r) vis[x] = true;\n    dfs1(rt), isok = true, rt = dfs2(rt, 0);\n    return isok;\n  }\n  vector<int> ns;\n  void output(int x) {\n    if (x <= n) return ns.push_back(x), void();\n    cout << x << \" : \" << op[x] << \"\\n\";\n    for (int v : son[x]) cout << x << \" \" << v << \"\\n\";\n    for (int v : son[x]) output(v);\n  }\n  int get(int x) {\n    if (x <= n) return 1;\n    int res = 1;\n    if (op[x] == 0)\n      for (int i = (1); i <= (((int)son[x].size())); ++i)\n        res = (long long)res * i % mod;\n    else\n      res = (long long)res * 2 % mod;\n    for (int v : son[x]) res = (long long)res * get(v) % mod;\n    return res;\n  }\n} t;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  t.init(n);\n  while (m--) {\n    vector<int> s;\n    int q, w;\n    cin >> q;\n    while (q--) cin >> w, s.push_back(w);\n    if (!t.insert(s)) return cout << \"0\\n\", 0;\n  }\n  cout << t.get(t.rt) << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long get_time() {\n  return chrono::duration_cast<chrono::nanoseconds>(\n             chrono::steady_clock::now().time_since_epoch())\n      .count();\n}\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n  bool done_something = false;\n  stringstream res;\n  res << \"[\";\n  for (; begin_iter != end_iter and counter; ++begin_iter) {\n    done_something = true;\n    counter--;\n    res << *begin_iter << \", \";\n  }\n  string str = res.str();\n  if (done_something) {\n    str.pop_back();\n    str.pop_back();\n  }\n  str += \"]\";\n  return str;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& out, const pair<S, T>& p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  for (int i = 0; i < (int)v.size(); i++) {\n    out << v[i];\n    if (i != (int)v.size() - 1) out << \", \";\n  }\n  out << \"]\";\n  return out;\n}\ntemplate <class TH>\nvoid _dbg(const char* name, TH val) {\n  clog << name << \": \" << val << endl;\n}\ntemplate <class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n  while (*names != ',') clog << *names++;\n  clog << \": \" << curr_val << \", \";\n  _dbg(names + 1, vals...);\n}\nconst long long mod = 998244353;\nconst int MAXN = 100;\nconst int MAXM = 100;\nint N;\nbool visited[MAXM];\nvector<int> aa[MAXM];\nint M;\nbitset<MAXN> S[MAXM];\nbool dfs(int v, vector<bitset<MAXN>>& E) {\n  visited[v] = true;\n  string intersection_type(E.size(), '-');\n  bitset<MAXN> A = S[v];\n  for (int i = 0; i < ((int)((E).size())); i++) {\n    bitset<MAXN> inter = A & E[i];\n    if (inter.none())\n      intersection_type[i] = '0';\n    else if (inter != E[i])\n      intersection_type[i] = '1';\n    else\n      intersection_type[i] = '2';\n    A = A & ~inter;\n  }\n  bool is_prefix = regex_match(intersection_type, regex(\"2*1?0*\"));\n  bool is_suffix = regex_match(intersection_type, regex(\"0*1?2*\"));\n  bool is_interval = regex_match(intersection_type, regex(\"0*1?2*1?0*\"));\n  if (!is_interval) return false;\n  if (!is_prefix and !is_suffix and A.any()) return false;\n  if (!is_suffix and A.any()) {\n    reverse(E.begin(), E.end());\n    reverse(intersection_type.begin(), intersection_type.end());\n  }\n  if (A.any()) {\n    E.push_back(A);\n    intersection_type += '2';\n  }\n  for (int i = ((int)((E).size())) - 1; i >= 0; i--) {\n    if (intersection_type[i] == '1') {\n      bitset<MAXN> e1 = S[v] & E[i];\n      bitset<MAXN> e2 = E[i] & ~S[v];\n      E.erase(E.begin() + i);\n      if (i >= 1 and intersection_type[i - 1] != '0') {\n        E.insert(E.begin() + i, e2);\n        E.insert(E.begin() + i, e1);\n      } else if (i < ((int)((intersection_type).size())) - 1 and\n                 intersection_type[i + 1] != '0') {\n        E.insert(E.begin() + i, e1);\n        E.insert(E.begin() + i, e2);\n      } else\n        assert(0);\n    }\n  }\n  for (int a : aa[v]) {\n    if (visited[a]) continue;\n    if (!dfs(a, E)) return false;\n  }\n  return true;\n}\nlong long solve() {\n  for (int i = 0; i < M; i++) aa[i].clear(), visited[i] = false;\n  for (int i = 0; i < M; i++) {\n    for (int j = i + 1; j < M; j++) {\n      bitset<MAXN> inter = S[i] & S[j];\n      if (inter.any() and inter != S[i] and inter != S[j]) {\n        aa[i].push_back(j);\n        aa[j].push_back(i);\n      }\n    }\n  }\n  vector<pair<bitset<MAXN>, vector<bitset<MAXN>>>> equiv;\n  for (int i = 0; i < M; i++) {\n    if (visited[i]) continue;\n    vector<bitset<MAXN>> E;\n    if (!dfs(i, E)) return 0;\n    bitset<MAXN> PP;\n    for (auto e : E) PP |= e;\n    equiv.push_back({PP, E});\n  }\n  bitset<MAXN> full_set;\n  for (int i = 0; i < N; i++) full_set[i] = 1;\n  equiv.emplace_back(full_set, vector<bitset<MAXN>>{full_set});\n  sort(equiv.begin(), equiv.end(),\n       [&](const pair<bitset<MAXN>, vector<bitset<MAXN>>>& A,\n           const pair<bitset<MAXN>, vector<bitset<MAXN>>>& B) {\n         if (A.first.count() != B.first.count())\n           return A.first.count() > B.first.count();\n         return A.second.size() < B.second.size();\n       });\n  long long res = 1;\n  for (int i = 0; i < ((int)((equiv).size())); i++) {\n    if (equiv[i].second.size() >= 2) res *= 2;\n    for (bitset<MAXN> A : equiv[i].second) {\n      int cnt = A.count();\n      for (int j = i + 1; j < ((int)((equiv).size())); j++) {\n        bitset<MAXN> P = equiv[j].first;\n        if ((P & A) == P) {\n          cnt -= P.count() - 1;\n          A &= ~P;\n        }\n      }\n      for (int m = 1; m <= cnt; m++) res = res * m % mod;\n    }\n  }\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> M;\n  for (int i = 0; i < M; i++) {\n    int q;\n    cin >> q;\n    for (int j = 0; j < q; j++) {\n      int s;\n      cin >> s;\n      S[i][s - 1] = 1;\n    }\n  }\n  cout << solve() << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline void NO() {\n  puts(\"0\");\n  exit(0);\n}\nint n, vis[105], fact[105];\nnamespace PQ {\nconst int V = 50005;\nstruct Node {\n  int ty;\n  bool full, empty;\n  vector<int> son;\n} tr[V];\nint tot, rt;\ninline int newnode(int ty) {\n  tr[++tot].ty = ty;\n  return tot;\n}\ninline bool isleaf(int u) { return u >= 1 && u <= n; }\ninline void Init() {\n  tot = 0;\n  rt = n + 1;\n  for (int i = 1; i <= n; i++) tr[rt].son.push_back(newnode(1));\n  newnode(0);\n}\nvoid fix(int u) {\n  vector<int> nson;\n  for (int v : tr[u].son) {\n    fix(v);\n    while (tr[v].son.size() == 1) v = tr[v].son[0];\n    if (isleaf(v) || !tr[v].son.empty()) nson.push_back(v);\n  }\n  tr[u].son.swap(nson);\n}\nvoid dfs(int u) {\n  if (isleaf(u)) {\n    tr[u].full = vis[u];\n    tr[u].empty = !vis[u];\n    return;\n  }\n  tr[u].full = tr[u].empty = 1;\n  for (int v : tr[u].son) {\n    dfs(v);\n    tr[u].full &= tr[v].full;\n    tr[u].empty &= tr[v].empty;\n  }\n}\nvector<int> split(int u) {\n  if (tr[u].full || tr[u].empty) return {u};\n  vector<int> nson;\n  if (tr[u].ty) {\n    if (tr[tr[u].son[0]].empty || tr[tr[u].son.back()].full)\n      reverse(tr[u].son.begin(), tr[u].son.end());\n    int l = V, r = -1;\n    for (int i = 0; i < (int)tr[u].son.size(); i++)\n      if (!tr[tr[u].son[i]].empty) {\n        l = min(l, i);\n        r = max(r, i);\n      }\n    if (l) NO();\n    for (int i = 0; i < (int)tr[u].son.size(); i++) {\n      int v = tr[u].son[i];\n      if (!tr[v].full && i >= l && i < r) NO();\n      if (tr[v].full || tr[v].empty)\n        nson.push_back(v);\n      else {\n        vector<int> cur = split(v);\n        nson.insert(nson.end(), cur.begin(), cur.end());\n      }\n    }\n  } else {\n    int x0 = newnode(0), x1 = newnode(0);\n    bool flag = 0;\n    nson.push_back(x1);\n    for (int v : tr[u].son) {\n      if (!tr[v].empty) {\n        if (!tr[v].full) {\n          if (flag) NO();\n          flag = 1;\n          vector<int> cur = split(v);\n          nson.insert(nson.end(), cur.begin(), cur.end());\n        } else\n          tr[x1].son.push_back(v);\n      } else\n        tr[x0].son.push_back(v);\n    }\n    nson.push_back(x0);\n  }\n  return nson;\n}\nvoid work(int u) {\n  if (tr[u].full || tr[u].empty) return;\n  if (tr[u].ty) {\n    int l = V, r = -1;\n    for (int i = 0; i < (int)tr[u].son.size(); i++)\n      if (!tr[tr[u].son[i]].empty) {\n        l = min(l, i);\n        r = max(r, i);\n      }\n    if (l == r) {\n      work(tr[u].son[l]);\n      return;\n    }\n    vector<int> nson;\n    for (int i = 0; i < (int)tr[u].son.size(); i++) {\n      int v = tr[u].son[i];\n      if (!tr[v].full && i > l && i < r) NO();\n      if (tr[v].full || tr[v].empty)\n        nson.push_back(v);\n      else {\n        vector<int> cur = split(v);\n        if (i == l) reverse(cur.begin(), cur.end());\n        nson.insert(nson.end(), cur.begin(), cur.end());\n      }\n    }\n    tr[u].son.swap(nson);\n  } else {\n    int tot = 0;\n    for (int v : tr[u].son) tot += !tr[v].empty;\n    if (tot == 1) {\n      for (int v : tr[u].son)\n        if (!tr[v].empty) {\n          work(v);\n          return;\n        }\n    }\n    vector<int> nson;\n    int x0 = newnode(1), x1 = newnode(0), cnt = 0;\n    nson.push_back(x0);\n    for (int v : tr[u].son) {\n      if (tr[v].empty)\n        nson.push_back(v);\n      else {\n        if (tr[v].full)\n          tr[x1].son.push_back(v);\n        else {\n          cnt++;\n          if (cnt > 2) NO();\n          vector<int> cur = split(v);\n          if (cnt == 1) reverse(cur.begin(), cur.end());\n          tr[x0].son.insert(tr[x0].son.end(), cur.begin(), cur.end());\n          if (cnt == 1) tr[x0].son.push_back(x1);\n        }\n      }\n    }\n    if (!cnt) nson.push_back(x1);\n    tr[u].son.swap(nson);\n  }\n}\nvoid add() {\n  dfs(rt);\n  work(rt);\n  fix(rt);\n  while (tr[rt].son.size() == 1) rt = tr[rt].son[0];\n}\nint findans(int u = rt) {\n  if (isleaf(u)) return 1;\n  int res = (tr[u].ty ? 2 : fact[tr[u].son.size()]);\n  for (int v : tr[u].son) res = 1ll * res * findans(v) % mod;\n  return res;\n}\n}  // namespace PQ\nint main() {\n  int m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = fact[0] = 1; i <= n; i++) fact[i] = 1ll * fact[i - 1] * i % mod;\n  PQ::Init();\n  while (m--) {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n    int c;\n    scanf(\"%d\", &c);\n    while (c--) {\n      int x;\n      scanf(\"%d\", &x);\n      vis[x] = 1;\n    }\n    PQ::add();\n  }\n  printf(\"%d\\n\", PQ::findans());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int IINF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = numeric_limits<double>::infinity();\nconst double EPS = 1e-9;\nconst double PI = acos((double)-1.0);\nconst int DX[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int DY[] = {0, 1, 0, -1, 1, -1, -1, 1};\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long sqr(long long x) { return x * x; }\nlong long sqr(int x) { return (long long)x * x; }\ndouble sqr(double x) { return x * x; }\nmt19937 mmtw(960172);\nlong long rnd(long long x, long long y) {\n  static uniform_int_distribution<long long> d;\n  return d(mmtw) % (y - x + 1) + x;\n}\ntemplate <typename T>\nT& updMin(T& a, T const& b) {\n  if (b < a) a = b;\n  return a;\n}\ntemplate <typename T>\nT& updMax(T& a, T const& b) {\n  if (a < b) a = b;\n  return a;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, vector<T>& a) {\n  for (T& x : a) in >> x;\n  return in;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, vector<T> const& a) {\n  bool f = true;\n  for (T const& x : a) {\n    if (!f) out << \" \";\n    f = false;\n    out << x;\n  }\n  return out;\n}\ntemplate <typename A, typename B>\nistream& operator>>(istream& in, pair<A, B>& p) {\n  return in >> p.first >> p.second;\n}\ntemplate <typename A, typename B>\nostream& operator<<(ostream& out, pair<A, B> const& p) {\n  return out << p.first << \" \" << p.second;\n}\ntemplate <typename T>\nT pw(T a, long long b) {\n  T r = T(1);\n  for (; b; b >>= 1) {\n    if (b & 1) r *= a;\n    a *= a;\n  }\n  return r;\n}\ntemplate <int M>\nstruct mint_t {\n  int v;\n  mint_t() : v(0) {}\n  mint_t(int v) : v(v % M) {\n    if (v < 0) v += M;\n  }\n  mint_t(long long v) : v(v % M) {\n    if (v < 0) v += M;\n  }\n  mint_t(mint_t<M> const& b) : v(b.v) {}\n  mint_t& operator=(mint_t b) {\n    v = b.v;\n    return *this;\n  }\n  mint_t& operator+=(mint_t b) {\n    v += b.v;\n    if (v >= M) v -= M;\n    return *this;\n  }\n  mint_t& operator-=(mint_t b) {\n    v -= b.v;\n    if (v < 0) v += M;\n    return *this;\n  }\n  mint_t& operator*=(mint_t b) {\n    v = 1LL * v * b.v % M;\n    return *this;\n  }\n  mint_t& operator/=(mint_t b) { return *this *= pw(b, M - 2); }\n  mint_t operator-() const { return mint_t(v == 0 ? 0 : M - v); }\n  mint_t& operator++() {\n    if (++v == M) v = 0;\n    return *this;\n  }\n  mint_t& operator--() {\n    if (v == 0)\n      v = M - 1;\n    else\n      --v;\n    return *this;\n  }\n  mint_t operator++(int) {\n    mint_t a = *this;\n    ++*this;\n    return a;\n  }\n  mint_t operator--(int) {\n    mint_t a = *this;\n    --*this;\n    return a;\n  }\n};\ntemplate <int M>\nmint_t<M> operator+(mint_t<M> a, mint_t<M> b) {\n  return a += b;\n}\ntemplate <int M>\nmint_t<M> operator-(mint_t<M> a, mint_t<M> b) {\n  return a -= b;\n}\ntemplate <int M>\nmint_t<M> operator*(mint_t<M> a, mint_t<M> b) {\n  return a *= b;\n}\ntemplate <int M>\nmint_t<M> operator/(mint_t<M> a, mint_t<M> b) {\n  return a /= b;\n}\ntemplate <int M>\nmint_t<M> operator+(mint_t<M> a, int b) {\n  return a += b;\n}\ntemplate <int M>\nmint_t<M> operator-(mint_t<M> a, int b) {\n  return a -= b;\n}\ntemplate <int M>\nmint_t<M> operator*(mint_t<M> a, int b) {\n  return a *= b;\n}\ntemplate <int M>\nmint_t<M> operator/(mint_t<M> a, int b) {\n  return a /= b;\n}\ntemplate <int M>\nmint_t<M> operator+(int a, mint_t<M> b) {\n  mint_t<M> aa = a;\n  return aa += b;\n}\ntemplate <int M>\nmint_t<M> operator-(int a, mint_t<M> b) {\n  mint_t<M> aa = a;\n  return aa -= b;\n}\ntemplate <int M>\nmint_t<M> operator*(int a, mint_t<M> b) {\n  mint_t<M> aa = a;\n  return aa *= b;\n}\ntemplate <int M>\nmint_t<M> operator/(int a, mint_t<M> b) {\n  mint_t<M> aa = a;\n  return aa /= b;\n}\ntemplate <int M>\nbool operator==(mint_t<M> a, mint_t<M> b) {\n  return a.v == b.v;\n}\ntemplate <int M>\nbool operator!=(mint_t<M> a, mint_t<M> b) {\n  return a.v != b.v;\n}\ntemplate <int M>\nbool operator<(mint_t<M> a, mint_t<M> b) {\n  return a.v < b.v;\n}\ntemplate <int M>\nbool operator>(mint_t<M> a, mint_t<M> b) {\n  return a.v > b.v;\n}\ntemplate <int M>\nbool operator<=(mint_t<M> a, mint_t<M> b) {\n  return a.v <= b.v;\n}\ntemplate <int M>\nbool operator>=(mint_t<M> a, mint_t<M> b) {\n  return a.v >= b.v;\n}\ntemplate <int M>\nbool operator==(mint_t<M> a, int b) {\n  return a == mint_t<M>(b);\n}\ntemplate <int M>\nbool operator!=(mint_t<M> a, int b) {\n  return a != mint_t<M>(b);\n}\ntemplate <int M>\nbool operator==(int a, mint_t<M> b) {\n  return b == mint_t<M>(a);\n}\ntemplate <int M>\nbool operator!=(int a, mint_t<M> b) {\n  return b != mint_t<M>(a);\n}\ntemplate <int M>\nistream& operator>>(istream& in, mint_t<M>& a) {\n  int x;\n  in >> x;\n  a = x;\n  return in;\n}\ntemplate <int M>\nostream& operator<<(ostream& out, mint_t<M> a) {\n  return out << a.v;\n}\nconst int MOD = 998244353;\nconst int N = 103;\nbool its(__int128_t a, __int128_t b) {\n  auto c = a & b;\n  return a != c && b != c && c;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> sets;\n  set<__int128_t> swas;\n  vector<__int128_t> setm;\n  for (int i = -1; i < m; ++i) {\n    int k;\n    vector<int> s;\n    if (i == -1)\n      k = n;\n    else {\n      cin >> k;\n    }\n    __int128_t mask = 0;\n    for (int j = 0; j < k; ++j) {\n      int s1;\n      if (i == -1)\n        s1 = j;\n      else {\n        cin >> s1;\n        --s1;\n      }\n      s.push_back(s1);\n      mask |= (__int128_t)1 << s1;\n    }\n    if (swas.count(mask)) continue;\n    swas.insert(mask);\n    setm.push_back(mask);\n    sets.push_back(s);\n  }\n  m = ((int)((sets).size()));\n  mint_t<MOD> ans = 1;\n  vector<char> vis(m, 0);\n  vector<pair<__int128_t, int>> keks, keks2;\n  for (int s0 = 0; s0 < m; ++s0) {\n    if (vis[s0]) continue;\n    vis[s0] = 1;\n    vector<int> rank(n, -1);\n    int mrank = 0;\n    for (int x : sets[s0]) rank[x] = 0;\n    set<int> q;\n    for (int i = 0; i < m; ++i)\n      if (!vis[i] && its(setm[i], setm[s0])) q.insert(i);\n    vector<int> qq = {s0};\n    while (!q.empty()) {\n      int s = *q.begin();\n      qq.push_back(s);\n      q.erase(s);\n      vis[s] = 1;\n      for (int i = 0; i < m; ++i)\n        if (!vis[i] && its(setm[i], setm[s])) q.insert(i);\n      int cl = IINF, cr = -IINF;\n      int wasMR = 0;\n      for (int i = 0; i < n; ++i)\n        if (rank[i] == mrank) ++wasMR;\n      for (int v : sets[s]) {\n        if (rank[v] == -1) rank[v] = mrank + 1;\n        if (rank[v] == mrank) wasMR--;\n        cl = min(rank[v], cl);\n        cr = max(rank[v], cr);\n      }\n      if (cr == mrank + 1 && wasMR && cl != mrank) {\n        for (int v = 0; v < n; ++v)\n          if (rank[v] == mrank + 1)\n            rank[v] = 0;\n          else if (rank[v] != -1)\n            rank[v] += 2;\n        for (int v : sets[s])\n          if (rank[v] != 0) --rank[v];\n        mrank = *max_element((rank).begin(), (rank).end());\n        continue;\n      }\n      for (int v = 0; v < n; ++v)\n        if (rank[v] >= cr) rank[v] += 2;\n      for (int v : sets[s]) {\n        if (rank[v] == cr + 2)\n          --rank[v];\n        else\n          ++rank[v];\n      }\n      mrank = *max_element((rank).begin(), (rank).end());\n    }\n    for (int s : qq) {\n      int cl = IINF, cr = -IINF;\n      for (int v : sets[s]) {\n        cl = min(rank[v], cl);\n        cr = max(rank[v], cr);\n      }\n      int cnt = ((int)((sets[s]).size()));\n      for (int i = 0; i < n; ++i)\n        if (cl <= rank[i] && rank[i] <= cr) --cnt;\n      if (cnt != 0 || (cl == cr && ((int)((qq).size())) != 1)) {\n        cout << \"0\\n\";\n        return;\n      }\n    }\n    if (((int)((qq).size())) > 1) ans *= 2;\n    map<int, __int128_t> skeks;\n    __int128_t kek = 0;\n    for (int i = 0; i < n; ++i) {\n      if (rank[i] != -1) {\n        skeks[rank[i]] |= (__int128_t)1 << i;\n        kek |= (__int128_t)1 << i;\n      }\n    }\n    keks2.push_back({kek, s0});\n    for (auto p : skeks) keks.push_back({p.second, s0});\n  }\n  for (auto kk : keks) {\n    auto mask = kk.first;\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) cnt += ((mask >> i) & 1);\n    for (auto kk2 : keks2) {\n      auto mask2 = kk2.first;\n      if ((mask2 & mask) != mask2 || kk2.second == kk.second) continue;\n      bool ok = true;\n      for (auto kk3 : keks2) {\n        auto mask3 = kk3.first;\n        if ((mask3 & mask) != mask3 || kk3.second == kk.second ||\n            kk3.second == kk2.second)\n          continue;\n        if ((mask3 & mask2) == mask2 &&\n            (mask3 != mask2 || kk3.second < kk2.second)) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        ++cnt;\n        for (int i = 0; i < n; ++i) cnt -= ((mask2 >> i) & 1);\n      }\n    }\n    for (int i = 1; i <= cnt; ++i) ans *= i;\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::vector;\nconst int N = 105, MOD = 998244353;\nint n, m, sz[N], fac[N], inv[N], id[N];\nbitset<N> q[N];\nvector<bitset<N> > v;\nbitset<N> U;\ninline int solve(bitset<N> v, vector<bitset<N> > q, int cnt, int ok) {\n  if (!v.count()) return 1;\n  if (q.empty())\n    return ok ? 1ll * fac[v.count()] * (cnt + 1) % MOD\n              : 1ll * fac[v.count() + cnt] * inv[cnt] % MOD;\n  vector<bitset<N> > e;\n  e.push_back((*q.rbegin()) & v);\n  q.pop_back();\n  while (1) {\n    bool ok = 0;\n    vector<bitset<N> > buff;\n    for (auto &x : q) {\n      int l = 0;\n      while (l < e.size() && (e[l] & x).none()) ++l;\n      if (l == e.size()) continue;\n      if ((e[l] & x) == x) continue;\n      int r = l + 1;\n      bitset<N> tmp;\n      tmp = e[l];\n      while (r < e.size() && (e[r] & x) == e[r]) tmp |= e[r], ++r;\n      if (r != e.size()) tmp |= e[r];\n      tmp &= x;\n      if (l == r && (e[r] & x) == x) continue;\n      for (int i = r + 1; i < e.size(); ++i)\n        if ((e[i] & x).any()) puts(\"0\"), exit(0);\n      if (l && r != e.size() && tmp != x) puts(\"0\"), exit(0);\n      if (tmp != x) {\n        ok = 1;\n        if (!l)\n          e.insert(e.begin(), x ^ tmp), buff.push_back(x & tmp);\n        else if (r == e.size())\n          e.push_back(x ^ tmp), buff.push_back(x & tmp);\n        else\n          puts(\"0\"), exit(0);\n        break;\n      }\n      if (r < e.size() && (e[r] & x).any()) {\n        auto a = e[r] & x;\n        ok = 1;\n        e[r] ^= a;\n        assert(e.size() >= r);\n        e.insert(e.begin() + r, a);\n        break;\n      }\n      if (l < e.size() && (e[l] & x) != e[l]) {\n        auto a = e[l] & x;\n        ok = 1;\n        e[l] ^= a;\n        assert(e.size() >= l + 1);\n        e.insert(e.begin() + l + 1, a);\n        break;\n      }\n    }\n    for (auto &x : buff) q.push_back(x);\n    if (!ok) break;\n  }\n  for (auto &x : e) v ^= x;\n  int ret = 1;\n  for (auto &x : e) {\n    vector<bitset<N> > tmp;\n    for (auto &y : q)\n      if ((x & y).any() && (x & y) != x) tmp.push_back(y);\n    ret = 1ll * ret * solve(x, tmp, 0, 1) % MOD;\n  }\n  if (e.size() > 1) ret = 2ll * ret % MOD;\n  vector<bitset<N> > tmp;\n  int cok = 0;\n  for (auto &y : q)\n    if ((v & y).any()) {\n      if ((v & y) != v)\n        tmp.push_back(y);\n      else\n        cok = 1;\n    }\n  ret = 1ll * ret * solve(v, tmp, (ok ? 0 : cnt) + 1, cok) % MOD;\n  ret = 1ll * ret * (cnt + 1) % MOD;\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  inv[0] = inv[1] = fac[0] = 1;\n  for (int i = 2; i <= n; ++i)\n    inv[i] = MOD - 1ll * (MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= n; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % MOD,\n    inv[i] = 1ll * inv[i] * inv[i - 1] % MOD;\n  for (int i = 1; i <= n; ++i) U.set(i);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d\", sz + i);\n    for (int j = 1, x; j <= sz[i]; ++j) scanf(\"%d\", &x), q[i].set(x);\n    id[i] = i;\n  }\n  std::sort(id + 1, id + m + 1,\n            [](int x, int y) { return q[x].count() < q[y].count(); });\n  for (int i = 1; i <= m; ++i)\n    if (q[id[i]].count() < n) v.push_back(q[id[i]]);\n  printf(\"%d\\n\", solve(U, v, 0, 0));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &t) {\n  t = 0;\n  char ch = getchar();\n  int f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  do {\n    (t *= 10) += ch - '0';\n    ch = getchar();\n  } while ('0' <= ch && ch <= '9');\n  t *= f;\n}\ntemplate <typename T>\nvoid write(T t) {\n  if (t < 0) {\n    putchar('-');\n    write(-t);\n    return;\n  }\n  if (t > 9) write(t / 10);\n  putchar('0' + t % 10);\n}\ntemplate <typename T>\nvoid writeln(T t) {\n  write(t);\n  puts(\"\");\n}\nconst int mod = 998244353;\nint jc[110], n, m, cnt;\nbool vis[110];\n__int128 S[110];\nint ans;\nint id[110], bit[1048576];\nint Pop(__int128 x) {\n  return bit[x & 1048575] + bit[(x >> 20) & 1048575] +\n         bit[(x >> 40) & 1048575] + bit[(x >> 60) & 1048575] +\n         bit[(x >> 80) & 1048575] + bit[(x >> 100) & 1048575];\n}\nvoid print(__int128 x) {\n  printf(\"( \");\n  for (int i = 1; i <= n; i++)\n    if (x >> (i - 1) & 1) printf(\"%d \", i);\n  printf(\")\");\n}\nstruct Comp {\n  __int128 P;\n  int szP;\n  vector<__int128> S, Z, Z2;\n  void build() {\n    if ((int)S.size() == 1) {\n      Z = S;\n      P = S[0];\n      return;\n    }\n    ans = (long long)ans * 2 % mod;\n    Z = {S[0] - (S[0] & S[1]), S[0] & S[1], S[1] - (S[0] & S[1])};\n    P = (S[0] | S[1]);\n    for (int i = 2; i < (int)S.size(); i++) {\n      Z2.clear();\n      vector<int> I;\n      for (int j = 0; j < Z.size(); j++)\n        if ((Z[j] & S[i]) && (Z[j] - (Z[j] & S[i]))) I.push_back(j);\n      __int128 Z0 = S[i] - (S[i] & P);\n      if ((int)I.size() >= 3) {\n        puts(\"0\");\n        exit(0);\n      }\n      if ((int)I.size() == 0) {\n        int l = -1, r = -1;\n        for (int j = 0; j < Z.size(); j++)\n          if (Z[j] & S[i]) {\n            if (l == -1) l = j;\n            r = j;\n          }\n        for (int j = 0; j < Z.size(); j++)\n          if (((Z[j] & S[i]) > 0) != (l <= j && j <= r)) {\n            puts(\"0\");\n            exit(0);\n          }\n        if (l == 0) {\n          if (Z0) Z2.push_back(Z0);\n          for (__int128 E : Z) Z2.push_back(E);\n        } else if (r == (int)Z.size() - 1) {\n          for (__int128 E : Z) Z2.push_back(E);\n          if (Z0) Z2.push_back(Z0);\n        } else if (Z0) {\n          puts(\"0\");\n          exit(0);\n        } else\n          Z2 = Z;\n      } else if ((int)I.size() == 2) {\n        for (int j = 0; j < Z.size(); j++)\n          if (((Z[j] & S[i]) != 0) != (I[0] <= j && j <= I[1])) {\n            puts(\"0\");\n            exit(0);\n          }\n        if (Z0) {\n          puts(\"0\");\n          exit(0);\n        }\n        for (int j = 0; j < I[0]; j++) Z2.push_back(Z[j]);\n        Z2.push_back(Z[I[0]] - (Z[I[0]] & S[i]));\n        Z2.push_back(Z[I[0]] & S[i]);\n        for (int j = I[0] + 1; j < I[1]; j++) Z2.push_back(Z[j]);\n        Z2.push_back(Z[I[1]] & S[i]);\n        Z2.push_back(Z[I[1]] - (Z[I[1]] & S[i]));\n        for (int j = I[1] + 1; j < Z.size(); j++) Z2.push_back(Z[j]);\n      } else {\n        int l = -1, r = -1;\n        for (int j = 0; j < Z.size(); j++)\n          if ((Z[j] & S[i]) != 0) {\n            if (l == -1) l = j;\n            r = j;\n          }\n        for (int j = 0; j < Z.size(); j++)\n          if (((Z[j] & S[i]) != 0) != (l <= j && j <= r)) {\n            puts(\"0\");\n            exit(0);\n          }\n        if (l != I[0] && r != I[0]) {\n          puts(\"0\");\n          exit(0);\n        }\n        if (!Z0) {\n          for (int j = 0; j < I[0]; j++) Z2.push_back(Z[j]);\n          if (l == I[0])\n            Z2.push_back(Z[I[0]] - (Z[I[0]] & S[i])),\n                Z2.push_back(Z[I[0]] & S[i]);\n          else\n            Z2.push_back(Z[I[0]] & S[i]),\n                Z2.push_back(Z[I[0]] - (Z[I[0]] & S[i]));\n          for (int j = I[0] + 1; j < Z.size(); j++) Z2.push_back(Z[j]);\n        } else {\n          if (l == 0 && r == I[0]) {\n            Z2.push_back(Z0);\n            for (int j = 0; j < I[0]; j++) Z2.push_back(Z[j]);\n            Z2.push_back(Z[I[0]] & S[i]),\n                Z2.push_back(Z[I[0]] - (Z[I[0]] & S[i]));\n            for (int j = I[0] + 1; j < Z.size(); j++) Z2.push_back(Z[j]);\n          } else if (l == I[0] && r == (int)Z.size() - 1) {\n            for (int j = 0; j < I[0]; j++) Z2.push_back(Z[j]);\n            Z2.push_back(Z[I[0]] - (Z[I[0]] & S[i])),\n                Z2.push_back(Z[I[0]] & S[i]);\n            for (int j = I[0] + 1; j < Z.size(); j++) Z2.push_back(Z[j]);\n            Z2.push_back(Z0);\n          } else {\n            puts(\"0\");\n            exit(0);\n          }\n        }\n      }\n      Z = Z2;\n      P |= S[i];\n    }\n  }\n} C[110];\nvector<int> g[110];\nvoid dfs(int u) {\n  C[cnt].S.push_back(S[u]);\n  vis[u] = 1;\n  for (int v : g[u])\n    if (!vis[v]) dfs(v);\n}\nbool cmp(int x, int y) {\n  if (C[x].szP != C[y].szP) return C[x].szP > C[y].szP;\n  return (int)C[x].S.size() < (int)C[y].S.size();\n}\nbool anc(int x, int y) {\n  if (C[x].P == C[y].P) return (int)C[x].S.size() == 1;\n  return (C[x].P & C[y].P) == C[y].P;\n}\nvector<int> son[110];\nint main() {\n  for (int i = 1; i < (1 << 20); i++) bit[i] = bit[i - (i & (-i))] + 1;\n  read(n), read(m);\n  ans = 1;\n  int x, y;\n  m++;\n  for (int i = 1; i <= m; i++) {\n    if (i < m) {\n      read(x);\n      while (x--) read(y), y--, S[i] |= (__int128)1 << y;\n    } else\n      S[i] = ((__int128)1 << n) - 1;\n  }\n  sort(S + 1, S + m + 1);\n  m = unique(S + 1, S + m + 1) - S - 1;\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j < i; j++) {\n      __int128 tmp = (S[i] & S[j]);\n      if (tmp != 0 && tmp != S[i] && tmp != S[j])\n        g[i].push_back(j), g[j].push_back(i);\n    }\n  }\n  for (int i = 1; i <= m; i++)\n    if (!vis[i]) cnt++, dfs(i), C[cnt].build();\n  for (int i = 1; i <= cnt; i++)\n    for (int j = 0; j < n; j++)\n      if (C[i].P >> j & 1) C[i].szP++;\n  for (int i = 1; i <= cnt; i++) id[i] = i;\n  jc[0] = 1;\n  for (int i = 1; i <= 100; i++) jc[i] = (long long)jc[i - 1] * i % mod;\n  sort(id + 1, id + cnt + 1, cmp);\n  for (int i = 2; i <= cnt; i++) {\n    int now = id[1];\n    for (int j = 2; j < i; j++)\n      if (anc(now, id[j]) && anc(id[j], id[i])) now = id[j];\n    son[now].push_back(id[i]);\n  }\n  for (int i = 1; i <= cnt; i++) {\n    for (__int128 E : C[i].Z) {\n      int now = Pop(E);\n      for (int j : son[i]) {\n        if ((C[j].P & E) == C[j].P) now -= C[j].szP - 1;\n      }\n      ans = (long long)ans * jc[now] % mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111;\nconst int MO = 998244353;\nint mul(int x, int y) { return (long long)x * y % MO; }\nint fpow(int x, int y = MO - 2) {\n  int z = 1;\n  while (y) {\n    if (y & 1) z = mul(z, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return z;\n}\nint n, q, m, w, a[N], f[N], g[N], h[N];\nbitset<N> d[N], t, c[N];\npair<int, int> solve(bitset<N> u) {\n  int i, j, x, y, l, r;\n  bitset<N> b;\n  j = 0;\n  for (i = 1; i <= q; i++) {\n    if (!a[i] && (d[i] & u) == d[i] && d[i].count() > d[j].count()) j = i;\n  }\n  if (!j) return make_pair(1, u.count());\n  a[j] = 1;\n  m = 1;\n  c[1] = d[j];\n  b = u ^ c[1];\n  while (1) {\n    x = 1;\n    for (i = 1; i <= q; i++) {\n      if (!a[i] && (d[i] & u) == d[i]) {\n        if ((d[i] & b) == d[i]) continue;\n        for (j = 1; j <= m; j++) {\n          t = d[i] & c[j];\n          h[j] = 0;\n          if (t == c[j])\n            h[j] = 2;\n          else {\n            if (t.count()) h[j] = 1;\n          }\n        }\n        l = m + 1, r = 0;\n        for (j = 1; j <= m; j++)\n          if (h[j]) l = min(l, j), r = max(r, j);\n        for (j = l + 1; j <= r - 1; j++)\n          if (h[j] != 2) return make_pair(0, 1);\n        if ((d[i] & b).count()) {\n          if (l == 1 && (h[l] == 2 || r == 1)) {\n            if (h[r] == 1) {\n              for (j = m; j > r; j--) c[j + 1] = c[j];\n              m++;\n              c[r + 1] = c[r] & (~d[i]);\n              c[r] &= d[i];\n            }\n            for (j = m; j >= 1; j--) c[j + 1] = c[j];\n            m++;\n            c[1] = b & d[i];\n            b &= ~d[i];\n          } else {\n            if (r == m && (h[r] == 2 || l == m)) {\n              m++;\n              c[m] = b & d[i];\n              b &= ~d[i];\n              if (h[l] == 1) {\n                for (j = m; j > l; j--) c[j + 1] = c[j];\n                m++;\n                c[l + 1] = c[l] & d[i];\n                c[l] &= ~d[i];\n              }\n            } else {\n              return make_pair(0, 1);\n            }\n          }\n          a[i] = 1, x = 0;\n          break;\n        }\n        if (l == r) {\n          if (h[l] == 2) a[i] = 1;\n          continue;\n        }\n        if (h[r] == 1) {\n          for (j = m; j > r; j--) c[j + 1] = c[j];\n          m++;\n          c[r + 1] = c[r] & (~d[i]);\n          c[r] &= d[i];\n        }\n        if (h[l] == 1) {\n          for (j = m; j > l; j--) c[j + 1] = c[j];\n          m++;\n          c[l + 1] = c[l] & d[i];\n          c[l] &= ~d[i];\n        }\n        a[i] = 1, x = 0;\n        break;\n      }\n    }\n    if (x) break;\n  }\n  pair<int, int> p;\n  x = 1;\n  if (m > 1) x = 2;\n  bitset<N> cc[m + 1], bb = b;\n  int mm = m;\n  for (i = 1; i <= mm; i++) cc[i] = c[i];\n  for (i = 1; i <= mm; i++) {\n    p = solve(cc[i]);\n    x = mul(x, p.first);\n    x = mul(x, f[p.second]);\n  }\n  p = solve(bb);\n  x = mul(x, p.first);\n  return make_pair(x, p.second + 1);\n}\nint main() {\n  int i, j, k, x, y;\n  pair<int, int> p;\n  n = 105;\n  f[0] = 1;\n  for (i = 1; i <= n; i++) f[i] = mul(f[i - 1], i);\n  g[n] = fpow(f[n]);\n  for (i = n; i >= 1; i--) g[i - 1] = mul(g[i], i);\n  scanf(\"%d%d\", &n, &q);\n  for (i = 1; i <= q; i++) {\n    scanf(\"%d\", &x);\n    while (x--) {\n      scanf(\"%d\", &y);\n      d[i][y] = 1;\n    }\n  }\n  for (i = 1; i <= n; i++) t[i] = 1;\n  p = solve(t);\n  printf(\"%d\\n\", mul(p.first, f[p.second]));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint Size[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --Size[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == Size[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (Size[sets[i]] > Size[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (Size[cur]) die();\n            break;\n          }\n        } else {\n          if (started && Size[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (Size[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n      Size[i]++;\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (Size[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111;\nconst int MO = 998244353;\nint mul(int x, int y) { return (long long)x * y % MO; }\nint fpow(int x, int y = MO - 2) {\n  int z = 1;\n  while (y) {\n    if (y & 1) z = mul(z, x);\n    x = mul(x, x);\n    y /= 2;\n  }\n  return z;\n}\nint n, q, m, w, a[N], f[N], g[N], h[N];\nbitset<N> d[N], t, c[N];\npair<int, int> solve(bitset<N> u) {\n  int i, j, x, y, l, r;\n  bitset<N> b;\n  j = 0;\n  for (i = 1; i <= q; i++)\n    if (!a[i] && (d[i] & u) == d[i] && d[i].count() > d[j].count()) j = i;\n  if (!j) return make_pair(1, u.count());\n  a[j] = 1;\n  m = 1;\n  c[1] = d[j];\n  b = u ^ c[1];\n  while (1) {\n    x = 1;\n    for (i = 1; i <= q; i++) {\n      if (!a[i] && (d[i] & u) == d[i]) {\n        if ((d[i] & b) == d[i]) continue;\n        for (j = 1; j <= m; j++) {\n          t = d[i] & c[j];\n          h[j] = 0;\n          if (t == c[j])\n            h[j] = 2;\n          else if (t.count())\n            h[j] = 1;\n        }\n        l = m + 1, r = 0;\n        for (j = 1; j <= m; j++)\n          if (h[j]) {\n            l = min(l, j);\n            r = max(r, j);\n          }\n        for (j = l + 1; j <= r - 1; j++)\n          if (h[j] != 2) return make_pair(0, 1);\n        if ((d[i] & b).count()) {\n          if (l == 1 && (h[l] == 2 || r == 1)) {\n            if (h[r] == 1) {\n              for (j = m; j > r; j--) c[j + 1] = c[j];\n              m++;\n              c[r + 1] = c[r] & (~d[i]);\n              c[r] &= d[i];\n            }\n            for (j = m; j >= 1; j--) c[j + 1] = c[j];\n            m++;\n            c[1] = b & d[i];\n            b &= ~d[i];\n          } else {\n            if (r == m && (h[r] == 2 || l == m)) {\n              m++;\n              c[m] = b & d[i];\n              b &= ~d[i];\n              if (h[l] == 1) {\n                for (j = m; j > l; j--) c[j + 1] = c[j];\n                m++;\n                c[l + 1] = c[l] & d[i];\n                c[l] &= ~d[i];\n              }\n            } else\n              return make_pair(0, 1);\n          }\n          a[i] = 1;\n          x = 0;\n          break;\n        }\n        if (l == r) {\n          if (h[l] == 2) a[i] = 1;\n          continue;\n        }\n        if (h[r] == 1) {\n          for (j = m; j > r; j--) c[j + 1] = c[j];\n          m++;\n          c[r + 1] = c[r] & (~d[i]);\n          c[r] &= d[i];\n        }\n        if (h[l] == 1) {\n          for (j = m; j > l; j--) c[j + 1] = c[j];\n          m++;\n          c[l + 1] = c[l] & d[i];\n          c[l] &= ~d[i];\n        }\n        a[i] = 1;\n        x = 0;\n        break;\n      }\n    }\n    if (x) break;\n  }\n  pair<int, int> p;\n  x = 1;\n  if (m > 1) x = 2;\n  bitset<N> cc[m + 1], bb = b;\n  int mm = m;\n  for (i = 1; i <= mm; i++) cc[i] = c[i];\n  for (i = 1; i <= mm; i++) {\n    p = solve(cc[i]);\n    x = mul(x, p.first);\n    x = mul(x, f[p.second]);\n  }\n  p = solve(bb);\n  x = mul(x, p.first);\n  return make_pair(x, p.second + 1);\n}\nint main() {\n  int i, j, k, x, y;\n  pair<int, int> p;\n  n = 105;\n  f[0] = 1;\n  for (i = 1; i <= n; i++) f[i] = mul(f[i - 1], i);\n  g[n] = fpow(f[n]);\n  for (i = n; i >= 1; i--) g[i - 1] = mul(g[i], i);\n  cin >> n >> q;\n  for (i = 1; i <= q; i++) {\n    cin >> x;\n    while (x--) {\n      cin >> y;\n      d[i][y] = 1;\n    }\n  }\n  for (i = 1; i <= n; i++) t[i] = 1;\n  p = solve(t);\n  cout << mul(p.first, f[p.second]) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nconst unsigned gen_seed =\n    std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937_64 gen(gen_seed);\nlong long gcd(long long a, long long b, long long& x, long long& y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long d = gcd(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return d;\n}\nlong long invmod(long long a, long long modulo) {\n  long long x, y;\n  long long g = gcd(a, modulo, x, y);\n  if (g != 1) {\n    return -1;\n  } else {\n    x = (x % modulo + modulo) % modulo;\n    return x;\n  }\n}\nstd::vector<std::vector<int>> g;\nstd::vector<std::vector<int>> a;\nstd::vector<long long> imod(1000);\nstd::vector<long long> ifac(1000);\nstd::vector<long long> fac(1000);\nstd::vector<int> vis;\nstd::vector<std::vector<int>> comp;\nstd::vector<std::vector<int>> compv;\nstd::vector<std::vector<int>> touched;\nvoid dfs(int v) {\n  vis[v] = 1;\n  comp.back().push_back(v);\n  for (auto u : g[v]) {\n    if (!vis[u]) dfs(u);\n  }\n}\nstd::vector<int> hp;\nstd::vector<int> ts;\nint curpart = 1;\nstd::vector<std::vector<int>> b;\nstd::vector<std::vector<int>> kaka;\nint n, m;\nvoid split(int u, int v) {\n  kaka = std::vector<std::vector<int>>(3);\n  for (int i = 0; i < n; i++) {\n    if (a[u][i] == 1) {\n      if (a[v][i] == 0)\n        kaka[0].push_back(i);\n      else\n        kaka[1].push_back(i);\n    } else if (a[v][i] == 1)\n      kaka[2].push_back(i);\n  }\n}\nint can;\nvoid addkaka(int v) {\n  std::vector<int> ina(n, 0);\n  for (int i = 0; i < n; i++)\n    if (a[v][i]) ina[i] = 1;\n  int l = kaka.size();\n  std::vector<std::vector<int>> ka1(l), ka2(l);\n  std::vector<int> per;\n  for (int i = 0; i < kaka.size(); i++) {\n    for (auto x : kaka[i]) {\n      ina[x] = 0;\n      if (a[v][x])\n        ka1[i].push_back(x);\n      else\n        ka2[i].push_back(x);\n    }\n    if (ka1[i].size() > 0) per.push_back(i);\n  }\n  int y = per.size();\n  for (int i = 0; i < y - 1; i++)\n    if (per[i] + 1 != per[i + 1]) {\n      can = 0;\n      return;\n    }\n  for (int i = 1; i < y - 1; i++)\n    if (ka2[per[i]].size() > 0) {\n      can = 0;\n      return;\n    }\n  std::vector<int> xtra;\n  for (int i = 0; i < n; i++) {\n    if (ina[i]) xtra.push_back(i);\n  }\n  if (xtra.size() > 0) {\n    if (per[0] == 0 && (per.size() == 1 || ka2[0].size() == 0)) {\n      kaka.clear();\n      kaka.push_back(xtra);\n      for (int i = 0; i < l; i++) {\n        if (ka1[i].size() > 0) kaka.push_back(ka1[i]);\n        if (ka2[i].size() > 0) kaka.push_back(ka2[i]);\n      }\n    } else if (per.back() == l - 1 &&\n               (per.size() == 1 || ka2[l - 1].size() == 0)) {\n      kaka.clear();\n      for (int i = 0; i < l; i++) {\n        if (ka2[i].size() > 0) kaka.push_back(ka2[i]);\n        if (ka1[i].size() > 0) kaka.push_back(ka1[i]);\n      }\n      kaka.push_back(xtra);\n    } else {\n      can = 0;\n      return;\n    }\n  } else {\n    kaka.clear();\n    for (int i = 0; i < l; i++) {\n      if (i <= per[0]) {\n        if (ka2[i].size() > 0) kaka.push_back(ka2[i]);\n        if (ka1[i].size() > 0) kaka.push_back(ka1[i]);\n      } else {\n        if (ka1[i].size() > 0) kaka.push_back(ka1[i]);\n        if (ka2[i].size() > 0) kaka.push_back(ka2[i]);\n      }\n    }\n  }\n}\nint main() {\n  long long curfac = 1;\n  for (int i = 1; i < 200; i++) {\n    imod[i] = invmod(i, mod);\n    curfac = curfac * i % mod;\n    fac[i] = curfac;\n    ifac[i] = invmod(curfac, mod);\n  }\n  scanf(\"%d %d\", &n, &m);\n  a = std::vector<std::vector<int>>(m, std::vector<int>(n, 0));\n  long long ans = fac[n];\n  b.resize(m);\n  for (int i = 0; i < m; i++) {\n    int q;\n    scanf(\"%d\", &q);\n    for (int j = 0; j < q; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      x--;\n      b[i].push_back(x);\n      a[i][x] = 1;\n    }\n  }\n  std::vector<int> ao;\n  g.resize(m);\n  for (int i = 0; i < m; i++)\n    for (int j = i + 1; j < m; j++) {\n      int can1 = 0, can2 = 0, can3 = 0;\n      for (int k = 0; k < n; k++) {\n        if (a[i][k] > a[j][k]) can1 = 1;\n        if (a[i][k] < a[j][k]) can2 = 1;\n        if (a[i][k] * a[j][k] == 1) can3 = 1;\n      }\n      if (can1 + can2 + can3 == 3) {\n        g[i].push_back(j);\n        g[j].push_back(i);\n      }\n    }\n  vis = std::vector<int>(m, 0);\n  for (int i = 0; i < m; i++)\n    if (!vis[i]) {\n      comp.push_back(std::vector<int>());\n      dfs(i);\n    }\n  int k = comp.size();\n  compv.resize(k);\n  vector<pair<std::pair<int, int>, int>> cord;\n  for (int i = 0; i < k; i++) {\n    std::vector<int> tk(n, 0);\n    for (auto x : comp[i]) {\n      for (int j = 0; j < n; j++) tk[j] |= a[x][j];\n    }\n    int sum = 0;\n    for (auto x : tk) sum += x;\n    cord.push_back(make_pair(make_pair(sum, -(int)comp[i].size()), i));\n    for (int j = 0; j < n; j++) {\n      if (tk[j]) compv[i].push_back(j);\n    }\n  }\n  sort((cord).begin(), (cord).end());\n  reverse((cord).begin(), (cord).end());\n  hp = std::vector<int>(n, 0);\n  ts = std::vector<int>(1005000, 0);\n  ts[0] = n;\n  for (auto cc : cord) {\n    int ind = cc.second;\n    int prt = hp[compv[ind][0]];\n    int clen = cc.first.first;\n    for (int i = 1; i < clen; i++)\n      if (hp[compv[ind][i]] != prt) {\n        ans = 0;\n        break;\n      }\n    ans = ans * ifac[ts[prt]] % mod;\n    ts[prt] -= clen - 1;\n    ans = ans * fac[ts[prt]] % mod;\n    if (ans == 0) break;\n    if (comp[ind].size() == 1) {\n      for (auto x : compv[ind]) hp[x] = curpart;\n      ts[curpart] = (int)compv[ind].size();\n      ans = ans * fac[ts[curpart]] % mod;\n      curpart++;\n      continue;\n    }\n    ans = ans * 2 % mod;\n    can = 1;\n    split(comp[ind][0], comp[ind][1]);\n    for (int i = 2; i < comp[ind].size(); i++) {\n      addkaka(comp[ind][i]);\n      if (can == 0) break;\n    }\n    if (can == 0) {\n      ans = 0;\n      break;\n    }\n    for (auto x : kaka) {\n      ans = ans * fac[x.size()] % mod;\n      for (auto y : x) hp[y] = curpart;\n      ts[curpart] = x.size();\n      curpart++;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int MOD = 998244353;\nstruct Mint {\n  int val;\n  Mint() { val = 0; }\n  Mint(ll x) {\n    val = (-MOD <= x && x < MOD) ? x : x % MOD;\n    if (val < 0) val += MOD;\n  }\n  template <typename U>\n  explicit operator U() const {\n    return (U)val;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n  Mint& operator+=(const Mint& m) {\n    if ((val += m.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((val -= m.val) < 0) val += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    val = (ll)val * m.val % MOD;\n    return *this;\n  }\n  friend Mint modex(Mint a, ll p) {\n    assert(p >= 0);\n    Mint ans = 1;\n    for (; p; p >>= 1, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  Mint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  Mint operator++(int) {\n    Mint result(*this);\n    *this += 1;\n    return result;\n  }\n  Mint operator--(int) {\n    Mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  Mint operator-() const { return Mint(-val); }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n  friend string to_string(const Mint& b) { return to_string(b.val); }\n};\nvector<Mint> fac(1, 1), invfac(1, 1);\nMint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  while (fac.size() <= n) {\n    fac.push_back(fac.back() * fac.size());\n    invfac.push_back(1 / fac.back());\n  }\n  return fac[n] * invfac[k] * invfac[n - k];\n}\nstruct PqTree {\n  int n;\n  int fail = 0;\n  vector<vector<int>> G;\n  vector<int> ty, sz, szc;\n  vector<bool> s;\n  PqTree(int _n) : n(_n), G(n + 2), ty(n + 2), sz(n + 2), szc(n + 2), s(n + 1) {\n    assert(n >= 1);\n    for (int i = 1; i <= n; ++i) G[n + 1].push_back(i);\n  }\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(const vector<int>& vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G.push_back(vec);\n    ty.push_back(0);\n    sz.push_back(0);\n    szc.push_back(0);\n    return G.size() - 1;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      }\n      ty[u] = 1;\n      G[u].clear();\n      addson(u, p2);\n      if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n      addson(u, mergeP(vec[0]));\n      if (t == 2) reverse(G[u].begin(), G[u].end());\n      return u;\n    }\n    if (getstate(G[u].front()) > getstate(G[u].back()))\n      reverse(G[u].begin(), G[u].end());\n    int flag = 0;\n    vector<int> tG;\n    for (auto v : G[u]) {\n      int sta = getstate(v);\n      if (sta == 0) {\n        if (flag == 1) flag = 2;\n        tG.push_back(v);\n      } else if (sta == 2) {\n        if (flag == 0)\n          flag = 1;\n        else if (flag == 2)\n          return fail = 2, 0;\n        tG.push_back(v);\n      } else {\n        if (flag == 0)\n          flag = 1, check(v, 2);\n        else if (flag == 1)\n          flag = 2, check(v, 1);\n        else\n          return fail = 3, 0;\n        for (auto x : G[v]) tG.push_back(x);\n      }\n    }\n    if (t && flag == 2) return fail = 4, 0;\n    if (t == 1) reverse(tG.begin(), tG.end());\n    G[u] = tG;\n    return u;\n  }\n  void dfsPermutation(int u, vector<int>& per) {\n    if (u <= n) per.push_back(u);\n    for (auto v : G[u]) dfsPermutation(v, per);\n  }\n  vector<int> getPermutation() {\n    vector<int> res;\n    dfsPermutation(n + 1, res);\n    return res;\n  }\n  Mint dfsCount(int u) {\n    if (u <= n) return 1;\n    Mint ret = 1;\n    if (!ty[u]) {\n      ret *= fac[G[u].size()];\n    } else if (G[u].size() != 1) {\n      ret *= 2;\n    }\n    for (auto v : G[u]) ret *= dfsCount(v);\n    return ret;\n  }\n  Mint countPermutations() {\n    if (fail) return 0;\n    binom(n, 0);\n    return dfsCount(n + 1);\n  }\n  void restrict(const vector<int>& res) {\n    for (int i = 1; i <= n; ++i) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  PqTree pq(n);\n  for (int i = 0; i < m; ++i) {\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> res;\n    while (q--) {\n      int s;\n      scanf(\"%d\", &s);\n      res.push_back(s);\n    }\n    pq.restrict(res);\n  }\n  Mint ans = pq.countPermutations();\n  printf(\"%d\\n\", ans.val);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint size[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --size[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == size[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (size[sets[i]] > size[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (size[cur]) die();\n            break;\n          }\n        } else {\n          if (started && size[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (size[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++size[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (size[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int N = 105, NC = N << 1, mod = 998244353;\nstd::vector<int> e[NC];\nint type[NC], opt[NC], nc, n;\nvoid dfs1(int x) {\n  if (x > n) {\n    opt[x] = 0;\n    for (auto v : e[x]) dfs1(v), opt[x] |= opt[v];\n  }\n}\nvoid dfs2(int x, int lim) {\n  if (opt[x] <= 2) return;\n  std::vector<int> a[3];\n  for (auto v : e[x]) a[opt[v] - 1].push_back(v);\n  if (((int)a[2].size()) + (!!lim) > 2) puts(\"0\"), exit(0);\n  if (!lim && ((int)a[1].size()) + ((int)a[2].size()) <= 1)\n    return dfs2(a[1].empty() ? a[2][0] : a[1][0], 0);\n  if (type[x]) {\n    std::vector<int> E;\n    int o = 0;\n    if (!a[1].empty()) {\n      if (((int)a[1].size()) == 1)\n        o = a[1][0];\n      else\n        o = ++nc, type[o] = 1, e[o] = a[1];\n    }\n    if (!a[2].empty()) {\n      dfs2(a[2][0], 2);\n      for (auto v : e[a[2][0]]) E.push_back(v);\n    }\n    if (o) E.push_back(o);\n    if (((int)a[2].size()) > 1) {\n      dfs2(a[2][1], 1);\n      for (auto v : e[a[2][1]]) E.push_back(v);\n    }\n    if (a[0].empty()) {\n      if (lim == 1) std::reverse(E.begin(), E.end());\n      type[x] = 0, e[x] = E;\n    } else {\n      if (!lim) {\n        int t = 0;\n        if (((int)E.size()) == 1)\n          t = E[0];\n        else\n          t = ++nc, type[t] = 0, e[t] = E;\n        e[x] = a[0], e[x].push_back(t);\n      } else {\n        int u = 0;\n        if (((int)a[0].size()) == 1)\n          u = a[0][0];\n        else\n          u = ++nc, type[u] = 1, e[u] = a[0];\n        e[x] = {u};\n        for (auto it : E) e[x].push_back(it);\n        if (lim == 1) std::reverse(e[x].begin(), e[x].end());\n      }\n    }\n  } else {\n    std::vector<int> E;\n    int cnt = 0;\n    if (opt[e[x].back()] == 1 || opt[e[x][0]] == 2)\n      std::reverse(e[x].begin(), e[x].end());\n    for (auto v : e[x]) {\n      if (opt[v] == 1)\n        cnt += cnt == 1, E.push_back(v);\n      else if (opt[v] == 2) {\n        if (cnt == 2) puts(\"0\"), exit(0);\n        cnt += !cnt, dfs2(v, 0), E.push_back(v);\n      } else {\n        if (cnt == 2) puts(\"0\"), exit(0);\n        ++cnt, dfs2(v, 3 - cnt);\n        for (auto it : e[v]) E.push_back(it);\n      }\n    }\n    if (lim && cnt == 2) puts(\"0\"), exit(0);\n    if (lim == 1) std::reverse(E.begin(), E.end());\n    e[x] = E;\n  }\n}\nint fac[N];\nint calc(int x) {\n  int ans = x <= n ? 1 : type[x] ? fac[((int)e[x].size())] : 2;\n  for (auto v : e[x]) ans = 1LL * ans * calc(v) % mod;\n  return ans;\n}\nint main() {\n  fac[0] = 1;\n  for (int i = 1; i < N; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n  int m;\n  read(n, m);\n  int rt = nc = n + 1;\n  type[n + 1] = 1;\n  for (int i = 1; i <= n; ++i) e[n + 1].push_back(i);\n  for (int i = 1; i <= m; ++i) {\n    int q;\n    read(q);\n    for (int i = 1; i <= n; ++i) opt[i] = 1;\n    for (int j = 1, x; j <= q; ++j) read(x), opt[x] = 2;\n    dfs1(rt), dfs2(rt, 0);\n  }\n  printf(\"%d\\n\", calc(rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nclass basic_PQ_tree {\n protected:\n  struct node {\n    std::vector<node *> son;\n    int type, op;\n    node(int tp) : son(), type(tp), op(0) {}\n  };\n  int n;\n  node *rt;\n  std::vector<node *> p;\n  bool ok;\n  void init_op(node *u) {\n    if (u->son.empty()) {\n      return;\n    }\n    u->op = 0;\n    for (auto v : u->son) {\n      init_op(v);\n      u->op |= v->op;\n    }\n  }\n  bool dfs(node *u, int lim) {\n    if (u->op != 3) {\n      return true;\n    }\n    std::vector<node *> a[4];\n    for (auto v : u->son) {\n      a[v->op].push_back(v);\n    }\n    if ((int)a[3].size() > 2 - (lim > 0)) {\n      return false;\n    }\n    if (lim == 0 && (int)(a[2].size() + a[3].size()) == 1) {\n      if (!a[2].empty()) {\n        return dfs(a[2][0], 0);\n      } else {\n        return dfs(a[3][0], 0);\n      }\n    }\n    if (u->type) {\n      if (u->son.front()->op == 2 || u->son.back()->op == 1) {\n        std::reverse(u->son.begin(), u->son.end());\n      }\n      int now = 0;\n      std::vector<node *> tmp;\n      for (auto v : u->son) {\n        if (v->op == 1) {\n          tmp.push_back(v);\n          now += now == 1;\n        } else {\n          if (now == 2) {\n            return false;\n          }\n          if (v->op == 2) {\n            tmp.push_back(v);\n            now += now == 0;\n          } else {\n            ++now;\n            if (!dfs(v, now == 1 ? 2 : 1)) {\n              return false;\n            }\n            tmp.insert(tmp.end(), v->son.begin(), v->son.end());\n            delete v;\n          }\n        }\n      }\n      if (lim > 0) {\n        if (now == 2) {\n          return false;\n        }\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n      }\n      u->son.swap(tmp);\n    } else {\n      node *z = nullptr;\n      if ((int)a[2].size() == 1) {\n        z = a[2][0];\n      } else if ((int)a[2].size() > 1) {\n        z = new node(0);\n        z->son = a[2];\n      }\n      std::vector<node *> tmp;\n      for (int i = 0; i < (int)a[3].size(); ++i) {\n        auto v = a[3][i];\n        if (!dfs(v, i == 0 ? 2 : 1)) {\n          return false;\n        }\n        tmp.insert(tmp.end(), v->son.begin(), v->son.end());\n        delete v;\n        if (i == 0 && z != nullptr) {\n          tmp.push_back(z);\n        }\n      }\n      if (tmp.empty() && z != nullptr) {\n        tmp.push_back(z);\n      }\n      if (a[1].empty()) {\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n        u->type = 1;\n        u->son.swap(tmp);\n      } else if (lim) {\n        node *z;\n        if ((int)a[1].size() > 1) {\n          z = new node(0);\n          z->son = a[1];\n        } else {\n          z = a[1][0];\n        }\n        tmp.insert(tmp.begin(), z);\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n        u->type = 1;\n        u->son.swap(tmp);\n      } else {\n        node *z;\n        if ((int)tmp.size() > 1) {\n          z = new node(1);\n          z->son = tmp;\n        } else {\n          z = tmp[0];\n        }\n        u->son = a[1];\n        u->son.push_back(z);\n      }\n    }\n    return true;\n  }\n\n public:\n  basic_PQ_tree(int _n) : n(_n), rt(new node(0)), p(n), ok(true) {\n    for (int i = 0; i < n; ++i) {\n      p[i] = new node(0);\n      rt->son.push_back(p[i]);\n    }\n  }\n  void insert(const std::vector<int> &a) {\n    if (!ok) {\n      return;\n    }\n    for (int i = 0; i < n; ++i) {\n      p[i]->op = 1;\n    }\n    for (int i : a) {\n      p[i]->op = 2;\n    }\n    init_op(rt);\n    ok &= dfs(rt, 0);\n  }\n  bool valid() { return ok; }\n};\ntemplate <int P>\nclass PQ_tree : public basic_PQ_tree {\n  std::vector<int> fac;\n  int calc(node *u) {\n    if (u->son.empty()) {\n      return 1;\n    }\n    int res = u->type ? 2 : fac[u->son.size()];\n    for (auto v : u->son) {\n      res = 1ll * res * calc(v) % P;\n    }\n    return res;\n  }\n\n public:\n  PQ_tree(int _n) : basic_PQ_tree(_n), fac(n + 1) {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      fac[i] = 1ll * fac[i - 1] * i % P;\n    }\n  }\n  int get_ans() { return valid() ? calc(rt) : 0; }\n};\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, m;\n  std::cin >> n >> m;\n  PQ_tree<998244353> T(n);\n  for (int i = 0; i < m; ++i) {\n    int k;\n    std::cin >> k;\n    std::vector<int> id(k);\n    for (int &x : id) {\n      std::cin >> x;\n      --x;\n    }\n    T.insert(id);\n  }\n  std::cout << T.get_ans() << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass basic_PQ_tree {\n protected:\n  struct node {\n    std::vector<node *> son;\n    int type, op;\n    node(int tp) : son(), type(tp), op(0) {}\n  };\n  int n;\n  node *rt;\n  std::vector<node *> p;\n  bool ok;\n  void init_op(node *u) {\n    if (u->son.empty()) {\n      return;\n    }\n    u->op = 0;\n    for (auto v : u->son) {\n      init_op(v);\n      u->op |= v->op;\n    }\n  }\n  bool dfs(node *u, int lim) {\n    if (u->op != 3) {\n      return true;\n    }\n    std::vector<node *> a[4];\n    for (auto v : u->son) {\n      a[v->op].push_back(v);\n    }\n    if ((int)a[3].size() > 2 - (lim > 0)) {\n      return false;\n    }\n    if (lim == 0 && (int)(a[2].size() + a[3].size()) == 1) {\n      if (!a[2].empty()) {\n        return dfs(a[2][0], 0);\n      } else {\n        return dfs(a[3][0], 0);\n      }\n    }\n    if (u->type) {\n      if (u->son.front()->op == 2 || u->son.back()->op == 1) {\n        std::reverse(u->son.begin(), u->son.end());\n      }\n      int now = 0;\n      std::vector<node *> tmp;\n      for (auto v : u->son) {\n        if (v->op == 1) {\n          tmp.push_back(v);\n          now += now == 1;\n        } else {\n          if (now == 2) {\n            return false;\n          }\n          if (v->op == 2) {\n            tmp.push_back(v);\n            now += now == 0;\n          } else {\n            ++now;\n            if (!dfs(v, now == 1 ? 2 : 1)) {\n              return false;\n            }\n            tmp.insert(tmp.end(), v->son.begin(), v->son.end());\n            delete v;\n          }\n        }\n      }\n      if (lim > 0) {\n        if (now == 2) {\n          return false;\n        }\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n      }\n      u->son.swap(tmp);\n    } else {\n      node *z = nullptr;\n      if ((int)a[2].size() == 1) {\n        z = a[2][0];\n      } else if ((int)a[2].size() > 1) {\n        z = new node(0);\n        z->son = a[2];\n      }\n      std::vector<node *> tmp;\n      for (int i = 0; i < (int)a[3].size(); ++i) {\n        auto v = a[3][i];\n        if (!dfs(v, i == 0 ? 2 : 1)) {\n          return false;\n        }\n        tmp.insert(tmp.end(), v->son.begin(), v->son.end());\n        delete v;\n        if (i == 0 && z != nullptr) {\n          tmp.push_back(z);\n        }\n      }\n      if (tmp.empty() && z != nullptr) {\n        tmp.push_back(z);\n      }\n      if (a[1].empty()) {\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n        u->type = 1;\n        u->son.swap(tmp);\n      } else if (lim) {\n        node *z;\n        if ((int)a[1].size() > 1) {\n          z = new node(0);\n          z->son = a[1];\n        } else {\n          z = a[1][0];\n        }\n        tmp.insert(tmp.begin(), z);\n        if (lim == 1) {\n          std::reverse(tmp.begin(), tmp.end());\n        }\n        u->type = 1;\n        u->son.swap(tmp);\n      } else {\n        node *z;\n        if ((int)tmp.size() > 1) {\n          z = new node(1);\n          z->son = tmp;\n        } else {\n          z = tmp[0];\n        }\n        u->son = a[1];\n        u->son.push_back(z);\n      }\n    }\n    return true;\n  }\n\n public:\n  basic_PQ_tree(int _n) : n(_n), rt(new node(0)), p(n), ok(true) {\n    for (int i = 0; i < n; ++i) {\n      p[i] = new node(0);\n      rt->son.push_back(p[i]);\n    }\n  }\n  void insert(const std::vector<int> &a) {\n    if (!ok) {\n      return;\n    }\n    for (int i = 0; i < n; ++i) {\n      p[i]->op = 1;\n    }\n    for (int i : a) {\n      p[i]->op = 2;\n    }\n    init_op(rt);\n    ok &= dfs(rt, 0);\n  }\n  bool valid() { return ok; }\n};\ntemplate <int P>\nclass PQ_tree : public basic_PQ_tree {\n  std::vector<int> fac;\n  int calc(node *u) {\n    if (u->son.empty()) {\n      return 1;\n    }\n    int res = u->type ? 2 : fac[u->son.size()];\n    for (auto v : u->son) {\n      res = 1ll * res * calc(v) % P;\n    }\n    return res;\n  }\n\n public:\n  PQ_tree(int _n) : basic_PQ_tree(_n), fac(n + 1) {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      fac[i] = 1ll * fac[i - 1] * i % P;\n    }\n  }\n  int get_ans() { return valid() ? calc(rt) : 0; }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  PQ_tree<998244353> pq(n);\n  for (int i = 0; i < m; ++i) {\n    int q;\n    cin >> q;\n    vector<int> a(q);\n    for (int it = 0; it < q; ++it) {\n      cin >> a[it];\n      a[it]--;\n    }\n    pq.insert(a);\n  }\n  cout << pq.get_ans() << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint sub(int a, int b) {\n  int s = a - b;\n  s %= mod;\n  if (s < 0) s += mod;\n  return s;\n}\nint sum(int a, int b) {\n  int s = a + b;\n  if (s >= mod) s -= mod;\n  return s;\n}\nint mult(int a, int b) { return (1LL * a * b) % mod; }\nconst int N = 105;\nconst int M = N * N;\nint type[M];\nvector<int> go[M];\nint tsz, root;\nint color[M];\nvoid init(int n) {\n  if (n == 1) {\n    root = tsz = 1;\n  } else {\n    root = tsz = n + 1;\n    type[root] = 1;\n    for (int i = 1; i <= n; i++) go[root].push_back(i);\n  }\n}\nchar *s;\nvoid Paint(int u) {\n  if (type[u] == 0) {\n    color[u] = s[u] == '1' ? 2 : 1;\n  } else {\n    color[u] = 0;\n    for (int v : go[u]) {\n      Paint(v);\n      color[u] |= color[v];\n    }\n  }\n}\nint Merge(vector<int> nodes) {\n  if (nodes.empty()) return 0;\n  if (nodes.size() == 1) return nodes[0];\n  int node = ++tsz;\n  type[node] = 1;\n  go[node] = nodes;\n  return node;\n}\nbool ok = true;\nint Solve(int u, int t) {\n  if (!ok) return 0;\n  if (color[u] != 3) return u;\n  vector<int> ch[3];\n  for (int v : go[u]) ch[color[v] - 1].push_back(v);\n  if (ch[2].size() > 2 || (t > 0 && ch[2].size() > 1)) {\n    ok = false;\n    return 0;\n  }\n  if (type[u] == 1) {\n    if (t == 0) {\n      go[u] = ch[0];\n      if (ch[2].size() == 2 || (ch[2].size() > 0 && ch[1].size() > 0)) {\n        int Q = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        int b = Merge(ch[1]);\n        if (b) go[Q].push_back(b);\n        if (ch[2].size() > 1) {\n          int q = Solve(ch[2][1], 2);\n          if (!ok) return 0;\n          for (int v : go[q]) go[Q].push_back(v);\n        }\n        go[u].push_back(Q);\n      } else if (ch[2].size() == 1) {\n        int Q = Solve(ch[2][0], 0);\n        if (!ok) return 0;\n        go[u].push_back(Q);\n      } else {\n        int b = Merge(ch[1]);\n        if (b) go[u].push_back(b);\n      }\n    } else {\n      type[u] = 2;\n      go[u].clear();\n      int w = Merge(ch[0]);\n      if (w) go[u].push_back(w);\n      if (ch[2].size()) {\n        int g = Solve(ch[2][0], 1);\n        if (!ok) return 0;\n        for (int v : go[g]) go[u].push_back(v);\n      }\n      int b = Merge(ch[1]);\n      if (b) go[u].push_back(b);\n      if (t == 2) reverse(go[u].begin(), go[u].end());\n    }\n    if (go[u].size() == 1) return go[u][0];\n    return u;\n  } else {\n    string pattern = t == 0 ? \"wgbgw\" : \"wgb\";\n    int ptr = 0;\n    if (color[go[u][0]] == 2 || color[go[u].back()] == 1)\n      reverse(go[u].begin(), go[u].end());\n    vector<int> ngo;\n    bool strict =\n        t != 0 || ch[2].size() > 1 || (ch[2].size() > 0 && ch[1].size() > 0);\n    for (int v : go[u]) {\n      char col = color[v] == 1 ? 'w' : color[v] == 2 ? 'b' : 'g';\n      while (ptr < pattern.size() && pattern[ptr] != col) ptr++;\n      if (ptr == pattern.size()) {\n        ok = false;\n        return 0;\n      }\n      if (color[v] != 3) {\n        ngo.push_back(v);\n      } else {\n        int Q;\n        if (!strict)\n          Q = Solve(v, 0);\n        else if (ptr == 1)\n          Q = Solve(v, 1);\n        else\n          Q = Solve(v, 2);\n        if (!ok) return 0;\n        if (!strict)\n          ngo.push_back(Q);\n        else\n          for (int h : go[Q]) ngo.push_back(h);\n        ptr++;\n      }\n    }\n    go[u] = ngo;\n    if (t == 2) reverse(go[u].begin(), go[u].end());\n    return u;\n  }\n}\nvoid AddSet(char *t) {\n  if (!ok) return;\n  s = t;\n  Paint(root);\n  root = Solve(root, 0);\n}\nvoid Print(int u) {\n  if (type[u] == 0) {\n    printf(\"%i \", u);\n  } else {\n    if (type[u] == 1) {\n      printf(\"P{ \");\n    } else\n      printf(\"Q[ \");\n    for (int v : go[u]) Print(v);\n    if (type[u] == 1) {\n      printf(\"} \");\n    } else\n      printf(\"] \");\n  }\n}\nvector<int> ord;\nint ANS = 1;\nchar mat[N][N];\nint fact[N];\nvoid DFS(int u) {\n  if (type[u] == 0) {\n    ord.push_back(u);\n  } else {\n    if (type[u] == 1)\n      ANS = mult(ANS, fact[go[u].size()]);\n    else\n      ANS = mult(ANS, 2);\n    for (int v : go[u]) DFS(v);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  if (n == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) fact[i] = mult(i, fact[i - 1]);\n  init(n);\n  for (int i = 1; i <= m; i++) {\n    int sz;\n    cin >> sz;\n    for (int j = 1; j <= n; j++) mat[i][j] = '0';\n    for (int j = 1; j <= sz; j++) {\n      int x;\n      cin >> x;\n      mat[i][x] = '1';\n    }\n    AddSet(mat[i]);\n  }\n  if (!ok) {\n    cout << 0 << '\\n';\n  } else {\n    DFS(root);\n    cout << ANS << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[128];\nlong long fp(long long a, long long n, long long mod = 998244353) {\n  if (n < 0) a = fp(a, mod - 2, mod), n = -n;\n  long long res = 1;\n  for (; n; n >>= 1, a = a * a % mod)\n    if (n & 1) res = res * a % mod;\n  return res;\n}\nconst int maxn = (int)2e5 + 20;\nconst int maxm = (int)1e6 + 20;\nconst int N = 500 + 5;\nstruct PQ_tree {\n  int n, tot;\n  int fail;\n  vector<int> G[N << 2];\n  int ty[N << 2];\n  int sz[N << 2];\n  int szc[N << 2];\n  bool s[N];\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(vector<int> &vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G[++tot] = vec;\n    return tot;\n  }\n  void init(int _n) {\n    n = _n;\n    tot = n + 1;\n    memset(ty, 0, sizeof(ty));\n    for (int i = 1; i <= n; i++) G[n + 1].push_back(i);\n    fail = 0;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      } else {\n        ty[u] = 1;\n        G[u].clear();\n        addson(u, p2);\n        if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n        addson(u, mergeP(vec[0]));\n        if (t == 2) reverse(G[u].begin(), G[u].end());\n      }\n      return u;\n    } else {\n      if (getstate(G[u].front()) > getstate(G[u].back()))\n        reverse(G[u].begin(), G[u].end());\n      int flag = 0;\n      vector<int> tG;\n      for (auto v : G[u]) {\n        int sta = getstate(v);\n        if (sta == 0) {\n          if (flag == 1) flag = 2;\n          tG.push_back(v);\n        } else if (sta == 2) {\n          if (flag == 0)\n            flag = 1;\n          else if (flag == 2)\n            return fail = 2, 0;\n          tG.push_back(v);\n        } else {\n          int p1;\n          if (flag == 0)\n            flag = 1, p1 = check(v, 2);\n          else if (flag == 1)\n            flag = 2, p1 = check(v, 1);\n          else\n            return fail = 3, 0;\n          for (auto x : G[v]) tG.push_back(x);\n        }\n      }\n      if (t && flag == 2) return fail = 4, 0;\n      if (t == 1) reverse(tG.begin(), tG.end());\n      G[u] = tG;\n      return u;\n    }\n  }\n  int res;\n  void dfs_permutation(int u) {\n    if (u <= n) {\n      return;\n    }\n    if (!ty[u]) {\n      res = (long long)res * fac[G[u].size()] % 998244353;\n    } else if (G[u].size() != 1) {\n      res = (long long)res * 2 % 998244353;\n    }\n    for (auto v : G[u]) {\n      dfs_permutation(v);\n    }\n  }\n  int get_permutation() {\n    res = 1;\n    dfs_permutation(n + 1);\n    return res;\n  }\n  void restrict(vector<int> res) {\n    for (int i = 1; i <= n; i++) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nint main() {\n  fac[0] = 1;\n  int i;\n  for (i = (1); i < (128); i++) fac[i] = (fac[i - 1] * i) % 998244353;\n  int n, m;\n  cin >> n >> m;\n  PQ_tree *pq = new PQ_tree;\n  pq->init(n);\n  for (i = (0); i < (m); i++) {\n    vector<int> res;\n    int amt;\n    cin >> amt;\n    int j;\n    for (j = (0); j < (amt); j++) {\n      int a;\n      cin >> a;\n      res.push_back(a);\n    }\n    pq->restrict(res);\n  }\n  if (pq->fail) {\n    cout << 0;\n  } else\n    cout << pq->get_permutation();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, fac[1010];\nclass PQ_Tree {\n private:\n  int n;\n\n public:\n  struct node {\n    vector<int> son;\n    int type, op;\n  } t[1010 << 1];\n  int tot, rt;\n  bool OK;\n  bitset<1010> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; ++i) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n) return (void)(t[u].op = vis[u] ? 2 : 1);\n    t[u].op = 0;\n    for (auto v : t[u].son) {\n      dfs1(v);\n      t[u].op |= t[v].op;\n    }\n  }\n  inline int GT(int u) { return t[u].op == 1 ? 0 : (t[u].op == 2 ? 2 : 1); }\n  void dfs2(int u, int lim) {\n    if (!OK || t[u].op ^ 3) return;\n    vector<int> a[3];\n    for (auto v : t[u].son) {\n      a[GT(v)].push_back(v);\n    }\n    if ((lim > 0) + a[1].size() >= 3) {\n      OK = false;\n    }\n    if (!lim && (a[1].size() + a[2].size()) <= 1) {\n      if (!a[1].empty()) dfs2(a[1][0], 0);\n      if (!a[2].empty()) dfs2(a[2][0], 0);\n      return;\n    }\n    if (t[u].type) {\n      int now = 0;\n      vector<int> S;\n      if (GT(t[u].son[0]) == 2 || !GT(t[u].son.back())) {\n        reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (auto v : t[u].son) {\n        int Type = GT(v);\n        if (Type == 0) {\n          S.push_back(v);\n          now += now == 1;\n        } else if (Type == 1) {\n          if (now == 2) OK = false;\n          ++now;\n          dfs2(v, 3 - now);\n          S.insert(S.end(), t[v].son.begin(), t[v].son.end());\n        } else {\n          S.push_back(v);\n          now += !now;\n          if (now == 2) OK = false;\n        }\n      }\n      if (lim && now == 2) OK = false;\n      if (lim == 1) reverse(S.begin(), S.end());\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1)\n        z = a[2][0];\n      else if (a[2].size() > 1)\n        z = ++tot, t[z].type = 0, t[z].son = a[2];\n      vector<int> S;\n      if (!a[1].empty()) {\n        dfs2(a[1][0], 2);\n        S.insert(S.end(), t[a[1][0]].son.begin(), t[a[1][0]].son.end());\n      }\n      if (~z) S.push_back(z);\n      if (a[1].size() > 1) {\n        dfs2(a[1][1], 1);\n        S.insert(S.end(), t[a[1][1]].son.begin(), t[a[1][1]].son.end());\n      }\n      if (a[0].empty()) {\n        if (lim == 1) reverse(S.begin(), S.end());\n        t[u].type = 1, t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[0][0];\n          if (a[0].size() > 1) {\n            z = ++tot, t[z].type = 0, t[z].son = a[0];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = S[0];\n          if (S.size() > 1) z = ++tot, t[z].son = S, t[z].type = 1;\n          t[u].son = a[0], t[u].son.push_back(z);\n        }\n      }\n    }\n  }\n  bool Insert(const bitset<1010> &B) {\n    vis = B;\n    dfs1(rt);\n    OK = true;\n    dfs2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (auto v : t[u].son) ans = 1LL * ans * calc(v) % mod;\n    return ans;\n  }\n} T;\nint main() {\n  n = read(), m = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  T.init(n);\n  while (m--) {\n    static bitset<1010> B;\n    B.reset();\n    int k = read();\n    while (k--) B[read()] = 1;\n    if (!T.Insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = (int)1e3 + 9, maxm = (int)1e6 + 9;\nconst int maxc = 26, maxd = 10;\nconst int mod = 998244353, INF = 0x3f3f3f3f;\nconst long long INFLL = (long long)INF << 32 | INF;\nconst double eps = (double)1e-12, pi = acos((double)-1);\ninline int sgn(double x) { return (x > eps) - (x < -eps); }\ninline bool is_prime(int x) {\n  if (x <= 2 || !(x & 1)) return x == 2;\n  for (int i = 3; i * i <= x; i += 2)\n    if (x % i == 0) return 0;\n  return 1;\n}\ninline long long mod_mul(long long x, long long y, long long mod) {\n  long long ret = x * y - (long long)((long double)x * y / mod + 1e-3) * mod;\n  for (; ret < 0; ret += mod)\n    ;\n  return ret;\n}\ninline long long mod_pow(long long x, long long k, long long mod) {\n  long long ret = mod > 1 ? 1 : 0;\n  for (; k > 0; k >>= 1, x = mod_mul(x, x, mod))\n    if (k & 1) ret = mod_mul(ret, x, mod);\n  return ret;\n}\nclass PQTree {\n private:\n  bool failed;\n  int n, tot, rt, typ[maxn];\n  vector<int> sub[maxn];\n  int newNode() {\n    typ[++tot] = 0;\n    vector<int>().swap(sub[tot]);\n    return tot;\n  }\n  int newP(vector<int> &vec) {\n    if (vec.empty()) return 0;\n    if (vec.size() == 1) return vec.back();\n    int u = newNode();\n    sub[u] = vec;\n    idx[u] = 0;\n    return u;\n  }\n  void addChild(int u, int v) {\n    if (v) sub[u].push_back(v);\n  }\n  void mergeSub(int u, int v) {\n    sub[u].insert(sub[u].end(), sub[v].begin(), sub[v].end());\n  }\n  int sz[maxn], ctr[maxn], idx[maxn];\n  int getID(int u) { return ctr[u] ? (ctr[u] < sz[u] ? 1 : 2) : 0; }\n  void dfs(int u, vector<bool> &row) {\n    sz[u] = u <= n;\n    ctr[u] = u <= n && row[u];\n    for (int v : sub[u]) {\n      dfs(v, row);\n      sz[u] += sz[v];\n      ctr[u] += ctr[v];\n    }\n    idx[u] = ctr[u] ? (ctr[u] < sz[u] ? 1 : 2) : 0;\n  }\n  int solve(int u, int uid) {\n    if (failed) return 0;\n    vector<int> vec[3];\n    for (int v : sub[u]) vec[idx[v]].push_back(v);\n    if (vec[1].size() > 2 || (uid > 0 && vec[1].size() > 1)) {\n      failed = 1;\n      return 0;\n    }\n    if (!uid && vec[1].size() == 1 && vec[2].empty())\n      return solve(vec[1].back(), 0);\n    if (!typ[u]) {\n      int p2 = newP(vec[2]);\n      if (!uid) {\n        sub[u] = vec[0];\n        if (vec[1].empty()) {\n          addChild(u, p2);\n        } else {\n          int p1 = solve(vec[1].front(), 1);\n          addChild(p1, p2);\n          if (vec[1].size() == 2) mergeSub(p1, solve(vec[1].back(), 2));\n          addChild(u, p1);\n        }\n      } else {\n        typ[u] = 1;\n        vector<int>().swap(sub[u]);\n        addChild(u, newP(vec[0]));\n        if (vec[1].size() == 1) mergeSub(u, solve(vec[1].back(), 1));\n        addChild(u, p2);\n        if (uid == 2) reverse(sub[u].begin(), sub[u].end());\n      }\n      return u;\n    }\n    if (idx[sub[u].front()] == 2 || idx[sub[u].back()] == 0)\n      reverse(sub[u].begin(), sub[u].end());\n    int cnt = 0;\n    vector<int> tmp;\n    tmp.swap(sub[u]);\n    for (int v : tmp)\n      if (!idx[v]) {\n        addChild(u, v);\n        if (cnt == 1) ++cnt;\n      } else if (idx[v] == 1) {\n        if (cnt > 1) {\n          failed = 1;\n          return 0;\n        }\n        int p1 = solve(v, ++cnt);\n        mergeSub(u, p1);\n      } else {\n        if (cnt > 1) {\n          failed = 1;\n          return 0;\n        }\n        if (!cnt) ++cnt;\n        addChild(u, v);\n      }\n    if (uid > 0 && cnt == 2) {\n      failed = 1;\n      return 0;\n    }\n    if (uid == 2) reverse(sub[u].begin(), sub[u].end());\n    return u;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ret = 1, deg = 0;\n    for (int v : sub[u]) {\n      ret = (long long)ret * calc(v) % mod;\n      ++deg;\n    }\n    if (!typ[u]) {\n      for (int i = 2; i <= deg; ++i) ret = (long long)ret * i % mod;\n    } else if (deg > 1) {\n      (ret <<= 1) %= mod;\n    }\n    return ret;\n  }\n\n public:\n  void init(int n) {\n    tot = failed = 0;\n    this->n = n;\n    for (int i = 1; i <= n; ++i) newNode();\n    rt = newNode();\n    for (int i = 1; i <= n; ++i) sub[rt].push_back(i);\n  }\n  bool apply(vector<bool> &row) {\n    dfs(rt, row);\n    solve(rt, 0);\n    return failed;\n  }\n  int count() { return failed ? 0 : calc(rt); }\n} T;\nvoid solve() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  T.init(n);\n  for (int i = 0; i < m; ++i) {\n    vector<bool> row(n + 1);\n    int sz, x;\n    scanf(\"%d\", &sz);\n    while (sz--) {\n      scanf(\"%d\", &x);\n      row[x] = 1;\n    }\n    T.apply(row);\n  }\n  printf(\"%d\\n\", T.count());\n}\nint main() {\n  int T = 1;\n  for (int Case = 1; Case <= T; ++Case) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class I {\n\n\tstatic final int MOD = 998244353;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic List<Item> pair(Item a, Item b) {\n\t\tList<Item> res = new ArrayList<>();\n\t\tres.add(a);\n\t\tres.add(b);\n\t\treturn res;\n\t}\n\n\tstatic abstract class Item {\n\n\t\tboolean haveIn, haveOut;\n\t\tabstract void processPresence(List<Integer> elements);\n\t\tabstract Item process(int bound);\n\t\tabstract int count();\n\t}\n\n\tstatic class Person extends Item {\n\t\tfinal int index;\n\n\t\tPerson(int index) {\n\t\t\tthis.index = index;\n\t\t}\n\n\t\tvoid processPresence(List<Integer> elements) {\n\t\t\tboolean have = false;\n\t\t\tfor (int i: elements) {\n\t\t\t\tif (i == index) {\n\t\t\t\t\thave = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\thaveIn = have;\n\t\t\thaveOut = !have;\n\t\t}\n\n\t\tItem process(int bound) {\n\t\t\treturn this;\n\t\t}\n\n\t\tint count() {\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn Integer.toString(index);\n\t\t}\n\t}\n\n\tstatic abstract class MultiItem extends Item {\n\t\tfinal List<Item> contents;\n\n\t\tMultiItem(List<Item> contents) {\n\t\t\tthis.contents = contents;\n\t\t}\n\n\t\tvoid processPresence(List<Integer> elements) {\n\t\t\thaveIn = haveOut = false;\n\t\t\tfor (Item i: contents) {\n\t\t\t\ti.processPresence(elements);\n\t\t\t\thaveIn |= i.haveIn;\n\t\t\t\thaveOut |= i.haveOut;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Group extends MultiItem {\n\n\t\tGroup(List<Item> contents) {\n\t\t\tsuper(contents);\n\t\t}\n\n\t\tstatic Item make(List<Item> items) {\n\t\t\treturn items.size() == 1 ? items.get(0) : new Group(items);\n\t\t}\n\n\t\tItem process(int bound) {\n\t\t\tList<Item> full = new ArrayList<>(), partial = new ArrayList<>(), none = new ArrayList<>();\n\t\t\tfor (Item i: contents) {\n\t\t\t\tif (i.haveIn) {\n\t\t\t\t\tif (i.haveOut) {\n\t\t\t\t\t\tpartial.add(i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfull.add(i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnone.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (partial.size()) {\n\t\t\tcase 0:\n\t\t\t{\n\t\t\t\tif (full.isEmpty() || none.isEmpty()) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tItem fullItem = Group.make(full);\n\t\t\t\tif (bound == 0) {\n\t\t\t\t\tnone.add(fullItem);\n\t\t\t\t\treturn new Group(none);\n\t\t\t\t} else {\n\t\t\t\t\tItem noneItem = Group.make(none);\n\t\t\t\t\treturn new Sequence(bound > 0 ? pair(fullItem, noneItem) : pair(noneItem, fullItem));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tItem p = partial.get(0);\n\t\t\t\tif (bound == 0) {\n\t\t\t\t\tif (full.isEmpty()) {\n\t\t\t\t\t\tp = p.process(0);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnone.add(p);\n\t\t\t\t\t\treturn new Group(none);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = p.process(1);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<Item> pi = new ArrayList<>(((Sequence) p).contents);\n\t\t\t\t\t\tpi.add(0, Group.make(full));\n\t\t\t\t\t\tnone.add(new Sequence(pi));\n\t\t\t\t\t\treturn Group.make(none);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = p.process(bound);\n\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tList<Item> res = new ArrayList<>();\n\t\t\t\t\tif (!full.isEmpty()) {\n\t\t\t\t\t\tres.add(Group.make(full));\n\t\t\t\t\t}\n\t\t\t\t\tList<Item> els = ((Sequence) p).contents;\n\t\t\t\t\tif (bound > 0) {\n\t\t\t\t\t\tres.addAll(els);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addAll(0, els);\n\t\t\t\t\t}\n\t\t\t\t\tif (!none.isEmpty()) {\n\t\t\t\t\t\tif (bound > 0) {\n\t\t\t\t\t\t\tres.add(Group.make(none));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres.add(0, Group.make(none));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Sequence(res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tif (bound != 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tItem p1 = partial.get(0).process(-1), p2 = partial.get(1).process(1);\n\t\t\t\tif (p1 == null || p2 == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tList<Item> sres = new ArrayList<>();\n\t\t\t\tsres.addAll(((Sequence) p1).contents);\n\t\t\t\tif (!full.isEmpty()) {\n\t\t\t\t\tsres.add(Group.make(full));\n\t\t\t\t}\n\t\t\t\tsres.addAll(((Sequence) p2).contents);\n\t\t\t\tnone.add(new Sequence(sres));\n\t\t\t\treturn Group.make(none);\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint count() {\n\t\t\tint res = 1;\n\t\t\tfor (int i = 0; i < contents.size(); i++) {\n\t\t\t\tres = mul(mul(res, i + 1), contents.get(i).count());\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('{');\n\t\t\tfor (int i = 0; i < contents.size(); i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tsb.append(\", \");\n\t\t\t\t}\n\t\t\t\tsb.append(contents.get(i).toString());\n\t\t\t}\n\t\t\tsb.append('}');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tstatic class Sequence extends MultiItem {\n\n\t\tSequence(List<Item> contents) {\n\t\t\tsuper(contents);\n\t\t}\n\n\t\tItem process(int bound) {\n\t\t\tList<Item> els = new ArrayList<>(contents);\n\t\t\tint n = els.size();\n\t\t\tint p1 = 0;\n\t\t\twhile (p1 < n && !els.get(p1).haveIn) {\n\t\t\t\t++p1;\n\t\t\t}\n\t\t\tint p2 = p1;\n\t\t\twhile (p2 < n && els.get(p2).haveIn) {\n\t\t\t\t++p2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tItem ii = els.get(i);\n\t\t\t\tif (ii.haveIn != (i >= p1 && i < p2)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (i > p1 && i < p2 - 1 && ii.haveOut) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!els.get(p1).haveOut && !els.get(p2 - 1).haveOut && (p1 == 0 || bound <= 0) && (p2 == n || bound >= 0)) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (p2 == p1 + 1) {\n\t\t\t\tif (bound == 0) {\n\t\t\t\t\tItem ni = els.get(p1).process(0);\n\t\t\t\t\tif (ni == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tels.set(p1, ni);\n\t\t\t\t\treturn new Sequence(els);\n\t\t\t\t} else if (p1 != 0 && p1 != n - 1) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tif ((p1 == 0) != (bound > 0)) {\n\t\t\t\t\t\tCollections.reverse(els);\n\t\t\t\t\t\tp1 = n - p1 - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (els.get(p1).haveOut) {\n\t\t\t\t\t\tItem ni = els.get(p1).process(bound);\n\t\t\t\t\t\tif (ni == null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tels.remove(p1);\n\t\t\t\t\t\tels.addAll(p1, ((Sequence) ni).contents);\n\t\t\t\t\t}\n\t\t\t\t\treturn new Sequence(els);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bound != 0) {\n\t\t\t\tboolean bad1 = p1 > 0 || els.get(p1).haveOut;\n\t\t\t\tboolean bad2 = p2 < n || els.get(p2 - 1).haveOut;\n\t\t\t\tif (bad1 && bad2) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ((bound > 0 && bad1) || (bound < 0 && bad2)) {\n\t\t\t\t\tCollections.reverse(els);\n\t\t\t\t\tint t = p1;\n\t\t\t\t\tp1 = n - p2;\n\t\t\t\t\tp2 = n - t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (els.get(p1).haveOut) {\n\t\t\t\tItem ni = els.get(p1).process(-1);\n\t\t\t\tif (ni == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tels.remove(p1);\n\t\t\t\tels.addAll(p1, ((Sequence) ni).contents);\n\t\t\t\tp2 += ((Sequence) ni).contents.size() - 1;\n\t\t\t}\n\t\t\tif (els.get(p2 - 1).haveOut) {\n\t\t\t\tItem ni = els.get(p2 - 1).process(1);\n\t\t\t\tif (ni == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tels.remove(p2 - 1);\n\t\t\t\tels.addAll(p2 - 1, ((Sequence) ni).contents);\n\t\t\t}\n\t\t\treturn new Sequence(els);\n\t\t}\n\n\t\tint count() {\n\t\t\tint res = 2;\n\t\t\tfor (int i = 0; i < contents.size(); i++) {\n\t\t\t\tres = mul(res, contents.get(i).count());\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('[');\n\t\t\tfor (int i = 0; i < contents.size(); i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tsb.append(\", \");\n\t\t\t\t}\n\t\t\t\tsb.append(contents.get(i).toString());\n\t\t\t}\n\t\t\tsb.append(']');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt(), m = scanInt();\n\t\tList<Item> preRoot = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreRoot.add(new Person(i));\n\t\t}\n\t\tItem root = Group.make(preRoot);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tList<Integer> cur = new ArrayList<>();\n\t\t\tint q = scanInt();\n\t\t\tfor (int j = 0; j < q; j++) {\n\t\t\t\tcur.add(scanInt() - 1);\n\t\t\t}\n\t\t\troot.processPresence(cur);\n\t\t\troot = root.process(0);\n\t\t\tif (root == null) {\n\t\t\t\tout.print(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.print(root.count());\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2, 3, \"Ofast\")\n#pragma GCC target(\"avx\", \"avx2\")\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid ckmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid ckmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int mod = 998244353;\nint n, m, fac[1010];\nclass PQ_Tree {\n private:\n  int n;\n\n public:\n  struct node {\n    vector<int> son;\n    int type, op;\n  } t[1010 << 1];\n  int tot, rt;\n  bool OK;\n  bitset<1010> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; ++i) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n) return (void)(t[u].op = vis[u] ? 2 : 1);\n    t[u].op = 0;\n    for (auto v : t[u].son) {\n      dfs1(v);\n      t[u].op |= t[v].op;\n    }\n  }\n  void dfs2(int u, int lim) {\n    if (!OK || t[u].op ^ 3) return;\n    vector<int> a[4];\n    for (auto v : t[u].son) {\n      a[t[v].op].push_back(v);\n    }\n    if ((lim > 0) + a[3].size() >= 3) {\n      OK = false;\n    }\n    if (!lim && (a[2].size() + a[3].size()) <= 1) {\n      if (!a[2].empty()) dfs2(a[2][0], 0);\n      if (!a[3].empty()) dfs2(a[3][0], 0);\n      return;\n    }\n    if (t[u].type) {\n      int now = 0;\n      vector<int> S;\n      if (t[t[u].son[0]].op == 2 || t[t[u].son.back()].op == 1) {\n        reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (auto v : t[u].son) {\n        if (t[v].op == 1) {\n          S.push_back(v);\n          now += now == 1;\n        } else if (t[v].op == 2) {\n          S.push_back(v);\n          now += !now;\n          if (now == 2) OK = false;\n        } else {\n          if (now == 2) OK = false;\n          ++now;\n          dfs2(v, 3 - now);\n          S.insert(S.end(), t[v].son.begin(), t[v].son.end());\n        }\n      }\n      if (lim && now == 2) OK = false;\n      if (lim == 1) reverse(S.begin(), S.end());\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1)\n        z = a[2][0];\n      else if (a[2].size() > 1)\n        z = ++tot, t[z].type = 0, t[z].son = a[2];\n      vector<int> S;\n      if (!a[3].empty()) {\n        dfs2(a[3][0], 2);\n        S.insert(S.end(), t[a[3][0]].son.begin(), t[a[3][0]].son.end());\n      }\n      if (~z) S.push_back(z);\n      if (a[3].size() > 1) {\n        dfs2(a[3][1], 1);\n        S.insert(S.end(), t[a[3][1]].son.begin(), t[a[3][1]].son.end());\n      }\n      if (a[1].empty()) {\n        if (lim == 1) reverse(S.begin(), S.end());\n        t[u].type = 1, t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[1][0];\n          if (a[1].size() > 1) {\n            z = ++tot, t[z].type = 0, t[z].son = a[1];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = S[0];\n          if (S.size() > 1) z = ++tot, t[z].son = S, t[z].type = 1;\n          t[u].son = a[1], t[u].son.push_back(z);\n        }\n      }\n    }\n  }\n  bool Insert(const bitset<1010> &B) {\n    vis = B;\n    dfs1(rt);\n    OK = true;\n    dfs2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) return 1;\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (auto v : t[u].son) ans = 1LL * ans * calc(v) % mod;\n    return ans;\n  }\n} T;\nint main() {\n  n = read(), m = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  T.init(n);\n  while (m--) {\n    static bitset<1010> B;\n    B.reset();\n    int k = read();\n    while (k--) B[read()] = 1;\n    if (!T.Insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int MOD = 998244353;\nstruct Mint {\n  int val;\n  Mint() { val = 0; }\n  Mint(ll x) {\n    val = (-MOD <= x && x < MOD) ? x : x % MOD;\n    if (val < 0) val += MOD;\n  }\n  template <typename U>\n  explicit operator U() const {\n    return (U)val;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n  Mint& operator+=(const Mint& m) {\n    if ((val += m.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((val -= m.val) < 0) val += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    val = (ll)val * m.val % MOD;\n    return *this;\n  }\n  friend Mint modex(Mint a, ll p) {\n    assert(p >= 0);\n    Mint ans = 1;\n    for (; p; p >>= 1, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  Mint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  Mint operator++(int) {\n    Mint result(*this);\n    *this += 1;\n    return result;\n  }\n  Mint operator--(int) {\n    Mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  Mint operator-() const { return Mint(-val); }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n  friend string to_string(const Mint& b) { return to_string(b.val); }\n};\nvector<Mint> fac(1, 1), invfac(1, 1);\nMint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  while (fac.size() <= n) {\n    fac.push_back(fac.back() * fac.size());\n    invfac.push_back(1 / fac.back());\n  }\n  return fac[n] * invfac[k] * invfac[n - k];\n}\nconst int N = 500 + 5;\nstruct PqTree {\n  int n, tot;\n  int fail;\n  vector<int> G[N << 2];\n  int ty[N << 2];\n  int sz[N << 2];\n  int szc[N << 2];\n  bool s[N];\n  inline int getstate(int u) {\n    if (szc[u] == 0) return 0;\n    if (szc[u] == sz[u]) return 2;\n    return 1;\n  }\n  void addson(int x, int y) {\n    if (y) G[x].push_back(y);\n  }\n  void join(int x, int y) {\n    for (auto v : G[y]) G[x].push_back(v);\n  }\n  int mergeP(vector<int>& vec) {\n    if (vec.size() == 0) return 0;\n    if (vec.size() == 1) return vec[0];\n    G[++tot] = vec;\n    return tot;\n  }\n  void init(int _n) {\n    n = _n;\n    tot = n + 1;\n    memset(ty, 0, sizeof(ty));\n    for (int i = 1; i <= n; ++i) G[n + 1].push_back(i);\n    fail = 0;\n  }\n  void dfs(int u) {\n    sz[u] = u <= n;\n    szc[u] = u <= n && s[u];\n    for (auto v : G[u]) {\n      dfs(v);\n      sz[u] += sz[v];\n      szc[u] += szc[v];\n    }\n  }\n  int check(int u, int t) {\n    if (fail) return 0;\n    vector<int> vec[3];\n    for (auto v : G[u]) vec[getstate(v)].push_back(v);\n    if (vec[1].size() > 2 || (t && vec[1].size() > 1)) return fail = 1, 0;\n    if (t == 0 && vec[1].size() == 1 && vec[2].size() == 0)\n      return check(vec[1][0], 0);\n    if (ty[u] == 0) {\n      int p2 = mergeP(vec[2]);\n      if (t == 0) {\n        G[u] = vec[0];\n        if (vec[1].size() == 0)\n          addson(u, p2);\n        else {\n          int tmp1 = check(vec[1][0], 2);\n          addson(tmp1, p2);\n          if (vec[1].size() == 2) join(tmp1, check(vec[1][1], 1));\n          addson(u, tmp1);\n        }\n        return u;\n      }\n      ty[u] = 1;\n      G[u].clear();\n      addson(u, p2);\n      if (vec[1].size() == 1) join(u, check(vec[1][0], 1));\n      addson(u, mergeP(vec[0]));\n      if (t == 2) reverse(G[u].begin(), G[u].end());\n      return u;\n    }\n    if (getstate(G[u].front()) > getstate(G[u].back()))\n      reverse(G[u].begin(), G[u].end());\n    int flag = 0;\n    vector<int> tG;\n    for (auto v : G[u]) {\n      int sta = getstate(v);\n      if (sta == 0) {\n        if (flag == 1) flag = 2;\n        tG.push_back(v);\n      } else if (sta == 2) {\n        if (flag == 0)\n          flag = 1;\n        else if (flag == 2)\n          return fail = 2, 0;\n        tG.push_back(v);\n      } else {\n        if (flag == 0)\n          flag = 1, check(v, 2);\n        else if (flag == 1)\n          flag = 2, check(v, 1);\n        else\n          return fail = 3, 0;\n        for (auto x : G[v]) tG.push_back(x);\n      }\n    }\n    if (t && flag == 2) return fail = 4, 0;\n    if (t == 1) reverse(tG.begin(), tG.end());\n    G[u] = tG;\n    return u;\n  }\n  void dfsPermutation(int u, vector<int>& per) {\n    if (u <= n) per.push_back(u);\n    for (auto v : G[u]) dfsPermutation(v, per);\n  }\n  vector<int> getPermutation() {\n    vector<int> res;\n    dfsPermutation(n + 1, res);\n    return res;\n  }\n  Mint dfsCount(int u) {\n    if (u <= n) return 1;\n    Mint ret = 1;\n    if (!ty[u]) {\n      ret *= fac[G[u].size()];\n    } else if (G[u].size() != 1) {\n      ret *= 2;\n    }\n    for (auto v : G[u]) ret *= dfsCount(v);\n    return ret;\n  }\n  Mint countPermutations() {\n    binom(n, 0);\n    return dfsCount(n + 1);\n  }\n  void restrict(const vector<int>& res) {\n    for (int i = 1; i <= n; ++i) s[i] = 0;\n    for (auto x : res) s[x] = 1;\n    dfs(n + 1);\n    check(n + 1, 0);\n  }\n};\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  PqTree pq;\n  pq.init(n);\n  for (int i = 0; i < m; ++i) {\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> res;\n    while (q--) {\n      int s;\n      scanf(\"%d\", &s);\n      res.push_back(s);\n    }\n    pq.restrict(res);\n  }\n  if (pq.fail) {\n    printf(\"0\\n\");\n  } else {\n    Mint ans = pq.countPermutations();\n    printf(\"%d\\n\", ans.val);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rnd(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXSONG = 100;\nconst int MAXFRIEND = 100;\nconst int MOD = 998244353;\nint nsong, nfriend;\nvector<int> like[MAXFRIEND];\nconst int PERM = 0;\nconst int ORDERED = 1;\nconst int LEAF = 2;\nstruct Node {\n  int kind;\n  vector<Node*> childs;\n  vector<int> leafs;\n};\nNode* concat(vector<Node*> lst, int kind = PERM) {\n  vector<Node*> nlst;\n  for (Node* ch : lst)\n    if (ch != NULL) nlst.push_back(ch);\n  lst = nlst;\n  if (((int)(lst).size()) == 0) return NULL;\n  if (((int)(lst).size()) == 1) return lst[0];\n  auto ret = new Node();\n  ret->kind = kind;\n  for (Node* ch : lst) {\n    ret->childs.push_back(ch);\n    for (int x : ch->leafs) ret->leafs.push_back(x);\n  }\n  return ret;\n}\nvoid print(Node* at) {\n  if (at->kind == LEAF) {\n    printf(\"%d\", at->leafs[0] + 1);\n    return;\n  }\n  printf(\"%c\", at->kind == PERM ? '(' : '[');\n  for (int i = (0); i < (((int)(at->childs).size())); ++i) {\n    if (i != 0) printf(\",\");\n    print(at->childs[i]);\n  }\n  printf(\"%c\", at->kind == PERM ? ')' : ']');\n}\nNode* process(Node* at, set<int> like, bool mustprefix) {\n  if (at->kind == LEAF) {\n    assert(((int)(at->leafs).size()) == 1 && ((int)(like).size()) == 1 &&\n           like.count(at->leafs[0]) == 1);\n    return at;\n  }\n  vector<Node*> none;\n  vector<Node*> all;\n  vector<int> partial;\n  vector<set<int>> to(((int)(at->childs).size()));\n  int fst = INT_MAX, lst = INT_MIN;\n  for (int i = (0); i < (((int)(at->childs).size())); ++i) {\n    for (int x : at->childs[i]->leafs)\n      if (like.count(x)) to[i].insert(x);\n    if (((int)(to[i]).size()) != 0) fst = min(fst, i), lst = max(lst, i);\n    if (((int)(to[i]).size()) == 0)\n      none.push_back(at->childs[i]);\n    else if (((int)(to[i]).size()) == ((int)(at->childs[i]->leafs).size()))\n      all.push_back(at->childs[i]);\n    else\n      partial.push_back(i);\n  }\n  if (((int)(all).size()) == ((int)(at->childs).size())) return at;\n  assert(((int)(all).size()) + ((int)(partial).size()) >= 1);\n  if (((int)(partial).size()) >= 3) return NULL;\n  if (mustprefix && ((int)(partial).size()) >= 2) return NULL;\n  bool partialprefix =\n      mustprefix || ((int)(partial).size()) >= 2 || ((int)(all).size()) >= 1;\n  vector<Node*> partialnodes;\n  for (int idx : partial) {\n    Node* cur = process(at->childs[idx], to[idx], partialprefix);\n    if (cur == NULL) return NULL;\n    partialnodes.push_back(cur);\n  }\n  Node* ret;\n  if (at->kind == PERM) {\n    Node* allnode = concat(all);\n    if (mustprefix) {\n      Node* nonenode = concat(none);\n      vector<Node*> lst;\n      lst.push_back(allnode);\n      if (((int)(partial).size()) == 1)\n        for (auto x : partialnodes[0]->childs) lst.push_back(x);\n      lst.push_back(nonenode);\n      ret = concat(lst, ORDERED);\n    } else {\n      if (((int)(partial).size()) >= 2)\n        reverse(partialnodes[0]->childs.begin(), partialnodes[0]->childs.end());\n      vector<Node*> withlst;\n      Node* with;\n      if (partialprefix) {\n        if (((int)(partial).size()) >= 2)\n          for (auto x : partialnodes[0]->childs) withlst.push_back(x);\n        withlst.push_back(allnode);\n        if (((int)(partial).size()) >= 1)\n          for (auto x :\n               partialnodes[((int)(partial).size()) >= 2 ? 1 : 0]->childs)\n            withlst.push_back(x);\n        with = concat(withlst, ORDERED);\n      } else {\n        assert(((int)(partial).size()) == 1 && ((int)(all).size()) == 0);\n        with = partialnodes[0];\n      }\n      vector<Node*> lst;\n      lst.push_back(with);\n      for (auto x : none) lst.push_back(x);\n      ret = concat(lst);\n    }\n  } else {\n    assert(at->kind == ORDERED);\n    if (((int)(all).size()) + ((int)(partial).size()) != lst - fst + 1)\n      return NULL;\n    for (int i = (0); i < (((int)(partial).size())); ++i)\n      if (partial[i] != fst && partial[i] != lst) return NULL;\n    if (mustprefix) {\n      assert(((int)(partial).size()) <= 1);\n      if (fst != 0 || ((int)(partial).size()) == 1 &&\n                          ((int)(all).size()) >= 1 && partial[0] == 0) {\n        fst = ((int)(at->childs).size()) - 1 - fst,\n        lst = ((int)(at->childs).size()) - 1 - lst, swap(fst, lst);\n        reverse(none.begin(), none.end());\n        reverse(all.begin(), all.end());\n        reverse(partial.begin(), partial.end());\n        for (int i = (0); i < (((int)(partial).size())); ++i)\n          partial[i] = ((int)(at->childs).size()) - 1 - partial[i];\n        reverse(to.begin(), to.end());\n        reverse(at->childs.begin(), at->childs.end());\n      }\n      if (fst != 0 || ((int)(partial).size()) == 1 &&\n                          ((int)(all).size()) >= 1 && partial[0] == 0)\n        return NULL;\n    }\n    if (((int)(partial).size()) == 0) {\n      ret = at;\n    } else {\n      for (int i = (0); i < (((int)(partial).size())); ++i)\n        if (partial[i] != lst && partial[i] == fst)\n          reverse(partialnodes[i]->childs.begin(),\n                  partialnodes[i]->childs.end());\n      vector<Node*> lst;\n      for (int i = (0); i < (((int)(at->childs).size())); ++i) {\n        bool done = false;\n        for (int j = (0); j < (((int)(partial).size())); ++j)\n          if (!done && i == partial[j]) {\n            done = true;\n            if (!partialprefix)\n              lst.push_back(partialnodes[j]);\n            else\n              for (auto x : partialnodes[j]->childs) lst.push_back(x);\n          }\n        if (!done) lst.push_back(at->childs[i]);\n      }\n      ret = concat(lst, ORDERED);\n    }\n  }\n  return ret;\n}\nint fac[MAXSONG + 1];\nint calc(Node* at) {\n  int ret = 1;\n  for (Node* ch : at->childs) ret = (long long)ret * calc(ch) % MOD;\n  if (at->kind == ORDERED) ret = (long long)ret * 2 % MOD;\n  if (at->kind == PERM)\n    ret = (long long)ret * fac[((int)(at->childs).size())] % MOD;\n  return ret;\n}\nint solve() {\n  fac[0] = 1;\n  for (int i = (1); i <= (nsong); ++i) fac[i] = (long long)fac[i - 1] * i % MOD;\n  Node* root = new Node();\n  root->kind = PERM;\n  for (int i = (0); i < (nsong); ++i) {\n    Node* leaf = new Node();\n    leaf->kind = LEAF;\n    leaf->leafs.push_back(i);\n    root->childs.push_back(leaf);\n    root->leafs.push_back(i);\n  }\n  for (int i = (0); i < (nfriend); ++i) {\n    set<int> likeset(like[i].begin(), like[i].end());\n    root = process(root, likeset, false);\n    if (root == NULL) return 0;\n  }\n  return calc(root);\n}\nvoid run() {\n  scanf(\"%d%d\", &nsong, &nfriend);\n  for (int i = (0); i < (nfriend); ++i) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    like[i] = vector<int>(cnt);\n    for (int j = (0); j < (cnt); ++j) scanf(\"%d\", &like[i][j]), --like[i][j];\n  }\n  printf(\"%d\\n\", solve());\n}\nint solvestupid() {\n  vector<int> p;\n  for (int i = (0); i < (nsong); ++i) p.push_back(i);\n  int ret = 0;\n  do {\n    bool ok = true;\n    for (int i = (0); i < (nfriend); ++i) {\n      bool any = false;\n      bool last = false;\n      set<int> likeset(like[i].begin(), like[i].end());\n      for (int j = (0); j < (nsong); ++j) {\n        if (likeset.count(p[j])) {\n          if (!any)\n            any = true;\n          else if (!last)\n            ok = false;\n          last = true;\n        } else {\n          last = false;\n        }\n      }\n    }\n    if (ok) ++ret;\n  } while (next_permutation(p.begin(), p.end()));\n  return ret;\n}\nvoid stress() {\n  int mxsong = 8, mxfriend = 4;\n  for (int rep = (0); rep < (100000); ++rep) {\n    nsong = rnd() % mxsong + 1;\n    nfriend = rnd() % (mxfriend + 1);\n    for (int i = (0); i < (nfriend); ++i) {\n      like[i].clear();\n      int cnt = rnd() % nsong + 1;\n      long long mask = 0;\n      for (int j = (0); j < (cnt); ++j)\n        while (true) {\n          int idx = rnd() % nsong;\n          if (mask & (1LL << idx)) continue;\n          mask |= 1LL << idx;\n          like[i].push_back(idx);\n          break;\n        }\n    }\n    int have = solve();\n    int want = solvestupid();\n    if (have == want) {\n      if (rep % 1000 == 999) printf(\".\");\n      continue;\n    }\n    printf(\"have=%d want=%d\\n\", have, want);\n    printf(\"%d %d\\n\", nsong, nfriend);\n    for (int i = (0); i < (nfriend); ++i) {\n      printf(\"%d\", ((int)(like[i]).size()));\n      for (int x : like[i]) printf(\" %d\", x + 1);\n      puts(\"\");\n    }\n    break;\n  }\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint fac[105];\nint n, m;\nbitset<105> S[105], tmp, S1, T;\nvector<int> ss[105];\nint tot;\nvector<bitset<105>> ord[105];\nint uid[105];\nbool used[105];\nvector<pair<int, int>> e[105];\nint d[105];\nint qr, que[105];\nint sz[105];\nint ans = 1;\nbool checkl(int i) {\n  T.reset();\n  while (i >= 0) {\n    T.set(i--);\n    if (S1 == T) return 1;\n  }\n  return 0;\n}\nbool checkr(int i, int r) {\n  T.reset();\n  while (i < r) {\n    T.set(i++);\n    if (S1 == T) return 1;\n  }\n  return 0;\n}\nbool update(bitset<105> da, vector<bitset<105>> &ans) {\n  if (!ans.size()) {\n    ans.push_back(da);\n    return 1;\n  }\n  int cnt3 = 0;\n  S1.reset();\n  T.reset();\n  for (int j = 0; j < ans.size(); j++) {\n    uid[j] = 0;\n    tmp = da & ans[j];\n    if (tmp.any()) uid[j] = 1, S1.set(j);\n    if (tmp != ans[j]) uid[j] |= 2;\n    if (uid[j] == 3) cnt3++;\n  }\n  if (cnt3 > 2) return 0;\n  tmp = da;\n  for (auto j : ans) tmp ^= tmp & j;\n  if (cnt3 == 2) {\n    if (tmp.any()) return 0;\n    int l, r;\n    for (int j = 0; j < ans.size(); j++)\n      if (uid[j] == 3) {\n        l = j;\n        break;\n      }\n    for (int j = ans.size() - 1; j; j--)\n      if (uid[j] == 3) {\n        r = j;\n        break;\n      }\n    for (int j = l; j <= r; j++) T.set(j);\n    if (S1 != T) return 0;\n    tmp = ans[r] & da;\n    ans.insert(ans.begin() + r + 1, ans[r] ^ tmp);\n    ans.insert(ans.begin() + r + 1, tmp);\n    ans.erase(ans.begin() + r);\n    tmp = ans[l] & da;\n    ans.insert(ans.begin() + l + 1, tmp);\n    ans.insert(ans.begin() + l + 1, ans[l] ^ tmp);\n    ans.erase(ans.begin() + l);\n    return 1;\n  } else if (cnt3 == 1) {\n    int i;\n    for (i = 0; i < ans.size(); i++)\n      if (uid[i] == 3) break;\n    if (tmp.any()) {\n      for (int j = 0; j <= i; j++) T.set(j);\n      if (S1 == T) {\n        ans.insert(ans.begin() + i + 1, ans[i] ^ (ans[i] & da));\n        ans.insert(ans.begin() + i + 1, ans[i] & da);\n        ans.erase(ans.begin() + i);\n        ans.insert(ans.begin(), tmp);\n      } else {\n        T.reset();\n        for (int j = i; j < ans.size(); j++) T.set(j);\n        if (S1 == T) {\n          ans.push_back(tmp);\n          tmp = ans[i] & da;\n          ans.insert(ans.begin() + i + 1, tmp);\n          ans.insert(ans.begin() + i + 1, ans[i] ^ tmp);\n          ans.erase(ans.begin() + i);\n        } else\n          return 0;\n      }\n      return 1;\n    } else {\n      tmp = ans[i] & da;\n      if (checkl(i)) {\n        ans.insert(ans.begin() + i + 1, ans[i] ^ tmp);\n        ans.insert(ans.begin() + i + 1, tmp);\n        ans.erase(ans.begin() + i);\n      } else if (checkr(i, ans.size())) {\n        ans.insert(ans.begin() + i + 1, tmp);\n        ans.insert(ans.begin() + i + 1, ans[i] ^ tmp);\n        ans.erase(ans.begin() + i);\n      } else\n        return 0;\n      return 1;\n    }\n  } else {\n    if (!tmp.any()) {\n      int i;\n      for (i = 0; i < ans.size(); i++)\n        if (uid[i] == 1) break;\n      return checkr(i, ans.size());\n    }\n    if (checkl(ans.size() - 1))\n      ans.push_back(tmp);\n    else if (checkr(0, ans.size()))\n      ans.insert(ans.begin(), tmp);\n    else\n      return 0;\n    return 1;\n  }\n}\nvoid dfs(int u) {\n  used[u] = 1;\n  for (int i = 1; i <= m; i++) {\n    if (used[i]) continue;\n    tmp = S[u] & S[i];\n    if (tmp.any() && tmp != S[u] && tmp != S[i]) {\n      if (update(S[i], ord[tot]))\n        dfs(i);\n      else {\n        printf(\"0\\n\");\n        exit(0);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  m++;\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  for (int i = 1; i <= n; i++) S[1].set(i);\n  for (int i = 2, s; i <= m; i++) {\n    S[i].reset();\n    scanf(\"%d\", &s);\n    for (int j = 1, t; j <= s; j++) {\n      scanf(\"%d\", &t);\n      S[i].set(t);\n    }\n    for (int j = 1; j < i; j++)\n      if (S[i] == S[j]) {\n        i--;\n        m--;\n        break;\n      }\n  }\n  for (int i = 1; i <= m; i++)\n    if (!used[i]) {\n      if (update(S[i], ord[++tot]))\n        dfs(i);\n      else {\n        printf(\"0\\n\");\n        exit(0);\n      }\n    }\n  for (int i = 1; i <= tot; i++) {\n    S[i].reset();\n    for (auto j : ord[i]) S[i] |= j;\n  }\n  for (int i = 1; i <= tot; i++)\n    for (int j = 1; j <= tot; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < ord[j].size(); k++)\n        if ((ord[j][k] & S[i]) == S[i]) {\n          d[i]++;\n          e[j].push_back(make_pair(i, k));\n          break;\n        }\n    }\n  for (int i = 1; i <= tot; i++)\n    if (!d[i]) que[++qr] = i;\n  for (int i = 1; i <= qr; i++) {\n    int u = que[i];\n    if (ord[u].size() > 1) ans = (ans << 1) % mod;\n    for (int j = 0; j < ord[u].size(); j++) sz[j] = ord[u][j].count();\n    for (auto j : e[u]) {\n      d[j.first]--;\n      if (!d[j.first]) {\n        que[++qr] = j.first;\n        sz[j.second] -= S[j.first].count() - 1;\n      }\n    }\n    for (int j = 0; j < ord[u].size(); j++) ans = 1ll * ans * fac[sz[j]] % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class cfGlobal15I {\n\t\n\tstatic final int P = 998244353;\n\t\n\tstatic PQNode[] collect(PQNode[] arr, int whatStatus) {\n\t\tint sz = 0;\n\t\tfor (PQNode v : arr) {\n\t\t\tif (v.status == whatStatus) {\n\t\t\t\tsz++;\n\t\t\t}\n\t\t}\n\n\t\tPQNode[] ret = new PQNode[sz];\n\t\tint ptr = 0;\n\t\tfor (PQNode v : arr) {\n\t\t\tif (v.status == whatStatus) {\n\t\t\t\tret[ptr++] = v;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic PQNode makeNode(PQNode[] arr, int whatType) {\n\t\tif (arr.length == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (arr.length == 1) {\n\t\t\treturn arr[0];\n\t\t}\n\t\tif (arr.length == 2) {\n\t\t\twhatType = PQNode.Q_NODE;\n\t\t}\n\t\treturn new PQNode(whatType, arr);\n\t}\n\n\tstatic <T> void fullCopy(T[] src, T[] dest, int destPos) {\n\t\tSystem.arraycopy(src, 0, dest, destPos, src.length);\n\t}\n\n\tstatic PQNode[] appendFirst(PQNode v, PQNode[] arr) {\n\t\tif (v == null) {\n\t\t\treturn arr;\n\t\t}\n\t\tPQNode[] ret = new PQNode[arr.length + 1];\n\t\tret[0] = v;\n\t\tfullCopy(arr, ret, 1);\n\t\treturn ret;\n\t}\n\n\tstatic PQNode[] appendLast(PQNode v, PQNode[] arr) {\n\t\tif (v == null) {\n\t\t\treturn arr;\n\t\t}\n\t\tPQNode[] ret = new PQNode[arr.length + 1];\n\t\tfullCopy(arr, ret, 0);\n\t\tret[arr.length] = v;\n\t\treturn ret;\n\t}\n\n\tstatic PQNode[] concat(PQNode[] arr1, PQNode[] arr2) {\n\t\tPQNode[] ret = new PQNode[arr1.length + arr2.length];\n\t\tfullCopy(arr1, ret, 0);\n\t\tfullCopy(arr2, ret, arr1.length);\n\t\treturn ret;\n\t}\n\n\tstatic <T> void reverse(T[] a) {\n\t\tfor (int i = 0, j = a.length - 1; i < j; i++, j--) {\n\t\t\tT tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t}\n\t}\n\n\tstatic class PQNode {\n\t\tstatic final int P_NODE = -1;\n\t\tstatic final int Q_NODE = -2;\n\n\t\t/**\n\t\t * < 0 if P or Q node <br>\n\t\t * otherwise this node is leaf and type is number of element\n\t\t */\n\t\tint type;\n\t\tPQNode[] child;\n\n\t\tpublic PQNode(int type, PQNode[] child) {\n\t\t\tthis.type = type;\n\t\t\tthis.child = child;\n\t\t}\n\n\t\tstatic final int EMPTY = 0;\n\t\tstatic final int FULL = 1;\n\t\tstatic final int PARTIAL = 2;\n\t\tstatic final int CONTAINS_ALL = 3;\n\t\t/**\n\t\t * see above for possible values <br>\n\t\t * in case of partial, first children are in current query, then not\n\t\t */\n\t\tint status;\n\n\t\t/**\n\t\t * number of leafs from current query in this subtree\n\t\t */\n\t\tint count;\n\n\t\tPQNode dfs(boolean[] b, int allQry) {\n\n\t\t\tif (type >= 0) {\n\t\t\t\tstatus = b[type] ? FULL : EMPTY;\n\t\t\t\tcount = b[type] ? 1 : 0;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tcount = 0;\n\n\t\t\tboolean allFull = true;\n\t\t\tboolean allEmpty = true;\n\t\t\tint cntPartial = 0;\n\t\t\tint[] idxPartial = new int[2];\n\n\t\t\tfor (int i = 0; i < child.length; i++) {\n\t\t\t\tchild[i] = child[i].dfs(b, allQry);\n\t\t\t\tif (child[i] == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < child.length; i++) {\n\t\t\t\tPQNode v = child[i];\n\n\t\t\t\tif (v.status == CONTAINS_ALL) {\n\t\t\t\t\tstatus = CONTAINS_ALL;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tallFull &= v.status == FULL;\n\t\t\t\tallEmpty &= v.status == EMPTY;\n\t\t\t\tif (v.status == PARTIAL) {\n\t\t\t\t\tif (cntPartial == 2) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tidxPartial[cntPartial++] = i;\n\t\t\t\t}\n\t\t\t\tcount += v.count;\n\t\t\t}\n\n\t\t\tboolean doesContainAll = count == allQry;\n\n\t\t\tif (allFull) {\n\t\t\t\tstatus = FULL;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (allEmpty) {\n\t\t\t\tstatus = EMPTY;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (cntPartial <= 1 && type == P_NODE && doesContainAll) {\n\t\t\t\tPQNode[] fulls = collect(child, FULL);\n\t\t\t\tPQNode[] emptys = collect(child, EMPTY);\n\n\t\t\t\tPQNode fullNode = makeNode(fulls, P_NODE);\n\n\t\t\t\tPQNode fullAndPartial;\n\t\t\t\tif (cntPartial == 0) {\n\t\t\t\t\tfullAndPartial = fullNode;\n\t\t\t\t} else {\n\t\t\t\t\tPQNode[] arr = appendFirst(fullNode,\n\t\t\t\t\t\t\tchild[idxPartial[0]].child);\n\t\t\t\t\tfullAndPartial = makeNode(arr, Q_NODE);\n\t\t\t\t}\n\n\t\t\t\tPQNode[] arr = appendFirst(fullAndPartial, emptys);\n\t\t\t\tPQNode ret = makeNode(arr, P_NODE);\n\t\t\t\tret.status = CONTAINS_ALL;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (cntPartial <= 1 && type == P_NODE && !doesContainAll) {\n\t\t\t\tPQNode[] fulls = collect(child, FULL);\n\t\t\t\tPQNode[] emptys = collect(child, EMPTY);\n\n\t\t\t\tPQNode full = makeNode(fulls, P_NODE);\n\t\t\t\tif (full != null) {\n\t\t\t\t\tfull.status = FULL;\n\t\t\t\t}\n\t\t\t\tPQNode empty = makeNode(emptys, P_NODE);\n\t\t\t\tif (empty != null) {\n\t\t\t\t\tempty.status = EMPTY;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPQNode ret;\n\t\t\t\tif (cntPartial == 1) {\n\t\t\t\t\tPQNode[] arr = appendFirst(full,\n\t\t\t\t\t\t\tappendLast(empty, child[idxPartial[0]].child));\n\t\t\t\t\tret = makeNode(arr, Q_NODE);\n\t\t\t\t} else {\n\t\t\t\t\tret = makeNode(new PQNode[] { full, empty }, Q_NODE);\n\t\t\t\t}\n\t\t\t\tret.count = count;\n\t\t\t\tret.status = PARTIAL;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (cntPartial == 2 && type == P_NODE && doesContainAll) {\n\t\t\t\tPQNode[] fulls = collect(child, FULL);\n\t\t\t\tPQNode[] emptys = collect(child, EMPTY);\n\n\t\t\t\tPQNode fullNode = makeNode(fulls, P_NODE);\n\n\t\t\t\treverse(child[idxPartial[0]].child);\n\n\t\t\t\tPQNode[] tmp = appendLast(fullNode, child[idxPartial[0]].child);\n\t\t\t\tPQNode fullAndPartial = makeNode(\n\t\t\t\t\t\tconcat(tmp, child[idxPartial[1]].child), Q_NODE);\n\n\t\t\t\tPQNode[] arr = appendFirst(fullAndPartial, emptys);\n\t\t\t\tPQNode ret = makeNode(arr, P_NODE);\n\t\t\t\tret.status = CONTAINS_ALL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t\n\t\t\tif (type == Q_NODE) {\n\t\t\t\tint size = child.length;\n\t\t\t\tfor (int i = 0; i < cntPartial; i++) {\n\t\t\t\t\tsize += child[idxPartial[i]].child.length - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPQNode[] arr = new PQNode[size];\n\t\t\t\tint ptr = 0;\n\t\t\t\t\n\t\t\t\tboolean firstPartial = true;\n\t\t\t\tfor (int i = 0; i< child.length; i++) {\n\t\t\t\t\tPQNode v = child[i];\n\t\t\t\t\tif (v.status == PARTIAL) { \n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean shouldRev;\n\t\t\t\t\t\tif (cntPartial == 1) {\n\t\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\t\tshouldRev = child[i + 1].status == FULL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tshouldRev = child[i - 1].status == EMPTY;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshouldRev = firstPartial;\n\t\t\t\t\t\t\tfirstPartial = !firstPartial;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (shouldRev) {\n\t\t\t\t\t\t\treverse(v.child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (PQNode u : v.child) {\n\t\t\t\t\t\t\tarr[ptr++] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarr[ptr++] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (arr[arr.length - 1].status == FULL) {\n\t\t\t\t\treverse(arr);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tptr = arr.length - 1;\n\t\t\t\twhile (ptr >= 0 && arr[ptr].status == EMPTY) {\n\t\t\t\t\tptr--;\n\t\t\t\t}\n\t\t\t\twhile (ptr >= 0 && arr[ptr].status == FULL) {\n\t\t\t\t\tptr--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ptr == -1) {\n\t\t\t\t\tPQNode ret = makeNode(arr, Q_NODE);\n\t\t\t\t\tret.count = count;\n\t\t\t\t\tret.status = doesContainAll ? CONTAINS_ALL : PARTIAL;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (ptr >= 0 && arr[ptr].status == EMPTY) {\n\t\t\t\t\tptr--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ptr == -1 && doesContainAll) {\n\t\t\t\t\tPQNode ret = makeNode(arr, Q_NODE);\n\t\t\t\t\tret.status = CONTAINS_ALL;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\n\t\t// not necessary methods below\n\n\t\tvoid genRepr(StringBuilder sb) {\n\t\t\tif (type >= 0) {\n\t\t\t\tsb.append(type + \" \");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append(type == P_NODE ? \"[\" : \"(\");\n\t\t\tfor (PQNode v : child) {\n\t\t\t\tv.genRepr(sb);\n\t\t\t}\n\t\t\tsb.append(type == P_NODE ? \"]\" : \")\");\n\t\t}\n\t\t\n\t\tvoid getOrder(List<Integer> ret) {\n\t\t\tif (type >= 0) {\n\t\t\t\tret.add(type);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (PQNode v : child) {\n\t\t\t\tv.getOrder(ret);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid getCounts(int[] a) {\n\t\t\tif (type >= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (type == P_NODE) {\n\t\t\t\ta[child.length]++;\n\t\t\t} else {\n\t\t\t\ta[2]++;\n\t\t\t}\n\t\t\tfor (PQNode v : child) {\n\t\t\t\tv.getCounts(a);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class PQTree {\n\t\t/**\n\t\t * null if there are no permutations\n\t\t */\n\t\tPQNode root;\n\t\tint n;\n\n\t\tpublic PQTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tPQNode[] arr = new PQNode[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = new PQNode(i, null);\n\t\t\t}\n\t\t\troot = makeNode(arr, PQNode.P_NODE);\n\t\t}\n\n\t\tvoid update(boolean[] b) {\n\t\t\tif (root == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor (boolean flag : b) {\n\t\t\t\tcnt += flag ? 1 : 0;\n\t\t\t}\n\t\t\tif (cnt <= 1 || cnt == b.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\troot = root.dfs(b, cnt);\n\t\t}\n\n\t\t// not necessary methods below\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (root == null) {\n\t\t\t\treturn \"null\";\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\troot.genRepr(sb);\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tList<Integer> getOrder() {\n\t\t\tList<Integer> ret = new ArrayList<>(n);\n\t\t\troot.getOrder(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tint[] getCounts() {\n\t\t\tint[] ret = new int[n + 1];\n\t\t\troot.getCounts(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tPQTree pq = new PQTree(n);\n\t\tfor (int i=  0;i < m; i++) {\n\t\t\tboolean[] b = new boolean[n];\n\t\t\tint k = nextInt();\n\t\t\twhile (k-- > 0) {\n\t\t\t\tb[nextInt() - 1] = true;\n\t\t\t}\n\t\t\tpq.update(b);\n\t\t}\n\t\t\n\t\tint[] fact = new int[n + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < fact.length; i++) {\n\t\t\tfact[i] = (int)((long)fact[i - 1] * i % P);\n\t\t}\n\t\t\n\t\tif (pq.root == null) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint ret = 1;\n\t\t\tint[] cnt = pq.getCounts();\n\t\t\tfor (int i = 1; i < cnt.length; i++) {\n\t\t\t\tfor (int j = 0; j < cnt[i]; j++) {\n\t\t\t\t\tret = (int)((long)ret * fact[i] % P);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ret);\n\t\t}\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tcfGlobal15I() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew cfGlobal15I();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid sc(int &x) { scanf(\"%d\", &x); }\nvoid sc(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sc(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sc(long long &x) { scanf(\"%lld\", &x); }\nvoid sc(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sc(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sc(char *x) { scanf(\"%s\", x); }\nvoid sc(char *x, char *y) { scanf(\"%s%s\", x, y); }\nvoid sc(char *x, char *y, char *z) { scanf(\"%s%s%s\", x, y, z); }\nvoid out(int x) { printf(\"%d\\n\", x); }\nvoid out(long long x) { printf(\"%lld\\n\", x); }\nvoid out(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid out(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid out(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid out(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid ast(long long x, long long l, long long r) { assert(x >= l && x <= r); }\nusing namespace std;\nconst int N = 105, mod = 998244353;\nint f[N];\nclass PQ_tree {\n public:\n  int n, tot, rt;\n  bitset<N> vis;\n  bool flag;\n  struct node {\n    vector<int> son;\n    bool type;\n    int op;\n  } t[N << 2];\n  int newnode(int type) {\n    tot++;\n    t[tot].type = type;\n    t[tot].son.clear();\n    return tot;\n  }\n  void init(int _n) {\n    flag = true;\n    n = _n;\n    rt = tot = n + 1;\n    t[rt].type = 0;\n    for (int i = 1; i <= n + 1; i++) t[i].son.clear();\n    for (int i = 1; i <= n; i++) t[rt].son.push_back(i);\n  }\n  void dfs1(int u) {\n    if (u <= n)\n      t[u].op = vis[u] ? 2 : 1;\n    else {\n      t[u].op = 0;\n      for (int v : t[u].son) {\n        dfs1(v);\n        t[u].op |= t[v].op;\n      }\n    }\n  }\n  void dfs2(int u, int lim) {\n    if (!flag || t[u].op != 3) return;\n    vector<int> vc[4];\n    for (int v : t[u].son) vc[t[v].op].push_back(v);\n    if ((lim != 0) + vc[3].size() >= 3) {\n      flag = false;\n      return;\n    }\n    if (!lim && vc[2].size() + vc[3].size() <= 1) {\n      for (int x : vc[2]) dfs2(x, 0);\n      for (int x : vc[3]) dfs2(x, 0);\n      return;\n    }\n    if (t[u].type) {\n      vector<int> s = t[u].son;\n      t[u].son.clear();\n      if (t[s[0]].op == 2 || t[s.back()].op == 1) reverse(s.begin(), s.end());\n      int now = 0;\n      for (int v : s) {\n        if (t[v].op == 1) {\n          t[u].son.push_back(v);\n          now += now == 1;\n        } else if (t[v].op == 2) {\n          t[u].son.push_back(v);\n          now += !now;\n          if (now == 2) {\n            flag = false;\n            return;\n          }\n        } else {\n          if (now == 2) {\n            flag = false;\n            return;\n          }\n          now++;\n          dfs2(v, 3 - now);\n          t[u].son.insert(t[u].son.end(), t[v].son.begin(), t[v].son.end());\n        }\n      }\n      if (lim && now == 2) {\n        flag = false;\n        return;\n      }\n      if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n    } else {\n      int z = -1;\n      if (vc[2].size() == 1)\n        z = vc[2][0];\n      else if (vc[2].size() > 1)\n        z = newnode(0), t[z].son = vc[2];\n      vector<int> s;\n      if (!vc[3].empty()) {\n        dfs2(vc[3][0], 2);\n        s.insert(s.end(), t[vc[3][0]].son.begin(), t[vc[3][0]].son.end());\n      }\n      if (z != -1) s.push_back(z);\n      if (vc[3].size() > 1) {\n        dfs2(vc[3][1], 1);\n        s.insert(s.end(), t[vc[3][1]].son.begin(), t[vc[3][1]].son.end());\n      }\n      if (vc[1].empty()) {\n        if (lim == 1) reverse(s.begin(), s.end());\n        t[u].type = 1, t[u].son = s;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = vc[1][0];\n          if (vc[1].size() > 1) {\n            z = ++tot, t[z].type = 0, t[z].son = vc[1];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), s.begin(), s.end());\n          if (lim == 1) reverse(t[u].son.begin(), t[u].son.end());\n        } else {\n          z = s[0];\n          if (s.size() > 1) z = ++tot, t[z].son = s, t[z].type = 1;\n          t[u].son = vc[1], t[u].son.push_back(z);\n        }\n      }\n    }\n  }\n  void ins(bitset<N> &s) {\n    if (!flag) return;\n    vis = s;\n    dfs1(rt);\n    dfs2(rt, 0);\n  }\n  int cal(int u) {\n    int ans = 1;\n    if (!t[u].type)\n      ans = f[t[u].son.size()];\n    else if (t[u].son.size() > 1)\n      ans = 2;\n    for (int v : t[u].son) ans = 1ll * ans * cal(v) % mod;\n    return ans;\n  }\n  int getans() {\n    if (!flag) return 0;\n    return cal(rt);\n  }\n} T;\nvoid sol(int cas) {\n  f[0] = 1;\n  for (int i = 1; i < N; i++) f[i] = 1ll * f[i - 1] * i % mod;\n  int n, m;\n  sc(n, m);\n  T.init(n);\n  for (int i = 1; i <= m; i++) {\n    int k;\n    sc(k);\n    bitset<N> bs;\n    while (k--) {\n      int x;\n      sc(x);\n      bs[x] = 1;\n    }\n    T.ins(bs);\n  }\n  printf(\"%d\\n\", T.getans());\n}\nint main() {\n  srand(time(0));\n  int t = 1, cas = 0;\n  while (t--) {\n    sol(++cas);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 7, mod = 998244353;\nint pow_mod(int x, int n) {\n  int res = 1;\n  while (n & 1) {\n    if (n & 1) res = 1LL * res * x % mod;\n    x = 1LL * x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\nstruct PQtree {\n  int siz[N], sizr[N], typ[N], n, nodecnt, fail, *s;\n  vector<int> con[N];\n  inline int state(int x) {\n    if (!sizr[x]) return 0;\n    if (sizr[x] == siz[x]) return 2;\n    return 1;\n  }\n  void init(int N) {\n    n = N;\n    nodecnt = n + 1;\n    for (int i = 1; i <= n; i++) con[n + 1].push_back(i);\n  }\n  void dfs(int np) {\n    siz[np] = (np <= n);\n    sizr[np] = (np <= n) ? (s[np] == 1) : 0;\n    for (int &x : con[np]) dfs(x), siz[np] += siz[x], sizr[np] += sizr[x];\n  }\n  int mergep(const vector<int> &v) {\n    if (!v.size()) return 0;\n    if (v.size() == 1) return v[0];\n    int p = ++nodecnt;\n    con[p] = v;\n    return p;\n  }\n  void addedge(int s, int e) {\n    if (e) con[s].push_back(e);\n  }\n  void merge(int a, int b) {\n    con[a].insert(con[a].end(), con[b].begin(), con[b].end());\n  }\n  int solve(int np, int t) {\n    if (fail) return 0;\n    vector<int> v[3];\n    for (int &x : con[np]) v[state(x)].push_back(x);\n    if (v[1].size() > 2 || (t > 0 && v[1].size() > 1)) {\n      fail = 1;\n      return 0;\n    }\n    if (t == 0 && v[1].size() == 1 && v[2].size() == 0)\n      return solve(v[1][0], 0);\n    if (typ[np] == 0) {\n      int P = mergep(v[2]);\n      if (!t) {\n        con[np] = v[0];\n        if (!v[1].size())\n          addedge(np, P);\n        else {\n          int p1 = solve(v[1][0], 1);\n          addedge(p1, P);\n          if (v[1].size() > 1) merge(p1, solve(v[1][1], 2));\n          addedge(np, p1);\n        }\n      } else {\n        typ[np] = 1;\n        con[np].clear();\n        addedge(np, mergep(v[0]));\n        if (v[1].size()) merge(np, solve(v[1][0], 1));\n        addedge(np, P);\n        if (t == 2) reverse(con[np].begin(), con[np].end());\n      }\n      return np;\n    } else {\n      if (state(con[np][0]) == 2 || state(con[np].back()) == 0)\n        reverse(con[np].begin(), con[np].end());\n      vector<int> tmp;\n      int cnt = 0;\n      for (int &x : con[np]) {\n        int S = state(x);\n        if (S == 1) {\n          int p;\n          if (cnt == 0)\n            cnt++, p = solve(x, 1);\n          else if (cnt == 1)\n            cnt++, p = solve(x, 2);\n          else {\n            fail = 1;\n            return 0;\n          }\n          for (int &x : con[p]) tmp.push_back(x);\n        } else if (S == 2) {\n          tmp.push_back(x);\n          if (cnt == 0)\n            cnt++;\n          else if (cnt == 2) {\n            fail = 1;\n            return 0;\n          }\n        } else {\n          tmp.push_back(x);\n          if (cnt == 1) cnt++;\n        }\n      }\n      if (t && cnt == 2) {\n        fail = 1;\n        return 0;\n      }\n      con[np] = tmp;\n      if (t == 2) reverse(con[np].begin(), con[np].end());\n      return np;\n    }\n  }\n  void regulate(int *S) {\n    s = S;\n    dfs(n + 1);\n    solve(n + 1, 0);\n  }\n  int cal(int x) {\n    if (x <= n) return 1;\n    int res = 1, d = 0;\n    for (auto &y : con[x]) res = 1LL * res * cal(y) % mod, d++;\n    if (!typ[x])\n      for (int i = 2; i <= d; ++i) res = 1LL * res * i % mod;\n    else if (d > 1)\n      res = (res << 1) % mod;\n    return res;\n  }\n  int count() { return fail ? 0 : cal(n + 1); }\n} T;\nint n, m, i, j, k, T_T, s[N];\nint main() {\n  for (scanf(\"%d%d\", &n, &m), T.init(n); m--;) {\n    scanf(\"%d\", &i);\n    memset(s, 0, sizeof(s));\n    for (j = 1; j <= i; ++j) scanf(\"%d\", &k), s[k] = 1;\n    T.regulate(s);\n  }\n  printf(\"%d\\n\", T.count());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nconst int M = 2000;\nint mod = 1000007;\nvoid die() {\n  printf(\"0\\n\");\n  exit(0);\n}\nstruct group {\n  vector<int> domain;\n  vector<int> sets;\n};\nstruct pattern {\n  pattern *left, *right;\n  group g;\n};\nbool matrix[N + 1][M + 1];\nint sizeT[N + 1];\nbool intersects[N + 1];\nvoid insertBefore(pattern* p, group g) {\n  pattern* left = p->left;\n  p->left = new pattern;\n  p->left->right = p;\n  p->left->left = left;\n  p->left->g = g;\n  if (p->left->left != NULL) p->left->left->right = p->left;\n}\nvoid insertAfter(pattern* p, group g) {\n  pattern* right = p->right;\n  p->right = new pattern;\n  p->right->left = p;\n  p->right->right = right;\n  p->right->g = g;\n  if (p->right->right != NULL) p->right->right->left = p->right;\n}\npair<group, group> split(group& g, int set) {\n  group gdifference, gintersection;\n  for (vector<int>::iterator it = g.domain.begin(); it != g.domain.end();\n       ++it) {\n    if (matrix[set][*it]) {\n      gintersection.domain.push_back(*it);\n      matrix[set][*it] = 0;\n      --sizeT[set];\n    } else\n      gdifference.domain.push_back(*it);\n  }\n  if (gdifference.domain.empty()) return make_pair(gdifference, g);\n  if (gintersection.domain.empty()) return make_pair(g, gintersection);\n  bool swp = 0;\n  if (gdifference.domain.size() < gintersection.domain.size()) {\n    swp = 1;\n    swap(gdifference, gintersection);\n  }\n  for (vector<int>::iterator it = g.sets.begin(); it != g.sets.end(); ++it) {\n    int intsize = 0;\n    for (vector<int>::iterator jt = gintersection.domain.begin();\n         jt != gintersection.domain.end(); ++jt) {\n      if (matrix[*it][*jt]) ++intsize;\n    }\n    if (intsize == 0)\n      gdifference.sets.push_back(*it);\n    else if (intsize == sizeT[*it])\n      gintersection.sets.push_back(*it);\n    else\n      intersects[*it] = true;\n  }\n  if (swp) swap(gdifference, gintersection);\n  return make_pair(gdifference, gintersection);\n}\nvoid erase(vector<int>& v, unsigned i) {\n  swap(v[i], v[v.size() - 1]);\n  v.pop_back();\n}\nint f(group g) {\n  vector<int> sets = g.sets;\n  int result = 1;\n  int iterations = 0;\n  while (g.domain.size() > 0) {\n    if (sets.empty()) {\n      iterations += g.domain.size();\n      break;\n    }\n    ++iterations;\n    unsigned first = 0;\n    for (unsigned i = 1; i < sets.size(); i++)\n      if (sizeT[sets[i]] > sizeT[sets[first]]) first = i;\n    int cur = sets[first];\n    erase(sets, first);\n    g.sets = sets;\n    pair<group, group> sp = split(g, cur);\n    pattern* p = new pattern;\n    p->left = p->right = NULL;\n    p->g = sp.second;\n    g = sp.first;\n    while (!sets.empty()) {\n      first = 0;\n      for (unsigned i = 0; i < sets.size(); i++) {\n        if (intersects[sets[i]]) {\n          first = i;\n          break;\n        }\n      }\n      if (!intersects[sets[first]]) break;\n      cur = sets[first];\n      erase(sets, first);\n      bool gotLeft = 0, gotRight = 0;\n      bool started = 0;\n      sp = split(g, cur);\n      group newElements = sp.second;\n      g = sp.first;\n      for (pattern* c = p; c != NULL; c = c->right) {\n        sp = split(c->g, cur);\n        if (sp.second.domain.empty()) {\n          if (started) {\n            if (sizeT[cur]) die();\n            break;\n          }\n        } else {\n          if (started && sizeT[cur]) {\n            if (!sp.first.domain.empty()) die();\n          } else if (started) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertBefore(c, sp.second);\n            } else if (c->right == NULL) {\n              gotRight = 1;\n            }\n            break;\n          } else if (sizeT[cur]) {\n            if (!sp.first.domain.empty()) {\n              c->g = sp.first;\n              insertAfter(c, sp.second);\n              c = c->right;\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n            }\n          } else {\n            if (c->right == NULL) {\n              gotRight = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertAfter(c, sp.second);\n              }\n            } else if (c->left == NULL) {\n              gotLeft = 1;\n              if (!sp.first.domain.empty()) {\n                c->g = sp.first;\n                insertBefore(c, sp.second);\n                p = p->left;\n              }\n            } else\n              die();\n            break;\n          }\n          started = 1;\n        }\n      }\n      if (!newElements.domain.empty()) {\n        if (gotRight) {\n          pattern* last = p;\n          while (last->right != NULL) last = last->right;\n          insertAfter(last, newElements);\n        } else if (gotLeft) {\n          insertBefore(p, newElements);\n          p = p->left;\n        } else\n          die();\n      }\n    }\n    if (p->right != NULL) {\n      result = (long long(result) * 2) % mod;\n    }\n    pattern* next;\n    for (pattern* c = p; c != NULL; c = next) {\n      next = c->right;\n      result = (long long(result) * f(c->g)) % mod;\n      delete c;\n    }\n    sets = g.sets;\n  }\n  for (int i = 1; i <= iterations; i++) result = (long long(result) * i) % mod;\n  return result;\n}\nint n, m, z;\nvoid read_data() {\n  scanf(\"%d %d\\n\", &m, &n);\n  mod = 998244353;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      matrix[i][j] = 0;\n    }\n    int foo;\n    scanf(\"%d\", &foo);\n    for (int j = 1; j <= foo; j++) {\n      int z;\n      scanf(\"%d\", &z);\n      matrix[i][z] = 1;\n    }\n    for (int j = 1; j <= m; j++) {\n      if (matrix[i][j]) ++sizeT[i];\n    }\n  }\n}\nint main() {\n  read_data();\n  group g;\n  for (int i = 1; i <= n; i++)\n    if (sizeT[i]) g.sets.push_back(i);\n  for (int i = 1; i <= m; i++) g.domain.push_back(i);\n  printf(\"%d\\n\", f(g));\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            IOrganizingAMusicFestival solver = new IOrganizingAMusicFestival();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class IOrganizingAMusicFestival {\n        int mod = 998244353;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            PQTree pqt = new PQTree(n);\n            boolean[] set = new boolean[n];\n            for (int i = 0; i < m; i++) {\n                Arrays.fill(set, false);\n                int q = in.ri();\n                for (int j = 0; j < q; j++) {\n                    set[in.ri() - 1] = true;\n                }\n                pqt.update(set);\n            }\n            if (!pqt.possible()) {\n                out.println(0);\n                return;\n            }\n            int[] res = pqt.getCounts();\n            Factorial fact = new Factorial(n, mod);\n            long ans = 1;\n            for (int i = 0; i < res.length; i++) {\n                for (int j = 0; j < res[i]; j++) {\n                    ans = ans * fact.fact(i) % mod;\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class PQTree {\n        PQTree.PQNode root;\n        int n;\n\n        public boolean possible() {\n            return root != null;\n        }\n\n        public PQTree(int n) {\n            this.n = n;\n            PQTree.PQNode[] arr = new PQTree.PQNode[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = new PQTree.PQNode(i, null);\n            }\n            root = makeNode(arr, PQTree.PQNode.P_NODE);\n        }\n\n        public void update(boolean[] b) {\n            if (root == null) {\n                return;\n            }\n            int cnt = 0;\n            for (boolean flag : b) {\n                cnt += flag ? 1 : 0;\n            }\n            if (cnt <= 1 || cnt == b.length) {\n                return;\n            }\n            root = root.dfs(b, cnt);\n        }\n\n        public String toString() {\n            if (root == null) {\n                return \"null\";\n            }\n            StringBuilder sb = new StringBuilder();\n            root.genRepr(sb);\n            return sb.toString();\n        }\n\n        public int[] getCounts() {\n            assert possible();\n            int[] ret = new int[n + 1];\n            root.getCounts(ret);\n            return ret;\n        }\n\n        static PQTree.PQNode[] collect(PQTree.PQNode[] arr, int whatStatus) {\n            int sz = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    sz++;\n                }\n            }\n\n            PQTree.PQNode[] ret = new PQTree.PQNode[sz];\n            int ptr = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    ret[ptr++] = v;\n                }\n            }\n\n            return ret;\n        }\n\n        static PQTree.PQNode makeNode(PQTree.PQNode[] arr, int whatType) {\n            if (arr.length == 0) {\n                return null;\n            }\n            if (arr.length == 1) {\n                return arr[0];\n            }\n            if (arr.length == 2) {\n                whatType = PQTree.PQNode.Q_NODE;\n            }\n            return new PQTree.PQNode(whatType, arr);\n        }\n\n        static <T> void fullCopy(T[] src, T[] dest, int destPos) {\n            System.arraycopy(src, 0, dest, destPos, src.length);\n        }\n\n        static PQTree.PQNode[] appendFirst(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            ret[0] = v;\n            fullCopy(arr, ret, 1);\n            return ret;\n        }\n\n        static PQTree.PQNode[] appendLast(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            fullCopy(arr, ret, 0);\n            ret[arr.length] = v;\n            return ret;\n        }\n\n        static PQTree.PQNode[] concat(PQTree.PQNode[] arr1, PQTree.PQNode[] arr2) {\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr1.length + arr2.length];\n            fullCopy(arr1, ret, 0);\n            fullCopy(arr2, ret, arr1.length);\n            return ret;\n        }\n\n        static <T> void reverse(T[] a) {\n            for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n                T tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n            }\n        }\n\n        static class PQNode {\n            static final int P_NODE = -1;\n            static final int Q_NODE = -2;\n            int type;\n            PQTree.PQNode[] child;\n            static final int EMPTY = 0;\n            static final int FULL = 1;\n            static final int PARTIAL = 2;\n            static final int CONTAINS_ALL = 3;\n            int status;\n            int count;\n\n            public PQNode(int type, PQTree.PQNode[] child) {\n                this.type = type;\n                this.child = child;\n            }\n\n            PQTree.PQNode dfs(boolean[] b, int allQry) {\n\n                if (type >= 0) {\n                    status = b[type] ? FULL : EMPTY;\n                    count = b[type] ? 1 : 0;\n                    return this;\n                }\n\n                count = 0;\n\n                boolean allFull = true;\n                boolean allEmpty = true;\n                int cntPartial = 0;\n                int[] idxPartial = new int[2];\n\n                for (int i = 0; i < child.length; i++) {\n                    child[i] = child[i].dfs(b, allQry);\n                    if (child[i] == null) {\n                        return null;\n                    }\n                }\n\n                for (int i = 0; i < child.length; i++) {\n                    PQTree.PQNode v = child[i];\n\n                    if (v.status == CONTAINS_ALL) {\n                        status = CONTAINS_ALL;\n                        return this;\n                    }\n                    allFull &= v.status == FULL;\n                    allEmpty &= v.status == EMPTY;\n                    if (v.status == PARTIAL) {\n                        if (cntPartial == 2) {\n                            return null;\n                        }\n                        idxPartial[cntPartial++] = i;\n                    }\n                    count += v.count;\n                }\n\n                boolean doesContainAll = count == allQry;\n\n                if (allFull) {\n                    status = FULL;\n                    return this;\n                }\n\n                if (allEmpty) {\n                    status = EMPTY;\n                    return this;\n                }\n\n                if (cntPartial <= 1 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n\n                    PQTree.PQNode fullAndPartial;\n                    if (cntPartial == 0) {\n                        fullAndPartial = fullNode;\n                    } else {\n                        PQTree.PQNode[] arr = appendFirst(fullNode,\n                                child[idxPartial[0]].child);\n                        fullAndPartial = makeNode(arr, Q_NODE);\n                    }\n\n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n\n                if (cntPartial <= 1 && type == P_NODE && !doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode full = makeNode(fulls, P_NODE);\n                    if (full != null) {\n                        full.status = FULL;\n                    }\n                    PQTree.PQNode empty = makeNode(emptys, P_NODE);\n                    if (empty != null) {\n                        empty.status = EMPTY;\n                    }\n\n                    PQTree.PQNode ret;\n                    if (cntPartial == 1) {\n                        PQTree.PQNode[] arr = appendFirst(full,\n                                appendLast(empty, child[idxPartial[0]].child));\n                        ret = makeNode(arr, Q_NODE);\n                    } else {\n                        ret = makeNode(new PQTree.PQNode[]{full, empty}, Q_NODE);\n                    }\n                    ret.count = count;\n                    ret.status = PARTIAL;\n                    return ret;\n                }\n\n                if (cntPartial == 2 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n\n                    reverse(child[idxPartial[0]].child);\n\n                    PQTree.PQNode[] tmp = appendLast(fullNode, child[idxPartial[0]].child);\n                    PQTree.PQNode fullAndPartial = makeNode(\n                            concat(tmp, child[idxPartial[1]].child), Q_NODE);\n\n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n\n                if (type == Q_NODE) {\n                    int size = child.length;\n                    for (int i = 0; i < cntPartial; i++) {\n                        size += child[idxPartial[i]].child.length - 1;\n                    }\n\n                    PQTree.PQNode[] arr = new PQTree.PQNode[size];\n                    int ptr = 0;\n\n                    boolean firstPartial = true;\n                    for (int i = 0; i < child.length; i++) {\n                        PQTree.PQNode v = child[i];\n                        if (v.status == PARTIAL) {\n\n                            boolean shouldRev;\n                            if (cntPartial == 1) {\n                                if (i == 0) {\n                                    shouldRev = child[i + 1].status == FULL;\n                                } else {\n                                    shouldRev = child[i - 1].status == EMPTY;\n                                }\n                            } else {\n                                shouldRev = firstPartial;\n                                firstPartial = !firstPartial;\n                            }\n\n                            if (shouldRev) {\n                                reverse(v.child);\n                            }\n\n                            for (PQTree.PQNode u : v.child) {\n                                arr[ptr++] = u;\n                            }\n                        } else {\n                            arr[ptr++] = v;\n                        }\n                    }\n\n                    if (arr[arr.length - 1].status == FULL) {\n                        reverse(arr);\n                    }\n\n                    ptr = arr.length - 1;\n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n                    while (ptr >= 0 && arr[ptr].status == FULL) {\n                        ptr--;\n                    }\n\n                    if (ptr == -1) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.count = count;\n                        ret.status = doesContainAll ? CONTAINS_ALL : PARTIAL;\n                        return ret;\n                    }\n\n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n\n                    if (ptr == -1 && doesContainAll) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.status = CONTAINS_ALL;\n                        return ret;\n                    }\n                }\n\n                return null;\n            }\n\n            void genRepr(StringBuilder sb) {\n                if (type >= 0) {\n                    sb.append(type + \" \");\n                    return;\n                }\n                sb.append(type == P_NODE ? \"[\" : \"(\");\n                for (PQTree.PQNode v : child) {\n                    v.genRepr(sb);\n                }\n                sb.append(type == P_NODE ? \"]\" : \")\");\n            }\n\n            void getCounts(int[] a) {\n                if (type >= 0) {\n                    return;\n                }\n                if (type == P_NODE) {\n                    a[child.length]++;\n                } else {\n                    a[2]++;\n                }\n                for (PQTree.PQNode v : child) {\n                    v.getCounts(a);\n                }\n            }\n\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(\"value\");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            if (n - 1 >= 0) {\n                inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            }\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);\n        }\n\n        public int fact(int n) {\n            if (n >= mod) {\n                return 0;\n            }\n            return fact[n];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 100;\nconst int Mod = 998244353;\nint n, m;\nint fac[Maxn + 5];\nstruct PQ_Tree {\n  int n;\n  struct node {\n    std::vector<int> son;\n    int type, op;\n  } t[Maxn << 1 | 5];\n  int tot, rt;\n  bool OK;\n  std::bitset<Maxn + 5> vis;\n  void init(int _n) {\n    tot = n = _n;\n    rt = ++tot;\n    for (int i = 1; i <= n; i++) {\n      t[rt].son.push_back(i);\n    }\n  }\n  void dfs_1(int u) {\n    if (u <= n) {\n      t[u].op = vis[u] ? 2 : 1;\n      return;\n    }\n    t[u].op = 0;\n    for (int i = 0; i < (int)t[u].son.size(); i++) {\n      int v = t[u].son[i];\n      dfs_1(v);\n      t[u].op |= t[v].op;\n    }\n  }\n  void dfs_2(int u, int lim) {\n    if (!OK || t[u].op != 3) {\n      return;\n    }\n    std::vector<int> a[4];\n    for (int i = 0; i < (int)t[u].son.size(); i++) {\n      int v = t[u].son[i];\n      a[t[v].op].push_back(v);\n    }\n    if ((lim > 0) + a[3].size() >= 3) {\n      OK = 0;\n    }\n    if (lim == 0 && (a[2].size() + a[3].size()) <= 1) {\n      if (!a[2].empty()) {\n        dfs_2(a[2][0], 0);\n      }\n      if (!a[3].empty()) {\n        dfs_2(a[3][0], 0);\n      }\n      return;\n    }\n    if (t[u].type) {\n      int now = 0;\n      std::vector<int> S;\n      if (t[t[u].son[0]].op == 2 || t[t[u].son.back()].op == 1) {\n        std::reverse(t[u].son.begin(), t[u].son.end());\n      }\n      for (int i = 0; i < (int)t[u].son.size(); i++) {\n        int v = t[u].son[i];\n        if (t[v].op == 1) {\n          S.push_back(v);\n          now += (now == 1);\n        } else if (t[v].op == 2) {\n          S.push_back(v);\n          now += (now == 0);\n          if (now == 2) {\n            OK = 0;\n          }\n        } else {\n          if (now == 2) {\n            OK = 0;\n          }\n          now++;\n          dfs_2(v, 3 - now);\n          S.insert(S.end(), t[v].son.begin(), t[v].son.end());\n        }\n      }\n      if (lim > 0 && now == 2) {\n        OK = 0;\n      }\n      if (lim == 1) {\n        std::reverse(S.begin(), S.end());\n      }\n      t[u].son = S;\n    } else {\n      int z = -1;\n      if (a[2].size() == 1) {\n        z = a[2][0];\n      } else if (a[2].size() > 1) {\n        z = ++tot;\n        t[z].type = 0;\n        t[z].son = a[2];\n      }\n      std::vector<int> S;\n      if (!a[3].empty()) {\n        dfs_2(a[3][0], 2);\n        S.insert(S.end(), t[a[3][0]].son.begin(), t[a[3][0]].son.end());\n      }\n      if (z != -1) {\n        S.push_back(z);\n      }\n      if (a[3].size() > 1) {\n        dfs_2(a[3][1], 1);\n        S.insert(S.end(), t[a[3][1]].son.begin(), t[a[3][1]].son.end());\n      }\n      if (a[1].empty()) {\n        if (lim == 1) {\n          std::reverse(S.begin(), S.end());\n        }\n        t[u].type = 1;\n        t[u].son = S;\n      } else {\n        if (lim) {\n          t[u].son.clear();\n          t[u].type = 1;\n          z = a[1][0];\n          if (a[1].size() > 1) {\n            z = ++tot;\n            t[z].type = 0;\n            t[z].son = a[1];\n          }\n          t[u].son.push_back(z);\n          t[u].son.insert(t[u].son.end(), S.begin(), S.end());\n          if (lim == 1) {\n            std::reverse(t[u].son.begin(), t[u].son.end());\n          }\n        } else {\n          z = S[0];\n          if (S.size() > 1) {\n            z = ++tot;\n            t[z].son = S;\n            t[z].type = 1;\n          }\n          t[u].son = a[1];\n          t[u].son.push_back(z);\n        }\n      }\n    }\n  }\n  bool insert(const std::bitset<Maxn + 5> &B) {\n    vis = B;\n    dfs_1(rt);\n    OK = 1;\n    dfs_2(rt, 0);\n    return OK;\n  }\n  int calc(int u) {\n    if (u <= n) {\n      return 1;\n    }\n    int ans = t[u].type ? 2 : fac[t[u].son.size()];\n    for (int i = 0; i < (int)t[u].son.size(); i++) {\n      int v = t[u].son[i];\n      ans = 1ll * ans * calc(v) % Mod;\n    }\n    return ans;\n  }\n} T;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = 1ll * fac[i - 1] * i % Mod;\n  }\n  T.init(n);\n  while (m--) {\n    static std::bitset<Maxn + 5> B;\n    B.reset();\n    int k;\n    scanf(\"%d\", &k);\n    while (k--) {\n      int a;\n      scanf(\"%d\", &a);\n      B[a] = 1;\n    }\n    if (!T.insert(B)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  printf(\"%d\\n\", T.calc(T.rt));\n  return 0;\n}\n"
        }
    ]
}