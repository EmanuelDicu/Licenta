{
    "name": "1450_B. Balls of Steel",
    "source": "CODEFORCES",
    "description": "You have n distinct points (x_1, y_1),\u2026,(x_n,y_n) on the plane and a non-negative integer parameter k. Each point is a microscopic steel ball and k is the attract power of a ball when it's charged. The attract power is the same for all balls.\n\nIn one operation, you can select a ball i to charge it. Once charged, all balls with Manhattan distance at most k from ball i move to the position of ball i. Many balls may have the same coordinate after an operation.\n\nMore formally, for all balls j such that |x_i - x_j| + |y_i - y_j| \u2264 k, we assign x_j:=x_i and y_j:=y_i.\n\n<image> An example of an operation. After charging the ball in the center, two other balls move to its position. On the right side, the red dot in the center is the common position of those balls. \n\nYour task is to find the minimum number of operations to move all balls to the same position, or report that this is impossible.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n, k (2 \u2264 n \u2264 100, 0 \u2264 k \u2264 10^6) \u2014 the number of balls and the attract power of all balls, respectively.\n\nThe following n lines describe the balls' coordinates. The i-th of these lines contains two integers x_i, y_i (0 \u2264 x_i, y_i \u2264 10^5) \u2014 the coordinates of the i-th ball.\n\nIt is guaranteed that all points are distinct.\n\nOutput\n\nFor each test case print a single integer \u2014 the minimum number of operations to move all balls to the same position, or -1 if it is impossible.\n\nExample\n\nInput\n\n\n3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n0 1\n0 2\n0 3\n\n\nOutput\n\n\n-1\n1\n-1\n\nNote\n\nIn the first test case, there are three balls at (0, 0), (3, 3), and (1, 1) and the attract power is 2. It is possible to move two balls together with one operation, but not all three balls together with any number of operations.\n\nIn the second test case, there are three balls at (6, 7), (8, 8), and (6, 9) and the attract power is 3. If we charge any ball, the other two will move to the same position, so we only require one operation.\n\nIn the third test case, there are four balls at (0, 0), (0, 1), (0, 2), and (0, 3), and the attract power is 1. We can show that it is impossible to move all balls to the same position with a sequence of operations.",
    "difficulty": "B",
    "tags": [
        "brute force",
        "geometry",
        "greedy"
    ],
    "rating": 1000,
    "public_test": [
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n0 1\n0 2\n0 3\n",
            "output": "\n-1\n1\n-1\n"
        }
    ],
    "generated_test": [
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n9 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n1 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 2\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 9\n4 1\n0 0\n0 2\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 9\n4 1\n0 0\n0 2\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n9 6\n6 9\n4 1\n0 0\n0 -1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n0 1\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 0\n6 9\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 11\n4 1\n0 0\n0 2\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n0 6\n6 9\n4 1\n0 0\n0 2\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n0 0\n0 1\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 1\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n4 0\n6 9\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 9\n4 1\n0 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n0 6\n6 9\n4 1\n0 0\n0 2\n1 4\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 0\n1 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n0 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 1\n1 1\n0 3\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n4 0\n6 9\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 9\n4 1\n0 -1\n0 0\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n4 0\n1 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n2 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 1\n1 1\n0 3\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n4 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 3\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n7 7\n4 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n4 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n7 7\n4 0\n6 9\n4 1\n-1 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 1\n3 3\n6 7\n9 8\n12 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 1\n3 3\n6 7\n9 8\n12 9\n4 1\n-1 0\n0 1\n0 2\n1 0\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 6\n9 9\n4 0\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 2\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 1\n3 3\n9 7\n9 8\n12 9\n4 1\n-1 0\n0 1\n0 2\n1 0\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 6\n9 9\n4 0\n0 0\n-1 2\n1 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 2\n1 4\n3 3\n6 7\n10 6\n3 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n0 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 15\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 1\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 1\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 9\n4 1\n1 0\n0 2\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 4\n1 2\n3 3\n6 7\n9 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 5\n6 7\n9 6\n6 9\n4 1\n0 0\n0 -1\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 -1\n0 1\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 7\n8 9\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 5\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 3\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n5 6\n6 11\n4 1\n0 0\n0 4\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n0 6\n6 9\n4 1\n0 0\n0 1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n-1 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 2\n9 8\n6 9\n4 1\n0 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 12\n8 6\n6 9\n4 1\n0 1\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n4 0\n6 9\n4 1\n0 0\n1 2\n0 3\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 5\n4 1\n0 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n0 4\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 2\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 0\n1 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n1 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 1\n6 9\n4 1\n0 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n4 0\n6 9\n4 1\n0 0\n1 2\n0 4\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n8 10\n6 9\n4 1\n0 -1\n0 0\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 9\n4 1\n0 0\n-1 2\n0 4\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 5\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n4 0\n1 2\n3 3\n6 14\n7 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n2 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n1 0\n0 3\n2 1\n3 3\n6 7\n8 6\n6 9\n4 1\n0 1\n1 1\n0 3\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 3\n1 0\n3 3\n6 7\n4 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n8 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 2\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 5\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n1 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n7 7\n4 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n4 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n-1 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 3\n3 3\n1 7\n8 6\n6 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 6\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n0 3\n1 1\n3 3\n6 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 2\n1 0\n3 3\n7 7\n4 0\n6 9\n4 1\n-1 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 1\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n-1 2\n0 2\n0 4\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 4\n1 4\n3 3\n12 7\n10 6\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n0 6\n9 9\n4 0\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 2\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 -1\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 2\n3 3\n9 7\n9 8\n12 9\n4 1\n-1 0\n0 1\n0 2\n1 0\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 0\n6 7\n8 6\n6 15\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 1\n3 3\n1 1\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 4\n1 2\n3 3\n6 7\n9 6\n6 9\n4 2\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 5\n6 10\n9 6\n6 9\n4 1\n0 0\n0 -1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 -1\n0 1\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n0 3\n1 1\n3 3\n6 7\n8 9\n6 9\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 0\n6 9\n4 1\n1 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 5\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n1 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 3\n3 3\n6 7\n8 6\n6 8\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 3\n3 3\n6 2\n10 6\n6 9\n4 1\n0 0\n0 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 4\n3 3\n6 7\n5 6\n6 11\n4 1\n0 0\n0 4\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 7\n0 6\n6 9\n4 1\n0 -1\n0 1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 2\n9 8\n1 9\n4 1\n0 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 1\n3 3\n6 12\n8 6\n10 9\n4 1\n0 1\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 3\n1 1\n3 3\n6 7\n4 0\n6 9\n4 1\n0 0\n1 2\n0 3\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 5\n4 1\n0 -1\n0 2\n0 2\n-1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 2\n6 7\n8 6\n6 9\n4 1\n0 0\n0 4\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 5\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 2\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 0\n0 2\n3 3\n6 7\n7 6\n6 9\n4 1\n0 0\n1 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n0 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n4 0\n3 9\n4 1\n0 0\n1 2\n0 4\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n12 9\n4 1\n0 0\n-1 2\n0 4\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n8 0\n1 2\n3 3\n6 14\n7 6\n6 9\n4 1\n0 0\n0 0\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n5 3\n1 1\n3 3\n2 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 3\n1 0\n3 3\n6 7\n3 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n8 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n-1 0\n3 3\n1 3\n3 3\n6 7\n8 6\n6 2\n4 1\n1 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n1 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n7 7\n4 0\n6 9\n4 1\n0 -1\n1 2\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 1\n1 1\n3 3\n4 7\n8 16\n6 9\n4 1\n0 -1\n0 0\n-1 2\n0 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 3\n3 3\n1 7\n8 6\n11 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n0 0\n1 3\n0 2\n0 6\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n0 3\n1 1\n3 4\n6 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 2\n1 0\n3 3\n7 7\n4 0\n6 9\n4 1\n-1 -1\n1 2\n-1 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n-1 2\n-1 2\n0 4\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 4\n1 4\n3 3\n12 7\n0 6\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 6\n0 -1\n3 2\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 -1\n0 3\n0 2\n0 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 2\n3 3\n9 7\n9 8\n12 9\n4 1\n-2 0\n0 1\n0 2\n1 0\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 0\n6 7\n8 6\n10 15\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 1\n3 3\n1 0\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 1\n3 3\n6 5\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 -1\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "1\n1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n3 3\n1 2\n3 5\n6 10\n9 6\n6 9\n4 1\n0 0\n0 -1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 6\n4 1\n0 -1\n0 1\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 8\n8 0\n6 9\n4 1\n1 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 5\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n2 -1\n0 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 3\n1 3\n3 3\n6 7\n8 6\n6 8\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 3\n3 3\n6 2\n10 6\n6 9\n4 1\n0 0\n0 2\n0 2\n-1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 1\n0 6\n6 9\n4 1\n0 -1\n0 1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n0 3\n1 1\n3 3\n6 12\n8 6\n10 9\n4 1\n0 1\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 5\n4 1\n0 -1\n0 2\n0 2\n-1 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 5\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 1\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 0\n0 2\n3 3\n6 7\n7 6\n6 9\n4 2\n0 0\n1 0\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n0 0\n0 0\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 0\n3 3\n6 7\n4 0\n3 9\n4 1\n1 0\n1 2\n0 4\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n3 3\n1 6\n3 3\n6 7\n8 6\n12 9\n4 1\n0 0\n-1 2\n0 4\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n2 3\n1 1\n3 3\n2 7\n9 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 3\n1 0\n3 3\n6 7\n3 -1\n6 9\n4 1\n0 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n8 7\n8 16\n6 9\n2 1\n0 -1\n0 0\n0 2\n1 3\n",
            "output": "-1\n-1\n1\n"
        },
        {
            "input": "3\n3 0\n-1 0\n3 4\n1 3\n3 3\n6 7\n8 6\n6 2\n4 1\n1 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n-1 0\n1 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n-1 1\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n7 7\n4 0\n6 9\n4 1\n0 -1\n2 2\n0 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 1\n1 1\n3 3\n4 7\n8 16\n6 0\n4 1\n0 -1\n0 0\n-1 2\n0 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 3\n3 3\n1 7\n8 6\n14 9\n4 1\n0 0\n-1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n20 6\n6 9\n4 1\n0 0\n1 3\n0 2\n0 6\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n0 3\n1 1\n3 4\n6 7\n13 8\n6 9\n4 1\n-1 0\n0 1\n0 2\n1 5\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 2\n1 0\n3 3\n7 7\n4 0\n6 9\n4 1\n-1 -1\n1 2\n-1 2\n0 4\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n3 4\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 2\n0 3\n0 2\n-1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n0 3\n3 3\n6 7\n8 8\n6 9\n4 0\n0 0\n-1 2\n-1 2\n0 4\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 3\n0 -1\n3 4\n1 4\n3 3\n12 7\n0 8\n6 9\n4 1\n-1 0\n0 3\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 6\n0 -1\n2 2\n1 4\n3 3\n6 7\n10 6\n6 9\n4 1\n-1 -1\n0 3\n0 2\n0 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n1 3\n1 2\n3 3\n9 7\n9 8\n22 9\n4 1\n-2 0\n0 1\n0 2\n1 0\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n6 3\n1 1\n3 0\n6 7\n8 6\n10 15\n4 1\n0 0\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 1\n3 3\n0 0\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 1\n3 3\n6 5\n8 6\n6 5\n4 0\n0 0\n0 2\n0 2\n0 3\n",
            "output": "1\n1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 -1\n3 3\n1 2\n3 3\n6 7\n8 6\n6 9\n4 0\n0 0\n0 2\n0 0\n0 3\n",
            "output": "1\n1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n3 3\n1 2\n3 5\n6 10\n9 6\n5 9\n4 1\n0 0\n0 -1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 1\n0 0\n3 5\n1 1\n3 3\n6 7\n8 8\n6 6\n4 1\n0 -1\n0 1\n0 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 0\n0 0\n3 3\n1 1\n3 3\n6 8\n8 0\n6 9\n4 1\n1 -1\n1 2\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 5\n1 1\n3 3\n6 7\n8 6\n6 9\n4 1\n2 -1\n0 2\n0 1\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n0 6\n1 3\n3 3\n6 7\n8 6\n6 8\n4 1\n0 0\n1 2\n0 2\n0 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 2\n3 3\n6 1\n1 6\n6 9\n4 1\n0 -1\n0 1\n1 2\n1 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 -1\n0 6\n1 1\n3 3\n6 12\n8 6\n10 9\n4 1\n0 1\n1 1\n0 2\n0 3\n",
            "output": "-1\n-1\n-1\n"
        },
        {
            "input": "3\n3 4\n0 0\n3 3\n1 1\n3 3\n6 7\n8 10\n6 5\n4 1\n0 0\n0 2\n0 2\n-1 3\n",
            "output": "1\n-1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 6\n1 2\n3 5\n6 7\n10 6\n6 9\n4 1\n0 0\n0 3\n0 2\n0 1\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 0\n0 2\n3 3\n6 7\n7 6\n6 9\n4 2\n0 0\n1 -1\n1 2\n1 3\n",
            "output": "-1\n1\n-1\n"
        },
        {
            "input": "3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n9 0\n6 9\n4 1\n0 0\n0 0\n0 4\n1 5\n",
            "output": "-1\n-1\n-1\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    long long a,b,c,d,e,f,g,h,i,j,k,l,m,n,x,y,z,t;\n    cin>>t;\n    while(t--)\n    {\n\n        cin>>a>>b;\n        pair<long long,long long>pp[a+1];\n        map<long long,long long>mp[a+1];\n        for(i=1; i<=a; i++)\n        {\n            cin>>c>>d;\n\n            pp[i]=make_pair(c,d);\n            long ct=0;\n            if(i>1)\n            {\n\n\n                for(j=1; j<i; j++)\n                {\n\n                    if(abs(pp[i].first-pp[j].first)+abs(pp[i].second-pp[j].second)<=b)\n                    {\n                       // cout<<i<<\" *** \"<<j <<\" \"<<abs(pp[i].first-pp[j].first)+abs(pp[i].second-pp[j].second)<<endl;\n                        mp[i][j]=1;\n                        mp[j][i]=1;\n\n\n                    }\n\n                }\n            }\n        }\n        f=0;\n        for(i=1; i<=a; i++)\n        {\n            if(mp[i].size()==a-1)\n            {\n\n\n                cout<< \"1\"<<endl;\n                f=1;\n                break;\n\n\n\n\n            }\n\n\n        }\n        if(f==0)\n            cout<<\"-1\"<<endl;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\n\tpublic static final int mod=1000000007;\t\n\tstatic long[][] dp;\n\tstatic Map<Integer,Integer> mp;\n\tstatic Set<Integer> set;\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t//File filein = new File(\"input.txt\");\n\t\t//BufferedReader sc=new BufferedReader(new FileReader(filein));\n\t\t//PrintWriter out=new PrintWriter(new FileWriter(\"output.txt\"));\t\t\n\n\t\t//Scanner sc=new Scanner(System.in);\n\t\tBufferedReader sc=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint tt=Integer.parseInt(sc.readLine());\n\t\tint t=tt;\n\t\tmp=new HashMap<>();\n\t\tset=new HashSet<>();\n\t\twhile(t-->0){\n\t\t\tout.flush();\n\t\t\tset.clear();\n\t\t\tString[] ip=sc.readLine().split(\" \");\n\t\t\tint n=Integer.parseInt(ip[0]);\n\t\t\tint k=Integer.parseInt(ip[1]);\n\t\t\tint[][] arr=new int[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tip=sc.readLine().split(\" \");\n\t\t\t\tint[] temp=new int[2];\n\t\t\t\ttemp[0]=Integer.parseInt(ip[0]);\n\t\t\t\ttemp[1]=Integer.parseInt(ip[1]);\n\t\t\t\tarr[i]=temp;\n\t\t\t}\n\t\t\tint[][] d=new int[n][n];\n\t\t\tboolean pos=false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\td[i][j]=Math.abs(arr[i][0]-arr[j][0])+Math.abs(arr[i][1]-arr[j][1]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tpos=true;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tif(d[i][j]>k){ pos=false; break;}\n\t\t\t\t}\n\t\t\t\tif(pos) break;\n\t\t\t}\n\n\t\t\tif(pos) out.println(1);\n\t\t\telse out.println(-1);\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t\tsc.close();\n\t}\n\n\tstatic boolean isSorted(int arr[],int i,int j){\n\t\tboolean sorted=true;\n\t\twhile(i<j){\n\t\t\tif(arr[i]>arr[i+1]){\n\t\t\t\tsorted=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn sorted;\n\t}\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint main()\n{\n  ll t;\n  cin>>t;\n  while(t--)\n  {\n    ll n,k;\n    cin>>n>>k;\n    ll a[n][2];\n    for(ll i=0;i<n;i++)\n      cin>>a[i][0]>>a[i][1];\n      ll ans=-1;\n      bool flag=0;\n    for(ll i=0;i<n;i++)\n    {\n      flag=0;\n      for(ll j=0;j<n;j++)\n      {\n        if((abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1]))>k)\n        {\n          flag=1;\n          break;\n        }\n      }\n      if(flag==0)\n      {\n        ans=1;\n        break;\n      }\n    }\n    cout<<ans<<\"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "# cook your dish here\nremaing_test_cases = int(input())\nwhile remaing_test_cases > 0:\n    points_count,K = map(int,input().split())\n    points = []\n    for i in range(points_count):\n        x,y = map(int,input().split())\n        points.append([x,y])\n    flag = 0    \n    for i in range(points_count):\n        count_power = 0\n        for j in range(points_count):\n          if (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])) <= K:\n            count_power = count_power + 1 \n        if count_power == points_count:\n            print(1)\n            flag = 1\n            break\n    if flag == 0:\n        print(-1)\n    remaing_test_cases = remaing_test_cases - 1 "
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n/*vector<int>v;\nvoid SieveOfEratosthenes(int n) \n{ \n    bool prime[n+1]; \n    memset(prime, true, sizeof(prime)); \n  \n    for (int p=2; p*p<=n; p++) \n    { \n        if (prime[p] == true) \n        { \n            for (int i=p*p; i<=n; i += p) \n                prime[i] = false; \n        } \n    } \n    for (int p=2; p<=n; p++) \n       if (prime[p]) \n          v.push_back(p);\n}\n\nint binarySearch( int l, int r, int x) \n{ \n    if (r >= l) { \n        int mid = l + (r - l) / 2; \n        if (v[mid] == x) \n            return mid; \n        if (v[mid] > x) \n            return binarySearch( l, mid - 1, x); \n\n        return binarySearch( mid + 1, r, x); \n    } \n\n} */\n\n/*\n    // adjacency matrix\nbool adjMatrixBool[N][N];\t\t\t// boolean relation\nint adjMatrix[N][N];\n \nvector<int>\tadjMatrixAll[N][N];\t\t// Keep all edges for a given pair of nodes\n \n \n// Adjacency lists\nvector< vector<int> > adjList1;\nvector< vector< pair<int, int> > > adjList2;\t// cost relation (node, cost): Select 1\n     of multiple edges\n \n*/\n \n/*\nvoid DFS_Mat(int u) {\n    vis[u] = 1;\n    for(int v=0;v<=n;v++)\n        if(adjMat[u][v] == 1 && vis[v] == 0)\n            DFS_Mat(v);\n \n}\n \nvoid DFS_List(int u) {\n    vis[u] = 1;\n    for( int v : adjList[u]){\n        if (vis[v] == 0)\n            DFS_List(v);\n    }\n \n}\n \n*/\n \n/*\nvector<int> BFS2(int s) {\n\tvector<int> len(adjList.size(), 1e6);\n\tqueue<int> q;\n\tq.push(s), len[s] = 0;\n \n\tint dep = 0, cur = s, sz = 1;\n\tfor ( ; !q.empty(); ++dep, sz = q.size()) {\n\t\twhile (sz--) {\n\t\t\tcur = q.front(), q.pop();\n\t\t\tfor(int i=0;i< adjList[cur].size();)\nif (len[adjList[cur][i]] == 1e6)\n\t\t\t\tq.push(adjList[cur][i]), len[adjList[cur][i]] = dep+1;\n\t\t} }\n\treturn len;\t//cur is the farthest node from s with depth dep\n}\n \n*/\n/*\nBacktracking(state)\n \n *\t\tif invalid(state)\t//e.g. the location is already visited or we reached to the end\n * \t\t\treturn\n *\n * \t\tif found_solution(state)\n * \t\t\tmark_solution_found\n * \t\t\treturn\n *\n * \t\tfor each child_state of state\n * \t\t\tstate' = do changes in state\n *\n * \t\t\tBacktracking(state')\n *\n * \t\t\tstate = undo changes in state'\n \n*/\n \n/*\nbool isPrime(long long n){\n   if(n < 2)\n       return false;\n   //Check all numbers from 2->root(N)\n   //If it is a divisor of n\n   for (long long i=2; i*i <= n; i++) // O(root(N))\n       if (n % i == 0)\n           return false;\n   return true;\n}\nvector<int>Primes;\nvoid Sieve(int n)\n{\n    bool prime[n+1];\n    memset(prime, true, sizeof(prime));\n \n    for (int p=2; p*p<=n; p++)\n    {\n        if (prime[p] == true)\n        {\n            for (int i=p*p; i<=n; i += p)\n                prime[i] = false;\n        }\n    }\n    for (int p=2; p<=n; p++)\n       if (prime[p])\n          Primes.push_back(p);\n}\n*/\n/*\nint GCD (int a,int b){\n   if (b==0)\n       return a;\n   return GCD (b, a % b);\n}\nint LCM(int a,int b){\n \n   return a / GCD(a, b) * b;\n // Avoid (a*b) / GCD(a,b) may overflow\n}\n \n*/\n/*\nint BinarySearch(int num) {\n   int st = 0, en = v.size() - 1;\n \n   while(st <= en) {\n       int mid = (st + en) >> 1;\n       if(v[mid] == num)\n           return mid;\n       if(v[mid] < num)\n           st = mid + 1;\n       else if(v[mid] > num)\n           en = mid - 1;\n   }\n   return -1;\n}\n*/\n/*\nCount Number of ones in binary representation\nint cntBits = __builtin_popcount(num);\n __builtin_popcountll(num) for long long\nCheck bit (Zero or One):\nif(((mask >> bitIndx) & 1) == 1)\n \nSet bit to One:\nmask |= (1 << bitIndx);\n \nSet bit to Zero:\nmask &= ~(1 << bitIndx);\n \nToggle bit :\nmask ^= (1 << bitIndx);\n \nCheck if number is Even or Odd:\n \nif(num & 1 == 1)\t\t\t(num & 1) = num%2\n   cout << \"ODD\";\n \nif(num & 1 == 0)\n   cout<<\"EVEN\";\n \n*/\n \n/*\nchar xyz[n];\n \nfor(int msk = 0; msk < (1 << n); msk++) {\n \nfor(int ind = 0; ind < n; ind++)\n \nif((msk >> ind) & 1)\n \n  cout << xyz[ind];\n \n      cout << endl;\n \n}\nif(mp.count(str))\n        {   \n            mp[str]++;\n        }\n        else {\n            mp[str]++;\n            \n        }\n        \n        priority_queue<int>pq;\n        priority_queue <int, vector<int>, greater<int>>pq2;\n*/\n/*\nmap<int,int>mpp;\n \nfor(cin>>N;i<N;i++){\n      cin>>arr[i];\n      r=mpp[arr[i]]=mpp[arr[i]-1]+1;\n      if(r>k)k=r,last=arr[i];\n}\ncout<<k<<endl,t=last-k+1;\nfor(i=0;i<N;i++)\nif(arr[i]==t)cout<<i+1<<\" \",t++;\n \n*/\n/*\n\nvector<int> adjList1[10];\nvector<int> len(10, 1e6);\nvoid BFS2(int s) {\n    \t\n\tqueue<int> q;\n\tq.push(s), len[s] = 0;\n \n\tint dep = 0, cur = s, sz = 1;\n\tfor ( ; !q.empty(); ++dep, sz = q.size()) {\n\t\twhile (sz--) {\n\t\t\tcur = q.front(), q.pop();\n\t\t\tfor(int i=0;i< adjList1[cur].size();i++)\n                if (len[adjList1[cur][i]] == 1e6)\n\t\t\t\t    q.push(adjList1[cur][i]), len[adjList1[cur][i]] = dep+1;\n\t\t} }\n\t\n}\n*/\nint main() \n{ \n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int t;\n    cin>>t;\n    while(t--){\n        int n,k;\n        cin>>n>>k;\n        int x[n],y[n];\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i];\n        }\n        int d=0,cx=0,cy=0;int v=0;\n        for(int i=0;i<n;i++){\n            cx=0,cy=0;\n            for(int j=0;j<n;j++){\n                if(i==j)continue;\n                d=abs(x[i]-x[j]);\n                d+=abs(y[i]-y[j]);\n                if(d>k){\n                    v++;break;}\n                \n            }\n            \n        }\n        if(v!=n)\n        cout<<1<<endl;\n        else cout<<-1<<endl;\n}\n}"
        },
        {
            "language": 1,
            "solution": "for test in range(input()):\n    n,k = map(int,raw_input().split())\n    p = []\n    for _ in range(n):\n        p.append(map(int,raw_input().split()))\n    for x in p:\n        a,b = x\n        f = 0\n        for y in p:\n            c,d = y\n            if abs(c-a) + abs(d-b)>k:\n                f = 1\n                break\n        if f==0:\n            print 1\n            break\n    else:\n        print -1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\n\nint n, k;\npair<int, int> adj[N];\nint ans;\n\nbool Checks(int i, int j) {\n   return abs(adj[i].first - adj[j].first) + abs(adj[i].second -adj[j].second) <= k;\n}\nint main()\n{\n   //freopen(\"in.txt\", \"r\", stdin);\n   //freopen(\".inp\", \"r\", stdin);\n   //freopen(\".out\", \"w\", stdout);\n   ios_base::sync_with_stdio(false);\n   cin.tie(0); cout.tie(0);\n\n   int t; cin >> t;\n   while(t--) {\n      cin >> n >> k;\n      for(int i = 0; i < n; ++i)\n         cin >> adj[i].first >> adj[i].second;\n\n      ans = 0;\n      bool check = false;\n      vector<bool> chos(n);\n\n      for(int k = 0; k < n; ++k) {\n         vector<int> best;\n\n         for(int i = 0; i < n; ++i) {\n            if(chos[i]) continue;\n\n            vector<int> att;\n\n            for(int j = 0; j < n; ++j) {\n               if(i == j) continue;\n               if(chos[j]) continue;\n               if(Checks(i, j)) att.push_back(j);\n            }\n\n            if(att.size() > best.size())\n               best.swap(att);\n         }\n\n         if(best.empty()) {\n            check = true; break;\n         }\n\n         for(auto x : best)\n            chos[x] = true;\n         ans++;\n         if(count(chos.begin(), chos.end(), false) == 1)\n            break;\n      }\n\n      if(!check) cout << ans << '\\n';\n      else cout << -1 << '\\n';\n   }\n\n    return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from os import path\nimport sys\n# mod = int(1e9 + 7)\n# import re  # can use multiple splits\nfrom math import ceil, floor,gcd,log\nfrom collections import defaultdict , Counter\n# from bisect import bisect_left, bisect_right\n#popping from the end is less taxing,since you don't have to shift any elements\nmaxx = float('inf')\n\nif (path.exists('input.txt')): \n\t#------------------Sublime--------------------------------------#\n\tsys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n\tI = lambda :int(sys.stdin.buffer.readline())\n\ttup= lambda : map(int , sys.stdin.buffer.readline().split())\n\tlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\n\tS = lambda: sys.stdin.readline().replace('\\n', '').strip()\n\t# def grid(r, c): return [lint() for i in range(r)]\n\t# def debug(*args, c=6): print('\\033[3{}m'.format(c), *args, '\\033[0m', file=sys.stderr)\n\tstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\n\tstar = lambda x: print(' '.join(map(str, x)))\n\n\nelse:\n\t#------------------PYPY FAst I/o--------------------------------#\n\tI = lambda :int(sys.stdin.buffer.readline())\n\ttup= lambda : map(int , sys.stdin.buffer.readline().split())\n\tlint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]\n\tS = lambda: sys.stdin.readline().replace('\\n', '').strip()\n\t# def grid(r, c): return [lint() for i in range(r)]\n\tstpr = lambda x : sys.stdout.write(f'{x}' + '\\n')\n\tstar = lambda x: print(' '.join(map(str, x)))\n# input = sys.stdin.readline\nfor _ in range(I()):\n\tn , k = tup()\n\ta=[]\n\tfor i in range(n):\n\t\tb ,c = tup()\n\t\ta.append((b,c))\n\t\n\tans = maxx\n\tfor i in range(n):\n\t\tse = set()\n\t\tf = 1\n\t\tfor j in range(n):\n\t\t\tif i != j :\n\t\t\t\tana = abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) \n\t\t\t\tif ana <= k:\n\t\t\t\t\tse.add(ana)\n\t\t\t\telse:\n\t\t\t\t\tf =0\n\t\t\t\t\tbreak\n\t\tif f:\n\t\t\tans= min(ans ,len(se))\n\t\t\tse.clear()\n\t\telse:\n\t\t\tse.clear()\n\tif ans == maxx:\n\t\tprint(-1)\n\telse:print(1)\n"
        },
        {
            "language": 3,
            "solution": "import math\nfrom collections import defaultdict\nfrom sys import stdin\ninput=stdin.readline\nT=int(input())\nfor _ in range(T):\n    n,k=map(int,input().split())\n    mat=[]\n    for i in range(n):\n        lis=list(map(int,input().split()))\n        mat.append(lis)\n    lim=len(mat)\n    f=0\n    for i in range(lim):\n        c=0\n        for j in range(lim):\n            ch=abs(mat[i][0]-mat[j][0])+abs(mat[i][1]-mat[j][1])\n            if ch<=k:\n                c+=1\n        if c==n:\n            f=1\n            break\n    if f:\n        print(1)\n    else:\n        print(-1)\n        \n            \n"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    xs=[]\n    ys=[]\n    for ii in range(n):\n        x,y=map(int,input().split())\n        xs.append(x)\n        ys.append(y)\n        #print(xs)\n        #print(ys)\n    done=False   \n    for i in range(n):\n        max_k=-1\n        for j in range(n):\n            max_k = max(max_k, abs(xs[i]-xs[j]) + abs(ys[i]-ys[j]))\n                \n        if max_k<=k:\n            print(1)\n            done=True\n            break\n                \n        \n        \n    if not done:\n        print(-1)\n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*; \n public class B{\nstatic int[] dx={-1,1,0,0};\nstatic int[] dy={0,0,1,-1};\n    static FastReader scan=new FastReader();\n   public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n  static ArrayList<Pair>es;\n  static LinkedList<Pair>edges[][];\n   static boolean prime[];\n   static void sieve(int n) \n    { \n        \n        prime = new boolean[n+1]; \n        for(int i=0;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n           \n            if(prime[p] == true) \n            { \n                \n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n          \n        \n    }  \n  \n public static boolean areSame(int []arr)\n    {\n        // Put all array elements in a HashSet\n        Set<Integer>s=new HashSet<Integer>();\n        for(int i=0;i<arr.length;i++)\n            s.add(arr[i]);\n\n \n        // If all elements are same, size of\n        // HashSet should be 1. As HashSet contains only distinct values.\n        return (s.size() == 1);\n    }\n   \n\n    \n     public static int lowerBound(long[] array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = (low + high) / 2;\n            //checks if the value is less than middle element of the array\n            if (value <= array[mid]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    public static int upperBound(long[] array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = low+(high-low) / 2;\n            if ( array[mid]>value) {\n                high = mid ;\n            } else {\n                low = mid+1;\n            }\n        }\n        return low;\n    }\nstatic long mod(long x,long y)\n    {\n        if(x<0)\n            x=x+(-x/y+1)*y;\n        return x%y;\n    }\n    \n    \n    static boolean isPowerOfTwo(int n)\n{\n    if(n==0)\n    return false;\n \nreturn (int)(Math.ceil((Math.log(n) / Math.log(2)))) == \n       (int)(Math.floor(((Math.log(n) / Math.log(2)))));\n}\nstatic int CeilIndex(int A[], int l, int r, int key) \n    { \n        while (r - l > 1) { \n            int m = l + (r - l) / 2; \n            if (A[m] >= key) \n                r = m; \n            else\n                l = m; \n        } \n  \n        return r; \n    } \n  \n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n        // Add boundary case, when array size is one \n  \n        int[] tailTable = new int[size]; \n        int len; // always points empty slot \n  \n        tailTable[0] = A[0]; \n        len = 1; \n        for (int i = 1; i < size; i++) { \n            if (A[i] < tailTable[0]) \n                // new smallest value \n                tailTable[0] = A[i]; \n  \n            else if (A[i] >= tailTable[len - 1]) \n                // A[i] wants to extend largest subsequence \n                tailTable[len++] = A[i]; \n  \n            else\n                // A[i] wants to be current end candidate of an existing \n                // subsequence. It will replace ceil value in tailTable \n                tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n        } \n  \n        return len; \n    } \nstatic boolean isprime(long x)\n           {\n            for(long i=2;i*i<=x;i++)\n                if(x%i==0)\n                    return false;\n                return true;\n           }\n           static long arr[];\n      \n        static int k;\n\n static boolean can(long x)\n {\n    int bl=0;\n    int i=0;\n    for(int kas=0;i<n&&kas<k;kas++)\n    {\n        long hasta=arr[i];\n        hasta+=x*2;\n        while(i<n-1&&arr[i+1]<=hasta)i++;\n        i++;\n        \n    }\nreturn (i>=n);\n }\nstatic int n,m;\nstatic boolean vis[][];\nstatic boolean light[][];\nstatic boolean e(int x,int y)\n{\n    return (x>=0&&x<n&&y>=0&&y<n);\n}\nstatic int ans=0;\nstatic void dfs(int x,int y)\n{\n    if(vis[x][y])\n        return;\n    vis[x][y]=true;\n   //light[x][y]=true;\n    for(Pair p:edges[x][y])\n    {\n        if(!light[p.x][p.y]){\n            light[p.y][p.y]=true;\n            ans++;\n            dfs(p.x,p.y);\n                    }\n    }\n    for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(e(nx,ny))\n        dfs(nx,ny);\n}\n\n}\nstatic int dist(int x1,int y1,int x2,int y2){\nreturn Math.abs(x1-x2)+Math.abs(y1-y2);\n}\nstatic int x;\nstatic int min(int y,int k)\n{\n    if(y==x)\n        return 0;\n    return Math.min(min(y+k,k++)+1,min(y-1,k)+1);\n}\nstatic boolean is(int arr[])\n{\n    for(int i=1;i<arr.length;i++)\n        if(arr[i]<arr[i-1])\n            return false;\n        return true;\n}\n  static void reverse(int myArray[]) \n    { \n        Collections.reverse(Arrays.asList(myArray)); \n    } \n    static boolean isPerfect(long n) \n{ \n    // To store sum of divisors \n    long sum = 1; \n  \n    // Find all divisors and add them \n    for (long i = 2; i * i <= n; i++) \n    { \n        if (n % i==0) \n        { \n            if(i * i != n) \n                sum = sum + i + n / i; \n            else\n                sum = sum + i; \n        } \n    }  \n    // If sum of divisors is equal to \n    // n, then n is a perfect number \n    if (sum == n && n != 1) \n        return true; \n  \n    return false; \n} \n    public static void main(String[] args)  throws IOException \n\n{\n//java.util.Scanner scan=new java.util.Scanner(new File(\"mootube.in\"));\n //PrintWriter out = new PrintWriter (new FileWriter(\"mootube.out\"));\n//java.util.Scanner scan=new java.util.Scanner(new File(\"lightson.in\"));\n//PrintWriter out = new PrintWriter (new FileWriter(\"lightson.out\"));\n    \n\nint t=scan.nextInt();\nouter:while(t-->0)\n{\n    int n=scan.nextInt(),k=scan.nextInt();\n    ArrayList<Pair>arr=new ArrayList<Pair>();\n    for(int i=0;i<n;i++)\n        arr.add(new Pair(scan.nextInt(),scan.nextInt()));\n    Collections.sort(arr);\n    ArrayList<Integer>dists=new ArrayList<Integer>();\n   for(int i=0;i<n;i++){\n    int c=0;\n        for( int j=0;j<n;j++)\n    {\n        if(i!=j)\n        {\n            int dist=Math.abs(arr.get(i).x-arr.get(j).x)+Math.abs(arr.get(i).y-arr.get(j).y);\n            if(dist<=k)\n                c++;\n        }\n    }\n    if(c==n-1){     \n       out.println(1);\n       continue outer;\n    }}    \n  out.println(-1);\n\n}\nout.close();\n}\nstatic class special{\n    char c;\n    int id;\n    special(char c,int id)\n    {\n        this.id=id;\n       this.c=c;\n    }\n   \n}\n public static  long pow(long b, long e) {\n            long r = 1;\n            while (e > 0) {\n                if (e % 2 == 1) r = r * b ;\n                b = b * b;\n                e >>= 1;\n            }\n            return r;\n        }\n\nprivate static void sort(long[] arr) {\n        List<Long> list = new ArrayList<>();\n        for (long object : arr) list.add(object);\n        Collections.sort(list);\n        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);\n    }\n public static class FastReader {\n        BufferedReader br;\n        StringTokenizer root;\n        \n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (root == null || !root.hasMoreTokens()) {\n                try {\n                    root = new StringTokenizer(br.readLine());\n                } catch (Exception addd) {\n                    addd.printStackTrace();\n                }\n            }\n            return root.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (Exception addd) {\n                addd.printStackTrace();\n            }\n            return str;\n        }\n         public int[] nextIntArray(int arraySize) {\n            int array[] = new int[arraySize];\n \n            for (int i = 0; i < arraySize; i++) {\n                array[i] = nextInt();\n            }\n \n            return array;\n        }\n}\npublic static class Pair implements Comparable<Pair>{\n         int x;\n        int  y;\n        int id;\n        public Pair(){}\n        public Pair(int x1, int y1,int id) {\n            x=x1;\n            y=y1;\n            this.id=id;\n        }\n        public Pair(int x1, int y1) {\n            x=x1;\n            y=y1;\n        \n        }\n        @Override\n        public int hashCode() {\n            return (int)(x + 31 * y);\n        }\n        public String toString() {\n            return x + \" \" + y;\n        }\n        @Override\n        public boolean equals(Object o){\n            if (o == this) return true;\n            if (o.getClass() != getClass()) return false;\n            Pair t = (Pair)o;\n            return t.x == x && t.y == y;\n        }\n        public  int compareTo(Pair o)\n        {\n            if(x==o.x)\n                return y-o.y;\n            return x-o.x;\n        }\n}\n\n}\n\n\n\n\n\n\n\n"
        },
        {
            "language": 1,
            "solution": "\n# Author : raj1307 - Raj Singh\n# Date   : 06.12.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\ndef main():\n\n\n\n    for _ in range(ii()):\n\n\n        \n        n,k=mi()\n\n        a=[]\n        for i in range(n):\n            a.append(li())\n\n\n\n        f=1\n        for i in range(n):\n\n            f=1\n\n            for j in range(n):\n\n                if abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])>k:\n                    f=-1\n                    break\n\n            if f==1:\n                break\n\n\n        if f==1:\n            print(1)\n        else:\n            print(-1)\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <stack>\n#include <sstream>\n#include <queue>\n#include <list>\n#include <climits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define all(v) v.begin(),v.end()\n\nstruct p {\n    int a;\n    int b;\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n    int tc = 1;\n    cin>>tc;\n    while (tc--) {\n        int n, k, j; cin >> n >> k;\n        vector<p> vec(n);\n        bool ok = 0;\n        for (p& j : vec) {\n            cin >> j.a >> j.b;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (j = 0; j < n; ++j) {\n                if (abs(vec[i].a - vec[j].a) + abs(vec[i].b - vec[j].b)>k)\n                    break;\n            }\n            if (j == n) {\n                ok = 1; break;\n            }\n        }\n        if (ok && k)cout << 1 << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution {\n    static Scanner in =new Scanner(System.in);\n    static final Random random=new Random();\n    static int mod=1000_000_007;\n    public static void main(String[] args) {\n     int tt=in.nextInt();//in.nextLine();\n      outer: while(tt-->0) {\n          int n=in.nextInt();long res=1;\n          int k=in.nextInt();int a[][]=new int[n][2];\n          for(int i=0;i<n;i++){\n              int a1=in.nextInt();int b=in.nextInt();\n              a[i][0]=a1;a[i][1]=b;\n          }//long max=0;\n          for(int i=0;i<n;i++){\n              long max=0;\n              for(int j=0;j<n;j++){\n                  if(i!=j){\n                      max=Math.max(max,Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1]));\n                  }\n              }\n              if(max<=k){System.out.println(1);continue outer;}\n          }\n\n          System.out.println(-1);\n        }\n    }\n    static int nCr(int n,int r,int p){\n        if (r == 0) return 1; \n        if(r==1)return n;\n        return ((int)fact(n)*modInverse((int)fact(r),p)%p * modInverse((int)fact(n-r),p) % p)%p; \n    }\n    static int modInverse(int n, int p) { \n        return power(n, p - 2, p); \n    } \n    static int power(int x,int y,int p) { \n        int res = 1;\n        x= x % p;\n        while (y>0) {\n            if (y%2==1) \n                res= (res *x)% p;\n            y= y >> 1;\n            x= (x * x)% p; \n        }\n        return res; \n    } \n    static int find(int p){\n        int m=0;int l=0,r=p;\n        while(l<=r){\n            int mid=l+(r-l)/2;\n            if(mid!=r)m++;\n            if(mid==r)break;\n            if(mid<r)l=mid+1;\n        }return m;\n    }\n    static int[]readAr(int n) {\n        int[] a=new int[n];\n        for (int i=0; i<n; i++) {a[i]=in.nextInt();}\n        return a;\n\t}\n    static int fact(int k){\n        long[]f=new long[10001];f[1]=1;\n        for(int i=2;i<10001;i++){\n            f[i]=(i*f[i-1]% mod);\n        }\n        return (int)f[k];\n    }\n\tstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void reverse(int []a){\n        int n= a.length;\n        for(int i=0;i<n/2;i++){\n            int temp=a[i];\n            a[i]=a[n-i-1];\n            a[n-i-1]=temp;\n            a[i]=a[i];\n        }\n        //debug(a);\n\t}\n\tstatic void debug(int []a) {\n        for (int i=0; i<a.length;i++) System.out.print(a[i]+\" \");\n\t}\n\tstatic void print(List<Integer>s) {\n        for(int x:s) System.out.print(x+\",\");\n        System.out.println();\n\t}\n\tstatic int gcd(int a, int b) {\n        return b==0 ? a : gcd(b, a % b);\n\t}\n    static int find_max(int []a){\n        int m=Integer.MIN_VALUE;\n        for(int x:a)m=Math.max(x,m);\n        return m;\n    }\n    static int find_min(int []a){\n        int m=Integer.MAX_VALUE;\n        for(int x:a)m=Math.min(x,m);\n        return m;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h> \nusing namespace std;\n \n#define ll long long int\n#define absdiff(a,b) (a>b)?a-b:b-a\n#define mp make_pair \n#define pb push_back\n#define ff first\n#define ss second\n#define fast  ios_base::sync_with_stdio(false);cin.tie(0);\n#define MOD 1000000007\n#define ll_MAX 19223372036859\n#define endl \"\\n\"\nll fast_expo(ll x,ll p){\n  if(p==0) return 1;\n  else if(p%2==0){ ll t=fast_expo(x,p/2)%MOD;return (t*t)%MOD;} \n  else return (x*(fast_expo(x,p-1))%MOD)%MOD;}\n\nint main(){\n  fast\n  #ifndef ONLINE_JUDGE\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n  #endif\n  \n  ll t_c; t_c = 1;\n  cin >> t_c;\n\n  for(ll t_i = 0; t_i < t_c; ++t_i){\n    ll n, k; cin >> n >> k;\n    ll ans = -1;\n\n    vector<ll> AdjL[n];\n    pair<ll, ll> arr[n];\n    for(ll i = 0; i < n; ++i){\n      cin >> arr[i].ff >> arr[i].ss;\n    }\n\n    for(ll i = 0; i < n; ++i){\n      ll flag = 1;\n      for(ll j = 0; j < n; ++j){\n        ll dis = abs(arr[j].ff - arr[i].ff) + abs(arr[j].ss - arr[i].ss);\n        if(dis > k){\n          flag = 0;\n          break;\n        }\n      }\n      if(flag){\n        ans = 1;\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
        },
        {
            "language": 3,
            "solution": "def ass(a, b):\n\tif a != b: print(f\"Assertion error: {a} != {b}\")\n\telse: print('OK')\ndef number(): return int(input())\ndef numbers(): return [int(item) for item in input().split()]\ndef word():    return input()\ndef words():   return [item for item in input().split()]\ndef dump(lst):\n\tfor i, item in enumerate(lst): print(i, item)\ndef binsearch(arr, a, b):\n\tm = (a + b) // 2\n\tif a >= b: return a - 1 if arr[a] == 0 else a\n\treturn binsearch(arr, a, m - 1) if arr[m] == 0 else binsearch(arr, m + 1, b)\n\ndef f(k,balls):\n\tflag = 1\n\tfor x0,y0 in balls:\n\t\tfor x1,y1 in balls:\n\t\t\tif abs(x0-x1) + abs(y0-y1) > k:\n\t\t\t\tflag = -1\n\t\t\t\tbreak\n\t\telse:\n\t\t\tflag = 1\n\t\t\tbreak\n\treturn flag\n\nfor t in range(number()):\n\tn,k = numbers()\n\tballs = [numbers() for i in range(n)]\n\tprint(f(k,balls))\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = map(int, input().split())\n    li = []\n    ans = -1\n    for i in range(n):\n        li.append(list(map(int, input().split())))\n    for i in range(n):\n        ok = True\n        for j in range(n):\n            if i!=j and k<abs(li[i][0]-li[j][0])+ abs(li[i][1]-li[j][1]):\n                ok = False\n                break\n        if ok:\n            ans = 1\n            break\n    print(ans)\n        \n    \n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.List;\n/*\n        author : Aditya Aggarwal\n\n        LinkedIn : https://www.linkedin.com/in/aditya7861/\n\n        ' The Dawn does not come twice to awaken the man '  ---->>>  ( My Motivation )\n\n        Believe In yourself, Everything is possible.\n\n        Never Give Up ... Failure is the biggest success\n */\n\npublic class Main\n{\n\n    static class AdityaFastIO\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        BufferedReader br;\n        StringTokenizer st;\n\n        public AdityaFastIO()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public AdityaFastIO(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        String word()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n)\n    {\n        long result = 1;\n        while (n > 0)\n        {\n            if (n % 2 == 1)\n            {\n                result = result * x % MOD;\n            }\n            n = n / 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(String sa, String sb)\n    {\n        long a = 0, b = 0;\n\n        for (int i = 0; i < sa.length(); i++)\n        {\n            a = (a * 10 + (sa.charAt(i) - '0')) %\n                    MOD;\n        }\n\n        for (int i = 0; i < sb.length(); i++)\n        {\n            b = (b * 10 + (sb.charAt(i) - '0')) %\n                    (MOD - 1);\n        }\n\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (a==0) return b;\n        else return gcd(b%a,a);\n    }\n\n    static long lcm(long a, long b)\n    {\n        return (a*b)/gcd(a,b);\n    }\n\n    static long lower_bound(List<Long> list, long k)\n    {\n        int s = 0;\n        int e = list.size();\n\n        while (s!=e)\n        {\n            int mid = (s+e)>>1;\n\n            if (list.get(mid)<k) s = mid+1;\n            else e = mid;\n        }\n\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static int upper_bound(List<Long> list, long k)\n    {\n        int s = 0;\n        int e = list.size();\n\n        while (s!=e)\n        {\n            int mid = (s+e)>>1;\n\n            if (list.get(mid)<=k) s = mid+1;\n            else e = mid;\n        }\n\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static void print(Object o) throws IOException {\n        OutputStream out = new BufferedOutputStream(System.out);\n\n        out.write((o+\"\").getBytes());\n\n        out.flush();\n    }\n\n    static void println(Object o) throws IOException {\n        OutputStream out = new BufferedOutputStream(System.out);\n        out.write((o+\"\\n\").getBytes());\n        out.flush();\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>>graph, int edge1, int edge2)\n    {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    static class Pair<X,Y>\n    {\n        public X first;\n        public Y second;\n\n        Pair(X first, Y second)\n        {\n            this.first = first;\n            this.second = second;\n        }\n\n        public static <X,Y> Pair <X,Y> of (X a, Y b)\n        {\n            return new Pair<>(a,b);\n        }\n\n        public String toString()\n        {\n            return \"(\"+first+\",\"+second+\")\";\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Integer> list)\n    {\n        if (list.size() == 0 || list.size() == 1) return true;\n\n        for (int i=1;i<list.size();i++) if (list.get(i)>list.get(i-1)) return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) throws java.lang.Exception\n    {\n        try\n        {\n            AdityaFastIO r = new AdityaFastIO();\n\n            try (OutputStream out = new BufferedOutputStream(System.out))\n            {\n\n                boolean tc = true;\n\n                int testcases = tc?r.ni():1;\n\n                while (testcases -- > 0)\n                {\n                    int n = r.ni();\n                    long k = r.nl();\n\n                    long[][] mat = new long[n][2];\n\n                    for (int i=0;i<n;i++)\n                    {\n                        mat[i][0] = r.nl();\n                        mat[i][1] = r.nl();\n                    }\n\n                   // boolean ff = true;\n\n                    boolean gg = false;\n\n                    for (int i=0;i<n;i++)\n                    {\n\n                        boolean ff = true;\n\n                        for (int j=0;j<n;j++)\n                        {\n                            if (Math.abs(mat[i][0]-mat[j][0])+Math.abs(mat[i][1]-mat[j][1])>k)\n                            {\n                                ff = false;\n                                break;\n                            }\n                        }\n\n                        if (ff)\n                        {\n                            out.write((1+\"\\n\").getBytes());\n                            gg = true;\n                            break;\n                        }\n                    }\n\n\n                    if (!gg)\n                    out.write((-1+\"\\n\").getBytes());\n                }\n            }\n        }\n        catch(Exception e){}\n        finally{}\n    }\n}\n\n/*\n        n = 8\n\n        1 -2 -3 -4 -5 -6 -7 -8\n */\n\n\n//(()) () (()((()()()())))\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    a = []\n    yes = 1\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(n):\n        yes = 0\n        for r in range(n):\n            if abs(a[i][0] - a[r][0]) + abs(a[i][1] - a[r][1]) > k:\n                yes = 1\n        if yes == 0:\n            break\n    if yes == 0:\n        print(1)\n    else:\n        print(-1)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\n \npublic class A {\n \n\tstatic final int mod = 1000000007;\n\tstatic final int temp = 998244353;\n\tstatic final long MOD = 1000000007;\n\tstatic final long M = (long)1e9+7;\n \n\t\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tint first, second;\n\t\tpublic Pair(int aa, int bb)\n\t\t{\n\t\t\tfirst = aa; second = bb;\n\t\t}\n\t\tpublic int compareTo(Pair p)\n\t\t{\n//\t\t\tif(a == p.a) return b - p.b;\n//\t\t\treturn a - p.a;\n\t\t\tif(first == p.first) return (int)(second - p.second);\n\t\t\treturn (int)(first - p.first);\n\t\t}\n\t}\n\t\n\t/* IO for List of Arrays\n\t * ArrayList<Integer>[] list = new ArrayList[m];\n\t\tfor(int i = 0;i<m;i++)\n\t\t{\n\t\t\tlist[i] = new ArrayList<>();\n\t\t}\n\t */\n\t\n\t/*\n\t * IO FOR 2D GRID IN JAVA\n\t * char[][] arr = new char[n][m]; //grid in Q.\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tchar[] nowLine = sc.next().toCharArray();\n\t\t\t\tfor(int j = 0;j<m;j++)\n\t\t\t\t{\n\t\t\t\t\tarr[i][j] = nowLine[i];\n\t\t\t\t}\n\t\t\t}\n\t * */\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tList<Integer> readList(int n)\n\t\t{\n\t\t\tList<Integer> l = new ArrayList<>();\n\t\t\tfor(int i = 0;i<n;i++) l.add(nextInt());\n\t\t\treturn l;\n\t\t}\n\t\t\n\t\tlong[] longReadArray(int n) throws IOException {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\t\n \n\tpublic static boolean isPrime(long n) {\n\t\tif(n == 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfor(long i = 2;i*i<=n;i++)\n\t\t{\n\t\t\tif(n%i == 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static List<Integer> Sieve(int n)\n\t{\n\t\tboolean prime[] = new boolean[n+1];\n\t\tArrays.fill(prime, true);\n\t\tList<Integer> l = new ArrayList<>();\n\t\t\n\t\t\n\t\tfor (int p=2; p*p<=n; p++) \n\t\t{ \n\t\t\tif (prime[p] == true) \n\t\t\t{ \t\n\t\t\t    for(int i=p*p; i<=n; i += p) \n\t\t\t\t{\n\t\t\t\t    prime[i] = false; \n\t\t\t\t}\t\n\t\t\t} \n\t\t} \n \n\t\tfor (int p=2; p<=n; p++) \n\t\t{\n\t\t    if (prime[p] == true)\n\t\t    {\n\t\t       l.add(p); \n\t\t    }\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\tpublic static int gcd(int a, int b)\n\t{\n\t\tif(b == 0)\n\t\t return a;\n\t\t\n\t\telse\n\t\treturn gcd(b,a%b);\n\t} \n \n\tpublic static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n\t\n\tpublic static long LongGCD(long a, long b)\n\t{\n\t\tif(b == 0)\n\t\t\t return a;\n\t\t\t\n\t\t\telse\n\t\t\treturn LongGCD(b,a%b);\n\t}\n\t\n\tpublic static long LongLCM(long a, long b)\n    {\n        return (a / LongGCD(a, b)) * b;\n    }\n\t\n\tpublic static int phi(int n)  //euler totient function\n    { \n        int result = 1; \n        for (int i = 2; i < n; i++) \n            if (gcd(i, n) == 1) \n                result++; \n        return result; \n    }\n\t\n\t    \n\tpublic static int[] computePrefix(int arr[], int n)\n\t{\n\t\tint[] prefix = new int[n];\n\t\tprefix[0] = arr[0];\n\t\tfor(int i = 1;i<n;i++)\n\t\t{\n\t\t\tprefix[i] = prefix[i-1]+arr[i];\n\t\t}\n\t\t\n\t\treturn prefix;\n\t}\n\t\n\t\n\tpublic static long fastPow(long x, long n) //include mod at each step if asked and in args of fn too\n\t{\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\telse if(n%2 == 0)\n\t\t\treturn fastPow(x*x,n/2);\n\t\telse\n\t\t\treturn x*fastPow(x*x,(n-1)/2);\n\t}\n\t\n\t\n\t   public static long power(long x, long y, long p)\n\t    {\n\t \n\t        long res = 1;\n\t \n\t        x = x % p;\n\t \n\t        while (y > 0) {\n\t            if (y % 2 == 1)\n\t                res = (res * x) % p;\n\t \n\t            y = y >> 1; \n\t            x = (x * x) % p;\n\t        }\n\t \n\t        return res;\n\t    }\n\t   \n\t   static long modInverse(long n, long p)\n\t    {\n\t        return power(n, p - 2, p);\n\t    }\n\t \n\t    // Returns nCr % p using Fermat's little theorem.\n\t    \n\t    public static long nCr(long n, long r,\n\t                             long p)\n\t    {\n\t          if (n<r) \n\t              return 0;\n\t          \n\t        if (r == 0)\n\t            return 1;\n\t \n\t        long[] fac = new long[(int)(n) + 1];\n\t        fac[0] = 1;\n\t \n\t        for (int i = 1; i <= n; i++)\n\t            fac[i] = fac[i - 1] * i % p;\n\t \n\t        return (fac[(int)(n)] * modInverse(fac[(int)(r)], p)\n\t                % p * modInverse(fac[(int)(n - r)], p)\n\t                % p)\n\t            % p;\n\t    }\n\t    \n\t    public static long[] modInvArr(long n, long mod)\n\t    {\n\t    \tlong[] ans = new long[(int)(n)+1];\n\t\t\tans[1] = 1;\n\t\t\tfor(int i = 2;i <= n;i++)\n\t\t\t{\n\t\t\t\tans[i] = (mod - (mod/i) * ans[(int)(mod%i)])%mod;\n\t\t\t}\n\t\t\treturn ans;\n\t    }\n \n\t\tpublic static int LowerBound(int a[], int x) {\n\t\t\t  int l=-1,r=a.length;\n\t\t\t  while(l+1<r) {\n\t\t\t    int m=(l+r)>>>1;\n\t\t\t    if(a[m]>=x) r=m;\n\t\t\t    else l=m;\n\t\t\t  }\n\t\t\t  return r;\n\t\t\t}\n\t\t\n\t\t\n\t\tpublic static int UpperBound(int a[], int x) {\n\t\t    int l=-1;\n\t\t    int r=a.length;\n\t\t    while(l+1<r) {\n\t\t       int m=(l+r)>>>1;\n\t\t       if(a[m]<=x) l=m;\n\t\t       else r=m;\n\t\t    }\n\t\t    return l+1;\n\t\t}\n\t\t\n\t\tpublic static void Sort(int[] a) {\n\t\t\tList<Integer> l=new ArrayList<>();\n\t\t\tfor (int i:a) l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\t//Collections.reverse(l);  //Use to Sort decreasingly \n\t\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t\t}\n\t\t\n\t\t//Modular Operations for Addition and Multiplication. \n\t\t\n\t\t   public static long perfomMod(long x){\n\t\t        return ((x%M + M)%M);\n\t\t    }\n\t\t   public static long addMod(long a, long  b){\n\t\t        return perfomMod(perfomMod(a)+perfomMod(b));\n\t\t    }\n\t\t   public static long mulMod(long  a, long b){\n\t\t        return perfomMod(perfomMod(a)*perfomMod(b));\n\t\t   }\n\t\t\n\t\tpublic static boolean isValid(String s1, String s2) \n\t\t\t{ \n\t\t\tint m = s1.length(), n = s2.length();\n\t\t\t\tint j = 0; \n\t\t\t\tfor (int i = 0; i < n && j < m; i++) \n\t\t\t\t\tif (s1.charAt(j) == s2.charAt(i)) \n\t\t\t\t\t\tj++; \n\n\t\t\t\treturn (j == m); \n\t\t\t} \n\t\t\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tReader sc=new Reader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0)\n\t\t{\n\t\t\tboolean flag = false;\n\t\t\tint n = sc.nextInt(),k = sc.nextInt();\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int j = 0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tint diff = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n\t\t\t\t\tif(diff <= k) c++;\n\t\t\t\t}\n\t\t\t\tif(c == n) flag = true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((flag == true ? 1 : -1));\n\t\t}\n\t\tout.close();\n\t}\n \n\t\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.IOException;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    //static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) throws IOException {\n\n        int t = in.nextInt();\n        while(t-->0){\n            int n = in.nextInt();\n            int k = in.nextInt();\n            Pair[] arr = new Pair[n];\n\n            for(int i=0;i<n;i++){\n                arr[i] = new Pair(in.nextInt(),in.nextInt());\n            }\n            boolean flag = false;\n            for(int i = 0;i<n;i++){\n                int max = -1;\n                for(int j=0;j<n;j++){\n                    int d = distance(arr[i],arr[j]);\n                    if(max<d){\n                        max = d;\n                    }\n                }\n                if(max <= k){\n                    flag = true;\n                    System.out.println(1);\n                    break;\n                }\n            }\n            if (!flag){\n                System.out.println(-1);\n            }\n\n        }\n\n\n\n    }\n    public static int distance(Pair p1,Pair p2){\n        int x = Math.abs(p1.getX()-p2.getX()) + Math.abs(p1.getY()-p2.getY());\n\n        return x;\n    }\n    public static class Pair{\n        private int x;\n        private int y;\n\n        public Pair(int x,int y){\n            this.x = x;\n            this.y = y;\n        }\n        public int getX(){\n            return this.x;\n        }\n        public int getY(){\n            return this.y;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define ll long long\n#define vll vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define sll set<ll>\n#define ins insert\n#define rep(i,n) for(int i=0;i<n;i++)\n#define vpp vector<pair<int,int>>\n#define mp make_pair\n#define ft first\n#define sc second\n#define gp \" \";\n#define MAX 9999999\n#define MOD 1000000007\n#define mnn(v2) *min_element(v2.begin(),v2.end());\n#define mxx(v2) *max_element(v2.begin(),v2.end());\nusing namespace std;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t=1;\n    cin>>t;\n    while(t--)\n    {\n        ll x,y,i,j,k,c=0,mx=0,m,n;\n        cin>>n>>k;\n        ll a[n],b[n];\n        for(i=0; i<n; i++)\n            cin>>a[i]>>b[i];\n        for(i=0; i<n; i++)\n        {\n            c=1;\n            for(j=0; j<n; j++)\n            {\n                if(abs(a[i]-a[j])+abs(b[i]-b[j])>k)\n                {\n                    c=0;\n                    break;\n                }\n\n            }\n            if(c)\n                break;\n        }\n        if(c)\n            cout<<1<<endl;\n        else\n            cout<<-1<<endl;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\n\nint main(){\n\tint t;\n\tcin>>t;\n\t\n\t\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\t\n\t\tpair<int, int> l[n];\n\t\tfor (int i=0; i<n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\t\n\t\t\tl[i]=make_pair(x,y);\n\t\t}\n\t\t\n\t\t\n\t\tint ans=-1;\n\t\t\n\t\tfor (int i=0; i<n; i++){\n\t\t\tbool pode=true;\n\t\t\tfor (int j=0; j<n; j++){\n\t\t\t\tif (abs(l[i].first-l[j].first)+abs(l[i].second-l[j].second)>k) pode=false;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif (pode) ans=1;\n\t\t}\n\t\t\n\t\t\n\t\tcout<<ans<<endl;\n\t\t\n\t\n\t}\n\n\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\n\ndef solve(N, K, balls):\n    for x1, y1 in balls:\n        bad = False\n        for x2, y2 in balls:\n            if x1 == x2 and y1 == y2:\n                continue\n            if abs(x1 - x2) + abs(y1 - y2) > K:\n                bad = True\n                break\n        if not bad:\n            return 1\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    TC = int(input())\n    for tc in range(1, TC + 1):\n        N, K = [int(x) for x in input().split()]\n        balls = [[int(x) for x in input().split()] for i in range(N)]\n        ans = solve(N, K, balls)\n        print(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport static java.lang.Math.*;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc =new FastScanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint T = sc.nextInt();\n\t\twhile(T-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tPoint[] points = new Point[n];\n\t\t\tfor(int i = 0 ; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tpoints[i] = new Point(x, y);\n\t\t\t}\n\t\t\tif(possible(points, n, k)) {\n\t\t\t\tpw.println(1);\n\t\t\t}else {\n\t\t\t\tpw.println(-1);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\t\t\n\t\tpw.close();\n\t}\n\t\n\tprivate static boolean possible(Point[] points, int n, int k) {\n\t\tfor(int i = 0 ; i < n; i++) {\n\t\t\tboolean all = true;\n\t\t\tfor(int j = 0 ; j < n; j++) {\t\t\t\t\t\n\t\t\t\tall &= abs(points[j].x - points[i].x) + abs(points[j].y - points[i].y) <= k;\n\t\t\t}\n\t\t\tif(all) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic class Point{\n\t\tint x; \n\t\tint y;\n\t\t\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\t\n\t}\n\t\n\tstatic void debug(Object... O) {\n\t\tSystem.out.println(Arrays.deepToString(O));\n\t}\n\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import Counter, defaultdict, deque\nimport bisect\nfrom sys import stdin, stdout\nfrom itertools import repeat\nimport math\n\n\ndef inp(force_list=False):\n    re = map(int, raw_input().split())\n    if len(re) == 1 and not force_list:\n        return re[0]\n    return re\n\ndef inst():\n    return raw_input().strip()\n\ndef gcd(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nmod = 1000000007\n\ndef my_main():\n    kase = inp()\n    pans = []\n    for i in range(kase):\n        n, k = inp()\n        da = [inp() for i in range(n)]\n        for i in range(n):\n            ok = 1\n            for j in range(n):\n                if abs(da[i][0] - da[j][0]) + abs(da[i][1] - da[j][1]) > k:\n                    ok = -1\n            if ok == 1:\n                break\n        print ok\n    # print '\\n'.join(pans)\n\nmy_main()\n"
        },
        {
            "language": 3,
            "solution": "import math\ni1=int(input())\nfor z in range(i1):\n    i = [int(a) for a in input().split()]\n    t=[]\n    a1=0\n    for x in range(i[0]):\n        t1= [int(a) for a in input().split()]\n        t.append(t1)\n    for x in t:\n        s=0\n        for z in t:\n            if math.fabs(x[0]-z[0])+math.fabs(x[1]-z[1])>i[1]:\n                s=1\n            if s==1:\n                break\n        if s==0:\n            a1=1\n            print(1)\n            break\n    if a1==0:\n      print(-1)\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  ballsofsteel.py\n#  \n#  Copyright 2020 grant <grant@DESKTOP-EBFFL3R>\n#  \n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 2 of the License, or\n#  (at your option) any later version.\n#  \n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n#  MA 02110-1301, USA.\n#  \n#  \n\n\ndef main(args):\n\tt = int(input());\n\tp = [];\n\tks = [];\n\t\n\tfor i in range(t):\n\t\tp.append([]);\n\t\tks.append(input().split(' '));\n\t\tn = int(ks[i][0]);\n\t\tfor j in range(n):\n\t\t\tp[i].append([]);\n\t\t\tl = input().split(' ');\n\t\t\tp[i][j].append(int(l[0]));\n\t\t\tp[i][j].append(int(l[1]));\n\t\n\tfor i in range(t):\n\t\tn = int(ks[i][0]);\n\t\tk = int(ks[i][1]);\n\t\tfor j in range(n):\n\t\t\tcounter = 0;\n\t\t\tfor m in range(n):\n\t\t\t\tif cityblock(p[i][j], p[i][m]) <= k:\n\t\t\t\t\tcounter = counter + 1;\n\t\t\tif counter == n:\n\t\t\t\tprint(1);\n\t\t\t\tbreak;\n\t\tif counter != n:\n\t\t\tprint(-1);\t\n\ndef cityblock(p1, p2):\n\treturn abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);\n\n\nif __name__ == '__main__':\n    import sys\n    sys.exit(main(sys.argv))\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:[*map(int,input().split())]\nexec(R()[0]*'n,k=R();a=[R()for _ in[0]*n];print(+(min(max(abs(x-u)+abs(y-v)for x,y in a)for u,v in a)<=k)or-1);')"
        },
        {
            "language": 3,
            "solution": "def check(ar,k):\n    for i in range(len(ar)):\n        c=0\n        x=ar[i][0]\n        y=ar[i][1]\n        for j in range(len(ar)):\n            xx=ar[j][0]\n            yy=ar[j][1]\n            if abs(xx-x) + abs(yy-y)<=k:\n                c+=1\n            else:\n                break\n        if c==len(ar):\n            return 1\n    return -1\ny122=int(input())\nfor _ in range(y122):\n    n,k=map(int,input().split())\n    ar=[]\n    xl='xxx'\n    xr='xxx'\n    yl='xxx'\n    yr='xxx'\n    for i in range(n):\n        ar.append(list(map(int,input().split())))\n    print(check(ar,k))\n        "
        },
        {
            "language": 3,
            "solution": "def dist(x, y):\n    return sum(abs(x[i] - y[i]) for i in range(2))\n\nt = int(input())\nfor __ in range(t):\n    n, k = map(int, input().split())\n    ls = []\n    for __ in range(n):\n        ls.append(tuple(map(int, input().split())))\n    ok = False\n    for i in range(n):\n        flag = False\n        for j in range(n):\n            if dist(ls[i], ls[j]) > k:\n                flag = True\n                break\n        if not flag:\n            ok = True\n            break\n    print(1 if ok else -1)\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n\tcerr << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args&&... args) {\n\tconst char *comma = strchr(names + 1, ',');\n\tcerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n\t__f(comma + 1, args...);\n}\n#define pi 3.141592653589\n#define MOD 1000000007\n#define to() int tt; cin>>tt; while(tt--)\n#define pb push_back\n#define in insert\n#define mp make_pair\n#define ff first\n#define ss second\n#define si(s) s.size()\n#define fori(it,v) for(it=v.begin();it!=v.end(); it++)\n#define for1(i,low,high) for(int i=low;i<high;i++)\n#define for2(i,low,high) for(int i=low;i<=high;i++)\n#define rev(i,high,low)  for(int i=high;i>=low ;i--)\n#define all(x) x.begin(), x.end()\n#define fil(x,i) memset(x,i,sizeof(x));\n#define setbits(x) __builtin_popcount(x)\n#define boost ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define read freopen(\"input.txt\",\"r\",stdin)\n#define write freopen(\"output.txt\",\"w\",stdout)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\nvoid i_o() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin) ;\n\tfreopen(\"output.txt\", \"w\", stdout) ;\n#endif\n}\n\nint main()\n{\n\tboost; i_o();\n\tto(){\n\t\tint n,k; cin>>n>>k;\n\t\tvector<pair<int,int> >v(n);\n\t\tfor1(i,0,n) cin>>v[i].ff>>v[i].ss;\n\n\t\tbool ans=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tbool f=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint d=abs(v[i].ff-v[j].ff)+abs(v[i].ss-v[j].ss);\n\t\t\t\tif(d>k){\n\t\t\t\t\tf=false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tans=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans)cout<<\"1\"<<endl;\n\t\telse cout<<\"-1\"<<endl;\n\t}\n\n\n\n\n\treturn 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_list_string(): return list(map(str, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_print_int(x): sys.stdout.write(str(x) + '\\n')\ndef get_print(x): sys.stdout.write(x + '\\n')\nfrom sys import maxsize\n\ndef solve():\n\tfor _ in range(get_int()):\n\t\tn,k = get_ints()\n\t\tdata = []\n\t\tfor i in range(n):\n\t\t\tdata.append(get_list())\n\t\tans = -1\n\t\tfor i in range(n):\n\t\t\tcount = 0\n\t\t\tfor j in range(n):\n\t\t\t\tif(i != j):\n\t\t\t\t\tif(abs(data[i][0] - data[j][0]) + abs(data[i][1] - data[j][1]) <= k):\n\t\t\t\t\t\tcount += 1\n\t\t\tif(count == n-1):\n\t\t\t\tans = 1\n\t\t\t\tbreak\n\t\tget_print_int(ans)\n\t\t\nsolve()"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nii ar[100];\n\nint main(){\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int t; cin >> t;\n    while(t--){\n        int n, k; cin >> n >> k;\n        for(int i = 1; i <= n; ++i){\n            cin >> ar[i].fi >> ar[i].se;\n        }\n        for(int i = 1; i <= n; ++i){\n            bool cek = true;\n            for(int j = 1; j <= n; ++j){\n                int dist = abs(ar[i].fi - ar[j].fi) + abs(ar[i].se - ar[j].se);\n                if(dist > k)cek = false;\n            }\n            if(cek){\n                cout << 1 << endl;\n                break;\n            }\n            if(i == n)cout << -1 << endl;\n        }\n    }\n    return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Balls_Of_Steel {\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\n\tpublic static void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\n\t\tfor (int i = 0; i <= a.length - 2; i++) {\n\t\t\tint j = i + r.nextInt(a.length - i);\n\n\t\t\tswap(a, i, j);\n\t\t}\n\t}\n\n\tpublic static void swap(int[] a, int i, int j) {\n\t\tint temp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = temp;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader t = new FastReader();\n\t\tPrintWriter o = new PrintWriter(System.out);\n\t\tint test = t.nextInt();\n\n\t\twhile (test-- > 0) {\n\t\t\tint n = t.nextInt();\n\t\t\tlong k = t.nextLong();\n\t\t\tlong[][] cord = new long[n][2];\n\t\t\tboolean res = false;\n\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tcord[i][0] = t.nextLong();\n\t\t\t\tcord[i][1] = t.nextLong();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint cnt = 0;\n\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tlong md = Math.abs(cord[i][0] - cord[j][0]) + Math.abs(cord[i][1] - cord[j][1]);\n\n\t\t\t\t\t\tif (md <= k) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cnt == n - 1) {\n\t\t\t\t\tres = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\to.println(res ? \"1\" : \"-1\");\n\t\t}\n\n\t\to.flush();\n\t\to.close();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector< pair<int, int> > a(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n \n\t\tint flag = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbool cont = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = abs(a[j].first - a[i].first) + abs(a[j].second - a[i].second);\n\t\t\t\tif (x > k) {\n\t\t\t\t\tcont = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cont) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n \n\t\tcout << flag << '\\n';\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#include <cmath>\n\n#define  floop(b) for(long long i=0;i<b;i++)\n#define  test long long t_c;cin>>t_c;for(long long ks=1;ks<=t_c;ks++)\n#define pb push_back\n#define sc(a) scanf(\"%lld\",&a)\n#define vi vector<int>\n#define all(x) x.begin(),x.end()\n#define cy cout<<\"YES\\n\";\n#define cn cout<<\"NO\\n\";\n#define nl cout<<endl;\n\ntypedef long long ll;\ntypedef long long int lli;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(0);\n    test\n    {\n        int n,k;\n        cin>>n>>k;\n        int x[n+1],y[n+2];\n        floop(n)\n        {\n            cin>>x[i]>>y[i];\n        }\n        int f=0,c=0;\n\n        for(int i=0;i<n;i++)\n        {\n            f=0;\n            for(int j=0;j<n;j++)\n            {\n                int d=abs(x[i]-x[j])+abs(y[i]-y[j]);\n                if(d<=k)\n                {\n                    f++;\n                    //close[i][j]=1;\n                }\n                else\n                {\n                    break;\n                }\n            }\n           // cout<<\"i=\"<<i<<\" \"<<f<<endl;\n            if(f==n)\n            {\n                c=1;\n                break;\n\n            }\n        }\n        if(c==1)\n        {\n            cout<<1<<endl;\n        }\n        else\n        {\n\n            cout<<-1<<endl;\n        }\n    }\n\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class CFB {\n  BufferedReader br;\n  PrintWriter out;\n  StringTokenizer st;\n  boolean eof;\n  private static final long MOD = 1000L * 1000L * 1000L + 7;\n  private static final int[] dx = {0, -1, 0, 1};\n  private static final int[] dy = {1, 0, -1, 0};\n  private static final String yes = \"Yes\";\n  private static final String no = \"No\";\n\n  void solve() {\n    int T = nextInt();\n//    int T = 1;\n    for (int i = 0; i < T; i++) {\n      helper();\n    }\n  }\n\n  void helper() {\n    int n = nextInt();\n    int k = nextInt();\n    int[] x = new int[n];\n    int[] y = new int[n];\n    for (int i = 0; i < n; i++) {\n      x[i] = nextInt();\n      y[i] = nextInt();\n    }\n    boolean valid = false;\n    for (int i = 0; i < n; i++) {\n      boolean tmp = true;\n      for (int j = 0; j < n; j++) {\n        int dist = Math.abs(x[i] - x[j]) + Math.abs(y[i] - y[j]);\n        if (dist > k) {\n          tmp = false;\n        }\n      }\n      if (tmp) {\n        valid = true;\n      }\n    }\n    outln(valid ? 1 : -1);\n  }\n\n  void shuffle(long[] a) {\n    int n = a.length;\n    for(int i = 0; i < n; i++) {\n        int r = i + (int) (Math.random() * (n - i));\n        long tmp = a[i];\n        a[i] = a[r];\n        a[r] = tmp;\n    }\n  }\n  long gcd(long a, long b) {\n    while(a != 0 && b != 0) {\n        long c = b;\n        b = a % b;\n        a = c;\n    }\n    return a + b;\n  }\n  private void outln(Object o) {\n      out.println(o);\n  }\n  private void out(Object o) {\n      out.print(o);\n  }\n  private void formatPrint(double val) {\n      outln(String.format(\"%.9f%n\", val));\n  }\n  public CFB() {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(System.out);\n    solve();\n    out.close();\n  }\n  public static void main(String[] args) {\n      new CFB();\n  }\n\n  public long[] nextLongArr(int n) {\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n        res[i] = nextLong();\n    return res;\n  }\n  public int[] nextIntArr(int n) {\n    int[] res = new int[n];\n    for(int i = 0; i < n; i++)\n        res[i] = nextInt();\n    return res;\n  }\n  public String nextToken() {\n    while (st == null || !st.hasMoreTokens()) {\n        try {\n            st = new StringTokenizer(br.readLine());\n        } catch (Exception e) {\n            eof = true;\n            return null;\n        }\n    }\n    return st.nextToken();\n  }\n  public String nextString() {\n    try {\n        return br.readLine();\n    } catch (IOException e) {\n        eof = true;\n        return null;\n    }\n  }\n  public int nextInt() {\n      return Integer.parseInt(nextToken());\n  }\n  public long nextLong() {\n      return Long.parseLong(nextToken());\n  }\n  public double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\nsol = []\nfor test in range(int(input())):\n  n, k = map(int, input().split())\n  points = []\n  for i in range(n):\n    points.append(tuple(map(int, input().split())))\n  invalid=True\n  for i in range(n):\n    can=True\n    for j in range(n):\n      if i == j: continue\n      dist = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n      if dist>k:\n        can=False\n        break\n    if can:\n      invalid=False\n      break\n  if invalid:\n    sol.append(-1)\n  else:\n    sol.append(1)\nfor r in sol:\n  print(r)\n\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nt = int(stdin.readline())\n#t=1\n\nfor _ in xrange(t):\n    n,k= map(int,stdin.readline().split())\n    #n = int(stdin.readline())\n    #a = map(int,stdin.readline().split())\n    #b = map(int,stdin.readline().split())\n    a = []\n    for i in xrange(n):\n        x,y = map(int,stdin.readline().split())\n        a.append((x,y))\n    ans = -1\n    for x,y in a:\n        cur = 0\n        #print x,y\n        for i,j in a:\n            cur = max(cur, abs(x-i) + abs(y-j))\n        #print cur\n        if cur <=k:\n            ans = 1\n            break\n    print ans"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\tstatic BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n\tstatic BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out));\n\tstatic StringTokenizer tok;\n\tpublic static void main(String[] args) throws Exception {\n\t\tsolution();\n\t}\n\tpublic static void solution() throws Exception {\n\t\tint TestCase = Integer.parseInt(rd.readLine());\n\t\tfor(int TT=0;TT<TestCase;TT++) {\n\t\t\ttok = new StringTokenizer(rd.readLine());\n\t\t\tint n = Integer.parseInt(tok.nextToken());\n\t\t\tint m = Integer.parseInt(tok.nextToken());\n\t\t\tint[][] drr = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ttok = new StringTokenizer(rd.readLine());\n\t\t\t\tdrr[i][0] = Integer.parseInt(tok.nextToken());\n\t\t\t\tdrr[i][1] = Integer.parseInt(tok.nextToken());\n//\t\t\t\tSystem.out.println(Arrays.toString(drr[i]));\n\t\t\t}\n\t\t\t\n\t\t\tint[] wgt = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tif(Math.abs(drr[j][0]-drr[i][0])+Math.abs(drr[j][1]-drr[i][1])<=m) {\n\t\t\t\t\t\twgt[i]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = Arrays.stream(wgt).max().getAsInt();\n\t\t\tif(max>=n) System.out.println(\"1\");\n\t\t\telse System.out.println(\"-1\");\n\t\t}\n\t}\n//\tpublic static void solution() throws Exception {\n//\t\tint TestCase = Integer.parseInt(rd.readLine());\n//\t\tfor(int TT=0;TT<TestCase;TT++) {\n//\t\t\tint n = Integer.parseInt(rd.readLine());\n//\t\t\tString str = rd.readLine();\n//\t\t\tint[] count = new int[26];\n//\t\t\tfor(int i=0;i<n;i++) count[str.charAt(i)-'a']++;\n//\t\t\tStringBuilder temp = new StringBuilder(\"\");\n//\t\t\tfor(int i=0;i<26;i++) {\n//\t\t\t\tfor(int j=0;j<count[i];j++) {\n//\t\t\t\t\ttemp.append((char)('a'+i)+\"\");\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tSystem.out.println(temp.toString());\n//\t\t}\n//\t}\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\"\"\"\nn=int(stdin.readline().strip())\nn,m=map(int,stdin.readline().strip().split())\ns=list(map(int,stdin.readline().strip().split()))\ns=stdin.readline().strip()\n\"\"\"\ncas=int(stdin.readline().strip())\nfor ca in range(cas):\n    n,k=map(int,stdin.readline().strip().split())\n    s=[list(map(int,stdin.readline().strip().split())) for i in range(n)]\n    f1=True\n    for i in range(n):\n        f=True\n        for j in range(n):\n            if abs(s[i][0]-s[j][0])+abs(s[i][1]-s[j][1])>k:\n                f=False\n                break\n        if f:\n            print(1)\n            f1=False\n            break\n    if f1:\n        print(-1)\n    \n    \n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1450_B {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = Integer.parseInt(in.readLine());\n\t\tfor(int i = 0; i < t; i++) {\n\t\t\tStringTokenizer line = new StringTokenizer(in.readLine());\n\t\t\tint n = Integer.parseInt(line.nextToken());\n\t\t\tint k = Integer.parseInt(line.nextToken());\n\t\t\tint[][] balls = new int[n][2];\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tline = new StringTokenizer(in.readLine());\n\t\t\t\tballs[j][0] = Integer.parseInt(line.nextToken());\n\t\t\t\tballs[j][1] = Integer.parseInt(line.nextToken());\n\t\t\t}\n\t\t\tboolean possible = false;\n\t\t\tfor(int a = 0; a < n; a++) {\n\t\t\t\tboolean allconnected = true;\n\t\t\t\tfor(int b = 0; b < n; b++) {\n\t\t\t\t\tif(Math.abs(balls[a][0] - balls[b][0]) + Math.abs(balls[a][1] - balls[b][1]) > k) {\n\t\t\t\t\t\tallconnected = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(allconnected) {\n\t\t\t\t\tpossible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(possible) {\n\t\t\t\tout.println(1);\n\t\t\t}else {\n\t\t\t\tout.println(-1);\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\tout.close();\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n     \n    import java.util.*;\n     \n    public class Try2{\n     \n    \t\n    \t\n    \tpublic static void main(String[] args) {\n    \t\tFastScanner fs = new FastScanner();\n    \t\tint t = fs.nextInt();\n    \t\t\n    \t\twhile (t-- > 0) {\n    \t\t\n    \t\t\tint n  = fs.nextInt();\n    \t\t\tint k = fs.nextInt();\n    \t\t\t\n    \t\t\tint[][] a = new int[n][2];\n    \t\t\t\n    \t\t\tfor(int i = 0;i<n;i++) {\n    \t\t\t\ta[i][0] = fs.nextInt();\n    \t\t\t\ta[i][1] = fs.nextInt();\n    \t\t\t\t\n    \t\t\t}\n    \t\t\t\n    \t\t\t\n    \t\t\tboolean b = false;\n    \t\t\t\n    \t\t\tfor(int i = 0;i<n;i++) {\n    \t\t\t\tint x1 = a[i][0];\n    \t\t\t\tint y1 = a[i][1];\n    \t\t\t\t\n    \t\t\t\tint count  =0;\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0;j<n;j++) {\n    \t\t\t\t\tint x2 = a[j][0];\n    \t\t\t\t\tint y2 = a[j][1];\n    \t\t\t\t\t\n    \t\t\t\t\tif((Math.abs(x1-x2) + Math.abs(y1-y2)<=k)){\n    \t\t\t\t\t\tcount++;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(count==n) {\n    \t\t\t\t\tb=true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(b) System.out.println(1);\n    \t\t\telse System.out.println(-1);\n    \t\t\t\n    \t\t\t\n    \t\t}\n    \t\t\t\n    \t\t\t\n    \t\t\t\n    \t\t}\n    \t\t\n    \t\n     \n    \t\n    \tstatic final Random random = new Random();\n     \n    \tstatic void ruffleSort(int[] a) {\n    \t\tint n = a.length;// shuffle, then sort\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tint oi = random.nextInt(n), temp = a[oi];\n    \t\t\ta[oi] = a[i];\n    \t\t\ta[i] = temp;\n    \t\t}\n    \t\tArrays.sort(a);\n    \t}\n     \n    \tstatic class FastScanner {\n    \t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \t\tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \t\tString next() {\n    \t\t\twhile (!st.hasMoreTokens())\n    \t\t\t\ttry {\n    \t\t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t\t} catch (IOException e) {\n    \t\t\t\t\te.printStackTrace();\n    \t\t\t\t}\n    \t\t\treturn st.nextToken();\n    \t\t}\n     \n    \t\tint nextInt() {\n    \t\t\treturn Integer.parseInt(next());\n    \t\t}\n     \n    \t\tint[] readArray(int n) {\n    \t\t\tint[] a = new int[n];\n    \t\t\tfor (int i = 0; i < n; i++)\n    \t\t\t\ta[i] = nextInt();\n    \t\t\treturn a;\n    \t\t}\n     \n    \t\tlong nextLong() {\n    \t\t\treturn Long.parseLong(next());\n    \t\t}\n    \t}\n     \n    }"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint mod = 998244353;\n\nint main() {\n    int T; cin >> T;\n    for(int l=0; l<T; l++) {\n        \n    int n, k; cin >> n >> k;\n    vector<pair<int, int>> vec(n);\n    for(int i=0; i<n; i++) {\n        cin >> vec[i].first >> vec[i].second;\n    }\n    int dis = 1e9;\n    for(int i=0; i<n; i++) {\n        int maxd = 0;\n        for(int j=0; j<n; j++) {\n            if (i == j) continue;\n            maxd = max(maxd, abs(vec[i].first - vec[j].first) + abs(vec[i].second - vec[j].second));\n        }\n        dis = min(maxd, dis);\n    }\n    if (dis <= k) cout << 1 << endl;\n    else cout << -1 << endl;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# def gcd(a,b):\n#     if (b==0):\n#         return a\n#     else:\n#         return gcd(b,a%b)\n# n = int(input())\n# for i in range(n):\n#     x = int(input())\n#     c = []\n#     for i in range(2,4*x+1):\n#         a = i+1\n#         b = i\n#         if a%b!=0 and b%a!=0 or gcd(a,b)!=1:\n#             c.append(a)\n#             c.append(b)\n#\n#     c = set(c)\n#     c2 = c\n#     # print(c)\n#     p = 0\n#     for l in c:\n#         for k in c2:\n#             if p<x:\n#                 if l%k!=0:\n#                     p+=1\n#                     print(k, end=\" \")\n#             else:\n#                 break\n#     print()\n#\n#\n# #\n# # for i in range(int(input())):\n# #     a, b = list(map(int, input().split()))\n# #     s = input()\n# #     s.count()\n\n\n# n = int(input())\n# for i in range(n):\n#     x = int(input())\n#     s = input()\n#     print(*sorted(s),sep=\"\")\n\n\n\n# t = int(input())\n# # for i in range(t):\n# #     n, k = list(map(int, input().split()))\n# #     x = []\n# #     y = []\n# #     for j in range(n):\n# #         p = list(map(int, input().split()))\n# #         x.append(p[0])\n# #         y.append(p[1])\n# #\n# #     s = []\n# #     c = 0\n# #     for i in range(n):\n# #         for j in range(i + 1, n):\n# #             s.append(abs(x[i] - x[j]) + abs(y[i] - y[j]))\n# #\n# #     print(s)\n# #     if max(s)<=k:\n# #         print(1)\n# #     else:\n# #         print(-1)\n\nt = int(input())\nfor i in range(t):\n    n, k = list(map(int, input().split()))\n    x = []\n    y = []\n    for j in range(n):\n        p = list(map(int, input().split()))\n        x.append(p[0])\n        y.append(p[1])\n\n    ll = len(x)\n    c = 0\n    f = 0\n    for i in range(ll):\n        c = 0\n        for j in range(ll):\n            if j == i:\n                continue\n            else:\n                s = abs(x[i] - x[j]) + abs(y[i] - y[j])\n                if s <= k:\n                    c += 1\n                else:\n                    break\n\n        if c==n-1 and f == 0:\n            f = 1\n            print(1)\n\n\n    if f == 0:\n        print(-1)\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import math\nfor _ in range(int(input())):\n        n,k=map(int,input().split())\n        l=[]\n        for __ in range(n):\n            x,y=map(int,input().split())\n            l.append([x,y])\n        c=0\n        cc=0\n        #print(l,len(l),n)\n        for i in range(n):\n            c=0\n            for j in range(n):\n                if i!=j and ((abs(l[i][0]-l[j][0])+abs(l[i][1]-l[j][1])))<=k:\n                    c+=1\n                    #print(i,j,((abs(l[i][0]-l[j][0])**2+abs(l[i][1]-l[j][1])**2)),k)\n                \n            \n            if c==n-1:\n                print(1)\n                cc=1\n                break\n            \n        if cc!=1:\n          print(-1)\n            \n                    \n"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\nfrom itertools import permutations \nimport threading,bisect,math,heapq,sys\n# threading.stack_size(2**27)\n# sys.setrecursionlimit(10**4)\nfrom sys import stdin, stdout\ni_m=9223372036854775807    \ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input()) \nprime=[]\ndef dfs(n,d,v):\n    v[n]=1\n    x=d[n]\n    for i in x:\n        if i not in v:\n            dfs(i,d,v)\n    return p \n\ndef block(x): \n      \n    v = [] \n    while (x > 0): \n        v.append(int(x % 2)) \n        x//=2\n    d=[]\n    for i in range(len(v)-1, -1,-1): \n        if (v[i] == 1): \n            d.append(i) \n    return d\n\"\"\"**************************MAIN*****************************\"\"\"\ndef main():\n    t=inin()\n    for _ in range(t):\n        n,k=cin()\n        a=[]\n        for i in range(n):\n            x,y=cin()\n            a.append((x,y))\n        g={}\n        for i in range(n):\n            for j in range(i+1,n):\n                if abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])<=k:\n                    if j not in g:\n                        g[j]=[i]\n                    else:\n                        g[j].append(i)\n                    if i not in g:\n                        g[i]=[j]\n                    else:\n                        g[i].append(j)\n        ans=-1\n        for i in g:\n            if len(g[i])==n-1:\n                ans=1\n        print(ans)\n\"\"\"***********************************************\"\"\"\n\n######## Python 2 and 3 footer by Pajenegod and c1729\nfac=[]\ndef fact(n,mod):\n    global fac\n    fac.append(1)\n    for i in range(1,n+1):\n        fac.append((fac[i-1]*i)%mod)\n    f=fac[:]\n    return f\ndef nCr(n,r,mod):\n    global fac\n    x=fac[n]\n    y=fac[n-r]\n    z=fac[r]\n    x=moddiv(x,y,mod)\n    return moddiv(x,z,mod)\ndef moddiv(m,n,p):\n    x=pow(n,p-2,p)\n    return (m*x)%p\ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    ll=[]\n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                ll.append(n//i)\n    l.extend(ll[::-1])\n    return l\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\ndef primeFactors(n): \n    a=[]\n    while n % 2 == 0: \n        a.append(2) \n        n = n // 2 \n    for i in range(3,int(math.sqrt(n))+1,2):  \n        while n % i== 0: \n            a.append(i) \n            n = n // i  \n    if n > 2: \n        a.append(n)\n    return a\n\"\"\"*******************************************************\"\"\"\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n') \n# Cout implemented in Python\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class BallsOfSteel {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n, k, i, j, count = 0;\n            n = in.nextInt();\n            k = in.nextInt();\n            int[][] a = new int[n][2];\n            //int[] b=new int[n];\n            for (i = 0; i < n; i++) {                \n                    a[i][0]=in.nextInt();\n                    a[i][1]=in.nextInt();                \n            }\n\n            for (i = 0; i < n; i++) {\n                count = 0;\n                for (j = 0; j < n; j++) {\n                    if (i != j && Math.abs(a[i][0] - a[j][0]) + Math.abs(a[i][1] - a[j][1]) <= k) {\n                        count++;\n                    }\n                }\n                if (count == n - 1) {\n                    System.out.println(1);\n                    break;\n                }\n            }\n            if (i == n) {\n                System.out.println(\"-1\");\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor t1 in range(t):\n    n,k=map(int,input().split())\n    x=[]\n    y=[]\n    for t2 in range(n):\n        x1,x2=map(int,input().split())\n        x.append(x1)\n        y.append(x2)\n    flag=0\n    for a in range(n):\n        flag=0\n        for b in range(n):\n            if a!=b:\n                if abs(x[a]-x[b])+abs(y[a]-y[b])>k:\n                    flag=1\n        if flag==0:\n            print(1)\n            flag=2\n            break\n    if flag!=2:\n        print(-1)\n                "
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------- fast io --------------------\nfrom math import ceil,floor,sqrt\nfrom collections import Counter,defaultdict,deque\ndef int1():\n    return int(input())\ndef map1():\n    return map(int,input().split())\ndef list1():\n    return list(map(int,input().split()))\nmod=pow(10,9)+7\ndef solve():\n    n,k=map1()\n    l1=[]\n    d=defaultdict(list)\n    for i in range(n):\n        l1.append(list1())\n    for i in range(n):\n        c=0\n        for j in range(n):\n            if(i!=j):\n                v=abs(l1[i][0]-l1[j][0])+abs(l1[i][1]-l1[j][1])\n                if(v<=k):\n                    c=c+1\n                else:\n                    c=0\n        if(c==(n-1)):\n            print(1)\n            return\n    print(-1)\n            \nfor _ in range(int(input())):\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ii pair<ll,ll>\n#define x first\n#define y second\nconst ll M=1e6+7;\nii a[M];\nint main()\n{\n    ll t;\n    cin>>t;\n    while(t--)\n    {\n        ll n;\n        cin>>n;\n        ll m;\n        cin>>m;\n        for(ll i=1;i<=n;i++)\n        {\n            cin>>a[i].x>>a[i].y;\n        }\n        bool check1=false;\n        for(ll i=1;i<=n;i++)\n        {\n            ll kq=0;\n            for(ll j=1;j<=n;j++)\n            {\n                kq=max(kq,abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y));\n            }\n            if(kq<=m)\n            {\n                check1=true;\n            }\n        }\n        if(!check1)\n        {\n            cout<<-1;\n        }\n        else\n        {\n            cout<<1;\n        }\n        cout<<endl;\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "# import sys\n\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n# input = sys.stdin.readline\n\n\nt = int(input())\n\nwhile t:\n    t -= 1\n\n    n, k = list(map(int, input().split()))\n    points = []\n\n    for _ in range(n):\n        points.append(list(map(int, input().split())))\n\n    \n    for point in points:\n        ans = 1\n        for opoint in points:\n            if point != opoint and abs(point[0]-opoint[0]) + abs(point[1]-opoint[1]) > k:\n                ans = -1\n        if ans == 1:\n            print(1)\n            break\n    else:\n        print(-1)"
        },
        {
            "language": 2,
            "solution": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\") \n \n \n#include<bits/stdc++.h>  \n#define ll long long int \n#define ff first  \n#define ss second  \n#define mkp make_pair \n#define pb push_back  \n#define pf push_front  \n#define maxn 1000001 \n#define mod 1000000007 \n\nusing namespace std;   \n\n\nvoid solve(){  \n    int n,k; \n    cin>>n>>k; \n    vector<pair<int,int>>v(n); \n    for(int i=0;i<n;++i){  \n      cin>>v[i].ff>>v[i].ss; \n    } \n    // sort(v.begin(),v.end());   \n  \n    for(int i=0;i<n;++i){ \n       bool flag=true; \n       bool flag1=true; \n       for(int j=i+1;j<n;++j){  \n            if(abs(v[i].ff-v[j].ff)+abs(v[i].ss-v[j].ss)>k){ \n                 flag=false; \n            }\n       } \n       for(int j=0;j<i;++j){  \n        if(abs(v[i].ff-v[j].ff)+abs(v[i].ss-v[j].ss)>k){ \n                 flag1=false; \n            }\n       } \n       if(flag&&flag1){  \n          cout<<\"1\\n\"; \n          return;\n       }\n    } \n    cout<<\"-1\\n\";\n    \n}\nint main(){    \n  ios_base::sync_with_stdio(false); \n  cin.tie(NULL);  \n\n    #ifndef ONLINE_JUDGE \n       freopen(\"input.txt\",\"r\",stdin);  \n       freopen(\"output.txt\",\"w\",stdout); \n    #endif   \n        \n              \n        int t; \n        cin>>t;\n        while(t--){ \n            solve();  \n        }\n \n     \nreturn 0;  \n\n} "
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <cmath>\n\nconstexpr int N = 105;\n\nint T, n, k;\nint x[N], y[N];\n\nint main() {\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n    std::cin >> T;\n    while (T--) {\n        std::cin >> n >> k;\n        for (int i = 1; i <= n; ++i) std::cin >> x[i] >> y[i];\n        bool flag = 0;\n        for (int i = 1; i <= n; ++i) {\n            bool ok = 1;\n            for (int j = 1; j <= n; ++j)\n                if (std::abs(x[i] - x[j]) + std::abs(y[i] - y[j]) > k) {\n                    ok = 0;\n                    break;\n                }\n            if (ok) { flag = 1; break; }\n        }\n        std::cout << (flag ? \"1\\n\" : \"-1\\n\");\n    }\n    return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class ECR\n{\n\tprivate static Scanner scan;\n\t\n\tpublic static void main (String[] args) {  \n    \tscan = new Scanner(System.in);\n    \tint t = scan.nextInt();\n    \tl :while(t-->0) {\n    \t\tint n = scan.nextInt();\n    \t\tint k = scan.nextInt();\n    \t\tif(n==2) {\n    \t\t\tint x1 = scan.nextInt();\n    \t\t\tint y1 = scan.nextInt();\n    \t\t\tint x2 = scan.nextInt();\n    \t\t\tint y2 = scan.nextInt();\n    \t\t\tif((Math.abs(x1-x2)+Math.abs(y1-y2)<=k)) {\n    \t\t\t\tSystem.out.println(1);\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tSystem.out.println(-1);\n    \t\t\t}\n    \t\t}\n    \t\telse {\n    \t\t\tint a[][] = new int[n][2];\n        \t\tfor(int i=0;i<n;i++) {\n        \t\t\ta[i][0] = scan.nextInt();\n        \t\t\ta[i][1] = scan.nextInt();\n        \t\t}\n        \t\tfor(int i =0;i<n;i++) {\n        \t\t\tfor(int j =0;j<n;j++) {\n        \t\t\t\tif(Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1])>k) {\n        \t\t\t\t\tbreak;\n        \t\t\t\t}\n        \t\t\t\tif(j==n-1) {\n        \t\t\t\t\tSystem.out.println(1);\n        \t\t\t\t\tcontinue l;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tSystem.out.println(-1);\n    \t\t}\n    \t\t\n    \t}\n    \t\n\t} \n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define ll long long int\n#define pb push_back\n#define mod 1000000007\n#define pi (3.141592653589)\nusing namespace std;\n ll n,k;\nbool compare(pair<ll,ll> a,pair<ll,ll> b)\n{\n    if(a.first<b.first)\n    return a.first<b.first;\n    else \n    return a.second<b.second;\n}\nint main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed;\n    cout.precision(10);\n    #ifndef ONLINE_JUDGE\n \t\tfreopen(\"input.txt\", \"r\", stdin);\n \t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n    int T;\n    cin >> T;\n    while(T--)\n    {\n       cin>>n>>k;\n       pair<ll,ll> p[n];\n\n       for(int i=0;i<n;i++)\n       cin>>p[i].first>>p[i].second;\n\n       ll total=0;\n       bool f=0;\n       for(int i=0;i<n;i++)\n       {\n           total=0;\n           for(int j=0;j<n;j++)\n           {\n               ll dis = abs(p[i].first-p[j].first)+abs(p[i].second-p[j].second);\n                if(dis<=k)\n                total++;\n\n           }\n           if(total==n)\n           {\n               f=1;break;\n           }\n       }\n       if(f)\n       cout<<1<<\"\\n\";\n       else\n       cout<<-1<<\"\\n\";\n    }\n\treturn 0;\n}\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n,k=[int(x) for x in input().split(' ')]\n    points=[]\n    for i in range(n):\n        point=[int(x) for x in input().split(' ')]\n        points.append(point)\n    flm=0\n    for i in range(len(points)):\n        fl=1\n        for j in range(len(points)):\n            if((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))>k):\n                fl=0\n                break\n        if(fl):\n            flm=1\n            break\n    if(flm):\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class codeforces_G12_B {\n\n    public static void main(String[] args) throws Exception {\n        FastScanner scanner = new FastScanner();\n        int count = scanner.nextInt();\n        for (int i = 0; i < count; i++) {\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            int[][] a = new int[n][];\n            for (int j = 0; j < n; j++) {\n                a[j] = scanner.readArray(2);\n            }\n            boolean allgood = false;\n            for (int j = 0; j < n; j++) {\n                boolean good = true;\n                for (int l = 0; l < n; l++) {\n                    if (Math.abs(a[l][0] - a[j][0]) + Math.abs(a[l][1] - a[j][1]) > k) {\n                        good = false;\n                        break;\n                    }\n                }\n                if (good) {\n                    allgood = true;\n                    System.out.println(1);\n                    break;\n                }\n            }\n            if (!allgood) {\n                System.out.println(-1);\n            }\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readArrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys, os\n# import numpy as np\nfrom math import sqrt, gcd, ceil, log, floor\nfrom bisect import bisect, bisect_left\nfrom collections import defaultdict, Counter, deque\nfrom heapq import heapify, heappush, heappop\nfrom itertools import permutations\ninput = sys.stdin.readline\nread = lambda: list(map(int, input().strip().split()))\n# read_f = lambda file:  list(map(int, file.readline().strip().split()))\n# from time import time\n# sys.setrecursionlimit(5*10**6)\n\nMOD = 10**9 + 7\n\n\ndef f(a, b, x, y, k):\n\treturn((abs(x-a)+abs(y-b)) <= k)\n\ndef main():\n\t# file1 = open(\"C:\\\\Users\\\\shank\\\\Desktop\\\\Comp_Code\\\\input.txt\", \"r\")\n\t# n = int(file1.readline().strip()); \n\t# arr = list(map(int, file1.read().strip().split(\" \")))\n\t# file1.close()\n\t# n = int(input())\n\tans = []\n\tfor _ in range(int(input())):\n\t\tn, k =read(); arr = []\n\t\tfor i in range(n):arr.append(read())\n\t\t# arr.sort()\n\t\t# a, b =arr[0]; x, y = arr[-1]\n\t\t# flag = 1\n\t\tfor i in arr:\n\t\t\ta, b = i\n\t\t\tfl = 1\n\t\t\tfor j in arr:\n\t\t\t\tx, y = j\n\t\t\t\tfl &= f(a, b, x, y, k)\n\t\t\tif fl:\n\t\t\t\tans.append(1)\n\t\t\t\tbreak\n\t\tif not fl:\n\t\t\tans.append(-1)\n\n\n\n\t\t\n\n\tprint((\"\\n\").join(map(str, ans)))\n\n\t\n\n\n\t# file = open(\"output.txt\", \"w\")\n\t# file.write(ans+\"\\n\")\n\t# file.close()\n\nif __name__ == \"__main__\":\n\tmain()\n\n\"\"\"\n\n\ntrygubbugyrt\n\n\"\"\""
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<utility>\n#include<list>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<map>\n#include<bitset>\nusing namespace std;\n#define int long long\n#define  nl <<\"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<char> vc;\ntypedef pair<int, int> pi;\ntypedef vector<pair<int, int> > vpi;\n\ntemplate<typename T> ostream& operator<<(ostream& stream, vector<T>& v)\n{\n    for (T& x : v) stream << x << \" \"; return stream;\n}\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& v)\n{\n    for (T& x : v) stream >> x; return stream;\n}\ntemplate<typename T> void sort(vector<T>& v)\n{\n    std::sort(v.begin(), v.end());\n    return;\n}\ntemplate<typename T> T max(vector<T>& v)\n{\n    return *(max_element(v.begin(), v.end()));\n}\ntemplate<typename T> T min(vector<T>& v)\n{\n    return *(min_element(v.begin(), v.end()));\n}\n\n\n\nvoid solve()\n{\n    int n,k;\n    cin>>n>>k;\n    vpi a(n);\n    for (size_t i = 0; i < n; i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        a[i]={x,y};\n    }\n    for (size_t i = 0; i < n; i++)\n    {\n        int count=1;\n        for (size_t j = 0; j < n; j++)\n        {\n            if(abs(a[i].first-a[j].first)+abs(a[j].second-a[i].second)>k)\n            {\n                count=0;\n                continue;\n            }\n        }\n        if(count)\n        {\n            cout<< 1 nl;\n            return;\n        }\n        \n    }\n    cout<<-1 nl;\n    \n    \n    \n\n}\n\n\nsigned main()\n{\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int t = 1;\n    cin >> t;\n    while (t--)\n    {\n\n        solve();\n\n    }\n    return 0;\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class main\n{\npublic static void main(String[]args)\n{\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nint ram=0,sita=0;\nwhile(t-->0)\n{\nint n=sc.nextInt();\nint k=sc.nextInt();\nint a[]=new int[n];\nint b[]=new int[n];\nfor(int i=0;i<n;i++)\n{\na[i]=sc.nextInt();\nb[i]=sc.nextInt();\n}\n for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(i!=j)\n                {\n                int res =(Math.abs(a[i]-a[j])+Math.abs(b[i]-b[j]));\n                if(res>k)\n                break;\n                else\n                ram++;\n                }\n            }\n            if(ram==n-1)\n            {\n            System.out.print(\"1\");\n            break;\n            }\n            else\n            sita++;\n            ram=0;\n        }\n        if(sita==n)\n        System.out.print(\"-1\");\n        System.out.println();\n        sita=0;\n        ram=0;\n    \n}\n}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define pi 126262\nusing namespace std;\nconst int maxx=1e6+7;\ntypedef long long ll;\n\nint T,n,k,x[110], y[110];\nint check(int id) \n{\n\tint ans=0;\n\tfor(int i = 0; i < n; i++)\n    {\n\t\tint dis = abs(x[id] - x[i]) + abs(y[id] - y[i]);\n\t\tans = max(ans, dis);\n\t}\n\treturn ans;\n}\n\nint main() \n{\n\tcin >> T;\n\twhile(T--) \n    {\n        cin >> n >> k;\n\t\tfor (int i = 0; i < n;i++) \n            cin >> x[i] >> y[i];\n\t\tint ans = -1;\n\t\tfor (int i = 0; i < n; i++)\n        {\n\t\t\tif (check(i) <= k) { ans = 1; goto nex;}\n\t\t}\n\t\tnex:\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nstruct stu\n{\n\tint a,b;\n}i[105];\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tcin>>n>>k;\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tcin>>i[x].a>>i[x].b;\n\t\t}\n\t\tbool flag=false;\n\t\tfor(int x=0;x<n;x++)\n\t\t{\n\t\t\tint y=0;\n\t\t\tfor(;y<n;)\n\t\t\t{\n\t\t\t\tif(x==y)\n\t\t\t\t{\n\t\t\t\t\ty++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(abs(i[x].a-i[y].a)+abs(i[x].b-i[y].b)>k)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tif(y==n)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(flag)cout<<\"1\"<<endl;\n\t\telse cout<<\"-1\"<<endl; \n\t}\n} \n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom math import inf\n\ninput = lambda: stdin.readline().strip()\nipnut = input\ndef dist(a,b):\n    return abs(a[0]-b[0])+abs(a[1]-b[1])<=k\nfor i in range(int(input())):\n    # n = int(input())\n    n,k = map(int,ipnut().split())\n    # d = list(map(int,input().split()))\n    coord = []\n    for i in range(n):\n        coord.append(tuple(map(int,input().split())))\n    f = -1\n    for i in range(n):\n        fl = 1\n        for j in range(n):\n            if not dist(coord[i],coord[j]):\n                fl = 0\n\n        if fl:\n            f = 1\n            break\n    print(f)"
        },
        {
            "language": 3,
            "solution": "# import sys\n#\nimport sys\n\ninput = sys.stdin.readline\nline_inp = lambda: list(map(int, input().strip().split()))\nint_inp = lambda: int(input())\n\n\ndef distance(x, y):\n    return abs(x[0] - y[0]) + abs(x[1] - y[1])\n\n\ndef solve(n, k, points):\n    man_dist = [0] * n\n    for i in range(n):\n        for j in range(n):\n            dist = distance(points[i], points[j])\n            if dist <= k:\n                man_dist[i] += 1\n\n        if man_dist[i] == n:\n            return 1\n\n    return -1\n\n\nfor i in range(int_inp()):\n    n, k = line_inp()\n    points = []\n    for j in range(n):\n        points.append(line_inp())\n\n    # print(points)\n    print(solve(n, k, points))\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Math.*;\n\nimport java.util.stream.*;\n\npublic class B {\n\n\tpublic Object solve () {\n\t\tint N = sc.nextInt();\n\t\tlong K = sc.nextInt();\n\t\tlong [][] P = sc.nextLongs(N);\n\n\t\tnext: for (int i : rep(N)) {\n\t\t\tfor (int j : rep(N))\n\t\t\t\tif (dist(P[i], P[j]) > K)\n\t\t\t\t\tcontinue next;\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tlong dist (long [] a, long [] b) {\n\t\tlong res = abs(a[0] - b[0]) + abs(a[1] - b[1]);\n\t\treturn res;\n\t}\n\n\tprivate static final int CONTEST_TYPE = 2;\n\n\tprivate static void init () {\n\t}\n\n\tprivate static int [] rep (int N) { return rep(0, N); }\n\tprivate static int [] rep (int S, int T) { if (S >= T) return new int [0]; int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }\n\t//////////////////////////////////////////////////////////////////////////////////// OFF\n\tprivate static IOUtils.MyScanner sc = new IOUtils.MyScanner();\n\tprivate static class IOUtils {\n\t\tpublic static class MyScanner {\n\t\t\tpublic String next () { newLine(); return line[index++]; }\n\t\t\tpublic int nextInt () { return Integer.parseInt(next()); }\n\t\t\tpublic String nextLine () { line = null; return readLine(); }\n\t\t\tpublic String [] nextStrings () { return split(nextLine()); }\n\t\t\tpublic long[] nextLongs () { return nextStream().mapToLong(Long::parseLong).toArray(); }\n\t\t\tpublic long[][] nextLongs (int N) { return IntStream.range(0, N).mapToObj(i -> nextLongs()).toArray(long[][]::new); }\n\t\t\t//////////////////////////////////////////////\n\t\t\tprivate boolean eol () { return index == line.length; }\n\t\t\tprivate String readLine () {\n\t\t\t\ttry {\n\t\t\t\t\treturn r.readLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate final java.io.BufferedReader r;\n\t\t\tprivate MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }\n\t\t\tprivate MyScanner (java.io.BufferedReader r) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.r = r;\n\t\t\t\t\twhile (!r.ready())\n\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\tstart();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] line;\n\t\t\tprivate int index;\n\t\t\tprivate void newLine () {\n\t\t\t\tif (line == null || eol()) {\n\t\t\t\t\tline = split(readLine());\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate java.util.stream.Stream<String> nextStream () { return java.util.Arrays.stream(nextStrings()); }\n\t\t\tprivate String [] split (String s) { return s.length() > 0 ? s.split(\" \") : new String [0]; }\n\t\t}\n\t\tprivate static String build (Object o, Object ... A) { return buildDelim(\" \", o, A); }\n\t\tprivate static String buildDelim (String delim, Object o, Object ... A) {\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tappend(b, o, delim);\n\t\t\tfor (Object p : A)\n\t\t\t\tappend(b, p, delim);\n\t\t\treturn b.substring(min(b.length(), delim.length()));\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////////////\n\t\tprivate static java.text.DecimalFormat formatter = new java.text.DecimalFormat(\"#.#########\");\n\t\tprivate static void start () { if (t == 0) t = millis(); }\n\t\tprivate static void append (java.util.function.Consumer<Object> f, java.util.function.Consumer<Object> g, final Object o) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tf.accept(java.lang.reflect.Array.get(o, i));\n\t\t\t}\n\t\t\telse if (o instanceof Iterable<?>)\n\t\t\t\t((Iterable<?>)o).forEach(f::accept);\n\t\t\telse\n\t\t\t\tg.accept(o instanceof Double ? formatter.format(o) : o);\n\t\t}\n\t\tprivate static void append (final StringBuilder b, Object o, final String delim) {\n\t\t\tappend(x -> { append(b, x, delim); }, x -> b.append(delim).append(x), o);\n\t\t}\n\t\tprivate static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);\n\t\tprivate static void print (Object o, Object ... A) {\n\t\t\tString res = build(o, A);\n\t\t\tif (DEBUG == 2)\n\t\t\t\terr(res, '(', time(), ')');\n\t\t\tif (res.length() > 0)\n\t\t\t\tpw.println(res);\n\t\t\tif (DEBUG == 1) {\n\t\t\t\tpw.flush();\n\t\t\t\tSystem.out.flush();\n\t\t\t}\n\t\t}\n\t\tprivate static void err (Object o, Object ... A) { System.err.println(build(o, A)); }\n\t\tprivate static int DEBUG;\n\t\tprivate static void exit () {\n\t\t\tString end = \"------------------\" + System.lineSeparator() + time();\n\t\t\tswitch(DEBUG) {\n\t\t\tcase 1: print(end); break;\n\t\t\tcase 2: err(end); break;\n\t\t\t}\n\t\t\tIOUtils.pw.close();\n\t\t\tSystem.out.flush();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tprivate static long t;\n\t\tprivate static long millis () { return System.currentTimeMillis(); }\n\t\tprivate static String time () { return \"Time: \" + (millis() - t) / 1000.0; }\n\t\tprivate static void run (int N) {\n\t\t\ttry { DEBUG = Integer.parseInt(System.getProperties().get(\"DEBUG\").toString()); }\n\t\t\tcatch (Throwable t) {}\n\n\t\t\tfor (int n = 1; n <= N; ++n) {\n\t\t\t\tObject res = new B().solve();\n\t\t\t\tif (res != null) {\n\t\t\t\t\t@SuppressWarnings(\"all\")\n\t\t\t\t\tObject o = CONTEST_TYPE == 0 ? \"Case #\" + n + \": \" + build(res) : res;\n\t\t\t\t\tprint(o);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit();\n\t\t}\n\t}\n\t////////////////////////////////////////////////////////////////////////////////////\n\tpublic static void main (String[] args) {\n\t\tinit();\n\t\t@SuppressWarnings(\"all\")\n\t\tint N = CONTEST_TYPE == 1 ? 1 : sc.nextInt();\n\t\tIOUtils.run(N);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static class Point {\n        int x;\n        int y;\n\n        public Point() {}\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static boolean attack(Point a, Point b, int k) {\n        if (Math.abs(a.x - b.x) + Math.abs(a.y - b.y) <= k) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        while (T-- > 0) {\n            int n, k;\n            n = scanner.nextInt();\n            k = scanner.nextInt();\n            Point[] points = new Point[n];\n            for (int i = 0; i < n; ++i) {\n                points[i] = new Point();\n                points[i].x = scanner.nextInt();\n                points[i].y = scanner.nextInt();\n            }\n            boolean canDo = false;\n            for (int i = 0; i < n; ++i) {\n                boolean allCan = true;\n                for (int j = 0; j < n; ++j) {\n                    if (!attack(points[i], points[j], k)) {\n                        allCan = false;\n                    }\n                }\n                if (allCan) {\n                    canDo = true;\n                    break;\n                }\n            }\n            if (canDo) {\n                System.out.println(1);\n            } else {\n                System.out.println(-1);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define ll long long\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\nusing namespace std;\nconst int tINF = (int)INT_MAX;\nconst long long lINF = (long long)LLONG_MAX;\nint getd(pair <int,int> l, pair <int,int> r) {\n    return abs(l.first - r.first) + abs(l.second - r.second);\n}\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t#ifdef DEBUG\n\t\t\tassert(freopen(\"inp\", \"r\", stdin));\n\t\t\tassert(freopen(\"out\", \"w\",stdout));\n\t#else\n\t\t\t#define cerr if(false)cerr\n\t#endif\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<pair<int,int>> ar(n);\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            ar[i] = {x,y};\n        }\n        int res = 0;\n        vector <int> br(n);\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j =0 ; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (getd(ar[i], ar[j]) <= k) {\n                    ++cnt;\n                }\n            }\n            if (cnt == n - 1)\n                res = 1;\n        }\n        if (res) {\n            cout << 1 << '\\n';\n        } else {\n            cout << -1 << '\\n';\n        }\n\n    }\n    cerr << \"Time execute: \" << (double)clock() / (double)CLOCKS_PER_SEC \n    << \" sec\" << endl;\n}"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, r = [int(i) for i in input().split()]\n    balls = []\n    z = False\n    for _ in range(n):\n        balls.append([int(i) for i in input().split()])\n    for i in balls:\n        if max([abs(i[0] - j[0]) + abs(i[1] - j[1]) for j in balls]) <= r:\n            print(1)\n            z = True\n            break\n    if not z:\n        print(-1)"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint n,k,flag;\nstruct node{\n\tint x,y,num;\n}a[110];\nint main()\n{\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tflag=0;\n\t\tcin>>n>>k;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint tot=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\tint dis=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);\n\t\t\t\tif(dis<=k)\n\t\t\t\ttot++;\n\t\t\t}\n\t\t\tif(tot==n-1)\n\t\t\tflag=1;\n\t\t}\n\t\tif(flag==1)\n\t\tputs(\"1\");\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}"
        },
        {
            "language": 1,
            "solution": "import sys\nif sys.subversion[0] == \"PyPy\":\n    import io, atexit\n    sys.stdout = io.BytesIO()\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n    \n    sys.stdin = io.BytesIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip()\n\nRS = raw_input\nRI = lambda x=int: map(x,RS().split())\nRN = lambda x=int: x(RS())\n''' ...................................................................... '''\n\n\ndef dist(a,b):\n    return abs(a[0]-b[0])+abs(a[1]-b[1])\n\nfor _ in xrange(RN()):\n    n,k = RI()\n    data = [RI() for i in xrange(n)]\n\n    ans = -1\n\n    for i in xrange(n):\n        for j in xrange(n):\n            if dist(data[i],data[j])>k:\n                break\n        else:\n            ans=1\n            break\n\n    print ans\n            \n\n                \n    \n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom math import gcd,ceil,sqrt,ceil\nfrom math import gcd,ceil,floor,sqrt,copysign,factorial,fmod,fsum,degrees\nfrom math import expm1,exp,log,log2,acos,asin,cos,tan,sin,pi,e,tau,inf,nan,atan2\n\nINF = float('inf')\nMOD = 998244353\nmod = 10**9+7\nfrom collections import Counter,defaultdict as df\nfrom functools import reduce\ndef counter(l): return dict(Counter(l))\ndef printm(l):\n    for i in range(len(l[0])):\n        print(*l[i])\ndef P(n) : \n    if (n <= 1) :return False\n    if (n <= 3) :return True\n    if (n % 2 == 0 or n % 3 == 0) :return False\n    for i in range(5,ceil(sqrt(n))+1,6):\n        if (n % i == 0 or n % (i + 2) == 0) :return False\n    return True\nimport math\ndef lcm(a,b): \n    return int((a*b) / gcd(a,b))\ndef so(x):      return {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}\ndef rev(l):     return list(reversed(l))\ndef ini():      return int(sys.stdin.readline())\ndef inp():      return map(int, sys.stdin.readline().strip().split())\ndef li():       return list(map(int, sys.stdin.readline().strip().split()))\ndef input():    return sys.stdin.readline().strip()\ndef inputm(n,m):return [li() for i in range(n)]\ndef d(x1 , y1 , x2 , y2): \n    return abs(x1-x2)+abs(y1-y2)\ndef solve():\n    n,k=inp()\n    l=[]\n    for i in range(n):\n        l+=[li()]\n    c=0\n    t=0\n    for i in l:\n        c=0\n        for j in l:\n            if d(i[0],i[1],j[0],j[1])<=k:\n                c+=1\n        if c==n:\n            t=1\n            break\n    if t:\n        print(1)\n    else:\n        print(-1)\n    \n    \n        \n            \n            \n        \n    \n\n            \n            \n                        \n        \n        \n        \n            \n    \n        \n        \n    \n        \n    \n    \n        \n            \n            \n        \n    \n\n\n\n\n\n\nfor i in range(ini()):\n    solve()\n\n#\u0938\u0930\u094d\u0935\u092d\u0942\u0924\u0947\u0937\u094d\u0935\u092d\u092f\u0926\u0938\u094d\u0924\u0902 \u0926\u0947\u0935\u093e \u092c\u094d\u0930\u093e\u0939\u094d\u092e\u0923\u0902 \u0935\u093f\u0926\u0941\u0903 \u0965 \u092d\u093e\u0935\u093e\u0930\u094d\u0925 : \u091c\u094b \u0935\u094d\u092f\u0915\u094d\u0924\u093f \u0938\u092e\u094d\u092e\u093e\u0928 \u0926\u093f\u090f \u091c\u093e\u0928\u0947 \u0905\u0925\u0935\u093e \u0905\u092a\u092e\u093e\u0928 \u0915\u093f\u092f\u0947 \u091c\u093e\u0928\u0947 \u092a\u0930 \u0928 \u0924\u094b \u092a\u094d\u0930\u0938\u0928\u094d\u0928 \u0939\u094b\u0924\u093e \u0939\u0948 \u0914\u0930 \u0928 \u0939\u0940 \u0928\u093e\u0916\u0941\u0936, \u0914\u0930 \u091c\u094b \u0938\u092d\u0940 \u092a\u094d\u0930\u093e\u0923\u093f\u092f\u094b\u0902 \u0905\u092d\u092f \u0926\u0947\u0924\u093e \u0939\u0948 \u0909\u0938\u0940 \u0915\u094b \u0926\u0947\u0935\u0924\u093e\u0917\u0923 \u092c\u094d\u0930\u093e\u0939\u094d\u092e\u0923 \u0915\u0939\u0924\u0947 \u0939\u0948 \u0964 \u0928\u093e\u092d\u093f\u0928\u0928\u094d\u0926\u0947\u0924 \u092e\u0930\u0923\u0902 \u0928\u093e\u092d\u093f\u0928\u0928\u094d\u0926\u0947\u0924 \u091c\u0940\u0935\u093f\u0924\u092e\u094d \u0964\n           \n        \n        \n        \n        \n        \n        \n    \n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,k,x[105],y[105];\n\nvoid mian(){\n    cin>>n>>k;\n    int ans=-1;\n    for(int i=1;i<=n;i++){\n        cin>>x[i]>>y[i];\n    }\n    for(int i=1;i<=n;i++){\n        bool f=true;\n        for(int j=1;j<=n;j++){\n            if(abs(x[i]-x[j])+abs(y[i]-y[j])>k)f=false;\n        }\n        if(f)ans=1;\n    }\n    cout<<ans<<'\\n';\n}\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin>>T;\n    while(T--)mian();\n\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TaskB {\n    public static void main(String[] arg) {\n        final FastScanner in = new FastScanner(System.in);\n        final PrintWriter out = new PrintWriter(System.out);\n        final int T = in.nextInt();\n        for(int t=0;t<T;t++){\n            final int n = in.nextInt();\n            final int k = in.nextInt();\n            final int [][] a = new int[n][2];\n            for(int i=0;i<n;i++){\n                a[i][0]=in.nextInt();\n                a[i][1]=in.nextInt();\n            }\n            int s = -1;\n            for(int i=0;i<n;i++){\n                boolean sol = true;\n                for(int j=0;j<n;j++){\n                    int dist =\n                            Math.abs(a[i][0]-a[j][0])\n                            + Math.abs(a[i][1]-a[j][1]);\n                    if(dist>k){\n                        sol=false;\n                        break;\n                    }\n                }\n                if(sol){\n                    s=1;break;\n                }\n            }\n            out.println(s);\n        }\n        out.close();\n        in.close();\n    }\n\n    public static String solution(final char[] s, final int l, final int r){\n        for(int i=l-1;i>=0;i--){\n            if(s[i]==s[l]){\n                return \"YES\";\n            }\n        }\n        for(int i=r+1;i<s.length;i++){\n            if(s[i]==s[r]){\n                return \"YES\";\n            }\n        }\n        return \"NO\";\n    }\n\n    private static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream stream) {\n            try {\n                br = new BufferedReader(new InputStreamReader(stream));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readIntArr(int n) {\n            int[] result = new int[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = Integer.parseInt(next());\n            }\n            return result;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#include <fstream>\n#include<chrono>\n \n#define ll long long\n#define db double\n#define deb(x) cout<<#x<<\": \"<<x<<\"\\n\"\n#define all(x) x.begin(),x.end()\n#define fo(i, n) for(i=0 ; i<n ; i++)\n#define Fo(i, k, n) for(i=k ; i<n ; i++)\n#define setBits(x) __builtin_popcountll(x)\n#define parity(x) __builtin_parity(x)\n \nusing namespace std;\nusing namespace chrono;\n\nvoid solve()\n{\n    int n,k;cin>>n>>k;\n    vector<pair<int,int>>v(n);\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        v[i]={x,y};\n    }\n    bool flag=false;\n    for(int i=0;i<n;i++){\n        int x=v[i].first;int y=v[i].second;\n        bool flag_each=true;\n        for(int j=0;j<n;j++){\n            int a=v[j].first;int b=v[j].second;\n            if(( abs(a-x)+abs(b-y) )>k){flag_each=false;break;}\n        }\n        if(flag_each){flag =true;break;}\n    }\n    if(flag)cout<<1<<endl;\n    else cout<<-1<<endl;\n}\n\n\nint32_t main() {\n \n    int t;cin>>t;\n    while(t--)solve();\n\n    return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "BUFSIZE = 8192\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom bisect import bisect_left                 #c++ lowerbound bl(array,element)\nfrom bisect import bisect_right                #c++ upperbound br(array,element) \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfor _ in range(int(input())):\n    n,m=map(int,input().split())\n    a=[]\n    for i in range(n):\n        a.append(tuple(map(int,input().split())))\n        f=0\n        c=-1\n    for i in range(n):\n        f=0\n        for j in range(n):\n            if abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])<=m:\n                f+=1\n        if f==n:\n            c=1\n            break\n    print(c)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define fast ios_base::sync_with_stdio(false);  cin.tie(NULL); cout.tie(NULL);\n#define scan(a,n) for(long long int index=0;index<n;index++) cin>>a[index];\n#define print(a,n) for(long long int index=0;index<n;index++) cout<<a[index]<<\" \";cout<<endl;\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ss second\n#define ff first\n#define vli vector<long long int>\n#define vlli vector<pair<long long int,long long int>>\n#define vsi vector<string>\n#define all(n) n.begin(),n.end()\n#define forn(i,a,b) for(i=a;i<b;i++)\nll mul(ll x,ll y){  return (x*y)%mod;}\nll power(ll x, ll y) {ll res = 1; x %= mod;\n while (y) {if (y & 1)res = mul(res, x); y >>= 1; x = mul(x, x);} return res;}\nll mod_inv(ll x) {return power(x, mod - 2);}\nll fact(ll n) {ll res = 1; for (ll i = 2; i <= n; i++) res = mul(res , i); return res; } \nll nCr(ll n, ll r) { return mul(fact(n),mod_inv(mul(fact(r),fact(n - r))));} \n\n \nint main() {\n  fast;\n  #ifndef ONLINE_JUDGE\n  freopen(\"input.txt\",\"r\",stdin);\n  freopen(\"output.txt\",\"w\",stdout);\n  #endif\n  ll t=1;\n  cin>>t;\n  while(t--){\n    ll n,k;\n    cin>>n>>k;\n    ll a[n],b[n],i;\n    for(i=0;i<n;i++){\n      cin>>a[i]>>b[i];\n    }\n    ll f=-1,j;\n    ll x,y;\n    for(i=0;i<n;i++){\n     x=0;\n     for(j=0;j<n;j++){\n        y=abs(a[i]-a[j])+abs(b[i]-b[j]);\n      if(y<=k) x++;\n     }\n     if(x==n) f=1;\n    }\n    cout<<f<<endl;\n\n   \n\n\n    \n  }\nreturn 0;    \n }  "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        StringBuffer sb = new StringBuffer();\n        while(t-->0){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for(int i=0;i<n;i++){\n                StringTokenizer st1 = new StringTokenizer(br.readLine());\n                x[i]=Integer.parseInt(st1.nextToken());\n                y[i]=Integer.parseInt(st1.nextToken());\n            }\n            boolean possible=false;\n            for(int i=0;i<n;i++){\n                boolean flag = false;\n                for(int j=0;j<n;j++){\n                    int w = Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j]);\n                    if(w>k){\n                        flag=true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    possible=true;\n                }\n            }\n            if(!possible){\n                sb.append(\"-1\\n\");\n            }\n            else{\n                sb.append(\"1\\n\");\n            }\n        }\n        br.close();\n        System.out.println(sb);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class BallsOfSteel {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0) {\n\t\t\tint n = sc.nextInt(), k = sc.nextInt();\n\t\t\tint[][] a = new int[n][2];\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\ta[i][0] = sc.nextInt(); a[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\t\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tint maxDis = 0;\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tmaxDis = Math.max(maxDis, (Math.abs(a[i][0] - a[j][0]) + Math.abs(a[i][1] - a[j][1])));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(maxDis <= k)\tans = 1;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "\nt = int(input())\nfor _ in range(t):\n    n,k = map(int, input().split())\n    ali = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        ali.append(li)\n    for i in range(0,n):\n        f =0 \n        for j in range(n):\n            q = abs(ali[i][0]-ali[j][0])\n            w = abs(ali[i][1] - ali[j][1])\n            if(q+w > k):\n                f = 1\n                break\n        if(f == 0):\n            break\n        \n    if(f == 1):\n        print(-1)\n    else:\n        print(1)\n    \n\n    \n\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define pln puts(\"\")\n#define il inline\n#define For(i,a,b) for(int i=(a),(i##i)=(b);i<=(i##i);++i)\n#define rep(i,n) for(int i=0,(i##i)=(n);i<(i##i);++i)\n#define Fodn(i,a,b) for(int i=(a),(i##i)=(b);i>=(i##i);--i)\ntypedef long long LL;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef long double LD;\ntemplate<typename T>\nil bool read(T&x){\n    x=0;char c=getchar();int f=1;\n    while((c<'0'||c>'9')&&(c!='-')&&(c!=EOF))c=getchar();\n    if(c==EOF)return 0;if(c=='-')f=-1,c=getchar();\n    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c&15);c=getchar();}\n    x*=f;return 1;\n}\ntemplate<typename T,typename...Args>\nil bool read(T&x,Args&...args){bool res=1;res&=read(x);res&=read(args...);return res;}\nconst double EPS=1e-6;\nconst int M=1000000007,INF=0x3f3f3f3f;\nconst LL INFLL=0x3f3f3f3f3f3f3f3fLL;\nconst int N=1000010;\n\nint n,k;\nint x[N],y[N];\n\nil void init(){\n    read(n,k);\n    For(i,1,n)read(x[i],y[i]);\n}\n\nil int solve(){\n    For(i,1,n){\n        bool can=1;\n        For(j,1,n){\n            if(abs(x[i]-x[j])+abs(y[i]-y[j])>k){\n                can=0;break;\n            }\n        }\n        if(can){return 1;}\n    }\n    return -1;\n}\n\nint main(){\n    int t;read(t);\n    while(t--){\n        init();printf(\"%d\\n\",solve());\n    }\n\n\n    return 0;\n}"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor i in range(t):\n    n,k = map(int,input().split())\n    L = []\n    for j in range(n):\n        x,y = map(int,input().split())\n        L.append([x,y])\n    mn = 0\n    ok = False\n    for i in range(n):\n        mn = 0 \n        \n        for j in range(n):\n            if i!= j:\n                x = abs(L[i][0]-L[j][0]) + abs(L[i][1] - L[j][1])\n                mn = max(mn,x)\n        if mn<=k:\n            ok = True \n        \n    if ok == False:\n        print(-1)\n    else:\n        print(1)\n            "
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 111;\nint n, k;\nint a[N][2];\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &a[i][0], &a[i][1]);\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tok &= abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) <= k;\n\t\tif (ok) {\n\t\t\tprintf(\"1\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define pii pair < int, int >\n#define pll pair < long long, long long>\n#define ull unsigned long long\n#define y1 stupid_cmath\n#define left stupid_left\n#define right stupid_right\n#define vi vector <int>\n#define sz(a) (int)a.size()\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x))\n \nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nint n, k;\nll x[110], y[110];\n \nvoid solve() {\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tbool reachable = true;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tll dist = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n\t\t\tif (dist > k) {\n\t\t\t\treachable = false;\n\t\t\t}\n\t\t}\n\t\tif (reachable) {\n\t\t\tcout << 1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n \nint main(){\n \n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n \n    return 0;\n}\n \n"
        },
        {
            "language": 3,
            "solution": "def dist(a, b):\n   return abs(a[0]-b[0]) + abs(a[1]-b[1])\n         \nt=int(input())\nfor _ in range(t):\n   n, k = map(int, input().split())\n   points = []\n   for i in range(n):\n      x, y = map(int, input().split())\n      points.append([x,y])\n   deg = []\n   m = 0\n   for i in range(n):\n      d = 0\n      for j in range(n):\n         if (dist(points[i], points[j]) <= k):\n            d += 1\n      m = max(m, d)\n   #print(\"m\", m, \"n\", n)\n   if m < n:\n      print(-1)\n   else:\n      print(1)\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 110;\nstruct node{\n    int x,y;\n}e[MAXN];\nbool cmp(node a,node b){\n    return a.x<b.x;\n}\nint l[MAXN],r[MAXN];\nint main(){\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        int n,k;\n        scanf(\"%d%d\",&n,&k);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d\",&e[i].x,&e[i].y);\n        }\n        sort(e+1,e+n+1,cmp);\n        bool flag=false;\n        for(int i=2;i<=n;i++){\n            if(!(e[i].x==e[1].x&&e[i].y==e[1].y)) flag=true;\n        }\n        if(!flag){\n            printf(\"0\\n\");continue;\n        }\n        for(int i=1;i<=n;i++){\n            int pos=n;\n            for(int j=i+1;j<=n;j++){\n                if(abs(e[j].x-e[i].x)+abs(e[j].y-e[i].y)>k){\n                    pos=j-1;break;\n                }\n            }\n            r[i]=pos;\n            pos=1;\n            for(int j=i-1;j>=1;j--){\n                if(abs(e[j].x-e[i].x)+abs(e[j].y-e[i].y)>k){\n                    pos=j+1;break;\n                }\n            }\n            l[i]=pos;\n        }\n        flag=false;\n        for(int i=1;i<=n;i++){\n            if(l[i]==1&&r[i]==n) flag=true;\n        }\n        if(flag){\n            printf(\"1\\n\");\n        }\n        else printf(\"-1\\n\");\n       // printf(\"%d\\n\",dp[1][n]==1000?-1:dp[1][n]);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//Praise our lord and saviour qlf9\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class B{\npublic static void main(String[] omkar) throws Exception\n{\n   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n   StringTokenizer st = new StringTokenizer(in.readLine());\n   StringBuilder sb = new StringBuilder();\n   int cases = Integer.parseInt(st.nextToken());\n   for(int i = 0; i < cases; i++)\n   {\n      solve(in, st, sb);\n   }  \n   System.out.println(sb);\n        }\n public static void solve(BufferedReader in, StringTokenizer st, StringBuilder sb) throws Exception\n {\n  st = new StringTokenizer(in.readLine());\n  int n = Integer.parseInt(st.nextToken());\n  int k = Integer.parseInt(st.nextToken());\n  int[] x = new int[n];\n  int[] y = new int[n];\n  for(int i = 0; i < n; i++)\n  {\n      st = new StringTokenizer(in.readLine());\n      x[i] = Integer.parseInt(st.nextToken());\n      y[i] = Integer.parseInt(st.nextToken());\n  }\n  for(int i = 0; i < n; i++)\n  {\n      if(test(x, y, k, i))\n      {\n         sb.append(\"1\\n\");\n         return;\n      }\n  }\n  sb.append(\"-1\\n\");\n         return;\n }\n public static boolean test(int[] x, int[] y, int k, int ind)\n {\n   for(int j = 0; j < x.length; j++)\n   {\n      if(Math.abs(x[j]-x[ind])+Math.abs(y[j]-y[ind]) > k)\n      {\n         return false;\n      }\n   }\n   return true;\n }\n public static int[] readArr(int N, BufferedReader in, StringTokenizer st) throws Exception\n      {\n         int[] arr = new int[N];\n         st = new StringTokenizer(in.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         return arr;\n      }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _1450B {\n    static int[] MODS = {1000000007, 998244353, 1000000009};\n    static int MOD = MODS[0];\n\n    public static void main(String[] args) {\n        sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int[][] points = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                points[i][0] = sc.nextInt();\n                points[i][1] = sc.nextInt();\n            }\n            boolean found = false;\n            for (int i = 0; i < n; i++) {\n                boolean bad = false;\n                for (int j = 0; j < n; j++) {\n                    int dist = Math.abs(points[i][0]-points[j][0])+Math.abs(points[i][1]-points[j][1]);\n                    if (dist > k) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (!bad) {\n                    found = true;\n                }\n            }\n            if (!found) {\n                out.println(-1);\n            } else {\n                out.println(1);\n            }\n        }\n        out.close();\n    }\n\n    public static int[] sort(int[] arr) {\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n            list.add(arr[i]);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = list.get(i);\n        }\n        return arr;\n    }\n\n    public static void scan(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = sc.nextInt();\n        }\n    }\n\n    public static MyScanner sc;\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long int\n#define ll long long\n#define quickie ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define rep(i, a, b) for(int i=a; i<b; i++)\n#define rep1(i, a, b) for(int i=a; i<=b; i++)\n#define repp(i, a, b) for(int i=b-1; i>=a; i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define db double\n#define mi map<int, int>\n#define vi vector<int>\n#define qi queue<int>\n#define mod 1000000007 ;\n#define MI(x) power(x, mod-2)\n#define test int t; cin >> t;\n#define all(a) a.begin(),a.end()\n#define pi 3.141592653589\n#define fact(n) rep(i, 1, n+1)ft.pb((ft[i-1]*i)%mod) ;\nint power(int x, int y) ;\nint gcd(int a, int b) ;\n\nint power(int x, int y) {\n    int res = 1; x %= mod;\n    while (y > 0) {\n        if (y & 1)\n            res = (res*x) % mod;\n        y = y>>1;\n        x = (x*x) % mod;\n    }\n    return res%mod;\n}\n\nint gcd(int a,int b) {\n    if(a==0) return b;\n    return gcd(b%a,a);\n}\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n// template<typename T>\n// using ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n// template<typename T>\n// using ordered_multiset = tree<T,null_type,less_equal<T>,rb_tree_tag,tree_order_statistics_node_update>;\n//(*****FOR USING ORDERED SET CHANGE INT*******)\n\n// struct chash {\n//     const int RANDOM = (long long)(make_unique<char>().get()) ^ chrono::high_resolution_clock::now().time_since_epoch().count();\n//     static unsigned long long hash_f(unsigned long long x) {\n//         x += 0x9e3779b97f4a7c15;\n//         x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n//         x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n//         return x ^ (x >> 31);\n//     }\n//     static unsigned hash_combine(unsigned a, unsigned b) { return a * 31 + b; }\n//     int operator()(int x) const { return hash_f(x)^RANDOM; }\n// };   \n\nsigned main() {\n    quickie\n    test\n    while(t--) {\n        int n, k ;\n        cin >> n >> k ;\n        vector<pair<int, int>> v ;\n        rep(i, 0, n) {\n            int x, y ;\n            cin >> x >> y ;\n            v.pb({x, y}) ;\n        }\n        int ans = -1 ;\n        rep(i, 0, n) {\n            int f = 0 ;\n            rep(j, 0, n) {\n                if(i == j) \n                    continue ;\n                if(abs(v[i].fi-v[j].fi) + abs(v[i].se-v[j].se) > k) {\n                    f = 1 ;\n                    break ;\n                }\n            }\n            if(f == 0) {\n                ans = 1 ;\n                break ;\n            }\n        }\n        cout << ans << \"\\n\" ;\n    }\n} "
        },
        {
            "language": 4,
            "solution": "\n/**\n * Date: 06 Dec, 2020\n * Link: https://codeforces.com/contest/1450/problem/B\n * \n * @author: Prasad Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\npublic class B_1450 {\n\n    public static void main(String[] args) throws IOException {\n        FastIO in = new FastIO(args);\n        int t = in.ni();\n        while (t-- > 0) {\n            int n = in.ni();\n            int k = in.ni();\n            int a[][] = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                a[i] = new int[] { in.ni(), in.ni() };\n            }\n            boolean p = false;\n            for (int i = 0; i < n; i++) {\n                boolean q = true;\n                for (int j = 0; j < n; j++) {\n                    q &= Math.abs(a[i][0] - a[j][0]) + Math.abs(a[i][1] - a[j][1]) <= k;\n                }\n                p |= q;\n            }\n            System.out.println(p ? 1 : -1);\n        }\n        in.bw.flush();\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            if (a == o.a) {\n                return Integer.compare(b, o.b);\n            }\n            return Integer.compare(a, o.a);\n        }\n\n        public static void sort(int a[]) {\n            Data d[] = new Data[a.length];\n            for (int i = 0; i < a.length; i++) {\n                d[i] = new Data(a[i], 0);\n            }\n            Arrays.sort(d);\n            for (int i = 0; i < a.length; i++) {\n                a[i] = d[i].a;\n            }\n        }\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n\n        public FastIO(String[] args) throws IOException {\n            if (args.length > 1) {\n                br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(args[0]))));\n                bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(args[1]))));\n            } else {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            }\n            s = br.readLine().split(\" \");\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n        }\n\n        public void print(int s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(int s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        public void print(long s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(long s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        public void print(double s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(double s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.TreeSet;\nimport java.util.SortedSet;\nimport java.util.Iterator;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\npublic class BallsOfSteel\n{\n\tstatic int k,n;\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint  t = sc.nextInt();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\tArrayList<Point> points = new ArrayList<Point>();\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tpoints.add(new Point(sc.nextInt(),sc.nextInt()));\n\t\t\t}\n\t\t\n\t\t\tfind(points);\n\t\t}\n\t}\n\n\n\tpublic static void find(ArrayList<Point> points)\n\t{\n\t\tSortedSet<Map.Entry<Point,ArrayList<Point>>> sortedSet = new TreeSet<Map.Entry<Point,ArrayList<Point>>>(new Comparator<Map.Entry<Point,ArrayList<Point>>>() {\n       \t \t    @Override\n\t\t    public int compare(Map.Entry<Point,ArrayList<Point>> o1, Map.Entry<Point,ArrayList<Point>> o2) {\n   \t\t\t    if(  o2.getValue().size()==o1.getValue().size())return 1;\n\t\t\t    return o2.getValue().size()-o1.getValue().size();\n   \t\t }\n\t\t});\n\t\t\n\t\tHashMap<Point, ArrayList<Point>> neighbours = new HashMap<Point,ArrayList<Point>>();\n\n\t\tfor(int i = 0;i<points.size();i++)\n\t\t{\t\n\t\t\tneighbours.put(points.get(i), new ArrayList<Point>());\n\t\t}\n\n\t\tfor(int i = 0;i<points.size();i++)\n\t\t{\n\t\t\tPoint target = points.get(i);\n\t\t\tfor(int j = 0;j<points.size();j++)\n\t\t\t{\n\t\t\t\tPoint tmp = points.get(j);\n\t\t\t\tif(i!=j)\n\t\t\t\t{\n\t\t\t\t\tfloat dist = Math.abs(target.x-tmp.x)+Math.abs(target.y-tmp.y);\n\t\t\t\t\tif(dist<=k)\n\t\t\t\t\t{\n\t\t\t\t\t\tneighbours.get(target).add(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tArrayList<Point> tmp = neighbours.get(0);\n\t\tsortedSet.addAll(neighbours.entrySet());\n\n\t\t//for(Object i : neighbours.entrySet())\n\t\t//\tSystem.out.println(i);\n\n\t\t//System.out.println(sortedSet.size());\n\t\tPoint point = sortedSet.first().getKey();\n\t\t\n\t\tint ctr = 0;\n\t\twhile (true)\n\t\t{\n\t\t\t//System.out.println(\"Out Size \"+neighbours.get(point).size()+\"\\t\"+point.x+\"\\t\"+point.y+\"\\t\"+sortedSet.size());\t\n\t\t\tif(neighbours.get(point).size()==0)\n\t\t\t{\n\t\t\t\tif(sortedSet.size()!=1)\n\t\t\t\t{\n\t\t\t\t\tctr=-1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tArrayList<Point> neighbour = neighbours.get(point);\n\t\t\twhile(neighbour.size()>0)\n\t\t\t{\n\t\t\t\tPoint neigh = neighbour.get(0);\n\t\t\t\tArrayList<Point> ineighbour = neighbours.get(neigh);\n\t\t\t\tfor(Point j : ineighbour){\n\t\t\t\t\tneighbours.get(j).remove(neigh);\n\t\t\t\t\t//System.out.println(j.x+\"\\t\"+j.y+\"\\t\\t\"+neigh.x+\"\\t\"+neigh.y);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"Size \"+neighbours.get(point).size());\n\t\t\t\tneighbours.remove(neigh);\n\t\t\t}\n\t\t\t\n\t\t\tctr++;\n\t\t\t\n\t\t\t sortedSet = new TreeSet<Map.Entry<Point,ArrayList<Point>>>(new Comparator<Map.Entry<Point,ArrayList<Point>>>() {\n       \t \t    @Override\n\t\t    public int compare(Map.Entry<Point,ArrayList<Point>> o1, Map.Entry<Point,ArrayList<Point>> o2) {\n   \t\t\t    if(  o2.getValue().size()==o1.getValue().size())return 1; \n\t\t\t    return o2.getValue().size()-o1.getValue().size();\n   \t\t }\n\t\t});\n\n\n\t\t\t//System.out.println(neighbours.keySet().size());\n\t\t\tsortedSet.addAll(neighbours.entrySet());\n\t\t\tpoint = sortedSet.first().getKey();\n                       \t\n\t\t\t//System.out.println(\"Dick Size \"+sortedSet.size());\n\t\t}\n\n\t\tSystem.out.println(ctr);\n\t\t\n\t}\n\n\tstatic class Point\n\t{\n\t\tpublic int x;\n\t\tpublic int y;\n\t\tpublic Point(int x, int y)\n\t\t{\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\n}\n\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    ans = -1\n    for i in range(n):\n        count=0\n        for j in range(n):\n            if abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])<=k:\n                count+=1\n        if count==n:\n            ans=1\n            break\n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#ifndef ONLINE_JUDGE\n\t#include \"debug.cpp\"\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nvoid solve()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int> > vp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tvp.push_back({x, y});\n\t}\n\t\n\tint ans = 0;\n\tbool ok = 0;\n\t// int cnt = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\t// bad = 1;\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (abs(vp[i].first - vp[j].first) + abs(vp[i].second - vp[j].second) <= k)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tif (cnt == n)\n\t\t\tok = 1;\n\t\t// if (cnt < n)\n\t\t// {\n\t\t// \tcout << \"-1\\n\";\n\t\t// \treturn;\n\t\t// }\n\t}\n\tif (ok)\n\t\tcout << \"1\\n\";\n\telse\n\t\tcout << \"-1\\n\";\n\t// cout << \"1\\n\";\n}\n\nint32_t main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.BufferedReader;\nimport java.util.*;\n\npublic class B {\n\tprivate static final FastReader fs = new FastReader();\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\t\n\tprivate static class pair implements Comparable<pair>{\n\t\tlong x,y;\n\t\tpublic pair(long x,long y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tlong man(pair o) {\n\t\t\treturn Math.abs(x-o.x)+Math.abs(y-o.y);\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif(x == o.x)\n\t\t\t\treturn Long.compare(y, o.y);\n\t\t\treturn Long.compare(x, o.x);\n\t\t}\n\t\tboolean isEqual(pair o) {\n\t\t\tif(x == o.x && y == o.y)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void solve() {\n\t\tint n = fs.nextInt(),k = fs.nextInt();\n\t\tpair[] p = new pair[n];\n\t\tfor(int i = 0; i<n; i++)\n\t\t\tp[i] = new pair(fs.nextLong(),fs.nextLong());\n\t\tint[] ans = new int[n];\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tfor(int j = 0; j<n; j++) {\n\t\t\t\tif(i!=j && p[i].man(p[j]) <= k)\n\t\t\t\t\tans[j]+=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tif(ans[i] >= n-1) {\n\t\t\t\tout.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(-1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tThread t = new Thread(null, null, \"\", 1 << 28) {\n\t\t\tpublic void run() {\n\t\t\t\tint test_case = 1;\n\t\t\t\ttest_case = fs.nextInt();\n\t\t\t\tfor (int cs = 1; cs <= test_case; cs++) {\n\t\t\t\t\tsolve();\n\t\t\t\t}\n\t\t\t\tout.close();\n\t\t\t}\n\t\t};\n\t\tt.start();\n\t\ttry {\n\t\t\tt.join();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readintarray(int n) {\n\t\t\tint res[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\n\t\tlong[] readlongarray(int n) {\n\t\t\tlong res[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate static class cf {\n\t\tpublic static long power(long base, long exponent) {\n\t\t\tlong res = 1;\n\t\t\twhile (exponent > 0) {\n\t\t\t\tif (exponent % 2 == 1)\n\t\t\t\t\tres *= base;\n\t\t\t\texponent >>= 1;\n\t\t\t\tbase *= base;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic static long mul(long a, long b, long mod) {\n\t\t\treturn (a % mod * b % mod) % mod;\n\t\t}\n\n\t\tpublic static long add(long a, long b, long mod) {\n\t\t\treturn (a % mod + b % mod) % mod;\n\t\t}\n\n\t\tpublic static long sub(long a, long b, long mod) {\n\t\t\treturn ((a % mod - b % mod) % mod + mod) % mod;\n\t\t}\n\n\t\tpublic static long power(long base, long exponent, long mod) {\n\t\t\tlong res = 1;\n\t\t\tbase %= mod;\n\t\t\twhile (exponent > 0) {\n\t\t\t\tif (exponent % 2 == 1)\n\t\t\t\t\tres = mul(res, base, mod);\n\t\t\t\texponent >>= 1;\n\t\t\t\tbase = mul(base, base, mod);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic static void sortIntArray(int[] a) {\n\t\t\tArrayList<Integer> tmp = new ArrayList<>();\n\t\t\tfor (int x : a)\n\t\t\t\ttmp.add(x);\n\t\t\tCollections.sort(tmp);\n\t\t\tfor (int i = 0; i < tmp.size(); i++)\n\t\t\t\ta[i] = tmp.get(i);\n\t\t}\n\n\t\tpublic static void sortLongArray(long[] a) {\n\t\t\tArrayList<Long> tmp = new ArrayList<>();\n\t\t\tfor (long x : a)\n\t\t\t\ttmp.add(x);\n\t\t\tCollections.sort(tmp);\n\t\t\tfor (int i = 0; i < tmp.size(); i++)\n\t\t\t\ta[i] = tmp.get(i);\n\t\t}\n\n\t\tpublic static <T extends Comparable<T>> void sort(T[] a) {\n\t\t\tArrayList<T> tmp = new ArrayList<>();\n\t\t\tfor (T x : a)\n\t\t\t\ttmp.add(x);\n\t\t\tCollections.sort(tmp);\n\t\t\tfor (int i = 0; i < tmp.size(); i++)\n\t\t\t\ta[i] = tmp.get(i);\n\t\t}\n\n\t\tpublic static class pair<T1 extends Comparable<T1>, T2 extends Comparable<T2>>\n\t\t\t\timplements Comparable<pair<T1, T2>> {\n\t\t\tT1 ff;\n\t\t\tT2 ss;\n\n\t\t\tpublic pair(T1 ff, T2 ss) {\n\t\t\t\tthis.ff = ff;\n\t\t\t\tthis.ss = ss;\n\t\t\t}\n\n\t\t\tpublic int compareTo(pair<T1, T2> o) {\n\t\t\t\tif (ff == o.ff)\n\t\t\t\t\treturn ss.compareTo(o.ss);\n\t\t\t\treturn ff.compareTo(o.ff);\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std ;\n\t#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n\t#define ll long long int\n\n//////////////////////////////////////////////////////////////////////////////////////////////\nvoid solve();\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n\nint main ()\n{\n\t// fastio\n\n \tll  t;\n \tcin>>t;\n \twhile(t--)\n \t{\n\tsolve();\n\n \t}\n}\n///////////////////////////////////////////\nvoid solve()\n{\n\n\tll n,i,doit=0,a,b,check=0,j,k;\n\tcin>>n>>k;\n\tll temp=0 ,count =0;\n\tvector<pair<ll,ll>>pq;\n\tfor( i=0;i<n;i++){\n\t\tcin>>a>>b;\n\n\t\tpq.push_back({a,b});\n\t}\n\tdoit=0;\n\tfor(ll i=0;i<n;i++){\n\t\tcheck= 0;\n\t\ta+=b;\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(i==j)\n\t\t\tcontinue;\n\t\t\ta++;\n\t\t\ta++;\n\t\t\tb++;\n\t\t\tb++;\n\t\t\ta+=b;\n\t\t\ta++;\n\t\t \ttemp =  abs(pq[i].first-pq[j].first);\n\t\t\tb++;\n\t\t\tb++;\n\t\t\tb+=a;\n\t\t\ttemp+=abs(pq[i].second-pq[j].second);\n\t\t\ta++;\n\t\t\ta++;\n\t\t\tb++;\n\t\t\tif(temp<=k)check++;\n\n\n\t\t}\n\n\n\t\tif(check==n-1)\n\t\tdoit= 1;\n\t\ta++;\n\t\ta++;\n\n\t}\n\t// (!doit)?cout<<-1<<\"\\n\":cout<<1<<\"\\n\";\n\tif(doit)\n\t\t\tcout<<1<<endl;\n\t\telse\n\t\t\tcout<<-1<<endl;\n\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t    int t;\n\t    Scanner in=new Scanner(System.in);\n\t    t=in.nextInt();\n\t    while(t-->0)\n\t    {\n\t        int n,k;\n\t        n=in.nextInt();\n\t        k=in.nextInt();\n\t        int x[]=new int[n];\n\t        int y[]=new int[n];\n\t        for(int i=0;i<n;i++)\n\t        {\n\t            x[i]=in.nextInt();\n\t            y[i]=in.nextInt();\n\t        }\n\t        for(int i=0;i<n;i++)\n\t        {\n\t            for(int j=0;j<n;j++)\n\t            {\n\t                if(Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j])>k)\n\t                {\n\t                   break; \n\t                }\n\t                if(j==n-1)\n\t                {\n\t                    System.out.println(\"1\");\n\t                    i=n+1;\n\t                }\n\t            }\n\t            if(i==n-1)\n\t            {\n\t                System.out.println(\"-1\");\n\t            }\n\t        }\n\t    }\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def balls_of_steel (n,k,balls) :\n    current_index = 0\n    while current_index < len(balls) :\n        compare = balls[current_index]\n        terminate = 1\n        for i,j in balls :  \n            ans = abs(compare[0]-i) + abs(compare[1]-j)\n            if ans > k :\n                terminate = 0\n                break\n                \n        \n        if terminate == 0 :\n            current_index += 1\n        \n        else :\n            return 1\n            \n    return -1\n    \n    \ntest = int(input())\nfor y in range(test) :\n    n,k = list(map(int,input().split()))\n    balls = []\n    for x in range(n) :\n        q = list(map(int,input().split()))\n        balls.append(q)\n    print (balls_of_steel(n,k,balls))\n\n    \n            \n        "
        },
        {
            "language": 2,
            "solution": "# include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll  t,c,f,x,x1,y,n,k;\n    cin>>t;\n    while(t--)\n    {\n\n    cin>>n>>k;\n    ll a[n],b[n];\n    for(int i=0; i<n; i++)\n    {\n        cin>>a[i]>>b[i];\n\n    }\n     x1=0;\n    for(int i=0; i<n; i++)\n\n    {\n        c=0;\n        for(int j=0; j<n; j++)\n        {\n\n             x=abs(a[i]-a[j]);\n            y=abs(b[i]-b[j]);\n\n            if(x+y<=k)\n            {\n                c++;\n                continue;\n            }\n            else\n                break;\n\n        }\n        if(c==n)\n            x1=1;\n    }\n\n    if(x1)\n        cout<<1<<endl;\n    else\n        cout<<-1<<endl;\n}\n}"
        },
        {
            "language": 3,
            "solution": "from math import *\nfrom bisect import *\nfrom collections import *\nfrom random import *\nfrom decimal import *\nimport sys\ninput=sys.stdin.readline\ndef inp():\n    return int(input())\ndef st():\n    return input().rstrip('\\n')\ndef lis():\n    return list(map(int,input().split()))\ndef ma():\n    return map(int,input().split())\nt=inp()\nwhile(t):\n    t-=1\n    n,k=ma()\n    r=[]\n    for i in range(n):\n        x,y=ma()\n        r.append([x,y])\n    fl=0\n    for i in range(n):\n        co=0\n        for j in range(n):\n            m=abs(r[j][0]-r[i][0])+abs(r[j][1]-r[i][1])\n            if(m<=k):\n                co+=1\n        if(co==n):\n            fl=1\n            break\n    if(fl):\n        print(1)\n    else:\n        print(-1)\n            \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst ld PI = acos(-1);\n\nvoid solve(){\n    ll n,k;\n    cin >> n >> k;\n    vector<pair<ll,ll>> a(n);\n    for(int i=0;i<n;i++){\n        cin >> a[i].first >> a[i].second;\n    }\n    bool isBad = false;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(abs(a[j].first - a[i].first) + abs(a[j].second - a[i].second) > k){\n                isBad = true;\n            }\n        }\n        if(!isBad){\n            cout << 1 << \"\\n\";\n            return;\n        }\n        isBad = false;\n    }\n    cout << -1 << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll t;\n    cin >> t;\n    while(t--)solve();\n    return 0;\n}"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef distance(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef balls_of_steel(P, n, k):\n    for i, p1 in enumerate(P):\n        possible = True\n        total_dist = 0\n        for j, p2 in enumerate(P):\n            dist = distance(p1, p2)\n            total_dist += dist\n            if dist > k:\n                possible = False\n                break\n        if possible:\n            break\n    if not possible:\n        return -1\n    else:\n        return 1 if total_dist > 0 else 0\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    P = [ [int(v) for v in input().split()] for _ in range(n) ]\n    ans = balls_of_steel(P, n, k)\n    print(ans)"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\n\nMOD = 998244353\nmod = 10**9 + 7\n\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\ndef prepare_factorial():\n    fact = [1]\n    for i in range(1, 20):\n        fact.append((fact[-1] * i) % mod)\n    ifact = [0] * 105\n    ifact[104] = pow(fact[104], mod - 2, mod)\n    for i in range(104, 0, -1):\n        ifact[i - 1] = (i * ifact[i]) % mod\n\n    return fact, ifact\n\n# import threading\n# threading.stack_size(1<<27)\nimport sys\n# sys.setrecursionlimit(10000)\n\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial\nfrom heapq import heappop, heapify, heappush\nfrom collections import Counter, defaultdict, deque\n# from itertools import permutations\n\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef ncr(n, r, fact, ifact):    # for using this uncomment the lines calculating fact and ifact\n    t = (fact[n] * (ifact[r] * ifact[n-r]) % mod) % mod\n    return t\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"*****************************************************************************************\"\"\"\n\ndef GCD(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x * y)//(GCD(x, y))\n\ndef get_xor(n):\n    return [n, 1, n+1, 0][n % 4]\n\ndef get_n(P):    # this function returns the maximum n for which Summation(n) <= Sum\n    ans = (-1 + sqrt(1 + 8*P))//2\n    return ans\n\n\"\"\" ********************************************************************************************* \"\"\"\n\ndef main():\n\n    T = int(input())\n    while T:\n\n        n, k = get_ints()\n        flag = 0\n        Arr = []\n        for i in range(n):\n            x, y = get_ints()\n            Arr.append((x, y))\n\n        for i in range(n):\n            currx, curry = Arr[i][0], Arr[i][1]\n            flag1 = 0\n            for j in range(n):\n                if abs(currx - Arr[j][0]) + abs(curry - Arr[j][1]) > k:\n                    flag1 = 1\n                    break\n            if flag1 == 0:\n                flag = 1\n                break\n\n        if flag == 1:\n            print(1)\n        else:\n            print(-1)\n        T -= 1\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()"
        },
        {
            "language": 3,
            "solution": "\nfor i in range(int(input())):\n    a=[int(j) for j in input().split()]\n    n=a[0]\n    k=a[1]\n    x=[]\n    y=[]\n    s=0\n    for i in range(n):\n        a=[int(j) for j in input().split()]\n        x.append(a[0])\n        y.append(a[1])\n    for i in range(n):\n        j=0\n        t=0\n        while j<n:\n            if (abs(x[i]-x[j]) + abs(y[i]-y[j]))>k:\n                t=1\n                break\n            j+=1 \n        if t==0:\n            s=1\n            break\n    if s==1:\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\tfor(int tt = 0; tt < t; tt++)\n\t\t{\n\t\t\tint n,k;\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\tboolean check = false;\n\t\t\tpair[] coords = new pair[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tcoords[i] = new pair(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif(hamilton(coords[i], coords[j]) <= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(count == n)\n\t\t\t\t{\n\t\t\t\t\tcheck = true;\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!check)\n\t\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n\t\n\tpublic static int hamilton(pair one, pair two)\n\t{\n\t\treturn Math.abs(one.getX()-two.getX())+Math.abs(one.getY()-two.getY());\n\t}\n}\n\nclass pair\n{\n\tprivate int x;\n\tprivate int y;\n\tpublic pair(int x, int y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\tpublic int getX() {\n\t\treturn x;\n\t}\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\tpublic int getY() {\n\t\treturn y;\n\t}\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long int\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nconst int N = 3e5 + 7;\nint32_t main(){\n    IOS;\n    int t;\n    cin >> t;\n    while(t--){\n        int n,k;\n        cin >> n >>k;\n        vector<pair<int,int>> parth;\n        for(int i = 0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            parth.push_back(make_pair(x,y));\n        }\n        sort(parth.begin(), parth.end());\n        int flag = -1;\n        int p;\n        for(int i = 0;i < n; i++){\n            int count = 0;\n            for(int j = 0;j < n; j++){\n                p = abs(parth[i].first-parth[j].first)+abs(parth[i].second-parth[j].second);\n                if(p<=k) count++;\n            }\n            if(count==n){\n                flag = true;\n                break;\n            }\n        }\n        \n\n        \n        cout << flag << endl;\n    }\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\npublic class problems {\n\t \n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\twhile(t>0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tint k=sc.nextInt();\n\t\t\tArrayList<ArrayList<Integer>> a=new ArrayList<>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tint y=sc.nextInt();\n\t\t\t\tArrayList<Integer> arr=new ArrayList<>();\n\t\t\t\tarr.add(x);\n\t\t\t\tarr.add(y);\n\t\t\t\ta.add(arr);\n\t\t\t}\t\t\n\t\t\tsolve(n,a,k);\n\t\t\tt--;\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic void solve(int n,ArrayList<ArrayList<Integer>> a,int k) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint count=0;\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif(j!=i) {\n\t\t\t\t\tArrayList<Integer> arr=a.get(i);\n\t\t\t\t\tArrayList<Integer> brr=a.get(j);\n\t\t\t\t\tif(Math.abs(arr.get(0)-brr.get(0))+Math.abs(arr.get(1)-brr.get(1))>k) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count==n-1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\tstatic boolean isPrime(long n) {\n\t\tfor(long i=2;i*i<=n;i++) {\n\t\t\tif(n%i==0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class A\n{\n\tprivate boolean ONLINE_JUDGE=System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate boolean TESTCASES=true;\n\tprivate boolean INTERACTIVE=false;\n\tprivate int MAX=100005;\n\tprivate long mod=(long)1e9+7;//(long)998244353;\n\tprivate int IMX=Integer.MAX_VALUE,IMN=Integer.MIN_VALUE;\n\tprivate long LMX=Long.MAX_VALUE,LMN=Long.MIN_VALUE;\n\n\tReader r;\n\tWriter w;\n\n\tvoid preprocess() throws Exception\n\t{\n\t\t/*Preprocess Here!!*/\n\t}\n\tpublic int gcd(int n1,int n2)\n\t{\n\t\twhile(n1 != n2)\n        {\n            if(n1 > n2)\n                n1 -= n2;\n            else\n                n2 -= n1;\n        }\n        return n1;\n\t}\n\tvoid solve(int tc) throws Exception\n\t{\n\t\tint n=r.ni();\n\t\tint k=r.ni();\n\t\tint arr[][]=new int[n][2];\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tarr[i][0]=r.ni();\n\t\t\tarr[i][1]=r.ni();\t\t\t\n\t\t}\n\t\tint yes=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\n\n\t\t\tint x=arr[j][0];\n\t\t\tint y=arr[j][1];\n\n\t\t\tint no=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif((Math.abs(arr[i][0]-x) + Math.abs(arr[i][1]-y))>k)\n\t\t\t\t\tno=1;\n\t\t\t}\n\t\t\n\t\t\tif(no==0)\n\t\t\t\tyes=1;;\n\t\t\n\t\t}\n\t\tif(yes==0)\n\t\t\tw.pl(-1);\n\t\telse\n\t\t\tw.pl(1);\n\t}\n\t\n\tvoid run() throws Exception\n\t{\t\n\t\tr=!ONLINE_JUDGE || INTERACTIVE? new Reader(\"Ainput.txt\"):new Reader();\n\t\tw=!ONLINE_JUDGE || INTERACTIVE? new Writer(\"Aoutput.txt\"):new Writer();\n\t\t\n\t\tpreprocess();\n\t\t\n\t\tint i,t=TESTCASES? r.ni():1;\n\t\tfor(i=1;i<=t;i++)\n\t\t\tsolve(i);\n\t\t\n\t\tw.f();\n\t\tw.c();\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew A().run();\n\t}\n\t\n\n\tclass Reader\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic Reader()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic Reader(String f) throws Exception\n\t\t{\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t}\n\t\tString get() throws Exception\n\t\t{\t\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst =new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException  e)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(e.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tString nl() throws Exception //nextLine\n\t\t{\t\n\t\t\tString str = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new Exception(e.toString());\n\t\t\t}  \n\t\t\treturn str;\n\t\t}\n\t\tint ni() throws Exception //nextInt\n\t\t{\n\t\t\treturn Integer.parseInt(get());\n\t\t}\n\t\tlong nlo() throws Exception //nextLong\n\t\t{\n\t\t\treturn Long.parseLong(get());\n\t\t}\n\t\tdouble nd() throws Exception //nextDouble\n\t\t{\n\t\t\treturn Double.parseDouble(get());\n\t\t}\n\t\tBigInteger nbi() throws Exception //nextBigInteger\n\t\t{\n\t\t\treturn new BigInteger(get());\n\t\t}\n\t\tBigDecimal nbd() throws Exception //nextBigDouble\n\t\t{\n\t\t\treturn new BigDecimal(get());\n\t\t}\n\t}\n\t\n\tclass Writer{\n\n\t\tPrintWriter pr;\n\t\tpublic Writer()\n\t\t{\n\t\t\tpr=new PrintWriter(System.out);\n\t\t}\n\t\tpublic Writer(String f) throws Exception\n\t\t{\n\t\t\tpr=new PrintWriter(f);\n\t\t}\n\t\tvoid p(Object o) throws Exception //print\n\t\t{\n\t\t\tpr.print(o);\n\t\t}\n\t\tvoid pl(Object o) throws Exception //printline\n\t\t{\n\t\t\tpr.println(o);\n\t\t}\n\t\tvoid f() throws Exception //flush\n\t\t{\n\t\t\tpr.flush();\n\t\t}\n\t\tvoid c() throws Exception //close\n\t\t{\n\t\t\tpr.close();\n\t\t}\n\t\tvoid pf(Object o) throws Exception //printflush\n\t\t{\n\t\t\tp(o);\n\t\t\tf();\n\t\t}\n\t}\n\n\tclass pair<T,G>\n\t{\n\t\tT x; G y;\n\t\tpublic pair(){}\n\t\tpublic pair(T x,G y)\n\t\t{\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn \" <\"+x.toString()+\",\"+y.toString()+\"> \";\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\nint main(){\n    int t, n, k;\n    cin>> t;\n\n    while(t--){\n        cin >> n >> k;\n        int res = -1;\n        vector<pair<int, int> > pts(n);\n        int x , y;\n        for (int i = 0; i < n; i++){\n            cin >> x >> y;\n            pts[i] = make_pair(x, y);\n        }\n\n        for (int i = 0; i < n; i++){\n            int cnt = 0;\n            for (int j = 0; j < n; j++){\n                if (abs(pts[i].first - pts[j].first) + abs(pts[i].second - pts[j].second) <= k)\n                    cnt++;\n            }\n            if (cnt == n)\n                res = 1;\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \"  \" << H; dbg_out(T...); }\n\n#ifdef SMIE\n#define debug(args...) cerr << \"(\" << #args << \"):\", dbg_out(args)\n#else\n#define debug(args...)\n#endif\n\nlong long dis(pair<long long, long long> a, pair<long long, long long> b) {\n    return abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0) {\n        //remeber to clear variable\n        int n;\n        long long k;\n        vector<pair<long long, long long>> points;\n\n        cin >> n >> k;\n        for (int i = 0; i < n; i++ ) {\n            long long x, y;\n            cin >> x >> y;\n            points.push_back({x, y});\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i++) {\n            bool cur_ok = true;\n            for (int j = 0; j < n; j++) {\n                if (dis(points[i], points[j]) > k) {\n                    cur_ok = false;\n                    break;\n                }\n            }\n            if (cur_ok == true) {\n                ok = true;\n                break;\n            }\n        }\n        if (ok == true) {\n            puts(\"1\");\n        } else {\n            puts(\"-1\");\n        }\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "using namespace std;\n\n#include <iostream>\n#include <set>\n#include <queue>\n#include <cstring>\n\n#define MAXN 105\n\nint arrX[MAXN],arrY[MAXN],degree[MAXN],important[MAXN];\nbool edges[MAXN][MAXN],visited[MAXN];\n\nint main() {\n\tint T;\n\tcin >> T;\n\twhile(T--) {\n\t\tint N,K;\n\t\tcin >> N >> K;\n\t\tint counter = N;\n\t\tfor(int i = 0;i < N;++i) {\n\t\t\tcin >> arrX[i] >> arrY[i];\n\t\t}\n\t\tmemset(edges,0,sizeof(edges));\n\t\tfor(int i = 0;i < N;++i) {\n\t\t\tfor(int j = 0;j < N;++j) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(abs(arrX[i] - arrX[j]) + abs(arrY[i] - arrY[j]) <= K) {\n\t\t\t\t\tedges[i][j] = true;\n\t\t\t\t\tdegree[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint curMax = 0;\n\t\tbool ans = false;\n\t\tfor(int i = 0;i < N;++i) {\n\t\t\tint counter = 0;\n\t\t\tfor(int j = 0;j < N;++j) {\n\t\t\t\tif(edges[i][j]) counter++;\n\t\t\t}\n\t\t\tif(counter == N - 1) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << 2 * ans - 1 << endl;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class rc{\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t    int n=sc.nextInt();\n\t\t    int k=sc.nextInt();\n\t\t    int arr[][] = new int[n][2];\n\t\t    for(int i=0; i<n; i++){\n\t\t        arr[i][0]=sc.nextInt();\n\t\t        arr[i][1]=sc.nextInt();\n\t\t    }\n\t\t    int op=-1,i,j;\n\t\t    for(i=0; i<n; i++){\n\t\t        for(j=0; j<n; j++){\n\t\t            if(Math.abs(arr[i][0]-arr[j][0])+Math.abs(arr[i][1]-arr[j][1])>k){\n\t\t                op=-1;\n\t\t                break;\n\t\t            }\n\t\t        }\n\t\t        if(j==n){\n\t\t           op=1;\n\t\t           break;\n\t\t        }\n\t\t    }\n\t\t    System.out.println(op);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#define ll long long\n#define ull unsigned ll\n#define ld long double\n#define pb push_back\n#define ppb pop_back\n#define clr clear\n#define len size()\n#define beg begin()\n#define end end()\n#define ins insert\n#define f first\n#define s second\n#define mp make_pair\n#define forn(i, l, r) for(ll i = l; i <= r; ++i)\n#define fastio ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n\nusing namespace std;\n\nint t, n, k;\n\nconst int MAXN = 110;\n\nint d[MAXN][MAXN], x[MAXN], y[MAXN];\nvector < int > g[MAXN];\n\nint main()\n{\n\tfastio;\n\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tcin >> n >> k;\n\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tg[i].clr();\n\t\t}\n\n\t\tfor (int i = 1; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\td[i][j] = d[j][i] = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n\t\t}\n\n\t\tfor (int i = 1; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t{\n\t\t\t\tif (d[i][j] <= k)\n\t\t\t\t{\n\t\t\t\t\tg[i].pb(j);\n\t\t\t\t\tg[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif ((int)g[i].len == n - 1)\n\t\t\t{\n\t\t\t\tans = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n,k=map(int,input().split())\n    l=[];ans=[];l1=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        l.append([x,y])\n    for i in range(n):\n        l1.append([])\n        for j in range(n):\n            l1[i].append(abs(l[i][0]-l[j][0])+abs(l[i][1]-l[j][1]))\n    for i in range(n):\n        c=0\n        for j in l1[i]:\n            if(j<=k): c+=1\n        ans.append(c)\n    print(1 if n in ans else -1)"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class B {\n    static StringBuilder out = new StringBuilder();\n    static Scanner sc = new Scanner(System.in);\n    public static void main(String[] args){\n        int t = sc.nextInt();\n        while (t-->0){\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int[][] Points = new int[n][3];\n            for (int i=0;i<n;i++){\n                Points[i][1] = sc.nextInt();\n                Points[i][2] = sc.nextInt();\n            }\n            boolean flag = false;\n\n            for (int i=0;i<n;i++){\n                int xi = Points[i][1];\n                int yi = Points[i][2];\n                boolean tmp = true;\n                for (int j=0;j<n;j++){\n                    if ((Math.abs(xi-Points[j][1])+Math.abs(yi-Points[j][2]))>k){\n                        tmp = false;\n                        break;\n                    }\n                }\n                if (tmp){\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag){\n                out.append(1+\"\\n\");\n            }else {\n                out.append(-1+\"\\n\");\n            }\n\n        }\n        System.out.println(out);\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class cf111{\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int q = sc.nextInt();\n        while (q-- > 0) {\n            int n = sc.nextInt();\n            int k=sc.nextInt();\n            int ar[][]=new int[n][2];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                int a=sc.nextInt();\n                int b=sc.nextInt();\n                ar[i][0]=a;\n                ar[i][1]=b;\n            }\n            boolean f=true;\n            for(i=0;i<n;i++)\n            {\n                f=true;\n                for(int j=0;j<n;j++)\n                {\n                    if(mdis(ar[i][0],ar[i][1],ar[j][0],ar[j][1])>k)\n                    {\n                        f=false;\n                        break;\n                    }\n                }\n                if(f)\n                {\n                    System.out.println(1);\n                    break;\n                }\n            }\n            if(!f)\n            {\n                System.out.println(-1);\n            }\n        }\n    }\n    public static int mdis(int x1,int y1,int x2,int y2)\n    {\n        int s1=Math.abs(x1-x2);\n        int s2=Math.abs(y1-y2);\n        int s=s1+s2;\n        return s;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n,k=map(int,input().split())\n    l=[];ans=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        l.append([x,y])\n    l1=[]\n    # print(l)\n    for i in range(n):\n        l1.append([])\n        for j in range(i+1,n):\n            l1[i].append(abs(l[i][0]-l[j][0])+abs(l[i][1]-l[j][1]))\n        for j in range(0,i+1):\n            l1[i].append(abs(l[i][0]-l[j][0])+abs(l[i][1]-l[j][1]))\n    # print(l1)\n    for i in range(n):\n        c=0\n        for j in l1[i]:\n            if(j<=k):\n                c+=1\n        ans.append(c)\n    # print(ans)\n    if n in ans:\n        print(1)\n    else:\n        print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int T = ri();\n        for (int Ti = 0; Ti < T; Ti++) {\n            int[] nk = ril(2);\n            int n = nk[0];\n            int k = nk[1];\n            int[][] balls = new int[n][];\n            for (int i = 0; i < n; i++) balls[i] = ril(2);\n            List<List<Integer>> adj = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n            for (int i = 0; i < n; i++) {\n                for (int j = i+1; j < n; j++) {\n                    if (Math.abs(balls[i][0] - balls[j][0]) + Math.abs(balls[i][1] - balls[j][1]) <= k) {\n                        adj.get(i).add(j);\n                        adj.get(j).add(i);\n                    }\n                }\n            }\n            boolean done = false;\n            for (int i = 0; i < n; i++) {\n                if (adj.get(i).size() == n-1) {\n                    pw.println(\"1\");\n                    done = true;\n                    break;\n                }\n            }\n            if (!done) pw.println(\"-1\");\n        }\n    }\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(\"%.16f\", d);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Scanner;\nimport java.io.*;\nimport javax.lang.model.util.ElementScanner6; \nimport static java.lang.System.out;\n\n\npublic class B1450\n{\n\n   \n    \n    public static void main(String args[])\n    {  \n\n        FastReader in=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int tc=1;\n     \n        tc=in.nextInt();\n        while(tc-->0)\n        {\n            \n        \tint n=in.nextInt();\n\t\t\t\n\t\t\tlong k=in.nextLong();\n\t\t\t\n\t\t\tlong arr[][]=new long[n][2];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tarr[i][0]=in.nextLong();\n\t\t\t\tarr[i][1]=in.nextLong();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint f=1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tf=1;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlong val=Math.abs(arr[i][0]-arr[j][0])+Math.abs(arr[i][1]-arr[j][1]);\n\t\t\t\t\tif(val>k)\n\t\t\t\t\t{\n\t\t\t\t\t\tf=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f==1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(f==0)pr.println(-1);\n\t\t\telse pr.println(1);\n\t\t\t\n\t\t\t\n        \n\n\n\n        }\n        pr.flush();\n    }\n\n\n    \n\n    static void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n    \n    \n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n    }\n\n    \n    static class FastReader\n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}\n"
        },
        {
            "language": 2,
            "solution": "// Example program\n#include <bits/stdc++.h>\nusing namespace std;\npair<int,int> p[200],last;\nint main(){\nint t; cin >>t ;\nwhile(t--){\n    int n,k,tmp=0,ok=1;\n    cin >> n >> k; \n    for(int i=0;i<n;i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    sort(p,p+n);  \n    last={p[0].first,p[0].second};\n    for(int i=0;i<n;i++){\n        ok=1;\n        for(int j=0;j<n;j++){\n        if((abs(p[i].first-p[j].first)+abs(p[i].second-p[j].second))>k)\n            ok=0;\n        }\n        if(ok) break;\n    }\n    cout << (ok?1:-1)<<'\\n';\n}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110;\n\n#define FOR(i,a,b) for(int i = a;i <= b;i++)\n#define _FOR(i,a,b) for(int i = a;i >= b;i--)\n\ntemplate<typename T> void read(T &x)\n{\n    x = 0;int f = 1;\n    char c = getchar();\n    for(;!isdigit(c);c = getchar()) if(c == '-') f = -1;\n    for(;isdigit(c);c = getchar()) x = x * 10 + c - '0';\n    x *= f;\n}\n\nint T,n,K,e[N][N],X[N],Y[N];\n\nint main()\n{\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n\tread(T);\n\twhile(T--)\n\t{\n\t\tbool flag;\n\t\tmemset(e,0,sizeof(e));\n\t\tread(n),read(K);\n\t\tFOR(i,1,n)\n\t\t\tread(X[i]),read(Y[i]);\n\t\tFOR(i,1,n)\n\t\t\tFOR(j,1,n)\n\t\t\t\tif(abs(X[i] - X[j]) + abs(Y[i] - Y[j]) <= K) e[i][j] = 1;\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tflag = 1;\n\t\t\tFOR(j,1,n)\n\t\t\t\tif(!e[i][j]) {flag = 0; break;}\n\t\t\tif(flag) break;  \n\t\t}\n\t\tif(flag) puts(\"1\");\n\t\telse puts(\"-1\");\n\t}\n    return 0;\n}\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define ll long long int\n#define pb push_back\n#define pob pop_back\n#define ub upper_bound\n#define lb lower_bound\n#define mp make_pair\n#define f0(i,n) for(i=0;i<n;i++)\n#define rf0(i,n) for(i=n-1;i>=0;i--)\n#define f2(i,n) for(i=1;i<n;i++)\n#define f1(i,n) for(i=1;i<=n;i++)\n#define fab(i,a,b) for(i=a;i<=b;i++)\n#define shr  ll t;cin>>t; while(t--)\n#define fi first\n#define sc second\n#define pll pair<ll,ll>\n#define vll vector<ll>\n#define vpll vector<pll>\n#define all(v) v.begin(),v.end()\n#define mod 1000000007\n#define dev(a) for(auto it:a)cout<<it<<\" \"\n#define prec(nm,prc) cout<<fixed << setprecision(nm)<<prc\n#define print(a) cout<<a<<endl;\n#define nl '\\n'\nusing namespace std;\nbool comp(pll &a,pll &b)\n{\n    return (a.sc<b.sc);\n}\nll power(ll n,ll p)\n{\n\tif(p==0)\n\treturn 1;\n\telse\n\t{\n\t\tll ans=power(n,p/2)%mod;\n\t\tans=(ans*ans)%mod;\n\t\tif(p%2==0)\n\t\treturn ans;\n\t\telse\n\t\treturn ans=(ans*n)%mod;\n\t}\n}\nbool isPrime(ll n) \n{ \n    if (n <= 1) \n        return false; \n    if (n <= 3) \n        return true; \n  \n    if (n % 2 == 0 || n % 3 == 0) \n        return false; \n  \n    for (ll i = 5; i * i <= n; i = i + 6) \n        if (n % i == 0 || n % (i + 2) == 0) \n            return false; \n  \n    return true; \n} \n\n\n    /********************HAR HAR MAHADEV***********JAI BAJRANG BALI************************/\n  int main()\n {\n  \tFAST;\n  \t/* ifstream cin;\n    cin.open(\"input.txt\");\n    ofstream cout;\n    cout.open(\"output.txt\");\n                      */\n  \tshr\n  \t  {  \n  \t  \tll i,j,n,a,b,c,c1,d,m,sum=0,temp,k,k2,k1,ans=0,cnt=0,r=0,e=0,f;\n  \t  \tstring str,stri,om,s;\n  \t     map<ll,ll>mp,mp1;\n  \t     set<ll>st; vector<vll> v;\n  \t     cin>>n>>k; ll x[n][2];\n  \t     f0(i,n)\n  \t     {\n  \t         cin>>x[i][0]>>x[i][1];\n  \t     }\n  \t    f0(i,n)\n  \t    {\n          vll vk;\n           f0(j,n)\n          {\n              \n              if(i!=j)\n              {\n                  vk.pb(abs(x[i][0]-x[j][0])+abs(x[i][1]-x[j][1]));\n              }\n             \n          }\n           v.pb(vk);\n          r++;\n      }\n  \t   f0(i,v.size())\n  \t   {\n      ll p=*max_element(all(v[i]));\n      if(p<=k){e=1;break;}\n      }\n      if(e==1)cout<<1;\n      else cout<<-1;\n      cout<<endl;\n  \t  }\n  \t  \n   \treturn 0;\n  }                     \n "
        },
        {
            "language": 2,
            "solution": "#define F first\n#define S second\n#define pb push_back\n#include <bits/stdc++.h>\nusing namespace std;\nint y[101] ;\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tint t ;\n\tcin >> t ;\n\twhile ( t-- ) {\n\t\tvector <pair<int,int>> x ;\n\t\tint n , k , a , b ;\n\t\tcin >> n >> k ;\n\t\tfor ( int i = 0 ; i < n ; i++ ) {\n\t\t\ty[i] = 0 ;\n\t\t\tcin >> a >> b ;\n\t\t\tx.pb({a,b});\n\t\t}\n\t\tbool yes = false ;\n\t\tfor ( int i = 0 ; i < n ; i++ ) {\n\t\t\tfor ( int j = 0 ; j < n ; j++ ) {\n\t\t\t\tif ( i == j ) continue ;\n\t\t\t\tif ( abs(x[i].F-x[j].F)+abs(x[i].S-x[j].S) <= k ) {\n\t\t\t\t\ty[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( y[i] == n-1 ) yes = true ;\n\t\t}\n\t\tcout << (yes?1:-1) << endl ;\n\t}\n\treturn 0;\n}"
        },
        {
            "language": 1,
            "solution": "for _ in range(input()):\n    n,k=[int(i) for i in raw_input().split()]\n    a=[[int(i) for i in raw_input().split()]for j in range(n)]\n    for x,y in a:\n        for i in range(n):\n            if abs(a[i][0]-x)+abs(a[i][1]-y)>k:\n                break\n        else:\n            print 1\n            break\n    else:\n        print -1\n"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor _ in range(t):\n\tn, k = map(int, input().split())\n\tx, y= [0]*n, [0]*n\n\tfor i in range(n):\n\t\tx[i], y[i] = map(int, input().split())\n\tans = -1\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif(abs(x[i] - x[j]) + abs(y[i] - y[j]) > k):\n\t\t\t\tbreak\n\t\t\tif(j == n-1):\n\t\t\t\tans = 1\n\tprint(ans)"
        },
        {
            "language": 3,
            "solution": "n=int(input())\nwhile n:\n    m=list(map(int,input().split()))\n    list1=[]\n    i=0\n    while i!=m[0]:\n        list2=list(map(int,input().split()))\n        list1.append(list2)\n        i=i+1\n    for i in range(m[0]):\n        flag=0\n        for j in range(m[0]):\n            if abs(list1[i][0]-list1[j][0])+abs(list1[i][1]-list1[j][1])<=m[1]:\n                flag=flag+1\n        if flag==m[0]:\n            break\n    if flag==m[0]:\n        print(1)\n    else:\n        print(-1)\n    n=n-1\n"
        },
        {
            "language": 1,
            "solution": "from __future__ import division\nfrom sys import stdin\n\nceil1 = lambda a, b: (a + b - 1) // b\nrints = lambda: [int(x) for x in stdin.readline().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\nfor _ in range(int(input())):\n    n, k = rints()\n    a, ans = rints_2d(n), -1\n    for i in range(n):\n        tem = 0\n        for j in range(n):\n            tem = max(tem, abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]))\n        if tem <= k:\n            ans = 1\n            break\n\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "t= int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    XY = []\n    for i in range(n):\n        x,y = map(int, input().split())\n        XY.append((x, y))\n    flag = False\n    for i in range(n):\n        xi, yi = XY[i]\n        for j in range(n):\n            xj, yj = XY[j]\n            if abs(xi-xj)+abs(yi-yj)>k:\n                break\n        else:\n            flag = True\n            break\n    if flag:\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ln \"\\n\"\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\n#define IO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n\n\nvector<pair<int, int>> a;\nvoid go() {\n  int n;cin >>n;\n  int k;cin >> k;\n\n  a.assign(n, {});\n\n  for(int i = 0;i < n;i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  for(int  i  = 0;i < n;i++) {\n    bool ok = true;\n    for(int j =0;j < n;j++) {\n      if(k >= abs(a[i].first - a[j].first) + abs(a[i].second - a[j].second)) {\n      }else {\n        ok = false;\n      }\n    }\n    if(ok) {\n      cout << 1 << ln;\n      return;\n    }\n  }\n  cout << -1 << ln;\n}\n\nint main() {\n  IO;\n  int t;cin >> t;\n  while(t--) go();\n}\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "for t in range(int(input())):\n    n,k=map(int,input().split())\n    a,f=[],0\n    for i in range(n):\n        a.append(tuple(map(int,input().split())))\n    for i in range(n):\n        f1=1\n        for j in range(n):\n            if abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])>k:\n                f1=0\n                break\n        if f1:\n            f=1\n            break\n    if f:\n        print(1)\n    else:\n        print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\nusing namespace std;\nvoid solve(){\n    int n, k;\n    cin >> n >> k;\n    int x_cord[n], y_cord[n];\n    for(int i = 0; i < n; i++)\n    {\n        cin >> x_cord[i] >> y_cord[i];\n    }\n    int ans = -1;\n    for(int i = 0; i < n; i++)\n    {\n        bool flag = true;\n        for(int j = 0; j < n; j++){\n            if(j != i && abs(x_cord[i] - x_cord[j]) + abs(y_cord[i] - y_cord[j]) > k)\n            {\n                flag = false;\n                break;\n            }\n        }\n        if(flag)\n        {\n            ans = 1;\n            break;\n        }\n    }\n    cout << ans << endl;\n}\nint main() {\n    int t;\n    cin >> t;\n    while(t--) solve();\n    return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class BallsOfSteel {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int T = Integer.parseInt(br.readLine());\n\n            for (int i = 1; i <= T; i++) {\n                int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n                int n = arr[0];\n                int k = arr[1];\n                int x[] = new int[n];\n                int y[] = new int[n];\n                for (int j = 0; j < n; j++) {\n                    int[] coord = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n                    x[j] = coord[0];\n                    y[j] = coord[1];\n                }\n                solve(x, y, k);\n            }\n\n        } catch (Exception e) {\n            return;\n        }\n    }\n\n    private static void solve(int[] x, int[] y, int k) {\n        int n= x.length;\n        int count;int point = 0;\n        for(int i=0;i<n;i++)\n        {\n            count = 0;\n            for(int j=0;j<n;j++){\n                int d = Math.abs(x[j] - x[i]) + Math.abs(y[j] - y[i]);\n                if(d <= k) {\n                    count++;\n                }\n            }\n            if(count == n)  {\n                point++;}\n        }\n        if(point > 0) System.out.println(\"1\");\n        else System.out.println(\"-1\");\n    }\n}"
        },
        {
            "language": 3,
            "solution": "t=int(input())\n\nfor _ in range(t):\n    n,k=map(int,input().split())\n    r=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        r.append([x,y])\n    flag=False\n    for i in range(n):\n        x0=r[i][0]\n        y0=r[i][1]\n        \n        for j in range(n):\n            x=r[j][0]\n            y=r[j][1]\n            if abs(x0-x)+abs(y0-y)>k:\n                break\n        else:\n            flag=True\n    if flag:\n        print(1)\n    else:\n        print(-1)"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import *\nimport math\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t-=1\n    n,k = [int(x) for x in input().split()]\n    x = [0]*n\n    y = [0]*n\n    for i in range(n):\n        x[i],y[i] = [int(x) for x in input().split()]\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if abs(x[i]-x[j])+abs(y[i]-y[j])<=k:\n                count+=1\n        if count==n:\n            break\n    if count==n:\n        print(1)\n    else:\n        print(-1)\n            "
        },
        {
            "language": 3,
            "solution": "rn=lambda:int(input())\nrl=lambda:list(map(int,input().split()))\nrns=lambda:map(int,input().split())\nrs=lambda:input()\nyn=lambda x:print('Yes') if x else print('No')\nYN=lambda x:print('YES') if x else print('NO')\n\nfor _ in range(rn()):\n    n,k=rns()\n    points=[]\n    ans=-1\n    for i in range(n):\n        points.append(rl())\n    for i in range(n):\n        b=[]\n        for j in range(n):\n            if i!=j:\n                b.append(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))\n        if all([i<=k for i in b]):\n            ans=1\n            break\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n\npublic class codeforcesC {\n\n    public static void main(String[] args) {\n        FastScanner fs=new FastScanner();\n        int T=fs.nextInt();\n        int ans=0;\n        for (int tt=0; tt<T; tt++) {\n          int n=fs.nextInt(),k=fs.nextInt();\n          ArrayList<Integer> [] c  =new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                c[i] = new ArrayList<Integer>();\n            }\n\n            for(int i=0;i<n;i++){\n              int x=fs.nextInt();\n              int y=fs.nextInt();\n              c[i].add(x);\n              c[i].add(y);\n\n            }\n//            for(int i=0;i<n;i++){\n//                System.out.println(c[i]);\n//            }\n\n            int count=0,found=0;\n            for(int i=0;i<n;i++){\n               count=0;\n                for(int j=0;j<n;j++) {\n//                    System.out.println(c[i].get(0)+\" \"+c[i].get(1));\n                    if (Math.abs(c[i].get(0) - c[j].get(0)) + Math.abs(c[i].get(1) - c[j].get(1)) <= k)\n                        count++;\n                }\n                if(count==n){\n                    found=1;\n                    break;\n                }\n\n            }\n\n\n            if(found==1){\n                System.out.println(1);\n            }\n            else\n                System.out.println(-1);\n\n\n\n\n\n        }\n    }\n\n    static void ruffle_sort(int[] a) {\n        //shandom_ruffle\n        Random r=new Random();\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=r.nextInt(i);\n            int temp=a[i];\n            a[i]=a[oi];\n            a[oi]=temp;\n        }\n\n        //sort\n        Arrays.sort(a);\n    }\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n\n}\n"
        },
        {
            "language": 1,
            "solution": "for _ in range(input()):\n    n,k=map(int,raw_input().split())\n    points=[]\n    for i in range(n):\n        x=map(int,raw_input().split())\n        points.append(x)\n    ans=-1\n    for i in range(n):\n        if ans!=-1:\n            break\n        for j in range(n):\n            dist=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n            if dist>k:\n                ans=-1\n                break\n            else:\n                ans=1\n    print ans\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n\n#define ll long long\n#define si(num) scanf(\"%d\" ,&num)\n#define sll(num) scanf(\"%lld\" ,&num)\n#define pll(num) printf(\"%lld\\n\" ,num)\n#define pllS(num) printf(\"%lld \" ,num)\n#define p0(num1) cout <<num1 <<\" \";\n#define p1(num1) cout <<num1 <<endl;\n#define p2(num1 ,num2) cout <<num1 <<\" \" <<num2 <<endl;\n#define p3(num1 ,num2 ,num3) cout <<num1 <<\" \" <<num2 <<\" \" <<num3 <<endl;\n#define nL  cout <<endl;\n#define f(i ,lV ,uV) for(i =lV ;i <=uV ;++i)\n#define fd(i ,lV ,uV) for(i =lV ;i >=uV ;--i)\n#define sz1 100002\n\nusing namespace std;\nll n ,k;\nll i ,j ,x ,y;\nll mm(ll x){ if(x >=0) return x; return -1*x;}\nll tP(){\n    cin >>n >>k;\n    ll x[n +1] ,y[n +1];\n    f(i ,1 ,n){\n        cin >>x[i] >>y[i];\n    }\n    f(i ,1 ,n){\n        ll t =0;\n        f(j ,1 ,n){\n            if(mm(x[i] -x[j]) +mm(y[i] -y[j]) >k) t =-1;\n        }if(t ==0) return 1;\n    }return -1;\n}\nint main(){\n    int test; cin >>test;\n    while(test--){\n        cout <<tP() <<endl;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define lld         long long int\n#define llf         long double\n#define pb          push_back\n#define mp          make_pair\n#define in          insert\n#define loopN(n)    for(lld i=0;i<n;i++)\n#define loopN2(n)   for(lld j=0;j<n;j++)\n#define loop(p,n)   for(lld i=p;i<=n;i++)\n#define rloop(p,n)  for(lld i=n;i>=p;i--)\n#define loop2(p,n)  for(lld j=p;j<=n;j++)\n#define all(v)      v.begin(),v.end()\n#define f1          first\n#define f2          second\n#define INF         2e18\n#define FILE        freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout)\n#define pi          2*acos(0.0)\n#define ISO         ios::sync_with_stdio(false);cin.tie(0)\n#define mem(a,b)    memset(a,b,sizeof(a))\n#define case(z)     cout<<\"Case \"<<z<<\": \"\n#define setprec(a)  fixed<< setprecision(a)\n//_______________________________________________\n#define on(m,p)     (m|(1<<p))\n#define ison(m,p)   (m&(1<<p))\n#define flip(m,p)   (m^(1<<p))\n#define allon(p)    ((1<<p)-1)\n//_______________________________________________\nusing namespace std;\nconst lld mod=1e9+7;\nlld fx[]= {1,0,-1, 0 ,1, 1,-1,-1};\nlld fy[]= {0,1,0 ,-1 ,1,-1,1 ,-1};\n\nlld n;\nlld x[105],y[105];\nlld k;\n\nvoid slv()\n{\n    cin>>n>>k;\n    loopN(n)cin>>x[i]>>y[i];\n    lld ans=-1;\n    loopN(n)\n    {\n        bool f=1;\n\n        loopN2(n)\n        {\n            if(abs(x[i]-x[j])+abs(y[i]-y[j])>k)\n            {\n                f=0;\n                break;\n            }\n\n        }\n        if(f)\n        {\n            ans=1;break;\n        }\n\n    }\n    cout<<ans<<endl;\n\n\n}\n\nint main()\n{\n    ISO;\n    lld idx=1;\n    lld t;cin>>t;while(t--)\n    {\n        //case(idx++);\n        slv();\n    }\n    return 0;\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\n#define f(i,k,n) for(ll i=k;i<n;i++)\n#define all(s) s.begin(),s.end()\n#define vec vector<ll>\n#define pb push_back\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\nvoid test(){\n    ll n,k,ans=1,till=0;\n    cin>>n>>k;\n    vector<pair<ll,ll> > v;\n\n    bool ok=true;\n    f(i,0,n){\n        ll a,b;\n        cin>>a>>b;\n        v.pb({a,b});\n    }\n    sort(all(v));\n    f(i,0,n){\n        f(j,0,n){\n            if(i!=j) till=max(till,abs(v[j].first-v[i].first)+abs(v[j].second-v[i].second));\n        }\n        if(till<=k) ok=false;\n        till=0;\n    }\n    ok?cout<<-1<<endl:cout<<1<<endl;\n}\nint main(){\n\tIOS;\n\tll t=1;cin>>t;\n\twhile(t--){\n        test();\n\t}\n\n\treturn 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def find():\n    N, K = map(int, input().split())\n    minX, maxX, minY, maxY = 10**5, 0, 10**5, 0\n    num = []\n    for __ in range(N):\n      X, Y = map(int, input().split())\n      num.append((X, Y))\n    for i in range(N):\n      for j in range(N):\n        if abs(num[i][0] - num[j][0]) + abs(num[i][1] - num[j][1]) > K:\n          break\n      else:\n        return 1\n    else:\n      return -1\nfor _ in range(int(input())):\n  print(find())\n  "
        },
        {
            "language": 4,
            "solution": "//package start;\n\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.util.function.BiFunction;\n\npublic class Main extends IO {\n\n    public static void main(String[] args) throws Exception {\n        int quantity = readInt();\n        mainCycle:\n        for (int i = 0; i < quantity; i++) {\n            int[] description = readArrayInt(\" \");\n            int[][] position = new int[description[0]][];\n            for (int j = 0; j < description[0]; j++) {\n                position[j] = readArrayInt(\" \");\n            }\n            for (int start = 0; start < description[0]; start++){\n                int[] startPosition = position[start];\n                boolean flag = false;\n                for (int j = 0; j < description[0]; j++) {\n                    if ((Math.abs(startPosition[0] - position[j][0]) + Math.abs(startPosition[1] - position[j][1])) > description[1]) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if (!flag){\n                    writeString(\"1\", \"\\n\");\n                    continue mainCycle;\n                }\n            }\n            writeString(\"-1\", \"\\n\");\n        }\n        print();\n    }\n\n}\n\nclass math {\n\n    protected static long remains = 0x3B9ACA07; // 1000000007\n\n    protected static int gcd(int a, int b) { // NOD\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    protected static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    protected static float gcd(float a, float b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    protected static double gcd(double a, double b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    protected static double lcm(double a, double b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    protected static float lcm(float a, float b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    protected static int lcm(int a, int b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    protected static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n\n    }\n\n    protected static long mult(long a, long b) {\n        return ((a % remains) * (b % remains)) % remains;\n    }\n\n    protected static long binpow(long base, long power) {\n        long res = 1;\n        while (power != 0)\n            if ((power & 1) == 1) {\n                res = mult(res, base);\n                power--;\n            } else {\n                base = mult(base, base);\n                power >>= 1;\n            }\n        return res;\n    }\n\n    protected static double log(double value, int base) {\n        return Math.log(value) / Math.log(base);\n    }\n\n    protected static long factorial(int number) {\n        if (number < 0) {\n            return 0;\n        }\n        return solveFactorial(number);\n    }\n\n    private static long solveFactorial(int number) {\n        if (number > 0) {\n            return solveFactorial(number - 1) * number;\n        }\n        return 1;\n    }\n\n}\n\nclass Int implements Comparable<Integer> {\n\n    protected int value;\n\n    Int(int value) {\n        this.value = value;\n    }\n\n    public Int add(int value) {\n        this.value += value;\n        return this;\n    }\n\n    @Override\n    public int compareTo(Integer o) {\n        return (this.value < o) ? -1 : ((this.value == o) ? 0 : 1);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value == (Integer) obj;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n    }\n}\n\n\nclass Fraction<T extends Number> extends Pair {\n\n    private Fraction(T dividend, T divider) {\n        super(dividend, divider);\n        reduce();\n    }\n\n    protected static <T extends Number> Fraction<T> createFraction(T dividend, T divider) {\n        return new Fraction<>(dividend, divider);\n    }\n\n    protected void reduce() {\n        if (getFirstElement() instanceof Integer) {\n            Integer Dividend = (Integer) getFirstElement();\n            Integer Divider = (Integer) getSecondElement();\n            int gcd = math.gcd(Dividend, Divider);\n            setFirst(Dividend / gcd);\n            setSecond(Divider / gcd);\n        } else if (getFirstElement() instanceof Long) {\n            Long Dividend = (Long) getFirstElement();\n            Long Divider = (Long) getSecondElement();\n            long gcd = math.gcd(Dividend, Divider);\n            setFirst(Dividend / gcd);\n            setSecond(Divider / gcd);\n        } else if (getFirstElement() instanceof Float) {\n            Float Dividend = (Float) getFirstElement();\n            Float Divider = (Float) getSecondElement();\n            float gcd = math.gcd(Dividend, Divider);\n            setFirst(Dividend / gcd);\n            setSecond(Divider / gcd);\n        } else if (getFirstElement() instanceof Double) {\n            Double Dividend = (Double) getFirstElement();\n            Double Divider = (Double) getSecondElement();\n            double gcd = math.gcd(Dividend, Divider);\n            setFirst(Dividend / gcd);\n            setSecond(Divider / gcd);\n        }\n    }\n\n    protected void addWithoutReturn(Fraction number) throws UnsupportedOperationException {\n        add(number, 0);\n    }\n\n    private Fraction add(Fraction number, int function) throws UnsupportedOperationException {\n        if (getFirstElement() instanceof Integer && number.getFirstElement() instanceof Integer) {\n            Integer Dividend = (Integer) getFirstElement();\n            Integer Divider = (Integer) getSecondElement();\n            Integer Dividend1 = (Integer) number.getFirstElement();\n            Integer Divider1 = (Integer) number.getSecondElement();\n            Integer lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirst((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecond(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createFraction((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n\n        } else if (getFirstElement() instanceof Long && number.getFirstElement() instanceof Long) {\n            Long Dividend = (Long) getFirstElement();\n            Long Divider = (Long) getSecondElement();\n            Long Dividend1 = (Long) number.getFirstElement();\n            Long Divider1 = (Long) number.getSecondElement();\n            Long lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirst((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecond(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createFraction((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else if (getFirstElement() instanceof Float && number.getFirstElement() instanceof Float) {\n            Float Dividend = (Float) getFirstElement();\n            Float Divider = (Float) getSecondElement();\n            Float Dividend1 = (Float) number.getFirstElement();\n            Float Divider1 = (Float) number.getSecondElement();\n            Float lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirst((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecond(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createFraction((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else if (getFirstElement() instanceof Double && number.getFirstElement() instanceof Double) {\n            Double Dividend = (Double) getFirstElement();\n            Double Divider = (Double) getSecondElement();\n            Double Dividend1 = (Double) number.getFirstElement();\n            Double Divider1 = (Double) number.getSecondElement();\n            Double lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirst((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecond(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createFraction((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    protected Fraction addWithReturn(Fraction number) {\n        return add(number, 1);\n    }\n\n    protected void multiplyWithoutReturn(Fraction number) throws UnsupportedOperationException {\n        multiply(number, 0);\n    }\n\n    protected Fraction multiplyWithReturn(Fraction number) throws UnsupportedOperationException {\n        return multiply(number, 1);\n    }\n\n    private Fraction multiply(Fraction number, int function) throws UnsupportedOperationException {\n        if (getFirstElement() instanceof Integer && number.getFirstElement() instanceof Integer) {\n            Integer first = (Integer) getFirstElement() * (Integer) number.getFirstElement();\n            Integer second = (Integer) getSecondElement() * (Integer) number.getSecondElement();\n            if (function == 0) {\n                setFirst(first);\n                setSecond(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createFraction(first, second);\n            answer.reduce();\n            return answer;\n        } else if (getFirstElement() instanceof Long && number.getFirstElement() instanceof Long) {\n            Long first = (Long) getFirstElement() * (Long) number.getFirstElement();\n            Long second = (Long) getSecondElement() * (Long) number.getSecondElement();\n            if (function == 0) {\n                setFirst(first);\n                setSecond(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createFraction(first, second);\n            answer.reduce();\n            return answer;\n\n        } else if (getFirstElement() instanceof Float && number.getFirstElement() instanceof Float) {\n            Float first = (Float) getFirstElement() * (Float) number.getFirstElement();\n            Float second = (Float) getSecondElement() * (Float) number.getSecondElement();\n            if (function == 0) {\n                setFirst(first);\n                setSecond(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createFraction(first, second);\n            answer.reduce();\n            return answer;\n        } else if (getFirstElement() instanceof Double && number.getFirstElement() instanceof Double) {\n            Double first = (Double) getFirstElement() * (Double) number.getFirstElement();\n            Double second = (Double) getSecondElement() * (Double) number.getSecondElement();\n            if (function == 0) {\n                setFirst(first);\n                setSecond(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createFraction(first, second);\n            answer.reduce();\n            return answer;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n\nclass Pair<T, T1> implements Cloneable {\n\n    private T first;\n    private T1 second;\n\n    Pair(T obj, T1 obj1) {\n        first = obj;\n        second = obj1;\n    }\n\n    protected static <T, T1> Pair<T, T1> createPair(T element, T1 element1) {\n        return new Pair<>(element, element1);\n    }\n\n    protected T getFirstElement() {\n        return first;\n    }\n\n    protected T1 getSecondElement() {\n        return second;\n    }\n\n    protected void setFirst(T element) {\n        first = element;\n    }\n\n    protected void setSecond(T1 element) {\n        second = element;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Pair)) {\n            return false;\n        }\n        Pair pair = (Pair) obj;\n        return first.equals(pair.first) && second.equals(pair.second);\n    }\n\n    @Override\n    public int hashCode() {\n        int hashCode = 1;\n        hashCode = 31 * hashCode + (first == null ? 0 : first.hashCode());\n        return 31 * hashCode + (second == null ? 0 : second.hashCode());\n    }\n\n    @Override\n    public Object clone() {\n        return Pair.createPair(first, second);\n    }\n}\n\nclass Graph {\n\n    private int[][] base;\n    private boolean[] used;\n    private int quantity;\n    private Integer[] ancestor;\n\n    public int[][] getBase() {\n        return base;\n    }\n\n    public boolean[] getUsed() {\n        return used;\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n\n    public Integer[] getAncestor() {\n        return ancestor;\n    }\n\n    public void setBase(int[][] base) {\n        this.base = base;\n    }\n\n    protected void start(int length) {\n        used = new boolean[length];\n        ancestor = new Integer[length];\n        Arrays.fill(ancestor, -1);\n        quantity = 0;\n    }\n\n\n    protected void edgesMatrixToDefault(int length, int inputQuantity, boolean readConsole, int[][] value) throws Exception {\n        base = new int[length][];\n        List<ArrayList<Integer>> inputBase = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            inputBase.add(new ArrayList<>());\n        }\n        for (int i = 0; i < inputQuantity; i++) {\n            int[] input = readConsole ? IO.readArrayInt(\" \") : value[i];\n            inputBase.get(input[0] - 1).add(input[1] - 1);\n            inputBase.get(input[0] - 1).add(input[2]); // price\n            inputBase.get(input[1] - 1).add(input[0] - 1);\n            inputBase.get(input[1] - 1).add(input[2]); // price\n        }\n        for (int i = 0; i < length; i++) {\n            base[i] = inputBase.get(i).stream().mapToInt(Integer::intValue).toArray();\n        }\n        start(length);\n    }\n\n    protected void adjacencyMatrixToDefault(int length, int not, boolean readConsole, int[][] value) throws Exception {\n        this.base = new int[length][];\n        List<Integer> buffer = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            int[] InputArray = readConsole ? IO.readArrayInt(\" \") : value[i];\n            for (int index = 0; index < length; index++) {\n                if (i != index && InputArray[index] != not) {\n                    buffer.add(index);\n                    // buffer.add(InputArray[index]); // price\n                }\n            }\n            this.base[i] = buffer.stream().mapToInt(Integer::intValue).toArray();\n            buffer.clear();\n        }\n        start(length);\n    }\n\n    protected int dfs(int position) throws Exception {\n        used[position] = true;\n        int next;\n        int count = 0;\n        for (int index = 0; index < base[position].length; index += 2) {\n            next = base[position][index];\n            if (!used[next]) {\n                ancestor[next] = position;\n                count += dfs(next);\n            }\n             /*else {\n                if (next != ancestor[position]) { // if cycle\n                    throw new Exception();\n                }\n            }*/\n        }\n        if (base[position].length == 2 && base[position][0] == ancestor[position]) {\n            return 1;\n        }\n        return count;\n    }\n\n    protected int dijkstra(int start, int stop, int size) {\n        start--;\n        stop--;\n        int[] dist = new int[size];\n        for (int i = 0; i < size; i++) {\n            if (i != start) {\n                dist[i] = Integer.MAX_VALUE;\n            }\n            ancestor[i] = start;\n        }\n\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt((int[] ints) -> ints[1]));\n        queue.add(new int[]{start, 0});\n        int position;\n        int[] getQueue;\n        while (queue.size() != 0) {\n            getQueue = queue.poll();\n            position = getQueue[0];\n            if (getQueue[1] > dist[position]) {\n                continue;\n            }\n            for (int index = 0; index < this.base[position].length; index += 2) {\n                if (dist[position] + this.base[position][index + 1] < dist[this.base[position][index]] && !this.used[this.base[position][index]]) {\n                    dist[this.base[position][index]] = dist[position] + this.base[position][index + 1];\n                    this.ancestor[this.base[position][index]] = position;\n                    queue.add(new int[]{this.base[position][index], dist[this.base[position][index]]});\n                }\n            }\n            used[position] = true;\n        }\n        return dist[stop] == Integer.MAX_VALUE ? -1 : dist[stop];\n    }\n\n    protected static boolean solveFloydWarshall(int[][] base, int length, int not) {\n        for (int k = 0; k < length; k++) {\n            for (int i = 0; i < length; i++) {\n                for (int j = 0; j < length; j++) {\n                    if (base[i][k] == not || base[k][j] == not) {\n                        continue;\n                    }\n                    int total = base[i][k] + base[k][j];\n                    if (base[i][j] != not) {\n                        base[i][j] = Math.min(base[i][j], total);\n                    } else {\n                        base[i][j] = total;\n                    }\n                }\n            }\n        }\n        for (int index = 0; index < length; index++) {\n            if (base[index][index] != 0) { // if cycle\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected static Pair<Long, int[][]> solveKruskal(int[][] edgesMatrix, final int countVertex, final int indexSort) {\n        int[][] answer = new int[countVertex - 1][2];\n        long sum = 0;\n        Arrays.sort(edgesMatrix, Comparator.comparingInt(value -> value[indexSort]));\n        SystemOfDisjointSets dsu = new SystemOfDisjointSets(countVertex);\n        for (int i = 0; i < countVertex; i++) {\n            dsu.makeSet(i);\n        }\n        int index = 0;\n        for (int[] value : edgesMatrix) {\n            if (dsu.mergeSets(value[0], value[1])) {\n                sum += value[indexSort];\n                answer[index] = new int[]{value[0], value[1]};\n                index++;\n            }\n        }\n        if (index < countVertex - 1) {\n            return Pair.createPair(null, null);\n        }\n        return Pair.createPair(sum, answer);\n    }\n\n    static class SegmentTree {\n\n        private int[] segmentArray;\n        private BiFunction<Integer, Integer, Integer> function;\n\n        protected void setSegmentArray(int[] segmentArray) {\n            this.segmentArray = segmentArray;\n        }\n\n        protected int[] getSegmentArray() {\n            return segmentArray.clone();\n        }\n\n        protected void setFunction(BiFunction<Integer, Integer, Integer> function) {\n            this.function = function;\n        }\n\n        protected BiFunction<Integer, Integer, Integer> getFunction() {\n            return function;\n        }\n\n        SegmentTree() {\n\n        }\n\n        SegmentTree(int[] startBase, int neutral, BiFunction<Integer, Integer, Integer> function) {\n            this.function = function;\n            int length = startBase.length;\n            int[] base;\n            if ((length & (length - 1)) != 0) {\n                int pow = 0;\n                while (length > 0) {\n                    length >>= 1;\n                    pow++;\n                }\n                pow--;\n                base = new int[2 << pow];\n                System.arraycopy(startBase, 0, base, 0, startBase.length);\n                Arrays.fill(base, startBase.length, base.length, neutral);\n\n            } else {\n                base = startBase;\n            }\n            segmentArray = new int[base.length << 1]; // maybe * 4\n            Arrays.fill(segmentArray, neutral);\n            inDepth(base, 1, 0, base.length - 1);\n        }\n\n        private void inDepth(int[] base, int position, int low, int high) {\n            if (low == high) {\n                segmentArray[position] = base[low];\n            } else {\n                int mid = (low + high) >> 1;\n                inDepth(base, position << 1, low, mid);\n                inDepth(base, (position << 1) + 1, mid + 1, high);\n                segmentArray[position] = function.apply(segmentArray[position << 1], segmentArray[(position << 1) + 1]);\n            }\n        }\n\n        protected int getValue(int left, int right, int neutral) {\n            return findValue(1, 0, ((segmentArray.length) >> 1) - 1, left, right, neutral);\n        }\n\n        private int findValue(int position, int low, int high, int left, int right, int neutral) {\n            if (left > right) {\n                return neutral;\n            }\n            if (left == low && right == high) {\n                return segmentArray[position];\n            }\n            int mid = (low + high) >> 1;\n            return function.apply(findValue(position << 1, low, mid, left, Math.min(right, mid), neutral),\n                    findValue((position << 1) + 1, mid + 1, high, Math.max(left, mid + 1), right, neutral));\n        }\n\n        protected void replaceValue(int index, int value) {\n            update(1, 0, (segmentArray.length >> 1) - 1, index, value);\n        }\n\n        private void update(int position, int low, int high, int index, int value) {\n            if (low == high) {\n                segmentArray[position] = value;\n            } else {\n                int mid = (low + high) >> 1;\n                if (index <= mid) {\n                    update(position << 1, low, mid, index, value);\n                } else {\n                    update((position << 1) + 1, mid + 1, high, index, value);\n                }\n                segmentArray[position] = function.apply(segmentArray[position << 1], segmentArray[(position << 1) + 1]);\n            }\n        }\n    }\n\n    static class SegmentTreeGeneric<T> {\n\n        private Object[] segmentArray;\n        private BiFunction<T, T, T> function;\n\n        protected void setSegmentArray(T[] segmentArray) {\n            this.segmentArray = segmentArray;\n        }\n\n        protected Object getSegmentArray() {\n            return segmentArray.clone();\n        }\n\n        protected void setFunction(BiFunction<T, T, T> function) {\n            this.function = function;\n        }\n\n        protected BiFunction<T, T, T> getFunction() {\n            return function;\n        }\n\n        SegmentTreeGeneric() {\n\n        }\n\n        SegmentTreeGeneric(T[] startBase, T neutral, BiFunction<T, T, T> function) {\n            this.function = function;\n            int length = startBase.length;\n            Object[] base;\n            if ((length & (length - 1)) != 0) {\n                int pow = 0;\n                while (length > 0) {\n                    length >>= 1;\n                    pow++;\n                }\n                pow--;\n                base = new Object[2 << pow];\n                System.arraycopy(startBase, 0, base, 0, startBase.length);\n                Arrays.fill(base, startBase.length, base.length, neutral);\n\n            } else {\n                base = startBase;\n            }\n            segmentArray = new Object[base.length << 1]; // maybe * 4\n            Arrays.fill(segmentArray, neutral);\n            inDepth(base, 1, 0, base.length - 1);\n        }\n\n        private void inDepth(Object[] base, int position, int low, int high) {\n            if (low == high) {\n                segmentArray[position] = base[low];\n            } else {\n                int mid = (low + high) >> 1;\n                inDepth(base, position << 1, low, mid);\n                inDepth(base, (position << 1) + 1, mid + 1, high);\n                segmentArray[position] = function.apply((T) segmentArray[position << 1], (T) segmentArray[(position << 1) + 1]);\n            }\n        }\n\n        protected T getValue(int left, int right, T neutral) {\n            return findValue(1, 0, ((segmentArray.length) >> 1) - 1, left, right, neutral);\n        }\n\n        private T findValue(int position, int low, int high, int left, int right, T neutral) {\n            if (left > right) {\n                return neutral;\n            }\n            if (left == low && right == high) {\n                return (T) segmentArray[position];\n            }\n            int mid = (low + high) >> 1;\n            return function.apply(findValue(position << 1, low, mid, left, Math.min(right, mid), neutral),\n                    findValue((position << 1) + 1, mid + 1, high, Math.max(left, mid + 1), right, neutral));\n        }\n\n        protected void replaceValue(int index, T value) {\n            update(1, 0, (segmentArray.length >> 1) - 1, index, value);\n        }\n\n        private void update(int position, int low, int high, int index, T value) {\n            if (low == high) {\n                segmentArray[position] = value;\n            } else {\n                int mid = (low + high) >> 1;\n                if (index <= mid) {\n                    update(position << 1, low, mid, index, value);\n                } else {\n                    update((position << 1) + 1, mid + 1, high, index, value);\n                }\n                segmentArray[position] = function.apply((T) segmentArray[position << 1], (T) segmentArray[(position << 1) + 1]);\n            }\n        }\n    }\n}\n\nclass SystemOfDisjointSets {\n\n    private int[] rank;\n    private int[] dsu;\n\n    SystemOfDisjointSets(int size) {\n        this.rank = new int[size];\n        this.dsu = new int[size];\n    }\n\n    protected void makeSet(int value) {\n        dsu[value] = value;\n        rank[value] = 0;\n    }\n\n    protected int findSet(int value) {\n        if (value == dsu[value]) {\n            return value;\n        }\n        return dsu[value] = findSet(dsu[value]);\n    }\n\n    protected boolean mergeSets(int first, int second) {\n        first = findSet(first);\n        second = findSet(second);\n        if (first != second) {\n            if (rank[first] < rank[second]) {\n                int number = first;\n                first = second;\n                second = number;\n            }\n            dsu[second] = first;\n            if (rank[first] == rank[second]) {\n                rank[first]++;\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\ninterface Array {\n    void useArray(int[] a);\n}\n\ninterface Method<T> {\n    void use(T value);\n}\n\nclass FastSort {\n\n    static enum TypeSort {\n        Shell,\n        Heap,\n        Merge,\n        My,\n        Insertion\n\n    }\n\n    protected static int[] sort(int[] array, int shellHeapMergeMyInsertionSort) {\n        sort(array, shellHeapMergeMyInsertionSort, array.length);\n        return array;\n    }\n\n    protected static int[] sortClone(int[] array, int shellHeapMergeMyInsertionSort) {\n        int[] base = array.clone();\n        sort(base, shellHeapMergeMyInsertionSort, array.length);\n        return base;\n    }\n\n    private static void sort(int[] array, int ShellHeapMergeMyInsertionSort, int length) {\n        if (ShellHeapMergeMyInsertionSort < 0 || ShellHeapMergeMyInsertionSort > 4) {\n            Random random = new Random();\n            ShellHeapMergeMyInsertionSort = random.nextInt(4);\n        }\n        if (ShellHeapMergeMyInsertionSort == 0) {\n            ShellSort(array);\n        } else if (ShellHeapMergeMyInsertionSort == 1) {\n            HeapSort(array);\n        } else if (ShellHeapMergeMyInsertionSort == 2) {\n            MergeSort(array, 0, length - 1);\n        } else if (ShellHeapMergeMyInsertionSort == 3) {\n            straightMergeSort(array, length);\n        } else if (ShellHeapMergeMyInsertionSort == 4) {\n            insertionSort(array);\n        }\n    }\n\n    private static void straightMergeSort(int[] array, int size) {\n        if (size == 0) {\n            return;\n        }\n        int length = (size >> 1) + ((size % 2) == 0 ? 0 : 1);\n        Integer[][] ZeroBuffer = new Integer[length + length % 2][2];\n        Integer[][] FirstBuffer = new Integer[0][0];\n        for (int index = 0; index < length; index++) {\n            int ArrayIndex = index << 1;\n            int NextArrayIndex = (index << 1) + 1;\n            if (NextArrayIndex < size) {\n                if (array[ArrayIndex] > array[NextArrayIndex]) {\n                    ZeroBuffer[index][0] = array[NextArrayIndex];\n                    ZeroBuffer[index][1] = array[ArrayIndex];\n                } else {\n                    ZeroBuffer[index][0] = array[ArrayIndex];\n                    ZeroBuffer[index][1] = array[NextArrayIndex];\n                }\n            } else {\n                ZeroBuffer[index][0] = array[ArrayIndex];\n            }\n        }\n        boolean position = false;\n        int pointer0, pointer, pointer1, number = 4, NewPointer, count;\n        Integer[][] NewBuffer;\n        Integer[][] OldBuffer;\n        length = (size >> 2) + ((size % 4) == 0 ? 0 : 1);\n        while (true) {\n            pointer0 = 0;\n            count = (number >> 1) - 1;\n            if (!position) {\n                FirstBuffer = new Integer[length + length % 2][number];\n                NewBuffer = FirstBuffer;\n                OldBuffer = ZeroBuffer;\n            } else {\n                ZeroBuffer = new Integer[length + length % 2][number];\n                NewBuffer = ZeroBuffer;\n                OldBuffer = FirstBuffer;\n            }\n            for (int i = 0; i < length; i++) {\n                pointer = 0;\n                pointer1 = 0;\n                NewPointer = pointer0 + 1;\n                if (length == 1) {\n                    for (int g = 0; g < size; g++) {\n                        if (pointer > count || OldBuffer[pointer0][pointer] == null) {\n                            array[g] = OldBuffer[NewPointer][pointer1];\n                            pointer1++;\n                        } else if (pointer1 > count || OldBuffer[NewPointer][pointer1] == null) {\n                            if (OldBuffer[pointer0][pointer] == null) {\n                                continue;\n                            }\n                            array[g] = OldBuffer[pointer0][pointer];\n                            pointer++;\n                        } else if (OldBuffer[pointer0][pointer] >= OldBuffer[NewPointer][pointer1]) {\n                            array[g] = OldBuffer[NewPointer][pointer1];\n                            pointer1++;\n                        } else {\n                            array[g] = OldBuffer[pointer0][pointer];\n                            pointer++;\n                        }\n                    }\n                    return;\n                }\n                for (int g = 0; g < number; g++) {\n                    if (pointer > count || OldBuffer[pointer0][pointer] == null) {\n                        if (OldBuffer[NewPointer][pointer1] == null) {\n                            continue;\n                        }\n                        NewBuffer[i][g] = OldBuffer[NewPointer][pointer1];\n                        pointer1++;\n                    } else if (pointer1 > count || OldBuffer[NewPointer][pointer1] == null) {\n                        if (OldBuffer[pointer0][pointer] == null) {\n                            continue;\n                        }\n                        NewBuffer[i][g] = OldBuffer[pointer0][pointer];\n                        pointer++;\n                    } else if (OldBuffer[pointer0][pointer] >= OldBuffer[NewPointer][pointer1]) {\n                        NewBuffer[i][g] = OldBuffer[NewPointer][pointer1];\n                        pointer1++;\n                    } else {\n                        NewBuffer[i][g] = OldBuffer[pointer0][pointer];\n                        pointer++;\n                    }\n                }\n                pointer0 += 2;\n            }\n            position = !position;\n            length = (length >> 1) + length % 2;\n            number <<= 1;\n        }\n    }\n\n    private static void ShellSort(int[] array) {\n        int j;\n        for (int gap = (array.length >> 1); gap > 0; gap >>= 1) {\n            for (int i = gap; i < array.length; i++) {\n                int temp = array[i];\n                for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {\n                    array[j] = array[j - gap];\n                }\n                array[j] = temp;\n            }\n        }\n    }\n\n    private static void HeapSort(int[] array) {\n        for (int i = (array.length >> 1) - 1; i >= 0; i--)\n            shiftDown(array, i, array.length);\n        for (int i = array.length - 1; i > 0; i--) {\n            swap(array, 0, i);\n            shiftDown(array, 0, i);\n        }\n    }\n\n    private static void shiftDown(int[] array, int i, int n) {\n        int child;\n        int tmp;\n        for (tmp = array[i]; leftChild(i) < n; i = child) {\n            child = leftChild(i);\n            if (child != n - 1 && (array[child] < array[child + 1]))\n                child++;\n            if (tmp < array[child])\n                array[i] = array[child];\n            else\n                break;\n        }\n        array[i] = tmp;\n    }\n\n    private static int leftChild(int i) {\n        return (i << 1) + 1;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void MergeSort(int[] array, int low, int high) {\n        if (low < high) {\n            int mid = (low + high) >> 1;\n            MergeSort(array, low, mid);\n            MergeSort(array, mid + 1, high);\n            merge(array, low, mid, high);\n        }\n    }\n\n    private static void merge(int[] array, int low, int mid, int high) {\n        int n = high - low + 1;\n        int[] Temp = new int[n];\n        int i = low, j = mid + 1;\n        int k = 0;\n        while (i <= mid || j <= high) {\n            if (i > mid)\n                Temp[k++] = array[j++];\n            else if (j > high)\n                Temp[k++] = array[i++];\n            else if (array[i] < array[j])\n                Temp[k++] = array[i++];\n            else\n                Temp[k++] = array[j++];\n        }\n        for (j = 0; j < n; j++)\n            array[low + j] = Temp[j];\n    }\n\n    private static void insertionSort(int[] elements) {\n        for (int i = 1; i < elements.length; i++) {\n            int key = elements[i];\n            int j = i - 1;\n            while (j >= 0 && key < elements[j]) {\n                elements[j + 1] = elements[j];\n                j--;\n            }\n            elements[j + 1] = key;\n        }\n    }\n}\n\nclass IO {\n\n    private static BufferedReader read;\n    private static boolean fileInput = false;\n    private static BufferedWriter write;\n    private static boolean fileOutput = false;\n\n    public static void setFileInput(boolean fileInput) {\n        IO.fileInput = fileInput;\n    }\n\n    public static void setFileOutput(boolean fileOutput) {\n        IO.fileOutput = fileOutput;\n    }\n\n    private static void startInput() {\n        try {\n            read = new BufferedReader(fileInput ? new FileReader(\"input.txt\") : new InputStreamReader(System.in));\n        } catch (Exception error) {\n        }\n    }\n\n    private static void startOutput() {\n        try {\n            write = new BufferedWriter(fileOutput ? new FileWriter(\"output.txt\") : new OutputStreamWriter(System.out));\n        } catch (Exception error) {\n        }\n    }\n\n    protected static int readInt() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Integer.parseInt(read.readLine());\n    }\n\n    protected static long readLong() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Long.parseLong(read.readLine());\n    }\n\n    protected static String readString() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return read.readLine();\n    }\n\n    protected static int[] readArrayInt(String split) throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Arrays.stream(read.readLine().split(split)).mapToInt(Integer::parseInt).toArray();\n    }\n\n    protected static long[] readArrayLong(String split) throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Arrays.stream(read.readLine().split(split)).mapToLong(Long::parseLong).toArray();\n    }\n\n    protected static String[] readArrayString(String split) throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return read.readLine().split(split);\n    }\n\n    protected static void writeArray(int[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Integer.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception error) {\n        }\n    }\n\n    protected static void writeArray(Integer[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Integer.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception error) {\n        }\n    }\n\n    protected static void writeArray(long[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Long.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception error) {\n        }\n    }\n\n    protected static void writeArray(Long[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Long.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception error) {\n        }\n    }\n\n    public static void writeArray(String[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(array[index]);\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeArray(boolean[] array, String split, boolean enter) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Boolean.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            if (enter) {\n                writeEnter();\n            }\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeInt(int number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Integer.toString(number));\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeInt(Integer number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Integer.toString(number));\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeLong(long number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Long.toString(number));\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeLong(Long number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Long.toString(number));\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeString(String word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeBoolean(boolean value, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(value ? \"true\" : \"false\");\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeBoolean(Boolean value, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(value ? \"true\" : \"false\");\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeChar(char word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void writeChar(Character word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception ignored) {\n        }\n    }\n\n\n    protected static void writeEnter() {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.newLine();\n        } catch (Exception ignored) {\n        }\n    }\n\n    protected static void print(boolean exit) throws Exception {\n        if (exit) {\n            print();\n        } else {\n            write.flush();\n        }\n    }\n\n    protected static void print() throws Exception {\n        if (write == null) {\n            return;\n        }\n        write.flush();\n        if (read != null) {\n            read.close();\n        }\n        write.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\n\ndef pi():\n    return(int(input()))\ndef pl():\n    return(int(input(), 16))\ndef ti():\n    return(list(map(int,input().split())))\ndef ts():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\n\n\ndef main():\n    B();\n\ndef A():\n    t = pi();\n    while t:\n        t -= 1;\n        n = ti();\n        s = ts();\n        temp = \"\";\n        for c in s:\n            if c == \"b\":\n                temp += \"b\";\n\n        ans = temp;\n        if len(temp) == 0:\n            print(*s, sep=\"\");\n            continue;\n        \n        for c in s:\n            if c != \"b\":\n                ans += c;\n        \n        print(ans);\n\ndef B():\n    t = pi();\n    while t:\n        t -= 1;\n        [n,k] = ti();\n        p = [[]*n]*n;\n        for i in range(n):\n            p[i] = ti();\n\n        isPossible = False;\n        for i in range(n):\n            f = True;\n            for j in range(n):\n                d = abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]);\n                if d > k:\n                    f = False;\n                    break;\n            if f:\n                isPossible = True;\n\n        if not isPossible:\n            print(-1);\n        else:\n            print(1);\n\n\n\nmain();\n"
        },
        {
            "language": 2,
            "solution": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define gcd(a,b) __gcd(a,b)\n#define pb push_back\n#define DRACO ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define ll long long int\n#define GO ll t; cin>>t; for(int i = 1 ; i <= t ;i++)\n#define mod  1000000007\n#define fore(p) for(auto& x:p)\n#define all(x) x.begin(),x.end()\n#define allr(x) x.rbegin(), x.rend()\n#define F first\n#define S second \n//check the corner cases(n==1)\n//try checking in reverse order\n//check your logic again\nll k;\nvoid Solve()\n{\n\tll i,j,l,n,m;\n\tcin >> n >> k;\n\tvector<pair<ll,ll>> v;\n\tfor(i = 0 ; i < n ;i++)\n\t{\tll x, y;\n\t\tcin >> x >> y;\n\t\tv.pb({x,y});\n\t}\n\n\tsort(all(v));\n\n\tfor(i = 0 ; i< n ;i++)\n\t{\tll f = 1;\n\t\tfor(j = 0 ; j < n ;j++)\n\t\t{\n\t\t\tif(abs(v[i].F-v[j].F) + abs(v[i].S-v[j].S) > k)\n\t\t\t{\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tcout << \"1\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcout << \"-1\\n\";\n}\nint main() \n{   DRACO\n    cout.precision(10);\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    #endif\n    GO\n    {   \t\n    \tSolve();\n    }\nreturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint r[110];\npair<int,int> p[110];\n\nint main(){\n  int t;\n  cin >> t;\n\n  while(t --){\n    memset(r,0,sizeof r);\n\n    int n,k;\n    cin >> n >> k;\n\n    for(int i = 1;i <= n;i++) cin >> p[i].first >> p[i].second;\n\n    for(int i = 1;i <= n;i++){\n      for(int j = 1;j <= n;j++){\n        if(abs(p[i].first - p[j].first) + abs(p[i].second - p[j].second) <= k)\n          r[i] ++;\n      }\n    }\n\n    bool f = false;\n\n    for(int i = 1;i <= n;i++){\n      if(r[i] == n){\n        cout << \"1\" << endl;\n        f = true;\n        break;\n      }\n    }\n\n    if(f == false) cout << \"-1\" << endl;\n    \n  }\n\n}"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    s = True\n    for i in range(n):\n        p = True\n        for j in range(n):\n            if abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) > k: p = False; break\n        if p: print(1); s = False; break\n    if s: print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class Main{\n\tstatic class Point{\n\t\tint x,y; \n\t\tPoint(int nx, int ny){\n\t\t\tx = nx; y = ny;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException{\n    \tIn in = new In();\n    \tfor(int q = in.pint(); q > 0; q--) {\n    \t\tin.tok();\n    \t\tint n = in.pint(); int k = in.pint();\n    \t\tint[] x = new int[n];\n    \t\tint[] y = new int[n];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tin.tok();\n    \t\t\tx[i] = in.pint();\n    \t\t\ty[i] = in.pint();\n    \t\t}\n    \t\tboolean f = false;\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tboolean b = true;\n    \t\t\tfor(int j = 0; j < n; j++) {\n    \t\t\t\tb &= Math.abs(x[i] - x[j]) + Math.abs(y[i] - y[j]) <= k;\n    \t\t\t}\n    \t\t\tf |= b;\n    \t\t}\n    \t\tSystem.out.println(f ? 1 : -1);\n    \t}\n    }\n}\t\n \n \nclass In{\n    BufferedReader in;\n    StringTokenizer st = new StringTokenizer(\"\");\n    public In(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n    }\n    \n    int pint() throws IOException{\n        if(st.hasMoreTokens()) {return Integer.parseInt(st.nextToken());}\n        else {return Integer.parseInt(in.readLine());}\n    }\n    double pdbl() throws IOException{\n        if(st.hasMoreTokens()) {return Double.parseDouble(st.nextToken());}\n        else {return Double.parseDouble(in.readLine());}\n    }\n    long plng() throws IOException{\n        if(st.hasMoreTokens()) {return Long.parseLong(st.nextToken());}\n        else {return Long.parseLong(in.readLine());}\n    }\n    char pchr() throws IOException{\n        if(st.hasMoreTokens()) {return st.nextToken().charAt(0);}\n        else {return in.readLine().charAt(0);}\n    }\n    String pstr() throws IOException{\n        if(st.hasMoreTokens()) {return st.nextToken();}\n        else {return in.readLine();}\n    }\n    String readLine() throws IOException{\n    \treturn in.readLine();\n    }\n    boolean ready() throws IOException {return in.ready();}\n    boolean readyN() throws IOException{return in.ready() || st.hasMoreTokens();}\n    void tok() throws IOException{st = new StringTokenizer(in.readLine());}\n    void skip() throws IOException{in.readLine();}\n}"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\n\n''' Hey stalker :) '''\nINF = 10 ** 50\nTEST_CASES = True\n\ndef main():\n    n, k = get_list()\n    locations = [get_list() for _ in range(n)]\n    ans = -1\n    for x1, y1 in locations:\n        can_attract_all = True\n        for x2, y2 in locations:\n            can_attract = abs(x2 - x1) + abs(y2 - y1) <= k\n            if not can_attract:\n                can_attract_all = False\n                break\n        if can_attract_all:\n            ans = 1\n            break\n\n    print(ans)\n\n\n\n\n\n\n''' FastIO Footer: PyRival Library, Thanks @c1729 and contributors '''\nimport os\nimport sys\n#from bisect import bisect_left, bisect_right, bisect\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\n# else:\n#     sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nget_int = lambda: int(input())\nget_list = lambda: list(map(int, input().split()))\n\nif __name__ == \"__main__\":\n    if TEST_CASES:\n        [main() for _ in range(int(input()))]\n    else:\n        main()\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long ll;\nlong long t,n,m,k,ccnt,pos=0,sum=0,minn2=INT_MAX,sum2,cnt=0,cnt1=0,cnt2=0,cnt3=0,cnt4=0,cnt5=0,cnt6=0,cnt7=0,a[2000005],x1,y7,x2,y2,x3,y3,aaa,bbb;\nlong long vis[1000005],b[1000005],c[1000005],c3[2005][2005],c4[1000005],kk[1000005],x,y,z,d=0,l2,r2;\nlong long pos1=0,pos2=0,tem,tem2,l,r,ans=0,ans2,mod=998244353,tw[100005],th[100005],dd,ee,out[1000005],te[100005],dp[1000005],dp2[1000005],dp3[1000005];\nlong long minn=LONG_LONG_MAX,maxx=-LONG_LONG_MAX;\nstring s1,s2,s;\nchar cc[2005][2005],ch,cr[100005],ch2;\nvector<int> v[100005];\n//vector<int> v2[100005];\nlong long fpow(long long aa,long long bb)\n{\n    long long kk1=aa;\n    long long kk2=1;\n    while(bb>1)\n    {\n        if(bb%2)\n        {\n            kk2*=kk1;\n            kk2%=mod;\n        }\n        kk1*=kk1;\n        kk1%=mod;\n        bb=bb/2;\n    }\n    return (kk1*kk2)%mod;\n}\nsigned main()\n{\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>t;\n    while(t--)\n    {\n        cin>>n>>k;\n        for(int i=0;i<n;i++)\n        {\n            cin>>a[i]>>b[i];\n        }\n        ans=0;\n        for(int i=0;i<n;i++)\n        {\n            d=1;\n            for(int j=0;j<n;j++)\n            {\n                if(abs(a[i]-a[j])+abs(b[i]-b[j])>k)\n                {\n                    d=0;\n                }\n            }\n            if(d)\n            {\n                ans=1;\n                break;\n            }\n        }\n        if(ans)\n        {\n            cout<<1<<'\\n';\n        }\n        else\n        {\n            cout<<-1<<'\\n';\n        }\n\n\n    }\n\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(), (a).end()\n#define reset(a,v) memset((a), v, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<ii> vii;\n\nconst int N = 105;\n\nint n, k;\nii dat[N];\n\nint getManhattanDist(ii a, ii b) {\n\treturn abs(a.fi - b.fi) + abs(a.se - b.se);\n}\n\nint main() {\n\tint tc; cin >> tc;\n\twhile (tc--) {\n\t\tcin >> n >> k;\n\t\tfor (int i = 0; i < n; i++) cin >> dat[i].fi >> dat[i].se;\n\t\tbool ok = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbool can = 1;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint dist = getManhattanDist(dat[i], dat[j]);\n\t\t\t\tif (dist > k) {\n\t\t\t\t\tcan = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (can) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) cout << \"1\\n\";\n\t\telse cout << \"-1\\n\";\n\t}\n\treturn 0;\n}"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom heapq import heappop, heappush\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    t = int(input())\n\n    for _ in range(t):\n        n, k = map(int, input().split())\n        balls = [[int(i) for i in input().split()] for _ in range(n)]\n\n        in_range = [0] * n\n\n        for i, ball_i in enumerate(balls):\n            for j, ball_j in enumerate(balls):\n                dist = abs(ball_i[0] - ball_j[0]) + abs(ball_i[1] - ball_j[1])\n                if dist <= k:\n                    in_range[i] += 1\n\n        print(1 if max(in_range) == n else -1)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 3,
            "solution": "def dist(a, b):\n\treturn abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef solve(n, k, p):\n\tfor i in range(n):\n\t\tif all(dist(p[i], p[j]) <= k for j in range(n)):\n\t\t\treturn 1\n\treturn -1\n\ntests = int(input())\nfor test in range(tests):\n\tn, k = map(int, input().split())\n\tp = [list(map(int, input().split())) for i in range(n)]\n\tprint(solve(n, k, p))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class b1450 implements Runnable{\n\t\n    public static void main(String[] args) {\n    \ttry{\n            new Thread(null, new b1450(), \"process\", 1<<26).start();\n        }\n        catch(Exception e){\n            System.out.println(e);\n        }\n    }\n\tpublic void run() {\n\t\tFastReader scan = new FastReader();\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t//PrintWriter out = new PrintWriter(\"file.out\");\n\t\tTask solver = new Task();\n\t\tint t = scan.nextInt();\n\t\t//int t = 1;\n\t\tfor(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tstatic final int oo = Integer.MAX_VALUE;\n\t\tstatic final long OO = Long.MAX_VALUE;\n\n\t\tList<List<Integer>> adj = new ArrayList<>();\n\t\tpublic void solve(int testNumber, FastReader sc, PrintWriter out) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint K = sc.nextInt();\n\t\t\t\n\t\t\ttup[] coords = new tup[N];\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tcoords[i] = new tup(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tloop:\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tif(Math.abs(coords[i].a - coords[j].a) + Math.abs(coords[i].b - coords[j].b) > K) {\n\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(\"1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t}\n\tstatic long modInverse(long N, long MOD) {\n\t\treturn binpow(N, MOD - 2, MOD);\n\t}\n\tstatic long modDivide(long a, long b, long MOD) {\n\t\ta %= MOD;\n\t\treturn (binpow(b, MOD-2, MOD) * a) % MOD;\n\t}\n\tstatic long binpow(long a, long b, long m) {\n\t\ta %= m;\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tres = res * a % m;\n\t\t\ta = a * a % m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int[] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\tstatic long[] reverse(long a[]) \n    { \n        long[] b = new long[a.length]; \n        for (int i = 0, j = a.length; i < a.length; i++, j--) { \n            b[j - 1] = a[i]; \n        } \n        \n        return b;\n    }\n\t\n\tstatic void shuffle(Object[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tObject temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\tstatic void shuffle(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t}\n\t\n\tstatic class tup implements Comparable<tup>, Comparator<tup>{\n\t\tint a, b;\n\t\ttup(int a,int b){\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic tup() {\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(tup o){\n\t\t\treturn Integer.compare(b,o.b);\n\t\t}\n\t\t@Override\n\t\tpublic int compare(tup o1, tup o2) {\n\t\t\treturn Integer.compare(o1.b, o2.b);\n\t\t}\n\t\t\n\t\t@Override\n\t    public int hashCode() {\n\t\t\treturn Objects.hash(a, b);\n\t    }\n \n\t    @Override\n\t    public boolean equals(Object obj) {\n\t    \tif (this == obj)\n                return true;\n\t    \tif (obj == null)\n                return false;\n\t    \tif (getClass() != obj.getClass())\n                return false;\n\t    \ttup other = (tup) obj;\n\t    \treturn a==other.a && b==other.b;\n\t    }\n\t    \n\t    @Override\n\t    public String toString() {\n\t    \treturn a + \" \" + b;\n\t    }\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\tint[] readArray(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong[] readLongArray(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic void dbg(int[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(long[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\tstatic void dbg(boolean[] arr) {\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n\n\tstatic void dbg(Object... args) {\n        for (Object arg : args)\n            System.out.print(arg + \" \");\n        System.out.println();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint t;cin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tint arr[n][2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>arr[i][0]>>arr[i][1];\n\t\t}\n\t\tint ans=-1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t\n\t\t\tint mx=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tmx=max( mx,abs(arr[i][0]-arr[j][0])+abs(arr[i][1]-arr[j][1]) );\n\t\t\t}\n\t\t\tif(mx<=k){\n\t\t\t\tans=1;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}"
        },
        {
            "language": 3,
            "solution": "t=int(input())\n\nfor s in range(t):\n    n,k=map(int,input().split())\n    l=[]\n\n    for i in range(n):\n        x,y=map(int,input().split())\n        l.append([x,y])\n\n    flag=0\n\n    for i in range(0,n):\n        c=0\n        for j in range(0,n):\n\n            if(abs(l[i][0]-l[j][0]) + abs(l[i][1]-l[j][1])>k):\n                break\n\n            c=c+1\n        if(c==n):\n            flag=1\n            print(1)\n            break\n\n    if(flag==0):\n        print(-1)\n\n   \n\n\n        \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#include <chrono> \n \nusing namespace std;\nusing namespace std::chrono; \n \n// #pragma GCC target (\"avx2\")\n// #pragma GCC optimization (\"O3\")\n// #pragma GCC optimization (\"unroll-loops\")\n// #pragma optimization_level 3\n// #pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define f0r(a, b) for (long long a = 0; a < (b); ++a)\n#define f1r(a, b, c) for (long long a = (b); a < (c); ++a)\n#define f0rd(a, b) for (long long a = (b); a >= 0; --a)\n#define f1rd(a, b, c) for (long long a = (b); a >= (c); --a)\n#define ms(arr, v) memset(arr, v, sizeof(arr))\n#define pb push_back\n#define send {ios_base::sync_with_stdio(false);}\n#define help {cin.tie(NULL); cout.tie(NULL);}\n#define fix(prec) {cout << setprecision(prec) << fixed;}\n#define mp make_pair\n#define f first\n#define s second\n#define all(v) v.begin(), v.end()\n#define getunique(v) {sort(all(v)); v.erase(unique(all(v)), v.end());}\n#define readgraph(list, edges) for (int i = 0; i < edges; i++) {int a, b; cin >> a >> b; a--; b--; list[a].pb(b); list[b].pb(a);}\n#define ai(a, n) for (int ele = 0; ele < n; ele++) cin >> a[ele];\n#define ain(a, lb, rb) for (int ele = lb; ele <= rb; ele++) cin >> a[ele];\n#define ao(a, n) {for (int ele = 0; ele < (n); ele++) { if (ele) cout << \" \"; cout << a[ele]; } cout << '\\n';}\n#define aout(a, lb, rb) {for (int ele = (lb); ele <= (rb); ele++) { if (ele > (lb)) cout << \" \"; cout << a[ele]; } cout << '\\n';}\n#define vsz(x) ((long long) x.size())\ntypedef long long int ll;\ntypedef long double lld;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\n \ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n\tcout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n\tcin >> p.first;\n\treturn cin >> p.second;\n}\n \nmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n// mt19937 rng(61378913);\n/* usage - just do rng() */\n \nvoid usaco(string filename) {\n  // #pragma message(\"be careful, freopen may be wrong\")\n\tfreopen((filename + \".in\").c_str(), \"r\", stdin);\n\tfreopen((filename + \".out\").c_str(), \"w\", stdout);\n}\n \nconst lld pi = 3.14159265358979323846;\n// const ll mod = 1000000007;\n// const ll mod = 998244353;\n// ll mod;\n \n\n\nll n, m, k, q, l, r, x, y, z;\nconst ll template_array_size = 1e6 + 585;\nll a[template_array_size];\nll b[template_array_size];\nll c[template_array_size];\nstring s, t;\nll ans = 0;\n\n\n\nvoid solve() {\n    int n,k;\n    cin >> n >> k;\n    \n    vl xs(n),ys(n);\n    \n    f0r(i,n) {\n        cin >> xs[i] >> ys[i];\n    }\n    \n    int ans = -1;\n    \n    f0r(i,n) {\n        ll mx = 0;\n        f0r(j,n) {\n             mx = max(mx,abs(xs[i]-xs[j])+abs(ys[i]-ys[j]));   \n        }\n        \n        if(mx <= k) ans = 1;\n    }\n    \n    cout << ans << '\\n';\n}\n \nint main() {\n\tsend help\n\n\tint tc = 1;\n\tcin >> tc;\n\twhile(tc--) solve();\n} \n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1999999999999999999\n#define mod 1000000007\n#define lb lower_bound\n#define ub upper_bound\n#define pb push_back\n#define pf push_front\n#define bn binary_search\n#define pq priority_queue\n#define int long long\n#define pii pair<int,int>\n#define mii map<int,int>\n#define umii unordered_map<int,int>\n#define um unordered_map\n#define vi vector<int>\n#define mii map<int,int>\n#define si set<int>\n#define ft first\n#define sc second\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) a*(b/gcd(a,b))\n#define bp(a) __builtin_popcountll(a)\n#define mmst(a,b) memset(a,b,sizeof(a))\n#define ld long double\nvoid lc(){cout<<endl;}\nint md(int n){return n%mod;}\nvoid solve()\n{\n\tint n;\n\tld k;\n\tcin>>n>>k;\n\t//k=k*((ld)(sqrt(2)));\n\tpii p[n];\n\tfor(int i=0;i<n;i++)\n\tcin>>p[i].ft>>p[i].sc;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint mind=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tint dis=abs(p[i].ft-p[j].ft)+abs(p[i].sc-p[j].sc);\n\t\t\tmind=max(mind,dis);\n\t\t}\n\t\tif(mind<=k)\n\t\t\t{\n\t\t\t\tcout<<\"1\";\n\t\t\t\treturn;\n\t\t\t}\n\t}\n    cout<<\"-1\";\n\t\n}\nsigned main()\n{ \n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t  solve();\n\t  lc();\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "for _ in range(0, int(input())):\n    n, k = map(int, input().split())\n    p = [tuple(map(int, input().split())) for i in range(0, n)]\n\n    if any([all([(abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1]) <= k) for j in range(0, n)]) for i in range(0, n)]):\n        print(1)\n    else:\n        print(-1)"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    a = []\n    s = 0\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for x in a:\n        for y in a:\n            if (abs(x[0] - y[0]) + abs(x[1] - y[1])) > k:\n                s += 1\n                break\n    if s < n:\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class prog2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(sc.readLine());\n\t\twhile (--t >= 0) {\n\t\t\tStringTokenizer st = new StringTokenizer(sc.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken()), k = Integer.parseInt(st.nextToken()), ans = 0, xavg = 0, yavg = 0;\n\t\t\tpair p[] = new pair[n];\n\t\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\t\tst = new StringTokenizer(sc.readLine());\n\t\t\t\tp[i] = new pair(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n\t\t\t}\n\t\t\tint flag1 = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint flag = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (p[i].dist(p[j]) > k) {\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == 0) {\n\t\t\t\t\tflag1 = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println((flag1 == 1) ? 1 : -1);\n\t\t}\n\t}\n}\n\nclass pair implements Comparable<pair> {\n\tint x, y;\n\n\tpair(int x1, int y1) {\n\t\tx = x1;\n\t\ty = y1;\n\t}\n\n\tint dist(pair p) {\n\t\treturn Math.abs(x - p.x) + Math.abs(y - p.y);\n\t}\n\n\t@Override\n\tpublic int compareTo(pair o) {\n\t\tif (x != o.x)\n\t\t\treturn x - o.x;\n\t\treturn y - o.y;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class B12 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            long k = sc.nextLong();\n            long [] x = new long[n];\n            long [] y = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = sc.nextInt();\n                y[i] = sc.nextInt();\n            }\n            boolean bad = true;\n            for (int i = 0; i < n; i++) {\n                boolean ok = true;\n                for (int j = 0; j < n; j++) {\n                    if (j == i) continue;\n                    if (Math.abs(x[i] - x[j]) + Math.abs(y[i] - y[j]) > k) ok = false;\n                }\n                if (ok) {\n                    bad = false;\n                    break;\n                }\n            }\n\n            out.println(bad ? -1 : 1);\n        }\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\nimport java.util.stream.*;\nimport static java.util.Arrays.*;\nimport java.lang.reflect.Array;\n\n@SuppressWarnings(\"unchecked\")\npublic class B_Balls_of_Steel {\n    public static PrintWriter out;\n    public static InputReader in;\n    public static long MOD = 1_000_000_007;\n    public static int[][] arr;\n    public static int[] marked;\n    public static int k,n;\n    public static int ct;\n    public static void func(int ix){\n        int x = arr[ix][0], y = arr[ix][1];\n        marked[ix] = 1;\n        int neigh = 0; boolean fd = false;\n        ArrayList<Integer> l = new ArrayList<>();\n        for(int i=0;i<n;i++){\n            if(marked[i]==1) continue;\n            int dist = abs(arr[i][0]-x) + abs(arr[i][1]-y);\n            if(dist>k) continue;\n            marked[i] = 1;\n            l.add(i);\n            fd = true;\n        }\n        if(fd) ct++;\n        for(int i : l) func(i);\n    }\n    public static void main(String[] args)throws IOException {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);\n        \n        int cases = in.nextInt();\n        \n        tloop:\n        for(int t = 0; t < cases; t++){\n            n = in.nextInt();\n            k = in.nextInt();\n            arr = new int[n][2];\n            for(int i=0;i<n;i++){\n                arr[i][0] = in.nextInt();\n                arr[i][1] = in.nextInt();\n            }\n            // marked = new int[n]; fill(marked,0);\n            // int ans = Integer.MAX_VALUE;\n            // for(int i=0;i<n;i++){\n            //     ct = 0;\n            //     fill(marked,0);\n            //     func(i);\n            //     boolean works = true;\n            //     for(int j : marked) if(j==0) works = false;\n            //     if(works) ans = min(ans,ct);\n            // }\n            boolean fd = false;\n            for(int i=0;i<n;i++){\n                boolean works = true;\n                for(int j=0;j<n;j++){\n                    int dist = abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1]);\n                    if(dist>k) {works = false; break;}\n                }\n                fd = fd | works;\n            }\n            out.println(fd ? 1 : -1);\n            // out.println((ans==Integer.MAX_VALUE) ? -1 : ans);\n        }\n        \n        out.close();\n    }\n    static void debug(Object... objs){\n        for(Object obj : objs){\n            out.print(obj+\", \");\n        }\n        out.println();\n    }\n    static void fill(Object obj, Object v){\n        int ln = Array.getLength(obj);\n        for(int i=0; i<ln; i++){\n            Object elem = Array.get(obj, i);\n            if(elem!=null && elem.getClass().isArray()) fill(elem, v);\n            else Array.set(obj, i, v);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextArrI(int n) {\n            int[] a=new int[n];\n            for(int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        \n        public long[] nextArrL(int n) {\n            long[] a=new long[n];\n            for (int i=0; i<n; i++) a[i]=nextLong();\n            return a;\n        }\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "            //    I solemnly swear that I am upto no good //\n\n#include <bits/stdc++.h>\n#define sub   freopen(\"input.txt\", \"r\", stdin);//freopen(\"output.txt\", \"w\", stdout);\nusing namespace std;\n#define ll long long\n#define time cerr << '\\n'<<\"Time (in s): \" << double(clock() - clk) * 1.0 / CLOCKS_PER_SEC << '\\n';\n#define pb push_back\n#define endl \"\\n\"\n#define input(arr,n) for(ll i1=0;i1<n;i1++ )cin>>arr[i1]\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define mod 1000000007\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define ff first\n#define ss second\n#define NN cout<<\"NO\"<<endl\n#define YY cout<<\"YES\"<<endl\n#define ub upper_bound\n#define lb lower_bound\n#define A 1000001\n#define make(a,b,c) make_pair(a,make_pair(b,c)) \nbool comp(ll a,ll b){\n    return a>b;\n}\n\n\nvoid solve(){\n    ll n,q,k;\n    // string s;\n    cin>>n>>k;\n    // n=s.size();\n    std::vector<pair<int,int> > ar(n);\n    for(int i=0;i<n;i++){\n        ll a,b;\n        cin>>a>>b;\n        ar[i]=mp(a,b);\n    }\n\n    for(int i=0;i<n;i++){\n        ll cnt=0;\n        for(int j=0;j<n;j++){\n            ll p=abs(ar[i].ff-ar[j].ff)+abs(ar[i].ss-ar[j].ss);\n            if(p<=k){\n                cnt++;\n            }\n        }\n        if(cnt==n){\n            cout<<1<<endl;\n            return;\n        }\n    }\n    cout<<-1<<endl;\n\n\n}\n\nint main(){ \n    // sub;    \n    fast;\n    // pre();\n    // clock_t clk = clock();\n    int t=1;\n    cin>>t;\n    while(t--){\n        solve();\n    }\n    // time;\n\n    return 0;\n}        \n\n                        // Mischief Managed //    \n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class s1\n{\n    public static void main(String []args)\n    {\n        Scanner sc= new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int arr[][]=new int[n][2];\n            for(int i=0;i<n;i++)\n            {\n                arr[i][0]=sc.nextInt();\n                arr[i][1]=sc.nextInt();\n            }\n            int count=0,found=0;\n            for(int i=0;i<n;i++)\n            {\n                count=0;\n                for(int j=0;j<n;j++)\n                {\n                    if(Math.abs(arr[i][0]-arr[j][0])+Math.abs(arr[i][1]-arr[j][1])<=k)\n                    count++;\n                }\n                if(count==n)\n                {\n                    found=1;\n                    break;\n                }\n            }\n            if(found==1)\n            System.out.println(1);\n            else \n            System.out.println(-1);\n           \n        }\n    }\n}   "
        },
        {
            "language": 3,
            "solution": "import sys\n\ninput = sys.stdin.readline\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\n\ndef main():\n    for _ in range(int(input())):\n        #n=int(input())\n        # a=list(map(int, input().split()))\n        n,k=map(int, input().split())\n        xy=[]\n        for i in range(n):\n            xy.append(list(map(int, input().split())))\n        f=0\n        for i in range(n):\n            currx=xy[i][0]\n            curry=xy[i][1]\n            f=1\n            for j in range(n):\n                if abs(xy[j][0]-currx)+abs(xy[j][1]-curry)>k:\n                    f=0\n                    break\n            if f:\n                break\n        if f:\n            print(1)\n        else:\n            print(-1)\n\n\n\n    return\n\nif __name__==\"__main__\":\n    main()\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class codeforces {\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tint k=sc.nextInt();\n\t\t\tpair[]a=new pair[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i]=new pair(sc.nextLong(), sc.nextLong());\n\t\t\t}\n\t\t\tlong[][]dis=new long[n][n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tdis[i][j]=Math.abs(a[i].x-a[j].x)+Math.abs(a[i].y-a[j].y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean can=false;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tboolean temp=true;\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tif(dis[i][j]>k)temp=false;\n\t\t\t\t}\n\t\t\t\tcan=can|temp;\n\t\t\t}\n\t\t\tpw.println(can?1:-1);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpw.close();\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic long[] nextlongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic Long[] nextLongArray(int n) throws IOException {\n\t\t\tLong[] a = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic Integer[] nextIntegerArray(int n) throws IOException {\n\t\t\tInteger[] a = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tlong y;\n\n\t\tpublic pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof pair) {\n\t\t\t\tpair p = (pair) o;\n\t\t\t\treturn p.x == x && p.y == y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn new Double(x).hashCode() * 31 + new Double(y).hashCode();\n\t\t}\n\n\t\tpublic int compareTo(pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(this.y, other.y);\n\t\t\t}\n\t\t\treturn Long.compare(this.x, other.x);\n\t\t}\n\t}\n\n\tstatic class tuble implements Comparable<tuble> {\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\n\t\tpublic tuble(int x, int y, int z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + z;\n\t\t}\n\n\t\tpublic int compareTo(tuble other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\tif (this.y == other.y) {\n\t\t\t\t\treturn this.z - other.z;\n\t\t\t\t}\n\t\t\t\treturn this.y - other.y;\n\t\t\t} else {\n\t\t\t\treturn this.x - other.x;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long mod = 1000000007;\n\tstatic Random rn = new Random();\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Greeks {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint dist = 0;\n\t\t\tMap<Integer,List<Integer>> mp = new HashMap<>();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tdist = 0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tdist = Math.abs(x[j] - x[i]) + Math.abs(y[j] - y[i]);\n\t\t\t\t\tif(dist <= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(mp.containsKey(i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmp.get(i).add(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\t\t\t\t\tlist.add(j);\n\t\t\t\t\t\t\tmp.put(i,list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean b = false;\n\t\t\tfor(int i : mp.keySet())\n\t\t\t\tif(mp.get(i).size() == n-1)\n\t\t\t\t{\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(b)\n\t\t\t\tSystem.out.println(1);\n\t\t\telse System.out.println(-1);\n \t\t}\n\t\t\n\t}\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\n// \npublic class B {\n\n\tpublic static FastScanner fs;\n\tpublic static void solve() {\n\t\tint n = fs.nextInt();\n\t\tint k = fs.nextInt();\n\t\tList<Integer> x =  new ArrayList<Integer>();\n\t\tList<Integer> y =  new ArrayList<Integer>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tx.add(fs.nextInt());\n\t\t\ty.add(fs.nextInt());\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint xi = x.get(i);\n\t\t\tint yi = y.get(i);\n\t\t\tint grouped = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(Math.abs(xi - x.get(j)) + Math.abs(yi - y.get(j)) <= k)\n\t\t\t\t\tgrouped++;\n\t\t\t}\n\t\t\t\n\t\t\tif(n - grouped == 1) {\n\t\t\t\tans = Math.min(ans, grouped);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans == Integer.MAX_VALUE ? -1 : n-ans);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfs=new FastScanner();\n\t\tint n = fs.nextInt();\n\t\twhile(n-- > 0) \n\t\t\tsolve();\n//\t\tSystem.out.println(\"\");\n\t}\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "\n\n#include <bits/stdc++.h>  \n\n#define ll long long \n#define ull unsigned long long\n#define M1 1000007\n\n\n#define for0(i, n) for (ll i = 0; i < (ll)(n); i++) // 0 based indexing\n#define for1(i, n) for (ll i = 1; i <= (ll)(n); i++) // 1 based indexing\n#define forc(i, l, r) for (ll i = (ll)(l); i <= (ll)(r); i++) // closed llerver from l to r r inclusive\n#define forr0(i, n) for (ll i = (ll)(n) - 1; i >= 0; i--) // reverse 0 based.\n#define forr1(i, n) for (ll i = (ll)(n); i >= 1; i--) // reverse 1 based\n\n\n#define pb push_back\n#define fi first\n#define se second\n\n\n\n#define all(x) (x).begin(), (x).end() \n#define rall(x) (x).rbegin(), (x).rend() \n\nusing namespace std;\n\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef pair<ll, ll> ii;\ntypedef vector<ii> vii;\ntypedef double ld;\n\nvector<bool> isthisprime(M1,true);\n\nbool inc(vi vec){   // tells if an array is NOn-decreasing or NOt in O(n) time complexity.\n\t\tforc(i,0,vec.size()-1){\n\t\t\t\tif(vec[i]<vec[i-1])return 0;\n\t\t}\n\t\treturn 1;\n}\n\nbool dec(vi vec){\n\tforc(i,0,vec.size()-1){\n\t\t\t\tif(vec[i]>vec[i-1])return 0;\n\t\t}\n\t\treturn 1;\n}\n\nbool isprime(ll n){    // miller rabin(deterministic version) with time complexity of O(log n).\n\t\tif(n<2)\n\t\t\t\treturn false;\n\t\tfor(ll x:{2,3,5,7,11,13,17,19,23,29,31,37}){\n\t\t\t\tif(n==x)\n\t\t\t\t\t\treturn true;\n\t\t\t\tbool flag=true;\n\t\t\t\tll r=1;\n\t\t\t\tll t=1;\n\t\t\t\twhile(r<=((n-1)>>__builtin_ctzll(n-1))){\n\t\t\t\t\t\tif(r&((n-1)>>__builtin_ctzll(n-1)))\n\t\t\t\t\t\t\t\tt=((ll)t*x)%n;\n\t\t\t\t\t\tx=((ll)x*x)%n;\n\t\t\t\t\t\tr<<=1;\n\t\t\t\t}\n\t\t\t\tif(t==1||t==n-1)\n\t\t\t\t\t\tflag=false;\n\t\t\t\tfor(r=0;r<__builtin_ctzll(n-1);r++){\n\t\t\t\t\t\tt=((ll)t*t)%n;\n\t\t\t\t\t\tif(t==n-1)\n\t\t\t\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag)\n\t\t\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n}\n\nll binpow(ll a, ll b) {  // Time complexity-->log(n) \n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n\nll addmod(ll a,ll b){\n\treturn (a%M1 + b%M1)%M1;\n}\n\n\n//-----------------------------------------------------------END------------------------------------------------------------------------------//\n\n\nvoid solve(){\n\tint n,k;cin>>n>>k;\n\tvii a(n);\n\tfor0(i,n)cin>>a[i].first>>a[i].second;\n\n\tll ans=-1,mx;\n\tfor0(i,n){\n\t\tmx = 0;\n\t\tfor0(j,n){\n\t\t\tmx = max(mx,(abs(a[i].first - a[j].first)+abs(a[j].second-a[i].second)));\n\t\t}\n\t\tif(mx<=k)ans=1;\n\t}\n\tcout<<ans<<'\\n';\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout.precision(10);\n\t//cout << fixed;\n           \n    \n    /*isthisprime[0]=false;\n    isthisprime[1]=false;\n\n  \n        \n    forc(i,2,M1){\n      \tif(isthisprime[i]){\n       \t\tfor(ll j=i*2;j<=M1;j+=i){\n       \t\t\tisthisprime[j]=false;\n       \t\t}\n       \t}\n    }*/\n\n\n\tll tt;cin>>tt;\n\twhile(tt--){\n\t    solve();\n\t}\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\nconst ll mod = 1000000007;\n#define fo(i,a,b) for(ll i=a;i<b;i++)\n#define T ll t; cin>>t; fo(i,0,t)\n#define printclock cerr<<\"Time : \"<<1000*(ld)clock()/(ld)CLOCKS_PER_SEC<<\"ms\\n\";\n\n/*vector<pair<ll, ll> > A;  //sorting map in asc order by val  //use A.begin() after the sort work as map\nbool cmp(pair<ll, ll>& a, //if using multiple time dont forget to use A.clear();\n         pair<ll, ll>& b) \n{ \n    return a.second < b.second; \n}\nvoid sort(map<ll, ll>& M)  //sort(ma);\n{  \n    for (auto& it : M) { \n        A.push_back(it); \n    } \n  \n    sort(A.begin(), A.end(), cmp);\n} \nll gcd(ll a,ll b){  //b>a\n    if(a==0)\n      return b;\n       gcd(b%a,a);\n}\nll isprime(ll n){\n    if(n==2)\n    return 1;\n    if(n<=1)\n    return 0;\n    for(ll i=2;i<=sqrt(n);i++){\n        if(n%i==0)\n         return 0;\n    }\n    return 1;\n}\nll fac(ll n){\n    if(n==0)\n    return 1;\n    if(n==1)\n    return 1;\n    ll i=n,fact=1;\n    while(n/i!=n){\n        fact=fact*i;\n       \n        i--;\n      \n    }\n      return fact%mod;\n}*/\nstring dectobin(ll n){\n    string str=bitset<32>(n).to_string();  //string length 32\n    \n    //const auto loc=str.find('1');//index of first '1' starting from 0\n    //if(loc!=string::npos)\n     //  return str.substr(loc);  \n     return str;  \n     //  return \"0\";\n}\nint main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n   T{\n       ll n,k;  cin>>n>>k;\n       ll x[n],y[n];\n       fo(i,0,n){\n           cin>>x[i]>>y[i];\n       }\n       ll r=-1;  \n           ll c;\n       fo(i,0,n){\n           fo(j,0,n){  if(i==j)\n                         continue;\n               if((abs(x[i]-x[j])+abs(y[i]-y[j]))<=k){\n                  //r=1; break;\n                  c=1;\n               }\n               else{\n                   c=-1; break;\n               }\n           }\n         if(c==1)\n           break;\n       }\n      if(c==1)\n        cout<<1;\n        else\n         cout<<r;\n           cout<<'\\n';\n   } \n   \tprintclock;\n    return 0;\n}\n\n\n\n\n\n\n\n \n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Question2 {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tint t = sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tpublic static void solve() {\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tint[][] cor = new int[n][2];\n\t\t\n\t\tfor(int i =0;i < n;i++) {\n\t\t\tcor[i][0] = sc.nextInt();\n\t\t\tcor[i][1] = sc.nextInt();\n\t\t}\n\t\touter : \n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tboolean ans = true;\n\t\t\tfor(int j = 0;j < n;j++) {\n\t\t\t\t\n\t\t\t\tif(!dist(cor, i, j, k))continue outer;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSystem.out.println(-1);\n\t}\n\t\n\tpublic static boolean dist(int[][] cor, int i, int j, int k) {\n\t\tint x1 = cor[i][0];\n\t\tint y1 = cor[i][1];\n\t\t\n\t\tint x2 = cor[j][0];\n\t\tint y2 = cor[j][1];\n\t\t\n\t\t//System.out.println(\"dis between : [\" + x1 + \",\" + y1 + \"] and [\" + x2 + \",\" + y2 + \"] : \" +( Math.abs(x1 - x2) + Math.abs(y1 - y2)));\n\t\treturn (Math.abs(x1 - x2) + Math.abs(y2 - y1) <= k);\n\t\t\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n\tn,k = list(map(int,input().split()))\n\tl = []\n\tfor i in range(n):\n\t\tl.append(list(map(int,input().split())))\n\tmans = -1\n\tfor i in range(n):\n\t\tans = 1\n\t\tfor j in range(n):\n\t\t\tif i != j and abs(l[i][0] - l[j][0]) + abs(l[i][1] - l[j][1]) > k:\n\t\t\t\tans -= 1\n\t\t\t\tbreak\n\t\tif ans == 1:\n\t\t\tprint(1)\n\t\t\tmans = 1\n\t\t\tbreak\n\tif mans == -1:\n\t\tprint(-1)"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor _ in range(t):\n\tn, k = map(int, input().split())\n\tarr = []\n\tfor i in range(n):\n\t\tx, y = map(int, input().split())\n\t\tarr += [[x, y]]\n\n\tflag = -1\n\tfor i in range(n):\n\t\tcount = 0\n\t\tfor j in range(n):\n\t\t\t# print(arr[i], arr[j], count)\n\t\t\tif abs(arr[i][0]-arr[j][0]) + abs(arr[i][1]-arr[j][1]) <= k:\n\t\t\t\tcount += 1\n\t\tif count == n:\n\t\t\tflag = 1\n\t\t\tbreak\n\n\tprint(flag)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Artem {\n    public static void main(String args[]) throws IOException{\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n        while(t--!=0){\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            Pair[] arr = new Pair[n];\n            for(int i=0;i<n;i++){\n                arr[i] = new Pair(sc.nextInt(),sc.nextInt());\n            }\n            int x =-1;\n            int y =-1;\n            int ans=-1;\n            for(int i=0;i<n;i++){\n                x = arr[i].x;\n                y=arr[i].y;\n                for(int j=0;j<n;j++){\n                    if(Math.abs(x-arr[j].x)+Math.abs(y-arr[j].y)>k){\n                        ans=-1;break;\n                    }else{\n                        if(j==n-1){\n                            ans=1;break;\n                        }\n                    }\n                }\n                if(ans==1)\n                    break;\n            }\n            pw.println(ans);\n        }\n        pw.close();\n    }\n    static class Pair implements Comparable<Pair>{\n        int x;\n        int y;\n        public Pair(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n        \n\n        @Override\n        public int compareTo(Pair z) {\n            if(this.x>z.x){\n                return 1;\n            }else if(this.x<z.x){\n                return -1;\n            }else{\n                if(this.y>z.y)\n                    return 1;\n                else if(this.y<z.y)\n                    return -1;\n                else\n                    return 0;\n            }\n        }\n\n        \n    }\n    static class Scanner {\n\tStringTokenizer st;\n\tBufferedReader br;\n        \n\tpublic Scanner(InputStream s) {\n\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t}\n        \n\tpublic Scanner(String file) throws FileNotFoundException {\n\t\tbr = new BufferedReader(new FileReader(file));\n        }\n\tpublic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic String nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic boolean ready() throws IOException {\n\t\treturn br.ready();\n\t}\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    A = [() for i in range(n)]\n    for i in range(n):\n        A[i] = tuple(list(map(int, input().split())))\n    for i in range(n):\n        for j in range(n):\n            if abs(A[i][0] - A[j][0]) + abs(A[i][1] - A[j][1]) > k:\n                break\n        else:\n            print(1)\n            break\n    else:\n        print(-1)\n    \n    \n"
        },
        {
            "language": 3,
            "solution": "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\n\nt, = map(int,input().split())\nfor _ in range(t):\n    n,k = map(int,input().split())\n    ps = []\n    for i in range(n):\n        x,y = map(int,input().split())\n        ps.append([x,y])\n    d = [0]*n\n    for a in range(n):\n        for i in range(a+1,n):\n            if abs(ps[i][0]-ps[a][0]) +abs(ps[i][1]-ps[a][1])<=k:\n                d[a]+=1\n                d[i]+=1\n    if n-1 in d:\n        print(1)\n    else:\n        print(-1)\n            \n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner();\n\t\tint t = fs.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = fs.nextInt(), k = fs.nextInt();\n\t\t\tPair[] p = new Pair[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = fs.nextInt(), y = fs.nextInt();\n\t\t\t\tp[i] = new Pair(x, y);\n\t\t\t}\n\n\t\t\tint dist, ans = -1;\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int j = 0; j < p.length; j++) {\n\t\t\t\t\tdist = Math.abs(p[i].x - p[j].x) + Math.abs(p[i].y - p[j].y);\n\t\t\t\t\tif (dist > k) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t\tans = 1;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int minDistance(int n, int point[]) {\n\n\t\tArrays.sort(point);\n\n\t\treturn point[(int) Math.ceil((double) (n / 2) - 1)];\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.x - o.x;\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tpublic String next() {\n\t\t\twhile (!st.hasMoreElements())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] readArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class ballsofsteel {\n\t\n\tstatic class Node{\n\t\tint x;\n\t\tint y;\n\t\tArrayList<Node> ranged;\n\t\t\n\t\tNode(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.ranged = new ArrayList<Node>();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\t\n\t\touter: for(int i = 0; i < t; i++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Node> nodes = new ArrayList<>();\n\t\t\t\n\t\t\tfor(int c = 0; c < n; c++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tNode node = new Node(x, y);\n\t\t\t\tnodes.add(node);\n\t\t\t}\n\t\t\t\n\t\t\tfor(Node node1 : nodes) {\n\t\t\t\tfor(Node node2 : nodes) {\n\t\t\t\t\tif(node1 == node2) continue;\n\t\t\t\t\tif((Math.abs(node1.x-node2.x)+Math.abs(node1.y-node2.y)) <= k) {\n\t\t\t\t\t\tnode1.ranged.add(node2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t    \n\t        for(int p = 0; p < n; p++){\n\t            Node node = nodes.get(p);\n\t            \n\t            HashSet<Node> visited = new HashSet<>();\n\t                \n                helper(node, visited, node, k);\n\t            \n\t            if(visited.size() == n) {\n\t            \tSystem.out.println(1);\n\t            \tcontinue outer;\n\t            }\n\t        }\n\t\t    System.out.println(-1);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static void helper(Node node, HashSet<Node> visited, Node root, int k){\n\t\tif((Math.abs(root.x-node.x)+Math.abs(root.y-node.y)) > k)\n\t\t\treturn;\n        \n\t\tvisited.add(node);\n        \n\t\tfor(Node child : node.ranged){\n            if(!visited.contains(child)){\n                helper(child, visited, root, k);\n            }\n        }   \n   }\n\t\n//\tpublic static int bos(ArrayList<Node> nodes, HashSet<Node> unvisited) {\n//\t\tArrayDeque<Node> queue = new ArrayDeque<>();\n//\t\tqueue.offer(nodes.get(0));\n//\t\t\n//\t\tint count = 0;\n//\t\t\n//\t\twhile(!queue.isEmpty()) {\n//\t\t\tNode node = queue.poll();\n//\t\t\tif(!unvisited.contains(node)) {\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t\t\n//\t\t\tunvisited.remove(node);\n//\t\t\t\n//\t\t\tcount++;\n//\t\t\t\n//\t\t\tfor(Node child : node.ranged) {\n//\t\t\t\tif(!unvisited.contains(node)) {\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n//\t\t\t\tqueue.offer(child);\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\nusing namespace std;\nint main(){\n    int cases;\n    cin>>cases;\n    while(cases--){\n        int n,k;\n        cin>>n>>k;\n        int arr[n][2];\n        for(int i = 0 ; i < n ; i++){\n            cin>>arr[i][0]>>arr[i][1];\n        }\n        int check = 0;\n        for(int i = 0 ; i < n ; i++){\n            check = 0;\n            for(int j = 0 ; j < n ; j++){\n                if(abs(arr[i][0] - arr[j][0]) + abs(arr[i][1] - arr[j][1]) <= k)\n                check++;\n            }\n            if(check == n){\n                break;\n            }\n            else{\n                check = 0;\n            }\n        }\n        if(check)\n        cout<<\"1\"<<endl;\n        else\n        cout<<\"-1\"<<endl;\n    }\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;  \npublic class Main \n{\n/*\n    HashMap<> map=new HashMap<>();\n    TreeMap<> map=new TreeMap<>();\n    map.put(p,map.getOrDefault(p,0)+1);\n    for(Map.Entry<> mx:map.entrySet()){\n          int v=mx.getValue(),k=mx.getKey();\n    }\n    ArrayList<Pair<Character,Integer>> l=new ArrayList<>();\n    ArrayList<> l=new ArrayList<>();\n    HashSet<> has=new HashSet<>();*/\n    PrintWriter out;\n    FastReader sc;\n    int mod=(int)(1e9+7);\n    HashSet<Long> h;\n    void find(int l,int r,long[] sum,int[] ar){\n          int mid=strSmall(l,r,ar,(ar[l]+ar[r])/2);\n      //     pl(mid);\n          if((mid)>=r||mid==-1)return;\n          long k=(sum[mid]-sum[l])+ar[l],x=(sum[r]-sum[mid]);\n      //     pl(k+\" \"+x);\n          h.add(k);\n          h.add(x);\n          find(l,mid,sum,ar);\n          find(mid+1,r,sum,ar);\n    }\n    public void sol(){\n          int t=ni();\n          while(t-->0){\n                int n=ni(),k=ni();\n                int[] x=new int[n],y=new int[n];\n                for(int i=0;i<n;i++){\n                      x[i]=ni();y[i]=ni();\n                }boolean f=false;\n                for(int i=0;i<n;i++){\n                      boolean b=false;\n                      for(int j=0;j<n;j++){\n                            if((abs(x[i]-x[j])+abs(y[i]-y[j]))>k){\n                                  b=true;\n                                  break;\n                            }\n                      }if(!b){\n                            f=true;\n                            break;\n                      }\n                }if(f){\n                      pl(\"1\");\n                }else pl(\"-1\");\n          }\n    }\n    public static void main(String[] args) \n\t{ \n\t      Main g=new Main();\n\t\tg.out=new PrintWriter(System.out);\n\t\tg.sc=new FastReader();\n\t\tg.sol();\n\t\tg.out.flush();\n\t}\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n \n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n \n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n \n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n \n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n \n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t} public int ni(){\n\t      return sc.nextInt();\n\t}public long nl(){\n\t      return sc.nextLong();\n\t}public double nd(){\n\t      return sc.nextDouble();\n\t}public char[] rl(){\n\t      return sc.nextLine().toCharArray();\n\t}public String rl1(){\n\t      return sc.nextLine();\n\t}\n\tpublic void pl(Object s){\n\t      out.println(s);\n\t}public void ex(){\n\t      out.println();\n\t}\n\tpublic void pr(Object s){\n\t      out.print(s);\n\t}public String next(){\n\t      return sc.next();\n\t}public long abs(long x){\n\t      return Math.abs(x);\n\t}\n\tpublic int abs(int x){\n\t      return Math.abs(x);\n\t}\n\tpublic double abs(double x){\n\t      return Math.abs(x);\n\t}\n      public long pow(long x,long y){\n            return (long)Math.pow(x,y);\n      }\n      public int pow(int x,int y){\n            return (int)Math.pow(x,y);\n      }\n      public double pow(double x,double y){\n            return Math.pow(x,y);\n      }public long min(long x,long y){\n            return (long)Math.min(x,y);\n      }\n      public int min(int x,int y){\n            return (int)Math.min(x,y);\n      }\n      public double min(double x,double y){\n            return Math.min(x,y);\n      }public static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}static void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(double[] a) {\n\t\tArrayList<Double> l = new ArrayList<>();\n\t\tfor (double i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}int  swap(int a,int b){\n\t      return a;\n\t}long  swap(long a,long b){\n\t      return a;\n\t}double  swap(double a,double b){\n\t      return a;\n\t}\n\tboolean isPowerOfTwo (int x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }boolean isPowerOfTwo (long x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }public long max(long x,long y){\n            return (long)Math.max(x,y);\n      }\n      public int max(int x,int y){\n            return (int)Math.max(x,y);\n      }\n      public double max(double x,double y){\n            return Math.max(x,y);\n      }long sqrt(long x){\n            return (long)Math.sqrt(x);\n      }int sqrt(int x){\n            return (int)Math.sqrt(x);\n      }void input(int[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=ni();\n      }void input(long[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=nl();\n      }int maxint(){\n            return Integer.MAX_VALUE;\n      }int minint(){\n            return Integer.MIN_VALUE;\n      }long maxlong(){\n            return Long.MAX_VALUE;\n      }long minlong(){\n            return Long.MIN_VALUE;\n      }void fill(int[] ar,int k){\n            Arrays.fill(ar,k);\n      }void yes(){\n            pl(\"YES\");\n      }void no(){\n            pl(\"NO\");\n      }\n    int[] sieve(int n) \n    { \n        boolean prime[] = new boolean[n+1]; \n        int[] k=new int[n+1];\n        for(int i=0;i<=n;i++) {\n            prime[i] = true; \n            k[i]=i;\n        }\n          \n        for(int p = 2; p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n               // sieve[p]=p;\n                for(int i = p*2; i <= n; i += p) {\n                    prime[i] = false; \n                  //  sieve[i]=p;\n                    while(k[i]%(p*p)==0){\n                          k[i]/=(p*p);\n                    }\n                }\n            } \n        }return k;\n    }int strSmall(int start,int end,int[] arr, int target)  \n    {  \n      //   int start = 0, end = arr.length-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr[mid] > target) {  \n                end = mid - 1;  \n            }   \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } \n      public static class pair implements Comparable<pair> {\n\t\tint x;\n\t\tint y;\n \n\t\tpublic pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n \n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n \n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof pair) {\n\t\t\t\tpair p = (pair) o;\n\t\t\t\treturn p.x == x && p.y == y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n \n\t\tpublic int hashCode() {\n\t\t\treturn new Double(x).hashCode() * 31 + new Double(y).hashCode();\n\t\t}\n \n\t\tpublic int compareTo(pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(this.y, other.y);\n\t\t\t}\n\t\t\treturn Long.compare(this.x, other.x);\n\t\t}\n      }\n\t \n} "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);\n        int testCases = Integer.parseInt(bufferedReader.readLine());\n        while (testCases > 0){\n            String[] input = bufferedReader.readLine().split(\" \");\n            int noOfBalls = Integer.parseInt(input[0]);\n            int chargePower = Integer.parseInt(input[1]);\n            List<CoordinatePoint> list = new ArrayList<>();\n            for(int i=0;i<noOfBalls;i++){\n                input = bufferedReader.readLine().split(\" \");\n                int x = Integer.parseInt(input[0]);\n                int y = Integer.parseInt(input[1]);\n                list.add(new CoordinatePoint(x,y));\n            }\n            int attRatedNode = 0;\n            boolean solved = false;\n            for(int i=0;i<noOfBalls;i++){\n                CoordinatePoint startPoint = list.get(i);\n                attRatedNode = 0;\n                for(int j=0;j<noOfBalls;j++){\n                    if(i == j){\n                        continue;\n                    } else {\n                        CoordinatePoint destinationNode = list.get(j);\n                        if(Math.abs(startPoint.x - destinationNode.x) + Math.abs(startPoint.y - destinationNode.y) <= chargePower){\n                            attRatedNode++;\n                        }\n                    }\n                }\n                if(attRatedNode == noOfBalls - 1){\n                    solved = true;\n                }\n            }\n            if(solved) System.out.println(1);\n            else System.out.println(-1);\n            testCases--;\n        }\n    }\n\n    static class CoordinatePoint {\n        public int x;\n        public int y;\n        CoordinatePoint(int x,int y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor i in range(t):\n    n,m=map(int,input().split())\n    a=[]\n    for j in range(n):\n        a.append(list(map(int,input().split())))\n    c=0\n    for j in range(n):\n        p=0\n        for k in range(n):\n            if(abs(a[j][0]-a[k][0])+abs(a[j][1]-a[k][1])<=m):\n                p+=1\n        if(p==n):\n            c=1\n    if(c==1):\n        print(\"1\")\n    else:\n        print(\"-1\")\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom bisect import bisect_right\nfrom math import gcd,log\nfrom collections import Counter\nfrom pprint import pprint\nfrom itertools import permutations \n\n\ndef main():\n    n,k=map(int,input().split())\n    # arr=list(map(input().split()))\n    ptr=[]\n    for i in range(n):\n        ptr.append(tuple(map(int,input().split())))\n    for i in range(n):\n        ok=True\n        for j in range(n):\n            if (abs(ptr[i][0]-ptr[j][0])+abs(ptr[i][1]-ptr[j][1])>k):\n                ok=False\n        if (ok):\n            print(1)\n            return \n    print(-1)\n\n\n        \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n\n    for _ in range(int(input())):\n        main()\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nimport sys\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\nINF = 1 << 40\n\n\ndef solve():\n    n, k = map(int, input().split())\n    point = [tuple(map(int, input().split())) for i in range(n)]\n    for i in range(n):\n        px, py = point[i]\n        if all(abs(px - x) + abs(py - y) <= k for (x, y) in point):\n            print(1)\n            return\n    print(-1)\n    return\n\n\ndef main():\n    t = 1\n    t = int(input())\n    for i in range(t):\n        solve()\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class s1\n{\n    public static void main(String []args)\n    {\n        Scanner sc= new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int arr[][]=new int[n][2];\n            for(int i=0;i<n;i++)\n            {\n                arr[i][0]=sc.nextInt();\n                arr[i][1]=sc.nextInt();\n            }\n            int count=0,found=0;\n            for(int i=0;i<n;i++)\n            {\n                count=0;\n                for(int j=0;j<n;j++)\n                {\n                    if(Math.abs(arr[i][0]-arr[j][0])+Math.abs(arr[i][1]-arr[j][1])<=k)\n                    count++;\n                }\n                if(count==n)\n                {\n                    found=1;\n                    break;\n                }\n            }\n            if(found==1)\n            System.out.println(1);\n            else \n            System.out.println(-1);\n           \n        }\n    }\n}\n//Code Contributed By Anonymous Guy"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define PF push_front\n#define MK make_pair\n#define MT make_tuple\n#define REP(i, a, b) for (int i = a; i <= b; i++)\n#define MOD 1000000007\n#define DEB(x) cout << #x << \"=\" << x << endl\n#define DEB2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int T = 1, n, k;\n  cin >> T;\n  while (T--) {\n    cin >> n >> k;\n    int X[n], Y[n];\n    REP(i, 0, n - 1) { cin >> X[i] >> Y[i]; }\n    bool anypos = false;\n    REP(i, 0, n - 1) {\n      bool ispos = true;\n      REP(j, 0, n - 1) {\n        if (abs(X[i] - X[j]) + abs(Y[i] - Y[j]) > k) {\n          ispos = false;\n          break;\n        }\n      }\n      if (ispos) {\n        cout << 1 << endl;\n        anypos = true;\n        break;\n      }\n    }\n    if (!anypos)\n      cout << -1 << endl;\n  }\n\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.*;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.math.*;\npublic class Main\n{\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static class Data implements Comparable<Data> {\n        int x;\n        int y;\n\n        public Data(int m, int n) {\n            x = m;\n            y = n;\n\n        }\n\n        @Override\n        public int compareTo(Data o) {\n\n            return o.y-y;\n        }\n    }\n\n    public static void main(String args[])\n    {\n        FastReader sc=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            ArrayList<Data> l = new ArrayList<>();\n            for(int i=0;i<n;i++)\n            {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                l.add(new Data(a,b));\n            }\n\n            long max = 0;\n\n            boolean f = true;\n            boolean can = false;\n\n       o:     for(int i=0;i<l.size();i++)\n            {\n                int c = 0;\n                for(int j=0;j<l.size();j++)\n                {\n                    max = Math.abs((long)l.get(i).x-l.get(j).x)+Math.abs((long)l.get(i).y-l.get(j).y);\n                    if(max<=k) {\n                      c++;\n                    }\n                }\n\n                if(c==l.size())\n                {\n                    can = true;\n                    break o;\n                }\n            }\n            if(can)\n                pw.println(1);\n            else\n                pw.println(-1);\n        }\n        pw.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "t = int(input())\n\nwhile (t):\n\n\tn,k = list(map(int,input().split()))\n\ta = []\n\n\tfor i in range(n):\n\t\tx,y = list(map(int,input().split()))\n\t\ta.append((x,y))\n\n\tflag = False\n\n\tfor i in range(n):\n\t\ttmp = set([(1 if abs(a[j][0]-a[i][0])+abs(a[j][1]-a[i][1]) <= k else 0) for j in range(n)])\n\t\tif (0 not in tmp):\n\t\t\tflag = True\n\t\t\tbreak\n\n\tif (flag):\n\t\tprint(1)\n\telse:\n\t\tprint(-1)\n\n\tt -= 1"
        },
        {
            "language": 3,
            "solution": "# cook your dish here\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    y=0\n    c,d=[],[]\n    for i in range(n):\n        a,b=map(int,input().split())\n        c.append(a)\n        d.append(b)\n    for i in range(n):\n        x=0\n        for j in range(n):\n            if abs(c[i]-c[j])+abs(d[i]-d[j])<=k:\n                x=x+1\n        if x>y:\n            y=x\n    if y==n:\n        print(1)\n    else:\n        print(-1)\n                \n            "
        },
        {
            "language": 4,
            "solution": "//package code;\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class c \n{\n    public static int t,Dx ,Dy ,J,count,n,len=100005,answer,k,x,r,m,phi[],mask ,a[],tin[],tout[],discover[],time=0, b[],degree[],parent[][] , parent1[] , size[] ,mat[][] , depth[],pre[],blockSize;\n    static long  mod=(long)(1e9) + 7 ,sum,mini ,mod1=(long)(998244353),bit[],ans , dp[][] ,Bit[];\n    static int[] dx={-1, 1,0,0} , dy={0 ,0 , -1 ,1} , dx8={-1,0,1} , dy8={-1,0,1};\n\n    static boolean visited[],isPandatic[] ;\n    public static TreeSet<Integer> ts[];\n    public static ArrayList<Integer> list ,adj[] ,divisor[];\n    public static PrintWriter pw;\n    public static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    public static int max1=2000005;\n    //public static String[] s;\n    public static void main(String[] args){\n        new Thread(null,null,\"Prabhat Kumar Prajapati\",1<<17)\n        {\n           public void run() \n           {\n               try\n               {\n                   solve();\n               }\n               catch(Exception e)\n               {   \n                   e.printStackTrace();\n                   System.exit(1);\n               }\n           }\n        }.start();\n    }\nstatic class Pair{\n  int x,y;\n  Pair(int v , int w){\n    this.x=v;\n    this.y=w;\n  }\n}\n\npublic static void solve()throws IOException\n{\n  pw = new PrintWriter(System.out);\n  Scanner sc=new Scanner(System.in);\n  t=sc.nextInt();\n  while(t-->0){\n    n=sc.nextInt();\n    k=sc.nextInt();\n    Pair[] pair=new Pair[n];\n    for(int i=0;i<n;i++){\n      pair[i]=new Pair(sc.nextInt() , sc.nextInt());\n    }\n    int ans=-1;\n    for(int i=0;i<n;i++){\n      int cnt=0;\n      for(int j=0;j<n;j++){\n        if(i==j)continue;\n        if(manHattanDist(pair[i] , pair[j])<=k){\n          cnt++;\n        }\n      }\n      if(cnt==n-1){\n        ans=1;\n        break;\n      }\n    }\n    pw.println(ans);\n  }\n  pw.close();\n}\nstatic int manHattanDist(Pair p1 , Pair p2){\n  return Math.abs(p1.x-p2.x)+Math.abs(p1.y-p2.y);\n}\n\nstatic long rangeSum(int l , int r){\n  return query(r)-query(l-1);\n}\nstatic void add(int index , long val){\n  while(index<=n){\n    Bit[index]+=val;\n    index+=(index&(-index));\n  }\n}\nstatic long query(int index){\n  long sum=0;\n  while(index>0){\n    sum+=Bit[index];\n    index-=(index&(-index));\n  }\n  return sum;\n}\n\n\n//(n-k+1)=(n-i) and i<k\n// n*(n-1)*(n-2)*(n-3)...(n-k+1)\n//-------------------------------\n//k*(k-1)*(k-2)*(k-3).....1\n\npublic static long nCk(long n,long k,long mod){\n  if(k>n-k)k = n-k;\n\n  long res = 1;\n  for(long i=0;i<k;i++){\n        res = (res*(n-i))%mod1;\n        res = res*(pow(i+1,mod1-2,mod1))%mod1;  // inverse \n            \n    }\n  return res;\n}\npublic static void dfs1(int cur , int par){\n  //tin[cur]=time++;\n  // parent[cur][0]=par==-1?0:par;\n  // for(int i=1;i<28;i++)parent[cur][i]=parent[parent[cur][i-1]][i-1];\n\n  for(int ver:adj[cur]){\n    if(ver==par)continue;\n    parent1[ver]=cur;\n    depth[ver]=depth[cur]+1;\n    dfs1(ver,cur);\n  }\n // tout[cur]=time-1;\n}\npublic  static boolean isParent(int u ,int v){\n  return tin[u]<=tin[v]&&tout[u]>=tout[v];\n}\npublic  static int lca(int u , int v){\n  if(isParent(u,v))return u;\n  if(isParent(v,u))return v;\n\n  for(int i=27;i>=0;i--){\n    if(!isParent(parent[u][i],v)){\n      u=parent[u][i];\n    }\n  }\n  return parent[u][0];\n}\n\n// here ans will store number of nodes on longest path\n// static int dfs(int cur){\n//     int d1=0;\n//     int d2=0;\n//     visited[cur]=true;\n//     for(int ver:adj[cur]){\n//         if(visited[ver])continue;\n//         int x=dfs(ver);\n//         if(x>d1){\n//             d2=d1;\n//             d1=x;\n//         }\n//         else if(x>d2){\n//             d2=x;\n//         }\n//         ans=Math.max(ans , d1+d2+1);\n//     }\n//     //pw.println((cur+1)  +\" \"+d1+\" \"+d2);\n//     return d1+1;\n// }\npublic static long pow(long n,long p,long m)\n{\n    long  result = 1;\n    while(p>0)\n    {\n        if(p%2==1)\n            result =result * n %m;\n        p >>=1;\n        n=n*n % m;   \n    }\n    return result;\n}\n\n}\n"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\n \nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef main():\n    pass\n \n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nt=int(input())\nwhile t:\n\tt-=1\n\tn,k=map(int,input().split())\n\tarr=[]\n\tfor i in range(n):\n\t\tarr.append(list(map(int,input().split())))\n\n\t\n\tfor i in range(n):\n\t\tcheck=True\n\t\tx,y=arr[i]\n\t\tfor j in range(n):\n\t\t\tdist=abs(x-arr[j][0])+abs(y-arr[j][1])\n\t\t\tif dist>k:\n\t\t\t\t\n\t\t\t\tcheck=False\n\t\t\t\tbreak\n\t\tif check:\n\n\t\t\tbreak\n\tif check:\n\t\tprint(1)\n\telse:\n\t\tprint(-1)\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n, k = map(int, sys.stdin.readline().split())\n\n    points = []\n    for _ in range(n):\n        points.append(list(map(int, sys.stdin.readline().split())))\n\n    found = False\n    for point1 in points:\n        good = True\n\n        for point2 in points:\n            dist = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n            if dist > k:\n                good = False\n                break\n\n        if good:\n            found = True\n            break\n\n    print(1 if found else -1)"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    n,k=map(int,input().split())\n    l=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        l.append([x,y])\n    c=0\n    q=0\n    for i in range(n):\n        c=0\n        for j in range(n):\n            if abs(l[i][0]-l[j][0])+abs(l[i][1]-l[j][1])<=k:\n               c+=1 \n            else:\n                break\n        if c==n:\n            q+=1\n            print(1)\n            break\n    if q==0:\n        print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define INF 2000000000\n#define MOD 1000000007\n#define MAXN 200005\n#define REP(temp, init_val, end_val) for (int temp = init_val; temp <= end_val; ++temp)\n#define REPR(temp, init_val, end_val) for (int temp = init_val; temp >= end_val; --temp)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> intpair;\nint read(){\n    int f = 1, x = 0;\n    char c = getchar();\n    while (c < '0' || c > '9'){if(c == '-') f = -f; c = getchar();}\n    while (c >= '0' && c <= '9')x = x * 10 + c - '0', c = getchar();\n    return f * x; \n}\ninline int lowbit(int x){\n    return x & (-x);\n}\ninline int modadd(int x, int y){\n    return (x + y >= MOD ? x + y - MOD: x + y);\n}\ninline int sgn(int x){\n    return (x < 0 ? -1: (x > 0 ? 1: 0));\n}\ntemplate<typename T>\nT gcd(T a, T b){\n    return (!b) ? a: gcd(b, a % b);\n}\nint poww(int a, int b){\n    int res = 1;\n    while (b > 0){\n        if (b & 1) res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, b >>= 1;\n    }\n    return res;\n}\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int ddx[] = {-1, -1, -1, 0, 0, 1, 1, 1}, ddy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n/*--------------------------------------------------------------------*/\n/*--------------------------------------------------------------------*/\n\nint n, k, x[105], y[105];\nvoid init(){\n    n = read(), k = read();\n    REP(i, 1 , n) x[i] = read(), y[i] = read();\n}\nvoid solve(){\n    REP(i, 1, n){\n        bool flag = true;\n        REP(j, 1 ,n){\n            if (abs(x[i] - x[j]) + abs(y[i] - y[j]) > k){flag = false;break;\n            }\n        }\n        if(flag){printf(\"1\\n\"); return ;}\n    }\n    printf(\"-1\\n\");\n}\nint main(){\n    int T = read();\n    while (T--){\n        init();\n        solve();\n    }\n    return 0;\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer; \nimport java.util.*;\nimport java.math.*;\npublic class Main \n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader()\n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next()\n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine();\n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n     public static void main (String[] args) throws java.lang.Exception {\n        FastReader sc=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n           int n=sc.nextInt(),k=sc.nextInt(),ct=0;\n           List<Integer> l=new ArrayList<>();\n           long a[][]=new long[n][2],sum=0,ans=0;String s=\"\";\n           for(int i=0;i<n;i++) \n           {\n               for(int j=0;j<2;j++) a[i][j]=sc.nextLong();\n           }\n           for(int i=0;i<n;i++)\n           {\n             ct=0;\n             for(int j=0;j<n;j++)\n             {    \n            if(Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1])>k)\n             {\n                 ct=1;break;\n             }\n             }\n             if(ct==0) {ans=1;break;}  \n           }\n           if(ans==1)\n           pw.println(1);\n           else pw.println(-1);\n        }\n    pw.close();\n    }\n}\n  "
        },
        {
            "language": 3,
            "solution": "import sys\n\n\n# def BFS(pathMap):\n#     q = {0}\n#     visited = [False for i in range(len(pathMap))]\n\n#     while True:\n#         if not q:\n#             break\n#         node = q.pop()\n#         visited[node] = True\n#         childs = {i for i in range(len(pathMap)) if not visited[i] and pathMap[node][i]}\n#         q.update(childs)\n\n#     return all(visited)\n\n\nT = int(input())\n\nfor t in range(T):\n    n, k = list(map(int, sys.stdin.readline().split()))\n    \n    points = []\n    pathMap = [[False for i in range(n)] for j in range(n)]\n\n    for p in range(n):\n        x, y = list(map(int, sys.stdin.readline().split()))\n        points.append((x, y))\n\n    for i in range(n):\n        ok = True\n        pathMap[i][i] = True\n        for j in range(i+1, n):\n            if abs(points[i][0] - points[j][0]) +  abs(points[i][1] - points[j][1]) <= k:\n                pathMap[i][j] = True\n                pathMap[j][i] = True\n\n        if not any(pathMap[i]):\n            ok = False\n            break\n\n    # for i in range(n):\n    #     print(pathMap[i])\n\n    if not ok:\n        print(-1)\n    else:\n        ok = False\n        for i in range(n):\n            if all(pathMap[i]):\n                ok = True\n                break\n        \n        print('{}'.format(1 if ok else -1))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t,n,k,i,j,flag,x;\n    cin>>t;\n    while(t--)\n    {   \n        flag=1;\n        cin>>n>>k;\n        pair<int,int> a[n];\n        for(i=0;i<n;i++)\n        {\n            cin>>a[i].first>>a[i].second;\n        }\n        x=-1;\n        for(i=0;i<n;i++)\n        {   \n            flag=1;\n            for(j=0;j<n;j++)\n            {\n               if((abs(a[i].first - a[j].first) + abs(a[i].second - a[j].second))>k)\n                {flag=-1;\n                break;\n                }\n            }\n            if(flag==1)\n            {x=0;\n            break;\n            }\n        }\n       (x==0)?cout<<1<<endl:cout<<-1<<endl;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    n,k=map(int,input().split())\n    l=[]\n    t=-1\n    for i in range(n):\n        x,y=map(int,input().split())\n        l.append([x,y])\n    for i in l:\n        q=0\n        for j in l:\n            if abs(i[1]-j[1])+abs(i[0]-j[0])<=k:q+=1\n            else:break\n        if q==n:t=1\n    print(t)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class solution {\n    static class Node {\n        int x;\n        int y;\n\n        Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner obj = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int length = obj.nextInt();\n        while (length-- != 0) {\n            int n = obj.nextInt();\n            int k = obj.nextInt();\n            Vector<Node> v = new Vector<>();\n            for (int i = 0; i < n; i++) {\n                int ch = obj.nextInt();\n                int c = obj.nextInt();\n                v.add(new Node(ch, c));\n            }\n            int flag = 1;\n            for (int i = 0; i < n; i++) {\n                flag = 0;\n                for (int j = 0; j < n; j++) {\n                    int result = Math.abs(v.get(i).x - v.get(j).x) + Math.abs(v.get(i).y - v.get(j).y);\n                    if (result > k) {\n                        flag = 1;\n                        break;\n                    }\n                }\n                if (flag == 0) break;\n            }\n            if (flag == 0) System.out.println(1);\n            else System.out.println(-1);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\tboolean found = false;\n\t\tfor (int i = 0; i < n && !found; i++) {\n\t\t\tfound = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (Math.abs(x[i] - x[j]) + Math.abs(y[i] - y[j]) > k) {\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tout.println(found ? 1 : -1);\n\t}\n\n\tvoid run() {\n\t\tint t = in.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tsolve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.ENGLISH);\n\n\t\tnew Main().run();\n\n\t}\n\n\tFastReader in = new FastReader(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastReader(InputStream ist) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(ist));\n\t\t}\n\n\t\tprivate void fixTokenizer() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\tfixTokenizer();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tfixTokenizer();\n\t\t\treturn st.nextToken(\"\\n\");\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class balls\n{\n    public static void main(String[] args) {\n        sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        for (int x = 0; x < t; ++x) {\n            int n = sc.nextInt(); int k = sc.nextInt();\n            int pos[][] = new int[n][2];\n            for (int i = 0; i < n; ++i) {\n                pos[i][0] = sc.nextInt();\n                pos[i][1] = sc.nextInt();\n            }\n            boolean possible = false;\n            for (int i = 0; i < n && !possible; ++i) {\n                int j = 0;\n                for ( ; j < n; ++j) {\n                    if (Math.abs(pos[i][0] - pos[j][0]) + Math.abs(pos[i][1] - pos[j][1]) > k)\n                        break;\n                }\n                if (j == n)\n                    possible = true;\n            }\n            if (possible)\n                out.println(1);\n            else \n                out.println(-1);\n        }\n        out.close();\n    }\n    public static void scan(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = sc.nextInt();\n        }\n    }\n \n    public static MyScanner sc;\n    public static PrintWriter out;\n \n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class p1450B{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n    T:  for(int t=sc.nextInt();t-->0;) {\n            int n=sc.nextInt(),k=sc.nextInt(),i=n;\n            pair [] p=new pair[n];\n            while(i-->0) p[i]=new pair(sc.nextInt(),sc.nextInt());\n        L:  while(++i<n){\n                for(int j=0;j<n;j++)\n                    if(Math.abs(p[i].x-p[j].x)+Math.abs(p[i].y-p[j].y)>k) continue L;\n                System.out.println(1);\n                continue T;\n            }System.out.println(-1);\n        }\n    }\n    static class pair{\n        int x,y;\n        public pair(int a,int b) {\n            x=a;y=b;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n        test: for (int g = 0; g < t; g++) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n\n            int[][] a = new int[n][2];\n\n            for (int i = 0; i < n; i++) {\n                a[i][0] = in.nextInt();\n                a[i][1] = in.nextInt();\n            }\n\n            Map<Integer, ArrayList<Integer>> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                if(!map.containsKey(i)) {\n                    map.put(i, new ArrayList<>());\n                }\n                ArrayList<Integer> edgeList = new ArrayList<>();\n                for (int j = i+1; j < n; j++) {\n                    if(!map.containsKey(j)) {\n                        map.put(j, new ArrayList<>());\n                    }\n                    int d = dist(a[i], a[j]);\n                    if(d <= k){\n                        map.get(i).add(j);\n                        map.get(j).add(i);\n                    }\n                }\n\n                if(map.get(i).size() == n-1){\n                    out.println(1);\n                    continue test;\n                }\n            }\n\n\n            out.println(-1);\n        }\n\n\n        out.flush();\n    }\n\n\n    static int dist(int[] a, int[] b){\n        return Math.abs(a[0] - b[0]) + Math.abs(b[1] - a[1]);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nint x[110];\nint y[110];\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n,k;\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\t}\n\t\tint f=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint c=1;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(i==j) continue ;\n\t\t\t\tif(abs(x[i]-x[j])+abs(y[i]-y[j])<=k) c++;\n\t\t\t}\n\t\t\tif(c==n) {\n\t\t\t\tf=1;break;\n\t\t\t}\n\t\t}\n\t\tif(f) printf(\"1\\n\");\n\t\telse printf(\"-1\\n\");\n\t} \n} "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B_Balls_of_Steel\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    \n    public static void main(String args[])\n    {\n        FastReader sc=new FastReader();\n                \n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int a[][]=new int[n][2];\n            for(int i=0;i<n;i++)\n            {\n                a[i][0]=sc.nextInt();\n                a[i][1]=sc.nextInt();\n\n            }\n            boolean ch=false;\n            for(int i=0;i<n;i++)\n            {\n                boolean ch1=true;\n                for(int j=0;j<n;j++)\n                {\n                    int kk=Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1]);\n                    if(kk>k)\n                    {\n                        ch1=false;\n                        break;\n                    }\n                }\n                if(ch1)\n                {\n                    ch=true;\n                    break;\n                }\n\n            }\n           if(ch) System.out.println(1);\n           else System.out.println(-1);\n        }\n\n    }\n}\n\n\n\n\n\n       \n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n\t//static int [] arr;\n\t//static boolean prime[] = new boolean[1000]; \n\t//static List<Long> al = new ArrayList<>();\n\t//static int l;\n\t//static String s; static StringBuilder sb;\n\t//static HashSet<L> hs;\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = sc.nextInt();\n        //int t = 1;\\\n        // sieve(600);\n        while (t-->0) {\n        \tint n = sc.nextInt();\n        \tint k = sc.nextInt();\n        \tint [] x = new int [n];\n        \tint [] y = new int [n];\n        \tfor(int i = 0 ; i < n ; i++) {\n        \t\tx[i] = sc.nextInt(); y[i] = sc.nextInt();\n        \t}\n        \tint ans = -1;\n        \tfor(int i = 0 ; i < n ; i++) {\n        \t\tboolean flag = true;\n        \t\tfor(int j = 0 ; j < n ; j++) \n        \t\t\tif(Math.abs(x[i]-x[j]) + Math.abs(y[i]-y[j])>k)\n        \t\t\t\tflag = false;\n        \t\tif(flag)\n        \t\t\tans = 1;\n        \t}\n\n        \tout.println(ans);\n\n\n        \t\n        \t\n        \n    }\n        out.close();\n    }\n//    public static int solve(int arr[] , int n , int x) {\n//    \tif(isSorted(arr))\n//    \t\treturn 0;\n//    \tint count = 0;\n//    \tfor(int i = 0 ; i < n ; i++) {\n//    \t\tfor(int j = 0 ; j < n ; j++) {\n//    \t\t\tif(x<arr[i]) {\n//    \t\t\t\tint temp = arr[i];\n//    \t\t\t\tarr[i] = x;\n//    \t\t\t\tx = temp;\n//    \t\t\t\tcount++;\n//    \t\t\t\tif(isSorted(arr))\n//    \t\t\t\t\treturn count;\n//    \t\t\t}\n//    \t\t}\n//    \t}\n//    \treturn -1;\n//    }\n//    public static boolean isSorted (int [] arr) {\n//    \tfor(int i = 0 ; i < arr.length -1 ; i++)\n//    \t\tif(arr[i]>arr[i+1])\n//    \t\t\treturn false;\n//    \treturn true;\n//    }\n\n     \n\n\n        \n\n    }\n\n//    static void findsubsequences(String s, String ans){\n//    \tif (s.length() == 0) {\n//    \t\tif(ans!=\"\")\n//    \t\t\tif(ans.length()!=l)\n//    \t\t\tal.add(Long.parseLong(ans));\n//    \t\treturn;\n//\t}\n//\n//\t\t// We add adding 1st character in string\n//\t\tfindsubsequences(s.substring(1), ans + s.charAt(0));\n//\t\t\n//\t\t// Not adding first character of the string\n//\t\t// because the concept of subsequence either\n//\t\t// character will present or not\n//\t\tfindsubsequences(s.substring(1), ans);\n//}\n    \n\n    \n\n    \n//    static void sieve(int n) \n//    { \n//        // Create a boolean array \"prime[0..n]\" and initialize \n//        // all entries it as true. A value in prime[i] will \n//        // finally be false if i is Not a prime, else true. \n//        \n//        for(int i=0;i<n;i++) \n//            prime[i] = true; \n//          \n//        for(int p = 2; p*p <=n; p++) \n//        { \n//            // If prime[p] is not changed, then it is a prime \n//            if(prime[p] == true) \n//            { \n//                // Update all multiples of p \n//                for(int i = p*p; i <= n; i += p) \n//                    prime[i] = false; \n//            } \n//        } \n//    }\n //Print all prime numbers \n//        for(int i = 2; i <= n; i++) \n//        { \n//            if(prime[i] == true) \n//                System.out.print(i + \" \"); \n//        } \n    \n\n \n\n    \n\n\tclass Pair  implements Comparable <Pair>{\n\t\tint a ;\n\t\tint b ;\n\t\tpublic Pair(int a , int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn this.a-o.a;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"( \" + this.a + \" , \" + this.b + \" )\\n\";\n\t\t}\n\t\t\n\t}\n\n\t\n\t\n\t\n\t\n\t class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic int[][] nextInt2DArr(int l, int w) throws IOException {\n\t\t\tint [][] arr = new int[l][w];\n\t\t\tfor(int i = 0 ; i < l ; i++)\n\t\t\t\tfor(int j = 0 ; j<w ; j++)\n\t\t\t\tarr[i][j]= Integer.parseInt(next());\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArr(int length) throws IOException {\n\t\t\tint[] arr = new int[length];\n\t\t\tfor(int i = 0 ; i < length ; i++)\n\t\t\t\tarr[i] = Integer.parseInt(next());\n\t\t\treturn arr;\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t }\n\t"
        },
        {
            "language": 2,
            "solution": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <tuple>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <random>\n#include <set>\n#include <stack>\n#include <time.h>\n#include <unordered_map>\n\n//#include <bits/stdc++.h>\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define FOR(i,i0,n) for(int (i)=(i0);(i)<(n);(i)++)\n#define FORR(i,i0,n) for(int (i)=(n)-1; (i)>=(i0);(i)--)\n#define SORT(x) sort(x.begin(),x.end())\n#define SORTR(x) sort(x.begin(),x.end(),greater<int>())\n\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n\nusing namespace std;\nusing ll = long long;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<int, double> pid;\ntypedef std::vector<int> vi;\ntypedef std::vector<pii> vii;\n\nconst double PI = 3.14159265358979323846264338327950L;\nconst int mod = 1000000007;\nconst int INF = 1001001001;\n\nstruct container{\n    int bottom, top, id;\n    container(int id, int bottom, int top): top(top), bottom(bottom),id(id){\n    }\n};\n\n\nstruct Data {\n    int ind;\n    ll time;\n    Data(int ind,ll time): ind(ind),time(time){}\n    bool operator<(const Data& a) const {\n    return time > a.time;\n    }\n};\n\n\n\n\nvoid solve(){\n    int n,k;\n    cin >> n >> k;\n    \n    vector<vector<int>> p;\n    \n    rep(i,n){\n        int x,y;\n        \n        cin >> x >> y;\n        \n        p.pb({x,y});\n    }\n    \n    \n    rep(i,n){\n        int ok = 1;\n        rep(j,n){\n            if (abs(p[i][0]-p[j][0]) + abs(p[i][1]-p[j][1]) > k){\n                ok = 0;\n            }\n        }\n        if (ok==0) continue;\n        \n        cout << 1;\n        return;\n    }\n    \n    \n    \n    cout << -1;\n    \n}\n\n\n\n\n\n\n\nint main() {\n    int T = 1;\n    cin >> T;\n\n    while (T--){\n        solve();\n        cout << endl;\n\n    }\n}\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SolutionB extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        new Thread(null, new SolutionB(), \"Main\", 1 << 26).start();\n    }\n\n    public void run() {\n        int t = scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve();\n        }\n        out.close();\n    }\n\n    static class Point {\n        int x;\n        int y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        Point[] points = new Point[n];\n\n        for (int i = 0; i < n; i++) {\n            int xi = scanner.nextInt();\n            int yi = scanner.nextInt();\n            points[i] = new Point(xi, yi);\n        }\n\n        for (int i = 0; i < n; i++) {\n            boolean allSuckedIn = true;\n            for (int j = 0; j < n; j++) {\n                if (Math.abs(points[i].x - points[j].x) + Math.abs(points[i].y - points[j].y) > k) {\n                    allSuckedIn = false;\n                    break;\n                }\n            }\n\n            if (allSuckedIn) {\n                System.out.println(\"1\");\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n\n    //REMINDERS:\n    //- CHECK FOR INTEGER-OVERFLOW BEFORE SUBMITTING\n\n    //- CAN U BRUTEFORCE OVER SOMETHING, TO MAKE IT EASIER TO CALCULATE THE SOLUTION\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class CodeForces1450B{\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint t = input.nextInt();\n\t\tfor(int l = 0;l<t;l++){\n\t\t\tint n = input.nextInt();\n\t\t\tint k = input.nextInt();\n\t\t\tint[][] a = new int[n][2];\n\t\t\tfor(int j = 0;j<n;j++){\n\t\t\t\ta[j][0] = input.nextInt();\n\t\t\t\ta[j][1] = input.nextInt();\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\tboolean bool = true;\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\tbool = true;\n\t\t\t\tfor(int j = 0;j<n;j++){\n\t\t\t\t\tif(Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1]) > k){\n\t\t\t\t\t\tbool = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bool){\n\t\t\t\t\tans = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class AvoidTrygub {\n    public static void main(String[] args) throws IOException {\n        // InputStream inputStream = new FileInputStream(\"input.txt\");\n        // OutputStream outputStream = new FileOutputStream(\"output.txt\");\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(in.nextInt(), in, out);\n        out.close();\n    }\n    static class TaskA {\n        long mod = (long)(1e9) + 7;\n        long fact[];\n        int depth[];\n        int parentTable[][];\n        int degree[];\n        ArrayList<Integer> leaves;\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        int diam = 0;\n\n        int res = 0;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) throws IOException {\n            while(testNumber-->0){\n                int n = in.nextInt();\n                int k = in.nextInt();\n                int a[][] = new int[n][n];\n                for(int i=0;i<n;i++){\n                    int x = in.nextInt();\n                    int y = in.nextInt();\n                    a[i] = new int[]{x , y};\n                }\n                int ans = -1;\n                for(int i=0;i<n;i++){\n                    int count = 0;\n                    for(int j=0;j<n;j++){\n                        if(abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]) <= k)\n                            count++;\n                    }\n                    if(count == n)\n                        ans = 1;\n                }\n                out.println(ans);\n            }\n        }\n\n        class Sort implements Comparator<int[]>{\n        \tpublic int compare(int a[] , int b[]){\n        \t\treturn a[0]+a[1] - b[0] - b[1];\n        \t}\n        }\n\n        public int lower(ArrayList<Integer> a , int x){\n            if(a.size() == 0)\n                return 0;\n            if(a.get(a.size()-1) < x)\n                return a.size();\n            int l = 0;\n            int r = a.size()-1;\n            while(l<=r){\n                int mid = (l+r)>>1;\n                if(a.get(mid)>=x && (mid<1 || a.get(mid-1)<x))\n                    return mid;\n                else if(a.get(mid) < x)\n                    l = mid+1;\n                else\n                    r = mid-1;\n            }\n            return -1;\n        }\n\n        public int distance(ArrayList<ArrayList<Integer>> a , int u , int v){\n            return depth[u]+depth[v] - 2*depth[lca(a , u , v)];\n        }\n\n        public int lca(ArrayList<ArrayList<Integer>> a , int u , int v){\n            if(depth[v]<depth[u]){\n                int x = u;\n                u = v;\n                v = x;\n            }\n            int diff = depth[v] - depth[u];\n            for(int i=0;i<parentTable[v].length;i++){\n                // checking whether the ith bit is set in the diff variable\n                if(((diff>>i)&1) == 1)\n                    v = parentTable[v][i];\n            }\n            if(v == u)\n                return v;\n            for(int i=parentTable[v].length-1;i>=0;i--){\n                if(parentTable[u][i] != parentTable[v][i]){\n                    v = parentTable[v][i];\n                    u = parentTable[u][i];\n                }\n            }\n            return parentTable[u][0];\n        }\n        \n\n        public int[][] multiply(int a[][] , int b[][]){\n            int c[][] = new int[a.length][b[0].length];\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<b[0].length;j++){\n                    for(int k=0;k<b.length;k++)\n                        c[i][j] += a[i][k]*b[k][j];\n                }\n            }\n            return c;\n        }\n\n        public int[][] multiply(int a[][] , int b[][] , int mod){\n            int c[][] = new int[a.length][b[0].length];\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<b[0].length;j++){\n                    for(int k=0;k<b.length;k++){\n                        c[i][j] += a[i][k]*b[k][j];\n                        c[i][j]%=mod;\n                    }\n                }\n            }\n            return c;\n        }\n\n        public int[][] pow(int a[][] , long b){\n            int res[][] = new int[a.length][a[0].length];\n            for(int i=0;i<a.length;i++)\n                res[i][i] = 1;\n            while(b>0){\n                if((b&1) == 1)\n                    res = multiply(res , a , 10);\n                a = multiply(a , a , 10);\n                b>>=1;\n            }\n            return res;\n        }\n\n        \n\n        // for the min max problems\n        public void build(int lookup[][] , int arr[], int n) { \n            for (int i = 0; i < n; i++) \n                lookup[i][0] = arr[i]; \n            for (int j = 1; (1 << j) <= n; j++) { \n                for (int i = 0; (i + (1 << j) - 1) < n; i++) { \n                    if (lookup[i][j - 1] > lookup[i + (1 << (j - 1))][j - 1]) \n                        lookup[i][j] = lookup[i][j - 1]; \n                    else\n                        lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1]; \n                } \n            } \n        }\n        public int query(int lookup[][] , int L, int R) { \n            int j = (int)(Math.log(R - L + 1)/Math.log(2)); \n            if (lookup[L][j] >= lookup[R - (1 << j) + 1][j]) \n                return lookup[L][j]; \n            else\n                return lookup[R - (1 << j) + 1][j]; \n        }\n\n        // for printing purposes\n        public void print1d(int a[] , PrintWriter out){\n            for(int i=0;i<a.length;i++)\n                out.print(a[i] + \" \");\n            out.println();\n        }\n        public void print1d(long a[] , PrintWriter out){\n            for(int i=0;i<a.length;i++)\n                out.print(a[i] + \" \");\n            out.println();\n        }\n        public void print2d(int a[][] , PrintWriter out){\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<a[i].length;j++)\n                    out.print(a[i][j] + \" \");\n                out.println();\n            }\n            // out.println();\n        }\n        public void print2d(long a[][] , PrintWriter out){\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<a[i].length;j++)\n                    out.print(a[i][j] + \" \");\n                out.println();\n            }\n            // out.println();\n        }\n\n\n        public void sieve(int a[]){\n            a[0] = a[1] = 1;\n            int i;\n            for(i=2;i*i<=a.length;i++){\n                if(a[i] != 0)\n                    continue;\n                a[i] = i;\n                for(int k = (i)*(i);k<a.length;k+=i){\n                    if(a[k] != 0)\n                        continue;\n                    a[k] = i;\n                }\n            }\n        }\n\n        public long nCrPFermet(int n , int r , long p){\n            if(r==0)\n                return 1l;\n            // long fact[] = new long[n+1];\n            // fact[0] = 1;\n            // for(int i=1;i<=n;i++)\n            //     fact[i] = (i*fact[i-1])%p;\n            long modInverseR = pow(fact[r] , p-2 , p);\n            long modInverseNR = pow(fact[n-r] , p-2 , p);\n            long w = (((fact[n]*modInverseR)%p)*modInverseNR)%p;\n            return w;\n        }\n        public long pow(long a, long b, long m) {\n            a %= m;\n            long res = 1;\n            while (b > 0) {\n                long x = b&1;\n                if (x == 1)\n                    res = res * a % m;\n                a = a * a % m;\n                b >>= 1;\n            }\n            return res;\n        }\n        public long pow(long a, long b) {\n            long res = 1;\n            while (b > 0) {\n                long x = b&1;\n                if (x == 1)\n                    res = res * a;\n                a = a * a;\n                b >>= 1;\n            }\n            return res;\n        }\n        public void sortedArrayToBST(TreeSet<Integer> a , int start, int end) { \n            if (start > end) {\n                return;\n            }\n            int mid = (start + end) / 2;\n            a.add(mid);\n            sortedArrayToBST(a, start, mid - 1);\n            sortedArrayToBST(a, mid + 1, end); \n        }\n        class Combine{\n            int value;\n            int delete;\n            Combine(int val , int delete){\n                this.value = val;\n                this.delete = delete;\n            }\n        }\n        class Sort2 implements Comparator<Combine>{\n            public int compare(Combine a , Combine b){\n                if(a.value > b.value)\n                    return 1;\n                else if(a.value == b.value && a.delete>b.delete)\n                    return 1;\n                else if(a.value == b.value && a.delete == b.delete)\n                    return 0;\n                return -1;\n            }\n        }\n        public int lowerLastBound(ArrayList<Integer> a , int x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>=x)\n                return -1;\n            if(a.get(r)<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid-1)<x)\n                    return mid-1;\n                else if(a.get(mid)>=x)\n                    r = mid-1;\n                else if(a.get(mid)<x && a.get(mid+1)>=x)\n                    return mid;\n                else if(a.get(mid)<x && a.get(mid+1)<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(ArrayList<Integer> a , int x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>x)\n                return l;\n            if(a.get(r)<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid+1)>x)\n                    return mid+1;\n                else if(a.get(mid)<=x)\n                    l = mid+1;\n                else if(a.get(mid)>x && a.get(mid-1)<=x)\n                    return mid;\n                else if(a.get(mid)>x && a.get(mid-1)>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public int lowerLastBound(long a[] , long x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>=x)\n                return -1;\n            if(a[r]<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid-1]<x)\n                    return mid-1;\n                else if(a[mid]>=x)\n                    r = mid-1;\n                else if(a[mid]<x && a[mid+1]>=x)\n                    return mid;\n                else if(a[mid]<x && a[mid+1]<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(long a[] , long x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>x)\n                return l;\n            if(a[r]<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid+1]>x)\n                    return mid+1;\n                else if(a[mid]<=x)\n                    l = mid+1;\n                else if(a[mid]>x && a[mid-1]<=x)\n                    return mid;\n                else if(a[mid]>x && a[mid-1]>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public long log(float number , int base){\n            return (long) Math.ceil((Math.log(number) / Math.log(base)) + 1e-9);\n        }\n        public long gcd(long a , long b){\n            if(a<b){\n                long c = b;\n                b = a;\n                a = c;\n            }\n            while(b!=0){\n                long c = a;\n                a = b;\n                b = c%a;\n            }\n            return a;\n        }\n        public long[] gcdEx(long p, long q) {\n            if (q == 0)\n                return new long[] { p, 1, 0 };\n            long[] vals = gcdEx(q, p % q);\n            long d = vals[0];\n            long a = vals[2];\n            long b = vals[1] - (p / q) * vals[2];\n            // 0->gcd 1->xValue 2->yValue\n            return new long[] { d, a, b };\n        }\n        public void sievePhi(int a[]){\n            a[0] = 0;\n            a[1] = 1;\n            for(int i=2;i<a.length;i++)\n                a[i] = i-1;\n            for(int i=2;i<a.length;i++)\n                for(int j = 2*i;j<a.length;j+=i)\n                    a[j] -= a[i];\n        }\n        public void lcmSum(long a[]){\n            int sievePhi[] = new int[(int)1e6 + 1];\n            sievePhi(sievePhi);\n            a[0] = 0;\n            for(int i=1;i<a.length;i++)\n                for(int j = i;j<a.length;j+=i)\n                    a[j] += (long)i*sievePhi[i];\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}"
        },
        {
            "language": 3,
            "solution": "'''Author- Akshit Monga'''\nfrom sys import stdin,stdout\ninput=stdin.readline\nt=int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    arr=[]\n    ans=-1\n    for i in range(n):\n        x,y=map(int,input().split())\n        arr.append((x,y))\n    for i in arr:\n        val=0\n        for j in arr:\n            if abs(i[0]-j[0])+abs(i[1]-j[1])<=k:\n                val+=1\n        if val==n:\n            ans=1\n            break\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n\n#define ll  long long int \n#define vi vector<int>\n#define vvi vector<vi>\n#define vl vector<ll>\n#define pb push_back\n#define fi(i,a,b) for(int i = (int)a; i<int(b); ++i)\n#define itr(it,v) for(auto it = v.begin(); it != v.end(); ++it)\n#define MAX 10000000\n#define IOS ios_base::sync_with_stdio(false); \n#define MOD 1000000000+7\n\nusing namespace std;\n\n\n\nint dist(int a, int b, int c, int d){\n    int dis = abs(a-c)+abs(b-d);\n    return dis;\n}\nbool solve(int n, int k){\n    int a[n][2];\n    fi(i,0,n){\n        cin >> a[i][0] >> a[i][1];\n    }\n\n    bool pos = true;\n    fi(i,0,n){\n        pos = true;\n        fi(j,0,n){\n            if(dist(a[j][0], a[j][1], a[i][0], a[i][1]) > k){\n                pos = false;\n                break;\n            }\n        }\n        if(pos){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main ()\n{\n    IOS;\n    int t; cin >> t;\n    //char ch; cin >> ch;\n    while(t--){\n        int n,k; cin >> n >> k;\n        if(solve(n, k)){\n            cout << \"1\\n\";\n        }\n        else{\n            cout << \"-1\\n\";\n        }\n    }\n    return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner();\n\t\tint T = fs.nextInt();\n\t\tfor (int t = 0; t<T; t++) {\n\t\t\tint n,k;\n\t\t\tn = fs.nextInt();\n\t\t\tk = fs.nextInt();\n\t\t\tArrayList<point> pts = new ArrayList<point>();\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tint x = fs.nextInt();\n\t\t\t\tint y = fs.nextInt();\n\t\t\t\tpts.add(new point(x,y));\n\t\t\t}\n\t\t\tboolean allWorks = false;\n\t\t\tfor (int i = 0; i<n; i++) {\n\t\t\t\tboolean works = true;\n\t\t\t\tfor(int j = 0; j<n; j++) {\n\t\t\t\t\tif (point.dist(pts.get(i), pts.get(j)) > k)works = false;\n\t\t\t\t}\n\t\t\t\tif (works) allWorks = true;\n\t\t\t}\n\t\t\tif (allWorks) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class point {\n\t\tint x,y;\n\n\t\tpublic point() {}\n\t\tpublic point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic static int dist(point p1, point p2) {\n\t\t\treturn Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t}\n\n\t}\n\n\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5+200;\n\nstruct node{\n    int x,y;\n}p[maxn];\n\n\n\nint main()\n{\n    int T;cin>>T;\n    while(T--){\n        int n,k;\n        cin>>n>>k;\n        for(int i=1;i<=n;i++){\n            cin>>p[i].x>>p[i].y;\n        }\n        int flag=0;\n        for(int i=1;i<=n;i++){\n            int dis = 0;\n            for(int j=1;j<=n;j++){\n                dis = max(abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y),dis);\n            }\n            if(dis<=k){flag=1;cout<<1<<endl;break;}\n        }\n        if(!flag)cout<<-1<<endl;\n    }\n    return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.HashMap;\npublic class j {\n \tprivate static FastScanner fs=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint t=fs.nextInt();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n = fs.nextInt();\n\t\t\tint k = fs.nextInt();\n\t\t\tNode a [] = new Node[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tNode n1 = new Node();\n\t\t\t\tn1.i = fs.nextInt();\n\t\t\t\tn1.j = fs.nextInt();\n\t\t\t\ta[i] = n1;\n\t\t\t}\n\t\t\touter:\n\t\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint count =0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\n\n\t\t\t\t\tlong a1 = Math.abs(a[i].i-a[j].i);\n\t\t\t\t\tlong b1 = Math.abs(a[i].j-a[j].j);\n\t\t\t\t\ta1 +=b1;\n\t\t\t\t\tif(a1<=k) count++;\n\n\t\t\t\t}\n\t\t\t\tif(count ==n )\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\n\n\n\t\t\t}\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\t\t\n\t\t}\n\t\n\t}\n\tstatic class Node\n\t{\n\t\tint i;\n\t\tint j;\n\t}\n\t\n \n\tstatic final Random random=new Random();\n\t\n\tstatic void ruffleSort(long[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n); long temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tint [] sort(int [] arr)\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int i : arr) list.add(i);\t\n\t\t\n\t\t\tCollections.sort(list);\n\t\t\tint res[] = new int[arr.length];\n\t\t\tfor(int i=0;i<arr.length;i++) res[i] = list.get(i);\n\t\t\t\n\n\t\t\treturn res;\n\t\t}\n\t}\n \n\t\n}"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor j in range(0,t):\n    n,k=map(int,input().split())\n    x=[]\n    y=[]\n    for i in range(0,n):\n        a,b=0,0\n        a,b=map(int,input().split())\n        x.append(a)\n        y.append(b)\n    fl=0\n    for i in range(0,n):\n        fl=-1\n        for g in range(0,n):\n            if(abs(x[i]-x[g])+abs(y[i]-y[g])<=k):\n                fl=0\n            else:\n                fl=-1\n                break\n        if(fl==0):\n            break\n    if(fl==-1):\n        print(-1)\n    else:\n        print(1)\n            \n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#include<cmath>\n#include<string>\nusing namespace std;\n#define L long long int\n\nint check1(L x1,L y1,L x2,L y2,L k){\n  L a,b;\n  a= (x2 -x1);\n  b = (y2-y1);\n  if(a<0){\n    a = -1*a;\n  }\n  if(b<0){\n    b= -1*b;\n  }\n  L c;\n  c =a+b;\n  if(c <= k){\n    return 1;\n  }\n  else{\n    return 0;\n  }\n\n\n}\n\n\nint main(){\n  L t;\n  cin >>t;\n\n  for (size_t j = 0; j < t; j++) {\n    L n,p;\n    cin >>n>>p;\n\n    L check=0;\n\n    std::vector<L> x(n);\n    std::vector<L> y(n);\n\n    for (size_t i = 0; i < n; i++) {\n      cin >> x[i] >> y[i];\n\n    }\n\n    L try1;\n\n    for (size_t i = 0; i < n; i++) {\n\n      try1 = 0;\n\n      for (size_t k = 0; k < n; k++) {\n\n        if(check1(x[i],y[i],x[k],y[k],p)){\n          try1 ++;\n        }\n        else{\n          break;\n        }\n      }\n      if( try1 == n){\n        cout << \"1\" << endl;\n        check =1;\n        break;\n      }\n    }\n    if(check == 0){\n      std::cout << \"-1\" << '\\n';\n    }\n  }\n\n\n\n\n\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def dis(x1,y1,x2,y2):\n    ans = abs(x1-x2) + abs(y1-y2)\n    return ans\n    \n    \nfor _ in range(int(input())):\n    n,k = map(int,input().split(' '))\n    arr = []\n    for _ in range(n):\n        x,y = map(int,input().split(' '))\n        arr.append([x,y])\n    d = []\n    v = []\n    ans = -1\n    for i in range(n):\n        d = []\n        for j in range(n):\n        \n                p = dis(arr[i][0],arr[i][1],arr[j][0],arr[j][1])\n                d.append(p)\n        c = 0\n    \n        for item in d:\n            if item<=k:\n                c = c + 1 \n        if c==n:\n            ans = 1\n            break\n            \n    print(ans)\n    "
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define endl \"\\n\"\n#define pb push_back\n#define int long long int\n#define ll long long\n#define vi vector<int>\n#define vll vector<ll>\n#define vvi vector < vi >\n#define pii pair<int,int>\n#define pll pair<long long, long long>\n#define mod 1000000007\n#define MOD 998244353\n#define inf 1000000000000000001;\n#define all(c) c.begin(),c.end()\n#define deb(x) cout<< \">\" << #x << '=' << x << endl;\n#define read(v) for(auto &it:v) cin>>it;\nconst int  N = 2e5 + 5;\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector <pair<int, int>> v;\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        v.pb({a, b});\n    }\n    bool flag = false;\n    for (int i = 0; i < v.size(); i++) {\n        int x = v[i].first, y = v[i].second;\n        bool f = true;\n        for (int j = 0; j < v.size(); j++) {\n            if (abs(v[j].first - x) + abs(v[j].second - y) > k) {\n                f = false;\n                break;\n            }\n        }\n        if (f) {\n            flag = true;\n            break;\n        }\n\n\n    }\n    if (flag) {\n        cout << 1 << endl;\n    }\n    else {\n        cout << -1 << endl;\n    }\n\n\n\n\n\n}\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    int  t = 1;\n    cin >> t;\n    while (t--) solve();\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define sz(a) signed(a.size())\n#define all(v) v.begin(),v.end()\n#define rall(v) (v.rbegin(),v.rend())\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n#define rep(i,n) for(int i(0);i<n;++i)\n#define trav(x, v) for (auto &x : v)\n#define OK(ok) cout << (ok ? \"YES\\n\" : \"NO\\n\")\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntemplate <class T> T sqr(T x) { return x * x; }\ntemplate <class T> T abs(T x) { return x < 0? -x : x; }\ntemplate <class T> T gcd(T a, T b) { return b? gcd(b, a % b) : a; }\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nconst int MOD=1000000007;\nconst int PRM=998244353;\n\n\nvoid solve(){\n\tint n,k,u,v,id=-1;\n\tcin >> n >> k;\n\tvector<int> x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor(int i(0);i<n;++i){\n\t\tbool chk=1;\n\t\tfor(int j(0);j<n;++j){\n\t\t\tif(j!=i){\n\t\t\t\tif(abs(x[i]-x[j])+abs(y[i]-y[j]) > k){\n\t\t\t\t\tchk=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(chk){\n\t\t\tid=i;break;\n\t\t}\n\t}\n\n\tif(id!=-1){\n\t\tcout << 1 << endl;\n\t}\n\telse{\n\t\tcout << -1 << endl;\n\t}\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\t#ifdef HOME\n    assert(freopen(\"input.txt\", \"r\", stdin));\n    assert(freopen(\"output.txt\", \"w\", stdout));\n    #endif\n    int t;\n    cin >> t;\n    while(t--){\n    \tsolve();\n    }\n\n    cerr << \"Time execute: \" << clock() / (double)CLOCKS_PER_SEC << \" sec\" << endl;\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while (t--)\n    {\n\n        long long int n, k;\n        cin >> n >> k;\n        int flag = 0;\n        long long int a[n][2];\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < 2; j++)\n                cin >> a[i][j];\n        }\n        for (int i = 0; i < n; i++)\n        {\n            int r = 0;\n            for (int j = 0; j < n; j++)\n            {\n                if (abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) > k)\n                {\n                    break;\n                }\n                r++;\n            }\n            if (r == n)\n            {\n                flag = 1;\n                cout << 1 << endl;\n                break;\n            }\n        }\n        if (flag == 0)\n        {\n            cout << -1 << endl;\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "T = int(raw_input())\nfor t in xrange(T):\n    n, k = map(int, raw_input().split())\n    a = [map(int, raw_input().split()) for _ in xrange(n)]\n    for i in xrange(n):\n        if all(i == j or abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) <= k for j in xrange(n)):\n            print 1\n            break\n    else:\n        print -1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n\n{\n\nlong long t,n,k,x,y;\n\nstring s;\n\ncin>>t;\n\nwhile(t--)\n{ \n    int n,c=0;\n            cin>>n;\n            int k;\n            cin>>k;\n            \n            vector<pair<int,int>>v(n);\n            \n            for(int i=0;i<n;i++)\n                cin>>v[i].first>>v[i].second;\n                \n            for(int i=0;i<n;i++){\n                int total=0;\n                for(int j=0;j<n;j++){\n                    if(abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second)<=k)\n                        total++;\n                }\n                if(total==n){\n                    c++;\n                    cout<<1<<\"\\n\";\n                    break;\n                }\n            }\n            \n            if(c==0)\n            cout<<-1<<\"\\n\";\n\n\n}\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(n) for(int i=0;i<n;i++)\n#define rrep(n) for(int i=n-1;i>=0;i--)\n#define mod 1000000007\ntypedef vector<int> vi; \ntypedef pair<int, int> pi; \n#define F first \n#define S second \n#define PB push_back\nvoid solve()\n{\n\tll n,k;\n\tcin>>n>>k;\n\tvector<pair<int,int>>v;\n    rep(n){\n    \tint x,y;\n    \tcin>>x>>y;\n    \tv.push_back({x,y});\n    }\n   for(int i=0;i<n;i++)\n   {\n   \tbool ok=true;\n   \tfor(int j=0;j<n;j++)\n   \t{\n   \t\tif(abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second)>k)\n   \t\t\t{\n   \t\t\t\tok=false;break;\n   \t\t\t}\n   \t}\n   \tif(ok)\n   \t\t{\n   \t\t\tcout<<1;return;\n   \t\t}\n   }\n   cout<<-1;\n\n}\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tll t=1;\n\tcin>>t;\n\twhile(t--)\n\t{\n\tsolve();\n\tcout<<\"\\n\";\n\t}\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "/*\n\n ALLAH IS ALMIGHTY              ******BISMILLAHIR RAHMANIR RAHIM.******              ALLAH IS ALMIGHTY\n                                    ```````````````````````````````\n                                        AUTHOR: ANISUR RAHAMAN\n                                            BSMRSTU(SHIICT)\n                                                ID:017\n\n\n                            ............LET's START OUR JOURNEY.............\n\n*/\n\n#include<bits/stdc++.h>\n\n#define I_O ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n#define ll long long int\n\n#define lls int64_t\n#define ld long double\n#define db double\n#define ull unsigned long long int\n\n//~~~~~~~~~~~~~~Pair~~~~~~~~~~~~~~~~~~//\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n#define pd pair<db,db>\n#define psi pair<string,int>\n#define vi vector<int>\n#define vl vector<ll>\n#define vd vector<db>\n#define vb vector<bool>\n#define vpi vector<pi>\n#define vpl vector<pl>\n#define vpd vector<pd>\n#define vpsi vector<psi>\n\n//~~~~~~~~~~~~~~Vector~~~~~~~~~~~~~~~~~//\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define in insert\n#define ff first\n#define ss second\n#define al(v) v.begin(),v.end()\n#define alr(v) v.rbegin(), v.rend()\n#define min(a, b) (((a) <= (b)) ? (a) : (b))\n#define max(a, b) (((a) >= (b)) ? (a) : (b))\n#define srt(v) sort(al(v))\n#define sz(x) ((ll)(x).size())\n#define rev(v) reverse(al(v))\n#define acl(v, n) accumulate(al(v), n)\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define tpu(str) transform(al(str), str.begin(), ::toupper)\n#define tpl(str) transform(al(str), str.begin(), ::tolower)\n#define mxv(v) *max_element(al(v))\n#define mnv(v) *min_element(al(v))\n\nconst int MOD = 1e9 + 7;\nconst ll INF = 2e18;\nconst int mxn = 2e9 + 9;\nconst int mxd = 2e5 + 5;\n\n//~~~~~~~~~~~~~~~Loops and Short~~~~~~~~~~~~~~~~//\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) (a*b)/gcd(a,b)\n#define PI acos(-1)\n#define C continue\n#define B break\n#define off return 0\n#define N '\\n'\n#define rep(i, n) for(lls i = 0; i < n; i++)\n#define repn(i, a, b) for(lls i = (lls)(a); i < (lls)(b); i++)\n#define repr(i, a, b) for(lls i = (lls)(a) - 1; i >= (lls)(b); i--)\n#define test_case() int T; cin >> T; while(T--)\nusing namespace std;\n\nvoid SoLuTioN()\n{\n    int n, k;\n    cin >> n >> k;\n    vi v(n), va(n);\n    rep(i, n) cin >> v[i] >> va[i];\n    rep(i, n){\n        int f = 0;\n        rep(j, n){\n            if(abs(v[i] - v[j]) + abs(va[i] - va[j]) > k){\n                f = 1;B;\n            }\n        }\n        if(f == 0){\n            cout << \"1\" << N;\n            return;\n        }\n    }\n    cout << \"-1\" << N;\n}\n\nint main()\n{\n    I_O\n    test_case()\n    {\n        SoLuTioN();\n    }\n\n    off;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class Coding {\n\n    private static BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        try {\n            run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void run() throws Exception {\n        InputModule inp = new InputModule();\n        OutputModule out = new OutputModule();\n        int t = inp.cinInt();\n        while (t > 0) {\n            int[] ints = inp.cinIntArray(2);\n            int n = ints[0];\n            int k = ints[1];\n            Point[] pts = new Point[n];\n            for(int i=0;i<n;++i) {\n                int[] ints1 = inp.cinIntArray(2);\n                pts[i] = new Point(ints1[0], ints1[1]);\n            }\n            boolean found = false;\n            for(int i=0;i<n;++i) {\n                int cnt = 0;\n                for(int j=0;j<n;++j) {\n                    if (i==j)continue;\n                    int dist = Math.abs(pts[i].x-pts[j].x) + Math.abs(pts[i].y - pts[j].y);\n                    if (dist<=k) cnt++;\n                }\n                if (cnt==(n-1)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (found) out.printInt(1);\n            else out.printInt(-1);\n            t--;\n        }\n    }\n\n    private static class InputModule {\n        private int cinInt() throws Exception {\n            return Integer.parseInt(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private long cinLong() throws Exception {\n            return Long.parseLong(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private Double cinDouble() throws Exception {\n            return Double.parseDouble(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private String cinString() throws Exception {\n            return bi.readLine();\n        }\n\n        private int[] cinIntArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            int[] ar = new int[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Integer.parseInt(values[i]);\n            }\n            return ar;\n        }\n\n        private int[] cinIntArray() throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            int[] ar = new int[values.length];\n            for (int i = 0; i < values.length; ++i) {\n                ar[i] = Integer.parseInt(values[i]);\n            }\n            return ar;\n        }\n\n        private long[] cinLongArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            long[] ar = new long[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Long.parseLong(values[i]);\n            }\n            return ar;\n        }\n\n        private String[] cinStringArray(int n) throws Exception {\n            return bi.readLine().split(\" \");\n        }\n    }\n\n    private static class OutputModule {\n        private void printInt(int ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printLong(long ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printDouble(Double ans) throws Exception {\n            writer.append(String.format(\"%.10f\", ans));\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printString(String ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printIntArray(int[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printLongArray(long[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printIntMatrix(int[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printLongMatrix(long[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printPoint(Point p) throws Exception {\n            writer.append(p.x + \" \" + p.y + \"\\n\");\n            writer.flush();\n        }\n\n        private void printPoints(List<Point> p) throws Exception {\n            for (Point pp : p) {\n                writer.append(pp.x + \" \" + pp.y + \"\\n\");\n            }\n            writer.flush();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvoid solve(){\n    int n,k;\n    cin>>n>>k;\n    pair<ll,ll> arr[n];\n    for(int i{};i<n;i++){\n        cin>>arr[i].first>>arr[i].second;\n    }\n    bool tr=false;\n    for(int i{};i<n;i++){\n        int tmp{};\n        for(int j{};j<n;j++){\n            if((abs(arr[i].first-arr[j].first)+abs(arr[i].second-arr[j].second)) <=k)\n                tmp++;\n        }\n        if(tmp==n){\n            tr=true;\n            break;\n        }\n    }\n    if(tr && k!=0)cout<<1;\n    else cout<<-1;\n}\n\nint main(){\n    int tt;\n    cin>>tt;\n    while(tt--){\n        solve();\n        cout<<\"\\n\";\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n/* \n * Subscribe to galen_colin!\n * https://tinyurl.com/galencolin\n*/\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint T=fs.nextInt();\n\t\ttest:for (int tt=0; tt<T; tt++) {\n\t\t\tint n=fs.nextInt(), k=fs.nextInt();\n\t\t\tint[] xs=new int[n], ys=new int[n];\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\txs[i]=fs.nextInt();\n\t\t\t\tys[i]=fs.nextInt();\n\t\t\t}\n\t\t\touter: for (int i=0; i<n; i++) {\n\t\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\t\tif (Math.abs(xs[i]-xs[j])+Math.abs(ys[i]-ys[j])>k) continue outer;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tcontinue test;\n\t\t\t}\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define double long double\n#define fr(n) for(int i=0;i<n;i++)\n#define sortv(a) sort(a.begin(),a.end())\n#define pb push_back\n#define endl \"\\n\"\n#define pii pair<int,int>\nconst int N = 1e6+5;\nconst int mod = 998244353;\n\nvector<int> adj[100005];\nvector<bool> vis(100005,false);\n\n// int mod = 1e9+7;\nint modexpo(int x,int p){\n    int res = 1;\n    x = x%mod;\n    while(p){\n        if(p%2)\n            res = res * x;\n        p >>= 1;\n        x = x*x % mod;\n        res %= mod;\n    }      \n    return res;\n}\n\n\nint isprime(int n){\n    if(n < 2)\n        return 0;\n    if(n < 4)\n        return 1;\n    if(n % 2 == 0 or n % 3 == 0)\n        return 0;\n    for(int i = 5; i*i <= n; i += 6)\n        if(n % i == 0 or n % (i+2) == 0)\n            return 0;\n    return 1;\n}\n\nvoid pairsort(int a[], int b[], int n){\n    pair<int, int> pairt[n];\n    for (int i = 0; i < n; i++) \n    {\n        pairt[i].first = a[i];\n        pairt[i].second = b[i];\n    }\n    sort(pairt, pairt + n);\n    for (int i = 0; i < n; i++) \n    {\n        a[i] = pairt[i].first;\n        b[i] = pairt[i].second;\n    }\n}\n\n    \n\n\nvoid solve()\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint n,k;\ncin >> n >> k;\n\nint x[n], y[n];\n\nfr(n)\n    cin >> x[i] >> y[i];\n\nfor(int i=0;i<n;i++)\n{\n    int maxx = 0;\n    for(int j=0;j<n;j++)\n    {\n        maxx = max(maxx, abs(x[i]-x[j])+abs(y[i]-y[j]));\n    }\n    if(maxx <= k)\n    {\n        cout << 1;\n        return;\n    }\n}\ncout << -1;\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\nint32_t main()\n{\n    int q = 1;\n    cin >> q;\n    while(q--)\n        solve(),cout << endl;\n    return 0;\n}\n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Long> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Integer> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map;\n     static Map<Integer,Integer> map1;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long ans;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n     //        int n = sc.nextInt();\n     //        // int m = sc.nextInt();\n     //        map = new HashMap<>();\n     //        for(int i = 0 ; i < n ; i++){\n     //            int l = sc.nextInt();\n     //            int r = sc.nextInt();\n     //            if(map.containsKey(l))\n     //                map.put(l,new ArrayList<>());\n     //            list = map.get(l);\n     //            list.add(r);\n\n     //            if(map.containsKey(r))\n     //                map.put(r,new ArrayList<>());\n     //            list1 = map.get(l);\n     //            list1.add(r);\n\n     //        }\n     //        boolean flag = false;\n     //        for(Integer i : map.keySet()){\n     //            if(map.get(i).size() > 2){\n     //                if(!flag)\n     //                    flag = true;\n     //                else{\n     //                    System.out.println(\"NO\");\n     //                    return;\n     //                }\n     //            }\n     //        }\n     //        System.out.print(sb);\n     //    }\n        \n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\n     public static void solve(){\n\n        int k = m;\n        \n        for(int i = 0 ; i < n ; i++){\n            int dist = 0;\n            boolean flag = false;\n            for(int j = 0 ; j < n ; j++){\n                dist = Math.abs(nodes[i].first - nodes[j].first) + \n                    Math.abs(nodes[i].second - nodes[j].second);\n                if(dist > k){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag){\n                System.out.println(\"1\");\n                return;\n            }\n        }\n        System.out.println(\"-1\");\n    }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            int t = sc.nextInt();\n            // int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                // n = sc.nextInt();\n                // n = sc.nextLong();\n                // a = sc.nextLong();\n                // b = sc.nextLong();\n                // c = sc.nextLong();\n                // d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                \n                // n = sc.nextLong();\n                n = sc.nextInt();\n                // n1 = sc.nextInt();\n\n                m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // s = sc.next();\n\n                // ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // arr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arr[i] = sc.nextLong();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                // darr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     darr[i] = sc.nextLong();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new int[n][n];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ;  j < n ; j++){\n                //         mat[i][j] = sc.nextInt();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                nodes = new Node[n];\n                for(int i = 0 ; i < n ;i++)\n                    nodes[i] = new Node(sc.nextInt(),sc.nextInt());\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n     public static long gcd(long a,long b){\n\n        if(b%a == 0){\n            return a;\n        }\n        return gcd(b%a,a);\n\n     }\n\n     public static void swap(int i,int j){\n         char temp = ch[j];\n         ch[j] = ch[i];\n         ch[i] = temp;\n     } \n\n    static final Random random=new Random();\n    \n    static void ruffleSort(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n\nusing namespace :: std;\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n\nconst int  maxn=200;\nconst ll inf=1e16+900;\n\nint x[maxn];\nint y[maxn];\nbool ger[maxn][maxn];\n\n\nint main(){\t\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tbool findd=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint d=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tger[i][j]=(abs(x[i]-x[j])+abs(y[i]-y[j])<=k);\n\t\t\t\td+=ger[i][j];\n\t\t\t}\n\t\t\tif(d==n){\n\t\t\t\tcout<<1<<endl;\n\t\t\t\tfindd=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!findd){\n\t\t\tcout<<-1<<endl;\n\t\t}\t\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "'''\nName : Jaymeet Mehta\ncodeforces id :mj_13\nProblem : \n'''\nfrom sys import stdin,stdout\ndef doit():\n    global points,n,k\n    for i in range(n):\n        x1,y1=points[i]\n        ok=True\n        for j in range(n):\n            x2,y2=points[j]\n            distance=abs(x1-x2)+abs(y1-y2)\n            if distance>k:\n                ok=False\n                break\n        if ok:\n            return 1\n    return -1\ntest=int(stdin.readline())\nfor _ in range(test):\n    n,k = map(int,stdin.readline().split())\n    points=[]\n    for i in range(n):\n        x,y = map(int,stdin.readline().split())\n        points.append([x,y])\n    print(doit())\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Balls_Of_Steel {\n\tstatic class pair\n\t{\n\t\tprivate int x;\n\t\tprivate int y;\n\t\tpublic pair(int x, int y)\n\t\t{\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint size = sc.nextInt();\n\t\t\tint distance = sc.nextInt();\n\t\t\tint[] visited = new int[size];\n\t\t\tpair[] coord = new pair[size];\n\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tcoord[i] = new pair(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tboolean flag = false;\n\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j = 0; j < size; j++)\n\t\t\t\t{\n\t\t\t\t\tif(Math.abs(coord[i].x - coord[j].x) + Math.abs(coord[i].y - coord[j].y) <= distance)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == size)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void BFS(int index, pair[] coord, int[] visited, int distance)\n\t{\n\t\tQueue<Integer> track = new LinkedList<Integer>();\n\t\tvisited[index] = 1;\n\t\ttrack.add(index);\n\t\twhile(!track.isEmpty())\n\t\t{\n\t\t\tint currentIndex = track.poll();\n\t\t\tfor(int i = 0; i < coord.length; i++)\n\t\t\t{\n\t\t\t\tif(visited[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(Math.abs(coord[i].x - coord[currentIndex].x) + Math.abs(coord[i].y - coord[currentIndex].y) <= distance)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrack.add(i);\n\t\t\t\t\t\tvisited[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline()\n \n# --------------------------------------------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef print_list(l):\n    print(' '.join(map(str,l)))\n    \n# sys.setrecursionlimit(100000)\n# import random\n# from functools import reduce\n# from functools import lru_cache\n# from heapq import *\n# from collections import deque as dq\n# import math\n# import bisect as bs\n# from collections import Counter\n# from collections import defaultdict as dc \n\n\nfor _ in range(N()):\n    n, k = RL()\n    dic = [[] for _ in range(n)]\n    p = []\n    for _ in range(n):\n        x, y = RL()\n        p.append((x, y))\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1]) <= k:\n                dic[i].append(j)\n                dic[j].append(i)\n    res = -1\n    for i in range(n):\n        if len(dic[i]) == n - 1:\n            res = 1\n            break\n    print(res)"
        },
        {
            "language": 2,
            "solution": "/**-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*-*                                                               *-*\n*-*                  Bismillahir Rahmanir Rahim                   *-*\n*-*                                                               *-*\n*-*                  Author: Ahsan Habib (comrade)                *-*\n*-*                    Metropolitan University                    *-*\n*-*                         Language: C++                         *-*\n*-*                                                               *-*\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**/\n#include<bits/stdc++.h>\n#include<cstdio>\n#define pii          pair<ll,ll >\n#include<string>\n#define In freopen(\"ahsan.txt\",\"r\",stdin);\n#define ll long long\n#define ff first\n#define ss second\n#define pb push_back\n#define sortv(v)  sort(v.begin(),v.end())\n#define bug(a) cerr << #a << \" : \" << a << endl\n#define   sz(x)       x.size()\n#define MOD 1000000007\n#define inf 999999999999\n/**\n            I don'n know anything like you\n    But one thing I know vary obviously That is I am \"Ahsan\"\n**/\nconst int mx = 1e6+5;\nconst int MAX = 1e6;\nusing namespace std;\nll a[MAX],m,i,t,k,ev=0,od=0,tt=0,n,cas = 1, cum[300050];\nvector<pii>G[MAX];\nconst int N = 1e6 + 100;\n\nint main()\n{\n    /***********************************/\n    ios::sync_with_stdio(true);\n    cin.tie(0);\n      ///In;\n    /**********************************/\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        vector<pii>v,v2;\n        int n,k ;\n        cin>>n>>k;\n        for(int i = 0; i<n; i++)\n        {\n            int x,y;\n            cin>>x>>y;\n            v.push_back(pii(x,y));\n        }\n\n        int f = 1;\n        for(int i = 0; i<n; i++)\n        {\n            f = 1;\n            for(int j = 0; j<n; j++)\n            {\n                int tm = abs(v[i].ff - v[j].ff)+abs(v[i].second- v[j].second);\n                if(tm>k)\n                {\n                    f = 0;\n                    break;\n                }\n            }\n            if(f==1)\n            {\n                break;\n            }\n\n        }\n        if(f==0)\n        {\n            cout<<\"-1\"<<endl;\n\n        }\n        else cout<<\"1\"<<endl;\n\n    }\n\n    return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nfor t in range(int(input())):\n    ball_idx=defaultdict(list)\n    rang=defaultdict(list)\n    n,k=map(int,input().split())\n    listi=[]\n    for i in range(n):\n        x,y=map(int,input().split()) \n        p=[]\n        p.append(x)\n        p.append(y)\n        listi.append(p)\n    kam=False\n    # for i in listi:\n    #     print(i[0],i[1],end=\" \")\n    for i in listi:\n        count=0\n        for j in listi:\n            p=abs(i[0]-j[0])\n            l=abs(i[1]-j[1])\n            if (0<p+l<=k):\n                count+=1\n        if count==n-1:\n            kam=True\n            print(1)\n            break\n    if kam==False:\n        print(-1)                "
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/*\n1\n4\n\n\n */\n\n\npublic class B {\n\tstatic FastReader sc=null;\n\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint t=sc.nextInt();\n\t\touter: while(t-->0) {\n\t\t\tint n=sc.nextInt(),k=sc.nextInt();\n\t\t\tint x[]=new int[n],y[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tboolean a=true;\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tif(Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j])>k)a=false;\n\t\t\t\t}\n\t\t\t\tif(a) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(-1);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\t\n\t\t\n\t\n\tstatic int[] reverse(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al,Collections.reverseOrder());\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\t\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader in, PrintWriter out) throws IOException {\n            int t = in.nextInt();\n            int kcc = 0;\n            // out.println(kcc);\n            while (kcc < t) {\n\n                // out.println(kcc);\n                int ans = -1;\n                int n = in.nextInt();\n                int k = in.nextInt();\n                int[][] v = new int[n][2];\n                for (int i = 0; i < n; i++) {\n                    v[i][0] = in.nextInt();\n                    v[i][1] = in.nextInt();\n\n                }\n                for (int i = 0; i < n; i++) {\n                    boolean ok = true;\n                    for (int j = 0; j < n; j++) {\n                        if (i != j && k < Math.abs(v[i][0] - v[j][0]) + Math.abs(v[i][1] - v[j][1])) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        ans = 1;\n                        break;\n                    }\n                }\n                out.println(ans);\n                kcc++;\n            }\n\n        }\n    }\n\n    public static boolean isSorted(int[] array) {\n        return IntStream.range(0, array.length - 1).noneMatch(i -> array[i] > array[i + 1]);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String nextLine() throws IOException {\n            return reader.readLine().trim();\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n\tn,k=map(int,input().split())\n\tl=[]\n\tfor i in range(n):\n\t\tl.append(list(map(int,input().split())))\n\tl.sort(key=lambda x:x[0]+x[1])\n\t#print(l)\n\tf=0\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tx1=l[i][0]\n\t\t\ty1=l[i][1]\n\t\t\tx2=l[j][0]\n\t\t\ty2=l[j][1]\n\t\t\td=abs(x1-x2)+abs(y1-y2)\n\t\t\tif d>k:\n\t\t\t\tf+=1\n\t\t\t\tbreak\n\tif f==n:\n\t\tprint(-1)\n\telse:\n\t\tprint(1)\n"
        },
        {
            "language": 2,
            "solution": "/*\n    Author      : Dinesh Verra\n    College     : ABV-IIITM\n    Date        : 11/12/2020\n*/\n// #pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp> \n// using namespace boost::multiprecision; \nusing namespace std;\ntypedef long long ll;\n// #define ll int\ntypedef unsigned long long ull;\n#define cu continue\n#define br break\n#define pb push_back\n#define eb emplace_back\n#define mod 1000000007\n#define inf 1000000000\n#define pll pair <ll,ll>\n#define min_pq priority_queue<pll,vector <pll>, greater <pll> >  \n#define ar array\n#define F first\n#define S second\n#define var(n) vector<ar<ll,n>>\n#define vll vector <ll>\n#define vpll vector <pll>\n#define dbg(n) cout<<#n<<' '<<n<<endl;\n#define all(v) v.begin(),v.end()\n#define nl cout<<'\\n'\n\ntemplate <typename A1>\nvoid prn(A1&& arg)\n{\n    cout<<arg<<'\\n';\n}\ntemplate <typename A1, typename... A>\nvoid prn(A1&& arg, A&&... args)\n{\n    cout<<arg<<' ';\n    prn(args...);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    #ifndef ONLINE_JUDGE\n    freopen(\"/home/dinesh_verra/cpp/input.txt\",\"r\",stdin);\n    // freopen(\"/home/dinesh_verra/cpp/A.txt\",\"w\",stdout);\n    #endif\n\n    ll t;\n    cin>>t;\n    while(t--) {\n\n        ll n,k;\n        cin>>n>>k;\n        var(2) a(n);\n        ll cnt;\n        for(ll i=0;i<n;i++) cin>>a[i][0]>>a[i][1];\n        for(ll i=0;i<n;i++) {\n\n            cnt=0;\n            for(ll j=0;j<n;j++) {\n                if(i==j) cu;\n                if(abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1]) <= k) cnt++;\n            }\n            if(cnt==(n-1)) {\n                prn(1);\n                goto end;\n            }\n        }\n        prn(-1);\n        end:\n        cu;\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;const int N=1e2+7;int T_T,n,m,i,j,x[N],y[N],flag;\nint main(){\n\tfor(cin>>T_T;T_T--;){\n\t\tfor(cin>>n>>m,flag=0,i=1;i<=n;++i)cin>>x[i]>>y[i];\n\t\tfor(i=1;i<=n;++i){\n\t\t\tfor(j=1;j<=n;++j)if(j!=i&&abs(x[i]-x[j])+abs(y[i]-y[j])>m)break;\n\t\t\tif(j==n+1)flag=1;\n\t\t}\n\t\tcout<<(flag?1:-1)<<endl;\n\t}\n} "
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing  namespace std;\ntypedef long long ll;\nint n,m;ll l,r;\nconst int maxn=1e6+1;\npair<int,int>p[105];\nint w[50];\nvoid run(){\n    cin>>n>>m;int ans=-1;\n    for(int i=1;i<=n;i++)cin>>p[i].first>>p[i].second;\n    for(int i=1;i<=n;i++){\n            int f=0;\n        for(int j=1;j<=n;j++){\n            if(abs(p[i].first-p[j].first)+abs(p[i].second-p[j].second)>m){f=1;break;}\n        }\n    if(!f){ans=1;break;}\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    int T;\n\n  cin>>T;  for(int i=1;i<=T;i++)run();\n  // run();\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nimport math\n\nfor _ in range(int(input())):\n    n, k = list(map(int,input().split()))\n    points = []\n    for i in range(n):\n        points.append(tuple(map(int,input().split())))\n    adj = dict()\n    for i in range(n):\n        for j in range(i+1,n):\n            temp1 = points[i]\n            temp2 = points[j]\n            if abs(temp1[0]-temp2[0])+abs(temp1[1]-temp2[1])<=k:\n                if temp1 not in adj:\n                    adj[temp1]=0\n                if temp2 not in adj:\n                    adj[temp2]=0\n                adj[temp1]+=1\n                adj[temp2]+=1\n    ans = False\n    for key in adj:\n        if adj[key]==n-1:\n            ans = True\n    if ans:\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 3,
            "solution": "t = int(input()) \nfor _ in range(t):\n\tn,k =  map(int, input().split())\n\ta = [0] * n\n\tfor i in range(n):\n\t\ta[i] = tuple(map(int, input().split()))\n\n\td = [0] * n\n\tfor i in range(n-1):\n\t\tfor j in range(i+1, n):\n\t\t \tdist = abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1])\n\t\t \tif dist <= k:\n\t\t \t\td[i] += 1\n\t\t \t\td[j] += 1\n\n\tif (n-1) in d:\n\t\tprint(1)\n\telse:\n\t\tprint(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#define ll long long int \n#define pb push_back \n#define F(i,n) for(ll i=0;i<n;i++)\nusing namespace std;\n\n\nint main() {\n    ll t=1;\n    cin>>t;\n    while(t--){\n        ll n,k;\n        cin>>n>>k;\n        vector <pair<ll,ll> > v;\n        ll x,y;\n        F(i,n)\n        {\n            cin>>x>>y;\n            v.pb({x,y});\n        }\n        ll flag=0;\n        F(i,n)\n        {\n            ll f=0;\n            F(j,n)\n            {\n                if(abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second)>k) f=1;\n            }\n            if(f==0) {flag=1;}\n        }\n        if(flag==1) cout<<1;\n        else cout<<-1;\n        cout<<endl;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport os\nfrom io import BytesIO, IOBase\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nT = int(input())\n\nfor _ in range(T):\n    n, k = map(int, input().split())\n    arr = []\n\n    for i in range(n):\n        x, y = map(int, input().split())\n        arr.append((x,y))\n\n    ok = False\n\n    for i in range(n):\n        cx, cy = arr[i]\n\n        for j in range(n):\n            if abs(cx - arr[j][0]) + abs(cy - arr[j][1]) > k:\n                break\n        else:\n            ok = True\n            break\n\n    if ok:\n        print(1)\n        continue\n    print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Global12B{\n\tpublic static void main(String[] main) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\tfor(int trial = 1; trial <= t; trial++){\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tint[][] coord = new int[n][2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tcoord[i][0] = Integer.parseInt(st.nextToken());\n\t\t\t\tcoord[i][1] = Integer.parseInt(st.nextToken());\n\t\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\t\tdist[i][j] = Math.abs(coord[j][0] - coord[i][0]) + Math.abs(coord[j][1] - coord[i][1]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean worked = false;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tboolean all = true;\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(dist[i][j] > k)\n\t\t\t\t\t\tall = false;\n\t\t\t\t}\n\t\t\t\tif(all) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tworked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!worked)\n\t\t\t\tout.println(-1);\n\t\t}\n\t\tout.close();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define rep(i,a,n) for (int i=a;i<=n;i++)\n#define per(i,a,n) for (int i=a;i>=n;i--)\n\nusing namespace std;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define PII pair<int,int>\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) a+1,a+n+1\n#define ALL(a) a.begin(),a.end()\n#define debug(a) cout <<#a << \"=\" << a << endl;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll<<60;\nconst int mod=1e9+7;\n#define TT int T;cin>>T;while(T--)\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}\ninline void write(int x){if(x<0) putchar('-'),x=-x;if(x>9) write(x/10);putchar(x%10+'0');}\n\nvoid solve(){\n\tint n,k;\n\tcin>>n>>k;\n\tPII a[110];\n\trep(i,1,n) cin>>a[i].fi>>a[i].se;\n\trep(i,1,n){\n\t\tint f=1;\n\t\trep(j,1,n){\n\t\t\t\n\t\t\tif(abs(a[i].fi-a[j].fi)+abs(a[i].se-a[j].se)>k){\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tcout<<1<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn;\n}\nint main(){\n\tTT{\n\t\tsolve();\n\t}\n    return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "test = int(input())\n\ndef dist(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]) \n\nfor t in range(test):\n    n, k = map(int, input().split())\n    P = [list(map(int, input().split())) for i in range(n)]\n    \n    found = None\n    for i in range(n):\n        found = True\n        for j in range(n):\n            if i == j:\n                continue\n            elif dist(P[i], P[j]) > k:\n                found = False    \n                break\n        \n        if found: break\n    \n    if found: print(1)\n    else: print(-1)"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    xy = [tuple(map(int, input().split())) for i in range(n)]\n    ans = -1\n    for x, y in xy:\n        flag = True\n        for x2, y2 in xy:\n            dx = abs(x2-x)\n            dy = abs(y2-y)\n            if dx + dy <= k:\n                continue\n            else:\n                flag = False\n                break\n        if flag:\n            ans = 1\n            break\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nfor _ in range(t):\n    n,k = [int(x) for x in input().split()]\n    points = []\n    for i in range(n):\n        points.append(([int(x) for x in input().split()]))\n    for i in range(len(points)):\n        y=0\n        for j in range(len(points)):\n            a,b = points[i][0],points[i][1]\n            c,d = points[j][0],points[j][1]\n            if abs(a-c)+abs(b-d)<=k:\n                y+=1\n            else:\n                break\n        if y==len(points):\n            print(1)\n            break\n    else:\n        print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.PI;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\nimport static java.lang.System.err;\n\npublic class B { \n    public static void main(String[] args) throws Exception {   \n        Foster sc = new Foster();\n        PrintWriter p = new PrintWriter(out);\n        int t = sc.nextInt();\n        test : while(t--!=0){\n            int n = sc.nextInt();\n            long k = sc.nextLong();\n            long x[] = new long[n];\n            long y[] = new long[n];\n            for(int i = 0; i < n; i++){\n                x[i] = sc.nextLong();\n                y[i] = sc.nextLong();\n            }\n            for(int i = 0; i < n; i++){\n                boolean thisCor = true;\n                for(int j = 0; j < n; j++){\n                    long dis = Math.abs(x[i] - x[j]) + Math.abs(y[i] - y[j]);\n                    if(dis > k)     thisCor = false;\n                }\n                if(thisCor){\n                    p.println(\"1\");\n                    continue test;\n                }\n            }\n            p.println(\"-1\");\n        }\n        p.close();\n    }\n\n    static int[] sort(int a[]){\n        ArrayList<Integer> arr = new ArrayList<>();\n        for(int i : a){\n            arr.add(i);\n        }\n        Collections.sort(arr);\n        for(int i = 0; i < arr.size(); i++){\n            a[i] = arr.get(i);\n        }\n        return a;\n    }\n    \n/* \n*/    \n/*\n1. Check overflow in pow function or in general\n2. Check indices of read array function\n3. Think of an easier solution because the problems you solve are always easy\n4. Check iterator of loop\n5. If still doesn't work, then jump from the 729th floor 'coz \"beta tumse na ho paayega\"\n\n    Move to top!!\n*/\n    static class Foster {\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n        StringTokenizer st = new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        int[] intArray(int n) {                   // Check indices\n            int arr[] = new int[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n        long[] longArray(int n) {                 // Check indices\n            long arr[] = new long[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n        int[] getBits(int n) {                   //in Reverse Order\n            int a[] = new int[31];\n            for(int i = 0; i < 31; i++) {\n                if(((1<<i) & n) != 0)\n                    a[i] = 1;\n            }\n            return a;\n        }\n        static String reverse(String s){\n            String temp = \"\";\n            for(int i = s.length()-1; i >= 0; i--){\n                temp += s.charAt(i);\n            }\n            return temp;\n        }\n        static long pow(long... a) {\n            long mod = Long.MAX_VALUE;\n            if(a.length == 3)   mod = a[2];\n            long res = 1;\n            while(a[1] > 0) {\n                if((a[1] & 1) == 1)\n                    res = (res * a[0]) % mod;\n                a[1] /= 2;\n                a[0] = (a[0] * a[0]) % mod;\n            }\n            return res;\n        }\n        static void print(Object... o) {\n            for(Object next : o) {\n                System.err.print(next + \" \");\n            }\n        }\n        static void println(Object... o) {\n            for(Object next : o) {\n                System.err.print(next + \" \");\n            }\n            System.err.println();\n        }\n        static void watch(Object...a) throws Exception {\n            int i = 1;\n            for (Object o: a) {\n                boolean found = false;\n                if (o.getClass().isArray()) {\n                    String type = o.getClass().getName().toString();\n                    switch (type) {\n                        case \"[I\": {\n                            int[] test = (int[]) o;\n                            println(i + \" : \" + Arrays.toString(test));\n                            break;\n                        }\n                        case \"[[I\": {\n                            int[][] obj = (int[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[J\": {\n                            long[] obj = (long[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[J\": {\n                            long[][] obj = (long[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[D\": {\n                            double[] obj = (double[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[D\": {\n                            double[][] obj = (double[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[Ljava.lang.String\": {\n                            String[] obj = (String[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[Ljava.lang.String\": {\n                            String[][] obj = (String[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        case \"[C\": {\n                            char[] obj = (char[]) o;\n                            println(i + \" : \" + Arrays.toString(obj));\n                            break;\n                        }\n                        case \"[[C\": {\n                            char[][] obj = (char[][]) o;\n                            println(i + \" : \" + Arrays.deepToString(obj));\n                            break;\n                        }\n                        default: {\n                            println(i + \" : type not identified\");\n                            break;\n                        }\n                    }\n                    found = true;\n                }\n                if (o.getClass() == ArrayList.class) {\n                    println(i + \" : LIST = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == TreeSet.class) {\n                    println(i + \" : SET = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == TreeMap.class) {\n                    println(i + \" : MAP = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == HashMap.class) {\n                    println(i + \" : MAP = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == LinkedList.class) {\n                    println(i + \" : LIST = \" + o);\n                    found = true;\n                }\n                if (o.getClass() == PriorityQueue.class) {\n                    println(i + \" : PQ = \" + o);\n                    found = true;\n                }\n                if (!found) {\n                    println(i + \" = \" + o);\n                }\n                i++;\n            }\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def f(n,k):\n\tpts = [list(map(int, input().split())) for _ in range(n)]\n\tdeg = [0 for _ in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\ta,b = pts[i]\n\t\t\tx,y = pts[j]\n\t\t\tman = abs(x-a)+abs(y-b)\n\t\t\tif man <= k:\n\t\t\t\tdeg[i] += 1\n\t\t\t\tdeg[j] += 1\n\tif max(deg) == n-1:\n\t\treturn 1\n\telse:\n\t\treturn -1\n\nt = int(input())\nfor i in range(t):\n\tn,k = list(map(int, input().split()))\n\tprint(f(n,k))\n"
        },
        {
            "language": 4,
            "solution": "// Dec 6, 2020\nimport java.util.*;\nimport java.io.*;\n\npublic class B {\n\tstatic class FastReader {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tprivate FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[] nextIntArrayOne(int n) {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFastReader s = new FastReader();\n\t\tStringBuilder str = new StringBuilder();\n\n\t\tint t = s.nextInt();\n\n\t\twhile (t-- > 0) {\n\t\t\tint n = s.nextInt(), k = s.nextInt();\n\t\t\tPair[] pairs = new Pair[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tpairs[i] = new Pair(s.nextInt(), s.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tint marked[] = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\tPair x = pairs[i];\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(i !=j ) {\n\t\t\t\t\t\tPair y = pairs[j];\n\t\t\t\t\t\tint a = Math.abs(x.i - y.i);\n\t\t\t\t\t\tint b = Math.abs(x.j - y.j);\n\t\t\t\t\t\tint temp =  a + b; \n\t\t\t\t\t\tif(temp <= k) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmarked[i] = count;\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\t\n\t\t\tfor(int p : marked) {\n\t\t\t\tif(p == n - 1) {\n\t\t\t\t\tans = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstr.append(ans+\"\\n\");\n\t\t}\n\t\tSystem.out.println(str);\n\t}\n\t\n\tstatic class Pair{\n\t\tint i,j;\n\t\tPair(int i,int j){\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor _ in range(t):\n    n,k=list(map(int,input().split()))\n    c=[]\n    for i in range(n):\n        c.append(list(map(int,input().split())))\n    f=1\n    for i in range(n):\n        f=1\n        for j in range(n):\n            if abs(c[i][0]-c[j][0])+abs(c[i][1]-c[j][1])>k:\n                f=-1\n                break\n        if f==1:\n            break\n    print(f)"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor i in range(t):\n    n,k=map(int,input().split())\n    li=[]\n    for j in range(n):\n        li.append(list(map(int,input().split())))\n  \n    for j in range(n):\n        c=0\n        x1=li[j][0]\n        y1=li[j][1]\n        for k1 in range(n):\n            x2=li[k1][0]\n            y2=li[k1][1]\n            dist=abs(x1-x2)+abs(y1-y2)\n            if dist>k:\n                \n                c=1\n                break\n        if c==0:\n            print(1)\n            break\n    if c==1:\n        print(-1)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.util.*;\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\n\n\n// graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees\n\n\n\npublic class scratch_25 {\n    static class Graph{\n\n        public static class Vertex{\n            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex\n        }\n\n        public static HashMap<Integer,Vertex> vt;   // for vertices(all)\n\n        public Graph(){\n            vt= new HashMap<>();\n        }\n\n        public static int numVer(){\n            return vt.size();\n        }\n\n        public static boolean contVer(int ver){\n            return vt.containsKey(ver);\n        }\n\n        public static void addVer(int ver){\n            Vertex v= new Vertex();\n            vt.put(ver,v);\n        }\n\n\n\n\n\n\n        public static void addEdge(int ver1, int ver2, int weight){\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n            Vertex v1= vt.get(ver1);\n            Vertex v2= vt.get(ver2);\n            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge\n            v2.nb.put(ver1,weight);\n        }\n\n        public static void delEdge(int ver1, int ver2){\n\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n            vt.get(ver1).nb.remove(ver2);\n            vt.get(ver2).nb.remove(ver1);\n        }\n        public static void delVer(int ver){\n            if(!vt.containsKey(ver)){\n                return;\n            }\n            Vertex v1= vt.get(ver);\n            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());\n            for (int i = 0; i <arr.size() ; i++) {\n                int s= arr.get(i);\n                vt.get(s).nb.remove(ver);\n            }\n            vt.remove(ver);\n        }\n           static boolean done[];\n            static int parent[];\n            static ArrayList<Integer>vals= new ArrayList<>();\n\n\n        public static boolean isCycle(int i){\n            Stack<Integer>stk= new Stack<>();\n\n            stk.push(i);\n            while(!stk.isEmpty()){\n                int x= stk.pop();\n                vals.add(x);\n             //   System.out.print(\"current=\"+x+\" stackinit=\"+stk);\n                if(!done[x]){\n                    done[x]=true;\n                }\n                else if(done[x] ){\n                    return true;\n                }\n\n                ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());\n                for (int j = 0; j <ar.size() ; j++) {\n                   if(parent[x]!=ar.get(j)){\n                       parent[ar.get(j)]=x;\n                    stk.push(ar.get(j));\n                   }\n                }\n               // System.out.println(\" stackfin=\"+stk);\n            }\n            return false;\n        }\n\n    static HashMap<Integer, Set<Integer>>map;\n        static int color[];\n        public static void bfs(int v){\n            Queue<Integer>q= new LinkedList<>();\n            q.add(v);\n            while(!q.isEmpty()){\n                int x= q.poll();\n                done[x]=true;\n                ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());\n                Set<Integer>set= new HashSet<>();\n                if(!map.containsKey(color[x])){\n                    set= new HashSet<>();\n                    map.put(color[x],set);\n                }\n                else{\n                    set= map.get(color[x]);\n                }\n                for (int i = 0; i <ar.size() ; i++) {\n                    int d= ar.get(i);\n                    if(color[d]!=color[x]){\n                    set.add(color[d]);}\n                    if(!map.containsKey(color[d])){\n                        Set<Integer>s= new HashSet<>();\n                        s.add(color[x]);\n                        map.put(color[d],s);\n                    }\n                    else{\n                        Set<Integer>s= map.get(color[d]);\n                        if(color[d]!=color[x]){\n                        s.add(color[x]);\n                        map.put(color[d],s);\n                    }}\n                    if(!done[d]){\n                        q.add(d);\n                    }\n                }\n                 map.put(color[x],set);\n            }\n        }\n        }\n        \n\n\n\n    // int count=0;\n    //static long count=0;\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /**\n         * get next word\n         */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n    static class Pair implements Comparable<Pair>{\n        int x;\n        int y;\n        public Pair(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n        @Override\n        public int compareTo(Pair o){\n            return (int)this.x-(int)o.x;\n            \n        }\n        @Override\n        public boolean equals(Object me) {\n            Pair binMe = (Pair)me;\n            if(this.x==binMe.x && this.y==binMe.y)\n                return true;\n            else\n                return false;\n\n        }\n\n        @Override\n        public int hashCode() {\n            return (int)this.x + (int)this.y;\n        }\n\n        @Override\n        public String toString() {\n            return x+\" \"+y;\n        }\n\n\n    }\n\n\n\n\n\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, or negative after MOD\n    public static void main(String[] args)  throws IOException {\n        Reader.init(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n     int t= Reader.nextInt();\n        for (int tt = 0; tt <t ; tt++) {\n            int n= Reader.nextInt();\n            int k= Reader.nextInt();\n            int arr[][]= new int[n][2];\n            for (int i = 0; i <n ; i++) {\n                arr[i][0]= Reader.nextInt();\n                arr[i][1]= Reader.nextInt();\n            }\n            boolean b=false;\n            for (int i = 0; i <n ; i++) {\n                int x1= arr[i][0];\n                int x2=arr[i][1];\n                boolean b1=true;\n                for (int j = 0; j <n ; j++) {\n                    if(Math.abs(arr[j][0]-x1)+Math.abs(arr[j][1]-x2)>k){\n                        b1=false;\n                        break;\n                    }\n                }\n                if(b1){\n                    b=true;\n                    break;\n                }\n            }\n            if(b){\n                out.append(1+\"\\n\");\n            }\n            else{\n                out.append(-1+\"\\n\");\n            }\n\n\n\n\n\n        }\n\n        out.flush();\n        out.close();\n\n    }\n\n\n\n\n\n    static long modExp(long a, long b, long mod) {\n        //System.out.println(\"a is \" + a + \" and b is \" + b);\n        if (a==1) return 1;\n        long ans = 1;\n        while (b!=0) {\n            if (b%2==1) {\n                ans = (ans*a)%mod;\n            }\n            a = (a*a)%mod;\n            b/=2;\n        }\n        return ans;\n    }\n\n\n    public static long modmul(long a, long b, long mod) {\n        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;\n    }\n\n    static long sum(long n){\n        //   System.out.println(\"lol=\"+ (n*(n-1))/2);\n        return (n*(n+1))/2;\n    }\n\n\n\n\n\n\n    public static ArrayList<Integer> Sieve(int n) {\n        boolean arr[]= new boolean [n+1];\n        Arrays.fill(arr,true);\n        arr[0]=false;\n        arr[1]=false;\n        for (int i = 2; i*i <=n ; i++) {\n            if(arr[i]){\n                for (int j = 2; j <=n/i ; j++) {\n                    int u= i*j;\n                    arr[u]=false;\n                }}\n        }\n        ArrayList<Integer> ans= new ArrayList<>();\n        for (int i = 0; i <n+1 ; i++) {\n            if(arr[i]){\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n\n\n\n    static long power( long x, long y, long p)\n    {\n\n        long res = 1;\n\n\n        x = x % p;\n\n        if (x == 0) return 0;\n\n        while (y > 0)\n        {\n\n            if((y & 1)==1)\n                res = (res * x) % p;\n\n\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static long ceil_div(long a, long b){\n        return (a+b-1)/b;\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b)\n    {\n        return (a*b)/gcd(a, b);\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\n// Problem: B. Balls of Steel\n// Contest: Codeforces - Codeforces Global Round 12\n// URL: https://codeforces.com/contest/1450/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static PrintWriter pw = new PrintWriter(System.out);\n    private static InputReader sc = new InputReader();\n    private static final int intmax = Integer.MAX_VALUE, intmin = Integer.MIN_VALUE;\n\n    static class Pair{\n        int first, second;\n        Pair(int first, int second){\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n    static class InputReader{\n        private static BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        private static StringTokenizer tk;\n\n        private void next()throws IOException{\n            while(tk == null || !tk.hasMoreTokens())   \n                tk = new StringTokenizer(r.readLine());\n        }\n\n        private int nextInt()throws IOException{\n            next();\n            return Integer.parseInt(tk.nextToken());\n        }\n\n        private long nextLong()throws IOException{\n            next();\n            return Long.parseLong(tk.nextToken());\n        }\n\n        private String readString()throws IOException{\n            next();\n            return tk.nextToken();\n        }\n\n        private double nextDouble()throws IOException{\n            next();\n            return Double.parseDouble(tk.nextToken());\n        }\n\n        private int[] intArray(int n)throws IOException{\n            next();\n            int arr[] = new int[n];\n\n            for(int i=0; i<n; i++)\n                arr[i] = nextInt();\n\n            return arr;\n        }\n\n        private long[] longArray(int n)throws IOException{\n            next();\n            long arr[] = new long[n];\n\n            for(int i=0; i<n; i++)\n                arr[i] = nextLong();\n\n            return arr;\n        }\n    }\n\n    public static void main(String args[])throws IOException{\n        int t = sc.nextInt();\n        while(t-->0)    solve();\n        pw.flush();\n        pw.close();\n    }\n    \n    private static int dist(int point1[], int point2[]){\n    \treturn Math.abs(point1[0] - point2[0]) + Math.abs(point1[1] - point2[1]);\n    }  \n\n    private static void solve()throws IOException{\n\t\tint n = sc.nextInt(), k = sc.nextInt(), dist[][] = new int[n][n], points[][] = new int[n][2];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tpoints[i] = sc.intArray(2);\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdist[i][j] = dist(points[i], points[j]);\n\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tboolean check = true;\n\t\t\t\n\t\t\tfor(int j = 0; j < n && check; j++)\n\t\t\t\tcheck = (dist[i][j] <= k);\n\t\t\t\n\t\t\tif(check){\n\t\t\t\tpw.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpw.println(-1);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "for i in range(int(input())):\n    n,k=map(int,input().split());l=[];t=-1\n    for i in range(n):x,y=map(int,input().split());l.append([x,y])\n    for i in l:\n        q=0\n        for j in l:\n            if abs(i[1]-j[1])+abs(i[0]-j[0])<=k:q+=1\n            else:break\n        if q==n:t=1\n    print(t)"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.abs;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n\tstatic void solve() throws Exception {\n\t\tint tests = scanInt();\n\t\ttest: for (int test = 0; test < tests; test++) {\n\t\t\tint n = scanInt(), k = scanInt();\n\t\t\tint x[] = new int[n], y[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = scanInt();\n\t\t\t\ty[i] = scanInt();\n\t\t\t}\n\t\t\ti: for (int i = 0; i < n; i++) {\n\t\t\t\tint cx = x[i], cy = y[i];\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (abs(x[j] - cx) + abs(y[j] - cy) > k) {\n\t\t\t\t\t\tcontinue i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(1);\n\t\t\t\tcontinue test;\n\t\t\t}\n\t\t\tout.println(-1);\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution \n{\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic int mod = (int)1e9 + 7;\n\t\n    public static void main(String args[]) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                try{\n                    solve();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        }, \"1\", 1 << 26).start();\n    }\n    \n    public static void solve(){\n    \tint t =in.nextInt();\n    \twhile(t-->0) {\n    \t\tint n = in.nextInt();\n    \t\tint k = in.nextInt();\n    \t\t\n    \t\tint[][] balls = new int[n][2];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tballs[i][0] = in.nextInt();\n    \t\t\tballs[i][1] = in.nextInt();\n    \t\t}\n    \t\t\n    \t\tif(n == 1) {\n    \t\t\tpn(0);\n    \t\t\tcontinue;\n    \t\t}\n    \t\t\n    \t\tint count = 0;\n    \t\tboolean found = false;\n    \t\t\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tcount = 0;\n    \t\t\tfor(int j = 0; j < n; j++) {\n    \t\t\t\tif(i == j) continue;\n    \t\t\t\tif(Math.abs(balls[i][0] - balls[j][0]) + Math.abs(balls[i][1] - balls[j][1]) <= k) {\n    \t\t\t\t\tcount++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif(count == n - 1) {\n    \t\t\t\tfound = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif(found) pn(1);\n    \t\telse pn(-1);\n    \t}\n    }\n   \n    /*TEMPLATE*/\n    \n    //MATHS\n    static int gcd(int a, int b) {\n    \treturn (b==0)?a:gcd(b,a%b);\n    }\n    \n    static long binPow(long x, long y) {\n        long ans = 1L;\n        while(y > 0) {\n            if(y % 2 == 1)\n                ans = mul(ans, x);\n            x = mul(x, x);\n            y /= 2;\n        }\n        return ans;\n    }\n    \n    static long add(long x, long y) {\n    \tx += y;\n    \treturn mod(x, mod);\n    }\n    \n    static long mul(long x, long y) {\n    \treturn mod(x * y, mod);\n    }\n    \n    static long divide(long x, long y) {\n        return mul(x, binPow(y, mod - 2));\n    }\n\n    static long mod(long x, long p) {\n        x %= p;\n        if (x < 0)\n            x += p;\n        return x;\n    }\n        \n    public static int[] spf(int maxn) {\n    \tint[] spf=new int[maxn+1];\n    \tspf[0]=spf[1]=1;\n    \tfor(int i=2;i<=maxn;i++) {\n    \t\tif(i%2==0) spf[i]=2;\n    \t\telse \n    \t\t\tspf[i]=i;\n    \t}\n    \tfor(int i=3;i*i<=maxn;i++) {\n    \t\tif(spf[i]==i){\n    \t\t\tfor (int j=i*i; j<=maxn; j+=i) \n                    if (spf[j]==j) \n                        spf[j] = i;\n    \t\t}\n    \t}\n    \treturn spf;\n    }\n    \n    //ARRAYS\n    public static int[] intArray(int n) {\n    \tint ar[]=new int[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tar[i]=in.nextInt();\n    \treturn ar;\n    }\n    \n    public static void swap(int i, int j, int ar[]) {\n    \tint c=ar[i];ar[i]=ar[j];ar[j]=c;\n    }\n    \n    public static void reverse(int ar[]) {\n    \tint l=0, r=ar.length-1;\n    \twhile(l<r) {\n    \t\tint temp=ar[l]; ar[l]=ar[r]; ar[r]=temp;\n    \t\tl++; r--;\n    \t}\n    }\n    \n    public static int upperBound(int[] array, int value) {\n    \t//return next higher element. If greater than all elements then returns array.length\n    \t//returns 0 if smaller than all elements\n    \tint low = 0;\n    \tint high = array.length;\n    \twhile (low < high) {\n    \t\tfinal int mid = (low + high) / 2;\n    \t\tif (value >= array[mid]) {\n    \t\t\tlow = mid + 1;\n    \t\t} else {\n    \t\t\thigh = mid;\n    \t\t}\n    \t}\n    \treturn low;\n    }\n    \n    public static int lowerBound(int[] array, int value) {\n    \t//Returns first occurrence.\n    \t//Bigger than all elements then return array.length\n    \t//Not found, then next greater.s\n    \tint low = 0;\n    \tint high = array.length;\n    \twhile (low < high) {\n    \t\tfinal int mid = (low + high) / 2;\n\t\t\tif (value <= array[mid]) {\n\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n    \t}\n    \treturn low;\n\t}\n    \n    public static void pn(Object o) {\n      System.out.println(o);\n    }\n    \n    static class InputReader {\n \n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n \n            int res = 0;\n \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n \n            return res * sgn;\n        }\n \n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n \n            long res = 0;\n \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n \n            return res * sgn;\n        }\n \n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# region fastio  # from https://codeforces.com/contest/1333/submission/75948789\nimport sys, io, os\n\nBUFSIZE = 8192\n\n\nclass FastIO(io.IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = io.BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(io.IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#endregion\n\n\n\nT = int(input())\nfor _ in range(T):\n    N, K = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n    for cx, cy in XY:\n        f = True\n        for x, y in XY:\n            d = abs(cx-x) + abs(cy-y)\n            if d > K:\n                f = False\n                break\n        if f:\n            print(1)\n            break\n    else:\n        print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\n \npublic class A {\n \n\tstatic final int mod = 1000000007;\n\tstatic final int temp = 998244353;\n\tstatic final long MOD = 1000000007;\n\tstatic final long M = (long)1e9+7;\n \n\t\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tint first, second;\n\t\tpublic Pair(int aa, int bb)\n\t\t{\n\t\t\tfirst = aa; second = bb;\n\t\t}\n\t\tpublic int compareTo(Pair p)\n\t\t{\n//\t\t\tif(a == p.a) return b - p.b;\n//\t\t\treturn a - p.a;\n\t\t\tif(first == p.first) return (int)(second - p.second);\n\t\t\treturn (int)(first - p.first);\n\t\t}\n\t}\n\t\n\t/* IO for List of Arrays\n\t * ArrayList<Integer>[] list = new ArrayList[m];\n\t\tfor(int i = 0;i<m;i++)\n\t\t{\n\t\t\tlist[i] = new ArrayList<>();\n\t\t}\n\t */\n\t\n\t/*\n\t * IO FOR 2D GRID IN JAVA\n\t * char[][] arr = new char[n][m]; //grid in Q.\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tchar[] nowLine = sc.next().toCharArray();\n\t\t\t\tfor(int j = 0;j<m;j++)\n\t\t\t\t{\n\t\t\t\t\tarr[i][j] = nowLine[i];\n\t\t\t\t}\n\t\t\t}\n\t * */\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tList<Integer> readList(int n)\n\t\t{\n\t\t\tList<Integer> l = new ArrayList<>();\n\t\t\tfor(int i = 0;i<n;i++) l.add(nextInt());\n\t\t\treturn l;\n\t\t}\n\t\t\n\t\tlong[] longReadArray(int n) throws IOException {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\t\n \n\tpublic static boolean isPrime(long n) {\n\t\tif(n == 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfor(long i = 2;i*i<=n;i++)\n\t\t{\n\t\t\tif(n%i == 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static List<Integer> Sieve(int n)\n\t{\n\t\tboolean prime[] = new boolean[n+1];\n\t\tArrays.fill(prime, true);\n\t\tList<Integer> l = new ArrayList<>();\n\t\t\n\t\t\n\t\tfor (int p=2; p*p<=n; p++) \n\t\t{ \n\t\t\tif (prime[p] == true) \n\t\t\t{ \t\n\t\t\t    for(int i=p*p; i<=n; i += p) \n\t\t\t\t{\n\t\t\t\t    prime[i] = false; \n\t\t\t\t}\t\n\t\t\t} \n\t\t} \n \n\t\tfor (int p=2; p<=n; p++) \n\t\t{\n\t\t    if (prime[p] == true)\n\t\t    {\n\t\t       l.add(p); \n\t\t    }\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\tpublic static int gcd(int a, int b)\n\t{\n\t\tif(b == 0)\n\t\t return a;\n\t\t\n\t\telse\n\t\treturn gcd(b,a%b);\n\t} \n \n\tpublic static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n\t\n\tpublic static long LongGCD(long a, long b)\n\t{\n\t\tif(b == 0)\n\t\t\t return a;\n\t\t\t\n\t\t\telse\n\t\t\treturn LongGCD(b,a%b);\n\t}\n\t\n\tpublic static long LongLCM(long a, long b)\n    {\n        return (a / LongGCD(a, b)) * b;\n    }\n\t\n\tpublic static int phi(int n)  //euler totient function\n    { \n        int result = 1; \n        for (int i = 2; i < n; i++) \n            if (gcd(i, n) == 1) \n                result++; \n        return result; \n    }\n\t\n\t    \n\tpublic static int[] computePrefix(int arr[], int n)\n\t{\n\t\tint[] prefix = new int[n];\n\t\tprefix[0] = arr[0];\n\t\tfor(int i = 1;i<n;i++)\n\t\t{\n\t\t\tprefix[i] = prefix[i-1]+arr[i];\n\t\t}\n\t\t\n\t\treturn prefix;\n\t}\n\t\n\t\n\tpublic static long fastPow(long x, long n) //include mod at each step if asked and in args of fn too\n\t{\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\telse if(n%2 == 0)\n\t\t\treturn fastPow(x*x,n/2);\n\t\telse\n\t\t\treturn x*fastPow(x*x,(n-1)/2);\n\t}\n\t\n\t\n\t   public static long power(long x, long y, long p)\n\t    {\n\t \n\t        long res = 1;\n\t \n\t        x = x % p;\n\t \n\t        while (y > 0) {\n\t            if (y % 2 == 1)\n\t                res = (res * x) % p;\n\t \n\t            y = y >> 1; \n\t            x = (x * x) % p;\n\t        }\n\t \n\t        return res;\n\t    }\n\t   \n\t   static long modInverse(long n, long p)\n\t    {\n\t        return power(n, p - 2, p);\n\t    }\n\t \n\t    // Returns nCr % p using Fermat's little theorem.\n\t    \n\t    public static long nCr(long n, long r,\n\t                             long p)\n\t    {\n\t          if (n<r) \n\t              return 0;\n\t          \n\t        if (r == 0)\n\t            return 1;\n\t \n\t        long[] fac = new long[(int)(n) + 1];\n\t        fac[0] = 1;\n\t \n\t        for (int i = 1; i <= n; i++)\n\t            fac[i] = fac[i - 1] * i % p;\n\t \n\t        return (fac[(int)(n)] * modInverse(fac[(int)(r)], p)\n\t                % p * modInverse(fac[(int)(n - r)], p)\n\t                % p)\n\t            % p;\n\t    }\n\t    \n\t    public static long[] modInvArr(long n, long mod)\n\t    {\n\t    \tlong[] ans = new long[(int)(n)+1];\n\t\t\tans[1] = 1;\n\t\t\tfor(int i = 2;i <= n;i++)\n\t\t\t{\n\t\t\t\tans[i] = (mod - (mod/i) * ans[(int)(mod%i)])%mod;\n\t\t\t}\n\t\t\treturn ans;\n\t    }\n \n\t\tpublic static int LowerBound(int a[], int x) {\n\t\t\t  int l=-1,r=a.length;\n\t\t\t  while(l+1<r) {\n\t\t\t    int m=(l+r)>>>1;\n\t\t\t    if(a[m]>=x) r=m;\n\t\t\t    else l=m;\n\t\t\t  }\n\t\t\t  return r;\n\t\t\t}\n\t\t\n\t\t\n\t\tpublic static int UpperBound(int a[], int x) {\n\t\t    int l=-1;\n\t\t    int r=a.length;\n\t\t    while(l+1<r) {\n\t\t       int m=(l+r)>>>1;\n\t\t       if(a[m]<=x) l=m;\n\t\t       else r=m;\n\t\t    }\n\t\t    return l+1;\n\t\t}\n\t\t\n\t\tpublic static void Sort(int[] a) {\n\t\t\tList<Integer> l=new ArrayList<>();\n\t\t\tfor (int i:a) l.add(i);\n\t\t\tCollections.sort(l);\n\t\t\t//Collections.reverse(l);  //Use to Sort decreasingly \n\t\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t\t}\n\t\t\n\t\t//Modular Operations for Addition and Multiplication. \n\t\t\n\t\t   public static long perfomMod(long x){\n\t\t        return ((x%M + M)%M);\n\t\t    }\n\t\t   public static long addMod(long a, long  b){\n\t\t        return perfomMod(perfomMod(a)+perfomMod(b));\n\t\t    }\n\t\t   public static long mulMod(long  a, long b){\n\t\t        return perfomMod(perfomMod(a)*perfomMod(b));\n\t\t   }\n\t\t\n\t\tpublic static boolean isValid(String s1, String s2) \n\t\t\t{ \n\t\t\tint m = s1.length(), n = s2.length();\n\t\t\t\tint j = 0; \n\t\t\t\tfor (int i = 0; i < n && j < m; i++) \n\t\t\t\t\tif (s1.charAt(j) == s2.charAt(i)) \n\t\t\t\t\t\tj++; \n\n\t\t\t\treturn (j == m); \n\t\t\t} \n\t\t\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tReader sc=new Reader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0)\n\t\t{\n\t\t\tboolean ok = false;\n\t\t\tint n = sc.nextInt(),k = sc.nextInt();\n\t\t\t\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t{\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int j = 0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tint diff = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n\t\t\t\t\tif(diff <= k) c++;\n\t\t\t\t}\n\t\t\t\tif(c == n) ok = true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((ok == true ? 1 : -1));\n\t\t}\n\t\tout.close();\n\t}\n \n\t\n}"
        },
        {
            "language": 3,
            "solution": "from math import *\nfrom collections import deque\nfrom copy import deepcopy\nimport sys\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef multi(): return map(int,input().split())\ndef strmulti(): return map(str, inp().split())\ndef lis(): return list(map(int, inp().split()))\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef stringlis(): return list(map(str, inp().split()))\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef printlist(a) :\n    print(' '.join(str(a[i]) for i in range(len(a))))\n\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#copied functions end\n\n#start coding\n\nt=int(inp())\nfor _ in range(t):\n    n,k=multi()\n    a=[]\n    for i in range(n):\n        a.append(lis())\n\n    ans=-1\n    num=0\n\n\n    for i in range(n):\n        already=True\n        for j in range(n):\n            if(i==j):\n                continue\n            if(abs(a[i][0]-a[j][0])+abs(a[i][1]-a[j][1])>k ):\n                already=False\n                break\n        if(already):\n            ans=1\n            break\n\n\n\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint x[501],y[501];\nint main()\n{\n\tint t,n,k,ans=0;\n\tbool flag;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tk=read();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tx[i]=read();\n\t\t\ty[i]=read();\n\t\t}\n\t\tflag=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tflag=false;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(abs(x[i]-x[j])+abs(y[i]-y[j])>k)\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==true)printf(\"-1\\n\");\n\t} \n\treturn 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def dist(p1,p2):\n    return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\nfor _ in range(input()):\n    N,K = map(int,raw_input().split())\n    pts = [tuple(map(int,raw_input().split())) for _ in range(N)]\n    works = False\n    for i in range(N):\n        works |= max(dist(pts[i],p) for p in pts) <= K\n    if works:\n        print 1\n    else:\n        print -1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define ll long\n#define lll long long\n#define mp make_pair\n#define pb push_back\n#define inf 1000000001\n\nlll p = 1000000007;\n\nusing namespace std;\n\nlll sq(lll i){\nreturn i*i;\n}\n\n\nlll fact(ll n){\nll ans=1;\nfor(ll i=1; i<=n;i++)ans=(ans*i)%p;\nreturn ans;\n}\n\n//***********************GRAPH ALGORITHMS*************************************************************\n\nvoid dfs(vector <ll> v[], vector<ll> &df, ll cov[], ll i){ //Also outputed resultant dfs\n\n    df.pb(i);\n    for(ll j=0; j<v[i].size(); j++){if(cov[v[i][j]]==0){cov[v[i][j]]=cov[i]; dfs(v, df, cov, v[i][j]);}}\n}\n\nvoid djikstra (vector <pair<ll, ll>> v[], ll d[], ll par[], ll s, ll n){ //n^2\n\n    for(ll i=0; i<n;i++){d[i]=inf; par[i]=-1;}\n    par[s]=s; d[s]=0;\n    bool cov[n]; for(ll i=0; i<n;i++)cov[i]=0;\n\n    ll u=-1;\n\n    for(int j=0; j<n;j++)\n    {\n        u=-1;\n        for(ll i=0; i<n;i++){\n        if(!cov[i] && (d[i]<d[u] || u==-1))u=i;\n    }\n\n    cov[u]=1;\n\n    for(ll i=0; i<v[u].size(); i++){\n        if(d[v[u][i].first] > d[u]+v[u][i].second){d[v[u][i].first]=d[u]+v[u][i].second; /*cout << d[u] << \" \" <<v[u][i].second <<\"\\n\"; */par[v[u][i].first]=u;}\n    }\n\n}\n\n}\n\nll findConnComp(vector <ll> v[], ll cov[], ll n){\n    ll j=0;\n    vector <ll> df;\n    for(ll i=0; i<n;i++)cov[i]=0;\n    for(ll i=0; i<n; i++){\n        if(!cov[i]){cov[i]=++j; dfs(v, df, cov, i);}\n    }\n    return j;\n}\n\n\n//*****************CODE STARTS **************************************\n\n\nint main(){\n\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll t; cin >> t;\n    while(t--){\n        ll n, k; cin >> n >> k;\n        pair<ll, ll> pos[n];\n        for(int i=0; i<n;i++){\n            cin >> pos[i].first >> pos[i].second;\n        }\n\n        vector <ll> v[n];\n        for(ll i=0; i<n;i++){\n            for(ll j=i+1; j<n;j++){\n                if(abs(pos[i].first-pos[j].first) + abs(pos[i].second-pos[j].second)<=k){v[i].pb(j); v[j].pb(i);}\n            }\n        }\n        bool done=0;\n    for(ll i=0; i<n;i++)if(v[i].size()==n-1)done=1;\n    if(done)cout << \"1\\n\";\n    else cout <<\"-1\\n\";\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n  public class sol\n{\npublic static void main (String[] args) throws java.lang.Exception\n{ Scanner in=new Scanner (System.in);\n\nint t1=in.nextInt();\nfor(int i11=1;i11<=t1;i11++)\n{ int n=in.nextInt();\nlong k=in.nextLong();long c=0;int[] x=new int[n];boolean f=true;\nint[] y=new int[n];\n\nfor(int i=0;i<n;i++)\n{ x[i]=in.nextInt();\ny[i]=in.nextInt();\n    \n }   \n int ans=0;\n if(k!=0)\n {\n for(int i=0;i<n;i++)\n { f=true;\n     for(int j=0;j<n;j++)\n     { c=(long)Math.abs(x[i]-x[j])+(long)Math.abs(y[i]-y[j]);\n         if(c>k)\n         f=false;\n         \n        \n         \n     }\n     if(f==true)\n    {\n        ans=1;\n        break;\n    }\n    if(f==false&&i==n-1)\n    ans=-1;\n     \n }\n \n System.out.println(ans);\n \n }\n else\n System.out.println(-1);\n }\n       \n    }\n    \n    \n     \n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\ndef manhattan_dist(x1, y1, x2, y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef solve(points, k):\n    for p1 in points:\n        found = True\n        for p2 in points:\n            if p1 == p2:\n                continue\n            if manhattan_dist(p1.x, p1.y, p2.x, p2.y) > k:\n                found = False\n                break\n        if found:\n            return 1\n    return -1\n\nif __name__ == \"__main__\":\n    for t in range(int(input())):\n        n, k = list(map(int, input().split()))\n        points = []\n        for i in range(n):\n            x, y = list(map(int, input().split()))\n            points.append(Point(x, y))\n        print(solve(points, k))\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\npublic class Main{\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        for(int i  = 0;i<t;i++) {\n            int n  = s.nextInt();\n            long k = s.nextLong();\n            long[][] pts = new long[n][2];\n            for(int j = 0;j<n;j++) {\n                pts[j][0] = s.nextLong();\n                pts[j][1] = s.nextLong();\n            }\n            int res = -1;\n            for(int x = 0;x<n;x++) {\n                boolean isValid = true;\n                for(int y = 0;y<n;y++) {\n                    if(x != y) {\n                    if(Math.abs(pts[x][0] - pts[y][0]) + Math.abs(pts[x][1] - pts[y][1]) > k) {\n                        isValid = false;\n                        break;\n                    }\n                    }\n                }\n                if(isValid) {\n                    res = 1;\n                    break;\n                }\n            }\n            \n            System.out.println(res);\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "'''\n3\n3 2\n0 0\n3 3\n1 1\n3 3\n6 7\n8 8\n6 9\n4 1\n0 0\n0 1\n0 2\n0 3\n\n'''\nfrom collections import defaultdict\n\ntcs = int(input())\n\nfor tc in range(tcs):\n    n, k = list(map(int, input().split()))\n    li = list()\n    for i in range(n):\n        x, y = list(map(int, input().split()))\n        li.append([x, y])\n    ans = -1\n    for i in range(n):\n        flag = True\n        for j in range(n):\n            if i!=j and k<abs(li[i][0]-li[j][0])+abs(li[i][1]-li[j][1]):\n                flag = False\n                break\n        if flag:\n            ans = 1\n            break\n            \n    print(ans)\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define FOR(i,s,t) for(int i=s;i<=t;++i)\n#define REP(i,t,s) for(int i=t;i>=s;--i)\n#define mem(a,x) memset(a,x,sizeof a)\nusing namespace std;\ntypedef long long ll;\nint x[222],y[222];\nint t,n;\nint dis(int i,int j) {\n\treturn abs(x[i]-x[j])+abs(y[i]-y[j]);\n}\nint k;\nint main() {\n\tcin>>t;\n\twhile(t--) {\n\t\tcin>>n>>k;\n\t\tFOR(i,1,n) cin>>x[i]>>y[i];\n\t\tFOR(i,1,n) {\n\t\t\tint j;\n\t\t\tfor(j=1;j<=n;++j) if(dis(i,j)>k) break;\n\t\t\tif(j==n+1) {\n\t\t\t\tcout<<1<<endl;\n\t\t\t\tgoto xx;\n\t\t\t}\n\t\t}\n\t\tcout<<-1<<endl;\n\t\txx:;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, gettrace\n\nif gettrace():\n    inputi = input\nelse:\n    def input():\n        return next(stdin)[:-1]\n\n\n    def inputi():\n        return stdin.buffer.readline()\n\n\ndef solve():\n    n, k = map(int, inputi().split())\n    points = []\n    for _ in range(n):\n        points.append(tuple(map(int, inputi().split())))\n    dist = []\n    for px, py in points:\n        for qx, qy in points:\n            if abs(px-qx) + abs(py-qy) > k:\n                break\n        else:\n            print(1)\n            return\n    else:\n        print(-1)\n\ndef main():\n    t = int(inputi())\n    for _ in range(t):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = in.nextInt();\n        while(t-->0) { \n        \tint n = in.nextInt(), k = in.nextInt();\n        \tPair a[] = new Pair[n];\n        \tfor(int i=0;i<n;i++){\n        \t\tint x = in.nextInt(), y = in.nextInt();\n        \t\ta[i] = new Pair(x,y);\n        \t}\n        \tboolean valid = false;\n        \tfor(int i=0;i<n;i++){\n        \t\tboolean v = true;\n        \t\tint x = a[i].first(), y = a[i].second();\n        \t\tfor(int j=0;j<n;j++){\n                   \tif(Math.abs(a[j].first()-x)+(long)Math.abs(a[j].second()-y)>(long)k){\n                   \t\tv = false; break;\n                   \t}\n        \t\t}\n        \t\tif(v){\n        \t\t\tvalid = true; break;\n        \t\t}\n        \t}\n        \tout.println((valid)?1:-1);\n        }\n        out.flush();\n\t}\n\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\t\tPair(int a, int b){ x = a; y = b; }\n\t\tint first() { return x; }\n\t\tint second() { return y; }\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(o.second() - this.second()>0)\n\t\t\t\treturn -1;\n\t\t\telse if(o.second() - this.second()<0)\n\t\t\t\treturn 1;\n\t\t\telse \n\t\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\t\n\tstatic long lcm(long a, long b) {\n\t\treturn (a*b)/gcd(a,b);\n\t}\n\t\t\n\tstatic long gcd(long a, long b) {\n\t\tif(b==0) return a;\n\t\telse return gcd(b,a%b);\n\t}\n\t\n\tstatic long hashInt(int x,int y) {\n\t\treturn x*(1_000_000_000L)+y;\n\t}\n\t\n\n\n\tstatic final Random random = new Random();\n\t\n\tstatic void ruffleSort(long[] a){\n\t\tint n = a.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j = random.nextInt(n);long temp = a[j];\n\t\t\ta[j] = a[i]; a[i] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2877\u28ef\u28bf\u28ff\u28f7\u28fb\u28af\u28ff\u287d\u28fb\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2838\u28ff\u28ff\u28c6\u2839\u28ff\u28ff\u28be\u28df\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fb\u28fd\u287f\u28ff\u28ce\u2819\u28ff\u28de\u28f7\u284c\u28bb\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2839\u28ff\u28ff\u2846\u283b\u28ff\u28df\u28ef\u287f\u28fd\u287f\u28ff\u28ff\u28ff\u28ff\u28fd\u2877\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28f7\u28ff\u28ff\u28ff\u2840\u2839\u28df\u28fe\u28df\u28c6\u2839\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28a0\u2858\u28ff\u28ff\u2844\u2809\u28bf\u28ff\u28fd\u2877\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u285d\u28f7\u28ef\u28bf\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u28bf\u28fe\u28bf\u28ff\u2844\u2884\u2818\u28bf\u28de\u287f\u28e7\u2848\u28b7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b8\u28e7\u2818\u28ff\u28f7\u2808\u28e6\u2819\u28bf\u28fd\u28f7\u28fb\u28fd\u28ff\u28ff\u28ff\u28ff\u28cc\u28bf\u28ef\u28bf\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28ef\u28ff\u28bf\u28ff\u2846\u28b8\u2877\u2848\u28bb\u287d\u28f7\u2877\u2844\u283b\u28fd\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28cf\u28b0\u28ef\u28b7\u2808\u28ff\u2846\u28b9\u28b7\u284c\u283b\u287e\u288b\u28f1\u28ef\u28ff\u28ff\u28ff\u28ff\u2846\u28bb\u287f\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284e\u28ff\u28be\u287f\u28ff\u2846\u28b8\u28fd\u28bb\u28c4\u2839\u28f7\u28df\u28ff\u28c4\u2839\u28df\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u2847\u28b8\u28ef\u28df\u28e7\u2818\u28f7\u2808\u286f\u281b\u2880\u2850\u28be\u28df\u28f7\u28fb\u28ff\u28ff\u28ff\u287f\u284c\u28bf\u28fb\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u287f\u28df\u28ff\u2847\u28b8\u28ef\u28df\u28ee\u28a7\u2848\u28bf\u28de\u287f\u28e6\u2818\u280f\u28f9\u28ff\u28fd\u28bf\u28ff\u28ff\u28ff\u28ff\u28ef\u28ff\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28fe\u2846\u2839\u2880\u28e0\u28fe\u28df\u28f7\u2848\u28bf\u28de\u28ef\u28bf\u28ff\u28ff\u28ff\u28b7\u2818\u28ef\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u28bf\u28fd\u2847\u2818\u281b\u281b\u281b\u2813\u2813\u2808\u281b\u281b\u281f\u2807\u2880\u28bf\u28fb\u28ff\u28ef\u28bf\u28ff\u28ff\u28ff\u28f7\u28bf\u28ff\u28ff\u2801\u28fe\u28ff\u28ff\u28ff\u28e7\u2844\u2807\u28f9\u28ff\u28fe\u28ef\u28ff\u2844\u283b\u28fd\u28ef\u28bf\u28fb\u28ff\u28ff\u2847\u28b9\u28fe\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u287d\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28de\u28c6\u2830\u28f6\u28f6\u2844\u2880\u28bb\u287f\u28ef\u28ff\u287d\u28ff\u28ff\u28ff\u28af\u28df\u287f\u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2810\u28f8\u28ff\u28ff\u28f7\u28ff\u28ff\u28c6\u2839\u28ef\u28ff\u28fb\u28ff\u28ff\u28ff\u2880\u28ff\u28bf\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ef\u287f\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2848\u28bf\u28f3\u2818\u2844\u283b\u28ff\u28be\u28fd\u28df\u287f\u28ff\u28af\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u28be\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u28fe\u28f7\u28fb\u28ff\u287f\u2847\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u2807\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u283b\u2847\u28b9\u28c6\u2839\u28df\u28fe\u28fd\u28fb\u28df\u28ff\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u28ff\u28ff\u283f\u281b\u281b\u2809\u2819\u280b\u2880\u2801\u2898\u28ef\u28ff\u28ff\u28e7\u2818\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u2843\u28bc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u280c\u28ff\u28c6\u2818\u28ff\u28de\u287f\u28de\u287f\u285e\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2880\u28c0\u28e0\u28e4\u28e4\u28f6\u28f6\u28f6\u2846\u28bb\u28fd\u28de\u287f\u28f7\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2818\u2801\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2819\u281b\u281b\u28bf\u28c4\u28bb\u28ff\u28e7\u2818\u28af\u28df\u287f\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u2843\u2880\u2880\u2818\u281b\u283f\u28bf\u28fb\u28df\u28ef\u28fd\u28fb\u28f5\u2840\u28bf\u28ef\u28df\u28ff\u2880\u28ff\n\u28ff\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28f6\u28f6\u2846\u2880\u28ff\u28fe\u28ff\u28fe\u28f7\u28ff\u28f6\u283f\u281a\u2809\u2880\u2880\u28e4\u28ff\u28f7\u28ff\u28ff\u28f7\u2848\u28bf\u28fb\u2883\u28fc\u28ff\u28ff\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u2876\u28e6\u28e4\u28c4\u28c0\u2840\u2809\u281b\u281b\u2837\u28ef\u28f3\u2808\u28fe\u287d\u28fe\u2880\u28ff\n\u28ff\u28bf\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2810\u28ff\u28ff\u28ff\u28ff\u283f\u280b\u2801\u2880\u2880\u28e4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28cc\u28e5\u28fe\u287f\u28ff\u28ff\u28f7\u28ff\u28ff\u28bf\u28f7\u28ff\u28ff\u28df\u28fe\u28fd\u28f3\u28af\u28df\u28f6\u28e6\u28e4\u287e\u28df\u28e6\u2818\u28ff\u28be\u2841\u28ba\n\u28ff\u28fb\u28ff\u28ff\u2877\u28ff\u28ff\u28ff\u28ff\u28ff\u2857\u28e6\u2838\u287f\u280b\u2801\u2880\u2880\u28e0\u28f4\u28bf\u28ff\u28fd\u28fb\u28bd\u28fe\u28df\u28f7\u28ff\u28df\u28ff\u28ff\u28ff\u28f3\u283f\u28f5\u28e7\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28f3\u28ef\u28ff\u28ff\u28ff\u28fd\u2880\u28b7\u28fb\u2804\u2818\n\u28ff\u28b7\u28fb\u28ff\u28ff\u28f7\u28fb\u28ff\u28ff\u28ff\u2877\u281b\u28c1\u2880\u28c0\u28e4\u28f6\u28ff\u28db\u287f\u28ff\u28ee\u28fd\u287b\u28ff\u28ee\u28fd\u28fb\u28af\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u2880\u28b8\u28ff\u2880\u2846\n\u2838\u28df\u28ef\u28ff\u28ff\u28f7\u28bf\u28fd\u28ff\u28ff\u28f7\u28ff\u28f7\u28c6\u2839\u28ff\u28f6\u28ef\u283f\u28ff\u28f6\u28df\u28fb\u28bf\u28f7\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2880\u28ef\u28df\u2880\u2847\n\u28c7\u2839\u28df\u28fe\u28fb\u28ff\u28ff\u28be\u287d\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u28b9\u28f6\u28ff\u28fb\u28f7\u28ef\u28df\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2880\u287f\u2847\u28b8\u2847\n\u28ff\u28c6\u2839\u28f7\u287b\u28fd\u28ff\u28ef\u28bf\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2807\u28b8\u28ff\u2807\u28fc\u2847\n\u2859\u283e\u28c6\u2839\u28ff\u28e6\u281b\u28ff\u28af\u28f7\u28bf\u287d\u28ff\u28ff\u28ff\u28ff\u28c6\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2803\u280e\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u2880\u28ff\u28fe\u28e3\u287f\u2847\n\u28ff\u28f7\u284c\u28a6\u2819\u28ff\u28ff\u28cc\u283b\u28fd\u28af\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28e7\u2829\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284f\u28b0\u28a3\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2880\u2880\u28bf\u28de\u28f7\u28bf\u2847\n\u28ff\u28fd\u28c6\u2839\u28e7\u2818\u28ff\u28ff\u2877\u28cc\u2819\u28b7\u28ef\u2877\u28df\u28ff\u28ff\u28ff\u28f7\u2840\u2879\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c8\u2803\u28f8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2880\u28f4\u2867\u2880\u2838\u28ff\u287d\u28ff\u2880\n\u28bb\u28fd\u28ff\u2844\u28bb\u28f7\u2848\u28bf\u28ff\u28ff\u28a7\u2880\u2819\u28bf\u28fb\u287e\u28fd\u28fb\u28ff\u28ff\u28c4\u280c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2881\u28f0\u28fe\u28df\u287f\u2880\u2844\u28bf\u28df\u28ff\u2880\n\u2844\u28bf\u28ff\u28f7\u2880\u2839\u28df\u28c6\u283b\u28ff\u28ff\u28c6\u2880\u28c0\u2809\u283b\u28ff\u287d\u28ef\u28ff\u28ff\u28f7\u28c8\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2880\u28e0\u2818\u28ef\u28f7\u28ff\u285f\u2880\u2886\u2838\u28ff\u285f\u28b8\n\u28f7\u2848\u28bf\u28ff\u28c7\u28b1\u2858\u28bf\u28f7\u28ec\u28d9\u283f\u28e7\u2818\u28c6\u2880\u2808\u283b\u28f7\u28df\u28fe\u28bf\u28ff\u28c6\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28e0\u285e\u28a1\u28ff\u2880\u28ff\u28ff\u28ff\u2807\u2844\u28b8\u2844\u28bb\u2847\u28fc\n\u28ff\u28f7\u2848\u28bf\u28ff\u2846\u28a3\u2840\u2819\u28be\u28df\u28ff\u28ff\u28f7\u2848\u2802\u2818\u28e6\u2848\u283f\u28ef\u28ff\u28be\u28ff\u28c6\u2819\u283b\u283f\u283f\u283f\u283f\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u281b\u288b\u28e0\u28fe\u285f\u28a0\u28ff\u28ff\u2880\u28ff\u28ff\u285f\u28a0\u28ff\u2888\u28e7\u2818\u28a0\u28ff\n\u28ff\u28ff\u28ff\u28c4\u283b\u28ff\u2844\u28b3\u2844\u2886\u2859\u283e\u28fd\u28ff\u28ff\u28c6\u2840\u28b9\u2877\u28c4\u2819\u28bf\u28ff\u287e\u28ff\u28c6\u2880\u2840\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u28c0\u28e0\u28f4\u287f\u28ef\u280f\u28e0\u28ff\u28ff\u284f\u28b8\u28ff\u287f\u2881\u28ff\u28ff\u2880\u28ff\u2806\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28c6\u28bb\u284c\u28bf\u28f6\u28a4\u28c9\u28d9\u28ff\u28f7\u2840\u2819\u283d\u2837\u2804\u2839\u28ff\u28df\u28ff\u28c6\u2899\u28cb\u28e4\u28e4\u28e4\u28c4\u28c0\u2880\u2880\u2880\u2880\u28fe\u28ff\u28df\u2877\u28ef\u287f\u2883\u28fc\u28ff\u28ff\u28ff\u2807\u28fc\u285f\u28e1\u28ff\u28ff\u28ff\u2880\u287f\u28a0\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ee\u28ff\u28ff\u28ff\u284c\u2801\u28a4\u28e4\u28e4\u28e4\u28ec\u28ed\u28f4\u28f6\u28f6\u28f6\u28c6\u2808\u28bb\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28e4\u28cc\u28c9\u2858\u281b\u283b\u2836\u28ff\u28ff\u28ff\u28ff\u285f\u28f0\u28eb\u28f4\u28ff\u28ff\u28ff\u28ff\u2804\u28f7\u28ff\u28ff\u28ff\n*/\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class k{\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{ \n\t\tScanner s=new Scanner(System.in);\n\n\t\tint t=s.nextInt();\n\t\tfor(int ie=0;ie<t;ie++) {\n\t\t\t\n\t\t\tint n=s.nextInt();\n\t\t\tint k=s.nextInt();\n\t\t\t\n\t\t\tint flag=0;\n\t\t\t\n\t\t\tint[] x=new int[n];\n\t\t\tint[] y=new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i]=s.nextInt();\n\t\t\t\ty[i]=s.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint h=0;\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tif(j!=i) {\n\t\t\t\t\t\tif(Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j])>k) {\n\t\t\t\t\t\t\th=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(h==0) {\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(flag==1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define mp make_pair\n#define pb push_back\n#define ip pair<ll,ll>\n#define iip pair<pair<ll,ll>,int>\n#define ff first\n#define ss second\n#define MAX 2000005\n#define f(j,i,k) for(ll j=i;j<k;j++)\n#define fe(j,i,k) for(ll j=i;j<=k;j++)\n#define fr(j,i,k) for(ll j=i;j>=k;j--)\n\nconst ll MOD = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll t;\n    cin>>t;\n    while(t--){\n        ll n,k;\n        cin>>n>>k;\n        ll x[n];\n        ll y[n];\n        f(i,0,n)\n            cin>>x[i]>>y[i];\n        ll A[n][n];\n        f(i,0,n)\n            f(j,0,n){\n                if(i==j){\n                    A[i][j]=0;\n                    continue;\n                }\n                A[i][j]=LLONG_MAX;\n                if(abs(x[i]-x[j])+abs(y[i]-y[j])<=k)\n                    A[i][j]=1;\n                \n            }\n\n        ll found=0;\n        f(i,0,n){\n            ll here=1;\n            f(j,0,n){\n                if(A[i][j]==LLONG_MAX){\n                    here=0;\n                    break;\n                }\n            }\n            if(here){\n                found=1;\n                break;\n            }\n                \n        }\n        if(found)\n            cout<<1<<endl;\n        else\n        {\n            cout<<-1<<endl;\n        }\n        \n    //     f(i,0,n){\n    //         f(j,0,n){\n    //             cout<<A[i][j]<<\" \";\n    //         }\n    //         cout<<endl;\n    // }\n    //     cout<<endl;\n    //     ll dist[n][n];\n    //     f(i,0,n)\n    //         f(j,0,n)\n    //             dist[i][j]=A[i][j];\n    //     f(k,0,n)\n    //         f(i,0,n)\n    //             f(j,0,n){\n    //                 if (dist[i][k]!=LLONG_MAX && dist[k][j]!=LLONG_MAX && dist[i][k] + dist[k][j] < dist[i][j])  \n    //                     dist[i][j] = dist[i][k] + dist[k][j];\n    //             }\n    //        f(i,0,n){\n    //         f(j,0,n){\n    //             cout<<dist[i][j]<<\" \";\n    //         }\n    //         cout<<endl;\n    // }\n    //     ll mymax=LLONG_MIN;\n    //     f(i,0,n)\n    //         f(j,0,n)\n    //             if(dist[i][j]>mymax)\n    //                 mymax=dist[i][j];\n    //     if(mymax==LLONG_MAX){\n    //         cout<<-1<<endl;\n    //     }\n    //     else\n    //     {\n    //         if(mymax&1)\n    //         {\n\n    //         }\n    //         cout<<max(1ll,mymax-2)<<endl;\n    //     }\n        \n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            Scanner sc = new Scanner(in);\n            \n            int T = sc.nextInt();\n            nextT:\n            for (int t = 0; t < T; t++) {\n                int n = sc.nextInt();\n                int k = sc.nextInt();\n\n                int[] xs = new int[n];\n                int[] ys = new int[n];\n\n                for (int i = 0; i < n; i++) {\n                    xs[i] = sc.nextInt();\n                    ys[i] = sc.nextInt();\n                }\n\n                cand:\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (Math.abs(xs[i] - xs[j]) + Math.abs(ys[i] - ys[j]) > k) continue cand;\n                    }\n                    out.println(1);\n                    continue nextT;\n                }\n\n                out.println(-1);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include \"bits/stdc++.h\"\n\n#define ll long long\nusing namespace std;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int>> a(n, vector<int>(2));\n    bool sw = 1;\n    for (int i = 0; i < n; i++)\n        cin >> a[i][0] >> a[i][1];\n    for(int i = 0; i < n; i++) {\n        bool flag = 0;\n        for (int j = 0; j < n; j++){\n            if (i != j && abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) > k) {\n                flag = 1;\n                break;\n            }\n        }\n        if(!flag){\n            sw = 0;\n            break;\n        }\n    }\n    if(!sw)\n        cout << 1 << endl;\n    else\n        cout << -1 << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n  public static void solve(BufferedReader br) throws IOException {\n    String[] s = br.readLine().split(\" \");\n    int n = Integer.parseInt(s[0]);\n    int k = Integer.parseInt(s[1]);\n\n    // all points can be moved to the same point if and only if there exist some point i\n    // such that all other points lie within the boundary\n    int[][] points = new int[n][2];\n    \n    for (int i=0; i<n; i++) {\n      s = br.readLine().split(\" \");\n      points[i][0] = Integer.parseInt(s[0]);\n      points[i][1] = Integer.parseInt(s[1]);\n    }\n\n    for (int i=0; i<n; i++) {\n      int count = 0;\n      for (int j=0; j<n; j++) {\n        if (j==i) continue;\n        if (Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]) > k) {\n          break;\n        } else {\n          count++;\n        }\n      }\n      if (count == n-1) {\n        System.out.println(1);\n        return;\n      }\n    }\n    \n    System.out.println(-1);\n    return;\n  }\n\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int t = Integer.parseInt(br.readLine());\n    while (t-- > 0) {\n      solve(br);\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n\ndef main(balls, k):\n    n = len(balls)\n    x, y = balls[0]\n    for x, y in balls:\n        good = True\n        for _x, _y in balls:\n            if abs(x-_x)+abs(y-_y) > k:\n                good = False\n                continue\n        if good:\n            return 1\n    return -1\n\n\nif __name__ == '__main__':\n    n, k = -1, -1\n    n_tests = -1\n    balls = []\n    for line in sys.stdin:\n        if n_tests == -1:\n            n_tests = int(line.strip())\n            n, k = -1, -1\n        elif n == k == -1:\n            n, k = [int(c) for c in line.strip().split()]\n        else:\n            balls.append([int(c) for c in line.strip().split()])\n            if len(balls) == n:\n                print(main(balls, k))\n                balls = []\n                n, k = -1, -1\n"
        },
        {
            "language": 3,
            "solution": "t = int(input())\n\n\ndef dist(x1, x2, y1, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    nums = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        nums.append([x, y])\n    ans = -1\n    for i in range(n):\n        mx = 0\n        for j in range(n):\n            mx = max(mx, dist(nums[i][0], nums[j][0], nums[i][1], nums[j][1]))\n        if mx <= k:\n            ans = 1\n\n    print(ans)\n    \n    \n    \n    \n            \n\n        \n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\n\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\n public class Codeforces {\n\t \n\n\t   \n\t static class FastReader\n\t    {BufferedReader br; \n\t        StringTokenizer st; \n\t public FastReader() \n\t        {  br = new BufferedReader(new\n\t                     InputStreamReader(System.in)); \n\t        } \n\t  \n\t       String next() \n\t        { \n\t            while (st == null || !st.hasMoreElements()) \n\t            { \n\t                try\n\t                { \n\t                    st = new StringTokenizer(br.readLine()); \n\t                } \n\t                catch (IOException  e) \n\t                { \n\t                    e.printStackTrace(); \n\t                } \n\t            } \n\t            return st.nextToken(); \n\t        } \n\t  \n\t        int nextInt() \n\t        { \n\t            return Integer.parseInt(next()); \n\t        } \n\t  \n\t        long nextLong() \n\t        { \n\t            return Long.parseLong(next()); \n\t        } \n\t  \n\t        double nextDouble() \n\t        { \n\t            return Double.parseDouble(next()); \n\t        } \n\t  \n\t        String nextLine() \n\t        { \n\t            String str = \"\"; \n\t            try\n\t            { \n\t                str = br.readLine(); \n\t            } \n\t            catch (IOException e) \n\t            { \n\t                e.printStackTrace(); \n\t            } \n\t            return str; \n\t        } \n\t    } \n\n\t \n\t\n\t \n\t \n\t    public static void main(String[] args)\n\t    {\n\t    \n\t    \tFastReader s=new FastReader();\n\t    \tint t=s.nextInt();\n\t    \t\n\t    \twhile(t-->0)\n\t    \t{\n\t    \t\n\t    \t\t\n\t    \tint n=s.nextInt();\n\t    \tint k=s.nextInt();\n\t    \t\n\t    \tint[] x=new int[n];\n\t    \tint[] y=new int[n];\n\t    \t\n\t    \t\n\t    \tfor(int i=0;i<n;i++)\n\t    \t{\n\t    \t\tx[i]=s.nextInt();\n\t    \t\ty[i]=s.nextInt();\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t}\n\t    \t\n\t    \tint max=Integer.MIN_VALUE;\n\t    \tfor(int i=0;i<n;i++)\n\t    \t{int count=0;\n\t    \t\tfor(int j=0;j<n;j++)\n\t    \t\t{\n\t    \t\t\tint sum=Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j]);\n\t    \t\t\t\n\t    \t\t\tif(sum<=k)\n\t    \t\t\t\tcount++;\n\t    \t\t\t\n\t    \t\t}//System.out.println(count);\n\t    \t\tmax=Math.max(max, count);\n\t    \t}\n\t    \t\n\t    \tif(max==n)\n\t    \t\tSystem.out.println(\"1\");\n\t    \telse System.out.println(\"-1\");\n\t    \t\n\t    \t\n\t    \t\t\n\t    \t\t\n\t    \t\t\n\t    \t}\n\t    }\n\t}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author revanth\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BBallsOfSteel solver = new BBallsOfSteel();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BBallsOfSteel {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n            while (t-- > 0) {\n                int n = in.nextInt(), k = in.nextInt();\n                ArrayList<Pair> al = new ArrayList<>();\n                for (int i = 0; i < n; i++)\n                    al.add(new Pair(in.nextInt(), in.nextInt()));\n                Collections.sort(al);\n                boolean flag1 = false;\n                for (int i = 0; i < n; i++) {\n                    boolean flag = true;\n                    for (int j = 0; j < n; j++) {\n                        int dist = Math.abs(al.get(i).x - al.get(j).x) + Math.abs(al.get(i).y - al.get(j).y);\n                        flag &= (dist <= k);\n                    }\n                    if (flag) {\n                        flag1 = true;\n                        break;\n                    }\n                }\n                out.println(flag1 ? \"1\" : \"-1\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int snumChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class Pair implements Comparable<Pair> {\n        public int x;\n        public int y;\n\n        public Pair(int x1, int y1) {\n            this.x = x1;\n            this.y = y1;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return x == pair.x &&\n                    y == pair.y;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n\n        public int compareTo(Pair p) {\n            if (x == p.x)\n                return Integer.compare(y, p.y);\n            return Long.compare(x, p.x);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Arange {\n\n     public static void main(String[] args) {        \n        Scanner sc=new Scanner(System.in);\n        \n        int t=sc.nextInt();\n        for(int w=0;w<t;w++){\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int a[][]=new int [n][2];\n            for(int i=0;i<n;i++){\n                for(int j=0;j<2;j++){\n                    a[i][j]=sc.nextInt();\n                }\n            }\n            int min=-1;\n            \n            for(int i=0;i<n;i++){\n                int f=0;\n                for(int j=0;j<n;j++){\n                    if(i!=j&&k<Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1])){\n                        f=1;\n                        break;\n                    }\n                }\n                if(f==0){\n                    min=1;\n                    break;\n                }\n            }\n            \n            System.out.println(min);\n            \n        }\n    }\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n \n //---------------------------------------------------------\n \n//#define _FILE_IO_ // Testing with I/O\n#define WLIB_DEF // WLIB - Utility functions\n#define WIO_DEF // WIO - Generic I/O functions\n \n//---------------------------------------------------------\n \n#ifdef WLIB_DEF\n/* Utility functions collection\n * Math Functions: _gcd_, _lcm_, _fact_, _pow_, _inv_, _C_, _A_\n * String Functions: _zfunc_, _pfunc_, _isPalindrome_\n * Vector Functions: _pSum_\n */\nnamespace WLIB{\n    \n    #define MYDEFS\n    #ifdef MYDEFS\n \n    // DFS\n    #define __graph_(t,name,siz) std::vector< std::vector<t> > name(siz)\n    #define __add_edge_(g,a,b) g[a].push_back(b); g[b].push_back(a)\n    \n    // loops\n    // #define __FOR_(it,st,nd)_ ___aux_FOR_ ## #(st<=nd)_(it,st,nd)\n    // #define __aux_FOR_true_(it,st,nd) for(int it = st; it <= nd; it++)\n    // #define __aux_FOR_false_(it,st,nd) for(int it = st; it >= nd; it--)\n \n    #endif\n \n    namespace LIB_TYPES {\n        typedef long long lint;\n    }\n \n    // >>> Math Functions <<<\n \n    // Greatest common divisor | Time: log(N) | Memory: 1\n    LIB_TYPES::lint _gcd_(LIB_TYPES::lint a, LIB_TYPES::lint b) {\n        if(b == 0) return a;\n        return _gcd_(b, a%b);\n    }\n \n    // Least common multiple | Time: log(N) | Memory: 1\n    LIB_TYPES::lint _lcm_(LIB_TYPES::lint a, LIB_TYPES::lint b) {\n        return (a * b) / _gcd_(a,b);\n    }\n \n    // Factorial of n by modulo mod | Time: N | Memory: 1\n    LIB_TYPES::lint _fact_(LIB_TYPES::lint n, LIB_TYPES::lint mod) {\n        LIB_TYPES::lint fct = 1;\n        for(LIB_TYPES::lint i = 1; i <= n; i++)\n            fct = (fct * i) % mod;\n        return fct % mod;\n    }\n \n    //  pw-th power of x by modulo mod| Time: log(pw) | Memory: 1\n    LIB_TYPES::lint _pow_(LIB_TYPES::lint base, LIB_TYPES::lint pw, LIB_TYPES::lint mod) {\n        LIB_TYPES::lint ans = 1ll;\n        while(pw > 0ll) {\n            if(pw & 1ll)\n                ans = (ans * base) % mod;\n \n            pw = pw >> 1ll;\n            base = (base * base) % mod;\n        }\n        return ans % mod;\n    }\n \n    // Inverse of x by modulo mod | Time: log(mod) | Memory: 1\n    LIB_TYPES::lint _inv_(LIB_TYPES::lint x, LIB_TYPES::lint mod) {\n        return _pow_(x, mod-2, mod) % mod;\n    }\n \n    // C by modulo mod | Time: N + log(mod) | Memory: 1\n    LIB_TYPES::lint _C_(LIB_TYPES::lint n, LIB_TYPES::lint m, LIB_TYPES::lint mod) {\n        return (_fact_(n, mod) * _inv_( ((_fact_(m, mod) * _fact_(n-m, mod)) % mod), mod)) % mod;\n    }\n \n    // A by module mod | Time: N + log(mod) | Memory: 1\n    LIB_TYPES::lint _A_(LIB_TYPES::lint n, LIB_TYPES::lint m, LIB_TYPES::lint mod) {\n        return (_fact_(n, mod) * _inv_( _fact_(n-m, mod), mod)) % mod;\n    }\n    \n    // List of prime numbers less or equal to N\n    std::vector<LIB_TYPES::lint> _primes_until_(LIB_TYPES::lint N) {\n        std::vector<bool> isPrime(N+1,true);\n        std::vector<LIB_TYPES::lint> primes;\n\n        for(LIB_TYPES::lint i = 2; i <= N; i++) {\n            if(!isPrime[i]) continue;\n            primes.push_back(i);\n            for(LIB_TYPES::lint j = i*i; j <= N; j+=i)\n                isPrime[j] = false;\n        }\n\n        return primes;\n    }\n\n    // >>> String Functions <<<\n \n    // P function | Time: N | Memory: N\n    vector<int> _pfunc_(string str) {\n        vector<int> p(str.length(),0);\n        \n        for(int i = 1, j = 0; i < str.length(); i++) {\n            while(j > 0 && str[j] != str[i]) {\n                j = p[j-1];\n            }\n            if(str[i] == str[j]) j++;\n            p[i] = j;\n        }\n \n        return p;\n    }\n \n    // Z function | Time: N | Memory: N\n    vector<int> _zfunc_(string str) {\n        vector<int> z(str.size(),0);\n \n        for(int i = 1, l = 0, r = 0; i < str.size(); i++) {\n            if(i <= r)\n                z[i] = min(z[i-l],r-i+1);\n \n            while(i+z[i]<str.size() && str[i+z[i]] == str[z[i]])\n                z[i]++;\n \n            if(z[i]-1 > r && z[i] != 0) {\n                l = i;\n                r = z[i] - 1;\n            }\n        }\n \n        return z;\n    }\n \n    // Is the string Palindrome or Not | Time: N | Memory: N\n    bool _isPalindrome_(string str, int L=0, int R=-1) {\n        if(R == -1) R = str.length()-1;\n        \n        while(L < R) {\n            if(str[L] != str[R])\n                return false;\n            L++; R--;\n        }\n \n        return true;\n    }\n \n    // >>> Vector Functions <<<\n \n    // Prefix sum | Time: N | Memory: N\n    template <class T>\n    vector<T> _pSum_(vector<T> v) {\n        for(int i = 1; i < v.size(); i++)\n            v[i] += v[i-1];\n        return v;\n    }\n \n}\n#endif\n \n#ifdef WIO_DEF\n/* Generic I/O functions\n * Functions: _readV_, _printV_\n * Defines: __endl_\n */ \nnamespace WIO{\n \n    #define __endl_ cout<<endl;\n \n    // Read vector | Time: N | Memory: 1\n    template <class T>\n    void _readV_(vector<T> &v, int offset = 0, int n = -1) {\n        if(n == -1) n = v.size()-1;\n        for(int i = offset; i <= n; i++)\n            cin >> v[i];\n    }\n \n    // Print vector | Time: N | Memory: N\n    template <class T>\n    void _printV_(vector<T> v, int offset = 0, int n = -1) {\n        if(n == -1) n = v.size()-1;\n        for(int i = offset; i <= n; i++)\n            cout << v[i] << \" \";\n    }\n \n    bool WIO_DEBUG_LOGS_FLAG = false;\n \n    void _log_(string s) {\n        if(WIO_DEBUG_LOGS_FLAG)\n            cout << \"LOG:: \" << s << endl;\n    }\n \n    void _elog_(string s) {\n        if(WIO_DEBUG_LOGS_FLAG)\n            cout << \"ERROR:: \" << s << endl;\n    }\n \n    void _celog_(string s) {\n        if(WIO_DEBUG_LOGS_FLAG)\n            cout << \"CRITICAL_ERROR::\" << s << endl;\n        assert(0);\n    }\n \n}\n#endif\n \n//---------------------------------------------------------\n \n#define for_in_range(i,s,f) for(int i = s; i <= f; i++)\n \ntypedef long long lint;\ntypedef vector<lint> vlint;\ntypedef vector<vector<int>> matrix_int;\ntypedef vector<vector<lint>> matrix_lint;\n#define fi first\n#define se second\n \nconst lint MOD = 1e9+7;\nconst lint PRIME = 31;\nconst lint LOG = 30;\nconst lint INF = INT64_MAX;\nconst lint MAXN= 1e6;\n\nvoid solve();\n\nint main() {\n \n    //---------------------Local flags-------------------------\n    //---------------------------------------------------------\n        //#define _FILE_IO_\n        //WIO::WIO_DEBUG_LOGS_FLAG = true;\n    //---------------------------------------------------------\n    \n    ios_base::sync_with_stdio(false);\n    \n    #ifdef _FILE_IO_\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    \n    int tst = 1;\n    cin >> tst;\n    while(tst--)\n        solve();\n\n}\n\nvoid solve() {\n    lint n, k;\n    cin >> n >> k;\n    vector<pair<lint,lint>> v;\n    for(int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        v.push_back({x,y});\n    }\n    \n    for(int i = 0; i < n; i++) {\n        lint flag = true;\n        for(int j = 0; j < n; j++) {\n           // cout <<v[i].first << \" \"<<v[i].second<<\" \"<< abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second) << endl;\n            if(abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second) > k) {\n                flag = false;\n                break;\n            }\n        }\n            if(flag) {\n                cout << 1 << endl;\n                return;\n            }\n    }\n\n    cout << -1 << endl;\n    return;\n}\n"
        },
        {
            "language": 2,
            "solution": "/*\n       \uff0f\uff1e  \u30d5\n      |  _  _|\n     \uff0f`\u30df _x \u5f61     * MEOW *\n    /      |\n   /   \u30fd   \uff89\n\uff0f\uffe3|   | | |\n| (\uffe3\u30fd\uff3f_\u30fd_)_)\n\uff3c\u4e8c\u3064\n*/\n#include <bits/stdc++.h>\n#define ll long long \n#define db(x) cout << (#x) << \" = \" << x << \"\\n\" ;\n#define pb push_back\n#define mt make_tuple\n#define F first\n#define S second\nusing namespace std;\nbool comp(pair <ll , ll> &a , pair <ll , ll> &b){\n  ll s1 = a.F + a.S , s2 = b.F + b.S;\n  if(s1==s2){\n    return a.F < b.F;\n  } else return s1 < s2;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n#ifndef ONLINE_JUDGE \n  freopen(\"input.txt\", \"r\", stdin); \n  freopen(\"output.txt\", \"w\", stdout); \n#endif\n  /* uWu */\n    ll t;\n    cin >> t;\n    while(t--){\n      ll n , k;\n      cin >> n >> k;\n      vector <  pair < ll , ll > > arr;\n      for(ll i = 0;i<n;i++){\n        ll a , b;\n        cin >> a >> b;\n        arr.pb({a,b});\n      }\n      ll extreme_d = 0 ,  found = 0;\n      for(ll i=0;i<n;i++){\n        ll a = arr[i].F , b = arr[i].S;\n        found = 1;\n        for(ll j=0;j<n;j++){\n          ll c = arr[j].F , d = arr[j].S;\n          if(abs(a-c) + abs(b-d)>k) found = 0;\n        }\n        if(found) break;\n      }\n      if(found){\n        cout << 1 << \"\\n\";\n      } else {\n        cout << -1 << \"\\n\";\n      }\n    }\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string ss ;\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define mp make_pair\n#define pb push_back\n\n\n\nvoid solve(){\n       ll n,k=0,q=0;\n       string s;\n      cin >> n >> k ;\n      ll x[n],y[n];\n      for(int i=0 ; i<n ; i++){\n          cin >> x[i] >> y[i];\n      }\n      bool ok=false;\n      for(int i=0 ; i<n ; i++){\n          for(int j=0 ; j<n ; j++){\n            if(abs(x[i]-x[j]) + abs(y[i]-y[j]) <= k){\n              q++;\n            }\n            if(q==n) ok=true;\n      } q=0;\n      }\n      cout << (ok ? \"1\\n\" : \"-1\\n\") ;\n      \n   \n}\n\n\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int t=1;\n    cin >> t;\n    while(t--)\n     solve();\n    return 0;\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class BallsofSteel {\n\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\tfor(int t1=1;t1<=t;t1++)\n\t\t{\n\t\t\tint n=sc.nextInt();\n\t\t\tint k=sc.nextInt();\n\t\t\t\n\t\t\tint sum=0;\n\t\t\tint a[][]=new int[n][2];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble d=Math.abs(a[i][0]-a[j][0])+Math.abs(a[i][1]-a[j][1]);\n\t\t\t\t\tif(d>k*1.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum==n)\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\n\t\t}\n\t\tsc.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<time.h>\n#include<bitset>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(int i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(int i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst int N=1e5+7;\nconst int INF=1e9+7;\nint T,n,k;\nint X[N],Y[N];\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d%d\",&n,&k);\n\t\trep(i,n)scanf(\"%d%d\",&X[i],&Y[i]);\n\t\tbool ans=0;\n\t\trep(i,n){\n\t\t\tbool fl=1;\n\t\t\trep(j,n)if(abs(X[i]-X[j])+abs(Y[i]-Y[j])>k)fl=0;\n\t\t\tif(fl){\n\t\t\t\tans=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans)puts(\"1\");\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconst int INF = 1e9 + 13;\nconst int N = 112;\n\nvector<int> g[N];\nint d[N];\npii a[N];\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n\n//    for(int i = 0; i < n; i++) {\n//        g[i].erase(g[i].begin(), g[i].end());\n////        for(int j = 0; j < n; j++) {\n////            d[i][j] = INF;\n////        }\n//    }\n\n    for(int i = 0; i < n; i++) {\n        cin >> a[i].f >> a[i].s;\n    }\n\n    for(int i = 0; i < n; i++) {\n        int cnt = 0;\n        for(int j = 0; j < n; j++) {\n            if(abs(a[i].f - a[j].f) + abs(a[i].s - a[j].s) <= k) {\n                cnt++;\n            }\n        }\n\n        if(cnt == n) {\n            cout << 1 << endl;\n            return;\n        }\n    }\n\n   cout << -1 << endl;\n}\n\nint main() {\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "def canCollapse(balls, k):\n\tif len(balls) <= 1:\n\t\treturn True\n\t\t\n\tfor a in balls:\n\t\tfound = 0\n\t\tfor b in balls:\n\t\t\tif abs(a[0] - b[0]) + abs(a[1] - b[1]) <= k:\n\t\t\t\tfound += 1\n\t\tif found <= 1:\n\t\t\treturn False\n\t\tif found == len(balls):\n\t\t\treturn True\n\t\n\treturn False\n\nt = int(input())\nfor i in range(t):\n\tn, k = map(int, input().split(\" \"))\n\tballs = []\n\tfor j in range(n):\n\t\tballs.append(list(map(int, input().split(\" \"))))\n\tprint(1 if canCollapse(balls, k) else -1)"
        },
        {
            "language": 1,
            "solution": "import sys\ntesting = len(sys.argv) > 2 and sys.argv[1] == \"i.txt\" and sys.argv[2] == \"o.txt\"\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    input = open(sys.argv[1], 'r').readline\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    input = sys.stdin.readline\n\n# from collections import defaultdict\n############ ---- Input Functions ---- ############\ndef intin():\n    return(int(input()))\ndef inltin():\n    return(list(map(int,input().split())))\ndef chrltin():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef strin():\n    s = input()\n    return s[:len(s) - 1]\n    \ndef main():\n    n, k = inltin()\n    p = []\n    for _ in xrange(n):\n        p.append(inltin())\n    e = []\n    for i in xrange(n-1):\n        for j in xrange(i+1, n):\n            if abs(p[i][0]-p[j][0]) + abs(p[i][1]-p[j][1]) <= k:\n                e.append([i,j])\n    cnt = [0]*n\n    for i,j in e:\n        cnt[i] += 1\n        cnt[j] += 1\n    print(1 if max(cnt)==n-1 else -1)\n\n\nif __name__ == \"__main__\":\n    for _ in xrange(intin()):\n        main()\n\n    if testing:\n        sys.stdout = cmd\n        print(int(round(time() * 1000))  - start_time)"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class B{\n \n  public static void main(String[] args) {\n    try (Scanner sc = new Scanner(System.in)) {\n      int t = sc.nextInt();\n      while (t-- > 0) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[][] points = new int[n][2];\n        for (int i = 0; i < n; i++) {\n          points[i][0] = sc.nextInt();\n          points[i][1] = sc.nextInt();\n        }\n        int cnt = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n          int localCnt = 0;\n          for (int j = 0; j < n; j++) {\n            if (i != j) {\n              if(manDistance(points, i, j) <= k)\n                localCnt++;\n            }\n          }\n          cnt = Math.max(cnt, localCnt);\n        }\n        System.out.println(cnt == n - 1 ? 1 : -1);\n      }\n    }\n  }\n \n  private static int manDistance(int[][] points, int p, int q) {\n    return Math.abs(points[p][0] - points[q][0]) + Math.abs(points[p][1] - points[q][1]);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "t=int(input())\nfor i in range(t):\n    n1,k=map(int,input().strip().split())\n    l=[]\n    for i in range(n1):\n        x,y=map(int,input().strip().split())\n        l.append([x,y])\n    flag=0\n    y=0\n    for j in l:\n        flag=0\n        for m in l:\n            s=abs(j[0]-m[0])\n            s+=abs(j[1]-m[1])\n            if s>k:\n               flag=1\n               break\n        if flag==0:\n            y=1\n            break\n    if y==1:\n        print(\"1\")\n    else:\n        print(\"-1\")\n    \n    \n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Map.Entry;\n\n\nimport java.io.*;\nimport java.math.*;\nimport static java.util.stream.Collectors.*;\nimport static java.util.Map.Entry.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\t\n\tpublic static void main (String[] args) throws IOException\n\t{\n\t\tfinal long mod=(long) (1e9+7);  \n\t\tReader s=new Reader();\n\t\t  PrintWriter pt=new PrintWriter(System.out);\n//\t\t  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t  int T=s.nextInt();\n//\t\t  int T=Integer.parseInt(br.readLine());\n//\t\t  int T=1;\n\t\t  while(T-->0)\n\t\t  {\n\t\t\t  int n=s.nextInt();\n\t\t\t  int k=s.nextInt();\n\t\t\t  int x[]=new int[n];\n\t\t\t  int y[]=new int[n];\n\t\t\t  for(int i=0;i<n;i++) {\n\t\t\t\t  x[i]=s.nextInt();\n\t\t\t\t  y[i]=s.nextInt();\n\t\t\t  }\n\t\t\t  int score[]=new int[n];\n\t\t\t  for(int i=0;i<n;i++) {\n\t\t\t\t  for(int j=0;j<n;j++) {\n\t\t\t\t\t  if(Math.abs(x[i]-x[j])+Math.abs(y[i]-y[j])<=k) {\n\t\t\t\t\t\t  score[i]++;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  boolean flag = false;\n\t\t\t  for(int i=0;i<n;i++) {\n\t\t\t\t  if(score[i]==n)\n\t\t\t\t\t  flag=true;\n\t\t\t  }\n\t\t\t  if(flag)\n\t\t\t\t  pt.println(1);\n\t\t\t  else\n\t\t\t\t  pt.println(-1);\n\t\t  }\n\t\t  pt.close();\n\t}\n\tstatic boolean isSorted(int arr[], int n) {\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tif(arr[i]>=arr[i-1]==false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic int setBit(int S, int j) { return S | 1 << j; }\n\n\tstatic int clearBit(int S, int j) { return S & ~(1 << j); }\n\n\tstatic int toggleBit(int S, int j) { return S ^ 1 << j; }\n\n\tstatic boolean isOn(int S, int j) { return (S & 1 << j) != 0; }\n\n\tstatic int turnOnLastZero(int S) { return S | S + 1; }\n\t\n\tstatic int turnOnLastConsecutiveZeroes(int S) { return S | S - 1; }\n\t\n\tstatic int turnOffLastBit(int S) { return S & S - 1; }\n\t\n\tstatic int turnOffLastConsecutiveBits(int S) { return S & S + 1; }\n\n\tstatic int lowBit(int S) { return S & -S; }\n\n\tstatic int setAll(int N) { return (1 << N) - 1; }\n\n\tstatic int modulo(int S, int N) { return (S & N - 1); }\t\t //S%N, N is a power of 2\n\n\tstatic boolean isPowerOfTwo(int S) { return (S & S - 1) == 0; }\n\t\n\tstatic boolean isWithin(long x, long y, long d, long k) {\n\t\treturn x*k*x*k + y*k*y*k <= d*d;\n\t}\n\t\n\tstatic long modFact(long n, \n            long p) \n\t{ \n\t\tif (n >= p) \n\t\t return 0; \n\t\t\n\t\tlong result = 1; \n\t\tfor (int i = 1; i <= n; i++) \n\t\t result = (result * i) % p; \n\t\t\n\t\treturn result; \n\t} \n\tstatic int sum(int[] arr, int n)\n\t{\n\t    int inc[]=new int[n+1];\n\t    int dec[]=new int[n+1];\n\t    inc[0] = arr[0];\n\t    dec[0] = arr[0];\n\n\t    for (int i = 1; i < n; i++) {\n\t        for (int j = 0; j < i; j++) {\n\t            if (arr[j] > arr[i]) {\n\t                dec[i] = max(dec[i], inc[j] + arr[i]);\n\t            }\n\t            else if (arr[i] > arr[j]) {\n\t                inc[i] = max(inc[i], dec[j] + arr[i]);\n\t            }\n\t        }\n\t    }\n\t    return max(inc[n - 1], dec[n - 1]);\n\t}\n\tstatic long nc2(long a) {\n\t\treturn a*(a-1)/2;\n\t}\n\tpublic static int numberOfprimeFactors(int n) \n    { \n        // Print the number of 2s that divide n \n\t\tHashSet<Integer> hs = new HashSet<Integer>();\n        while (n%2==0) \n        { \n            hs.add(2);\n            n /= 2; \n        } \n  \n        // n must be odd at this point.  So we can \n        // skip one element (Note i = i +2) \n        for (int i = 3; i <= Math.sqrt(n); i+= 2) \n        { \n            // While i divides n, print i and divide n \n            while (n%i == 0) \n            { \n                hs.add(i);\n                n /= i; \n            } \n        } \n  \n        // This condition is to handle the case whien \n        // n is a prime number greater than 2 \n        if (n > 2) \n            hs.add(n);\n        return hs.size();\n    } \n\tstatic int gcd(int a, int b) \n    { \n      if (b == 0) \n        return a; \n      return gcd(b, a % b);  \n    } \n\n\n\n\n\t\n\n\tstatic void reverse(int arr[],int start, int end) \n\t{ \n\t\tint temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}  \n\tstatic void reverse(long arr[],int start, int end) \n\t{ \n\t\tlong temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}  \n\tstatic boolean isPrime(int n) \n    { \n        // Corner cases \n        if (n <= 1) return false; \n        if (n <= 3) return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n % 2 == 0 || n % 3 == 0) return false; \n      \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n            return false; \n      \n        return true; \n    } \n\tstatic int p2(int n) {\n\t\tint k=0;\n\t\twhile(n>1) {\n\t\t\tif(n%2!=0)\n\t\t\t\treturn k;\n\t\t\tn/=2;\n\t\t\tk++;\n\t\t}\n\t\treturn k;\n\t}\n\tstatic boolean isp2(int n) {\n\t\twhile(n>1) {\n\t\t\tif(n%2==1)\n\t\t\t\treturn false;\n\t\t\tn/=2;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic int binarySearch(int arr[], int first, int last, int key){  \n\t\t   int mid = (first + last)/2;  \n\t\t   while( first <= last ){  \n\t\t      if ( arr[mid] < key ){  \n\t\t        first = mid + 1;     \n\t\t      }else if ( arr[mid] == key ){  \n\t\t        return mid;  \n\t\t      }else{  \n\t\t         last = mid - 1;  \n\t\t      }  \n\t\t      mid = (first + last)/2;  \n\t\t   }  \n\t\t   return -1;\n\t\t }  \n\n\tstatic void print(int a[][]) {\n\t\tfor(int i=0;i<a.length;i++)\n\t\t{\n\t\t\tfor(int j=0;j<a[0].length;j++)\n\t\t\t\tSystem.out.print(a[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic int max (int x, int y) {\n\t\treturn (x > y)? x : y;\n\t} \n\tstatic int search(Pair[] p, Pair pair) {\n\t\tint l=0, r=p.length;\n\t\twhile (l <= r) { \n\t        int m = l + (r - l) / 2;\n\t        if (p[m].compareTo(pair)==0) \n\t            return m; \n\t        if (p[m].compareTo(pair)<0) \n\t            l = m + 1; \n\t        else\n\t            r = m - 1;\n\t    }\n\t    return -1;\n\t}\n\tstatic void pa(int a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t\t\n\t}\n\tstatic void pa(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t\t\n\t}\n\tstatic void reverseArray(int arr[], \n            int start, int end) \n\t{ \n\t\tint temp; \n\t\t   \n\t\twhile (start < end) \n\t\t{ \n\t\t    temp = arr[start];  \n\t\t    arr[start] = arr[end]; \n\t\t    arr[end] = temp; \n\t\t    start++; \n\t\t    end--; \n\t\t}  \n\t}     \n\tstatic boolean isPalindrome(String s) {\n\t\tint l=s.length();\n\t\tfor(int i=0;i<l/2;i++)\n\t\t{\n\t\t\tif(s.charAt(i)!=s.charAt(l-i-1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic long nc2(long n, long m) {\n\t\treturn (n*(n-1)/2)%m;\n\t}\n\tstatic long c(long a) {\n\t\treturn a*(a+1)/2;\n\t}\n\tstatic int next(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length - 1;  \n    \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;  \n    \n            // Move to right side if target is  \n            // greater.  \n            if (arr[mid] < target) {  \n                start = mid + 1;  \n            }  \n    \n            // Move left side.  \n            else {  \n                ans = mid;  \n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }  \n\n\tstatic long power(long x, long y, long p) \n    { \n        long res = 1; \n        x = x % p; \n                      \n        while (y > 0) \n        { \n            if (y % 2 == 1) \n                res = (res * x) % p; \n            y = y >> 1;\n            x = (x * x) % p; \n        } \n        return  res; \n    } \n    static long modInverse(long n, long p) \n    { \n        return power(n, p-2, p); \n    } \n    static long nCrModP(long n, long r, \n                                    long p) \n    { \n        if(r>n)\n        \treturn 0;\n    \tif (r == 0) \n            return 1; \n        long[] fac = new long[(int) (n+1)]; \n        fac[0] = 1; \n        for (int i = 1 ;i <= n; i++) \n            fac[i] = fac[i-1] * i % p; \n        return (fac[(int) n]* modInverse(fac[(int) r], p) \n                % p * modInverse(fac[(int) (n-r)], p) \n                                    % p) % p; \n    } \n\tstatic String reverse(String str)\n\t{\n\t\treturn new StringBuffer(str).reverse().toString();\n\t}\n\n\n\n\tstatic long fastpow(long x, long y, long m)  \n    { \n        if (y == 0) \n            return 1; \n          \n        long p = fastpow(x, y / 2, m) % m; \n        p = (p * p) % m; \n      \n        if (y % 2 == 0) \n            return p; \n        else\n            return (x * p) % m; \n    } \n\t\n\tstatic boolean isPerfectSquare(long l)\n\t{\n\t\treturn Math.pow((long)Math.sqrt(l),2)==l;\n\t}\n\t\n\t\n\tstatic void merge(long[] arr, int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    } \n\tstatic void merge(int arr[], int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(long arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    } \n    static class Pair implements Comparable<Pair>{\n        int a;\n        int b;\n        Pair(int a,int b){\n            this.a=a;\n \n            this.b=b;\n        }   \n        public int compareTo(Pair p){\n            if(a>p.a)\n                return 1;\n            if(a==p.a)\n                return (b-p.b);\n            return -1;\n        }\n    }\n\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[128]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n}"
        },
        {
            "language": 4,
            "solution": "//I AM THE CREED\n/* //I AM THE CREED\n/* package codechef; // don't place package name! */\nimport java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.StringTokenizer; \nimport java.util.*;\nimport java.awt.Point;\npublic class Main{\n    public static void main(String[] args) throws IOException \n    { \n        Scanner input=new Scanner(System.in);\n        input.nextInt();\n        while(input.hasNext()){\n            int n=input.nextInt();\n            int k=input.nextInt();\n            int[][] points=new int[n][2];\n            for(int i=0;i<n;i++){\n                points[i][0]=input.nextInt();\n                points[i][1]=input.nextInt();\n            }\n            boolean connected=false;\n            for(int i=0;i<n;i++){\n                boolean all=true;\n                for(int j=0;j<n;j++){\n                    if(i!=j){\n                        if(Math.abs(points[i][0]-points[j][0])+Math.abs(points[i][1]-points[j][1])>k){\n                            all=false;\n                        }\n                    }\n                }\n                if(all){\n                    connected=true;\n                    break;\n                }\n            }\n            System.out.println(connected?1:-1);\n            \n            \n            \n            \n        }\n\n        \n    }\n    static void solve(int alice, int bob){\n        if(alice==1){\n            System.out.println(0+\" \"+bob);\n            return;\n        }\n        if(bob==1){\n            System.out.println(alice-1+\" \"+bob);\n            return;\n        }\n        if(alice>=bob){\n            System.out.println((alice-bob)+\" \"+bob);\n            return;\n        }\n        solve(bob-1, alice-1);\n    }\n    \n    static boolean isPrime(int n)\n    {\n \n        // Check if number is less than\n        // equal to 1\n        if (n <= 1)\n            return false;\n \n        // Check if number is 2\n        else if (n == 2)\n            return true;\n \n        // Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        // If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2) \n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n \n    //Credits to SecondThread(https://codeforces.com/profile/SecondThread) for this tempelate.\n    static class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n    \n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nconst int maxn=105;\nusing namespace std;\nint t,n,k,sum[maxn],x[maxn],y[maxn];\nint calc(int i,int j){\n\treturn abs(x[i]-x[j])+abs(y[i]-y[j]);\n}\nint main(){\n\tscanf(\"%d\",&t);\n\tfor(;t;t--){\n\t\tmemset(sum,0,sizeof(sum));\n\t\tscanf(\"%d %d\",&n,&k);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n\t\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(calc(i,j)<=k)sum[i]++,sum[j]++;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(sum[i]==n-1){puts(\"1\");break;}\n\t\t\tif(i==n)puts(\"-1\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict,deque\nimport sys\nimport bisect\ninput=sys.stdin.readline\n\nt=int(input())\nfor ii in range(t):\n    n,k=map(int,input().split())\n    store=[]\n    for i in range(n):\n        x,y=map(int,input().split())\n        store.append((x,y))\n    check=[0]*(n)\n    for i in range(n):\n        for j in range(n):\n            if i!=j:\n                manhat=abs(store[i][0]-store[j][0])+abs(store[i][1]-store[j][1])\n                if manhat<=k:\n                    check[i]+=1\n    if (n-1) in check:\n        print(1)\n    else:\n        print(-1)\n    \n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nT = int(input())\nfor _ in range(T):\n    N, K = map(int, input().split())\n    X = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        X.append((x, y))\n    for i, (x, y) in enumerate(X):\n        for j, (x2, y2) in enumerate(X):\n            # print(\"x, x2, y, y2 =\", x, x2, y, y2)\n            if abs(x - x2) + abs(y - y2) > K:\n                break\n        else:\n            print(1)\n            break\n    else:\n        print(-1)\n\n"
        },
        {
            "language": 4,
            "solution": "//package CodeForces;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport javafx.util.Pair;\n\npublic class Main {\n\n    public static MyScanner sc = new MyScanner();\n    public static int MOD = 1000000007;\n    // __builtin_popcountll(n) <-- c++ // binary count(1) ex. 8 --> 0100 --> 1\n    HashSet<Integer> set = new HashSet<>();\n    HashMap<Integer, Integer> map = new HashMap<>();\n    Random r = new Random();\n    ArrayList<Integer> l = new ArrayList<>();\n    LinkedList<Integer> link = new LinkedList<>();\n    public static int[][] dp;\n\n    /* ********************************* main ********************************* */\n    public static void main(String[] args) {\n        int t = 1;\n        t = sc.nextInt();\n        while(t-->0){\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            ArrayList<MyPair> l = new ArrayList<>();\n            for (int i = 0; i < n; i++) l.add(new MyPair(sc.nextInt(), sc.nextInt()));\n            boolean ok = false;\n            for (int i = 0, c = 0; i < n && !ok; i++, c = 0) {\n                for (int j = 0; j < n; j++) {\n                    int dif1 = Math.abs(l.get(i).x - l.get(j).x);\n                    int dif2 = Math.abs(l.get(i).y - l.get(j).y);\n                    if(dif1 + dif2 <= k) c++;\n                }\n                if(c == n) ok = true;\n            }\n            System.out.println(ok ? 1 : -1);\n        }\n    }\n    /* ********************************* End ********************************* */\n\n    public static ArrayList<Integer> factorize(Long n){\n        HashSet<Integer> set = new HashSet<>();\n        while(n%2 == 0){\n            set.add(2);\n            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {\n            while (n % i == 0) {\n                set.add(i);\n                n /= i;\n            }\n        }\n        ArrayList<Integer> l = new ArrayList<>(set);\n        return l;\n    }\n    \n    public static boolean contain(Queue q1, Queue q2, int i){\n        return containQ1(q1, q2, q1.size() - 1) && containQ2(q2, q1, q2.size() - 1);\n    }\n    \n    public static boolean containQ1(Queue q1, Queue q2, int i){\n        if(i == -1) return true;\n        if(q2.contains(q1.peek())){\n            q1.add(q1.remove()); \n            return containQ1(q1, q2, i - 1);\n        }\n        return false;\n    }\n    \n    public static boolean containQ2(Queue q1, Queue q2, int i){\n        if(i == -1) return true;\n        if(q2.contains(q1.peek())){\n            q1.add(q1.remove()); \n            return containQ2(q1, q2, i - 1);\n        }\n        return false;\n    }\n    \n    public static void removeLast(ArrayList a, int l){\n        if(l == a.size() - 1){\n            a.remove(l);\n            return;\n        }\n        removeLast(a, ++l);\n    }\n    public static double m(int i){\n        if(i == 0) return 0;\n        if(i == 1) return 1;\n        return 1.0/i + m(--i);\n    }\n    \n    public static void reverse(LinkedList a, int l, int r){\n        if(l > r) return;\n        a.add(l, a.remove(r));\n        reverse(a, ++l, r);\n    }\n        \n    public static int BinarySearch(int[] a, int v, int f, int l){\n        if(f > l) return -1;\n        int mid = (f + l)/2;\n        if(a[mid] == v)\n            return mid;\n        if(v < a[mid])\n            return BinarySearch(a, v, f, mid - 1);\n        else\n            return BinarySearch(a, v, mid + 1, l);\n    }\n    \n    public static int gcdEuclids(int m, int n){\n        int r = m % n;\n        while (r != 0) {\n            m = n;\n            n = r;\n            r = m % n;\n        }\n        return n;\n    }\n\n    public static int gcd(int m, int n){\n        return n != 0 ? gcd(n, m%n) : n;\n    }\n    \n    \n    \n    public static class MyScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static class MyPair {\n\n        int x;\n        int y;\n\n        public MyPair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public String toString() {\n            return \"[\" + x  + \", \" + y + \"]\";\n        }\n        \n    }\n\n    public static int Fibonacci(int n) {\n        int[] a = new int[n + 1];\n        a[0] = 0;\n        a[1] = 1;\n        for (int i = 2; i < a.length; i++) {\n            a[i] = a[i - 1] + a[i - 2];\n        }\n        return a[n];\n    }\n\n    public static boolean isprime(long n) {\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int[] addarr(int[] a, int n) {\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        return a;\n    }\n\n    public static long factt(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * factt(n - 1);\n    }\n\n    public static long sumDigit(long n) {\n        int a = 0;\n        while (n != 0) {\n            a += n % 10;\n            n /= 10;\n        }\n        return a;\n    }\n\n    public static long pow(long n, long p) {\n        return p == 0 ? 1 : n * pow(n, p - 1);\n    }\n\n    public static long fastpow(long v, long p) {\n        if (p == 0) {\n            return 1;\n        }\n        if (p == 1) {\n            return v;\n        }\n        long ans = fastpow(v, p / 2);\n        if (p % 2 == 1) {\n            return ans * ans * v;\n        } else {\n            return ans * ans;\n        }\n    }\n    \n    public static int LCS(String s1, String s2, int i, int j) {\n//        String s1 = sc.next();\n//        String s2 = sc.next();\n//        dp = new int[s1.length()][s2.length()];\n//        System.out.println(LCS(s1, s2, s1.length()-1, s2.length()-1));\n        if (i == -1 || j == -1) {\n            return 0;\n        } else if (dp[i][j] != 0) {\n            return dp[i][j];\n        } else if (s1.charAt(i) == s2.charAt(j)) {\n            return dp[i][j] = 1 + LCS(s1, s2, i - 1, j - 1);\n        } else {\n            return dp[i][j] = Math.max(LCS(s1, s2, i - 1, j), LCS(s1, s2, i, j - 1));\n        }\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "for test in range(int(input())):\n    n, k = list(map(int, input().split()))\n    balls = []\n    for i in range(n):\n        balls.append(tuple(map(int, input().split())))\n\n    balls.sort()\n    found = False\n\n    for c_ball in balls:\n        ok = True\n        for ball in balls:\n            ok &= abs(c_ball[0] - ball[0]) + abs(c_ball[1] - ball[1]) <= k\n        if ok:\n            found = True\n\n    if found:\n        print(1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 2,
            "solution": "/**Bismillahir Rahmanir Rarim**/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(c)              c.begin(), c.end()\n#define CC(x) cout << (x) << endl\n#define rep(i,n) for(int i=0;i<n;i++)\n#define FastRead ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define EPS 1e-9\n#define sz(v) int((v).size())\nconst unsigned long long inf=1e18;\nconst int range=1e6;\nconst long long inff=1e-12;\nconst int dx[] = { 0, 1, -1, 0 };\nconst int dy[] = { -1, 0, 0, 1 };\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) {if (b == 0)return a;return gcd(b, a % b);}\nusing namespace std;\nbool cmp(const pair<ll,ll>&a, const pair<ll,ll>&b){return (a.se>b.se);}\nvoid vecp(vector<ll>v){for(int i=0;i<sz(v);i++){cout <<v[i]<<\" \";}cout <<endl;}\nint main()\n{\n    FastRead\n    ll x,y,l,r,n,c,z,a=0,b=0,cas=1,d,x1,x2,y1,y2,t,N,mx=0,k;\n    cin >> t;\n    while(t--){\n        cin >>x>>k;\n        vector<pair<int,int>>p(x);\n        for(int i=0;i<x;i++){\n            cin >>p[i].fi >>p[i].se;\n        }\n        sort(all(p));\n        int f=0,ff=0;\n        for(int i=0;i<x;i++){\n            f=0;\n            for(int j=0;j<x;j++){\n                if(i!=j){\n                    ll a=abs(p[i].fi-p[j].fi);\n                    ll b=abs(p[i].se-p[j].se);\n                    if(a+b<=k){\n                        continue;\n                    }\n                    else{\n                        f=1;\n                        break;\n                    }\n                }\n            }\n            if(f==0){\n               ff=1;\n               break;\n            }\n\n        }\n        if(ff==0){\n            cout <<-1 <<endl;\n        }\n        else{\n            cout <<1 <<endl;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 1791791791;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n\nstruct Point{\n    ll x;\n    ll y;\n};\n\nint main()\n{\n    fast_cin();\n    ll t,n,k;\n    cin >> t;\n    forn(d,t){\n        cin >> n >> k;\n        vector<Point> v(n);\n        forn(i,n){\n            cin >> v[i].x >> v[i].y;\n        }\n        bool isCan = false;\n        forn(i,n){\n            bool f = true;\n            forn(j,n){\n                if((abs(v[i].x - v[j].x) + abs(v[i].y - v[j].y)) > k){\n                    f = false;\n                    break;\n                }\n            }\n            if(f) isCan = true;\n        }\n        if(isCan){\n            cout << 1 << ln;\n        }\n        else{\n            cout << -1 << ln;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\n\npublic class Main {\n\n\tpublic static void main(final String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tfinal FastScanner fs = new FastScanner();\n\t\tfinal java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n\t\tsolve(fs, out);\n\t\tout.flush();\n\t}\n\n\tpublic void solve(final FastScanner fs, final java.io.PrintWriter out) {\n\t\tint t = fs.nextInt();\n\t\tcont2: while(t --> 0) {\n\t\t\tfinal int n = fs.nextInt(), k = fs.nextInt();\n\t\t\tfinal Point[] p = new Point[n];\n\t\t\tfor (int i = 0;i < n;++ i) p[i] = new Point(fs.nextInt(), fs.nextInt());\n\t\t\tcont: for (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < n;++ j) {\n\t\t\t\t\tif (Math.abs(p[i].x - p[j].x) + Math.abs(p[i].y - p[j].y) > k) continue cont;\n\t\t\t\t}\n\t\t\t\tout.println(1);\n\t\t\t\tcontinue cont2;\n\t\t\t}\n\t\t\tout.println(-1);\n\t\t}\n\t}\n}\n\nclass FastScanner {\n\n\tprivate final java.io.InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[8192];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) return true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (final java.io.IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn buflen > 0;\n\t}\n\n\tprivate byte readByte() {\n\t\treturn hasNextByte() ? buffer[ptr++ ] : -1;\n\t}\n\n\tprivate static boolean isPrintableChar(final byte c) {\n\t\treturn 32 < c || c < 0;\n\t}\n\n\tprivate static boolean isNumber(final int c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++ ;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile (isPrintableChar(b = readByte()))\n\t\t\tsb.appendCodePoint(b);\n\t\treturn sb.toString();\n\t}\n\n\tpublic final char nextChar() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\treturn (char)readByte();\n\t}\n\n\tpublic final long nextLong() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tlong n = 0;\n\t\ttry {\n\t\t\tbyte b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\treturn n;\n\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\tdo\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\twhile (isNumber(b = readByte()));\n\t\t} catch (final java.util.NoSuchElementException e) {}\n\t\treturn n;\n\t}\n\n\tpublic final int nextInt() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tint n = 0;\n\t\ttry {\n\t\t\tbyte b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\treturn n;\n\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\tdo\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\twhile (isNumber(b = readByte()));\n\t\t} catch (final java.util.NoSuchElementException e) {}\n\t\treturn n;\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n\nclass Arrays {\n\n\tpublic static void sort(final int[] array) {\n\t\tint l, min = 0xFFFFFFFF, max = 0;\n\t\tfor (l = 0; l < array.length; ++l) {\n\t\t\tfinal int i = array[l];\n\t\t\tmin &= i;\n\t\t\tmax |= i;\n\t\t\tif ((i & 0x80000000) == 0) break;\n\t\t}\n\t\tfor (int r = l + 1; r < array.length; ++r) {\n\t\t\tfinal int i = array[r];\n\t\t\tmin &= i;\n\t\t\tmax |= i;\n\t\t\tif ((i & 0x80000000) != 0) {\n\t\t\t\tarray[r] = array[l];\n\t\t\t\tarray[l++ ] = i;\n\t\t\t}\n\t\t}\n\t\tfinal int use = min ^ max, bit = Integer.highestOneBit(use & 0x7FFFFFFF);\n\t\tif (bit == 0) return;\n\t\tsort(array, 0, l, use, bit);\n\t\tsort(array, l, array.length, use, bit);\n\t}\n\n\tprivate static void sort(final int[] array, final int left, final int right, final int use, int digit) {\n\t\tif (right - left <= 96) {\n\t\t\tfor (int i = left + 1; i < right; ++i) {\n\t\t\t\tfinal int tmp = array[i];\n\t\t\t\tint tmp2, j;\n\t\t\t\tfor (j = i; j > left && (tmp2 = array[j - 1]) > tmp; --j)\n\t\t\t\t\tarray[j] = tmp2;\n\t\t\t\tarray[j] = tmp;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint l = left;\n\t\twhile (l < right && (array[l] & digit) == 0)\n\t\t\t++l;\n\t\tfor (int r = l + 1; r < right; ++r) {\n\t\t\tfinal int i = array[r];\n\t\t\tif ((i & digit) == 0) {\n\t\t\t\tarray[r] = array[l];\n\t\t\t\tarray[l++ ] = i;\n\t\t\t}\n\t\t}\n\t\tif ((digit = Integer.highestOneBit(use & digit - 1)) == 0) return;\n\t\tsort(array, left, l, use, digit);\n\t\tsort(array, l, right, use, digit);\n\t}\n\n\tpublic static void sort(final long[] array) {\n\t\tint l;\n\t\tlong min = 0xFFFFFFFFFFFFFFFFL, max = 0;\n\t\tfor (l = 0; l < array.length; ++l) {\n\t\t\tfinal long i = array[l];\n\t\t\tmin &= i;\n\t\t\tmax |= i;\n\t\t\tif ((i & 0x8000000000000000L) == 0) break;\n\t\t}\n\t\tfor (int r = l + 1; r < array.length; ++r) {\n\t\t\tfinal long i = array[r];\n\t\t\tmin &= i;\n\t\t\tmax |= i;\n\t\t\tif ((i & 0x8000000000000000L) != 0) {\n\t\t\t\tarray[r] = array[l];\n\t\t\t\tarray[l++ ] = i;\n\t\t\t}\n\t\t}\n\t\tfinal long use = min ^ max, bit = Long.highestOneBit(use & 0x7FFFFFFFFFFFFFFFL);\n\t\tif (bit == 0) return;\n\t\tsort(array, 0, l, use, bit);\n\t\tsort(array, l, array.length, use, bit);\n\t}\n\n\tprivate static void sort(final long[] array, final int left, final int right, final long use, long digit) {\n\t\tif (right - left <= 96) {\n\t\t\tfor (int i = left + 1, j; i < right; ++i) {\n\t\t\t\tfinal long tmp = array[i];\n\t\t\t\tlong tmp2;\n\t\t\t\tfor (j = i; j > left && (tmp2 = array[j - 1]) > tmp; --j)\n\t\t\t\t\tarray[j] = tmp2;\n\t\t\t\tarray[j] = tmp;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint l = left;\n\t\twhile (l < right && (array[l] & digit) == 0)\n\t\t\t++l;\n\t\tfor (int r = l + 1; r < right; ++r) {\n\t\t\tfinal long i = array[r];\n\t\t\tif ((i & digit) == 0) {\n\t\t\t\tarray[r] = array[l];\n\t\t\t\tarray[l++ ] = i;\n\t\t\t}\n\t\t}\n\t\tif ((digit = Long.highestOneBit(use & digit - 1)) == 0) return;\n\t\tsort(array, left, l, use, digit);\n\t\tsort(array, l, right, use, digit);\n\t}\n}\n\nclass IntMath {\n\n\tpublic static int gcd(int a, int b) {\n\t\twhile (a != 0)\n\t\t\tif ((b %= a) != 0) a %= b;\n\t\t\telse return a;\n\t\treturn b;\n\t}\n\n\tpublic static int gcd(final int... array) {\n\t\tint ret = array[0];\n\t\tfor (int i = 1; i < array.length; ++i)\n\t\t\tret = gcd(ret, array[i]);\n\t\treturn ret;\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\twhile (a != 0)\n\t\t\tif ((b %= a) != 0) a %= b;\n\t\t\telse return a;\n\t\treturn b;\n\t}\n\n\tpublic static long gcd(final long... array) {\n\t\tlong ret = array[0];\n\t\tfor (int i = 1; i < array.length; ++i)\n\t\t\tret = gcd(ret, array[i]);\n\t\treturn ret;\n\t}\n\n\tpublic static long lcm(final long a, final long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tpublic static int pow(final int a, int b) {\n\t\tint ans = 1;\n\t\tfor (int mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\tpublic static long powLong(final long a, long b) {\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\tpublic static int pow(final int a, int b, final int mod) {\n\t\tif (b < 0) b = b % (mod - 1) + mod - 1;\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul = mul * mul % mod)\n\t\t\tif ((b & 1) != 0) ans = ans * mul % mod;\n\t\treturn (int)ans;\n\t}\n\n\tpublic static int floorsqrt(final long n) {\n\t\treturn (int)Math.sqrt(n + 0.1);\n\t}\n\n\tpublic static int ceilsqrt(final long n) {\n\t\treturn n <= 1 ? (int)n : (int)Math.sqrt(n - 0.1) + 1;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main\n{\t\n\tclass Pair\n\t{\n\t\tint x;\n\t\tint y;\n\t\tpublic Pair(int x,int y)\n\t\t{\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tMain main=new Main();\n\t\tScanner sc=new Scanner(System.in);\n\t\tArrayList<Pair> list=new ArrayList<Pair>(100);\n\t\tint t=sc.nextInt();\n\t\tfor(int i=0;i<t;i++)\n\t\t{\n\t\t\tint n=sc.nextInt();\n\t\t\tint k=sc.nextInt();\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tint y=sc.nextInt();\n\t\t\t\tlist.add(main.new Pair(x, y));\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint mx=0;\n\t\t\t\tPair aj=list.get(j);\n\t\t\t\tfor(int m=0;m<n;m++)\n\t\t\t\t{\n\t\t\t\t\tPair am=list.get(m);\n\t\t\t\t\tmx=Math.max(mx, Math.abs(aj.x-am.x)+Math.abs(aj.y-am.y));\n\t\t\t\t}\n\t\t\t\tif(mx<=k)\n\t\t\t\t\tans=1;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tlist.clear();\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n_tests = int(input())\nfor test in range(n_tests):\n    [n, k] = input().split(' ')\n    k = int(k)\n    d = []\n    n = int(n)\n    for i in range(n):\n        p = input().split(' ')\n        p = [int(w) for w in p]\n        d.append(p)\n    md = []\n    t = False\n    for i in range(n):\n        q = d[i]\n        a = 0\n        for j in range(n):\n            s = abs(q[0] - d[j][0]) + abs(q[1] - d[j][1])\n            if s <= k:\n                a += 1\n        if a == n:\n            t = True\n            break\n    if t:\n        print(1)\n    else:\n        print(-1)"
        },
        {
            "language": 3,
            "solution": "test_case=int(input())\nfor ix in range(test_case):\n  n=[int(x) for x in input().split()]\n  no=n[0]\n  pow=n[1]\n  dist=[]\n  flag=False\n  for ixx in range(no):\n    point=[int(x) for x in input().split()]\n    dist.append(point)\n  for i in range(no):\n    count=0\n    \n    for j in range(no):\n      d=abs(dist[i][0]-dist[j][0])+abs(dist[i][1]-dist[j][1])\n      if d<=pow:\n        count=count+1\n    if count==no:\n      flag=True\n      break\n    \n  if flag:\n    print(\"1\")\n  else:\n    print(\"-1\")\n"
        }
    ]
}