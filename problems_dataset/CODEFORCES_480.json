{
    "name": "480_B. Long Jumps",
    "source": "CODEFORCES",
    "description": "Valery is a PE teacher at a school in Berland. Soon the students are going to take a test in long jumps, and Valery has lost his favorite ruler! \n\nHowever, there is no reason for disappointment, as Valery has found another ruler, its length is l centimeters. The ruler already has n marks, with which he can make measurements. We assume that the marks are numbered from 1 to n in the order they appear from the beginning of the ruler to its end. The first point coincides with the beginning of the ruler and represents the origin. The last mark coincides with the end of the ruler, at distance l from the origin. This ruler can be repesented by an increasing sequence a1, a2, ..., an, where ai denotes the distance of the i-th mark from the origin (a1 = 0, an = l).\n\nValery believes that with a ruler he can measure the distance of d centimeters, if there is a pair of integers i and j (1 \u2264 i \u2264 j \u2264 n), such that the distance between the i-th and the j-th mark is exactly equal to d (in other words, aj - ai = d). \n\nUnder the rules, the girls should be able to jump at least x centimeters, and the boys should be able to jump at least y (x < y) centimeters. To test the children's abilities, Valery needs a ruler to measure each of the distances x and y. \n\nYour task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances x and y. Valery can add the marks at any integer non-negative distance from the origin not exceeding the length of the ruler.\n\nInput\n\nThe first line contains four positive space-separated integers n, l, x, y (2 \u2264 n \u2264 105, 2 \u2264 l \u2264 109, 1 \u2264 x < y \u2264 l) \u2014 the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.\n\nThe second line contains a sequence of n integers a1, a2, ..., an (0 = a1 < a2 < ... < an = l), where ai shows the distance from the i-th mark to the origin.\n\nOutput\n\nIn the first line print a single non-negative integer v \u2014 the minimum number of marks that you need to add on the ruler.\n\nIn the second line print v space-separated integers p1, p2, ..., pv (0 \u2264 pi \u2264 l). Number pi means that the i-th mark should be at the distance of pi centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.\n\nExamples\n\nInput\n\n3 250 185 230\n0 185 250\n\n\nOutput\n\n1\n230\n\n\nInput\n\n4 250 185 230\n0 20 185 250\n\n\nOutput\n\n0\n\n\nInput\n\n2 300 185 230\n0 300\n\n\nOutput\n\n2\n185 230\n\nNote\n\nIn the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.\n\nIn the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.\n\nIn the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills.",
    "difficulty": "B",
    "tags": [
        "binary search",
        "greedy",
        "implementation"
    ],
    "rating": 1700,
    "public_test": [
        {
            "input": "3 250 185 230\n0 185 250\n",
            "output": "1\n230\n"
        },
        {
            "input": "2 300 185 230\n0 300\n",
            "output": "2\n185 230\n"
        },
        {
            "input": "4 250 185 230\n0 20 185 250\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "4 100 90 91\n0 7 8 110\n",
            "output": "1\n98\n"
        },
        {
            "input": "3 10 1 5\n0 3 10\n",
            "output": "2\n1 5\n"
        },
        {
            "input": "3 10 7 8\n0 10 10\n",
            "output": "2\n7 8\n"
        },
        {
            "input": "5 550 175 400\n0 151 251 450 550\n",
            "output": "2\n175 400\n"
        },
        {
            "input": "112 1867 1261 1606\n0 7 17 43 67 70 87 112 129 141 148 162 179 180 189 202 211 220 231 247 250 277 308 311 327 376 400 406 409 417 418 444 480 512 514 515 518 547 572 575 578 587 612 617 654 684 701 742 757 761 788 821 825 835 841 843 850 858 869 872 881 936 939 969 970 971 997 1026 1040 817 1068 1070 1073 1076 1095 1110 1115 1154 1166 1178 1179 1203 1204 1225 1237 1241 1246 1275 1302 1305 1311 1312 1315 1338 1340 1419 1428 1560 1561 1576 1591 1594 1618 1643 1658 1660 1664 1689 1803 1822 1835 1867\n",
            "output": "1\n1808\n"
        },
        {
            "input": "4 100 80 81\n0 0 3 100\n",
            "output": "2\n80 81\n"
        },
        {
            "input": "4 1001 10 20\n0 500 530 1000\n",
            "output": "1\n510\n"
        },
        {
            "input": "6 504 400 500\n0 3 5 201 105 504\n",
            "output": "2\n400 500\n"
        },
        {
            "input": "6 12 7 10\n0 0 3 4 6 12\n",
            "output": "1\n10\n"
        },
        {
            "input": "16 115 62 112\n0 5 24 32 38 43 44 57 62 72 74 92 108 105 113 115\n",
            "output": "1\n112\n"
        },
        {
            "input": "18 187 27 157\n0 17 18 31 36 37 40 53 73 121 96 107 119 150 167 181 184 187\n",
            "output": "1\n27\n"
        },
        {
            "input": "4 300 4 5\n-1 6 7 300\n",
            "output": "1\n2\n"
        },
        {
            "input": "3 2 1 2\n0 0 2\n",
            "output": "1\n1\n"
        },
        {
            "input": "2 1000000000 100000000 247211576\n0 1000000000\n",
            "output": "2\n100000000 247211576\n"
        },
        {
            "input": "3 10 2 6\n0 9 10\n",
            "output": "2\n2 6\n"
        },
        {
            "input": "4 100 10 11\n0 4 10 100\n",
            "output": "1\n11\n"
        },
        {
            "input": "3 450 100 400\n0 75 450\n",
            "output": "2\n100 400\n"
        },
        {
            "input": "4 20 6 7\n0 1 12 20\n",
            "output": "1\n7\n"
        },
        {
            "input": "4 600 100 400\n0 50 350 733\n",
            "output": "1\n450\n"
        },
        {
            "input": "5 200000 1 100029\n0 100000 100009 100010 155981\n",
            "output": "1\n100029\n"
        },
        {
            "input": "19 180 117 148\n0 1 19 20 21 28 57 65 68 70 78 19 100 116 154 157 173 179 180\n",
            "output": "2\n117 148\n"
        },
        {
            "input": "4 300 120 189\n0 110 140 300\n",
            "output": "2\n120 189\n"
        },
        {
            "input": "5 401 300 400\n0 000 250 350 401\n",
            "output": "2\n300 400\n"
        },
        {
            "input": "3 8 1 3\n0 7 8\n",
            "output": "1\n3\n"
        },
        {
            "input": "5 1000 89 778\n0 1 500 501 1000\n",
            "output": "2\n89 778\n"
        },
        {
            "input": "3 11 3 5\n-1 9 11\n",
            "output": "1\n6\n"
        },
        {
            "input": "4 1000 900 901\n0 950 951 1001\n",
            "output": "1\n50\n"
        },
        {
            "input": "4 250 185 114\n0 20 185 250\n",
            "output": "1\n114\n"
        },
        {
            "input": "4 100 77 91\n0 7 8 110\n",
            "output": "2\n77 91\n"
        },
        {
            "input": "3 10 2 5\n0 3 10\n",
            "output": "1\n5\n"
        },
        {
            "input": "3 2 0 2\n0 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4 600 100 453\n0 50 350 733\n",
            "output": "2\n100 453\n"
        },
        {
            "input": "4 300 120 290\n0 110 140 300\n",
            "output": "2\n120 290\n"
        },
        {
            "input": "3 8 2 3\n0 7 13\n",
            "output": "2\n2 3\n"
        },
        {
            "input": "5 1000 126 778\n0 1 500 501 1000\n",
            "output": "2\n126 778\n"
        },
        {
            "input": "2 100 80 152\n0 0 3 100\n",
            "output": "2\n80 152\n"
        },
        {
            "input": "16 115 22 112\n0 5 24 11 38 43 44 57 62 72 74 92 108 105 113 115\n",
            "output": "2\n22 112\n"
        },
        {
            "input": "18 187 27 120\n0 17 18 31 36 37 40 53 73 121 96 107 97 150 167 181 184 187\n",
            "output": "1\n64\n"
        },
        {
            "input": "1 10 7 8\n0 5 6 10\n",
            "output": "2\n7 8\n"
        },
        {
            "input": "6 35 29 30\n0 10 15 31 32 35\n",
            "output": "1\n2\n"
        },
        {
            "input": "3 13 8 10\n0 2 21\n",
            "output": "1\n10\n"
        },
        {
            "input": "3 10 7 8\n0 4 10\n",
            "output": "2\n7 8\n"
        },
        {
            "input": "5 550 175 400\n0 200 251 450 550\n",
            "output": "2\n175 400\n"
        },
        {
            "input": "112 1867 1261 1606\n0 7 17 43 67 70 87 112 129 141 148 162 179 180 189 202 211 220 231 247 250 277 308 311 327 376 400 406 409 417 418 444 480 512 514 515 518 547 572 575 578 587 612 617 654 684 701 742 757 761 788 821 825 835 841 843 850 858 869 872 881 936 939 969 970 971 997 1026 1040 817 1068 1070 1073 1076 1095 1110 1115 1154 1166 1178 1179 1203 1204 1225 1012 1241 1246 1275 1302 1305 1311 1312 1315 1338 1340 1419 1428 1560 1561 1576 1591 1594 1618 1643 1658 1660 1664 1689 1803 1822 1835 1867\n",
            "output": "1\n1808\n"
        },
        {
            "input": "2 100 80 81\n0 0 3 100\n",
            "output": "2\n80 81\n"
        },
        {
            "input": "16 115 62 112\n0 5 24 11 38 43 44 57 62 72 74 92 108 105 113 115\n",
            "output": "1\n112\n"
        },
        {
            "input": "18 187 27 157\n0 17 18 31 36 37 40 53 73 121 96 107 97 150 167 181 184 187\n",
            "output": "1\n27\n"
        },
        {
            "input": "1 1000000000 100000000 247211576\n0 1000000000\n",
            "output": "2\n100000000 247211576\n"
        },
        {
            "input": "3 10 2 6\n-1 9 10\n",
            "output": "2\n2 6\n"
        },
        {
            "input": "4 100 10 11\n0 4 10 110\n",
            "output": "1\n11\n"
        },
        {
            "input": "5 150074 1 100029\n0 100000 100009 100010 155981\n",
            "output": "1\n100029\n"
        },
        {
            "input": "19 180 117 148\n0 2 19 20 21 28 57 65 68 70 78 19 100 116 154 157 173 179 180\n",
            "output": "2\n117 148\n"
        },
        {
            "input": "5 401 300 400\n0 110 250 350 401\n",
            "output": "2\n300 400\n"
        },
        {
            "input": "3 10 2 8\n0 3 10\n",
            "output": "1\n2\n"
        },
        {
            "input": "5 550 175 400\n0 10 251 450 550\n",
            "output": "2\n175 400\n"
        },
        {
            "input": "3 2 0 1\n0 0 2\n",
            "output": "1\n1\n"
        },
        {
            "input": "1 1000000010 100000000 247211576\n0 1000000000\n",
            "output": "2\n100000000 247211576\n"
        },
        {
            "input": "4 100 10 11\n0 6 10 110\n",
            "output": "1\n11\n"
        },
        {
            "input": "4 600 100 453\n1 50 350 733\n",
            "output": "2\n100 453\n"
        }
    ],
    "solution": [
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class D {\n\tprivate static BufferedReader in;\n\tprivate static StringTokenizer st;\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tst= new StringTokenizer(\"\");\n\t\tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tint l = nextInt();\n\t\tint x = nextInt();\n\t\tint y = nextInt();\n\t\tint a[] = new int [n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tboolean X = false;\n\t\tboolean Y = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ind = Arrays.binarySearch(a, a[i]+x);\n\t\t\tif(ind >= 0){\n\t\t\t\tX = true;\n\t\t\t}\n\t\t\tind = Arrays.binarySearch(a,a[i]+y);\n\t\t\tif(ind >= 0){\n\t\t\t\tY = true;\n\t\t\t}\n\t\t}\n\t\tif(X && Y){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ind = Arrays.binarySearch(a, a[i]+x+y);\n\t\t\tif(ind >= 0){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(a[i]+x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ind = Arrays.binarySearch(a, a[i] + y - x);\n\t\t\tif(ind >= 0){\n\t\t\t\tif(a[i] - x >=0){\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i]-x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(a[i] + y <=l){\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i]+y);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tif(!X){\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(a[i] - x >= 0){\n\t\t\t\t\tlist.add(a[i]-x);\n\t\t\t\t\tX = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(a[i] + x <= l){\n\t\t\t\t\tlist.add(a[i]+x);\n\t\t\t\t\tX = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!Y){\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(a[i] - y >= 0){\n\t\t\t\t\tlist.add(a[i]-y);\n\t\t\t\t\tY = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(a[i] + y <= l){\n\t\t\t\t\tlist.add(a[i]+y);\n\t\t\t\t\tY = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!X && !Y){\n\t\t\tlist.add(0);\n\t\t\tlist.add(x);\n\t\t\tlist.add(y);\n\t\t}else{\n\t\t\tif(!X){\n\t\t\t\tlist.add(0);\n\t\t\t\tlist.add(x);\n\t\t\t}\n\t\t\tif(!Y){\n\t\t\t\tlist.add(0);\n\t\t\t\tlist.add(y);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(list.size());\n\t\tfor (int i : list) {\n\t\t\tSystem.out.print(i+\" \");\n\t\t}\n\t\tout.close();\n\t}\n\n\tprivate static double nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tprivate static long nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate static int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate static String next() throws IOException {\n\t\twhile(!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], b[100005], ansx, ansy, n, qst, qed, now, ansk, x, y, l;\nbool find(int nx, int t) {\n  qst = 1;\n  qed = 1;\n  now = b[1];\n  while (qst <= n) {\n    if (now == nx) {\n      if (t == 0)\n        return 1;\n      else {\n        if (a[qed] - x >= 0 || a[qed] + y <= l) return 1;\n      }\n    }\n    if (qed < qst && now > nx) {\n      now -= b[qed];\n      qed++;\n    } else {\n      qst++;\n      now += b[qst];\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j, m;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    b[i - 1] = a[i] - a[i - 1];\n  }\n  n--;\n  if (!find(x, 0)) ansx++;\n  if (!find(y, 0)) ansy++;\n  if (x == y && ansx) {\n    printf(\"%d\\n%d\\n\", 1, x);\n  } else if (x != y && ansx && ansy) {\n    if (find(x + y, 0)) ansk++;\n    if (ansk) {\n      printf(\"1\\n%d\\n\", x + a[qed]);\n    } else {\n      if (find(y - x, 1)) ansk++;\n      if (ansk) {\n        printf(\"1\\n\");\n        if (a[qed] - x >= 0)\n          printf(\"%d\\n\", a[qed] - x);\n        else\n          printf(\"%d\\n\", a[qed] + y);\n      } else\n        printf(\"2\\n%d %d\\n\", x, y);\n    }\n  } else {\n    if (ansx + ansy == 2) {\n      printf(\"2\\n%d %d\\n\", x, y);\n    } else {\n      printf(\"%d\\n\", ansx + ansy);\n      if (ansx) printf(\"%d\\n\", x);\n      if (ansy) printf(\"%d\\n\", y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, bool> m;\nint n, l;\nlong long x, y;\nint s = -1;\nint main() {\n  ios::sync_with_stdio(false);\n  bool f1 = false, f2 = false;\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    long long t;\n    cin >> t;\n    m[t] = true;\n    if (t - x >= 0)\n      if (m[t - x]) f1 = true;\n    if (t - y >= 0)\n      if (m[t - y]) f2 = true;\n    if (t >= y && t - y + x >= 0 && m[t - y + x]) {\n      s = t - y;\n    }\n    if (t < y && t - y + x >= 0 && m[t - y + x]) {\n      if (t + x <= l) s = t + x;\n    }\n    if (t >= x + y && m[t - x - y]) s = t - x;\n    if (m[x]) f1 = true;\n    if (m[y]) f2 = true;\n  }\n  int res = (!f1) + (!f2);\n  if (res == 2) {\n    if (s != -1) {\n      cout << 1 << endl;\n      cout << s << \" \";\n      return 0;\n    }\n  }\n  cout << res << endl;\n  if (!f1) cout << x << \" \";\n  if (!f2) cout << y << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint aa[100000], n;\nint find(int x) {\n  int i, j;\n  for (i = 0, j = 0; i < n; i++) {\n    while (j < n && aa[j] - aa[i] < x) j++;\n    if (j < n && aa[j] - aa[i] == x) return i;\n  }\n  return -1;\n}\nint main() {\n  int l, x, y, i, ix, iy, j, tmp;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (i = 0; i < n; i++) scanf(\"%d\", &aa[i]);\n  ix = find(x);\n  iy = find(y);\n  if (ix != -1 && iy != -1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (ix != -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", y);\n    return 0;\n  }\n  if (iy != -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  i = find(x + y);\n  if (i != -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", aa[i] + x);\n    return 0;\n  }\n  i = find(y - x);\n  if (i != -1 && aa[i] + y <= l) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", aa[i] + y);\n    return 0;\n  }\n  for (i = 0, j = n - 1; i < j; i++, j--)\n    tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n  for (i = 0; i < n; i++) aa[i] = l - aa[i];\n  i = find(y - x);\n  if (i != -1 && aa[i] + y <= l) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", l - (aa[i] + y));\n    return 0;\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Ishani {\npublic static void main(String [] args){\nScanner in=new Scanner(System.in);\nint n=in.nextInt();\nlong l=in.nextLong();\nlong x=in.nextLong();\nlong y=in.nextLong();\nlong array[]=new long[n];\nHashSet<Long>hs=new HashSet<Long>();\nfor(int i=0;i<n;i++){\n\tarray[i]=in.nextLong();\n    hs.add(array[i]);\n}\n\n   boolean flag1=false;\n   boolean flag2=false;\n   boolean flag3=false;\n   boolean flag4=false;\n   long temp=0;\n   for(int i=0;i<n;i++){\n   \tif(hs.contains(array[i]+x))flag1=true;\n   \tif(hs.contains(array[i]+y))flag2=true;\n   \tif(hs.contains(array[i]+x-y) && array[i]+x<=l||hs.contains(array[i]+x-y) && array[i]-y >=0){\n   \t\tflag3=true;\n   \t    if(hs.contains(array[i]+x-y) && array[i]+x<=l)temp=(array[i]+x);\n   \t    else temp=(array[i]-y);\n   \t    //break;\n   \t}\n   \tif(hs.contains(array[i]+x+y)){\n   \t\tflag4=true;\n   \t\ttemp=array[i]+x;//break;\n   }\n   }\n   if(flag1 && flag2)\n   \tSystem.out.println(\"0\");\n   \t\n   else if(!flag1 && flag2){\n   \tSystem.out.println(\"1\");\n   \tSystem.out.println(x);\n   }\n   else if(flag1 && !flag2){\n   \tSystem.out.println(\"1\");\n   \tSystem.out.println(y);\n   }\n   else if(flag4){\n   \tSystem.out.println(\"1\");\n    System.out.println(temp);\n   }\n   else if(!flag1 && !flag2 && flag3){\n   \t System.out.println(\"1\");\n   \t System.out.println(temp);\n   }\n   else {\n   \tSystem.out.println(\"2\");\n   \tSystem.out.println(x+\" \"+y);\n}\n //if(n==99994)System.out.println(flag1+\" \"+flag2+\" \"+flag3 +\" \"+flag4 +\" \"+temp+\" \");\n}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class B {\n\n\tpublic B () {\n\t\tsc.nextInt();\n\t\tlong L = sc.nextLong(), X = sc.nextLong(), Y = sc.nextLong();\n\t\tlong [] A = sc.nextLongs();\n\n\t\tSet<Long> S = new TreeSet<>();\n\t\tfor (long a : A) S.add(a);\n\n\t\tint [] t = test(S, A, X, Y);\n\t\tint s = t[0] + t[1];\n\t\tif (s <= 1) {\n\t\t\tif (s == 0) exit(0);\n\t\t\telse if (t[0] == 0) println(1, Y);\n\t\t\telse println(1, X);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (long a : A)\n\t\t\tfor (long z : new long [] { a - X, a + X })\n\t\t\t\tif (z >= 0 && z <= L)\n\t\t\t\t\tif (S.contains(z - Y) || S.contains(z + Y)) {\n\t\t\t\t\t\tprintln(1, z);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\tprint(2);\n\t\texit(X, Y);\n\t}\n\n\tint [] test(Set<Long> S, long [] A, long X, long Y) {\n\t\tint xx = 1, yy = 1;\n\t\tfor (long a : A)  {\n\t\t\tif (S.contains(a + X))\n\t\t\t\txx = 0;\n\t\t\tif (S.contains(a + Y))\n\t\t\t\tyy = 0;\n\t\t}\n\t\treturn new int [] { xx, yy };\n\t}\n\n\t////////////////////////////////////////////////////////////////////////////////////\n\tprivate final static IOUtils.MyScanner sc = new IOUtils.MyScanner();\n\tprivate static void print (Object o, Object ... A) { IOUtils.print(o, A); }\n\tprivate static void println (Object o, Object p, Object ... A) { IOUtils.println(o, p, A); }\n\tprivate static void exit (Object o, Object ... A) { IOUtils.print(o, A); IOUtils.exit(); }\n\tprivate static class IOUtils {\n\t\tpublic static class MyScanner {\n\t\t\tpublic String next() { newLine(); return line[index++]; }\n\t\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\t\tpublic long nextLong() { return Long.parseLong(next()); }\n\t\t\tpublic String nextLine() { line = null; return readLine(); }\n\t\t\tpublic String [] nextStrings() { return split(nextLine()); }\n\t\t\tpublic long [] nextLongs() {\n\t\t\t\tString [] L = nextStrings();\n\t\t\t\tlong [] res = new long [L.length];\n\t\t\t\tfor (int i = 0; i < L.length; ++i)\n\t\t\t\t\tres[i] = Long.parseLong(L[i]);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t//////////////////////////////////////////////\n\t\t\tprivate boolean eol() { return index == line.length; }\n\t\t\tprivate String readLine() {\n\t\t\t\ttry {\n\t\t\t\t\treturn r.readLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate final java.io.BufferedReader r;\n\t\t\tprivate MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }\n\t\t\tprivate MyScanner (java.io.BufferedReader r) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.r = r;\n\t\t\t\t\twhile (!r.ready())\n\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\tstart();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] line;\n\t\t\tprivate int index;\n\t\t\tprivate void newLine() {\n\t\t\t\tif (line == null || eol()) {\n\t\t\t\t\tline = split(readLine());\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] split(String s) { return s.length() > 0 ? s.split(\" \") : new String [0]; }\n\t\t}\n\t\tprivate static String build(Object o, Object ... A) { return buildDelim(\" \", o, A); }\n\t\tprivate static String buildDelim(String delim, Object o, Object ... A) {\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tappend(b, o, delim);\n\t\t\tfor (Object p : A)\n\t\t\t\tappend(b, p, delim);\n\t\t\treturn b.substring(delim.length());\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////////////\n\t\tprivate static void start() { if (t == 0) t = millis(); }\n\t\tprivate static void append(StringBuilder b, Object o, String delim) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tappend(b, java.lang.reflect.Array.get(o, i), delim);\n\t\t\t} else if (o instanceof Iterable<?>)\n\t\t\t\tfor (Object p : (Iterable<?>) o)\n\t\t\t\t\tappend(b, p, delim);\n\t\t\telse {\n\t\t\t\tif (o instanceof Double)\n\t\t\t\t\to = new java.text.DecimalFormat(\"#.############\").format(o);\n\t\t\t\tb.append(delim).append(o);\n\t\t\t}\n\t\t}\n\t\tprivate static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);\n\t\tprivate static void print(Object o, Object ... A) { pw.println(build(o, A)); }\n\t\tprivate static void println(Object o, Object p, Object ... A) {\n\t\t\tprint(o); print(p);\n\t\t\tfor (Object q : A)\n\t\t\t\tprint(q);\n\t\t}\n\t\tprivate static void err(Object o, Object ... A) { System.err.println(build(o, A)); }\n\t\tprivate static void exit() {\n\t\t\tIOUtils.pw.close();\n\t\t\tSystem.out.flush();\n\t\t\terr(\"------------------\");\n\t\t\terr(IOUtils.time());\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tprivate static long t;\n\t\tprivate static long millis() { return System.currentTimeMillis(); }\n\t\tprivate static String time() { return \"Time: \" + (millis() - t) / 1000.0; }\n\t}\n\tpublic static void main (String[] args) { new B(); IOUtils.exit(); }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\n\t\tint cnt = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] - x == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (a[i] - x > 0) {\n\t\t\t\tint t = a[i] - x;\n\t\t\t\tif (Arrays.binarySearch(a, t) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n - 1) {\n\t\t\t\tcnt++;\n\t\t\t\tsb.append(x + \" \");\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] - y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (a[i] - y > 0) {\n\t\t\t\tint t = a[i] - y;\n\t\t\t\tif (Arrays.binarySearch(a, t) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n - 1) {\n\t\t\t\tcnt++;\n\t\t\t\tsb.append(y);\n\t\t\t}\n\t\t}\n\t\tif (cnt == 2) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint addX = a[i] + x;\n\t\t\t\tint addY = a[i] + y;\n\t\t\t\tint subX = a[i] - x;\n\t\t\t\tint subY = a[i] - y;\n\t\t\t\tif (addX <= l && Arrays.binarySearch(a, addX - y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (addX <= l && Arrays.binarySearch(a, addX + y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (addY <= l && Arrays.binarySearch(a, addY - x) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addY);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (addY <= l && Arrays.binarySearch(a, addY + x) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addY);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (subX >= 0 && Arrays.binarySearch(a, subX - y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(subX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (subX >= 0 && Arrays.binarySearch(a, subX + y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(subX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\t\tif (sb.length() > 0)\n\t\t\tSystem.out.println(sb);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Abc {\n    public static void main(String[] args) throws IOException {\n        FastReader sc = new FastReader();\n        int n=sc.nextInt(),l=sc.nextInt(),x=sc.nextInt(),y=sc.nextInt();\n        boolean xx=false,yy=false;\n        Set<Integer> s=new HashSet<>();\n        int arr[]=new int[n];\n        for (int i=0;i<n;i++){\n            int a=sc.nextInt();\n            s.add(a);\n            arr[i]=a;\n        }\n        for (int i:s){\n            int a=i+x,b=i+y;\n            if (s.contains(a)){\n                xx=true;\n            }\n            if (s.contains(b)){\n                yy=true;\n            }\n        }\n        if (xx && yy){\n            System.out.println(0);\n        }else if (xx && !yy){\n            System.out.println(1);\n            System.out.println(y);\n        }else if (!xx && yy){\n            System.out.println(1);\n            System.out.println(x);\n        }else {\n            for (int i:s){\n                int a=i+x+y;\n                if (s.contains(a)){\n                    System.out.println(1);\n                    System.out.println(i+x);\n                    return;\n                }\n            }\n            for (int i:s){\n                int d=y-x;\n                if (s.contains(d+i)){\n                    if (i+y<=l){\n                        System.out.println(1);\n                        System.out.println(i+y);\n                        return;\n                    }else if (i-x>=0){\n                        System.out.println(1);\n                        System.out.println(i-x);\n                        return;\n                    }\n                }\n            }\n            System.out.println(2);\n            System.out.println((arr[0]+x)+\" \"+(arr[0]+y));\n        }\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 10;\nconst long long INF = 1e18 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-10;\nconst double pi = acos(-1);\nint T, cases, n, m, t;\nset<int> s;\nint a[maxn];\nint main() {\n  ios::sync_with_stdio(false);\n  ;\n  int x, y;\n  cin >> n >> m >> x >> y;\n  for (int i = 1; i <= n; i++) cin >> a[i], s.insert(a[i]);\n  bool ans1 = 0, ans2 = 0;\n  for (int i = 1; i <= n; i++) {\n    if (s.count(a[i] - x) || s.count(a[i] + x)) ans1 = 1;\n    if (s.count(a[i] - y) || s.count(a[i] + y)) ans2 = 1;\n  }\n  if (ans1 && ans2)\n    cout << \"0\" << endl;\n  else if (ans1)\n    cout << \"1\\n\" << y << endl;\n  else if (ans2)\n    cout << \"1\\n\" << x << endl;\n  else {\n    for (int i = 1; i <= n; i++) {\n      int tmp = a[i] + x;\n      if (tmp <= m && (s.count(tmp - y) || s.count(tmp + y))) {\n        cout << \"1\\n\" << tmp << endl;\n        return 0;\n      }\n      tmp = a[i] - x;\n      if (tmp >= 0 && (s.count(tmp - y) || s.count(tmp + y))) {\n        cout << \"1\\n\" << tmp << endl;\n        return 0;\n      }\n      tmp = a[i] + y;\n      if (tmp <= m && (s.count(tmp - x) || s.count(tmp + x))) {\n        cout << \"1\\n\" << tmp << endl;\n        return 0;\n      }\n      tmp = a[i] - y;\n      if (tmp >= 0 && (s.count(tmp - x) || s.count(tmp + x))) {\n        cout << \"1\\n\" << tmp << endl;\n        return 0;\n      }\n    }\n    cout << \"2\\n\" << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class D {\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n    \n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public void solve() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        \n        int n = nextInt();\n        int l = nextInt();\n        int x = nextInt();\n        int y = nextInt();\n        \n        int [] values = new int[n];\n\n        for(int i = 0 ; i < n ; i++)\n            values[i] = nextInt();\n        \n        Arrays.sort(values);\n        \n        boolean xNeed = true;\n        boolean yNeed = true;\n        \n        int [] solutionsX = new int[2*n];\n        int [] solutionsY = new int[2*n];\n        int count1 = 0;\n        int count2 = 0;\n        for(int i = 0 ; i < n ; i++)\n        {\n            int val1 = Arrays.binarySearch(values, values[i] + x);\n            int val2 = Arrays.binarySearch(values, values[i] + y);\n            \n            int val3 = Arrays.binarySearch(values, values[i] - x);\n            int val4 = Arrays.binarySearch(values, values[i] - y);\n            \n            if(val1 >= 0)\n                xNeed = false;\n            else \n                if(values[i] + x < l)\n                    solutionsX[count1++] = values[i]+x;\n            \n            if(val2 >= 0)\n                yNeed = false;\n            else \n                if(values[i] + y < l)\n                    solutionsY[count2++] = values[i]+y;\n            \n            if(val3 >= 0)\n                xNeed = false;\n            else \n                if(values[i] - x > 0)\n                    solutionsX[count1++] = values[i]-x;\n            \n            if(val4 >= 0)\n                yNeed = false;\n            else \n                if(values[i] - y > 0)\n                    solutionsY[count2++] = values[i]-y;\n        }\n        \n        Arrays.sort(solutionsX);\n        Arrays.sort(solutionsY);\n        \n        if(xNeed && yNeed) {\n            for(int i = 0 ; i < solutionsX.length; i++)\n            {\n                if(solutionsX[i] == 0)\n                    continue;\n                int index = Arrays.binarySearch(solutionsY, solutionsX[i]);\n                if(index >= 0) {\n                    out.println(1);\n                    out.println(solutionsX[i]);\n                    out.close();\n                    return;\n                }\n            }\n            \n            out.println(2);\n            out.println(solutionsX[solutionsX.length-1]+\" \"+solutionsY[solutionsY.length-1]);\n            out.close();\n            return;\n        }\n        \n        if(xNeed) {\n            out.println(1);\n            out.println(solutionsX[solutionsX.length-1]);\n            out.close();\n            return;\n        }\n        \n        if(yNeed) {\n            out.println(1);\n            out.println(solutionsY[solutionsY.length-1]);\n            out.close();\n            return;\n        }\n        \n        out.println(0);\n        out.close();\n    }\n    \n    public static void main (String [] args) throws IOException {\n        new D().solve();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[(int)2e5 + 10];\nint n, l, x, y;\nmap<int, int> mp;\nint fnd(int num) { return (mp.count(num) > 0 && num >= 0 && num <= l); }\nint main() {\n  scanf(\"%d %d\", &n, &l);\n  scanf(\"%d %d\", &x, &y);\n  int a, b, c, d, ans = -1;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &arr[i]);\n    mp[arr[i]] = 1;\n  }\n  int mn = 3;\n  bool foundx = 0, foundy = 0;\n  for (int i = 0; i < n; i++) {\n    a = fnd(arr[i] + x);\n    b = fnd(arr[i] + y);\n    c = fnd(arr[i] - x);\n    d = fnd(arr[i] - y);\n    if (a || c) foundx = 1;\n    if (b || d) foundy = 1;\n    if (ans == -1) {\n      if (fnd(arr[i] + x + y)) ans = arr[i] + x;\n      if (arr[i] + x <= l && fnd(arr[i] + x - y)) ans = arr[i] + x;\n      if (arr[i] + x <= l && fnd(arr[i] + x + y)) ans = arr[i] + x;\n      if (arr[i] - x >= 0 && fnd(arr[i] - x - y)) ans = arr[i] - x;\n      if (arr[i] - x >= 0 && fnd(arr[i] - x + y)) ans = arr[i] - x;\n    }\n    if (foundx && foundy) {\n      mn = 0;\n      break;\n    }\n  }\n  if (foundx && foundy)\n    printf(\"%d\\n\", 0);\n  else if (ans != -1) {\n    printf(\"%d\\n\", 1);\n    printf(\"%d\\n\", ans);\n  } else if (foundx) {\n    printf(\"%d\\n\", 1);\n    printf(\"%d\\n\", y);\n  } else if (foundy) {\n    printf(\"%d\\n\", 1);\n    printf(\"%d\\n\", x);\n  } else {\n    printf(\"%d\\n\", 2);\n    printf(\"%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(\n\t\t\t\tnew BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tRoutine routine = new Routine();\n\t\troutine.run(in, out);\n\t\tout.flush();\n\t}\n}\n\nclass Routine {\n\tint n, l, x, y;\n\tint[] as = new int[200_005];\n\t\n\tpublic void run(Scanner in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tl = in.nextInt();\n\t\tx = in.nextInt();\n\t\ty = in.nextInt();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tint mask = 3;\n\t\t\n\t\tSet<Integer> set = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tset.add(as[i]);\n\t\t\tif (set.contains(as[i]-x)) {\n\t\t\t\tmask &= ~1;\n\t\t\t}\n\t\t\tif (set.contains(as[i]-y)) {\n\t\t\t\tmask &= ~2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (mask == 0) {\n\t\t\tout.println(0);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 1) {\n\t\t\tout.println(1);\n\t\t\tout.println(x);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 2) {\n\t\t\tout.println(1);\n\t\t\tout.println(y);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set.contains(as[i]-(x+y))) {\n\t\t\t\tout.println(1);\n\t\t\t\tout.println(as[i]-x);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\t\n\t\t\tif (set.contains(as[i]-(y-x))) {\n\t\t\t\tif (as[i]+x <= l) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]+x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (as[i]-(y-x)-x >= 0) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]-(y-x)-x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(2);\n\t\tout.println(x+\" \"+y);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> arr;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int v;\n    cin >> v;\n    arr.insert(v);\n  }\n  bool f1, f2, f3, f4;\n  int v3, v4;\n  f1 = f2 = f3 = f4 = false;\n  int res = 2147483647;\n  for (auto v : arr) {\n    f1 |= arr.count(v + x);\n    f2 |= arr.count(v + y);\n    if (arr.count(v + x + y)) {\n      f3 = true;\n      v3 = v + x;\n    }\n    if (arr.count(v + x - y)) {\n      if (v - y >= 0) {\n        f4 = true;\n        v4 = v - y;\n      } else if (v + x <= l) {\n        f4 = true;\n        v4 = v + x;\n      }\n    }\n  }\n  if (f1 && f2)\n    cout << 0 << endl;\n  else if (f1 || f2 || f3 || f4) {\n    cout << 1 << endl;\n    if (f1)\n      cout << y << endl;\n    else if (f2)\n      cout << x << endl;\n    else if (f3)\n      cout << v3 << endl;\n    else if (f4)\n      cout << v4 << endl;\n  } else\n    cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class B {\n\n    static StringTokenizer st;\n    static BufferedReader br;\n    static PrintWriter pw;\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int L = nextInt();\n        int x = nextInt();\n        int y = nextInt();\n        int[]a = new int[n+1];\n        boolean xx = false, yy = false; \n        for (int i = 1; i <= n; i++) {\n            a[i] = nextInt();\n        }\n        int right = 1;\n        for (int i = 1; i < n; i++) {\n            if (right <= i)\n                right = i+1;\n            while (right < n && a[right]-a[i] < x)\n                right++;\n            if (a[right]-a[i]==x) {\n                xx = true;\n                break;\n            }\n        }\n        right = 1;\n        for (int i = 1; i < n; i++) {\n            if (right <= i)\n                right = i+1;\n            while (right < n && a[right]-a[i] < y)\n                right++;\n            if (a[right]-a[i]==y) {\n                yy = true;\n                break;\n            }\n        }\n        if (xx && yy)\n            System.out.println(0);\n        else {\n            if (xx) {\n                System.out.println(1);\n                System.out.println(y);\n            }\n            else if (yy) {\n                System.out.println(1);\n                System.out.println(x);\n            }\n            else {\n                right = 1;\n                for (int i = 1; i < n; i++) {\n                    if (right <= i)\n                        right = i+1;\n                    while (right < n && a[right]-a[i] < y-x)\n                        right++;\n                    if (a[right]-a[i]==y-x && a[i] >= x) {\n                        System.out.println(1);\n                        System.out.println(a[i]-x);\n                        return;\n                    }\n                }\n                right  = 1;\n                for (int i = 1; i < n; i++) {\n                    if (right <= i)\n                        right = i+1;\n                    while (right < n && a[right]-a[i] < y+x)\n                        right++;\n                    if (a[right]-a[i]==y+x && a[i]+x <= L) {\n                        System.out.println(1);\n                        System.out.println(a[i]+x);\n                        return;\n                    }\n                }\n                right  = 1;\n                for (int i = 1; i < n; i++) {\n                    if (right <= i)\n                        right = i+1;\n                    while (right < n && a[right]-a[i] < y-x)\n                        right++;\n                    if (a[right]-a[i]==y-x && a[i]+y <= L) {\n                        System.out.println(1);\n                        System.out.println(a[i]+y);\n                        return;\n                    }\n                }\n                System.out.println(2);\n                System.out.println(x+\" \"+y);\n            }\n        }\n        pw.close();\n    }\n    private static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    private static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    private static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    private static String next() throws IOException {\n        while (st==null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nifstream fin(\"in.in\");\nofstream fout(\"out.out\");\nconst int N = 100000 + 10;\nint n, l, x, y, first[N], extra;\nvector<int> ext;\nset<int> s, markX, markY;\nbool canX, canY;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> first[i];\n    s.insert(first[i]);\n    if (s.find(first[i] - x) != s.end()) canX = true;\n    if (s.find(first[i] - y) != s.end()) canY = true;\n  }\n  if (canX && canY) return (cout << 0), 0;\n  if (canX) return (cout << 1 << endl << y), 0;\n  if (canY) return (cout << 1 << endl << x), 0;\n  for (int i = 0; i < n; i++) {\n    if (first[i] + x <= l) {\n      ext.push_back(first[i] + x);\n      markX.insert(first[i] + x);\n    }\n    if (first[i] + y <= l) {\n      ext.push_back(first[i] + y);\n      markY.insert(first[i] + y);\n    }\n    if (first[i] - x >= 0) {\n      ext.push_back(first[i] - x);\n      markX.insert(first[i] - x);\n    }\n    if (first[i] - y >= 0) {\n      ext.push_back(first[i] - y);\n      markY.insert(first[i] - y);\n    }\n  }\n  for (int i = 0; i < ext.size(); i++)\n    if (markX.find(ext[i]) != markX.end() && markY.find(ext[i]) != markY.end())\n      return (cout << 1 << endl << ext[i]), 0;\n  cout << 2 << endl << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y=map(int,raw_input().split())\nr=map(int,raw_input().split())\ndic={}\nfor i in r:\n\tdic[i]=True\nch1=0\nch2=0\nfor i in r:\n\tif ch1==0:\n\t\tif i-x in dic or i+x in dic:\n\t\t\tch1=1\n\tif ch2==0:\n\t\tif i-y in dic or i+y in dic:\n\t\t\tch2=1\nif ch1==1 and ch2==0:\n\tif r[0]+y <=l:\n\t\tprint \"1\"\n\t\tprint r[0]+y\n\telse:\n\t\tprint \"2\"\n\t\tprint 0,y\n\nelif ch1==0 and ch2==1:\n\tif r[0]+x <=l:\n\t\tprint \"1\"\n\t\tprint r[0]+x\n\telse:\n\t\tprint \"2\"\n\t\tprint 0,x\nelif ch1==1 and ch2==1:\n\tprint \"0\"\nelse:\t\n\tz=0\n\tf=0\n\tflag=0\n\tfor i in r:\n\t\tif i+x<=l:\n\t\t\tif i+x-y>=0:\n\t\t\t\tif i+x-y in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tflag=1\n\t\t\t\t\tf=1\n\t\t\t\t\tbreak\n\t\t\tif i+x+y<=l:\n\t\t\t\tif i+x+y in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=2\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\t\n\t\tif i-x>=0:\n\t\t\tif i-x-y>=0:\t\t\t\t\n\t\t\t\tif i-x-y in dic:\n\t\t\t\t\tf=3\n\t\t\t\t\tz=i\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif i-x+y<=l:\n\t\t\t\tif i-x+y in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=4\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\t\t\t\t\t\n\t\n\t\tif i+y<=l:\n\t\t\tif i+y-x>=0:\n\t\t\t\tif i+y-x in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=5\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif i+y+x<=l:\n\t\t\t\tif i+y+x in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=6\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\t\n\t\tif i-y>=0:\n\t\t\tif i-y-x>=0:\t\t\t\t\n\t\t\t\tif i-y-x in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=7\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\t\t\tif i-y+x<=l:\n\t\t\t\tif i-y+x in dic:\n\t\t\t\t\tz=i\n\t\t\t\t\tf=8\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\tif flag==1:\n\t\tprint \"1\"\n\t\tif f==1 or f==2:\n\t\t\tprint z+x\n\t\telif f==3 or f==4:\n\t\t\tprint z-x\n\t\telif f==5 or f==6:\n\t\t\tprint z+y\n\t\telif f==7 or f==8:\n\t\t\tprint z-y\n\telse:\n\t\tprint \"2\"\n\t\tprint x,y\n\t\t\t\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], *t, n, l, i, s;\nint solve(int x) {\n  for (i = 0; i < n - 1; i++) {\n    s = a[i] + x;\n    t = lower_bound(a + i, a + n, s);\n    if (*t == s) return 1;\n  }\n  return 0;\n}\nvoid work(int x, int y) {\n  for (i = 0; i < n - 1; i++) {\n    s = a[i] + y - x;\n    t = lower_bound(a + i, a + n, s);\n    if (*t == s) {\n      if (*t + x <= l) {\n        printf(\"1\\n%d\\n\", *t + x);\n        break;\n      } else if (*t - y >= 0) {\n        printf(\"1\\n%d\\n\", *t - y);\n        break;\n      }\n    }\n  }\n  if (i == n - 1) printf(\"2\\n%d %d\\n\", x, y);\n}\nint main() {\n  int x, y;\n  while (~scanf(\"%d%d%d%d\", &n, &l, &x, &y)) {\n    int flag = 0;\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    if (!solve(x)) flag++;\n    if (!solve(y)) flag += 2;\n    if (flag == 0)\n      printf(\"0\\n\");\n    else if (flag == 1)\n      printf(\"1\\n%d\\n\", x);\n    else if (flag == 2)\n      printf(\"1\\n%d\\n\", y);\n    else {\n      if (solve(y + x))\n        printf(\"1\\n%d\\n\", *t - y);\n      else\n        work(x, y);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> mp;\npair<int, int> ans;\nint a[100001];\nbool fx = false, fy = false;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    mp[a[i]] = 1;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (mp.find(a[i] - x) != mp.end() || mp.find(a[i] + x) != mp.end())\n      fx = true;\n    if (mp.find(a[i] - y) != mp.end() || mp.find(a[i] + y) != mp.end())\n      fy = true;\n    if (fx && fy) {\n      cout << \"0\" << endl;\n      return 0;\n    }\n  }\n  if (fx && !fy) {\n    cout << \"1\" << endl << y << endl;\n    return 0;\n  }\n  if (!fx && fy) {\n    cout << \"1\" << endl << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (a[i] + x <= l && mp.find(a[i] + x + y) != mp.end()) {\n      cout << \"1\" << endl << a[i] + x << endl;\n      return 0;\n    }\n    if (a[i] - x >= 0 && mp.find(a[i] - x + y) != mp.end()) {\n      cout << \"1\" << endl << a[i] - x << endl;\n      return 0;\n    }\n    if (a[i] + x <= l && mp.find(a[i] + x - y) != mp.end()) {\n      cout << \"1\" << endl << a[i] + x << endl;\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    from bisect import bisect_left\n    n, l, x, y = map(int, input().split())\n    aa, d = list(map(int, input().split())), {}\n    for z in (x, y, y + x):\n        for a in aa:\n            a += z\n            if a > l:\n                break\n            b = aa[bisect_left(aa, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z, tmp = y - x, []\n        for a in aa:\n            a += z\n            if a > l:\n                break\n            b = aa[bisect_left(aa, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    print(len(res))\n    if res:\n        print(*res)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, std::size_t N>\nstruct _v_traits {\n  using type = std::vector<typename _v_traits<T, N - 1>::type>;\n};\ntemplate <typename T>\nstruct _v_traits<T, 1> {\n  using type = std::vector<T>;\n};\ntemplate <typename T, std::size_t N = 1>\nusing vec = typename _v_traits<T, N>::type;\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  os << \"[\";\n  for (const auto &v : vec) {\n    os << v << \",\";\n  }\n  os << \"]\";\n  return os;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<long long> a(n);\n  for (long long &i : a) {\n    cin >> i;\n  }\n  {\n    bool x_ok = false, y_ok = false;\n    for (long long i = 0; i < n; i++) {\n      if (binary_search(a.begin() + i + 1, a.end(), x + a[i])) {\n        x_ok = true;\n        break;\n      }\n    }\n    for (long long i = 0; i < n; i++) {\n      if (binary_search(a.begin() + i + 1, a.end(), y + a[i])) {\n        y_ok = true;\n        break;\n      }\n    }\n    if (x_ok and y_ok) {\n      cout << 0 << endl;\n      return 0;\n    }\n    if (x_ok) {\n      cout << 1 << endl;\n      cout << y << endl;\n      return 0;\n    }\n    if (y_ok) {\n      cout << 1 << endl;\n      cout << x << endl;\n      return 0;\n    }\n  }\n  {\n    vector<long long> added;\n    for (long long av : a) {\n      if (av + x <= l) {\n        added.push_back(av + x);\n      }\n      if (0 <= av - x) {\n        added.push_back(av - x);\n      }\n    }\n    sort(added.begin(), added.end());\n    for (long long av : a) {\n      for (long long b : {av - y, av + y}) {\n        if (binary_search(added.begin(), added.end(), b)) {\n          cout << 1 << endl;\n          cout << *lower_bound(added.begin(), added.end(), b);\n          return 0;\n        }\n      }\n    }\n  }\n  {\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n\ndef rl(T=str):\n    return list(map(T,input().split()))\n\ndef ok(a,d,x):\n    for v in a:\n        if v+x in d:\n            return True\n    return False\n\n\ndef try_one(a,d,x,y):\n    def can_place(v):\n        #print(v)\n        #print(v+x,v-x,v+y,v-y)\n        if a[0] <= v <= a[-1]:\n            if (v + x in d or v - x in d) and \\\n               (v + y in d or v - y in d):\n               return True\n\n        return False;\n    for v in a:\n        for _ in [-x,+x,-y,+y]:\n            if can_place(v+_):\n                return v+_;\n\n    return None\n\ndef main():\n    n, l, x, y = rl(int)\n    a = rl(int)\n    d = set(a)\n\n    if ok(a,d,x):\n        if ok(a,d,y):\n            print(0)\n        else:\n            print(1)\n            print(y)\n    else:\n        if ok(a,d,y):\n            print(1)\n            print(x)\n        else:\n            p = try_one(a,d,x,y)\n            if p is not None:\n                print(1)\n                print(p)\n            else:\n                print(2)\n                print(x,y)\n\nmain()\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String args[]) throws NumberFormatException,\n\t\t\tIOException {\n\n\t\tStdin in = new Stdin();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.readInt();\n\t\tint l = in.readInt();\n\t\tint x = in.readInt();\n\t\tint y = in.readInt();\n\t\tif (x > y) {\n\t\t\tx += y;\n\t\t\ty = x - y;\n\t\t\tx = x - y;\n\t\t}\n\t\tint a = 0;\n\t\tHashSet<Integer> count = new HashSet<Integer>();\n\t\tboolean getX = false;\n\t\tboolean getY = false;\n\t\tint ans = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = in.readInt();\n\t\t\tif (count.contains(a - x))\n\t\t\t\tgetX = true;\n\t\t\tif (count.contains(a - y))\n\t\t\t\tgetY = true;\n\t\t\tif (ans == -1 && !getX && !getY) {\n\t\t\t\tif (count.contains(a - x - y)) {\n\t\t\t\t\tans = a - x;\n\t\t\t\t} else {\n\t\t\t\t\tif (count.contains(a + x - y)) {\n\t\t\t\t\t\tif (a >= y)\n\t\t\t\t\t\t\tans = a - y;\n\t\t\t\t\t\telse if (a + x <= l)\n\t\t\t\t\t\t\tans = a + x;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount.add(a);\n\n\t\t}\n\t\tif (getX && getY) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tif (getX) {\n\t\t\t\tout.println(1);\n\t\t\t\tif (a >= y)\n\t\t\t\t\tout.println(a - y);\n\t\t\t\telse\n\t\t\t\t\tout.println(y - a);\n\t\t\t} else {\n\t\t\t\tif (getY) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tif (a >= x)\n\t\t\t\t\t\tout.println(a - x);\n\t\t\t\t\telse\n\t\t\t\t\t\tout.println(x - a);\n\t\t\t\t} else {\n\t\t\t\t\tif (ans != -1) {\n\t\t\t\t\t\tout.println(1);\n\t\t\t\t\t\tout.println(ans);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(2);\n\t\t\t\t\t\tif (a >= x)\n\t\t\t\t\t\t\tout.print(a - x);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tout.print(x - a);\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t\tif (a >= y)\n\t\t\t\t\t\t\tout.println(a - y);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tout.println(y - a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\n\tprivate static class Stdin {\n\t\tInputStreamReader read;\n\t\tBufferedReader br;\n\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tprivate Stdin() {\n\t\t\tread = new InputStreamReader(System.in);\n\t\t\tbr = new BufferedReader(read);\n\n\t\t}\n\n\t\tprivate String readNext() throws IOException {\n\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tprivate int readInt() throws IOException, NumberFormatException {\n\n\t\t\treturn Integer.parseInt(readNext());\n\n\t\t}\n\n\t\tprivate long readLong() throws IOException, NumberFormatException {\n\n\t\t\treturn Long.parseLong(readNext());\n\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000;\nint i, j, k, l, m, n, o, p, x, y, L, a[N];\nmap<int, bool> F;\ninline void Init() {\n  cin >> n >> L >> x >> y;\n  F.clear();\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    F[a[i]] = 1;\n  }\n}\ninline void Solve() {\n  int isx, isy, aj, ans, Find;\n  isx = isy = 0;\n  for (i = 1; i <= n; i++) {\n    aj = a[i] - x;\n    if (F[aj]) isx = 1;\n    aj = a[i] + x;\n    if (F[aj]) isx = 1;\n    aj = a[i] - y;\n    if (F[aj]) isy = 1;\n    aj = a[i] + y;\n    if (F[aj]) isy = 1;\n  }\n  if (isx && isy)\n    puts(\"0\");\n  else if (isx) {\n    puts(\"1\");\n    printf(\"%d\\n\", y);\n  } else if (isy) {\n    puts(\"1\");\n    printf(\"%d\\n\", x);\n  } else {\n    Find = 0;\n    for (i = 1; i <= n; i++) {\n      if (a[i] + x <= L) {\n        isy = 0;\n        o = a[i] + x;\n        aj = o + y;\n        if (F[aj]) isy = 1;\n        aj = o - y;\n        if (F[aj]) isy = 1;\n        if (isy) {\n          Find = 1;\n          ans = o;\n          break;\n        }\n      }\n      if (a[i] - x >= 0) {\n        isy = 0;\n        o = a[i] - x;\n        aj = o + y;\n        if (F[aj]) isy = 1;\n        aj = o - y;\n        if (F[aj]) isy = 1;\n        if (isy) {\n          Find = 1;\n          ans = o;\n          break;\n        }\n      }\n    }\n    if (Find) {\n      puts(\"1\");\n      printf(\"%d\\n\", ans);\n    } else {\n      puts(\"2\");\n      printf(\"%d %d\\n\", x, y);\n    }\n  }\n}\nint main() {\n  Init();\n  Solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint a[200001];\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  int ans = -1;\n  bool ok1 = 0, ok2 = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] >= x && s.count(a[i] - x)) ok1 = 1;\n    if (a[i] <= l - x && s.count(a[i] + x)) ok1 = 1;\n    if (a[i] >= y && s.count(a[i] - y)) ok2 = 1;\n    if (a[i] <= l - y && s.count(a[i] + y)) ok2 = 1;\n  }\n  if (ok1 && ok2)\n    printf(\"0\\n\");\n  else if (ok1 || ok2)\n    printf(\"1\\n%d\\n\", ok1 == 1 ? y : x);\n  else {\n    for (int i = 1; i <= n; i++) {\n      if (a[i] >= x + y && s.count(a[i] - x - y)) {\n        ans = a[i] - x;\n        break;\n      }\n      if (a[i] >= x && a[i] - x + y <= l && s.count(a[i] - x + y)) {\n        ans = a[i] - x;\n        break;\n      }\n      if (a[i] + x + y <= l && s.count(a[i] + x + y)) {\n        ans = a[i] + y;\n        break;\n      }\n      if (a[i] + y <= l && a[i] + y - x >= 1 && s.count(a[i] + y - x)) {\n        ans = a[i] + y;\n        break;\n      }\n    }\n    if (ans != -1)\n      printf(\"1\\n%d\\n\", ans);\n    else\n      printf(\"2\\n%d %d\\n\", x, y);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> calc(const vector<int> &pts, int x) {\n  vector<int> cands;\n  int last = 0;\n  for (int start = 0; start < (int)pts.size() && last < (int)pts.size();\n       ++start) {\n    if (pts[start] + x > pts.back()) {\n      break;\n    }\n    last =\n        lower_bound(begin(pts) + last, end(pts), pts[start] + x) - begin(pts);\n    if (last == (int)pts.size()) {\n      break;\n    }\n    if (pts[last] == pts[start] + x) {\n      cands.clear();\n      return cands;\n    } else {\n      cands.push_back(pts[start] + x);\n    }\n  }\n  for (int start = 0; start < (int)pts.size(); ++start) {\n    if (pts[start] - x < 0) continue;\n    auto p = lower_bound(begin(pts), end(pts), pts[start] - x);\n    assert(p != end(pts));\n    if (*p == pts[start] - x) {\n      cands.clear();\n      return cands;\n    } else {\n      cands.push_back(pts[start] - x);\n    }\n  }\n  sort(begin(cands), end(cands));\n  return cands;\n}\nint main() {\n  int n, L, x, y;\n  scanf(\"%d %d %d %d\", &n, &L, &x, &y);\n  vector<int> pts(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &pts[i]);\n  }\n  vector<int> needx = calc(pts, x);\n  vector<int> needy = calc(pts, y);\n  if (needx.size() > needy.size()) {\n    needx.swap(needy);\n  }\n  if (needx.size() == 0) {\n    if (needy.size() == 0) {\n      puts(\"0\");\n    } else {\n      printf(\"1\\n%d\\n\", needy[0]);\n    }\n  } else {\n    assert(needy.size() > 0);\n    for (int i = 0; i < (int)needx.size(); ++i) {\n      auto p = lower_bound(begin(needy), end(needy), needx[i]);\n      if (p != end(needy) && *p == needx[i]) {\n        printf(\"1\\n%d\\n\", needx[i]);\n        return 0;\n      }\n    }\n    printf(\"2\\n%d %d\\n\", needx[0], needy[0]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(set<int> mySet, int value) {\n  for (auto it = mySet.begin(); it != mySet.end(); ++it)\n    if (mySet.find(*it - value) != mySet.end()) return true;\n  return false;\n}\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  set<int> mySet;\n  for (int i = 0; i < n; ++i) {\n    int value;\n    scanf(\"%d\", &value);\n    mySet.insert(value);\n  }\n  if (check(mySet, x) && check(mySet, y)) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (check(mySet, x)) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  } else if (check(mySet, y)) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (auto it = mySet.begin(); it != mySet.end(); ++it)\n    if (*it - x >= 0 && (mySet.find(*it - x + y) != mySet.end() ||\n                         mySet.find(*it - x - y) != mySet.end())) {\n      printf(\"1\\n%d\\n\", *it - x);\n      return 0;\n    } else if (*it + x <= l && (mySet.find(*it + x - y) != mySet.end() ||\n                                mySet.find(*it + x + y) != mySet.end())) {\n      printf(\"1\\n%d\\n\", *it + x);\n      return 0;\n    } else if (*it - y >= 0 && (mySet.find(*it - y + x) != mySet.end() ||\n                                mySet.find(*it - y - x) != mySet.end())) {\n      printf(\"1\\n%d\\n\", *it - y);\n      return 0;\n    } else if (*it + y <= l && (mySet.find(*it + y - x) != mySet.end() ||\n                                mySet.find(*it + y + x) != mySet.end())) {\n      printf(\"1\\n%d\\n\", *it + y);\n      return 0;\n    }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> f;\nint n, l, x, y;\nint a[110000];\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    f[a[i]] = 1;\n  }\n  bool f1, f2;\n  f1 = f2 = 0;\n  for (int i = 1; i <= n; i++) {\n    if (f[a[i] - x]) f1 = 1;\n    if (f[a[i] - y]) f2 = 1;\n  }\n  if (f1 && f2) {\n    printf(\"0\");\n    return 0;\n  }\n  if (f1) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  if (f2) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++)\n    if (f[a[i] - x - y]) {\n      printf(\"1\\n%d\", a[i] - y);\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (f[a[i] - (y - x)] && a[i] + x <= l) {\n      printf(\"1\\n%d\", a[i] + x);\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (f[a[i] + (y - x)] && a[i] - x >= 0) {\n      printf(\"1\\n%d\", a[i] - x);\n      return 0;\n    }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nlong long n, len, girl, boy, x;\nset<long long> st;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  bool g = 0, b = 0;\n  cin >> n >> len >> girl >> boy;\n  for (int i = 0; i < n; ++i) cin >> x, st.insert(x);\n  for (auto it : st)\n    b |= (st.find(it + boy) != st.end()), g |= (st.find(it + girl) != st.end());\n  long long small = *st.begin();\n  if (g && b)\n    cout << 0;\n  else if (b) {\n    if (small + girl <= len)\n      cout << \"1\\n\" << small + girl;\n    else\n      cout << \"2\\n0 \" << girl;\n  } else if (g) {\n    if (small + boy <= len)\n      cout << \"1\\n\" << small + boy;\n    else\n      cout << \"2\\n0 \" << boy;\n  } else {\n    set<long long> bx, gx;\n    for (auto it : st)\n      bx.insert(it + boy), bx.insert(it - boy), gx.insert(it + girl),\n          gx.insert(it - girl);\n    for (auto it : bx)\n      if (it >= 0 && it <= len && gx.find(it) != gx.end())\n        return cout << \"1\\n\" << it, 0;\n    if (small + boy <= len && small + girl <= len)\n      cout << \"2\\n\" << small + boy << ' ' << small + girl;\n    else\n      cout << \"3\\n0 \" << boy << ' ' << girl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  map<long long, bool> mp1, mp2, mp3, mp4;\n  bool zx = false, zy = false;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    mp1[a[i] + x] = true;\n    mp1[a[i] - x] = true;\n    mp4[a[i] + y] = true;\n    mp4[a[i] - y] = true;\n    mp2[a[i] + (x + y)] = true;\n    mp2[a[i] - (x + y)] = true;\n    mp2[a[i] + (x - y)] = true;\n    mp2[a[i] - (x - y)] = true;\n    mp3[a[i]] = true;\n  }\n  for (int i = 0; i < n; i++) {\n    if (mp1[a[i]]) {\n      zx = true;\n    }\n    if (mp4[a[i]]) {\n      zy = true;\n    }\n  }\n  if (zx && zy) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (zx) {\n    cout << 1 << endl;\n    cout << y << endl;\n    return 0;\n  }\n  if (zy) {\n    cout << 1 << endl;\n    cout << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (mp2[a[i]]) {\n      if (mp3[a[i] + (x + y)]) {\n        cout << 1 << endl;\n        cout << (a[i] + x) << endl;\n        return 0;\n      }\n      if (mp3[a[i] - (x + y)]) {\n        cout << 1 << endl;\n        cout << (a[i] - x) << endl;\n        return 0;\n      }\n      if (mp3[a[i] - (x - y)]) {\n        if (a[i] - x > 0) {\n          cout << 1 << endl;\n          cout << (a[i] - x) << endl;\n          return 0;\n        } else if (a[i] + y < l) {\n          cout << 1 << endl;\n          cout << (a[i] + y) << endl;\n          return 0;\n        }\n      }\n      if (mp3[a[i] + (x - y)]) {\n        if (a[i] + x < l) {\n          cout << 1 << endl;\n          cout << (a[i] + x) << endl;\n          return 0;\n        } else if (a[i] - y > 0) {\n          cout << 1 << endl;\n          cout << (a[i] - y) << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\nfrom bisect import bisect_left\n\nn, l, x, y = map(int, raw_input().split())\nmarks = map(int, raw_input().split())\n\nmarkx = set()\nmarky = set()\n\ndef in_range(x):\n  return x >= 0 and x <= l\n\nfor mark in marks:\n  if in_range(mark + x):\n    markx.add(mark + x)\n  if in_range(mark - x):\n    markx.add(mark - x)\n  if in_range(mark + y):\n    marky.add(mark + y)\n  if in_range(mark - y):\n    marky.add(mark - y)\n\nfound_x = False\nfound_y = False\nfor mark in marks:\n  if mark in markx:\n    found_x = True\n  if mark in marky:\n    found_y = True\nif found_x and found_y:\n  print 0\n  exit()\nif found_x:\n  print 1\n  print y\n  exit()\nif found_y:\n  print 1\n  print x\n  exit()\nintersect = markx.intersection(marky)\nif len(intersect) == 0:\n  print 2\n  print x, y\nelse:\n  print 1\n  print intersect.pop()\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y=map(int,raw_input().split())\nori=map(int,raw_input().split())\nboy=[]\ngirl=[]\nfor i in ori:\n    if i+y<=l:\n        boy.append(i+y)\n    if 0<=i-y:\n        boy.append(i-y)\n    if i+x<=l:\n        girl.append(i+x)\n    if i-x>=0:\n        girl.append(i-x)\ntem=0\nboy.sort()\ngirl.sort()\nbh=False\ngh=False\nfor i in boy:\n    while i>ori[tem] and tem<n-1:\n        tem+=1\n    if i==ori[tem]:\n        bh=True\n        break\ntem=0\nfor j in girl:\n    while j>ori[tem] and tem<n-1:\n        tem+=1\n    if j==ori[tem]:\n        gh=True\n        break\nif bh and gh:\n    print 0\nelif bh:\n    print 1\n    print x\nelif gh:\n    print 1\n    print y\nelse:\n    bg=False\n    tem=0\n    for i in boy:\n        while i>girl[tem] and tem<len(girl)-1:\n            tem+=1\n        if i==girl[tem]:\n            bg=True\n            break\n    if bg:\n        print 1\n        print i\n    else:\n        print 2\n        print x,y"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class a {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        TreeMap<Integer,LinkedList<Integer>> hm=new TreeMap<Integer,LinkedList<Integer>>();  \n        int n=s.nextInt();\n        int l=s.nextInt();\n        int x=s.nextInt();\n        int y=s.nextInt();\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n          a[i]=s.nextInt();\n        Arrays.sort(a);\n        int flag1=0,flag2=0;\n        for(int i=0;i<n;i++){\n           if(f(a,a[i]+x,0,n-1))\n              flag1=1;\n           if(f(a,a[i]+y,0,n-1))\n              flag2=1; \n        }\n        if(flag1==1&&flag2==0){\n            System.out.println(\"1\");\n            System.out.println(y);\n        }\n        if(flag1==0&&flag2==1){\n            System.out.println(\"1\");\n            System.out.println(x);\n        }\n        if(flag1==0&&flag2==0){\n            int flag3=0,k=-1;\n           for(int i=0;i<n;i++){\n            if((f(a,a[i]+y-x,0,n-1)||f(a,a[i]+y+x,0,n-1))&&a[i]+y<=a[n-1]){\n                 k=a[i]+y;\n                 break;\n             }\n              if((f(a,a[i]+x+y,0,n-1)||f(a,a[i]+x-y,0,n-1))&&a[i]+x<=a[n-1]){\n                 k=a[i]+x;\n                 break;\n             } \n             if((f(a,a[i]-y-x,0,n-1)||f(a,a[i]-y+x,0,n-1))&&a[i]-y>=a[0]){\n                 k=a[i]-y;\n                 break;\n             }\n              if((f(a,a[i]-x+y,0,n-1)||f(a,a[i]-x-y,0,n-1))&&a[i]-x>=a[0]){\n                 k=a[i]-x;\n                 break;\n             }   \n           }\n           if(k!=-1){\n              System.out.println(\"1\"); \n              System.out.println(k);\n           }\n           else{\n              System.out.println(\"2\"); \n              System.out.println(x+\" \"+y);\n           } \n        }\n        if(flag1==1&&flag2==1)\n           System.out.println(\"0\"); \n    }\n    public static boolean f(int array[], int search, int first , int last){\n\n    int  middle = (first + last)/2;\n \n    while( first <= last )\n    {\n      if ( array[middle] < search )\n        first = middle + 1;    \n      else if ( array[middle] == search ) \n      {\n        return true;\n      }\n      else\n         last = middle - 1;\n \n      middle = (first + last)/2;\n   }\n   if ( first > last )\n     return false;\n     return false;   \n  }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid printArray(long long start, long long end, int arr[]) {\n  for (long long i = start; i < end; i++) cout << arr[i] << \" \";\n  cout << \"\\n\";\n}\nvoid printVector(long long start, long long end, vector<int> vec) {\n  for (long long i = start; i < end; i++) cout << vec[i] << \" \";\n  cout << \"\\n\";\n}\nlong long nextPerfectSquare(long long N) {\n  long long nextN = floor(sqrt(N)) + 1;\n  if (sqrt(N) == floor(sqrt(N))) nextN--;\n  return nextN * nextN;\n}\nlong long countSetBits(long long n) {\n  long long count = 0;\n  while (n) {\n    count += n & 1;\n    n >>= 1;\n  }\n  return count;\n}\nvoid solve() {\n  int n, l, x, y, i;\n  cin >> n >> l >> x >> y;\n  int A[n];\n  vector<int> ans;\n  for (i = 0; i < n; i++) cin >> A[i];\n  ans.clear();\n  for (i = 0; i < n; i++)\n    if (binary_search(A, A + n, A[i] - x)) break;\n  if (i == n) {\n    for (i = 0; i < n; i++) {\n      if (A[i] > x) {\n        ans.push_back(A[i] - x);\n        break;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (binary_search(A, A + n, A[i] - y)) break;\n  }\n  if (i == n) {\n    for (i = 0; i < n; i++) {\n      if (A[i] > y) {\n        ans.push_back(A[i] - y);\n        break;\n      }\n    }\n  }\n  if (ans.size() > 1) {\n    for (i = 0; i < n; i++) {\n      if (binary_search(A, A + n, A[i] - x + y) && A[i] - x > 0) {\n        cout << 1 << \"\\n\";\n        cout << A[i] - x << \"\\n\";\n        return;\n      }\n      if (binary_search(A, A + n, A[i] - x - y) && A[i] - x > 0) {\n        cout << 1 << \"\\n\";\n        cout << A[i] - x << \"\\n\";\n        return;\n      }\n      if (binary_search(A, A + n, A[i] + x - y) && A[i] + x < l) {\n        cout << 1 << \"\\n\";\n        cout << A[i] + x << \"\\n\";\n        return;\n      }\n      if (binary_search(A, A + n, A[i] + x + y) && A[i] + x < l) {\n        cout << 1 << \"\\n\";\n        cout << A[i] + x << \"\\n\";\n        return;\n      }\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  sort(ans.begin(), ans.end());\n  printVector(0, ans.size(), ans);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class B274 {\n  \n  public void solve() throws IOException {\n    int n = nextInt();\n    int l = nextInt();\n    int girl = nextInt();\n    int boy = nextInt();\n    int tot = girl + boy;\n    int diff = boy - girl;\n    \n    int[] a = new int[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = nextInt();\n    }\n    \n    boolean hasgirl = false;\n    boolean hasboy = false;\n    boolean hastot = false;\n    int totmark = -1;\n    \n    for (int x = 0; x < n; x++) {\n      if (hasboy && hasgirl) break;\n      \n      if (!hasboy && a[x] + boy <= l) {\n        int iboy = Arrays.binarySearch(a, x + 1, n, a[x] + boy);\n        hasboy |= (iboy >= 0);\n      }\n      if (!hasgirl && a[x] + girl <= l) {\n        int igirl = Arrays.binarySearch(a, x + 1, n, a[x] + girl);\n        hasgirl |= (igirl >= 0);\n      }\n      if (!hastot && a[x] + tot <= l) {\n        int itot = Arrays.binarySearch(a, x + 1, n, a[x] + tot);\n        hastot |= (itot >= 0);\n        totmark = a[x] + girl;\n      }\n      if (!hastot && a[x] + diff <= l) {\n        int itot = Arrays.binarySearch(a, x + 1, n, a[x] + diff);\n        if (itot >= 0) {\n          if (a[x] + boy <= l) {\n            hastot = true;\n            totmark = a[x] + boy;\n          } else if (a[x] - girl >= 0) {\n            hastot = true;\n            totmark = a[x] - girl;\n          }\n        }\n      }\n    }\n    \n    if (hasgirl && hasboy) {\n      System.out.println(0);\n    } else if (!hasgirl && !hasboy && !hastot) {\n      System.out.println(2);\n      System.out.println(girl + \" \" + boy);\n    } else if (hastot) {\n      System.out.println(1);\n      System.out.println(totmark);\n    } else if (!hasgirl) {\n      System.out.println(1);\n      System.out.println(girl);\n    } else if (!hasboy) {\n      System.out.println(1);\n      System.out.println(boy);\n    }\n  }\n\n  public BufferedReader br;\n  public StringTokenizer st;\n  public PrintWriter out;\n\n  public String nextToken() throws IOException {\n    while (st == null || !st.hasMoreTokens()) {\n      st = new StringTokenizer(br.readLine());\n    }\n\n    return st.nextToken();\n  }\n\n  public String nextLine() throws IOException {\n    return br.readLine();\n  }\n\n  public int nextInt() throws IOException {\n    return Integer.parseInt(nextToken());\n  }\n\n  public long nextLong() throws IOException {\n    return Long.parseLong(nextToken());\n  }\n\n  public double nextDouble() throws IOException {\n    return Double.parseDouble(nextToken());\n  }\n\n  public void run() throws IOException {\n    boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    oj = true;\n    br = new BufferedReader(\n        new InputStreamReader(oj ? System.in : new FileInputStream(\"input.txt\")));\n    out = new PrintWriter(oj ? System.out : new FileOutputStream(\"output.txt\"));\n    solve();\n    out.close();\n  }\n\n  public static void main(String[] args) throws IOException {\n    new B274().run();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int in[100005];\nint main() {\n  int n;\n  long long int l, x, y;\n  scanf(\"%d %I64d %I64d %I64d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", &in[i]);\n  bool X = false, Y = false, XY = false, XY2 = false, XY3 = false;\n  int L, R, T;\n  for (int i = 0; i < n; i++) {\n    int p = lower_bound(in, in + n, in[i] + x) - in;\n    if (p < n && in[p] == in[i] + x) X = true;\n    p = lower_bound(in, in + n, in[i] + y) - in;\n    if (p < n && in[p] == in[i] + y) Y = true;\n    p = lower_bound(in, in + n, in[i] + x + y) - in;\n    if (p < n && in[p] == in[i] + x + y) {\n      XY = true;\n      L = i;\n    }\n    p = lower_bound(in, in + n, in[i] + y - x) - in;\n    if (p < n && in[p] == in[i] + y - x && in[i] + y <= l) {\n      XY2 = true;\n      R = i;\n    } else if (p < n && in[p] == in[i] + y - x && in[i] - x >= 0) {\n      XY3 = true;\n      T = i;\n    }\n  }\n  if (X && Y)\n    puts(\"0\");\n  else {\n    if (X) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", y);\n    } else if (Y) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", x);\n    } else if (XY) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", in[L] + x);\n    } else if (XY2) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", in[R] + y);\n    } else if (XY3) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", in[T] - x);\n    } else {\n      puts(\"2\");\n      printf(\"%I64d %I64d\\n\", x, y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class CO_479D {\n\tstatic int imax = Integer.MAX_VALUE, imin = Integer.MIN_VALUE;\n\tstatic long lmax = Long.MAX_VALUE, lmin = Long.MIN_VALUE;\n\tstatic long mod = (long) 1e9 + 7;\n\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// int test=in.ni();\n\t\tint test = 1;\n\t\tint i = 0, j = 0;\n\t\twhile (test-- > 0) {\n\t\t\tint n = in.ni();\n\t\t\tint l = in.ni();\n\t\t\tint x = in.ni();\n\t\t\tint y = in.ni();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tarr[i] = in.ni();\n\t\t\tboolean findx = find(arr, x);\n\t\t\tboolean findy = find(arr, y);\n\t\t\tif (findx && findy) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t} else if ((findx && !findy) || (!findx && findy)) {\n\t\t\t\t// System.out.println(left + \" \" + right);\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tif (!findx) {\n\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (find(arr, x + y)) {\n\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\tSystem.out.println(arr[left] + x);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (find2(arr, y - x)) {\n\t\t\t\t\tfor (i = 0; i < list.size(); i++) {\n\t\t\t\t\t\tPair ob = list.get(i);\n\t\t\t\t\t\t// System.out.println(ob);\n\t\t\t\t\t\tif (arr[ob.x] - x >= 0) {\n\t\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\t\tSystem.out.println(arr[ob.x] - x);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (arr[ob.y] + x <= l) {\n\t\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\t\tSystem.out.println(arr[ob.y] + x);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"2\");\n\t\t\t\tSystem.out.print(x + \" \" + y);\n\n\t\t\t}\n\t\t\t// System.out.println(find(arr, 10) + \" \" + left + \" \" + right);\n\t\t\t// out.println();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic int left = -1, right = -1;\n\n\tstatic boolean find(int arr[], int q) {\n\t\tif (arr.length == 1)\n\t\t\treturn false;\n\t\tint l = 0, r = 1;\n\t\twhile (r < arr.length) {\n\t\t\tint diff = arr[r] - arr[l];\n\t\t\tif (diff == q) {\n\t\t\t\tleft = l;\n\t\t\t\tright = r;\n\t\t\t\treturn true;\n\t\t\t} else if (diff < q) {\n\t\t\t\tr++;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic ArrayList<Pair> list = new ArrayList<>();\n\n\tstatic boolean find2(int arr[], int q) {\n\t\tif (arr.length == 1)\n\t\t\treturn false;\n\t\tint l = 0, r = 1;\n\t\tboolean flag = false;\n\t\twhile (r < arr.length) {\n\t\t\tint diff = arr[r] - arr[l];\n\t\t\tif (diff == q) {\n\t\t\t\tleft = l;\n\t\t\t\tright = r;\n\t\t\t\tflag = true;\n\t\t\t\tlist.add(new Pair(l, r));\n\t\t\t\tl++;\n\t\t\t\tr++;\n\t\t\t} else if (diff < q) {\n\t\t\t\tr++;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\n\tstatic class Pair {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\t}\n\n\tstatic void print(int arr[], int len) {\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String ns() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic char[] ncs() {\n\t\t\treturn ns().toCharArray();\n\t\t}\n\n\t\tpublic String nLine() {\n\t\t\tint c = read();\n\t\t\t// while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1)\n\t\t\t// c = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1);\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic static boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, L, X, Y;\nint marks[100000 + 5];\nmap<int, bool> seen;\nbool ok(int cur) {\n  for (int i = 0; i < N; ++i)\n    if (marks[i] + cur >= 0 && marks[i] + cur <= L && seen[marks[i] + cur])\n      return true;\n  return false;\n}\nint find_mark() {\n  int poss1, poss2, poss3, poss4;\n  for (int i = 0; i < N; ++i) {\n    poss1 = marks[i] + X;\n    poss2 = marks[i] - X;\n    poss3 = marks[i] + Y;\n    poss4 = marks[i] - Y;\n    if (poss1 >= 0 && poss1 <= L) {\n      if (poss1 + Y >= 0 && poss1 + Y <= L && seen[poss1 + Y]) return poss1;\n    }\n    if (poss1 >= 0 && poss1 <= L) {\n      if (poss1 - Y >= 0 && poss1 - Y <= L && seen[poss1 - Y]) return poss1;\n    }\n    if (poss2 >= 0 && poss2 <= L) {\n      if (poss2 - Y >= 0 && poss2 - Y <= L && seen[poss2 - Y]) return poss2;\n    }\n    if (poss2 >= 0 && poss2 <= L) {\n      if (poss2 + Y >= 0 && poss2 + Y <= L && seen[poss2 + Y]) return poss2;\n    }\n    if (poss3 >= 0 && poss3 <= L) {\n      if (poss3 + X >= 0 && poss3 + X <= L && seen[poss3 + X]) return poss3;\n    }\n    if (poss3 >= 0 && poss3 <= L) {\n      if (poss3 - X >= 0 && poss3 - X <= L && seen[poss3 - X]) return poss3;\n    }\n    if (poss4 >= 0 && poss4 <= L) {\n      if (poss4 - X >= 0 && poss4 - X <= L && seen[poss4 - X]) return poss4;\n    }\n    if (poss4 >= 0 && poss4 <= L) {\n      if (poss4 + X >= 0 && poss4 + X <= L && seen[poss4 + X]) return poss4;\n    }\n  }\n  return -1;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> N >> L >> X >> Y;\n  for (int i = 0; i < N; ++i) {\n    cin >> marks[i];\n    seen[marks[i]] = true;\n  }\n  if (ok(X) && ok(Y)) {\n    cout << \"0\\n\";\n    return 0;\n  } else if (ok(X) || ok(Y)) {\n    if (ok(X))\n      cout << \"1\\n\" << Y << \"\\n\";\n    else\n      cout << \"1\\n\" << X << \"\\n\";\n    return 0;\n  }\n  int mark = find_mark();\n  if (mark == -1)\n    cout << \"2\\n\" << X << \" \" << Y << \"\\n\";\n  else\n    cout << \"1\\n\" << mark << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> P;\nint a[100010];\nint n, l, x, y, tp, maxm;\nint g[2];\nbool o[2];\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  g[0] = min(x, y);\n  g[1] = max(x, y);\n  o[0] = o[1] = true;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    P[a[i]] = 1;\n  }\n  sort(a + 1, a + n + 1);\n  bool boy = false, girl = false;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] - x >= 0 && P[a[i] - x]) girl = true;\n    if (a[i] - y >= 0 && P[a[i] - y]) boy = true;\n  }\n  if (boy && girl) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (boy) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  if (girl) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  bool flag1 = false;\n  bool flag2 = false;\n  bool flag3 = false;\n  int where = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] >= x && P[a[i] + y - x]) {\n      flag1 = true;\n      where = a[i];\n      break;\n    }\n    if (a[i] + y <= l && P[a[i] + y - x]) {\n      flag2 = true;\n      where = a[i];\n      break;\n    }\n    if (a[i] + x + y <= l && P[a[i] + x + y]) {\n      flag3 = true;\n      where = a[i];\n      break;\n    }\n  }\n  if (flag1)\n    printf(\"1\\n%d\\n\", where - x);\n  else if (flag2)\n    printf(\"1\\n%d\\n\", where + y);\n  else if (flag3)\n    printf(\"1\\n%d\\n\", where + x);\n  else\n    printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a, b, c, d;\nint aa[100100];\nint find(int q) {\n  int j = 1;\n  for (int i = 2; i <= n; i++) {\n    while (aa[i] - aa[j] > q) j++;\n    if (aa[i] - aa[j] == q) return j;\n  }\n  return 0;\n}\nint find1(int q) {\n  int j = 1;\n  for (int i = 2; i <= n; i++) {\n    while (aa[i] - aa[j] > q) j++;\n    if (aa[i] - aa[j] == q) {\n      int ll = aa[j], rr = aa[i];\n      if (ll - x > 0) return ll - x;\n      if (rr + x < l) return rr + x;\n    }\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &aa[i]);\n  a = find(x);\n  b = find(y);\n  if (a && b) {\n    printf(\"0\");\n    return 0;\n  }\n  if (a) {\n    printf(\"1\\n\");\n    printf(\"%d\", y);\n    return 0;\n  }\n  if (b) {\n    printf(\"1\\n\");\n    printf(\"%d\", x);\n    return 0;\n  }\n  if (x + y <= l) c = find(x + y);\n  if (c) {\n    printf(\"1\\n\");\n    printf(\"%d\", aa[c] + x);\n    return 0;\n  }\n  d = find1(y - x);\n  if (d) {\n    printf(\"1\\n\");\n    printf(\"%d\", d);\n    return 0;\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nbool x_pres, y_pres;\nint main() {\n  ios_base::sync_with_stdio(0);\n  ;\n  cin >> n >> l >> x >> y;\n  vector<long long> m(n);\n  for (long long i = 0; i < n; i++) cin >> m[i];\n  sort(m.begin(), m.end());\n  for (long long i = 0; i < m.size(); i++) {\n    if (binary_search(m.begin(), m.end(), m[i] - x) or\n        binary_search(m.begin(), m.end(), m[i] + x)) {\n      x_pres = true;\n      break;\n    }\n  }\n  for (long long i = 0; i < m.size(); i++) {\n    if (binary_search(m.begin(), m.end(), m[i] - y) or\n        binary_search(m.begin(), m.end(), m[i] + y)) {\n      y_pres = true;\n      break;\n    }\n  }\n  if (x_pres and y_pres) {\n    cout << 0 << endl;\n  } else if (x_pres) {\n    cout << 1 << endl;\n    cout << y << endl;\n  } else if (y_pres) {\n    cout << 1 << endl;\n    cout << x << endl;\n  } else {\n    for (long long i = 0; i < m.size(); i++) {\n      if (binary_search(m.begin(), m.end(), m[i] + x + y)) {\n        cout << 1 << endl;\n        cout << m[i] + x << endl;\n        return 0;\n      }\n    }\n    if (x > y) swap(x, y);\n    for (long long i = 0; i < m.size(); i++) {\n      if (binary_search(m.begin(), m.end(), m[i] + y - x)) {\n        if (m[i] - x >= 0) {\n          cout << 1 << endl;\n          cout << m[i] - x << endl;\n          return 0;\n        } else if (m[i] + y <= l) {\n          cout << 1 << endl;\n          cout << m[i] + y << endl;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[1000000];\nmap<int, int> mp;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  int i;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &arr[i]);\n    mp[arr[i]] = 1;\n  }\n  int cnt = 0;\n  for (i = 0; i < n; i++) {\n    if (mp.count(arr[i] + x)) {\n      cnt++;\n      break;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (mp.count(arr[i] + y)) {\n      if (cnt)\n        cnt = 3;\n      else\n        cnt = 2;\n      break;\n    }\n  }\n  if (cnt == 3)\n    printf(\"0\\n\");\n  else if (cnt == 1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", y);\n  } else if (cnt == 2) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", x);\n  } else {\n    int diff = y - x;\n    int sum = x + y;\n    for (i = 0; i < n; i++) {\n      if (mp.count(arr[i] + diff)) {\n        if (arr[i] + y <= l) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", arr[i] + y);\n          return 0;\n        } else if (arr[i] - x >= 0) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", arr[i] - x);\n          return 0;\n        }\n      }\n    }\n    for (i = 0; i < n; i++) {\n      if (mp.count(arr[i] + sum)) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", arr[i] + y);\n        return 0;\n      }\n    }\n    printf(\"2\\n\");\n    printf(\"%d %d\\n\", x, y);\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inft = 1000000009;\nint n, a[1000005];\npair<int, int> ff(int x) {\n  int l = 0;\n  for (int r = 0; r < n; r++) {\n    while (l < n && a[l] + x < a[r]) l++;\n    if (a[l] + x == a[r]) return pair<int, int>(a[l], a[r]);\n  }\n  return pair<int, int>(-1, -1);\n}\npair<int, int> fl(int x) {\n  int r = n - 1;\n  for (int l = n - 1; l >= 0; l--) {\n    while (r >= 0 && a[l] + x < a[r]) r--;\n    if (a[l] + x == a[r]) return pair<int, int>(a[l], a[r]);\n  }\n  return pair<int, int>(-1, -1);\n}\nvoid solve() {\n  int l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  bool okx = ff(x) != pair<int, int>(-1, -1);\n  bool oky = ff(y) != pair<int, int>(-1, -1);\n  if (okx && oky) {\n    cout << 0 << endl;\n    return;\n  }\n  if (okx || oky) {\n    cout << 1 << endl;\n    if (!okx) cout << x << endl;\n    if (!oky) cout << y << endl;\n    return;\n  }\n  pair<int, int> str = ff(x + y);\n  if (str != pair<int, int>(-1, -1)) {\n    cout << 1 << endl;\n    printf(\"%d\\n\", str.first + x);\n    return;\n  }\n  str = ff(y - x);\n  if (str != pair<int, int>(-1, -1) && str.first + y <= l) {\n    cout << 1 << endl;\n    cout << str.first + y << endl;\n    return;\n  }\n  str = fl(y - x);\n  if (str != pair<int, int>(-1, -1) && str.first - x >= 0) {\n    cout << 1 << endl;\n    cout << str.first - x << endl;\n    return;\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n}\nint main() {\n  int k = 1;\n  for (int i = 0; i < k; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 2147383647;\nconst double pi = 2 * acos(0.0);\nconst double eps = 1e-9;\nlong long gcd(long long a, long long b) {\n  a = ((a) < 0 ? -(a) : (a));\n  b = ((b) < 0 ? -(b) : (b));\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n}\nint ext_gcd(int a, int b, int &x, int &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  int x1, y1;\n  int d = ext_gcd(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return d;\n}\nlong long power(long long a, long long p) {\n  long long res = 1, x = a;\n  while (p) {\n    if (p & 1) res = (res * x);\n    x = (x * x);\n    p >>= 1;\n  }\n  return res;\n}\nlong long bigmod(long long a, long long p, long long m) {\n  long long res = 1, x = a % m;\n  while (p) {\n    if (p & 1) res = (res * x) % m;\n    x = (x * x) % m;\n    p >>= 1;\n  }\n  return res;\n}\nint n, l, x, y;\nvector<int> arr;\nint findJump(int v) {\n  for (int i = (0); i <= (n - 1); ++i) {\n    int cur = arr[i];\n    int f = cur + v;\n    int pos = lower_bound((arr).begin(), (arr).end(), f) - arr.begin();\n    if (pos >= 0 && pos <= n - 1 && arr[pos] == f) return 1;\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = (0); i <= (n - 1); ++i) {\n    int t;\n    scanf(\"%d\", &t);\n    arr.push_back(t);\n  }\n  int jumpx = findJump(x);\n  int jumpy = findJump(y);\n  if (jumpx && jumpy) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (jumpx + jumpy == 1) {\n    printf(\"1\\n\");\n    if (jumpx == 0)\n      printf(\"%d\\n\", x);\n    else\n      printf(\"%d\\n\", y);\n    return 0;\n  }\n  bool one = false;\n  int res;\n  for (int i = (0); i <= (n - 1); ++i) {\n    int cur = arr[i];\n    int f = cur + x + y;\n    int pos = lower_bound(arr.begin(), arr.end(), f) - arr.begin();\n    if (pos <= n - 1 && pos >= 0 && arr[pos] == f) {\n      one = true;\n      res = cur + x;\n      break;\n    }\n    f = cur + y - x;\n    pos = lower_bound(arr.begin(), arr.end(), f) - arr.begin();\n    if (pos <= n - 1 && pos >= 0 && arr[pos] == f) {\n      one = true;\n      res = cur + y;\n      if (res > l) res = cur - x;\n      if (res < 0) {\n        one = false;\n        continue;\n      }\n      break;\n    }\n  }\n  if (one) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", res);\n    return 0;\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N3 = 1e3 + 15;\nconst int N4 = 1e4 + 15;\nconst int N5 = 1e5 + 15;\nconst int N6 = 1e6 + 15;\nconst int N7 = 1e7 + 15;\nconst int N8 = 1e8 + 15;\nconst int N9 = 1e9 + 15;\nconst double pi = acos(-1.0);\nint dx[10] = {0, 1, -1, 1, -1, 2, -2, 2, -2};\nint dy[10] = {0, 2, 2, -1, -1, 1, 1, -1, -1};\nbool okx = 0, oky = 0;\nint n, a[N5], l, x, r, y;\nset<int> ans;\nint bin(int l, int r, int val) { return (binary_search(a + l, a + r, val)); }\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  for (int i = 1; i <= n && a[i] + x <= l; ++i)\n    if (bin(1, n + 1, a[i] + x)) {\n      okx = true;\n      break;\n    }\n  for (int i = 1; i <= n && a[i] + y <= l; ++i)\n    if (bin(1, n + 1, a[i] + y)) {\n      oky = true;\n      break;\n    }\n  if (!okx && !oky) {\n    for (int i = 1; i <= n; ++i) {\n      if (a[i] + y <= l && bin(1, n + 1, a[i] + y - x)) {\n        ans.insert(a[i] + y);\n        break;\n      }\n    }\n    if (ans.size() == 0) {\n      for (int i = 1; i <= n; ++i) {\n        if (a[i] - y >= 0 && bin(1, n + 1, a[i] - y + x)) {\n          ans.insert(a[i] - y);\n          break;\n        }\n      }\n    }\n    if (ans.size() == 0) {\n      for (int i = 1; i <= n; ++i) {\n        if (a[i] + x + y <= l && bin(1, n + 1, a[i] + x + y)) {\n          ans.insert(a[i] + x);\n          break;\n        }\n      }\n    }\n    if (ans.size() == 0) {\n      ans.insert(x);\n      ans.insert(y);\n    }\n  } else {\n    if (!okx) ans.insert(x);\n    if (!oky) ans.insert(y);\n  }\n  cout << ans.size() << \"\\n\";\n  for (set<int>::iterator it = ans.begin(); it != ans.end(); ++it)\n    cout << *it << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100002], u, v, r = 2;\nset<int> A;\nbool X, Y;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    A.insert(a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (A.find(a[i] + x) != A.end()) X = true;\n    if (A.find(a[i] + y) != A.end()) Y = true;\n  }\n  if (X && Y) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (X) {\n    printf(\"%d\\n%d\\n\", 1, y);\n    return 0;\n  }\n  if (Y) {\n    printf(\"%d\\n%d\\n\", 1, x);\n    return 0;\n  }\n  u = x;\n  v = y;\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x < l &&\n        (A.find(a[i] + x - y) != A.end() || A.find(a[i] + x + y) != A.end())) {\n      r = 1;\n      u = a[i] + x;\n      break;\n    }\n    if (a[i] - x > 0 &&\n        (A.find(a[i] - x + y) != A.end() || A.find(a[i] - x - y) != A.end())) {\n      r = 1;\n      u = a[i] - x;\n      break;\n    }\n  }\n  printf(\"%d\\n\", r);\n  (r == 2) ? printf(\"%d %d\\n\", u, v) : printf(\"%d\\n\", u);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\n\n   \npublic class Main {\n    public static void main(String[] args) throws IOException{\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n           \n        //InputStream inputStream = new FileInputStream(\"input.txt\");\n        //OutputStream outputStream = new FileOutputStream(\"output.txt\");\n           \n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n           \n        TaskA solver = new TaskA();\n        solver.solve(in, out);\n           \n           \n        out.close();\n    }\n}\n   \nclass TaskA {\n    public void solve(InputReader in, OutputWriter out) {\n        \n    \tint n = in.nextInt(), l = in.nextInt();\n    \tint x = in.nextInt(), y = in.nextInt();\n    \t\n    \tTreeSet<Integer> set = new TreeSet<Integer>();\n    \tint[] a = in.nextIntArray(n);\n    \tfor(int i=0; i<n; i++)\n    \t\tset.add(a[i]);\n    \t\n    \tboolean f1=false,f2=false;\n    \tfor(int i=0; i<n; i++){\n    \t\tif(set.contains(a[i]+x)) f1=true;\n    \t\tif(set.contains(a[i]+y)) f2=true;\n    \t}\n    \t\n    \tif(f1 && f2){\n    \t\tout.writeln(0);\n    \t}else{\n    \t\tif(f1){\n    \t\t\tout.writeln(1);\n    \t\t\tout.writeln(y);\n    \t\t}else if(f2){\n    \t\t\tout.writeln(1);\n    \t\t\tout.writeln(x);\n    \t\t}else{\n    \t\t\t\n    \t\t\tint d = y-x;\n    \t\t\tfor(int i=0; i<n; i++){\n    \t\t\t\tif(set.contains(a[i]+d)){\n    \t\t\t\t\tif(a[i]+y<=l){\n    \t\t\t\t\t\tout.writeln(1);\n    \t\t\t\t\t\tout.writeln(a[i]+y);\n    \t\t\t\t\t\treturn;\n    \t\t\t\t\t}else if(a[i]+d-y>=0){\n    \t\t\t\t\t\tout.writeln(1);\n    \t\t\t\t\t\tout.writeln(a[i]+d-y);\n    \t\t\t\t\t\treturn;\n    \t\t\t\t\t}\n    \t\t\t\t}else if(set.contains(a[i]+x+y)){\n    \t\t\t\t\tout.writeln(1);\n    \t\t\t\t\tout.writeln(a[i]+x);\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tout.writeln(2);\n    \t\t\tout.writeln(x+\" \"+y);\n    \t\t\t\n    \t\t}\n    \t}\n    \t\t\n    \t\n    }\n    \n    \n}\n\n \nclass InputReader{\n       \n    BufferedReader reader;\n    StringTokenizer tokenizer;\n       \n    public InputReader(InputStream stream){\n        tokenizer = null;\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n       \n    public String next(){\n        while(tokenizer==null || !tokenizer.hasMoreTokens()){\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n           \n        return tokenizer.nextToken();\n    }\n       \n    public String nextLine(){\n        tokenizer = null;\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException();\n        }\n    }\n       \n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n       \n    public long nextLong(){\n        return Long.parseLong(next());\n    }\n       \n    public double nextDouble(){\n        return Double.parseDouble(next());\n    }\n       \n    public int[] nextIntArray(int n){\n        int[] res = new int[n];\n        for(int i=0; i<n; i++)\n            res[i] = nextInt();\n           \n        return res;\n    }\n       \n}\n   \nclass OutputWriter{\n       \n    PrintWriter out;\n       \n    public OutputWriter(OutputStream stream){\n        out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(stream)));\n    }\n       \n    public void write(Object ...o){\n        for(Object cur : o)\n            out.print(cur);\n    }\n       \n    public void writeln(Object ...o){\n        write(o);\n        out.println();\n    }\n       \n    public void flush(){\n        out.flush();\n    }\n       \n    public void close(){\n        out.close();\n    }\n       \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint binsearch(const vector<int> &T, int orig, int beg, int end, int val) {\n  if (beg == end) {\n    if (T[beg] - T[orig] == val)\n      return beg;\n    else\n      return -1;\n  }\n  int sr = (beg + end) / 2;\n  if (T[sr] - T[orig] >= val)\n    return binsearch(T, orig, beg, sr, val);\n  else\n    return binsearch(T, orig, sr + 1, end, val);\n}\nvector<pair<int, int> > find_all(const vector<int> &T, int val) {\n  vector<pair<int, int> > ans;\n  int n = T.size();\n  for (int(i) = (0); i <= (n - 2); ++(i)) {\n    int a = binsearch(T, i, i + 1, n - 1, val);\n    if (a != -1) ans.push_back(make_pair(i, a));\n  }\n  return ans;\n}\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  vector<int> T(n);\n  vector<int> ans;\n  for (int i = 0; i < (n); ++i) scanf(\"%d\", &T[i]);\n  vector<pair<int, int> > X = find_all(T, x);\n  vector<pair<int, int> > Y = find_all(T, y);\n  if (X.empty() || Y.empty()) {\n    if (X.empty() && Y.empty()) {\n      vector<pair<int, int> > P = find_all(T, x + y);\n      if (!P.empty())\n        ans.push_back(T[P.front().first] + x);\n      else {\n        vector<pair<int, int> > N = find_all(T, y - x);\n        for (auto &&p : N) {\n          int a = T[p.first] - x, b = T[p.second] + x;\n          if (a > 0) {\n            ans.push_back(a);\n            break;\n          }\n          if (b < l) {\n            ans.push_back(b);\n            break;\n          }\n        }\n        if (ans.empty()) {\n          ans.push_back(x);\n          ans.push_back(y);\n        }\n      }\n    } else {\n      int a = (X.empty()) ? x : y;\n      ans.push_back(a);\n    }\n  }\n  printf(\"%d\\n\", (int)ans.size());\n  for (auto &&x : ans) printf(\"%d \", x);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\n/**\n *\n * @author umang\n */\n\npublic class D479 {\n    \n    public static int mod = 1000000007;\n\n    public static int[] p = new int[1000010];\n\n    public static void main(String[] args) {\n \n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        int n=in.nextInt();\n        long l=in.nextLong();\n        long x=in.nextLong();\n        long y=in.nextLong();\n        long[] arr=new long[n];\n        HashSet<Long> set=new HashSet<>();\n        long[] c=new long[2];  \n        \n        for(int i=0;i<n;i++){\n            arr[i]=in.nextInt();\n            set.add(arr[i]);\n        }\n        \n        if(set.contains(x)) c[0]=-1;\n        if(set.contains(y)) c[1]=-1;\n        for(int i=0;i<n;i++){\n            if(set.contains(x+arr[i])) c[0]=-1;\n            if(set.contains(y+arr[i])) c[1]=-1;            \n        }\n        \n        if(c[0]==-1 && c[1]==-1){\n            w.println(0);\n        }\n        else if(c[0]==-1){\n            w.println(1);\n            w.println(y);\n        }\n        else if(c[1]==-1){\n            w.println(1);\n            w.println(x);\n        }\n        else{\n            c[0]=c[1]=-1;\n            for(int i=0;i<n;i++){\n                if(set.contains(arr[i]+x+y)){\n                    c[0]=arr[i]+x;\n                    break;\n                }\n                if(set.contains(arr[i]+y-x)){\n                    c[0]=arr[i]-x;\n                    if(c[0]<0){\n                        c[0]=arr[i]+y;\n                        if(c[0]<=l) break;\n                        else{\n                            c[0]=-1;\n                        }\n                    }\n                }\n            }\n            if(c[0]==-1){\n                w.println(2);\n                w.println(x+\" \"+y);\n            }\n            else{\n                w.println(1);\n                w.println(c[0]);\n            }\n        }\n        \n        w.close();\n    }\n    \n    public static boolean isPal(String s){\n        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n                if(s.charAt(i)!=s.charAt(j)) return false;\n        }\n        return true;\n    }\n    public static String rev(String s){\n\t\tStringBuilder sb=new StringBuilder(s);\n\t\tsb.reverse();\n\t\treturn sb.toString();\n    }\n    \n    public static long gcd(long x,long y){\n\tif(x%y==0)\n\t\treturn y;\n\telse\n\t\treturn gcd(y,x%y);\n    }\n    \n    public static int gcd(int x,int y){\n\tif(x%y==0)\n\t\treturn y;\n\telse \n\t\treturn gcd(y,x%y);\n    }\n    \n    public static long gcdExtended(long a,long b,long[] x){\n        \n        if(a==0){\n            x[0]=0;\n            x[1]=1;\n            return b;\n        }\n        long[] y=new long[2];\n        long gcd=gcdExtended(b%a, a, y);\n        \n        x[0]=y[1]-(b/a)*y[0];\n        x[1]=y[0];\n        \n        return gcd;\n    }\n    \n    public static int abs(int a,int b){\n\treturn (int)Math.abs(a-b);\n    }\n\n    public static long abs(long a,long b){\n\treturn (long)Math.abs(a-b);\n    }\n    \n    public static int max(int a,int b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static int min(int a,int b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n    \n    public static long max(long a,long b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static long min(long a,long b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n\n    public static long pow(long n,long p,long m){\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n    }\n    \n    public static long pow(long n,long p){\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n    }\n    \n    static class Pair{\n\t\tint x;\n\t\tint y;\n\t\tPair(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n    \n    public static class CompareTable implements Comparator{\n        public int compare(Object o1,Object o2){\n            Pair p1 = (Pair) o1;\n            Pair p2 = (Pair) o2;\n            \n            if(p1.x>p2.x)\n                return -1;\n            else if(p1.x<p2.x)\n                return 1;\n            else{\n                if(p1.y<p2.y)\n                    return -1;\n                else if(p1.y>p2.y)\n                    return 1;\n                else\n                    return 0;\n            }\n        }\n    }\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}    \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char const *argv[]) {\n  long n, l, x, y, num;\n  cin >> n >> l >> x >> y;\n  long arr[n];\n  unordered_set<long> st;\n  for (int i = 0; i < n; i++) {\n    cin >> num;\n    arr[i] = num;\n    st.insert(num);\n  }\n  bool xposs = false, yposs = false;\n  for (int i = 0; i < n - 1 and !xposs; i++) {\n    if (st.find(arr[i] + x) != st.end()) xposs = true;\n  }\n  for (int i = 0; i < n - 1 and !yposs; i++) {\n    if (st.find(arr[i] + y) != st.end()) yposs = true;\n  }\n  long mn = *min_element(arr, arr + n);\n  if (xposs and yposs)\n    cout << 0 << endl;\n  else if (xposs)\n    cout << 1 << endl << mn + y << endl;\n  else if (yposs)\n    cout << 1 << endl << mn + x << endl;\n  else {\n    unordered_set<long> pmx;\n    for (int i = 0; i < n; i++) {\n      if (arr[i] + x <= l) pmx.insert(arr[i] + x);\n      if (arr[i] - x >= 0) pmx.insert(arr[i] - x);\n    }\n    int oneval = -1;\n    for (int i = 0; i < n and oneval == -1; i++) {\n      if ((arr[i] + y <= l) and pmx.find(arr[i] + y) != pmx.end())\n        oneval = arr[i] + y;\n      if ((arr[i] - y >= 0) and pmx.find(arr[i] - y) != pmx.end())\n        oneval = arr[i] - y;\n    }\n    if (oneval != -1)\n      cout << 1 << endl << oneval << endl;\n    else\n      cout << 2 << endl << mn + x << \" \" << mn + y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100005];\npair<int, int> find_first(int pos) {\n  int lp = 0;\n  for (int rp = 0; rp < n; rp++) {\n    while (lp < n && a[lp] + pos < a[rp]) lp++;\n    if (a[lp] + pos == a[rp]) return make_pair(a[lp], a[rp]);\n  }\n  return make_pair(-1, -1);\n}\npair<int, int> find_last(int pos) {\n  int rp = n - 1;\n  for (int lp = n - 1; lp >= 0; lp--) {\n    while (rp >= 0 && a[lp] + pos < a[rp]) rp--;\n    if (a[lp] + pos == a[rp]) return make_pair(a[lp], a[rp]);\n  }\n  return make_pair(-1, -1);\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  bool findX = (find_first(x) != make_pair(-1, -1));\n  bool findY = (find_first(y) != make_pair(-1, -1));\n  if (findX && findY) {\n    cout << 0;\n    return 0;\n  }\n  if (findX) {\n    cout << 1 << endl << y;\n    return 0;\n  }\n  if (findY) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  pair<int, int> ans = find_first(x + y);\n  if (ans != make_pair(-1, -1)) {\n    cout << 1 << endl << ans.first + x;\n    return 0;\n  }\n  ans = find_first(y - x);\n  if (ans != make_pair(-1, -1) && ans.first + y < l) {\n    cout << 1 << endl << ans.first + y;\n    return 0;\n  }\n  ans = find_last(y - x);\n  if (ans != make_pair(-1, -1) && ans.first - x >= 0) {\n    cout << 1 << endl << ans.first - x;\n    return 0;\n  }\n  cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class B {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint l = io.nextInt();\n\t\t\tint x = io.nextInt();\n\t\t\tint y = io.nextInt();\n\t\t\t\n\t\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\t\tTreeSet<Integer> setX = new TreeSet<>();\n\t\t\tTreeSet<Integer> setY = new TreeSet<>();\n\t\t\tint[] ps = io.nextIntArray(n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tset.add(ps[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint flag = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(set.contains(ps[i] + x) ||\n\t\t\t\t\tset.contains(ps[i] - x)) { flag |= 1; }\n\t\t\t\telse {\n\t\t\t\t\tsetX.add(ps[i] + x);\n\t\t\t\t\tsetX.add(ps[i] - x);\n\t\t\t\t}\n\n\t\t\t\tif(set.contains(ps[i] + y) ||\n\t\t\t\t\tset.contains(ps[i] - y)) { flag |= 2; }\n\t\t\t\telse {\n\t\t\t\t\tsetY.add(ps[i] + y);\n\t\t\t\t\tsetY.add(ps[i] - y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 3) {\n\t\t\t\tio.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(flag == 1) {\n\t\t\t\tio.out.println(1);\n\t\t\t\tio.out.println(y);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(flag == 2) {\n\t\t\t\tio.out.println(1);\n\t\t\t\tio.out.println(x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(!setX.isEmpty() && !setY.isEmpty()) {\n\t\t\t\tint x0 = setX.first();\n\t\t\t\tint y0 = setY.first();\n\t\t\t\tif(x0 == y0 && x0 >= 0 && x0 <= l) {\n\t\t\t\t\tio.out.println(1);\n\t\t\t\t\tio.out.println(x0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(x0 < y0) setX.pollFirst();\n\t\t\t\telse setY.pollFirst();\n\t\t\t}\n\t\t\tio.out.println(2 + \" \" + x + \" \" + y);\n\t\t}\n\t}\n\t\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new B().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    private final Reader reader;\n\n    private final Writer writer;\n\n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n\n    }\n\n    private void solve() throws IOException {\n        int N = reader.nextUnsignedInt();\n        int L = reader.nextUnsignedInt();\n        int X = reader.nextUnsignedInt();\n        int Y = reader.nextUnsignedInt();\n        int A[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = reader.nextUnsignedInt();\n        }\n\n        if (both(X, Y, A)) {\n            writer.print(\"0\\n\");\n        } else {\n            int mark = single(N, L, X, Y, A);\n            if (mark != -1) {\n                writer.print(\"1\\n\");\n                writer.print(mark + \"\\n\");\n            } else {\n                writer.print(\"2\\n\");\n                writer.print(X + \" \" + Y + \"\\n\");\n            }\n        }\n        writer.flush();\n\n    }\n\n    private boolean both(int X, int Y, int[] A) {\n        boolean x_found = false, y_found = false;\n\n        for (int i = 0; i < A.length; i++) {\n            if (Arrays.binarySearch(A, A[i] + X) >= 0) {\n                x_found = true;\n            }\n            if (Arrays.binarySearch(A, A[i] + Y) >= 0) {\n                y_found = true;\n            }\n\n        }\n        return x_found && y_found;\n    }\n\n    private int single(int N, int L, int X, int Y, int[] A) {\n\n        for (int i = 0; i < N; i++) {\n            if (A[i] + X <= L && (Arrays.binarySearch(A, A[i] + X - Y) >= 0 || Arrays.binarySearch(A, A[i] + X + Y) >= 0)) {\n                return A[i] + X;\n            }\n            if (A[i] - X >= 0 && (Arrays.binarySearch(A, A[i] - X - Y) >= 0 || Arrays.binarySearch(A, A[i] - X + Y) >= 0)) {\n                return A[i] - X;\n            }\n            if (Arrays.binarySearch(A, A[i] + X) >= 0) {\n                return Y;\n            }\n            if (Arrays.binarySearch(A, A[i] + Y) >= 0) {\n                return X;\n            }\n        }\n        return -1;\n\n    }\n\n    private static class Tower implements Comparable<Tower> {\n        private int a;\n        private int b;\n\n        public Tower(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n\n        @Override\n        public int compareTo(Tower o) {\n            return this.a == o.a ? this.b - o.b : this.a - o.a;\n        }\n    }\n\n\n\n    Main(InputStream in, OutputStream out) {\n        this.reader = new Reader(in);\n        this.writer = new Writer(out);\n    }\n\n    public Main() {\n        this.reader = new Reader();\n        this.writer = new Writer();\n    }\n\n\n}\n\nclass Reader {\n\n    private final int BUFFER_SIZE = 65536;\n\n    private final DataInputStream din;\n\n    private final byte[] buffer;\n\n    private int bufferPointer, bytesRead;\n\n    Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(InputStream in) {\n        din = new DataInputStream(in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public long nextUnsignedLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= 32) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        return ret;\n    }\n\n    public int nextUnsignedInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= 32) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        return ret;\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) {\n            c = read();\n        }\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        if (neg) {\n            return -ret;\n        }\n        return ret;\n    }\n\n    public String nextString(int MAX) throws IOException {\n        int cnt = 0;\n        char[] buf = new char[MAX];\n        byte c;\n        while ((c = read()) < 33) ;\n        buf[cnt++] = (char) c;\n        while ((c = read()) >= 33) {\n            buf[cnt++] = (char) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public char firstCharOfNextUnSpacedString() throws IOException {\n        byte c;\n        char res;\n        while ((c = read()) < 33) ;\n        res = (char) c;\n        while ((c = read()) >= 33) ;\n        return res;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) {\n            buffer[0] = -1;\n        }\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead) {\n            fillBuffer();\n        }\n        return buffer[bufferPointer++];\n    }\n}\n\nclass Writer {\n    private final BufferedWriter out;\n\n    Writer() {\n        out = new BufferedWriter(new OutputStreamWriter(System.out), 512);\n    }\n\n    public Writer(OutputStream out) {\n        this.out = new BufferedWriter(new OutputStreamWriter(out), 512);\n    }\n\n    void print(char c) throws IOException {\n        out.write(c);\n    }\n\n    void print(String str) throws IOException {\n        out.write(str);\n    }\n\n    void println() throws IOException {\n        out.write(\"\\n\");\n    }\n\n    void flush() throws IOException {\n        out.flush();\n    }\n\n    @Override\n    protected void finalize() throws IOException {\n        out.flush();\n    }\n}"
        },
        {
            "language": 1,
            "solution": "par = map(int, raw_input().split(\" \"))\nn, l, x, y = par[0], par[1], par[2], par[3]\na = map(int, raw_input().split(\" \"))\n\nmarkx = set()\nmarky = set()\n\n\nfor item in a:\n    if item -x >= 0:\n        markx.add(item - x)\n    if x + item <= l:\n        markx.add(x + item)\n    if item - y >= 0:\n        marky.add(item - y)\n    if y + item <= l:\n        marky.add(y + item)\n\n#print markx\n#print marky\n\nfor item in a:\n    if item in markx:\n        markx = None\n        break\nfor item in a:\n    if item in marky:\n        marky = None\n        break\n\nif markx == None and marky == None:\n    print 0\nelif markx == None:\n    print 1\n    print marky.pop()\nelif marky == None:\n    print 1\n    print markx.pop()\nelse:\n    intersect = (markx & marky)\n    if len(intersect) == 0:\n        print 2\n        print markx.pop(), marky.pop()\n    else:\n        print 1\n        print intersect.pop()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100 * 1000 + 100;\nlong long a[maxn];\nset<long long> s;\nvector<int> v;\nvoid f();\nint main() {\n  long long n, l, x, y, siz;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  int isx = 0, isy = 0;\n  for (int i = 0; i < n; i++) s.insert(a[i]);\n  for (int i = 0; i < n; i++) {\n    if (a[i] - x >= 0) {\n      siz = s.size();\n      s.insert(a[i] - x);\n      if (siz == s.size()) isx = 1;\n    }\n  }\n  s.clear();\n  for (int i = 0; i < n; i++) s.insert(a[i]);\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x <= l) {\n      siz = s.size();\n      s.insert(a[i] + x);\n      if (siz == s.size()) isx = 1;\n    }\n  }\n  s.clear();\n  for (int i = 0; i < n; i++) s.insert(a[i]);\n  for (int i = 0; i < n; i++) {\n    if (a[i] - y >= 0) {\n      siz = s.size();\n      s.insert(a[i] - y);\n      if (siz == s.size()) isy = 1;\n    }\n  }\n  s.clear();\n  for (int i = 0; i < n; i++) s.insert(a[i]);\n  for (int i = 0; i < n; i++) {\n    if (a[i] + y <= l) {\n      siz = s.size();\n      s.insert(a[i] + y);\n      if (siz == s.size()) isy = 1;\n    }\n  }\n  s.clear();\n  if (isx == 1 && isy == 1) {\n    cout << 0 << endl;\n    exit(0);\n  }\n  long long ind = -1;\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x <= l) s.insert(a[i] + x);\n    if (a[i] - x >= 0) s.insert(a[i] - x);\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] - y >= 0) {\n      siz = s.size();\n      s.insert(a[i] - y);\n      if (siz == s.size()) ind = a[i] - y;\n    }\n  }\n  s.clear();\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x <= l) s.insert(a[i] + x);\n    if (a[i] - x >= 0) s.insert(a[i] - x);\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] + y <= l) {\n      siz = s.size();\n      s.insert(a[i] + y);\n      if (siz == s.size()) ind = a[i] + y;\n    }\n  }\n  s.clear();\n  if (ind != -1)\n    cout << 1 << '\\n' << ind << endl;\n  else if (isx)\n    cout << 1 << '\\n' << y << endl;\n  else if (isy)\n    cout << 1 << '\\n' << x << endl;\n  else\n    cout << 2 << '\\n' << x << ' ' << y << endl;\n  cin >> n;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package LongJumps;\n\n\n\nimport java.util.Scanner;\n\n/**\n *\n * @author zhassan\n */\npublic class LongJumos {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n\n        int marks[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            marks[i] = in.nextInt();\n        }\n\n        int mx = x;\n        int my = y;\n        \n        if(doesExist(x,0,n,marks)){ \n        \tmx = 0;\n        }\n      \n        if(doesExist(y,0,n,marks)){\n        \tmy = 0;\n        }\n      \n        if(mx+my == 0){\n        \tSystem.out.println(0);\n        \tSystem.exit(0);\n        } else if(mx == 0){\n        \t\n        \tfor(int i = 0;i<n;i++){\n        \t\tif(doesExist((marks[i]-y),0,n,marks)){\n        \t\t\tSystem.out.println(0);\n        \t\t\tSystem.exit(0);\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println(1);\n        \tSystem.out.println(my);\n        \tSystem.exit(0);\n        } else if(my == 0){\n        \tfor(int i = 0;i<n;i++){\n        \t\tif(doesExist((marks[i]-x),0,n,marks)){\n        \t\t\tSystem.out.println(0);\n        \t\t\tSystem.exit(0);\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println(1);\n        \tSystem.out.println(mx);\n        \tSystem.exit(0);\n        } else {\n        \tfor(int i = 0;i<n;i++){\n        \t\tif(doesExist((marks[i]-y),0,n,marks)){\n        \t        my = 0;\n        \t\t}\n        \t\t\n        \t\tif(doesExist((marks[i]-x),0,n,marks)){\n    \t            mx = 0;\n    \t\t     }\n        \t}\n        \t\n        \tif(mx+my == 0){\n        \t\tSystem.out.println(0);\n        \t\tSystem.exit(0);\n        \t} else if(my == 0){\n        \t\tSystem.out.println(1);\n        \t\tSystem.out.println(mx);\n        \t\tSystem.exit(0);\n        \t} else if(mx == 0){\n        \t\tSystem.out.println(1);\n        \t\tSystem.out.println(my);\n        \t\tSystem.exit(0);\n        \t} else {\n        \t\t\n        \t\tint dx[] = new int[n];\n        \t\tint dy[] = new int[n];\n        \t\tint sx[] = new int[n];\n        \t\tint sy[] = new int[n];\n        \t\tfor(int i = 0;i<n;i++){\n        \t\t\tdx[i] = (marks[i]-x);sx[i] = (marks[i]+x);\n        \t\t\tdy[i] = (marks[i]-y);sy[i] = (marks[i]+y);\n        \t\t}\n        \t\t\n        \t\tfor(int i = 0;i<n;i++){\n        \t\t\t\n        \t\t\tif(doesExist(y,0,n,dx)){\n        \t\t\t\tSystem.out.println(1);\n        \t\t\t\tSystem.out.println(x);\n        \t\t\t\tSystem.exit(0);\n        \t\t\t}\n        \t\t\t\n        \t\t\tif(doesExist(dx[i],0,n,dy)){\n        \t\t\t\tif(dx[i]>0){\n        \t\t\t\t  System.out.println(1);\n        \t\t\t\t  System.out.println(dx[i]);\n        \t\t\t\t  System.exit(0);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\t\n\n\t\t\t\t\tif(sx[i]<l&&doesExist(sx[i],0,n,sy)){\n\t\t\t\t      System.out.println(1);\n       \t\t\t\t  System.out.println(sx[i]);\n       \t\t\t\t  System.exit(0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(dy[i]>0&&doesExist(dy[i],0,n,sx)){\n\t\t\t\t\t\tSystem.out.println(1);\n\t       \t\t\t\tSystem.out.println(dy[i]);\n\t       \t\t\t\tSystem.exit(0);\n\t\t\t\t\t}\n        \t\t\t\n        \t\t}\n        \t\t\n        \t\tSystem.out.println(2);\n        \t\tSystem.out.println(mx+\" \"+my);\n        \t\tSystem.exit(0);\n        \t\t\n        \t}\n        \t\n        }\n       \n    }\n\n\n    private static boolean doesExist(int n, int s, int f, int[] a) {\n        if (s + 1 == f) {\n            if (a[s] == n || (f < a.length && a[f] == n)) {\n                return true;\n            } \n            \n            return false;\n        } else { \n\n        int middle = (s + f) / 2;\n        if (n > a[middle]) {\n            return doesExist(n, middle, f, a);\n        } else if(n<a[middle]){\n            return doesExist(n, s, middle, a);\n        } else {\n        \treturn true;\n        }\n         \n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(new BufferedInputStream(System.in));\n\t\twhile (in.hasNext()) {\n\t\t\tint n = in.nextInt(), l = in.nextInt(), x = in.nextInt(), y = in\n\t\t\t\t\t.nextInt();\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tHashSet<Integer> set2 = new HashSet<Integer>();\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = in.nextInt();\n\t\t\t\tset.add(a[i]);\n\t\t\t}\n\t\t\tboolean ok1 = false, ok2 = false;\n\t\t\tfor (int i = 0; i < n && !ok1; i++)\n\t\t\t\tif (set.contains(a[i] + x))\n\t\t\t\t\tok1 = true;\n\t\t\t\telse {\n\t\t\t\t\tif (a[i] + x < l)\n\t\t\t\t\t\tset2.add(a[i] + x);\n\t\t\t\t\tif (a[i] - x > 0)\n\t\t\t\t\t\tset2.add(a[i] - x);\n\t\t\t\t}\n\n\t\t\tfor (int i = 0; a[i] <= l - y; i++) {\n\t\t\t\tif (set.contains(a[i] + y))\n\t\t\t\t\tok2 = true;\n\t\t\t}\n\t\t\tList<Integer> ans = new ArrayList<Integer>();\n\n\t\t\tif (ok1 ^ ok2)\n\t\t\t\tans.add(ok2 ? x : y);\n\t\t\telse if (!ok1 && !ok2) {\n\t\t\t\tfor (int i = 0; i < n && ans.size() == 0; i++) {\n\t\t\t\t\tif (set2.contains(a[i] + y))\n\t\t\t\t\t\tans.add(a[i] + y);\n\t\t\t\t\telse if (set2.contains(a[i] - y))\n\t\t\t\t\t\tans.add(a[i] - y);\n\t\t\t\t}\n\t\t\t\tif (ans.size() == 0) {\n\t\t\t\t\tans.add(x);\n\t\t\t\t\tans.add(y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.size());\n\t\t\tif (ans.size() > 0)\n\t\t\t\tSystem.out.println(ans.get(0)\n\t\t\t\t\t\t+ (ans.size() > 1 ? \" \" + ans.get(1) : \"\"));\n\t\t}\n\t\tin.close();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nvector<int> v;\nmap<int, bool> mark;\nbool mark1, mark2;\nint a[maxn];\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    mark[a[i]] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (mark[a[i] + x] == 1 or mark[a[i] - x] == 1) {\n      mark1 = true;\n    }\n    if (mark[a[i] + y] == 1 or mark[a[i] - y] == 1) {\n      mark2 = true;\n    }\n  }\n  if (mark1 == false) {\n    v.push_back(x);\n  }\n  if (mark2 == false) {\n    v.push_back(y);\n  }\n  if (v.size() != 2) {\n    cout << v.size() << endl;\n    for (int i = 0; i < v.size(); i++) {\n      cout << v[i] << \" \";\n    }\n    return 0;\n  }\n  int d = abs(y - x);\n  for (int i = 1; i <= n; i++) {\n    if (mark[a[i] + d] == 1 and a[i] + max(x, y) <= l) {\n      cout << 1 << endl;\n      return cout << a[i] + max(x, y) << endl, 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (mark[a[i] + x + y] == 1 and a[i] + x <= l) {\n      cout << 1 << endl;\n      return cout << a[i] + x << endl, 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (mark[d + a[i]] == 1 and a[i] - min(x, y) >= 0) {\n      cout << 1 << endl;\n      return cout << a[i] - min(x, y) << endl, 0;\n    }\n  }\n  cout << v.size() << endl;\n  for (int i = 0; i < v.size(); i++) {\n    cout << v[i] << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000111;\nset<int> x, y;\nint marks[MAXN];\nset<int> pop;\nint main() {\n  int n, l, xx, yy;\n  scanf(\"%d%d%d%d\", &n, &l, &xx, &yy);\n  int xw = 0, yw = 0;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    pop.insert(a);\n    if (pop.find(a - xx) != pop.end()) xw = 1;\n    if (pop.find(a - yy) != pop.end()) yw = 1;\n    if (a - xx >= 0) x.insert(a - xx);\n    if (a + xx <= l) x.insert(a + xx);\n    if (a - yy >= 0) y.insert(a - yy);\n    if (a + yy <= l) y.insert(a + yy);\n  }\n  if (xw == 1 && yw == 1) {\n    puts(\"0\");\n    return 0;\n  }\n  if (xw == 1) {\n    printf(\"1\\n%d\\n\", *(y.begin()));\n    return 0;\n  }\n  if (yw == 1) {\n    printf(\"1\\n%d\\n\", *(x.begin()));\n    return 0;\n  }\n  for (auto x1 : x) {\n    if (y.find(x1) != y.end()) {\n      printf(\"1\\n%d\\n\", x1);\n      return 0;\n    }\n  }\n  puts(\"2\");\n  printf(\"%d %d\\n\", *(x.begin()), *(y.begin()));\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    void solve() throws IOException {\n        int n = readInt();\n        int l = readInt();\n        int x = readInt();\n        int y = readInt();\n\n        int[] a = new int[n];\n        Set<Integer> set = new HashSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            a[i] = readInt();\n            set.add(a[i]);\n        }\n        boolean xOk = false, yOk = false;\n        for (int v : a) {\n            if (set.contains(v + x)) {\n                xOk = true;\n            }\n            if (set.contains(v + y)) {\n                yOk = true;\n            }\n        }\n        if (xOk && yOk) {\n            out.println(0);\n            return;\n        }\n\n        if (xOk) {\n            out.println(1);\n            out.println(y);\n            return;\n        }\n        if (yOk) {\n            out.println(1);\n            out.println(x);\n            return;\n        }\n\n        int S = -1;\n        for (int v : a) {\n            int s = v - x;\n            if (s >= 0) {\n                if (set.contains(s - y) || set.contains(s + y)) {\n                    S = s;\n                }\n            }\n            s = v + x;\n            if (s <= l) {\n                if (set.contains(s - y) || set.contains(s + y)) {\n                    S = s;\n                }\n            }\n            s = v - y;\n            if (s >= 0) {\n                if (set.contains(s - x) || set.contains(s + x)) {\n                    S = s;\n                }\n            }\n            s = v + y;\n            if (s <= l) {\n                if (set.contains(s - x) || set.contains(s + x)) {\n                    S = s;\n                }\n            }\n        }\n        if (S != -1) {\n            out.println(1);\n            out.println(S);\n            return;\n        }\n        out.println(2);\n        out.println(x + \" \" + y);\n    }\n\n    //-------------------------------------------------\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n\n    public void run() {\n        try {\n            long startTime = System.currentTimeMillis();\n            Locale.setDefault(Locale.US);\n            if (ONLINE_JUDGE) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            tok = new StringTokenizer(\"\");\n            solve();\n            in.close();\n            out.close();\n            long endTime = System.currentTimeMillis();\n            long totalMemory = Runtime.getRuntime().totalMemory();\n            long freeMemory = Runtime.getRuntime().freeMemory();\n            System.err.println(\"Time = \" + (endTime - startTime) + \" ms\");\n            System.err.println(\"Memory = \" + ((totalMemory - freeMemory) / 1024) + \" KB\");\n        } catch (Throwable e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    void debug(Object... o) {\n        if (!ONLINE_JUDGE) {\n            System.err.println(Arrays.deepToString(o));\n        }\n    }\n\n    public static void main(String[] args) {\n        new Solution().run();\n    }\n\n\n    //------------------------------------------------------------------------------\n    static class Mergesort {\n\n        private Mergesort() {\n        }\n\n        public static void sort(int[] a) {\n            mergesort(a, 0, a.length - 1);\n        }\n\n        public static void sort(long[] a) {\n            mergesort(a, 0, a.length - 1);\n        }\n\n        public static void sort(double[] a) {\n            mergesort(a, 0, a.length - 1);\n        }\n\n        private static final int MAGIC_VALUE = 42;\n\n        private static void mergesort(int[] a, int leftIndex, int rightIndex) {\n            if (leftIndex < rightIndex) {\n                if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                    insertionSort(a, leftIndex, rightIndex);\n                } else {\n                    int middleIndex = (leftIndex + rightIndex) / 2;\n                    mergesort(a, leftIndex, middleIndex);\n                    mergesort(a, middleIndex + 1, rightIndex);\n                    merge(a, leftIndex, middleIndex, rightIndex);\n                }\n            }\n        }\n\n        private static void mergesort(long[] a, int leftIndex, int rightIndex) {\n            if (leftIndex < rightIndex) {\n                if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                    insertionSort(a, leftIndex, rightIndex);\n                } else {\n                    int middleIndex = (leftIndex + rightIndex) / 2;\n                    mergesort(a, leftIndex, middleIndex);\n                    mergesort(a, middleIndex + 1, rightIndex);\n                    merge(a, leftIndex, middleIndex, rightIndex);\n                }\n            }\n        }\n\n        private static void mergesort(double[] a, int leftIndex, int rightIndex) {\n            if (leftIndex < rightIndex) {\n                if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                    insertionSort(a, leftIndex, rightIndex);\n                } else {\n                    int middleIndex = (leftIndex + rightIndex) / 2;\n                    mergesort(a, leftIndex, middleIndex);\n                    mergesort(a, middleIndex + 1, rightIndex);\n                    merge(a, leftIndex, middleIndex, rightIndex);\n                }\n            }\n        }\n\n        private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n            int length1 = middleIndex - leftIndex + 1;\n            int length2 = rightIndex - middleIndex;\n            int[] leftArray = new int[length1];\n            int[] rightArray = new int[length2];\n            System.arraycopy(a, leftIndex, leftArray, 0, length1);\n            System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n            for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n                if (i == length1) {\n                    a[k] = rightArray[j++];\n                } else if (j == length2) {\n                    a[k] = leftArray[i++];\n                } else {\n                    a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n                }\n            }\n        }\n\n        private static void merge(long[] a, int leftIndex, int middleIndex, int rightIndex) {\n            int length1 = middleIndex - leftIndex + 1;\n            int length2 = rightIndex - middleIndex;\n            long[] leftArray = new long[length1];\n            long[] rightArray = new long[length2];\n            System.arraycopy(a, leftIndex, leftArray, 0, length1);\n            System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n            for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n                if (i == length1) {\n                    a[k] = rightArray[j++];\n                } else if (j == length2) {\n                    a[k] = leftArray[i++];\n                } else {\n                    a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n                }\n            }\n        }\n\n        private static void merge(double[] a, int leftIndex, int middleIndex, int rightIndex) {\n            int length1 = middleIndex - leftIndex + 1;\n            int length2 = rightIndex - middleIndex;\n            double[] leftArray = new double[length1];\n            double[] rightArray = new double[length2];\n            System.arraycopy(a, leftIndex, leftArray, 0, length1);\n            System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n            for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n                if (i == length1) {\n                    a[k] = rightArray[j++];\n                } else if (j == length2) {\n                    a[k] = leftArray[i++];\n                } else {\n                    a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n                }\n            }\n        }\n\n        private static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n            for (int i = leftIndex + 1; i <= rightIndex; i++) {\n                int current = a[i];\n                int j = i - 1;\n                while (j >= leftIndex && a[j] > current) {\n                    a[j + 1] = a[j];\n                    j--;\n                }\n                a[j + 1] = current;\n            }\n        }\n\n        private static void insertionSort(long[] a, int leftIndex, int rightIndex) {\n            for (int i = leftIndex + 1; i <= rightIndex; i++) {\n                long current = a[i];\n                int j = i - 1;\n                while (j >= leftIndex && a[j] > current) {\n                    a[j + 1] = a[j];\n                    j--;\n                }\n                a[j + 1] = current;\n            }\n        }\n\n        private static void insertionSort(double[] a, int leftIndex, int rightIndex) {\n            for (int i = leftIndex + 1; i <= rightIndex; i++) {\n                double current = a[i];\n                int j = i - 1;\n                while (j >= leftIndex && a[j] > current) {\n                    a[j + 1] = a[j];\n                    j--;\n                }\n                a[j + 1] = current;\n            }\n        }\n\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cando(const set<int>& S, int x) {\n  for (set<int>::const_iterator it = S.begin(); it != S.end(); ++it) {\n    int v = *it;\n    if (S.count(v - x) || S.count(v + x)) return true;\n  }\n  return false;\n}\nint main() {\n  set<int> S;\n  int N, L, X, Y, v;\n  scanf(\"%d%d%d%d\", &N, &L, &X, &Y);\n  for (int i = 0; i < (N); ++i) scanf(\"%d\", &v), S.insert(v);\n  if (cando(S, X) && cando(S, Y)) {\n    cout << 0 << endl;\n    return 0;\n  } else if (cando(S, X)) {\n    cout << 1 << endl;\n    cout << L - Y << endl;\n    return 0;\n  } else if (cando(S, Y)) {\n    cout << 1 << endl;\n    cout << L - X << endl;\n    return 0;\n  }\n  for (set<int>::iterator it = S.begin(); it != S.end(); ++it) {\n    int xx = *it;\n    long long nw = xx - X;\n    long long yy = nw - Y;\n    assert(!S.count(nw));\n    assert(abs(nw - xx) == X);\n    assert(abs(nw - yy) == Y);\n    if ((0 <= (nw) && (nw) <= L) && (0 <= (xx) && (xx) <= L) &&\n        (0 <= (yy) && (yy) <= L) && S.count(xx) && S.count(yy)) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  };\n  for (set<int>::iterator it = S.begin(); it != S.end(); ++it) {\n    int xx = *it;\n    long long nw = xx + X;\n    long long yy = nw - Y;\n    assert(!S.count(nw));\n    assert(abs(nw - xx) == X);\n    assert(abs(nw - yy) == Y);\n    if ((0 <= (nw) && (nw) <= L) && (0 <= (xx) && (xx) <= L) &&\n        (0 <= (yy) && (yy) <= L) && S.count(xx) && S.count(yy)) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  };\n  for (set<int>::iterator it = S.begin(); it != S.end(); ++it) {\n    int xx = *it;\n    long long nw = xx + X;\n    long long yy = nw + Y;\n    assert(!S.count(nw));\n    assert(abs(nw - xx) == X);\n    assert(abs(nw - yy) == Y);\n    if ((0 <= (nw) && (nw) <= L) && (0 <= (xx) && (xx) <= L) &&\n        (0 <= (yy) && (yy) <= L) && S.count(xx) && S.count(yy)) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  };\n  for (set<int>::iterator it = S.begin(); it != S.end(); ++it) {\n    int xx = *it;\n    long long nw = xx - X;\n    long long yy = nw + Y;\n    assert(!S.count(nw));\n    assert(abs(nw - xx) == X);\n    assert(abs(nw - yy) == Y);\n    if ((0 <= (nw) && (nw) <= L) && (0 <= (xx) && (xx) <= L) &&\n        (0 <= (yy) && (yy) <= L) && S.count(xx) && S.count(yy)) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  };\n  cout << 2 << endl;\n  cout << L - X << \" \" << L - Y << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint l = io.nextInt();\n\t\tint x = io.nextInt();\n\t\tint y = io.nextInt();\n\t\tint[] a = io.arrayInt(n);\n\t\tint foundX = diffSearch(a, 0, 0, x) != null ? 1 : 0;\n\t\tint foundY = diffSearch(a, 0, 0, y) != null ? 1 : 0;\n\t\tint f = foundX + foundY;\n\t\tif (f > 0) {\n\t\t\tif (f == 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(foundX == 1 ? y : x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tPair foundXPlusY = diffSearch(a, 0, 0, x+y);\n\t\tif (foundXPlusY != null) {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(a[foundXPlusY.i] + x);\n\t\t\treturn;\n\t\t}\n\t\tint i=0, j=0;\n\t\tint diff = y - x;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(;j<n;j++) {\n\t\t\t\tif (a[j] - a[i] >= diff) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[j] - a[i] == diff) {\n\t\t\t\tif (a[i] >= x) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i]-x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (a[i] + y <= l) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i]+y);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(2);\n\t\tSystem.out.println(x + \" \" + y);\n\t}\n\n\tpublic static Pair diffSearch(int[] a,int s,int g,int diff) {\n\t\tint n = a.length;\n\t\tint i=s,j=g;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(;j<n;j++) {\n\t\t\t\tif (a[j] - a[i] >= diff) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[j] - a[i] == diff) {\n\t\t\t\treturn new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic class Pair {\n\t\tint i,j;\n\t\tpublic Pair(int i,int j) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t}\n\n}\nclass IO {\n\tBufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n\tStringBuilder out = new StringBuilder();\n\tint index = 0;\n\tString bfl = null;\n\tString[] bf = new String[0];\n\tprivate boolean read() {\n\t\ttry {\n\t\t\tbfl = bi.readLine();\n\t\t\tif (bfl == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbf = bfl.split(\"\\\\s\");\n\t\t\tindex = 0;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}\n\tpublic boolean hasNext() { return index < bf.length ? true : read(); }\n\tpublic boolean hasNextLine() { return read(); }\n\tpublic String next() { return hasNext() ? bf[index++] : null; }\n\tpublic String nextLine() { if (hasNextLine()) {index = bf.length; return bfl; }else return null; }\n\tpublic int nextInt() { return Integer.parseInt(next()); }\n\tpublic long nextLong() { return Long.parseLong(next()); }\n\tpublic double nextDouble() { return Double.parseDouble(next()); };\n\tpublic char nextChar() { return next().charAt(0); }\n\tpublic void println(long x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(double x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(String s) { out.append(s); out.append(\"\\n\"); }\n\tpublic void println() { out.append(\"\\n\"); }\n\tpublic void print(long x) { out.append(x); }\n\tpublic void print(double x) { out.append(x); }\n\tpublic void print(String s) { out.append(s); }\n\tpublic void print(char c) {out.append(c);}\n\tpublic void flush() {System.out.print(out); out = new StringBuilder(); }\n\tpublic int[] arrayInt(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] arrayLong(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double[] arrayDouble(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextDouble();\n\t\t}\n\t\treturn a;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "#Adapted from code of hatsuyuki15 in this contest\nn, l, x, y = map(int, input().split())\na = set(map(int, input().split()))\nboy = False\ngirl = False\none = False\nwhere = -1\nfor i in a:\n    if i + x in a:\n        boy = True\n    if i + y in a:\n        girl = True\n    if i - x > 0 and i - x + y in a:\n        one = True\n        where = i - x\n    if i + x < l and i + x - y in a:\n        one = True\n        where = i + x\n    if i + x + y in a:\n        one = True\n        where = i + x\n\n\nif boy and girl:\n    print(0)\nif boy and not girl:\n    print(1)\n    print(y)\nif girl and not boy:\n    print(1)\n    print(x)\nif not boy and not girl:\n    if one:\n        print(1)\n        print(where)\n    if not one:\n        print(2)\n        print(x, y)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool Can(const vector<int64_t>& A, int64_t X, int* idx = NULL) {\n  for (int i = 0; i < A.size(); ++i) {\n    int64_t reper = A[i] + X;\n    if (binary_search(A.begin(), A.end(), reper)) {\n      if (idx) {\n        *idx = i;\n      }\n      return true;\n    }\n  }\n  return false;\n}\nbool Can2(const vector<int64_t>& A, int64_t X, int* idx = NULL) {\n  for (int i = static_cast<int>(A.size()) - 1; i >= 0; --i) {\n    int64_t reper = A[i] + X;\n    if (binary_search(A.begin(), A.end(), reper)) {\n      if (idx) {\n        *idx = i;\n      }\n      return true;\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int N;\n  int64_t L, X, Y;\n  cin >> N >> L >> X >> Y;\n  vector<int64_t> A(N);\n  for (int64_t& a : A) {\n    cin >> a;\n  }\n  bool can_x = Can(A, X);\n  bool can_y = Can(A, Y);\n  if (can_x && can_y) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  if (can_x && !can_y) {\n    cout << 1 << '\\n' << Y << '\\n';\n    return 0;\n  }\n  if (!can_x && can_y) {\n    cout << 1 << '\\n' << X << '\\n';\n    return 0;\n  }\n  int idx = 0;\n  if (Can(A, Y - X, &idx)) {\n    if (A[idx] + Y <= L) {\n      cout << 1 << '\\n';\n      cout << A[idx] + Y << '\\n';\n      return 0;\n    }\n    if (A[idx] - X >= 0) {\n      cout << 1 << '\\n';\n      cout << A[idx] - X << '\\n';\n      return 0;\n    }\n  }\n  if (Can2(A, Y - X, &idx)) {\n    if (A[idx] - X >= 0) {\n      cout << 1 << '\\n';\n      cout << A[idx] - X << '\\n';\n      return 0;\n    }\n  }\n  if (Can(A, X + Y, &idx)) {\n    cout << 1 << '\\n';\n    cout << A[idx] + X << '\\n';\n    return 0;\n  }\n  cout << 2 << '\\n';\n  cout << X << ' ' << Y << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, l, x, y;\nint a[N];\nmap<int, bool> exist;\nvector<int> coolx;\nvector<int> cooly;\nbool check(int d) {\n  int low, high, mid;\n  low = 1;\n  high = n;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (d - a[mid] == x) return true;\n    if (d - a[mid] < x)\n      high = mid - 1;\n    else\n      low = mid + 1;\n  }\n  low = 1;\n  high = n;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (a[mid] - d == x) return true;\n    if (a[mid] - d < x)\n      low = mid + 1;\n    else\n      high = mid - 1;\n  }\n  return false;\n}\nint main() {\n  int i;\n  cin >> n >> l >> x >> y;\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; i++) {\n    if (a[i] >= x)\n      if (exist[a[i] - x]) coolx.push_back(i);\n    exist[a[i]] = true;\n  }\n  exist.clear();\n  for (i = 1; i <= n; i++) {\n    if (a[i] >= y)\n      if (exist[a[i] - y]) cooly.push_back(i);\n    exist[a[i]] = true;\n  }\n  if (coolx.size() > 0 && cooly.size() > 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (coolx.size() > 0 && cooly.size() == 0) {\n    cout << 1 << endl;\n    for (i = 1; i <= n; i++) {\n      if (a[i] >= y) {\n        cout << a[i] - y << endl;\n        break;\n      }\n    }\n    return 0;\n  }\n  if (coolx.size() == 0 && cooly.size() > 0) {\n    cout << 1 << endl;\n    for (i = 1; i <= n; i++) {\n      if (a[i] >= x) {\n        cout << a[i] - x << endl;\n        break;\n      }\n    }\n    return 0;\n  }\n  int d;\n  for (i = 1; i <= n; i++) {\n    d = a[i] + y;\n    if (d <= l)\n      if (check(d)) {\n        cout << 1 << endl;\n        cout << d << endl;\n        return 0;\n      }\n    if (a[i] >= y) {\n      d = a[i] - y;\n      if (check(d)) {\n        cout << 1 << endl;\n        cout << d << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> M;\nint A[100005];\nint main() {\n  int n, x, y, l;\n  cin >> n >> l >> x >> y;\n  bool can_x = false, can_y = false;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    M[A[i]] = i + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] < x) continue;\n    if (M[A[i] - x] > 0) {\n      can_x = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] < y) continue;\n    if (M[A[i] - y] > 0) {\n      can_y = true;\n      break;\n    }\n  }\n  if (can_x && can_y) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (can_x == true && can_y == false) {\n    cout << 1 << endl;\n    cout << y << endl;\n    return 0;\n  }\n  if (can_x == false && can_y == true) {\n    cout << 1 << endl;\n    cout << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] + x <= l) {\n      if (A[i] + x - y >= 0 && M[A[i] + x - y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] + x << endl;\n        return 0;\n      }\n      if (A[i] + x + y <= l && M[A[i] + x + y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] + x << endl;\n        return 0;\n      }\n    }\n    if (A[i] - x >= 0) {\n      if (A[i] - x - y >= 0 && M[A[i] - x - y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] - x << endl;\n        return 0;\n      }\n      if (A[i] - x + y <= l && M[A[i] - x + y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] - x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Main {\n\tstatic class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[256]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\t\n\tstatic class arr implements Comparable<arr>{\n\t\tlong x;int y;\n\t\tarr(long a,int b){\n\t\t\tx=a;\n\t\t\ty=b;\n\t\t}\n\t\tpublic int compareTo(arr ob){\n\t\t\treturn (int)(this.x-ob.x);\n\t\t}\n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tReader in = new Reader();\n\t\tint n = in.nextInt();\n\t\tint l = in.nextInt();\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tp[i] = in.nextInt();\n\t\tboolean fa=false,fb=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x = a+p[i];\n\t\t\tif(x<=l && !fa)\n\t\t\t\tfa = get(p,x,i,n-1);\n\t\t\tx=b+p[i];\n\t\t\tif(x<=l && !fb)\n\t\t\t\tfb = get(p,x,i,n-1);\n\t\t\tif(fa && fb)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fa && fb)\n\t\t\tSystem.out.println(0);\n\t\telse if(!fa && fb){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\telse if(!fb && fa){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(b);\n\t\t}\n\t\telse if(!fa && !fb){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint e = p[i]+a;\n\t\t\t\tint f = p[i]+b;\n\t\t\t\tint g = p[i]-a;\n\t\t\t\tint h = p[i]-b;\n\t\t\t\tif(e+b<=l && get(p,e+b,0,n-1) || e-b>=0 && get(p,e-b,0,n-1)){\n\t\t\t\t\tif(e<=l && e>=0){\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+e);\n\t\t\t\t\tSystem.exit(0);}\n\t\t\t\t}\n\t\t\t\tif(f+a<=l && get(p,f+a,0,n-1) || f-a>=0 && get(p,f-a,0,n-1)){\n\t\t\t\t\tif(f<=l && f>=0){\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+f);\n\t\t\t\t\tSystem.exit(0);}\n\t\t\t\t}\n\t\t\t\tif(g+b<=l && get(p,g+b,0,n-1)|| g-b>=0 && get(p,g-b,0,n-1)){\n\t\t\t\t\tif(g<=l && g>=0){\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+g);\n\t\t\t\t\tSystem.exit(0);}\n\t\t\t\t}\n\t\t\t\tif(h+a<=l && get(p,h+a,0,n-1)|| h-a>=0 && get(p,h-a,0,n-1)){\n\t\t\t\t\tif(h<=l && h>=0){\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+h);\n\t\t\t\t\tSystem.exit(0);}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(a+\" \"+b);\n\t\t}\n\t}\n\tstatic boolean get(int[] p,int x,int l,int u){\n\t\tif(l>u)\n\t\t\treturn false;\n\t\tint mid=(l+u)/2;\n\t\tif(p[mid]==x)\n\t\t\treturn true;\n\t\tif(p[mid]<x)\n\t\t\treturn get(p,x,mid+1,u);\n\t\tif(p[mid]>x)\n\t\t\treturn get(p,x,l,mid-1);\n\t\treturn false;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class P, class Q>\ninline void smin(P &a, Q b) {\n  if (b < a) a = b;\n}\ntemplate <class P, class Q>\ninline void smax(P &a, Q b) {\n  if (a < b) a = b;\n}\nconst int maxn = 100000 + 100;\nint n, l, x, y;\nint a[maxn];\nset<int> s;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> l >> x >> y;\n  for (int i = 0, _n = (int)(n); i < _n; i++) cin >> a[i], s.insert(a[i]);\n  bool hx = false, hy = false;\n  for (int i = 0, _n = (int)(n); i < _n; i++) {\n    if (s.find(a[i] - x) != s.end()) hx = true;\n    if (s.find(a[i] - y) != s.end()) hy = true;\n  }\n  if (hx && hy) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (hx || hy) {\n    int v = x;\n    if (hx) v = y;\n    cout << 1 << endl;\n    cout << v << endl;\n    return 0;\n  }\n  for (int i = 0, _n = (int)(n); i < _n; i++) {\n    if (s.find(a[i] - x - y) != s.end()) {\n      cout << 1 << endl;\n      cout << a[i] - x << endl;\n      return 0;\n    }\n    if (s.find(a[i] - y + x) != s.end() && a[i] + x < l) {\n      cout << 1 << endl;\n      cout << a[i] + x << endl;\n      return 0;\n    }\n    if (s.find(a[i] + y - x) != s.end() && a[i] - x > 0) {\n      cout << 1 << endl;\n      cout << a[i] - x << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst int size = 300 * 1000 + 100;\nint a[size];\nset<int> marks;\nint n, len, x, y;\nset<int> couldget(int val) {\n  set<int> psb;\n  for (int i = 0; i < n; i++)\n    if (marks.find(a[i] + val) != marks.end()) psb.insert(a[i]);\n  return psb;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &len, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    marks.insert(a[i]);\n  }\n  set<int> cx = couldget(x);\n  set<int> cy = couldget(y);\n  set<int> csum = couldget(x + y);\n  set<int> cdif = couldget(y - x);\n  if (!cx.empty() && !cy.empty()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (!cx.empty() || !cy.empty()) {\n    cout << 1 << endl;\n    if (!cx.empty())\n      cout << y << endl;\n    else\n      cout << x << endl;\n    return 0;\n  }\n  if (!csum.empty()) {\n    cout << 1 << endl;\n    cout << *csum.begin() + x << endl;\n    return 0;\n  }\n  if (!cdif.empty() && (*cdif.begin() + y <= len || *cdif.rbegin() >= x)) {\n    cout << 1 << endl;\n    if (*cdif.begin() + y <= len) {\n      cout << *cdif.begin() + y << endl;\n    } else {\n      cout << *cdif.rbegin() - x << endl;\n    }\n    return 0;\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;\nconst int IINF = 1000000000;\nconst double PI = acos(-1.0);\nconst long long LINF = 6000000000000000000LL;\nint main() {\n  int n, l, x, y;\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) == 4) {\n    vector<int> v(n);\n    set<int> marks;\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d\", &v[i]);\n      marks.insert(v[i]);\n    }\n    bool first = false, second = false;\n    for (int i = 0; i < n; ++i) {\n      if (marks.find(v[i] - x) != marks.end() ||\n          marks.find(v[i] + x) != marks.end()) {\n        first = true;\n      }\n      if (marks.find(v[i] - y) != marks.end() ||\n          marks.find(v[i] + y) != marks.end()) {\n        second = true;\n      }\n    }\n    if (first && second) {\n      printf(\"0\\n\");\n    } else if (first || second) {\n      printf(\"1\\n\");\n      for (int i = 0; i < n; ++i) {\n        int val;\n        if (!first)\n          val = x;\n        else\n          val = y;\n        if (v[i] - val >= 0) {\n          printf(\"%d\\n\", v[i] - val);\n          break;\n        }\n        if (v[i] + val <= l) {\n          printf(\"%d\\n\", v[i] + val);\n          break;\n        }\n      }\n    } else {\n      for (int i = 0; i < n; ++i) {\n        vector<int> check = {v[i] + x, v[i] - x, v[i] + y, v[i] - y};\n        for (int to : check) {\n          if (to < 0 || to > l) continue;\n          if (marks.find(to - x) != marks.end() &&\n              marks.find(to + y) != marks.end()) {\n            printf(\"1\\n%d\\n\", to);\n            return 0;\n          }\n          if (marks.find(to + x) != marks.end() &&\n              marks.find(to - y) != marks.end()) {\n            printf(\"1\\n%d\\n\", to);\n            return 0;\n          }\n          if (marks.find(to - x) != marks.end() &&\n              marks.find(to - y) != marks.end()) {\n            printf(\"1\\n%d\\n\", to);\n            return 0;\n          }\n          if (marks.find(to + x) != marks.end() &&\n              marks.find(to + y) != marks.end()) {\n            printf(\"1\\n%d\\n\", to);\n            return 0;\n          }\n        }\n      }\n      printf(\"2\\n%d %d\\n\", x, y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n = in.readInt();\n        int l = in.readInt();\n        int x = in.readInt();\n        int y = in.readInt();\n        long[] a = new long[n];\n        HashSet<Long> markings = new HashSet<Long>();\n        int minMarkings = 0;\n        for (int i = 0; i < n; i++) {\n            a[i] = in.readInt();\n            markings.add(a[i]);\n        }\n        HashSet<Long> possibleMarkings = new HashSet<Long>();\n        boolean found = false;\n        for (int i = 0; i < n; i++) {\n            long val = (long) a[i] + x;\n            if (val <= l) {\n                if (markings.contains(val)) {\n                    found = true;\n                    break;\n                }\n                else {\n                    possibleMarkings.add(val);\n                }\n            }\n            val = (long) a[i] - x;\n            if (val >= 0) {\n                if (markings.contains(val)) {\n                    found = true;\n                    break;\n                }\n                else {\n                    possibleMarkings.add(val);\n                }\n            }\n        }\n        if (!found) {\n            minMarkings++;\n        }\n        long otherMark = 0;\n        found = false;\n        for (int i = 0; i < n; i++) {\n            long val = (long) a[i] + y;\n            if (val <= l) {\n                if (markings.contains(val)) {\n                    found = true;\n                    break;\n                }\n                else if (possibleMarkings.contains(val)) {\n                    out.printLine(minMarkings);\n                    out.printLine(val);\n                    return;\n                }\n                else {\n                    otherMark = val;\n                }\n            }\n            val = (long) a[i] - y;\n            if (val >= 0) {\n                if (markings.contains(val)) {\n                    found = true;\n                    break;\n                }\n                else if (possibleMarkings.contains(val)) {\n                    if (minMarkings == 0) {\n                        minMarkings++;\n                    }\n                    out.printLine(minMarkings);\n                    out.printLine(val);\n                    return;\n                }\n                else {\n                    otherMark = val;\n                }\n            }\n        }\n        if (!found) {\n            minMarkings++;\n        }\n        out.printLine(minMarkings);\n        if (minMarkings == 1) {\n            if (!found) {\n                out.printLine(otherMark);\n            }\n            else {\n                out.printLine(possibleMarkings.iterator().next());\n            }\n        }\n        else if (minMarkings == 2) {\n            out.printLine(otherMark + \" \" + possibleMarkings.iterator().next());\n        }\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "__author__ = \"zabidon\"\n\nn, l, x, y = map(int, input().split())\ndata = set(map(int, input().split()))\n\nold_x = any(i + x in data for i in data)\nold_y = any(i + y in data for i in data)\n\nif old_x and old_y:\n    #all\n    print(0)\nelif old_x:\n    #one\n    print(1)\n    print(y)\nelif old_y:\n    #one\n    print(1)\n    print(x)\nelse:\n    found = False\n    for i in data:\n        if i + x + y in data:\n            found = True\n            print(1)\n            print(i + x)\n\n        elif i + x - y in data:\n            # because x<y\n            # i + x - y mean exist one mark\n            if 0 <= i + x <= l:\n                found = True\n                print(1)\n                print(i + x)\n\n            if not found and 0 <= i - y <= l:\n                found = True\n                print(1)\n                print(i - y)\n        if found:\n            break\n     \n    if not found:\n        print(2)\n        print(x, y)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid afill(T *arr, int size, T val) {\n  fill(arr, arr + size, val);\n}\nlong long mod = 1e9 + 7;\ndouble eps = 1e-9;\nconst int MAX_SIZE = 1e5;\nint n, t, m, q, k;\nint l, x, y;\nint arr[1 << 17];\nbool check(int pp, int xx) {\n  if (pp - xx >= 0 && *lower_bound(arr, arr + n, pp - xx) == pp - xx)\n    return true;\n  if (pp + xx <= l && *lower_bound(arr, arr + n, pp + xx) == pp + xx)\n    return true;\n  return false;\n}\nbool check2(int p, int off) {\n  if (p < 0 || p > l) return false;\n  if (p + off < 0 || p + off > l) return false;\n  return *lower_bound(arr, arr + n, p + off) == p + off;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) cin >> arr[i];\n  bool fst = false, scd = false;\n  for (int i = 0; i < n; ++i) {\n    fst |= check(arr[i], x);\n    scd |= check(arr[i], y);\n  }\n  if (fst & scd) {\n    cout << 0 << '\\n';\n  } else if (scd) {\n    cout << 1 << '\\n' << x << '\\n';\n  } else if (fst) {\n    cout << 1 << '\\n' << y << '\\n';\n  } else {\n    bool f = false;\n    for (int i = 0; i < n && !f; ++i) {\n      int pos = arr[i];\n      if (check2(pos - x, y) || check2(pos - x, -y)) {\n        cout << 1 << '\\n' << pos - x << '\\n';\n        f = true;\n      } else if (check2(pos + x, y) || check2(pos + x, -y)) {\n        cout << 1 << '\\n' << pos + x << '\\n';\n        f = true;\n      }\n    }\n    if (!f) cout << 2 << '\\n' << x << ' ' << y << '\\n';\n  }\n  cin >> n;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool umin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool umax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint arr[100009];\nmap<int, int> pm, hs;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", arr + i), pm[arr[i]] = 1;\n  int dx = 0, dy = 0;\n  for (int i = 1; i <= n; i++) {\n    if (pm[arr[i] + x] or pm[arr[i] - x]) dx = 1;\n    if (pm[arr[i] + y] or pm[arr[i] - y]) dy = 1;\n    if (arr[i] + x <= l) hs[arr[i] + x] = 1;\n    if (arr[i] - x >= 0) hs[arr[i] - x] = 1;\n  }\n  if (dx or dy) {\n    if (dx and dy)\n      printf(\"0\\n\");\n    else if (dx)\n      printf(\"1\\n%d\\n\", y);\n    else\n      printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (hs[arr[i] + y] or hs[arr[i] - y]) {\n      if (hs[arr[i] + y] and arr[i] + y <= l) {\n        printf(\"1\\n%d\\n\", arr[i] + y);\n        return 0;\n      } else if (hs[arr[i] - y] and arr[i] - y >= 0) {\n        printf(\"1\\n%d\\n\", arr[i] - y);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.*;\n\n@SuppressWarnings(\"unused\")\npublic class round274D {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] use = br.readLine().split(\" \");\n        int n = parseInt(use[0]);\n        int l = parseInt(use[1]);\n        int x = parseInt(use[2]);\n        int y = parseInt(use[3]);\n        int[] seq = new int[n];\n        use = br.readLine().split(\" \");\n        for (int i = 0; i < n; ++i)\n            seq[i] = parseInt(use[i]);\n        boolean foundX = false, foundY = false;\n        for (int i = 0; i < n; ++i) {\n            int upX = seq[i] + x;\n            int upY = seq[i] + y;\n            if (!foundX && upX <= l) {\n                if (Arrays.binarySearch(seq, upX) >= 0)\n                    foundX = true;\n            }\n            if (!foundY && upY <= l) {\n                if (Arrays.binarySearch(seq, upY) >= 0)\n                    foundY = true;\n            }\n        }\n        int ans = 0;\n        if (!foundX)\n            ++ans;\n        if (!foundY)\n            ++ans;\n        if (ans == 0)\n            System.out.println(0);\n        else {\n            if (ans == 1) {\n                System.out.println(ans);\n                if (!foundX)\n                    System.out.println(x);\n                else\n                    System.out.println(y);\n            } else {\n                for (int i = 0; i < n; ++i) {\n                    int upX = seq[i] + x;\n                    if (upX <= l) {\n                        int y1 = upX - y;\n                        int y2 = upX + y;\n                        if (Arrays.binarySearch(seq, y1) >= 0\n                                || Arrays.binarySearch(seq, y2) >= 0) {\n                            System.out.println(1);\n                            System.out.println(upX);\n                            return;\n                        }\n                    }\n                    int downX = seq[i] - x;\n                    if(downX >= 0){\n                        int y1 = downX - y;\n                        int y2 = downX + y;\n                        if (Arrays.binarySearch(seq, y1) >= 0\n                                || Arrays.binarySearch(seq, y2) >= 0) {\n                            System.out.println(1);\n                            System.out.println(downX);\n                            return;\n                        }\n                    }\n                    int upY = seq[i] + y;\n                    if (upY <= l) {\n                        int x1 = upY - x;\n                        int x2 = upY + x;\n                        if (Arrays.binarySearch(seq, x1) >= 0\n                                || Arrays.binarySearch(seq, x2) >= 0) {\n                            System.out.println(1);\n                            System.out.println(upY);\n                            return;\n                        }\n                    }\n                    int downY = seq[i] - y;\n                    if(downY >= 0){\n                        int x1 = downY - x;\n                        int x2 = downY + x;\n                        if (Arrays.binarySearch(seq, x1) >= 0\n                                || Arrays.binarySearch(seq, x2) >= 0) {\n                            System.out.println(1);\n                            System.out.println(downY);\n                            return;\n                        }\n                    }\n                }\n                System.out.println(ans);\n                System.out.println(x + \" \" + y);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"avx,avx2,fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nlong long MOD = 1e9 + 7;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0),\n      cout << fixed << setprecision(20);\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  set<long long> q;\n  for (int i = 0; i < n; i++) {\n    long long a;\n    cin >> a;\n    q.insert(a);\n  }\n  long long fl1 = 0, fl2 = 0;\n  for (auto i : q) {\n    if (q.count(i + x) || q.count(i - x)) {\n      fl1 = 1;\n    }\n    if (q.count(i + y) || q.count(i - y)) {\n      fl2 = 1;\n    }\n  }\n  if (fl1 && fl2) {\n    cout << 0;\n    return 0;\n  }\n  if (fl1 || fl2) {\n    cout << 1 << endl;\n    if (!fl1)\n      cout << x;\n    else\n      cout << y;\n    return 0;\n  }\n  set<long long> q2;\n  for (auto i : q) {\n    if (0 <= i - x) q2.insert(i - x);\n    if (i + x <= l) q2.insert(i + x);\n  }\n  for (auto i : q) {\n    if (q2.count(i - y) || q2.count(i + y)) {\n      cout << 1 << endl;\n      if (q2.count(i - y))\n        cout << i - y;\n      else\n        cout << i + y;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, sxy;\nint a[105000];\nbool fx, fy, fxy;\nset<long long> s;\nint main() {\n  s.clear();\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    s.insert((long long)a[i]);\n  }\n  fx = fy = fxy = false;\n  for (int i = 0; i < n; i++) {\n    long long tmp;\n    if (!fx) {\n      tmp = a[i];\n      tmp = tmp + x;\n      if (s.find(tmp) != s.end()) fx = true;\n    }\n    if (!fy) {\n      tmp = a[i];\n      tmp = tmp + y;\n      if (s.find(tmp) != s.end()) fy = true;\n    }\n    if (!fxy) {\n      tmp = a[i];\n      tmp = tmp + x + y;\n      if (s.find(tmp) != s.end()) {\n        sxy = a[i] + x;\n        fxy = true;\n        continue;\n      }\n      tmp = a[i];\n      tmp = tmp + x - y;\n      if (s.find(tmp) != s.end()) {\n        long long tt = a[i];\n        tt = tt + x;\n        if (tt <= l) {\n          sxy = a[i] + x;\n          fxy = true;\n          continue;\n        } else {\n          tt = a[i];\n          tt = tt - y;\n          if (tt >= 0) {\n            sxy = a[i] - y;\n            fxy = true;\n            continue;\n          }\n        }\n      }\n      tmp = a[i];\n      tmp = tmp + y - x;\n      if (s.find(tmp) != s.end()) {\n        long long tt = a[i];\n        tt = tt + y;\n        if (tt <= l) {\n          sxy = a[i] + y;\n          fxy = true;\n          continue;\n        } else {\n          tt = a[i];\n          tt = tt - x;\n          if (tt >= 0) {\n            sxy = a[i] - x;\n            fxy = true;\n            continue;\n          }\n        }\n      }\n    }\n  }\n  int cnt = 0;\n  cnt = fx + fy;\n  if (cnt == 2)\n    puts(\"0\");\n  else if (cnt == 1) {\n    printf(\"1\\n\");\n    if (fx) printf(\"%d\\n\", y);\n    if (fy) printf(\"%d\\n\", x);\n  } else {\n    if (fxy) {\n      printf(\"1\\n\");\n      printf(\"%d\\n\", sxy);\n    } else {\n      printf(\"2\\n\");\n      printf(\"%d %d\\n\", x, y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 4;\nint n, l, x, y, a[MAXN], xf = 0, yf = 0, f = -1;\nbool bs(int lo, int hi, int c) {\n  int mid;\n  while (lo < hi) {\n    mid = (lo + hi) / 2;\n    if (a[mid] >= c)\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  return (lo != n && a[lo] == c);\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    if (bs(0, n, x + a[i])) xf = 1;\n    if (bs(0, n, y + a[i])) yf = 1;\n  }\n  if (!xf && !yf) {\n    for (int i = 0; i < n; i++) {\n      if (a[i] + x <= l) {\n        if (bs(0, n, a[i] + x - y) || bs(0, n, a[i] + x + y)) {\n          f = a[i] + x;\n          break;\n        }\n      }\n      if (a[i] - x >= 0) {\n        if (bs(0, n, a[i] - x - y) || bs(0, n, a[i] - x + y)) {\n          f = a[i] - x;\n          break;\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] + y <= l) {\n        if (bs(0, n, a[i] + y - x) || bs(0, n, a[i] + y + x)) {\n          f = a[i] + y;\n          break;\n        }\n      }\n      if (a[i] - y >= 0) {\n        if (bs(0, n, a[i] - y - x) || bs(0, n, a[i] - y + x)) {\n          f = a[i] - y;\n          break;\n        }\n      }\n    }\n    if (f != -1)\n      cout << 1 << endl << f;\n    else\n      cout << 2 << endl << x << ' ' << y;\n  } else if (!xf)\n    cout << 1 << endl << x;\n  else if (!yf)\n    cout << 1 << endl << y;\n  else\n    cout << 0;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, L, fx, fy, ans;\nint a[100010];\nset<int> aa, x;\nint main() {\n  int i, canx = 0, cany = 0, tmp;\n  scanf(\"%d%d%d%d\", &n, &L, &fx, &fy);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    aa.insert(a[i]);\n  }\n  for (i = 1; i <= n; i++) {\n    if (!canx) {\n      tmp = a[i] + fx;\n      if (aa.find(tmp) != aa.end()) canx = 1;\n    }\n    if (!cany) {\n      tmp = a[i] + fy;\n      if (aa.find(tmp) != aa.end()) cany = 1;\n    }\n  }\n  if (canx && cany) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (canx + cany == 1) {\n    printf(\"1\\n\");\n    if (!canx)\n      printf(\"%d\\n\", fx);\n    else\n      printf(\"%d\\n\", fy);\n    return 0;\n  }\n  ans = -1;\n  for (i = 1; i <= n; i++) {\n    tmp = a[i] + fx;\n    if (tmp >= 0 && tmp <= L) x.insert(tmp);\n    tmp = a[i] - fx;\n    if (tmp >= 0 && tmp <= L) x.insert(tmp);\n  }\n  for (i = 1; i <= n; i++) {\n    tmp = a[i] + fy;\n    if (tmp >= 0 && tmp <= L && x.find(tmp) != x.end()) {\n      ans = tmp;\n      break;\n    }\n    tmp = a[i] - fy;\n    if (tmp >= 0 && tmp <= L && x.find(tmp) != x.end()) {\n      ans = tmp;\n      break;\n    }\n  }\n  if (ans != -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", ans);\n  } else {\n    printf(\"2\\n\");\n    printf(\"%d %d\\n\", fx, fy);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int toInt(string s) {\n  int i;\n  stringstream(s) >> i;\n  return i;\n}\ninline string toString(long long i) {\n  string s;\n  stringstream ss;\n  ss << i;\n  ss >> s;\n  return s;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, l, x, y, fx = 1, fy = 1, f = 0, tmp = -1;\n  cin >> n >> l >> x >> y;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) cin >> v[i];\n  map<int, bool> m;\n  for (int i = 0; i < n; i++) m[v[i]] = 1;\n  for (int i = 0; i < n; i++) {\n    if (m[v[i] + x]) fx = 0;\n    if (m[v[i] + y]) fy = 0;\n  }\n  if (fx && fy) {\n    for (int i = 0; i < n; i++) {\n      if ((v[i] + x) < l) {\n        if (m[v[i] + x + y] || m[v[i] + x - y]) {\n          f = 1;\n          tmp = v[i] + x;\n        }\n      }\n      if ((v[i] + y) < l) {\n        if (m[v[i] + y + x] || m[v[i] + y - x]) {\n          f = 1;\n          tmp = v[i] + y;\n        }\n      }\n      if ((v[i] - x) > 0) {\n        if (m[v[i] - x + y] || m[v[i] - x - y]) {\n          f = 1;\n          tmp = v[i] - x;\n        }\n      }\n      if ((v[i] - y) > 0) {\n        if (m[v[i] - y + x] || m[v[i] - y - x]) {\n          f = 1;\n          tmp = v[i] - y;\n        }\n      }\n    }\n    if (f) {\n      cout << 1 << endl;\n      cout << tmp << endl;\n    } else {\n      cout << 2 << endl;\n      cout << x << ' ' << y << endl;\n    }\n  } else if (fx || fy) {\n    cout << 1 << endl;\n    if (fx) cout << x << endl;\n    if (fy) cout << y << endl;\n  } else\n    cout << 0 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y=map(int,raw_input().split())\nori=map(int,raw_input().split())\nboy=[]\ngirl=[]\nfor i in ori:\n    if i-x>=0:\n        girl.append(i-x)\n    if i+x<=l:\n        girl.append(i+x)\n    if i-y>=0:\n        boy.append(i-y)\n    if i+y<=l:\n        boy.append(i+y)\ngirl.sort()\nboy.sort()\nbh=gh=False\nbg=False\ni=0\nfor k in girl:\n    while ori[i]<k and i<n-1:\n        i+=1\n    if ori[i]==k:\n        gh=True\ni=0\nfor k in boy:\n    while ori[i]<k and i<n-1:\n        i+=1\n    if ori[i]==k:\n        bh=True\nif gh and bh:\n    print 0\nelif gh:\n    print 1\n    print y\nelif bh:\n    print 1\n    print x\nelse:\n    i=0\n    n=len(girl)\n    for k in boy:\n        while girl[i]<k and i<n-1:\n            i+=1\n        if girl[i]==k:\n            bg=True\n            break\n    if bg:\n        print 1\n        print k\n    else:\n        print 2\n        print x,y"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline int size(const T& c) {\n  return c.size();\n}\nusing namespace std;\nint fastMax(int x, int y) { return (((y - x) >> (32 - 1)) & (x ^ y)) ^ y; }\nint fastMin(int x, int y) { return (((y - x) >> (32 - 1)) & (x ^ y)) ^ x; }\nconst int maxn = 100000 + 10;\nint a[maxn];\nmap<int, bool> ma;\nmap<int, bool> ma1;\nmap<int, bool> ma2;\nint l, x, y, n;\nbool ok1, ok2;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  ma.clear();\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] >= x && ma[a[i] - x]) ok1 = true;\n    if (a[i] >= y && ma[a[i] - y]) ok2 = true;\n    ma[a[i]] = true;\n    if (a[i] >= x) ma1[a[i] - x] = true;\n    if (a[i] + x <= l) ma1[a[i] + x] = true;\n    if (a[i] >= y) ma2[a[i] - y] = true;\n    if (a[i] + y <= l) ma2[a[i] + y] = true;\n  }\n  if (ok1 && ok2) {\n    cout << 0;\n  } else if (ok1 || ok2) {\n    if (ok1) {\n      cout << 1 << endl;\n      cout << y;\n    }\n    if (ok2) {\n      cout << 1 << endl;\n      cout << x << endl;\n    }\n  } else {\n    for (__typeof((ma2).begin()) it = (ma2).begin(); it != (ma2).end(); it++) {\n      int u = (*it).first;\n      if (ma1[u] && ma2[u]) {\n        cout << 1 << endl;\n        cout << u << endl;\n        return 0;\n      }\n    }\n    cout << 2 << endl;\n    cout << x << ' ' << y << endl;\n  }\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = int(1e9) + 7;\nlong long powmod(long long num, long long power) {\n  if (power == 0) return 1 % MOD;\n  if (power == 1) return num % MOD;\n  long long t = powmod(num, power / 2) % MOD;\n  return power % 2 ? t * t % MOD * num % MOD : t * t % MOD;\n}\nlong long pow1(long long num, long long power) {\n  if (power == 0) return 1;\n  if (power == 1) return num;\n  long long t = pow1(num, power / 2);\n  return power % 2 ? t * t * num : t * t;\n}\nint check(int);\nint binarysearch(int len) {\n  int lo = 1, hi = len, mid, flag;\n  while (lo <= hi) {\n    mid = hi + lo >> 1;\n    (flag = check(mid)) ? lo = mid + 1 : hi = mid - 1;\n  }\n  return mid - 1 + flag;\n}\nconst int N = 1000 * 100 + 5;\nint debug = 1;\nint check(int a) { return a; }\ninline int inp() {\n  int n = 0, s = 1, c = getchar();\n  if (c == '-') s = -1;\n  while (c < 48) c = getchar();\n  while (c > 47) n = (n << 3) + (n << 1) + c - '0', c = getchar();\n  return n * s;\n}\nlong long a[N];\nset<long long> s;\nint main() {\n  ios::sync_with_stdio(false);\n  long long i, j, n, t, l, x, y;\n  long long X = 0, Y = 0;\n  cin >> n >> l >> x >> y;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  for (i = 0; i < n; i++) {\n    if (s.find(a[i] + x) != s.end()) X = 1;\n    if (s.find(a[i] + y) != s.end()) Y = 1;\n  }\n  if (X == 1 && Y == 1) {\n    cout << 0;\n  } else if (X == 1) {\n    cout << 1 << endl << y;\n  } else if (Y == 1) {\n    cout << 1 << endl << x;\n  } else {\n    int flag = 0, cur = -1;\n    for (i = 0; i < n; i++) {\n      if (s.find(a[i] + x + y) != s.end()) {\n        flag = 1;\n        cur = a[i] + x;\n      }\n      if (s.find(a[i] + y - x) != s.end() && a[i] + y <= l) {\n        flag = 1;\n        cur = a[i] + y;\n      }\n      if (s.find(a[i] + y - x) != s.end() && a[i] - x >= 0) {\n        flag = 1;\n        cur = a[i] - x;\n      }\n      if (s.find(a[i] + x - y) != s.end() && a[i] - y >= 0) {\n        flag = 1;\n        cur = a[i] - y;\n      }\n      if (s.find(a[i] + x - y) != s.end() && a[i] + x <= l) {\n        flag = 1;\n        cur = a[i] + x;\n      }\n    }\n    if (flag == 0) {\n      cout << 2 << endl << x << \" \" << y;\n    } else {\n      cout << 1 << endl << cur;\n    }\n  }\n  cin >> i;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 110000;\nset<int> mark, add;\nvector<int> A;\nvector<int> B;\nint main() {\n  int val, n, l, x, y;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &l);\n  scanf(\"%d\", &x);\n  scanf(\"%d\", &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &val);\n    mark.insert(val);\n  }\n  int a = -1, b = -1;\n  int fa = false, fb = false;\n  for (set<int>::iterator it = mark.begin(); it != mark.end(); it++) {\n    int val = (*it);\n    int d = (val - x);\n    if (d >= 0) {\n      if (mark.find(d) != mark.end()) {\n        fa = true;\n        break;\n      } else {\n        A.push_back((d));\n      }\n    }\n    d = val + x;\n    if (d > l) continue;\n    if (mark.find(d) != mark.end()) {\n      fa = true;\n      break;\n    } else {\n      A.push_back((d));\n    }\n  }\n  for (set<int>::iterator it = mark.begin(); it != mark.end(); it++) {\n    int val = (*it);\n    int d = (val - y);\n    if (d >= 0) {\n      if (mark.find(d) != mark.end()) {\n        fb = true;\n        break;\n      } else {\n        B.push_back((d));\n      }\n    }\n    d = val + y;\n    if (d > l) continue;\n    if (mark.find(d) != mark.end()) {\n      fb = true;\n      break;\n    } else {\n      B.push_back((d));\n    }\n  }\n  if (fa && fb) {\n    cout << 0 << endl;\n  } else if (fa && !fb) {\n    cout << 1 << endl;\n    cout << B[0] << endl;\n  } else if (!fa && fb) {\n    cout << 1 << endl;\n    cout << A[0] << endl;\n  } else {\n    sort(A.begin(), A.end());\n    cout << endl;\n    for (int i = 0; i < ((int)B.size()); i++) {\n      if (binary_search(A.begin(), A.end(), B[i])) {\n        cout << 1 << endl;\n        cout << B[i] << endl;\n        return 0;\n      }\n    }\n    cout << 2 << endl;\n    if (A[0] > B[0]) swap(A[0], B[0]);\n    cout << A[0] << \" \" << B[0] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package testing;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.*;\n\npublic class A {\n\tstatic public class Pair{\n\t\tint a,b,c;\n\t\tpublic Pair(int a,int b,int c) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tstatic class cmp implements Comparator<Pair>{\n\t\tpublic int compare(Pair p,Pair q) {\n\t\t\tif(p.a<q.a) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = 1;\n\t\touter:\n\t\twhile(t-->0) {\t \n\t       int n,l,x,y;\n\t       n = fs.nextInt();\n\t       l = fs.nextInt();\n\t       x = fs.nextInt();\n\t       y = fs.nextInt();\n\t       int arr[] = new int[n];\n\t       arr = fs.readArray(n);\n\t       int xdone,ydone;\n\t       xdone = ydone = 0;\n\t       TreeMap<Integer,Integer>p = new TreeMap<>();\n\t       for(int i=0;i<n;i++) {\n\t    \t   if(p.containsKey(arr[i]-x)) {\n\t    \t\t   xdone = 1;\n\t    \t   }\n\t    \t   if(p.containsKey(arr[i]-y)) {\n\t    \t\t   ydone = 1;\n\t    \t   }\n\t    \t   p.put(arr[i], 1);\n\t       }\n\t       if(xdone==1&&ydone==1) {\n\t    \t   out.println(0);\n\t       }\n\t       else if(xdone==1) {\n\t    \t   out.println(1);\n\t    \t   out.println(y);\n\t       }\n\t       else if(ydone==1) {\n\t    \t   out.println(1);\n\t    \t   out.println(x);\n\t       }\n\t       else {\n\t    \t   for(int i=0;i<n;i++) {\n\t    \t\t   int ss = arr[i] - y;\n\t    \t\t   if(ss>=0) {\n\t\t    \t\t   if(p.containsKey(ss+x)||p.containsKey(ss-x)) {\n\t\t    \t\t\t   out.println(1);\n\t\t    \t\t\t   out.println(ss);\n\t\t    \t\t\t   break outer;\n\t\t    \t\t   }\n\t    \t       }\n\t    \t\t   ss = arr[i] + y;\n\t    \t\t   if(ss<=l) {\n\t\t    \t\t    if(p.containsKey(ss+x)||p.containsKey(ss-x)) {\n\t\t    \t\t\t   out.println(1);\n\t\t    \t\t\t   out.println(ss);\n\t\t    \t\t\t   break outer;\n\t\t    \t\t    }\n\t    \t\t   }\n\t    \t   }\n\t    \t   int tmp = x;\n\t    \t   x = y;\n\t    \t   y = tmp;\n\t    \t   for(int i=0;i<n;i++) {\n\t    \t\t   int ss = arr[i] - y;\n\t    \t\t   if(ss>=0) {\n\t\t    \t\t   if(p.containsKey(ss+x)||p.containsKey(ss-x)) {\n\t\t    \t\t\t   out.println(1);\n\t\t    \t\t\t   out.println(ss);\n\t\t    \t\t\t   break outer;\n\t\t    \t\t   }\n\t    \t\t   }\n\t    \t\t   ss = arr[i] + y;\n\t    \t\t   if(ss<=l) {\n\t\t    \t\t   if(p.containsKey(ss+x)||p.containsKey(ss-x)) {\n\t\t    \t\t\t   out.println(1);\n\t\t    \t\t\t   out.println(ss);\n\t\t    \t\t\t   break outer;\n\t\t    \t\t   }\n\t    \t\t   }\n\t    \t   }\n\t    \t   out.println(2);\n\t    \t   out.println(x+\" \"+y);\n\t    \t   \n\t       }\n\t       \n\t\t}\n\t\tout.close();\n\t    \t\n\t   \n\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n \n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\ta[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.HashSet;\nimport java.util.ArrayList;\n\npublic class Main\n{\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n    static void solve () {\n        FastReader fr =new FastReader();    PrintWriter op =new PrintWriter(System.out);\n \n        int n =fr.nextInt() ,i ;    long l =fr.nextLong() ,x =fr.nextLong() ,y =fr.nextLong() ;\n        HashSet<Long> hs =new HashSet<>() ;   ArrayList<Long> al =new ArrayList<>() ;   boolean f[] ={false , false} ;\n        for (i =0 ; i<n ; ++i)  hs.add (fr.nextLong()) ;\n        \n        for (long vl : hs) {\n            if (hs.contains(vl+x))  {   f[0] =true ;    break;  }\n        }\n        for (long vl : hs) {\n            if (hs.contains(vl+y))  {   f[1] =true ;    break;  }\n        }\n        if (!(f[0]&f[1])) {\n            if ((f[0]|f[1])) {\n                i =1 ;    if (f[0])   al.add(y) ;    if (f[1])   al.add(x) ;\n            }\n            else {\n                long j =x+y ,k =-1 ,m ;\n                for (long vl : hs) {\n                    if (hs.contains(vl+j))  {   k =vl ;    break;  }\n                }\n                if (k!=-1) {\n                    i =1 ;  al.add (k+x) ;\n                }\n                else {\n                    j =y-x ;    k =l+1l ;   m =-1l ;\n                    for (long vl : hs) {\n                        if (hs.contains(vl+j))  {   k =Math.min(k,vl) ;m =Math.max(m,vl) ;f[0] =true ;  }\n                    }\n                    if (f[0]) {\n                        k += y ;    m -= x ;\n                        if (k<=l) {\n                            i =1 ;  al.add(k) ;\n                        }\n                        else if (m>=0) {\n                            i =1 ;  al.add(m) ;\n                        }\n                        else {\n                            i =2 ;  al.add(x) ; al.add(y) ;\n                        }\n                    }\n                    else {\n                        i =2 ;  al.add(x) ; al.add(y) ;\n                    }\n                }\n            }\n        }\n        else    i =0 ;\n        op.println(i) ;\n        for (i =0 ; i<al.size() ; ++i)  op.print(al.get(i)+\" \") ;\n        op.flush();    op.close();\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br =new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st==null || (!st.hasMoreElements())) \n            {\n                try\n                {\n                    st =new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    e.printStackTrace();\n                }\n                \n            }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            String str =\"\";\n\n            try\n            {\n                str =br.readLine();\n            }\n            catch(IOException e)\n            {\n                e.printStackTrace();\n            }\n\n            return str;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next()) ;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\ntemplate <class T>\ninline T tmin(T a, T b) {\n  return (a < b) ? a : b;\n}\ntemplate <class T>\ninline T tmax(T a, T b) {\n  return (a > b) ? a : b;\n}\ntemplate <class T>\ninline void add_max(T &a, T b) {\n  if (b > a) a = b;\n}\ntemplate <class T>\ninline void add_min(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\ninline T tabs(T a) {\n  return (a > 0) ? a : -a;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<int> a(n);\n  int ans = 2;\n  bool tx = false, ty = false;\n  for (int i = (0); i < (n); ++i) {\n    cin >> a[i];\n  }\n  for (int i = (0); i < (n); ++i) {\n    if (binary_search(a.begin(), a.end(), a[i] + x)) tx = true;\n    if (binary_search(a.begin(), a.end(), a[i] + y)) ty = true;\n  }\n  if (tx && ty) {\n    printf(\"%d\\n\", 0);\n    return 0;\n  }\n  if (tx || ty) {\n    if (!tx)\n      printf(\"%d\\n%d\\n\", 1, x);\n    else\n      printf(\"%d\\n%d\\n\", 1, y);\n    return 0;\n  }\n  for (int i = (0); i < (n); ++i) {\n    if (a[i] >= x) {\n      if (binary_search(a.begin(), a.end(), a[i] - x - y)) {\n        printf(\"%d\\n%d\\n\", 1, a[i] - x);\n        return 0;\n      }\n      if (binary_search(a.begin(), a.end(), a[i] - x + y)) {\n        printf(\"%d\\n%d\\n\", 1, a[i] - x);\n        return 0;\n      }\n    }\n    if (a[i] + x <= l) {\n      if (binary_search(a.begin(), a.end(), a[i] + x - y)) {\n        printf(\"%d\\n%d\\n\", 1, a[i] + x);\n        return 0;\n      }\n      if (binary_search(a.begin(), a.end(), a[i] + x + y)) {\n        printf(\"%d\\n%d\\n\", 1, a[i] + x);\n        return 0;\n      }\n    }\n  }\n  printf(\"%d\\n%d %d\\n\", 2, x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.min;\nimport static java.lang.Math.max;\n\npublic class Main {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n        // Sworn to fight and die\n    }\n\n    public static void mergeSort(int[] a) {\n        mergeSort(a, 0, a.length - 1);\n    }\n\n    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {\n        final int MAGIC_VALUE = 2;\n        if (levtIndex < rightIndex) {\n            if (rightIndex - levtIndex <= MAGIC_VALUE) {\n                insertionSort(a, levtIndex, rightIndex);\n            } else {\n                int middleIndex = (levtIndex + rightIndex) / 2;\n                mergeSort(a, levtIndex, middleIndex);\n                mergeSort(a, middleIndex + 1, rightIndex);\n                merge(a, levtIndex, middleIndex, rightIndex);\n            }\n        }\n    }\n\n    private static void merge(int[] a, int levtIndex, int middleIndex,\n                              int rightIndex) {\n        int length1 = middleIndex - levtIndex + 1;\n        int length2 = rightIndex - middleIndex;\n        int[] levtArray = new int[length1];\n        int[] rightArray = new int[length2];\n        System.arraycopy(a, levtIndex, levtArray, 0, length1);\n        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {\n            if (i == length1) {\n                a[k] = rightArray[j++];\n            } else if (j == length2) {\n                a[k] = levtArray[i++];\n            } else {\n                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]\n                        : rightArray[j++];\n            }\n        }\n    }\n\n    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {\n        for (int i = levtIndex + 1; i <= rightIndex; i++) {\n            int current = a[i];\n            int j = i - 1;\n            while (j >= levtIndex && a[j] > current) {\n                a[j + 1] = a[j];\n                j--;\n            }\n            a[j + 1] = current;\n        }\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    class LOL implements Comparable<LOL> {\n\n        int x;\n        int y;\n\n        public LOL(int x, int y) {\n            this.x = x;\n            this.y = y;\n\n        }\n\n\n\n        @Override\n        public int compareTo(LOL o) {\n            if (x == o.x) {\n                return y - o.y;\n            }\n\n            return (x - o.x);\n            // return o.x * o.y - x * y; // <----\n        }\n\n    }\n\n    Map <Integer, ArrayList<Integer>> g = new HashMap<Integer, ArrayList<Integer>>();\n\n\n\n\n\n\n\n    int n;\n    TreeSet<Integer> a;\n    ArrayList<Integer> result;\n    int l;\n\n    public void func(int x, int y) {\n        int locSum = 0;\n        for (Integer temp: a) {\n            if (a.contains(temp + x)) {\n                for (Integer temp1: a) {\n                    if (a.contains(temp1 + y)) {\n                        return;\n                    }\n                }\n                result.add(y);\n                return;\n            }\n        }\n\n        for (Integer temp: a) {\n            if (a.contains(temp + y)) {\n                result.add(x);\n                return;\n            }\n        }\n\n\n\n        for (Integer r: a) {\n            int tempSum = 0;\n            int temp1 = r - x;\n            int temp2 = r + x;\n            int temp3 = r - y;\n            int temp4 = r + y;\n\n            if (temp1 >= 0 && temp1 <= l) {\n                if (a.contains(temp1 + y) || a.contains(temp1 - y)) {\n                    result.add(temp1);\n                    return;\n                }\n            }\n\n            if (temp2 >= 0 && temp2 <= l) {\n                if (a.contains(temp2 + y) || a.contains(temp2 - y)) {\n                    result.add(temp2);\n                    return;\n                }\n            }\n\n            if (temp3 >= 0 && temp3 <= l) {\n                if (a.contains(temp3 + x) || a.contains(temp3 - x)) {\n                    result.add(temp3);\n                    return;\n                }\n            }\n\n            if (temp4 >= 0 && temp4 <= l) {\n                if (a.contains(temp4 + x) || a.contains(temp4 - x)) {\n                    result.add(temp4);\n                    return;\n                }\n            }\n\n        }\n\n        result.add(x);\n        result.add(y);\n\n\n\n\n    }\n\n\n\n    public void solve() throws IOException {\n        n = readInt();\n        l = readInt();\n        int x = readInt();\n        int y = readInt();\n        a = new TreeSet<Integer>();\n        result = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            a.add(readInt());\n        }\n\n        func(x, y);\n\n\n        out.println(result.size());\n\n        for (Integer temp: result) {\n            out.print(temp + \" \");\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n}"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/13 20:48\n\n\"\"\"\n\n\ndef solve(N, L, X, Y, A):\n    vs = set(A)\n    mx = any([a+X in vs for a in A])\n    my = any([a+Y in vs for a in A])\n    if mx and my:\n        print(0)\n    elif mx:\n        print(1)\n        print(Y)\n    elif my:\n        print(1)\n        print(X)\n    else:\n        # try to add 1 mark\n        for a in vs:\n            for b, c in [(a + X, Y), (a + Y, X), (a - X, Y), (a - Y, X)]:\n                if 0 <= b <= L:\n                    if (b + c <= L and b + c in vs) or (b - c >= 0 and b - c in vs):\n                        print(1)\n                        print(b)\n                        return\n\n        # add 2 marks\n        print(2)\n        print('{} {}'.format(X, Y))\n\n\nN, L, X, Y = map(int, input().split())\nA = [int(x) for x in input().split()]\nsolve(N, L, X, Y, A)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nmap<long long, bool> mp;\nint a[100005];\nvoid chk(int d, int t) {\n  if (d < 0 || d > l) return;\n  if ((mp[d + t] || mp[d - t])) {\n    cout << 1 << endl << d;\n    exit(0);\n  }\n}\nint main() {\n  bool fst = false, sec = false;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    mp[a[i]] = true;\n  }\n  for (int i = 0; i < n; i++) {\n    if (mp[a[i] - x]) fst = true;\n    if (mp[a[i] + x]) fst = true;\n    if (mp[a[i] - y]) sec = true;\n    if (mp[a[i] + y]) sec = true;\n  }\n  if (fst && sec) {\n    cout << 0;\n    return 0;\n  } else if (fst && !sec) {\n    cout << 1 << endl << y;\n    return 0;\n  } else if (!fst && sec) {\n    cout << 1 << endl << x;\n    return 0;\n  } else {\n    for (int i = 0; i < n; i++) {\n      chk(a[i] + x, y);\n      chk(a[i] - x, y);\n      chk(a[i] + y, x);\n      chk(a[i] - y, x);\n    }\n    cout << 2 << endl << x << ' ' << y;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100007;\nint l, x, y, z, n;\nint a[maxn];\nbool foundX, foundY, foundZ;\nset<int> mys;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  z = x + y;\n  foundX = foundY = foundZ = 0;\n  int pz;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    mys.insert(a[i]);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (mys.find(a[i] - x) != mys.end()) foundX = 1;\n    if (mys.find(a[i] - y) != mys.end()) foundY = 1;\n    if (mys.find(a[i] - x - y) != mys.end()) {\n      foundZ = 1;\n      pz = a[i] - y;\n    }\n    if (mys.find(a[i] + (y - x)) != mys.end() && a[i] - x >= 0) {\n      foundZ = 1;\n      pz = a[i] - x;\n    }\n    if (mys.find(a[i] - (y - x)) != mys.end() && a[i] + x <= l) {\n      foundZ = 1;\n      pz = a[i] + x;\n    }\n  }\n  if (foundX && foundY) {\n    puts(\"0\");\n  } else if (foundX || foundY) {\n    puts(\"1\");\n    if (foundX)\n      printf(\"%d\", y);\n    else\n      printf(\"%d\", x);\n  } else if (foundZ) {\n    puts(\"1\");\n    printf(\"%d\", pz);\n  } else {\n    puts(\"2\");\n    printf(\"%d %d\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint a[100002], frist, mid, es, n;\nusing namespace std;\nint main() {\n  int t1 = 0, t2 = 0, t3 = 0, t4 = 0;\n  int ants = 2, p = -1, q = 0;\n  int i, l, x, y;\n  cin >> n;\n  cin >> l >> x >> y;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  for (i = 1; i < n + 1; i++) {\n    if (binary_search(a, a + n + 1, a[i] + x)) t1 = 1;\n    if (binary_search(a, a + n + 1, a[i] + y)) t2 = 1;\n    if (binary_search(a, a + n + 1, a[i] + x + y)) {\n      t3 = 1;\n      p = a[i];\n    }\n    if (binary_search(a, a + n + 1, a[i] + y - x) &&\n        ((a[i] + y <= l) || (a[i] - x >= 0))) {\n      t4 = 1;\n      p = a[i];\n    }\n  }\n  if (t1) {\n    ants--;\n    q = 1;\n  }\n  if (t2) {\n    ants--;\n    q = 2;\n  }\n  if (ants == 2 && (t3 || t4)) {\n    ants--;\n  }\n  cout << ants << endl;\n  if (ants == 2) cout << a[1] + x << \" \" << a[1] + y << endl;\n  if (ants == 1) {\n    if (p == -1) {\n      if (q == 1) {\n        cout << a[1] + y << endl;\n      } else\n        cout << a[1] + x << endl;\n    } else {\n      if (p + y <= l)\n        cout << p + y << endl;\n      else\n        cout << p - x << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class D {\n    public static void main(String args[]) throws Exception {\n        Reader reader = new Reader();\n        reader.initConsoleReading();\n        int n, l, x, y;\n        n = reader.nextInt();\n        l = reader.nextInt();\n        x = reader.nextInt();\n        y = reader.nextInt();\n        boolean xFound, yFound;\n        xFound = yFound = false;\n        int[] marks = new int[n];\n        HashSet<Integer> seen = new HashSet<>();\n        HashSet<Integer> xNeed = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            marks[i] = reader.nextInt();\n            if (seen.contains(marks[i] - x)) {\n                xFound = true;\n            }\n            if (seen.contains(marks[i] - y)) {\n                yFound = true;\n            }\n            xNeed.add(marks[i] + x);\n            xNeed.add(marks[i] - x);\n            seen.add(marks[i]);\n        }\n        if (xFound && yFound) {\n            System.out.println(0);\n        } else if (xFound) {\n            System.out.println(\"1\\n\" + y);\n        } else if (yFound) {\n            System.out.println(\"1\\n\" + x);\n        } else if (!make_1(xNeed, marks, y)) {\n            System.out.println(\"2\\n\" + x + \" \" + y);\n        }\n        reader.dispose();\n\n    }\n\n    private static boolean make_1(HashSet<Integer> xNeed, int[] marks, int y) {\n        int len = marks[marks.length - 1];\n        for (int i = 0; i < marks.length; i++) {\n            if (marks[i] + y <= len && xNeed.contains(marks[i] + y)) {\n                System.out.println(\"1\\n\" + (marks[i] + y));\n                return true;\n            } else if (marks[i] - y >= 0 && xNeed.contains(marks[i] - y)) {\n                System.out.println(\"1\\n\" + (marks[i] - y));\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /************************************Helper Methods Begin Here**********************************************/\n    private static String reverse(String toRev) {\n        return new StringBuilder(toRev).reverse().toString();\n    }\n\n    public static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n        static final int prime = 31;\n        private F first;\n        private S second;\n\n        public Pair(F f, S s) {\n            this.first = f;\n            this.second = s;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = 1;\n            result = prime * result + this.first.hashCode();\n            result = prime * result + this.second.hashCode();\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Pair<F, S> s = (Pair<F, S>) obj;\n            return this.first.equals(s.first) && this.second.equals(s.second);\n        }\n\n        @Override\n        public int compareTo(Pair<F, S> p) {\n            int c1 = this.first.compareTo(p.first);\n            if (c1 == 0) {\n                return this.second.compareTo(p.second);\n            }\n            return c1;\n        }\n    }\n\n    public static int swap(int a, int b) {\n        /*a = Main.swap(b,b=a); goes from left to right*/\n        return a;\n    }\n\n    public static long swap(long a, long b) {\n        /*a = Main.swap(b,b=a); goes from left to right*/\n        return a;\n    }\n\n    private static <T1, T2> void init6d(T1[][][][][][] sixD, T2 val) {\n        for (T1[][][][][] fiveD : sixD) init5d(fiveD, val);\n    }\n\n    private static <T1, T2> void init5d(T1[][][][][] fiveD, T2 val) {\n        for (T1[][][][] fourD : fiveD) init4d(fourD, val);\n    }\n\n    private static <T1, T2> void init4d(T1[][][][] fourD, T2 val) {\n        for (T1[][][] threeD : fourD) init3d(threeD, val);\n    }\n\n    private static <T1, T2> void init3d(T1[][][] threeD, T2 val) {\n        for (T1[][] twoD : threeD) init2d(twoD, val);\n    }\n\n    private static <T1, T2> void init2d(T1[][] twoD, T2 val) {\n        for (T1[] oneD : twoD) init1d(oneD, val);\n    }\n\n    private static <T1, T2> void init1d(T1[] oneD, T2 val) {\n        Arrays.fill(oneD, val);\n    }\n\n    public static boolean next_permutation(int[] p) {\n        for (int a = p.length - 2; a >= 0; --a)\n            if (p[a] < p[a + 1])\n                for (int b = p.length - 1; ; --b)\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n        return false;\n    }\n\n    public static long gcd(long a, long b) {\n        if (a < 0) a *= -1;\n        if (b < 0) b *= -1;\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public Reader() {\n        }\n\n        public Reader initConsoleReading() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n            return this;\n        }\n\n        public Reader initFileReading(String filePath) throws FileNotFoundException {\n            reader = new BufferedReader(new FileReader(filePath), 32768);\n            tokenizer = null;\n            return this;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public void dispose() throws IOException {\n            this.reader.close();\n        }\n    }\n    /************************************Helper Methods Ends Here**********************************************/\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint nextInt(void) {\n  char ch;\n  int sign, x;\n  do {\n    ch = getchar();\n  } while (ch < '-');\n  if (ch == '-') {\n    sign = -1;\n    ch = getchar();\n  } else\n    sign = 1;\n  x = 0;\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return sign * x;\n}\nint binarySearch(int *data, int n, int key) {\n  int l = 0, r = n - 1, m;\n  while (l <= r) {\n    m = (l + r) / 2;\n    if (key == data[m])\n      return 1;\n    else if (key < data[m])\n      r = m - 1;\n    else\n      l = m + 1;\n  }\n  return 0;\n}\nint a[100000];\nint main(void) {\n  int i;\n  int n, l, x, y;\n  int flag;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (i = 0; i < n; i++) a[i] = nextInt();\n  flag = 0;\n  for (i = 0; i < n && a[i] + x <= a[n - 1]; i++)\n    if (binarySearch(a, n, a[i] + x)) {\n      flag |= 1;\n      break;\n    }\n  for (i = 0; i < n && a[i] + y <= a[n - 1]; i++)\n    if (binarySearch(a, n, a[i] + y)) {\n      flag |= 2;\n      break;\n    }\n  switch (flag) {\n    case 0:\n      for (i = 0; i < n; i++)\n        if (a[i] + x <= a[n - 1] && (binarySearch(a, n, a[i] + x - y) ||\n                                     binarySearch(a, n, a[i] + x + y))) {\n          printf(\"%d\\n%d\\n\", 1, a[i] + x);\n          return 0;\n        } else if (a[i] - x >= 0 && binarySearch(a, n, a[i] - x + y)) {\n          printf(\"%d\\n%d\\n\", 1, a[i] - x);\n          return 0;\n        }\n      printf(\"%d\\n%d %d\\n\", 2, x, y);\n      break;\n    case 1:\n      printf(\"%d\\n%d\\n\", 1, y);\n      break;\n    case 2:\n      printf(\"%d\\n%d\\n\", 1, x);\n      break;\n    case 3:\n      puts(\"0\");\n      break;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 122222;\nint arr[maxn], n;\nint l[maxn], r[maxn], len, ll, maxl, maxr, minl, minr;\nbool get_val(int x) {\n  if (x > ll) return 0;\n  len = 0;\n  for (int i = 1; i < n; i++) {\n    int head = i + 1, tail = n;\n    if (arr[tail] - arr[i] < x)\n      continue;\n    else if (arr[tail] - arr[i] == x) {\n      l[len] = i, r[len] = head;\n      len++;\n    } else if (arr[head] - arr[i] > x)\n      continue;\n    {\n      while (tail - head > 1) {\n        int mid = (tail + head) / 2;\n        if (arr[mid] - arr[i] <= x)\n          head = mid;\n        else\n          tail = mid;\n      }\n      if (arr[head] - arr[i] == x) {\n        l[len] = i, r[len] = head;\n        len++;\n      }\n    }\n  }\n  maxl = -1, minl = 0x3f3f3f3f;\n  for (int i = 0; i < len; i++) {\n    if (arr[l[i]] > maxl) maxl = arr[l[i]], maxr = arr[r[i]];\n    if (arr[l[i]] < minl) minl = arr[l[i]], minr = arr[r[i]];\n  }\n  return len != 0;\n}\nint main() {\n  int x, y;\n  while (~scanf(\"%d%d%d%d\", &n, &ll, &x, &y)) {\n    for (int i = 1; i <= n; i++) scanf(\"%d\", arr + i);\n    int flag = 0;\n    if (get_val(x)) flag |= 1;\n    if (get_val(y)) flag |= 2;\n    if (flag == 3) {\n      puts(\"0\");\n    } else if (flag == 2) {\n      printf(\"1\\n%d\\n\", x);\n    } else if (flag == 1) {\n      printf(\"1\\n%d\\n\", y);\n    } else {\n      flag = 0;\n      if (get_val(x + y)) {\n        printf(\"1\\n%d\\n\", minl + x);\n        continue;\n      } else if (get_val(y - x)) {\n        if (ll - minr >= x) {\n          printf(\"1\\n%d\\n\", minr + x);\n          continue;\n        } else if (maxl >= x) {\n          printf(\"1\\n%d\\n\", maxl - x);\n          continue;\n        }\n      }\n      printf(\"2\\n%d %d\\n\", x, y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class b {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    int n = input.nextInt();\n    int L = input.nextInt(), x = input.nextInt(), y = input.nextInt();\n    int[] data = new int[n];\n    for(int i = 0; i<n; i++) data[i] = input.nextInt();\n    boolean hasX = false, hasY = false;\n    HashSet<Integer> set = new HashSet<Integer>();\n    for(int i = 0; i<n; i++)\n    {\n        set.add(data[i]);\n        if(set.contains(data[i] - x)) hasX = true;\n        if(set.contains(data[i] - y)) hasY = true;\n    }\n    if(hasX && hasY) out.println(0);\n    else if(hasX) out.println(1+\"\\n\"+y);\n    else if(hasY) out.println(1+\"\\n\"+x);\n    else\n    {\n        boolean hasPair = false;\n        int val = -1;\n        for(int i = 0; i<n; i++)\n        {\n            if(set.contains(data[i] - (x+y)))\n            {\n                val = data[i] - x;\n                hasPair = true;\n            }\n            if(set.contains(data[i] - (y-x)) && data[i] + x <= L)\n            {\n                val = data[i] + x;\n                hasPair = true;\n            }\n            else if(set.contains(data[i] - (y-x)) && data[i] - y >= 0)\n            {\n                val = data[i] - y;\n                hasPair = true;\n            }\n        }\n        if(hasPair)\n        {\n            out.println(1+\"\\n\"+val);\n        }\n        else\n        {\n            out.println(2);\n            out.println(x+\" \"+y);\n        }\n    }\n    \n    out.close();\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, l, x, y;\n  set<long long> Set;\n  while (cin >> n >> l >> x >> y) {\n    for (int i = 1; i <= n; ++i) {\n      long long t;\n      scanf(\"%I64d\", &t);\n      Set.insert(t);\n    }\n    bool checkx = 0;\n    bool checky = 0;\n    for (set<long long>::iterator it = Set.begin(); it != Set.end(); it++) {\n      if (Set.find(*it + x) != Set.end()) {\n        checkx = 1;\n      }\n      if (Set.find(*it + y) != Set.end()) {\n        checky = 1;\n      }\n      if (checkx && checky) {\n        break;\n      }\n    }\n    if (checkx && checky) {\n      cout << 0 << endl;\n      break;\n    }\n    if (checkx) {\n      cout << 1 << endl;\n      cout << y << endl;\n      break;\n    }\n    if (checky) {\n      cout << 1 << endl;\n      cout << x << endl;\n      break;\n    }\n    bool find = 0;\n    long long ans = 0;\n    for (set<long long>::iterator it = Set.begin(); it != Set.end(); it++) {\n      if ((*it + x <= l) && Set.find(*it + x + y) != Set.end()) {\n        find = 1;\n        ans = *it + x;\n        break;\n      }\n      if ((*it + x <= l) && Set.find(*it + x - y) != Set.end()) {\n        find = 1;\n        ans = *it + x;\n        break;\n      }\n      if ((*it - x >= 0) && Set.find(*it - x + y) != Set.end()) {\n        find = 1;\n        ans = *it - x;\n        break;\n      }\n      if ((*it - x >= 0) && Set.find(*it - x - y) != Set.end()) {\n        find = 1;\n        ans = *it - x;\n        break;\n      }\n    }\n    if (find) {\n      cout << 1 << endl;\n      cout << ans << endl;\n      break;\n    }\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def fastio():\n\timport sys\n\tfrom io import StringIO \n\tfrom atexit import register\n\tglobal input\n\tsys.stdin = StringIO(sys.stdin.read())\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\tsys.stdout = StringIO()\n\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\n\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\n\nn, l, x, y = I()\na = I()\ns = set(a)\nf = 0\nfor i in range(n):\n\tif a[i] + x in s:\n\t\tbreak\nelse:\n\tf = 1\nfor i in range(n):\n\tif a[i] + y in s:\n\t\tbreak\nelse:\n\tf += 2\nif f == 1:\n\tprint(1)\n\tprint(x)\nelif f == 2:\n\tprint(1)\n\tprint(y)\nelif f == 0:\n\tprint(0)\nelse:\n\tfor i in range(n):\n\t\tk = a[i] + x\n\t\tif 0 <= k <= l and ((k - y >= 0 and (k-y) in s) or ((k+y) <= l and (k+y) in s)):\n\t\t\tprint(1)\n\t\t\tprint(k)\n\t\t\texit()\n\t\tk = a[i] - x\n\t\tif 0 <= k <= l and ((k - y >= 0 and (k-y) in s) or ((k+y) <= l and (k+y) in s)):\n\t\t\tprint(1)\n\t\t\tprint(k)\n\t\t\texit()\n\tfor i in range(n):\n\t\tk = a[i] + y\n\t\tif 0 <= k <= l and (k - x >= 0 and (k-x) in s or (k+x) <= l and (k+x) in s):\n\t\t\tprint(1)\n\t\t\tprint(k)\n\t\t\tbreak\n\t\tk = a[i] - y\n\t\tif 0 <= k <= l and (k - x >= 0 and (k-x) in s or (k+x) <= l and (k+x) in s):\n\t\t\tprint(1)\n\t\t\tprint(k)\n\t\t\tbreak\n\telse:\n\t\tprint(2)\n\t\tprint(x, y)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long INF = 1000000007;\nconst double cp = 2 * asin(1.0);\nconst double eps = 1e-9;\nconst long long mod = 1000000007;\nusing namespace std;\nint main() {\n  cin.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  map<int, int> a;\n  map<int, int> dif;\n  map<int, int>::iterator it;\n  int n, l, x, y, b[1000005];\n  bool fx = false, fy = false;\n  cin >> n >> l >> x >> y;\n  int mini = 1e9, maxi = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> b[i];\n    a[b[i]]++;\n    mini = min(mini, b[i]);\n    maxi = max(maxi, b[i]);\n    dif[b[i] - x]++;\n    dif[b[i] + x]++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (a.find(b[i] + x)->second != 0) fx = true;\n    if (a.find(b[i] - x)->second != 0) fx = true;\n    if (a.find(b[i] + y)->second != 0) fy = true;\n    if (a.find(b[i] - y)->second != 0) fy = true;\n  }\n  if (fx && fy) {\n    cout << 0;\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (dif.find(b[i] - y)->second != 0 && b[i] - y > 0 && b[i] - y <= l) {\n      cout << 1 << endl;\n      cout << abs(b[i] - y) << endl;\n      return 0;\n    }\n    if (dif.find(b[i] + y)->second != 0 && b[i] + y > 0 && b[i] + y <= l) {\n      cout << 1 << endl;\n      cout << abs(b[i] + y) << endl;\n      return 0;\n    }\n  }\n  vector<int> ans;\n  if (!fx) {\n    if (mini + x > l)\n      ans.push_back(maxi - x);\n    else\n      ans.push_back(mini + x);\n  }\n  if (!fy) {\n    if (mini + y > l)\n      ans.push_back(maxi - y);\n    else\n      ans.push_back(mini + y);\n  }\n  cout << ans.size() << endl;\n  for (int i = 0; i < ans.size(); ++i) cout << ans[i] << ' ';\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> beg, X;\nset<int> Y;\nint n, l, x, y;\nint main() {\n  int p, ansx, ansy;\n  bool a = false, b = false;\n  int c = 0;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &p);\n    beg[p] = 1;\n    if (p >= x) {\n      X[p - x] = 1;\n      if (beg[p - x]) a = true;\n    }\n    if (p >= y) {\n      Y.insert(p - y);\n      if (beg[p - y]) b = true;\n    }\n    if (p + y <= l) {\n      Y.insert(p + y);\n    }\n    if (p + x <= l) {\n      X[p + x] = 1;\n    }\n  }\n  int ans;\n  if (a && b)\n    printf(\"0\\n\");\n  else if (a) {\n    printf(\"1\\n%d\\n\", y);\n  } else if (b) {\n    printf(\"1\\n%d\\n\", x);\n  } else {\n    set<int>::iterator it = Y.begin();\n    bool flag = false;\n    for (it; it != Y.end(); it++) {\n      if (X[*it]) {\n        printf(\"1\\n%d\\n\", *it);\n        flag = true;\n        break;\n      }\n    }\n    if (!flag) printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class d\n{\n    public static void print(String str,long val){\n        System.out.println(str+\"  \"+val);\n    }\n\n    public long gcd(long a, long b) {\n        if (b==0L) return a;\n        return gcd(b,a%b);\n    }\n\n    public static void debug(long[][] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.println(Arrays.toString(arr[i]));\n        }\n    }\n    public static void debug(int[][] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.println(Arrays.toString(arr[i]));\n        }\n    }\n    public static void debug(String[] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.println(arr[i]);\n        }\n    }\n\n    public static void print(int[] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.print('\\n');\n    }\n\n    public static void print(Object[] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.print('\\n');\n    }\n    public static void print(String[] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.print('\\n');\n    }\n    public static void print(long[] arr){\n        int len = arr.length;\n        for(int i=0;i<len;i++){\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.print('\\n');\n    }\n\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n        public FastReader(String path) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(path));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static void sort(long[] arr){\n        Long[] temp = new Long[arr.length];\n        for(int i=0;i<arr.length;i++){\n            temp[i] = arr[i];\n        }\n        Arrays.sort(temp);\n        for(int i=0;i<arr.length;i++){\n            arr[i] = temp[i];\n        }\n    }\n\n\n    public static void main(String[] args)\n    {\n        FastReader s=new FastReader();\n        int n = s.nextInt();\n        long l = s.nextInt();\n        long x = s.nextInt();\n        long y = s.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++){\n            arr[i] = s.nextInt();\n        }\n        long diff = Math.abs(y-x);\n        long[] pref = new long[n];\n        boolean has_x = false;\n        boolean has_y = false;\n        boolean has_diff = false;\n        boolean has_sum = false;\n        int sum_idx  =-1;\n        int diff_idx = -1;\n        TreeSet<Long> set = new TreeSet<>();\n        set.add(0L);\n        for(int i=0;i<n;i++){\n            set.add(arr[i]);\n            if(!has_x){\n                if(set.contains(arr[i]-x)){\n                    has_x = true;\n                }\n            }\n            if(!has_y){\n                if(set.contains(arr[i]-y)){\n                    has_y = true;\n                }\n            }\n            if(!has_diff){\n                if(set.contains(arr[i]-diff)){\n                    has_diff = true;\n                    diff_idx =i;\n                }\n            }\n            if(!has_sum){\n                if(set.contains(arr[i]-(x+y))){\n                    has_sum = true;\n                    sum_idx =i;\n                }\n            }\n        }\n        boolean rev_diff = false;\n        int rev_idx =-1;\n        set = new TreeSet<>();\n        set.add(0L);\n        for(int i=n-1;i>=0;i--){\n            set.add(arr[i]);\n            if(!rev_diff){\n                if(set.contains(arr[i]+diff)){\n                    rev_diff = true;\n                    rev_idx =i;\n                }\n            }\n        }\n        int cnt =0;\n        if(has_x && has_y){\n            System.out.println(0);\n            return;\n        }\n        if(has_x){\n            System.out.println(1);\n            System.out.println(l-y);\n            return;\n        }\n        if(has_y){\n            System.out.println(1);\n            System.out.println(l-x);\n            return;\n        }\n        if(has_diff){\n            if(arr[diff_idx]+Math.min(x,y)<=l){\n                System.out.println(1);\n                System.out.println(Math.min(x,y)+arr[diff_idx]);\n                return;\n            }\n        }\n        if(rev_diff){\n            if(arr[rev_idx]-x>=0){\n                System.out.println(1);\n                System.out.println(arr[rev_idx]-x);\n                return;\n            }\n        }\n        if(has_sum){\n            System.out.println(1);\n            System.out.println(arr[sum_idx]-x);\n            return;\n        }\n        System.out.println(2);\n        System.out.println(l-x);\n        System.out.println(l-y);\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n//    OutputStream out = new BufferedOutputStream( System.out );\n//        for(int i=1;i<n;i++){\n//              out.write((arr[i]+\" \").getBytes());\n//         }\n//        out.flush();\n//  long start_time = System.currentTimeMillis();\n//  long end_time = System.currentTimeMillis();\n//  System.out.println((end_time - start_time) + \"ms\");\n\n\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, mark_len, girl, boy;\nint mark[100005];\nvoid input() {\n  scanf(\"%d%d%d%d\", &n, &mark_len, &girl, &boy);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &mark[i]);\n  }\n}\nbool find(int a) {\n  int* p = lower_bound(mark, mark + n, a);\n  if (p == mark + n) return false;\n  return a == *p;\n}\nvoid work() {\n  bool found_boy = false;\n  bool found_girl = false;\n  for (int i = 0; i < n; i++) {\n    found_boy = found_boy || find(mark[i] + boy);\n    found_girl = found_girl || find(mark[i] + girl);\n  }\n  if (found_boy && found_girl) {\n    puts(\"0\");\n    return;\n  }\n  if (found_boy) {\n    puts(\"1\");\n    printf(\"%d\\n\", girl);\n    return;\n  }\n  if (found_girl) {\n    puts(\"1\");\n    printf(\"%d\\n\", boy);\n    return;\n  }\n  for (int i = 0; i < n; i++) {\n    if ((find(mark[i] + girl - boy) && mark[i] + girl <= mark_len) ||\n        find(mark[i] + girl + boy)) {\n      printf(\"1\\n%d\\n\", mark[i] + girl);\n      return;\n    }\n    if (find(mark[i] - girl + boy) && mark[i] - girl >= 0) {\n      printf(\"1\\n%d\\n\", mark[i] - girl);\n      return;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", girl, boy);\n}\nint main() {\n  input();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstatic const auto INF = std::numeric_limits<int>::max();\nbool check_default(int x, int l, const std::set<int>& marks) {\n  for (auto p : marks) {\n    if (marks.count(p + x)) {\n      return true;\n    }\n    if (marks.count(p - x)) {\n      return true;\n    }\n  }\n  return false;\n}\nbool check(int p, int y, int l, const std::set<int>& marks) {\n  if (p < 1 || p > l) {\n    return false;\n  }\n  return marks.count(p - y) || marks.count(p + y);\n}\nint main() {\n  int n, l, x, y;\n  std::cin >> n >> l >> x >> y;\n  std::set<int> marks;\n  for (int i = 0; i < n; ++i) {\n    int a;\n    std::cin >> a;\n    marks.insert(a);\n  }\n  auto xok = check_default(x, l, marks);\n  auto yok = check_default(y, l, marks);\n  std::vector<int> ans;\n  if (!xok && !yok) {\n    for (auto p : marks) {\n      if (check(p + x, y, l, marks)) {\n        ans.push_back(p + x);\n        break;\n      }\n      if (check(p - x, y, l, marks)) {\n        ans.push_back(p - x);\n        break;\n      }\n    }\n    if (ans.empty()) {\n      ans.push_back(x);\n      ans.push_back(y);\n    }\n  } else if (xok && !yok) {\n    ans.push_back(y);\n  } else if (!xok && yok) {\n    ans.push_back(x);\n  }\n  std::cout << ans.size() << std::endl;\n  if (!ans.empty()) {\n    std::copy(std::begin(ans), std::end(ans),\n              std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << std::endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  set<int> s;\n  bool b = false, g = false;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (s.count(a[i] - x) > 0) b = true;\n    if (s.count(a[i] - y) > 0) g = true;\n  }\n  if (b && g) {\n    cout << 0;\n    return 0;\n  }\n  if ((g && !b) || (!g && b)) {\n    if (!b) cout << 1 << endl << a.back() - x;\n    if (!g) cout << 1 << endl << a.back() - y;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] - x >= 0) {\n      int pos = a[i] - x;\n      if (s.count(pos - y) > 0 || s.count(pos + y) > 0) {\n        cout << 1 << endl << pos;\n        return 0;\n      }\n    }\n    int pos = a[i] + x;\n    if ((pos <= l) && (s.count(pos - y) > 0 || s.count(pos + y) > 0)) {\n      cout << 1 << endl << pos;\n      return 0;\n    }\n  }\n  cout << 2 << endl << a.back() - x << \" \" << a.back() - y;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Codeforces 479D - Long Jumps\n * Created by Darren on 14-10-20.\n * O(n*log(n)) time and O(n) space.\n *\n * Tag: binary search\n */\npublic class D {\n    Reader in = new Reader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        new D().run();\n    }\n\n    void run() throws IOException {\n        int n = in.nextInt(), l = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n\n        boolean forGirl = false, forBoy = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (binarySearch(a, a[i]+x))\n                forGirl = true;\n            if (binarySearch(a, a[i]+y))\n                forBoy = true;\n        }\n\n        if (forGirl && forBoy) {\n            out.println(0);\n        } else if (forGirl || forBoy) {\n            out.println(1);\n            if (forGirl)\n                out.println(y);\n            else\n                out.println(x);\n        } else {\n            int position = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] + x < l) {\n                    if (a[i]+x+y <= l && binarySearch(a, a[i]+x+y) ||\n                            a[i]+x-y >= 0 && binarySearch(a, a[i]+x-y)) {\n                        position = a[i] + x;\n                        break;\n                    }\n                }\n                if (a[i] - x > 0) {\n                    if (a[i]-x+y <= l && binarySearch(a, a[i]-x+y) ||\n                            a[i]-x-y >= 0 && binarySearch(a, a[i]-x-y)) {\n                        position = a[i] - x;\n                        break;\n                    }\n                }\n                if (a[i] + y < l) {\n                    if (a[i]+y+x <= l && binarySearch(a, a[i]+y+x) ||\n                            a[i]+y-x >= 0 && binarySearch(a, a[i]+y-x)) {\n                        position = a[i] + y;\n                        break;\n                    }\n                }\n                if (a[i] - y > 0) {\n                    if (a[i]-y+x < l && binarySearch(a, a[i]-y+x) ||\n                            a[i]-y-x > 0 && binarySearch(a, a[i]-y-x)) {\n                        position = a[i] - y;\n                        break;\n                    }\n                }\n            }\n            if (position > 0) {\n                out.println(1);\n                out.println(position);\n            } else {\n                out.println(2);\n                out.printf(\"%d %d\\n\", x, y);\n            }\n        }\n        out.flush();\n    }\n\n    boolean binarySearch(int[] a, int target) {\n        int lower = 0, upper = a.length-1;\n        while (lower < upper) {\n            int mid = (lower + upper) / 2;\n            if (a[mid] == target)\n                return true;\n            if (a[mid] < target)\n                lower = mid + 1;\n            else\n                upper = mid - 1;\n        }\n        if (a[lower] == target)\n            return true;\n        return false;\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public Reader(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /** get next word */\n        String nextToken() throws IOException {\n            while ( ! tokenizer.hasMoreTokens() ) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer( reader.readLine() );\n            }\n            return tokenizer.nextToken();\n        }\n\n        String readLine() throws IOException {\n            return reader.readLine();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt( nextToken() );\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong( nextToken() );\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble( nextToken() );\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 100011;\nvector<long long> v;\nlong long dist[2];\nbool ok[2];\nbool puede(long long l, long long n) {\n  for (long long i = 0; i < n; i++) {\n    long long pos = lower_bound(v.begin(), v.end(), v[i] + l) - v.begin();\n    if (pos == n) break;\n    if (v[pos] == v[i] + l) {\n      return true;\n    }\n  }\n  return false;\n}\nbool puede2(long long l, long long n) {\n  long long pos = lower_bound(v.begin(), v.end(), l) - v.begin();\n  if (pos == n) return false;\n  if (v[pos] == l) {\n    return true;\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.precision(10);\n  cout << fixed;\n  long long n, l, q;\n  cin >> n >> l >> dist[0] >> dist[1];\n  for (long long i = 0; i < n; i++) {\n    cin >> q;\n    v.push_back(q);\n  }\n  for (long long i = 0; i < 2; i++) {\n    ok[i] = puede(dist[i], n);\n  }\n  if (ok[0] && ok[1]) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (ok[0] || ok[1]) {\n    cout << 1 << endl;\n    if (ok[0]) {\n      cout << dist[1] << endl;\n    } else {\n      cout << dist[0] << endl;\n    }\n    return 0;\n  }\n  for (long long i = 0; i < n; i++) {\n    long long pos =\n        lower_bound(v.begin(), v.end(), v[i] + dist[1] + dist[0]) - v.begin();\n    if (pos == n) break;\n    if (v[pos] == v[i] + dist[1] + dist[0]) {\n      cout << 1 << endl;\n      cout << v[i] + dist[0] << endl;\n      return 0;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    if (0 <= v[i] - dist[0] && puede2(v[i] - dist[0] + dist[1], n)) {\n      cout << 1 << endl;\n      cout << v[i] - dist[0] << endl;\n      return 0;\n    }\n    if (0 <= v[i] - dist[1] && puede2(v[i] - dist[1] + dist[0], n)) {\n      cout << 1 << endl;\n      cout << v[i] - dist[1] << endl;\n      return 0;\n    }\n    if (v[i] + dist[1] <= v[n - 1] && puede2(v[i] - dist[0] + dist[1], n)) {\n      cout << 1 << endl;\n      cout << v[i] + dist[1] << endl;\n      return 0;\n    }\n    if (v[i] + dist[0] <= v[n - 1] && puede2(v[i] - dist[1] + dist[0], n)) {\n      cout << 1 << endl;\n      cout << v[i] + dist[0] << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << dist[0] << \" \";\n  cout << dist[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, a[100001];\nset<int> events;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &m, &x, &y);\n  events.clear();\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), events.insert(a[i]);\n  int status = 0;\n  for (int i = 1; i <= n; i++) {\n    int z = a[i] - x;\n    if (z > 0 && events.find(z) != events.end()) status |= 1;\n    z = a[i] + x;\n    if (z <= m && events.find(z) != events.end()) status |= 1;\n    z = a[i] - y;\n    if (z > 0 && events.find(z) != events.end()) status |= 2;\n    z = a[i] + y;\n    if (z <= m && events.find(z) != events.end()) status |= 2;\n  }\n  if (status == 3) {\n    printf(\"0\\n\");\n    return 0;\n  } else if (status == 1) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  } else if (status == 2) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  } else {\n    events.clear();\n    for (int i = 1; i <= n; i++) {\n      int z = a[i] - x;\n      if (z > 0) events.insert(z);\n      z = a[i] + x;\n      if (z <= m) events.insert(z);\n    }\n    bool ok = true;\n    for (int i = 1; i <= n && ok; i++) {\n      int z = a[i] - y;\n      if (z > 0 && events.find(z) != events.end()) {\n        printf(\"1\\n%d\\n\", z);\n        ok = false;\n        break;\n      }\n      z = a[i] + y;\n      if (z <= m && events.find(z) != events.end()) {\n        printf(\"1\\n%d\\n\", z);\n        ok = false;\n        break;\n      }\n    }\n    if (ok) printf(\"2\\n%d %d\\n\", x, y);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> M;\nint n, l, x, y, a[100005];\nbool okx, oky;\ninline bool has(int x) { return M.find(x) != M.end(); }\nbool ok(int d, int t) {\n  if (d < 0 || d > l) return 0;\n  return (has(d + t) || has(d - t));\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    M.insert(a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (has(a[i] - x)) okx = 1;\n    if (has(a[i] - y)) oky = 1;\n  }\n  if (okx && oky)\n    cout << 0;\n  else if (okx && !oky)\n    cout << 1 << endl << y;\n  else if (!okx && oky)\n    cout << 1 << endl << x;\n  else {\n    int i;\n    for (i = 0; i < n; i++) {\n      if (ok(a[i] + x, y)) {\n        cout << 1 << endl << a[i] + x;\n        break;\n      }\n      if (ok(a[i] - x, y)) {\n        cout << 1 << endl << a[i] - x;\n        break;\n      }\n    }\n    if (i == n) cout << 2 << endl << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\nconst int MAXM = 100000007;\nconst int MAX = 1e7;\nconst int des = 10000;\nconst int maxn = 100005;\nint main() {\n  map<int, bool> mp;\n  vector<int> g;\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int tmp;\n    cin >> tmp;\n    g.push_back(tmp);\n    mp[tmp] = true;\n  }\n  bool nadX = true;\n  for (int i = 0; i < n - 1; i++) {\n    if (g[i] + x <= l && mp.find(g[i] + x) != mp.end()) {\n      nadX = false;\n      break;\n    }\n  }\n  bool nadY = true;\n  for (int i = 0; i < n - 1; i++) {\n    if (g[i] + y <= l && mp.find(g[i] + y) != mp.end()) {\n      nadY = false;\n      break;\n    }\n  }\n  if (nadX && nadY) {\n    for (int i = 0; i < n; i++) {\n      int plusa = g[i] + x - y, minusa = g[i] - x + y;\n      if (mp.find(plusa) != mp.end() && g[i] + x <= l) {\n        cout << \"1\\n\" << g[i] + x << endl;\n        return 0;\n      }\n      if (mp.find(minusa) != mp.end() && g[i] - x > 0) {\n        cout << \"1\\n\" << g[i] - x << endl;\n        return 0;\n      }\n      int plusa1 = g[i] + x + y, minusa1 = g[i] - x - y;\n      if (mp.find(plusa1) != mp.end() && g[i] + x + y <= l) {\n        cout << \"1\\n\" << g[i] + x << endl;\n        return 0;\n      }\n      if (mp.find(minusa1) != mp.end() && g[i] - x - y > 0) {\n        cout << \"1\\n\" << g[i] - x << endl;\n        return 0;\n      }\n    }\n    cout << 2 << endl << x << \" \" << y << endl;\n    return 0;\n  }\n  if (nadX) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  if (nadY) {\n    cout << 1 << endl << y;\n    return 0;\n  }\n  cout << 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "class CodeforcesTask480BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n_l_x_y = []\n        self.ruler = []\n\n    def read_input(self):\n        self.n_l_x_y = [int(x) for x in input().split(\" \")]\n        self.ruler = [int(x) for x in input().split(\" \")]\n\n    def process_task(self):\n        dists = {}\n        for a in self.ruler:\n            dists[a] = True\n        hasx = False\n        hasy = False\n        for a in self.ruler:\n            try:\n                if dists[a - self.n_l_x_y[2]]:\n                    hasx = True\n            except KeyError:\n                pass\n            try:\n                if dists[a + self.n_l_x_y[2]]:\n                    hasx = True\n            except KeyError:\n                pass\n            try:\n                if dists[a - self.n_l_x_y[3]]:\n                    hasy = True\n            except KeyError:\n                pass\n            try:\n                if dists[a - self.n_l_x_y[3]]:\n                    hasy = True\n            except KeyError:\n                pass\n            if hasx and hasy:\n                break\n        if hasx and hasy:\n            self.result = \"0\"\n        elif hasx:\n            self.result = \"1\\n{0}\".format(self.n_l_x_y[3])\n        elif hasy:\n            self.result = \"1\\n{0}\".format(self.n_l_x_y[2])\n        else:\n            res = [0, 0]\n            sgn = False\n            dst = self.n_l_x_y[2] + self.n_l_x_y[3]\n            diff = self.n_l_x_y[3] - self.n_l_x_y[2]\n            for a in self.ruler:\n                try:\n                    if dists[a - dst]:\n                        if a - self.n_l_x_y[2] > 0:\n                            sgn = True\n                            res = a - self.n_l_x_y[2]\n                except KeyError:\n                    pass\n                try:\n                    if dists[a + dst]:\n                        if a + self.n_l_x_y[2] < self.n_l_x_y[1]:\n                            sgn = True\n                            res = a + self.n_l_x_y[2]\n                except KeyError:\n                    pass\n                try:\n                    if dists[a - diff]:\n                        if a + self.n_l_x_y[2] < self.n_l_x_y[1]:\n                            sgn = True\n                            res = a + self.n_l_x_y[2]\n                except KeyError:\n                    pass\n                try:\n                    if dists[a + diff]:\n                        if a - self.n_l_x_y[2] > 0:\n                            sgn = True\n                            res = a - self.n_l_x_y[2]\n                except KeyError:\n                    pass\n                if sgn:\n                    break\n            if sgn:\n                self.result = \"1\\n{0}\".format(res)\n            else:\n                self.result = \"2\\n{0} {1}\".format(self.n_l_x_y[2], self.n_l_x_y[3])\n\n    def get_result(self):\n        return self.result\n\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask480BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int UI;\ntypedef long int LI;\ntypedef unsigned long int ULI;\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\nLL mod = 1e9 + 7;\ninline int scanInt() {\n  int n = 0;\n  char ch = getchar();\n  int sign = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') sign = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    n = (n << 1) + (n << 3) + (int)(ch - '0');\n    ch = getchar();\n  }\n  return n * sign;\n}\ninline LL scanLong() {\n  LL n = 0;\n  char ch = getchar();\n  LL sign = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') sign = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    n = (n << 1) + (n << 3) + (LL)(ch - '0');\n    ch = getchar();\n  }\n  return n * sign;\n}\nint main() {\n  LL n = scanLong();\n  ;\n  LL l = scanLong();\n  ;\n  LL x = scanLong();\n  ;\n  LL y = scanLong();\n  ;\n  vector<LL> arr(n);\n  for (__typeof(n) i = (0) - ((0) > (n)); i != (n) - ((0) > (n));\n       i += 1 - 2 * ((0) > (n)))\n    arr[i] = scanLong();\n  set<LL> s;\n  s.insert(x);\n  s.insert(y);\n  for (__typeof(arr.end()) it = (arr.begin()) - ((arr.begin()) > (arr.end()));\n       it != (arr.end()) - ((arr.begin()) > (arr.end()));\n       it += 1 - 2 * ((arr.begin()) > (arr.end()))) {\n    if (binary_search(arr.begin(), arr.end(), *it + x)) s.erase(x);\n    if (binary_search(arr.begin(), arr.end(), *it + y)) s.erase(y);\n  }\n  if (s.size() == 0)\n    puts(\"0\");\n  else if (s.size() == 1) {\n    puts(\"1\");\n    printf(\"%lld \", *s.begin());\n    printf(\"\\n\");\n  } else {\n    for (__typeof(arr.end()) it = (arr.begin()) - ((arr.begin()) > (arr.end()));\n         it != (arr.end()) - ((arr.begin()) > (arr.end()));\n         it += 1 - 2 * ((arr.begin()) > (arr.end()))) {\n      if (binary_search(arr.begin(), arr.end(), *it + x + y) ||\n          binary_search(arr.begin(), arr.end(), *it + x - y)) {\n        if (*it + x <= l) {\n          puts(\"1\");\n          printf(\"%lld \", (*it + x));\n          printf(\"\\n\");\n          return 0;\n        }\n      }\n      if (binary_search(arr.begin(), arr.end(), *it - x + y) ||\n          binary_search(arr.begin(), arr.end(), *it - x - y)) {\n        if (*it - x >= 0) {\n          puts(\"1\");\n          printf(\"%lld \", (*it - x));\n          printf(\"\\n\");\n          return 0;\n        }\n      }\n      if (binary_search(arr.begin(), arr.end(), *it + y + x) ||\n          binary_search(arr.begin(), arr.end(), *it + y - x)) {\n        if (*it + y <= l) {\n          puts(\"1\");\n          printf(\"%lld \", (*it + y));\n          printf(\"\\n\");\n          return 0;\n        }\n      }\n      if (binary_search(arr.begin(), arr.end(), *it - y + x) ||\n          binary_search(arr.begin(), arr.end(), *it - y - x)) {\n        if (*it - y >= 0) {\n          puts(\"1\");\n          printf(\"%lld \", (*it - y));\n          printf(\"\\n\");\n          return 0;\n        }\n      }\n    }\n    puts(\"2\");\n    printf(\"%lld \", x);\n    printf(\"%lld \", y);\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class LongJumps {\n\n  static BufferedReader in;\n  static PrintWriter out;\n  static StringTokenizer tok;\n\n  static void solve() throws Exception {\n    int n = nextInt(), l = nextInt(), x = nextInt(), y = nextInt();\n    int[] p = nextIntArray(n, 0);\n    Set<Integer> set = new HashSet<>();\n    set.add(x);\n    set.add(y);\n    Set<Integer> set2 = new HashSet<>();\n    for (int pi : p) {\n      if (pi == x)\n        set.remove(x);\n      if (pi == y)\n        set.remove(y);\n      if (set2.contains(pi - x))\n        set.remove(x);\n      if (set2.contains(pi - y))\n        set.remove(y);\n      set2.add(pi);\n    }\n    if (set.size() == 2)\n      for (int i : set2) {\n        int x1 = i + x;\n        if (x1 < l && (set2.contains(x1 + y) || set2.contains(x1 - y))) {\n          out.println(1);\n          out.println(x1);\n          return;\n        }\n        int x2 = i - x;\n        if (x2 > 0 && (set2.contains(x2 + y) || set2.contains(x2 - y))) {\n          out.println(1);\n          out.println(x2);\n          return;\n        }\n        int y1 = i + y;\n        if (y1 < l && (set2.contains(y1 + x) || set2.contains(y1 - x))) {\n          out.println(1);\n          out.println(y1);\n          return;\n        }\n        int y2 = i - y;\n        if (y2 > 0 && (set2.contains(y2 + x) || set2.contains(y2 - x))) {\n          out.println(1);\n          out.println(y2);\n          return;\n        }\n      }\n    out.println(set.size());\n    for (int i : set)\n      out.print(i + \" \");\n  }\n\n  public static void main(String args[]) {\n    try {\n      in = new BufferedReader(new InputStreamReader(System.in));\n      out = new PrintWriter(new OutputStreamWriter(System.out));\n      solve();\n      in.close();\n      out.close();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n\n  static int nextInt() throws IOException {\n    return Integer.parseInt(next());\n  }\n\n  static int[] nextIntArray(int len, int start) throws IOException {\n    int[] a = new int[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextInt();\n    return a;\n  }\n\n  static long nextLong() throws IOException {\n    return Long.parseLong(next());\n  }\n\n  static long[] nextLongArray(int len, int start) throws IOException {\n    long[] a = new long[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextLong();\n    return a;\n  }\n\n  static String next() throws IOException {\n    while (tok == null || !tok.hasMoreTokens()) {\n      tok = new StringTokenizer(in.readLine());\n    }\n    return tok.nextToken();\n  }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class D{\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(in.readLine());\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint l=Integer.parseInt(st.nextToken());\n\t\tint x=Integer.parseInt(st.nextToken());\n\t\tint y=Integer.parseInt(st.nextToken());\n\n\t\tint A[]=new int[n];\n\t\tHashSet<Integer> hs=new HashSet<Integer>();\n\t\tst=new StringTokenizer(in.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint val=Integer.parseInt(st.nextToken());\n\t\t\tA[i]=val;\n\t\t\ths.add(val);\n\t\t}\n\n\n\n\n\t\tboolean is_x=false;\n\t\tboolean is_y=false;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint val=A[i];\n\t\t\tif(val-x>=0&&(!is_x)){\n\t\t\t\tif(hs.contains(val-x))is_x=true;\n\t\t\t}\n\t\t\telse if(val+x<=l&&(!is_x)){\n\t\t\t\tif(hs.contains(val+x))is_x=true;\n\t\t\t}\n\n\t\t\tif(val-y>=0&&(!is_y)){\n\t\t\t\tif(hs.contains(val-y))is_y=true;\n\t\t\t}\n\t\t\telse if(val+y<=l&&(!is_y)){\n\t\t\t\tif(hs.contains(val+y))is_y=true;\n\t\t\t}\n\t\t}\n\t\tif(is_x&&is_y){\n\t\t\tSystem.out.println(\"0\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(is_y){\n\t\t\tSystem.out.println(\"1\");\n\t\t\tSystem.out.println(x);\n\t\t\treturn;\n\t\t}\n\t\tif(is_x){\n\t\t\tSystem.out.println(\"1\");\n\t\t\tSystem.out.println(y);\n\t\t\treturn;\n\t\t}\n\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint val=A[i];\n\t\t\tint r=val-x;\n\t\t\tif(r>=0){\n\t\t\t\tif(r-y>=0){\n\t\t\t\t\tif(hs.contains(r-y)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r+y<=l){\n\t\t\t\t\t//System.out.println(r+y);\n\t\t\t\t\tif(hs.contains(r+y)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\n\t\t\tr=val+x;\n\t\t\tif(r<=l){\n\t\t\t\tif(r-y>=0){\n\t\t\t\t\tif(hs.contains(r-y)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r+y<=l){\n\t\t\t\t\tif(hs.contains(r+y)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\n\n\t\t\tr=val-y;\n\t\t\tif(r>=0){\n\t\t\t\tif(r-x>=0){\n\t\t\t\t\tif(hs.contains(r-x)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r+x<=l){\n\t\t\t\t\tif(hs.contains(r+x)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\n\n\n\n\t\t\tr=val+y;\n\t\t\tif(r<=l){\n\t\t\t\tif(r-x>=0){\n\t\t\t\t\tif(hs.contains(r-x)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r+x<=l){\n\t\t\t\t\tif(hs.contains(r+x)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tSystem.out.println(r);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"2\");\n\t\tSystem.out.println(x+\" \"+y);\n\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint n, l, x, y, a[100005];\nbool J(int w) {\n  if (w < 0 || w > l) return 0;\n  int L = 1, R = n;\n  while (L <= R) {\n    int mid = (L + R) >> 1;\n    if (a[mid] < w)\n      L = mid + 1;\n    else if (a[mid] > w)\n      R = mid - 1;\n    else\n      return 1;\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  int k = 0;\n  for (int i = 1; i < n; i++) {\n    int w = a[i] + x;\n    if (!(k & 1) && J(w)) k += 1;\n    w = a[i] + y;\n    if (k < 2 && J(w)) k += 2;\n  }\n  if (k != 0) {\n    if (k == 1) {\n      printf(\"1\\n%d\\n\", y);\n    } else if (k == 2) {\n      printf(\"1\\n%d\\n\", x);\n    } else\n      puts(\"0\");\n  } else {\n    bool ok = 0;\n    for (int i = 1; i <= n; i++) {\n      int w = a[i] + x;\n      if (w <= l) {\n        if (J(w + y) || J(w - y)) {\n          ok = 1;\n          printf(\"1\\n%d\\n\", w);\n          break;\n        }\n      }\n      w = a[i] - x;\n      if (w >= 0) {\n        if (J(w + y) || J(w - y)) {\n          ok = 1;\n          printf(\"1\\n%d\\n\", w);\n          break;\n        }\n      }\n    }\n    if (!ok) {\n      swap(x, y);\n      for (int i = 1; i <= n; i++) {\n        int w = a[i] + x;\n        if (w <= l) {\n          if (J(w + y) || J(w - y)) {\n            ok = 1;\n            printf(\"1\\n%d\\n\", w);\n            break;\n          }\n        }\n        w = a[i] - x;\n        if (w >= 0) {\n          if (J(w + y) || J(w - y)) {\n            ok = 1;\n            printf(\"1\\n%d\\n\", w);\n            break;\n          }\n        }\n      }\n    }\n    if (!ok) printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nint a[100000];\nint fnd1(int f) {\n  int l = 0;\n  for (int r = 0; r < n; r++) {\n    while (a[l] + f < a[r] && l < n) l++;\n    if (a[l] + f == a[r]) return l;\n  }\n  return -1;\n}\nint fnd2(int f) {\n  int r = n - 1;\n  for (int l = n - 1; l >= 0; l--) {\n    while (a[l] + f < a[r] && r >= 0) r--;\n    if (a[l] + f == a[r]) return l;\n  }\n  return -1;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  bool p, q;\n  p = q = 0;\n  p = (fnd1(x) != -1);\n  q = (fnd1(y) != -1);\n  if (p && q)\n    cout << 0 << endl;\n  else {\n    if (p)\n      cout << 1 << endl << y << endl;\n    else if (q)\n      cout << 1 << endl << x << endl;\n    else {\n      int c;\n      c = fnd1(x + y);\n      if (c != -1) {\n        cout << 1 << endl << a[c] + x << endl;\n        return 0;\n      }\n      c = fnd1(y - x);\n      if (c != -1 && a[c] + y <= l) {\n        cout << 1 << endl << a[c] + y << endl;\n        return 0;\n      }\n      c = fnd2(y - x);\n      if (c != -1 && a[c] - x >= 0) {\n        cout << 1 << endl << a[c] - x << endl;\n      } else\n        cout << 2 << endl << x << \" \" << y << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 100000;\nset<int> MP;\nint N, L, X, Y, A = 1, B = 1;\nvector<int> sol;\nbool FIND(int val) { return MP.find(val) != MP.end(); }\nint main() {\n  cin >> N >> L >> X >> Y;\n  for (int i = 1; i <= N; ++i) {\n    int nr;\n    cin >> nr;\n    MP.insert(nr);\n  }\n  for (auto i : MP) {\n    int p = i;\n    if (FIND(p + X)) A = 0;\n    if (FIND(p + Y)) B = 0;\n  }\n  if (A && B) {\n    for (auto i : MP) {\n      int p = i;\n      if (!FIND(p + X) && p + X <= L) {\n        if (FIND(p + X - Y) || FIND(p + X + Y)) {\n          cout << \"1\\n\";\n          cout << p + X << '\\n';\n          return 0;\n        }\n      }\n      if (!FIND(p + Y) && p + Y <= L) {\n        if (FIND(p + Y - X) || FIND(p + Y + X)) {\n          cout << \"1\\n\";\n          cout << p + Y << '\\n';\n          return 0;\n        }\n      }\n      if (!FIND(p + X) && p - X >= 0) {\n        if (FIND(p - X - Y) || FIND(p - X + Y)) {\n          cout << \"1\\n\";\n          cout << p - X << '\\n';\n          return 0;\n        }\n      }\n      if (!FIND(p - Y) && p - Y >= 0) {\n        if (FIND(p - Y - X) || FIND(p - Y + X)) {\n          cout << \"1\\n\";\n          cout << p - Y << '\\n';\n          return 0;\n        }\n      }\n    }\n    cout << \"2\\n\";\n    cout << X << ' ' << Y << '\\n';\n    return 0;\n  } else if (A) {\n    cout << \"1\\n\";\n    cout << X << '\\n';\n  } else if (B) {\n    cout << \"1\\n\";\n    cout << Y << '\\n';\n  } else\n    cout << \"0\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class B\n{\n        String line;\n        StringTokenizer inputParser;\n        BufferedReader is;\n        FileInputStream fstream;\n        DataInputStream in;\n        String FInput=\"\";\n        \n        void openInput(String file)\n        {\n\n                if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin\n                else\n                {\n                        try{\n                \n                                \n                        fstream = new FileInputStream(file);\n                        in = new DataInputStream(fstream);\n                        is = new BufferedReader(new InputStreamReader(in));\n                        }catch(Exception e)\n                        {\n                                System.err.println(e);\n                        }\n                }\n\n        }\n        \n        void readNextLine()\n    \t{\n    \t\ttry {\n    \t\t\tline = is.readLine();\n    \t\t\tinputParser = new StringTokenizer(line, \" ,\\t\");\n    \t\t\t//System.err.println(\"Input: \" + line);\n    \t\t} catch (IOException e) {\n    \t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n    \t\t}\t\n    \t\tcatch (NullPointerException e)\n    \t\t{\n    \t\t\tline=null;\n    \t\t\t\n    \t\t}\n    \t\t\n    \t}\n        \n        long NextLong()\n        {\n                String n = inputParser.nextToken();\n                \n                long val = Long.parseLong(n);\n                \n                 return val;\n        }\n        \n        int NextInt()\n        {\n                String n = inputParser.nextToken();\n                int val = Integer.parseInt(n);\n                \n                //System.out.println(\"I read this number: \" + val);\n                return val;\n        }\n        \n        String NextString()\n        {\n                String n = inputParser.nextToken();\n                return n;\n        }\n        \n        void closeInput()\n        {\n                try {\n                        is.close();\n                } catch (IOException e) {\n                        System.err.println(\"Unexpected IO ERROR: \" + e);\n                }\n                        \n        }\n        \n        public static void main(String [] argv)\n        {\n                //String filePath=\"circles.in\";\n                String filePath=null;\n                if(argv.length>0)filePath=argv[0];\n                new B(filePath);\n                \n        }\n        \n        public B(String inputFile)\n        {\n        \topenInput(inputFile);\n    \t\tStringBuilder sb = new StringBuilder();\n    \t\treadNextLine();\n    \t\tint N=NextInt(), L=NextInt(), X=NextInt(), Y=NextInt();\n    \t\treadNextLine();\n    \t\tint [] p = new int[N];\n    \t\tfor(int i=0; i<N; i++)\n    \t\t{\n    \t\t\tp[i]=NextInt();\n    \t\t}\n    \t\t\n    \t\tboolean a=false, b=false;\n    \t\t\n    \t\tfor(int i=0; i<N; i++)\n    \t\t{\n    \t\t\tint r = Arrays.binarySearch(p, p[i]+X);\n    \t\t\tif(r>=0)a=true;\n    \t\t\tr = Arrays.binarySearch(p, p[i]-X);\n    \t\t\tif(r>=0)a=true;\n    \t\t\tr = Arrays.binarySearch(p, p[i]+Y);\n    \t\t\tif(r>=0)b=true;\n    \t\t\tr = Arrays.binarySearch(p, p[i]-Y);\n    \t\t\tif(r>=0)b=true;\n    \t\t}\n    \t\tint res=0;\n    \t\tif(!a)\n    \t\t{\n    \t\t\tint AA=X;\n    \t\t\tif(!a)\n    \t\t\t{\n    \t\t\t\tfor(int i=0; i<N; i++)\n    \t\t\t\t{\n    \t\t\t\t\tint P=p[i]+X;\n    \t\t\t\t\tif(P>=0&&P<=L)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tint r = Arrays.binarySearch(p, P+Y);\n    \t\t    \t\t\tif(r>=0)b=true;\n    \t\t    \t\t\tr = Arrays.binarySearch(p, P-Y);\n    \t\t    \t\t\tif(r>=0)b=true;\n    \t\t\t\t\t}\n    \t\t\t\t\tif(b)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tAA=p[i]+X;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\tP=p[i]-X;\n    \t\t\t\t\tif(P>=0&&P<=L)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tint r = Arrays.binarySearch(p, P+Y);\n    \t\t    \t\t\tif(r>=0)b=true;\n    \t\t    \t\t\tr = Arrays.binarySearch(p, P-Y);\n    \t\t    \t\t\tif(r>=0)b=true;\n    \t\t\t\t\t}\n    \t\t\t\t\tif(b)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tAA=p[i]-X;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tres++;\n    \t\t\tsb.append(AA+\" \");\n    \t\t}\n    \t\tif(!b)\n    \t\t{\n    \t\t\t\n    \t\t\tif(!b)\n    \t\t\t{\n\t    \t\t\tres++;\n\t    \t\t\tsb.append(Y);\n    \t\t\t}\n    \t\t}\n    \t\tsb.insert(0, res+\"\\n\");\n        \tSystem.out.println(sb);\n    \t\tcloseInput();\t\n        }\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong n, l, x, y, a[1 << 20];\nset<long> has;\nlong hx, hy;\nlong ans;\nlong thx, thy;\nvoid check(long ps) {\n  if (ps < 0 || ps > l) return;\n  hx = thx;\n  hy = thy;\n  if (has.find(ps + x) != has.end()) hx = 1;\n  if (has.find(ps + y) != has.end()) hy = 1;\n  if (has.find(ps - x) != has.end()) hx = 1;\n  if (has.find(ps - y) != has.end()) hy = 1;\n  if (hx && hy) ans = ps;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    has.insert(a[i]);\n  }\n  hx = hy = 0;\n  for (int i = 0; i < n; i++) {\n    if (has.find(a[i] + x) != has.end()) hx = 1;\n    if (has.find(a[i] + y) != has.end()) hy = 1;\n    if (has.find(a[i] - x) != has.end()) hx = 1;\n    if (has.find(a[i] - y) != has.end()) hy = 1;\n  }\n  thx = hx;\n  thy = hy;\n  if (hx && hy) {\n    cout << 0 << endl;\n  } else {\n    ans = -1;\n    for (int i = 0; i < n; i++) {\n      check(a[i] - x);\n      check(a[i] + x);\n      check(a[i] - y);\n      check(a[i] + y);\n    }\n    if (ans >= 0)\n      cout << 1 << endl << ans << endl;\n    else {\n      cout << 2 << endl;\n      cout << x << \" \" << y << endl;\n    }\n  }\n  cin.get();\n  cin.get();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class B {\n\n    static void solve() throws IOException {\n        int n = nextInt();\n        int l = nextInt();\n        int x = nextInt();\n        int y = nextInt();\n        HashSet<Integer> len = new HashSet<>( n );\n        for ( int i = 0; i < n; i ++ ) {\n            len.add( nextInt() );\n        }\n        boolean cx = false;\n        boolean cy = false;\n        int cymx = -1;\n        int cypx = -1;\n        for (Integer a : len) {\n            if ( len.contains( a + x ) ) {\n                cx = true;\n            }\n            if ( len.contains( a + y ) ) {\n                cy = true;\n            }\n            if ( len.contains( a + y - x ) && ( a - x >= 0 || a + y <= l ) ) {\n                cymx = a;\n            }\n            if ( a + y <= 1000000000 && len.contains( a + y + x ) ) {\n                cypx = a;\n            }\n        }\n        if ( cx && cy ) {\n            out.println( 0 );\n        } else if ( cx || cy ) {\n            out.println( 1 );\n            out.println( cx ? y : x );\n        } else if ( cymx >= 0 ) {\n            out.println( 1 );\n            if ( cymx - x >= 0 ) {\n                out.println( cymx - x );\n            } else {\n                out.println( cymx + y );\n            }\n        } else if ( cypx >= 0 ) {\n            out.println( 1 );\n            out.println( cypx + x );\n        } else {\n            out.println( 2 );\n            out.println( x + \" \" + y );\n        }\n    }\n\n    static StreamTokenizer in;\n    static PrintWriter out;\n\n    static int nextInt() throws IOException {\n        in.nextToken();\n        return ( int ) in.nval;\n    }\n\n    public static void main( String[] args ) throws IOException {\n        in = new StreamTokenizer( new InputStreamReader( System.in ) );\n        out = new PrintWriter( System.out );\n        solve();\n        out.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long Max(long long a, long long b) { return (a > b ? a : b); }\nlong long Min(long long a, long long b) { return (a > b ? b : a); }\nlong long n, length, x, y, tmp, answer;\nvector<long long> V;\nvector<long long> ans;\nbool X, Y;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> length >> x >> y;\n  for (long long i = 0; i < n; i++) {\n    cin >> tmp;\n    V.push_back(tmp);\n  }\n  answer = 2;\n  X = false;\n  Y = false;\n  for (long long i = 0; i < n; i++) {\n    if (binary_search(V.begin(), V.end(), x + V[i])) {\n      answer--;\n      X = true;\n      break;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    if (binary_search(V.begin(), V.end(), y + V[i])) {\n      Y = true;\n      answer--;\n      break;\n    }\n  }\n  if (answer == 0) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (answer == 1) {\n    if (X) {\n      cout << \"1\\n\" << y << \"\\n\";\n      return 0;\n    } else {\n      cout << \"1\\n\" << x << \"\\n\";\n      return 0;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    if (V[i] + x < length) {\n      if (binary_search(V.begin(), V.end(), V[i] + x + y)) {\n        cout << \"1\\n\" << V[i] + x << \"\\n\";\n        return 0;\n      }\n      if (binary_search(V.begin(), V.end(), V[i] + x - y)) {\n        cout << \"1\\n\" << V[i] + x << \"\\n\";\n        return 0;\n      }\n    }\n    if (V[i] - x > 0) {\n      if (binary_search(V.begin(), V.end(), V[i] - x + y)) {\n        cout << \"1\\n\" << V[i] - x << \"\\n\";\n        return 0;\n      }\n      if (binary_search(V.begin(), V.end(), V[i] - x - y)) {\n        cout << \"1\\n\" << V[i] - x << \"\\n\";\n        return 0;\n      }\n    }\n    if (V[i] + y < length) {\n      if (binary_search(V.begin(), V.end(), V[i] + x + y)) {\n        cout << \"1\\n\" << V[i] + y << \"\\n\";\n        return 0;\n      }\n      if (binary_search(V.begin(), V.end(), V[i] + y - x)) {\n        cout << \"1\\n\" << V[i] + y << \"\\n\";\n        return 0;\n      }\n    }\n    if (V[i] - y > 0) {\n      if (binary_search(V.begin(), V.end(), V[i] + x - y)) {\n        cout << \"1\\n\" << V[i] - y << \"\\n\";\n        return 0;\n      }\n      if (binary_search(V.begin(), V.end(), V[i] - y - x)) {\n        cout << \"1\\n\" << V[i] - y << \"\\n\";\n        return 0;\n      }\n    }\n  }\n  cout << \"2\\n\" << x << \" \" << y << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\n\n\npublic class Main {\n\n   \n    \n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] in = br.readLine().split(\" \");\n        \n        int n = Integer.parseInt(in[0]);\n        int L = Integer.parseInt(in[1]);\n        int x = Integer.parseInt(in[2]);\n        int y = Integer.parseInt(in[3]);\n        \n        int[] a = new int[n];\n        HashSet<Integer> H = new HashSet<>();\n        in=br.readLine().split(\" \");\n        for(int i=0;i<n;i++){\n            a[i] = Integer.parseInt(in[i]);\n            H.add(a[i]);\n        }\n           \n        int cnt = 0;\n        boolean hasX = containsVal(a, H, x);\n        boolean hasY = containsVal(a, H, y);\n        String ans = \"\";\n        if(hasX && hasY) {\n            //do nothing just print all the results in H\n            \n        }\n        else if(hasX) {\n            ans = y+\"\";\n            cnt=1;\n        }\n        else if(hasY) {\n            ans = x+\"\";\n            cnt=1;\n        }\n        else {\n            if(H.contains(x+y)) {\n                cnt=1;\n                ans = x+\"\";\n                        \n            }\n            else{\n                //try to do it in one step\n                //extend all by x first \n                boolean seen1 = false;\n                HashSet<Integer> S1 = new HashSet<>();\n                HashSet<Integer> S2 = new HashSet<>();\n                HashSet<Integer> S3 = new HashSet<>();\n                for(Integer t: H) {\n                    if(t+x <= L) S1.add(t+x);\n                    if(t-x>=0) S2.add(t-x);\n                    if(t-y >=0) S3.add(t-y);\n                }\n                for(Integer t : H) {\n                    if(S1.contains(t+y) && (t+y)<=L){\n                        seen1=true;\n                        ans=t+y+\"\";\n                        cnt=1;\n                        break;\n                    }\n                    else if(S2.contains(t-y)) {\n                        seen1=true;\n                        ans=t-y+\"\";\n                        cnt=1;\n                        break;\n                    }\n                    else if(S2.contains(t+y) && (t+y)<=L) {\n                        seen1=true;\n                        ans=t+y+\"\";\n                        cnt=1;\n                        break;\n                    }\n                    else if(S3.contains(t+x) && t+x <=L) {\n                        seen1=true;\n                        ans=t+y+\"\";\n                        cnt=1;\n                        break;\n                    }\n                }\n                \n                if(!seen1) {\n                    cnt=2;\n                    ans = y+\" \"+x;\n                }\n                        \n            }\n        }\n        bw.append(cnt+\"\\n\");\n        \n        bw.append(ans+\"\\n\");\n\n                    \n        \n        bw.close();\n        \n        \n    }\n\n    private static boolean containsVal(int[] a, HashSet<Integer> H, int x) {\n        boolean seen = false;\n        for(int i=0;i<a.length;i++) {\n            if(H.contains(a[i]+x)) {\n                seen=true;\n                break;\n            }\n        }\n        return seen;\n    }\n\n    \n    \n\n}\n"
        },
        {
            "language": 3,
            "solution": "R = lambda: map(int, input().split())\nn, l, x, y = R()\narr = set(R())\nx_good, y_good = False, False\nfor m in arr:\n    if m + x in arr or m - x in arr:\n        x_good = True\n        break\nfor m in arr:\n    if m + y in arr or m - y in arr:\n        y_good = True\n        break\nif x_good and y_good:\n    print(0)\n    exit()\nelif x_good:\n    print(1)\n    print(y)\n    exit()\nelif y_good:\n    print(1)\n    print(x)\n    exit()\nelse:\n    for m in arr:\n        if m + x <= l and (m + x + y in arr or m + x - y in arr):\n            print(1)\n            print(m + x)\n            exit()\n        if m - x >= 0 and (m - x + y in arr or m - x - y in arr):\n            print(1)\n            print(m - x)\n            exit()\n        if m + y <= l and (m + y + x in arr or m + y - x in arr):\n            print(1)\n            print(m + y)\n            exit()\n        if m - y >= 0 and (m - y + x in arr or m - y - x in arr):\n            print(1)\n            print(m - y)\n            exit()\nprint(2)\nprint(x, y)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic final class code\n// class code\n// public class Solution\n{\n\tstatic void solve()throws IOException\n\t{\n\t\tint n=nextInt();\n\t\tint l=nextInt();\n\t\tint x=nextInt();\n\t\tint y=nextInt();\n\t\tHashSet<Integer> set=new HashSet<>();\n\t\twhile(n-->0)\n\t\t\tset.add(nextInt());\n\t\tboolean hasx=false,hasy=false;\n\t\tfor(int i:set)\n\t\t{\n\t\t\tif(set.contains(i+x))\n\t\t\t\thasx=true;\n\t\t\tif(set.contains(i+y))\n\t\t\t\thasy=true;\n\t\t}\n\t\tif(hasx && hasy)\n\t\t{\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tif(hasx)\n\t\t{\n\t\t\tout.println(1+\"\\n\"+y);\n\t\t\treturn;\n\t\t}\n\t\tif(hasy)\n\t\t{\n\t\t\tout.println(1+\"\\n\"+x);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i:set)\n\t\t{\n\t\t\tif(i+x<l)\n\t\t\t{\n\t\t\t\tif(set.contains(i+x-y) || set.contains(i+x+y))\n\t\t\t\t{\n\t\t\t\t\tout.println(\"1\\n\"+(i+x));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i-x>0)\n\t\t\t{\n\t\t\t\tif(set.contains(i-x-y) || set.contains(i-x+y))\n\t\t\t\t{\n\t\t\t\t\tout.println(\"1\\n\"+(i-x));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"2\\n\"+x+\" \"+y);\n\t}\n\n\t///////////////////////////////////////////////////////////\n\t\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tout=new PrintWriter(new BufferedOutputStream(System.out));\n\t\trandom=new Random();\n\t\tsolve();\n \n\t\t// int t=nextInt();\n\t\t// for(int i=1;i<=t;i++)\n\t\t// {\n\t\t// \t// out.print(\"Case #\"+i+\": \");\n\t\t// \tsolve();\n\t\t// }\n \n\t\tout.close();\n\t}\n\tstatic final long mod=(long)(1e9+7);\n\tstatic final int inf=(int)(1e9+1);\n\t// static final long inf=(long)(1e18);\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tint first,second;\n\t\tPair(int a,int b)\n\t\t{\n\t\t\tfirst=a;\n\t\t\tsecond=b;\n\t\t}\n\t\tpublic int compareTo(Pair p)\n\t\t{\n\t\t\tif(this.first==p.first)\n\t\t\t\treturn this.second-p.second;\n\t\t\treturn this.first-p.first;\n\t\t}\n\t\tpublic boolean equals(Object p)\n\t\t{\n\t\t\tPair p1=(Pair)p;\n\t\t\treturn (first==p1.first && second==p1.second);\n\t\t}\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn this.first+\" \"+this.second;\n\t\t}\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn (int)((1l*(inf+1)*this.first+this.second)%mod);\n\t\t}\n\t}\n\tstatic void debug(Object ... a)\n\t{\n\t\tSystem.out.print(\"> \");\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic void debug(int a[]){debuga(Arrays.stream(a).boxed().toArray());}\n\tstatic void debug(long a[]){debuga(Arrays.stream(a).boxed().toArray());}\n\tstatic void debuga(Object a[])\n\t{\n\t\tSystem.out.print(\"> \");\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t}\n \n\t\n\tstatic Random random;\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\tstatic String nextToken()throws IOException\n\t{\n\t\twhile(st==null || !st.hasMoreTokens())\n\t\t\tst=new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tstatic String nextLine()throws IOException\n\t{\n\t\treturn br.readLine();\n\t}\n\tstatic int nextInt()throws IOException\n\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tstatic long nextLong()throws IOException\n\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tstatic double nextDouble()throws IOException\n\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, int> mp;\nlong long n, m, i, j, x, y, num[100005];\nbool in(long long x) { return (x > -1 && x <= m); }\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> x >> y;\n  for (i = 1; i <= n; i++) {\n    cin >> num[i];\n    mp[num[i]] = 1;\n  }\n  bool okx = 0, oky = 0;\n  for (i = 1; i <= n; i++) {\n    if (mp[num[i] + x] || mp[num[i] - x]) okx = 1;\n    if (mp[num[i] + y] || mp[num[i] - y]) oky = 1;\n  }\n  if (okx) {\n    if (oky) {\n      cout << 0;\n      return 0;\n    }\n    cout << 1 << endl << y;\n    return 0;\n  }\n  if (oky) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  for (i = 1; i <= n; i++) {\n    if (in(num[i] - x) && (mp[num[i] - x - y] || mp[num[i] - x + y])) {\n      cout << 1 << endl << num[i] - x;\n      return 0;\n    }\n    if (in(num[i] + x) && (mp[num[i] + x - y] || mp[num[i] + x + y])) {\n      cout << 1 << endl << num[i] + x;\n      return 0;\n    }\n    if (in(num[i] - y) && (mp[num[i] - x - y] || mp[num[i] + x - y])) {\n      cout << 1 << endl << num[i] - y;\n      return 0;\n    }\n    if (in(num[i] + y) && (mp[num[i] - x + y] || mp[num[i] + x + y])) {\n      cout << 1 << endl << num[i] + y;\n      return 0;\n    }\n  }\n  cout << 2 << endl << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nint n, ll, x, y;\nvector<int> a;\nint t;\nusing namespace std;\nint main() {\n  cin >> n >> ll >> y >> x;\n  for (int i = 0; i < n; i++) {\n    cin >> t;\n    a.push_back(t);\n  }\n  bool hx = false;\n  bool hy = false;\n  int l = 0;\n  int r = 0;\n  while (r < n) {\n    if (a[r] - a[l] == x) {\n      hx = 1;\n      break;\n    }\n    if (a[r] - a[l] < x) {\n      r++;\n    } else {\n      l++;\n    }\n  }\n  l = 0;\n  r = 0;\n  while (r < n) {\n    if (a[r] - a[l] == y) {\n      hy = 1;\n      break;\n    }\n    if (a[r] - a[l] < y) {\n      r++;\n    } else {\n      l++;\n    }\n  }\n  if (hx && hy) {\n    cout << 0 << endl;\n  } else if (hx) {\n    cout << 1 << endl;\n    cout << y << endl;\n  } else if (hy) {\n    cout << 1 << endl;\n    cout << x << endl;\n  } else {\n    l = 0;\n    r = 0;\n    while (r < n) {\n      if (a[r] - a[l] == x + y) {\n        cout << 1 << endl;\n        cout << a[l] + x << endl;\n        return 0;\n      }\n      if (a[r] - a[l] < x + y) {\n        r++;\n      } else {\n        l++;\n      }\n    }\n    l = 0;\n    r = 0;\n    while (r < n) {\n      if (a[r] - a[l] == x - y && a[l] - y >= 0) {\n        cout << 1 << endl;\n        cout << a[l] - y << endl;\n        return 0;\n      }\n      if (a[r] - a[l] < x - y) {\n        r++;\n      } else {\n        l++;\n      }\n    }\n    l = 0;\n    r = 0;\n    while (r < n) {\n      if (a[r] - a[l] == x - y && a[r] + y <= ll) {\n        cout << 1 << endl;\n        cout << a[r] + y << endl;\n        return 0;\n      }\n      if (a[r] - a[l] < x - y) {\n        r++;\n      } else {\n        l++;\n      }\n    }\n    cout << 2 << endl;\n    cout << x << endl;\n    cout << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\n\t\tint cnt = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] - x == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (a[i] - x > 0) {\n\t\t\t\tint t = a[i] - x;\n\t\t\t\tif (Arrays.binarySearch(a, t) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n - 1) {\n\t\t\t\tcnt++;\n\t\t\t\tsb.append(x + \" \");\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] - y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (a[i] - y > 0) {\n\t\t\t\tint t = a[i] - y;\n\t\t\t\tif (Arrays.binarySearch(a, t) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n - 1) {\n\t\t\t\tcnt++;\n\t\t\t\tsb.append(y);\n\t\t\t}\n\t\t}\n\t\tif (cnt == 2) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint addX = a[i] + x;\n\t\t\t\tint subX = a[i] - x;\n\t\t\t\tif (addX <= l && Arrays.binarySearch(a, addX - y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (addX <= l && Arrays.binarySearch(a, addX + y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(addX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (subX >= 0 && Arrays.binarySearch(a, subX - y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(subX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (subX >= 0 && Arrays.binarySearch(a, subX + y) >= 0) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append(subX);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\t\tif (sb.length() > 0)\n\t\t\tSystem.out.println(sb);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100000];\nint main() {\n  int n, l, x, y, f = 0, i;\n  set<int> s;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  for (i = 0; i < n; i++) {\n    if (s.count(a[i] + x)) f |= 1;\n    if (s.count(a[i] + y)) f |= 2;\n  }\n  if (f == 3) {\n    puts(\"0\");\n    return 0;\n  } else if (f == 1) {\n    puts(\"1\");\n    printf(\"%d\\n\", y);\n    return 0;\n  } else if (f == 2) {\n    puts(\"1\");\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  for (i = 0; i < n; i++) {\n    if (s.count(a[i] + y - x)) {\n      if (a[i] >= x) {\n        puts(\"1\");\n        printf(\"%d\\n\", a[i] - x);\n        return 0;\n      } else if (a[i] + y <= l) {\n        puts(\"1\");\n        printf(\"%d\\n\", a[i] + y);\n        return 0;\n      }\n    }\n    if (s.count(a[i] + x + y)) {\n      puts(\"1\");\n      printf(\"%d\\n\", a[i] + x);\n      return 0;\n    }\n  }\n  puts(\"2\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100100;\nint n, l, x, y, v[MAXN];\nint c1, c2, c3, c4, ret, ret2;\nint main() {\n  cin.sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  c1 = c2 = c3 = c4 = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> v[i];\n  }\n  for (int i = 1; i < n; ++i) {\n    if (v[lower_bound(v + i + 1, v + n + 1, v[i] + x) - v] == v[i] + x) c1 = 1;\n    if (v[lower_bound(v + i + 1, v + n + 1, v[i] + y) - v] == v[i] + y) c2 = 1;\n    if (v[lower_bound(v + i + 1, v + n + 1, v[i] + x + y) - v] ==\n        v[i] + x + y) {\n      c3 = 1;\n      ret = v[i] + x;\n    }\n    if (v[lower_bound(v + i + 1, v + n + 1, v[i] + abs(x - y)) - v] ==\n        v[i] + abs(x - y)) {\n      if (v[i] + max(x, y) <= l) {\n        c4 = 1;\n        ret2 = v[i] + max(x, y);\n      } else if (v[i] - min(x, y) >= 0) {\n        c4 = 1;\n        ret2 = v[i] - min(x, y);\n      }\n    }\n  }\n  if (c1 && c2)\n    cout << 0;\n  else if (c3)\n    cout << 1 << \"\\n\" << ret;\n  else if (c4)\n    cout << 1 << \"\\n\" << ret2;\n  else {\n    cout << 2 - c1 - c2 << \"\\n\";\n    if (!c1) cout << x << \" \";\n    if (!c2) cout << y << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    \n    \n    static InputReader in;\n    static PrintWriter out;\n        \n    public static void main(String[] args) throws IOException{\n        //InputStream ins = new FileInputStream(\"E:\\\\rush.txt\");\n        InputStream ins = System.in;\n        in = new InputReader(ins);\n        out = new PrintWriter(System.out);\n        //code start from here\n        new Task().solve(in, out);\n        out.close();\n    }\n    \n    static int N = 50000;\n    static class Task{\n        int n,l,x,y;\n        boolean ok1,ok2;\n        Map<Integer,Integer> dic,dic1,dic2;\n        \n        public void solve(InputReader in,PrintWriter out) {\n        \tdic = new HashMap<Integer,Integer>();\n        \tdic1 = new HashMap<Integer,Integer>();\n        \tdic2 = new HashMap<Integer,Integer>();\n        \tok1 = false;ok2 = false;\n        \tn = in.nextInt();l = in.nextInt();\n        \tx = in.nextInt();y = in.nextInt();\n        \tfor (int i = 1;i <= n;i++) {\n        \t\tint ai;\n        \t\tai = in.nextInt();\n        \t\tif (dic.containsKey(ai-x)) ok1 = true;\n        \t\tif (dic.containsKey(ai-y)) ok2 = true;\n        \t\tdic1.put(ai-x, 1);\n        \t\tdic1.put(ai+x, 1);\n        \t\tdic2.put(ai-y, 1);\n        \t\tdic2.put(ai+y, 1);\n        \t\tdic.put(ai, 1);\n        \t}\n        \tif (ok1 && ok2) {\n        \t\tout.println(0);\n        \t}else if (!ok1 && !ok2) {\n        \t\tfor (Map.Entry<Integer,Integer> it:dic1.entrySet()) {\n        \t\t\tint x = it.getKey();\n        \t\t\tif (x<0) continue;\n        \t\t\tif (x>l) continue;\n        \t\t\tif (dic2.containsKey(x)) {\n        \t\t\t\tout.println(1);\n        \t\t\t\tout.println(x);\n        \t\t\t\treturn;\n        \t\t\t}\n        \t\t}\n        \t\tout.println(2);\n        \t\tout.println(x+\" \"+y);\n        \t}else {\n        \t\tout.println(1);\n        \t\tif (!ok1) {\n        \t\t\tout.println(x);\n        \t\t}else {\n        \t\t\tout.println(y);\n        \t\t}\n        \t}\n        }\n    }\n\n    \n\n    static class InputReader{\n        public BufferedReader br;\n        public StringTokenizer tokenizer;\n        \n        public InputReader(InputStream ins) {\n            br = new BufferedReader(new InputStreamReader(ins));\n            tokenizer = null;\n        }\n        \n        public String next(){\n            while (tokenizer==null || !tokenizer.hasMoreTokens()) {\n                try {\n                tokenizer = new StringTokenizer(br.readLine());\n                }catch(IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nconst int inf = 1e9 + 7;\nconst long long ll_inf = 1e18 + 420;\nconst double eps = 1e-4;\nconst int N = 1e6 + 7;\nconst int MAX = 2e5 + 9;\nconst int mod = 1e9 + 7;\nconst long double pi = 3.14159265359;\nbool t[2];\nint n, l, x, y;\nint main() {\n  cin >> n >> l >> x >> y;\n  set<int> s;\n  int a[n + 100];\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  for (auto i : s) {\n    auto it = s.find(i + x);\n    if (it != s.end()) t[0] = 1;\n    it = s.find(i + y);\n    if (it != s.end()) t[1] = 1;\n  }\n  if (t[0] && t[1]) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (t[0]) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", y);\n    return 0;\n  }\n  if (t[1]) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  for (auto i : s) {\n    auto it = s.find(i + x + y);\n    if (it != s.end()) {\n      printf(\"1\\n\");\n      printf(\"%d\\n\", i + x);\n      return 0;\n    }\n    it = s.find(i + y - x);\n    if (it != s.end()) {\n      if (i - x >= 0) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", i - x);\n        return 0;\n      } else if (i + y <= l) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", i + y);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e6 + 7;\nlong long b, c, res, a[N], l, x, y, n;\nmap<long long, long long> m;\nint main() {\n  cin >> n >> l >> x >> y;\n  if (x > y) swap(x, y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", a + i);\n    m[a[i]] = 1;\n  }\n  res = 2;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] == x || m[a[i] + x]) b = 1;\n    if (a[i] == y || m[a[i] + y]) c = 1;\n  }\n  if (b && c) {\n    cout << 0;\n    return 0;\n  }\n  if (b || c) {\n    cout << 1 << endl;\n    cout << (!b ? x : y) << endl;\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (m[a[i] + x - y] && a[i] + x <= l) {\n      cout << 1 << endl << a[i] + x;\n      return 0;\n    } else if (m[a[i] + y - x] && a[i] + y <= l) {\n      cout << 1 << endl << a[i] + y;\n      return 0;\n    } else if (m[a[i] - x + y] && a[i] - x >= 0) {\n      cout << 1 << endl << a[i] - x;\n      return 0;\n    } else if (m[a[i] + y + x] && a[i] + y + x <= l) {\n      cout << 1 << endl << a[i] + y;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class LongJumps {\n\t\n\tstatic int l;\n\t\n\tpublic static void main(String args[]) throws IOException {\n\t\tFastIO io = new FastIO(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = io.nextInt();\n\t\tl = io.nextInt();\n\t\tint x = io.nextInt(), y = io.nextInt();\n\t\tint a[] = new int[n+5];\n\t\tfor(int i = 0; i < n; i++) a[i] = io.nextInt();\n\t\t\n\t\tint f1 = check(a, n, x, 0), f2 = check(a, n, y, 0);\n\t\t\n\t\tif(f1 != -1) {\n\t\t\tif(f2 != -1) out.println(0);\n\t\t\telse out.printf(\"1\\n%d\\n\", y);\n\t\t}\n\t\telse {\n\t\t\tif(f2 != -1) out.printf(\"1\\n%d\\n\", x);\n\t\t\t\n\t\t\telse {\n\t\t\t\tint f = check(a, n, x+y, 0);\n\t\t\t\tif(f != -1) out.printf(\"1\\n%d\\n\", a[f]+x);\n\t\t\t\telse {\n\t\t\t\t\tint pos = -1, offset= Math.max(x, y);\n\t\t\t\t\tf = check(a, n, Math.max(x, y) - Math.min(x, y), offset);\n\t\t\t\t\tif(f == -1) {\n\t\t\t\t\t\toffset = -Math.min(x, y);\n\t\t\t\t\t\tf = check(a, n, Math.max(x, y) - Math.min(x, y), offset);\n\t\t\t\t\t}\n\t\t\t\t\tif(f != -1) pos = a[f] + offset;\n\t\t\t\t\tif(pos != -1) out.printf(\"1\\n%d\\n\", pos);\n\t\t\t\t\telse out.printf(\"2\\n%d %d\\n\", x, y);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.flush();\n\t\tout.close();\t\n\t}\n\t\n\tpublic static int check(int a[], int n, int d, int offset) {\n\t\t\n\t\tint i = 1, j = 0;\n\t\twhile(i < n) {\n\t\t\tif(a[i] - a[j] == d) {\n\t\t\t\tif(offset==0 || a[j]+offset<=l && a[j]+offset>=0)\n\t\t\t\t\treturn j;\n\t\t\t}\n\t\t\tif(a[i]-a[j] > d) j++;\n\t\t\telse i++;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tstatic class FastIO{\n\t\t\n//\t\tfinal int maxn = 1e5+5;\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastIO(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\t\t\n\t\tpublic String next() throws IOException{\n\t\t\twhile(st==null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\t\n\t\tpublic boolean ready() throws IOException{\n\t\t\treturn br.ready();\n\t\t}\n\t\t\n\t\tpublic void print(String str){\n\t\t\tSystem.out.print(str);\n\t\t}\n\t\t\n\t\tpublic void println(String str){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t\t\n\t\tpublic void print(int str){\n\t\t\tSystem.out.print(str);\n\t\t}\n\t\t\n\t\tpublic void print(double str){\n\t\t\tSystem.out.print(str);\n\t\t}\n\t\t\n\t\tpublic void print(char str){\n\t\t\tSystem.out.print(str);\n\t\t}\n\t\t\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main\n{\n\n\tstatic Hashtable<Integer, String> a = new Hashtable<Integer, String>();\n\tstatic int both, t, z, n, l, x, y;\n\t\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\n\t\tn = sc.nextInt();\n\t\tl = sc.nextInt();\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tz = sc.nextInt();\n//\t\t\tSystem.out.println(z);\n\t\t\tif(a.get(z) == null)\n\t\t\t{\n\t\t\t\ta.put(z, \"n\");\t// Neutral\t\n\t\t\t}\t\t\t\n\t\t\telse if(a.get(z) == \"g\")\n\t\t\t{\n\t\t\t\ta.put(z, \"ng\");\n\t\t\t}\n\t\t\telse if(a.get(z) == \"b\")\n\t\t\t{\n\t\t\t\ta.put(z, \"nb\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta.put(z, \"ngb\");\n\t\t\t}\n\t\t\t\n\t\t\tt = z - x;\n//\t\t\tSystem.out.println(\"Check Alpha: \" + t);\n\t\t\tif(t >= 0)\n\t\t\t{\n\t\t\t\tif(a.get(t) == \"n\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"ng\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"nb\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"ngb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"b\")\n\t\t\t\t{\n\t\t\t\t\tboth = t;\n\t\t\t\t\ta.put(t, \"gb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == null)\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"g\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = z + x;\n//\t\t\tSystem.out.println(\"Check Bravo: \" + t);\n\t\t\tif(t <= l)\n\t\t\t{\n\t\t\t\tif(a.get(t) == \"n\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"ng\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"nb\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"nbg\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"b\")\n\t\t\t\t{\n\t\t\t\t\tboth = t;\n\t\t\t\t\ta.put(t, \"gb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == null)\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"g\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = z - y;\n//\t\t\tSystem.out.println(\"Check Charlie: \" + t);\n\t\t\tif(t >= 0)\n\t\t\t{\n\t\t\t\tif(a.get(t) == \"n\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"nb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"ng\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"ngb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"g\")\n\t\t\t\t{\n\t\t\t\t\tboth = t;\n\t\t\t\t\ta.put(t, \"gb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == null)\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"b\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = z + y;\n//\t\t\tSystem.out.println(\"Check Delta: \" + t);\n\t\t\tif(t <= l)\n\t\t\t{\n\t\t\t\tif(a.get(t) == \"n\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"nb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"ng\")\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"ngb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == \"g\")\n\t\t\t\t{\n\t\t\t\t\tboth = t;\n\t\t\t\t\ta.put(t, \"gb\");\n\t\t\t\t}\n\t\t\t\telse if(a.get(t) == null)\n\t\t\t\t{\n\t\t\t\t\ta.put(t, \"b\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(a.containsValue(\"ngb\") || (a.containsValue(\"ng\") && a.containsValue(\"nb\")))\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(a.containsValue(\"ng\") && a.containsValue(\"b\"))\n\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(y);\n\t\t}\n\t\telse if(a.containsValue(\"nb\") && a.containsValue(\"g\"))\n\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t\telse if(a.containsValue(\"gb\"))\n\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(both);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(x + \" \" + y);\n\t\t}\n\t}\n\t\n\n\t\n\t//-----------PrintWriter for faster output---------------------------------\n\tpublic static PrintWriter out;\n\n\t//-----------MyScanner class for faster input----------\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine(){\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "// CodeForces Round #479 C competition\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Lineika {\n\n\tint n;\n\tint []a;\n\tint l,x,y;\n\tint val, ax, ay;\n\n\tprivate void readData(BufferedReader bin) throws IOException {\n\t\tString s = bin.readLine();\n\t\tString[] ss = s.split(\" \");\n\t\tn = Integer.parseInt(ss[0]);\n\t\tl = Integer.parseInt(ss[1]);\n\t\tx = Integer.parseInt(ss[2]);\n\t\ty = Integer.parseInt(ss[3]);\n\t\ta = new int[n];\n\t\ts = bin.readLine();\n\t\tss = s.split(\" \");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(ss[i]);\n\t\t}\n\t}\n\n\tvoid printRes() {\n\t\tif (val == 0) {\n\t\t\tSystem.out.println(val);\n\t\t} else if (val==1) {\n\t\t\tSystem.out.println(val);\n\t\t\tSystem.out.println(ax);\n\t\t} else {\n\t\t\tSystem.out.println(val);\n\t\t\tSystem.out.println(x + \" \" + y);\n\t\t}\n\t}\n\t\n\tprivate boolean checknum(int num) {\n\t\tfor (int i=0; i<n-1; i++) {\n\t\t\tint aj = a[i] + num;\n\t\t\tif (haveValue(aj)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate boolean check0() {\n\t\treturn checknum(x) && checknum(y);\n\t}\n\t\n\tboolean haveValue(int aj) {\n\t\tint i0 = 0;\n\t\tint i1 = n;\n\t\twhile (i0<i1) {\n\t\t\tint ii = (i0+i1) / 2;\n\t\t\tif (a[ii] == aj) {\n\t\t\t\treturn true;\n\t\t\t} else if (a[ii] < aj) {\n\t\t\t\ti0 = ii + 1;\n\t\t\t} else {\n\t\t\t\ti1 = ii;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean check1() {\n\t\t// check x+y\n\t\tfor (int i=0; i<n-1; i++) {\n\t\t\tint aj = a[i] + (x+y);\n\t\t\tif (haveValue(aj)) {\n\t\t\t\tax = a[i] + y;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// check y - x\n\t\tfor (int i=0; i<n-1; i++) {\n\t\t\tint aj = a[i] + (y-x);\n\t\t\tif (haveValue(aj)) {\n\t\t\t\tif (a[i] + y <= l) {\n\t\t\t\t\tax = a[i] + y;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (a[i] -x >= 0) {\n\t\t\t\t\tax = a[i] - x;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (checknum(x)) {\n\t\t\tax = y;\n\t\t\treturn true;\n\t\t}\n\t\tif (checknum(y)) {\n\t\t\tax = x;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\n\tprivate void calculate() {\n\t\t// search for minimum last day\n\t\tval = 2;\n\t\tif (check0()) {\n\t\t\tval = 0;\n\t\t} else if (check1()) {\n\t\t\tval = 1;\n\t\t} \n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// BufferedReader bin = new BufferedReader(new FileReader(\"cactus.in\"));\n\t\tBufferedReader bin = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\tLineika l = new Lineika();\n\t\tl.readData(bin);\n\t\tl.calculate();\n\t\tl.printRes();\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dc\ndef serch(a,b,x,y):\n        for i in range(1,n):\n                if (b[a[i]-x-y]):\n                        return a[i]-y\n                if b[a[i]-(y-x)] and a[i]+x<=l:\n                        return a[i]+x\n                if b[a[i]+(y-x)] and a[i]-x>=0:\n                        return a[i]-x\n        return 0\n                \nn,l,x,y=[int(i) for i in input().split()]\na=[int(i) for i in input().split()]\nb=dc(int)\nb=dc(lambda :0,b)\nk1=0\nk2=0\nfor i in range(n):\n        b[a[i]]=1\n        if b[a[i]-x]==1:\n                k1=1\n        if b[a[i]-y]==1:\n                k2=1\nif k1==1 and k2==1:\n        print(0)\nelif k1==0 and k2==0:\n        z=serch(a,b,x,y)\n        if z!=0:\n                print(1)\n                print(z)\n        else:\n                print(2)\n                print(x,y)\nelif k1==0:\n        print(1)\n        print(x)\nelse:\n        print(1)\n        print(y)\n\n\n\n                \n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class D {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        n = scanner.nextInt();\n        l = scanner.nextInt();\n        x = scanner.nextInt();\n        y = scanner.nextInt();\n        a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = scanner.nextInt();\n        boolean isInX = isIn(x), isInY = isIn(y);\n        if(isInX && isInY)\n            System.out.println(0);\n        else if(isInX) {\n            System.out.println(1);\n            System.out.println(y);\n        } else if (isInY) {\n            System.out.println(1);\n            System.out.println(x);\n        } else {\n            boolean succ = false;\n            for(int i = 0; i < n ; i++) {\n                int left = a[i] - x;\n                int right = a[i] + x;\n                if(left >= 0 && left <= l) {\n                    boolean flag = isIn2(0, i, left, y);\n                    if(flag) {\n                        System.out.println(1);\n                        System.out.println(left);\n                        succ = true;\n                        break;\n                    }\n                    flag = isIn3(i, n, left, y);\n                    if(flag) {\n                        System.out.println(1);\n                        System.out.println(left);\n                        succ = true;\n                        break;\n                    }\n                }\n                if(right >= 0 && right <= l) {\n                    boolean flag = isIn2(0, i, right, y);\n                    if(flag) {\n                        System.out.println(1);\n                        System.out.println(right);\n                        succ = true;\n                        break;\n                    }\n                    flag = isIn3(i, n, right, y);\n                    if(flag) {\n                        System.out.println(1);\n                        System.out.println(right);\n                        succ = true;\n                        break;\n                    }\n                }\n            }\n            if(!succ) {\n                System.out.println(2);\n                System.out.println(x + \" \" + y);\n            }\n        }\n    }\n\n    private static boolean isIn2(int l, int r, int pos, int v) {\n        int low = l, high = r;\n        while (low < high) {\n            int mid = ((low + high) >> 1);\n            if (Math.abs(pos - a[mid]) == v)\n                return true;\n            if (Math.abs(pos - a[mid]) > v)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return false;\n    }\n\n    private static boolean isIn3(int l, int r, int pos, int v) {\n        int low = l, high = r;\n        while (low < high) {\n            int mid = ((low + high) >> 1);\n            if (Math.abs(pos - a[mid]) == v)\n                return true;\n            if (Math.abs(pos - a[mid]) < v)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return false;\n    }\n    static int n, l, x, y;\n    static int a[];\n\n    static boolean isIn(int num) {\n        if(num == 0) return true;\n        \n        for (int i = 1; i < n; i++) {\n            int low = 0, high = i;\n            while (low < high) {\n                int mid = ((low + high) >> 1);\n                if (a[i] - a[mid] == num)\n                    return true;\n                if (a[i] - a[mid] > num)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n/**\n * Created by hama_du on 2014/11/03.\n */\npublic class ProblemB {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int[] marks = new int[n];\n        for (int i = 0; i < n; i++) {\n            marks[i] = in.nextInt();\n        }\n\n        boolean makeX = make(marks, x);\n        boolean makeY = make(marks, y);\n        boolean makeXY = make(marks, x+y);\n\n        int[] answer = {};\n        if (makeX && makeY) {\n            answer = new int[]{};\n        } else if (makeX) {\n            answer = new int[]{y};\n        } else if (makeY) {\n            answer = new int[]{x};\n        } else if (makeXY) {\n            answer = new int[]{ marks[lastL] + x };\n        } else {\n            if (make(marks, y-x) && marks[lastL] + y <= l) {\n                answer = new int[] { marks[lastL] + y};\n            } else if (makeR(marks, y-x) && marks[lastR] - y >= 0) {\n                answer = new int[] { marks[lastR] - y };\n            } else {\n                answer = new int[]{x, y};\n            }\n        }\n\n        String ln = \"\";\n        for (int f : answer) {\n            ln += \" \" + f;\n        }\n        out.println(answer.length);\n        if (ln.length() >= 1) {\n            out.println(ln.substring(1));\n        }\n        out.flush();\n    }\n\n\n    static int lastL, lastR;\n\n    static boolean make(int[] mark, int x) {\n        int n = mark.length;\n        int l = 0;\n        int r = 0;\n        while (l < n) {\n            while (r < n && mark[r] - mark[l] < x) {\n                r++;\n            }\n            if (r >= n) {\n                break;\n            }\n            if (mark[r] - mark[l] == x) {\n                lastL = l;\n                lastR = r;\n                return true;\n            }\n            l++;\n        }\n        return false;\n    }\n\n    private static boolean makeR(int[] mark, int x) {\n        int n = mark.length;\n        int l = n-1;\n        int r = n-1;\n        while (r >= 0) {\n            while (l >= 0 && mark[r] - mark[l] < x) {\n                l--;\n            }\n            if (l < 0) {\n                break;\n            }\n            if (mark[r] - mark[l] == x) {\n                lastL = l;\n                lastR = r;\n                return true;\n            }\n            r--;\n        }\n        return false;\n    }\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class D \n{\n    FastScanner in;\n    PrintWriter out;\n    \n    public void solve() throws IOException \n    {\n        int n = in.nextInt();       \n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        \n        int mas[] = in.nextIntArray(n);     \n        int xy[]  = {x, y};     \n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 2; j++)\n            {\n                if(xy[j] >= 0)\n                {\n                    int dif = mas[i] - xy[j];\n                    int sum = mas[i] + xy[j];\n                    \n                    if(dif >= 0 && Arrays.binarySearch(mas, dif) >= 0)\n                        xy[j] = -1;\n                    \n                    if(sum <= l && Arrays.binarySearch(mas, sum) >= 0)\n                        xy[j] = -1;     \n                }\n            }\n            \n            if(xy[0] == -1 && xy[1] == -1)\n                break;\n        }\n        \n        if(xy[0] == -1 && xy[1] == -1)\n            out.print(0);\n        else\n        {\n            if(xy[0] == -1)\n                xy = new int[]{xy[1]};\n            else if(xy[1] == -1)\n                xy = new int[]{xy[0]};\n            \n            if(xy.length == 1)\n            {\n                out.println(1);\n                out.print(xy[0]);\n            }\n            else\n            {\n                boolean found = false;\n                \n                for(int i = 0; i < n; i++)\n                {\n                    int rMas[] = {mas[i] + x, mas[i] - x};\n                    \n                    for(int r : rMas)\n                    {\n                        int a1 = r + y;\n                        int a2 = r - y;\n                        \n                        if( r >= 0 && r <= l && ( (a1 <= l && Arrays.binarySearch(mas, a1) >= 0) || (a2 >= 0 && Arrays.binarySearch(mas, a2) >= 0)) )\n                        {\n                            out.println(1);\n                            out.print(r);\n                            found = true;\n                            break;\n                        }\n                    }\n                    \n                    if(found)\n                        break;\n                }\n                \n                if(!found)\n                {\n                    out.println(2);\n                    out.print(x + \" \" + y);\n                }\n            }\n        }\n    }\n\n    public void run() \n    {\n        try \n        {\n            in  = new FastScanner();\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        }\n        catch (IOException e) \n        {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner \n    {\n        BufferedReader  br;\n        StringTokenizer st;\n        \n        FastScanner() \n        {\n            br = new BufferedReader(new InputStreamReader(System.in));        \n        }\n\n        FastScanner(File f) \n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            }\n            catch (FileNotFoundException e) \n            {\n                e.printStackTrace();\n            }\n        }\n\n        String nextLine() \n        {\n            String ret = null;\n            try\n        {\n                ret = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n            \n            return ret;\n        }\n\n        String next() \n        {\n            while (st == null || !st.hasMoreTokens()) \n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() \n        {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() \n        {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() \n        {\n            return Double.parseDouble(next());\n        }\n        \n        int[] nextIntArray(int size) \n        {\n            int[] array = new int[size];\n            \n            for (int i = 0; i < size; i++)\n            {\n                array[i] = nextInt();\n            }\n            \n            return array;\n        }\n        \n        long[] nextLongArray(int size) \n        {\n            long[] array = new long[size];\n            \n            for (int i = 0; i < size; i++)\n            {\n                array[i] = nextLong();\n            }\n            \n            return array;\n        }\n        \n        BigInteger nextBigInteger() \n        {\n            return new BigInteger(next());\n        }\n        \n        Point nextIntPoint()\n        {\n            int x = nextInt();\n            int y = nextInt();\n            return new Point(x, y);\n        }\n        \n        Point[] nextIntPointArray(int size)\n        {\n            Point[] array = new Point[size];\n            \n            for (int index = 0; index < size; ++index)\n            {\n                array[index] = nextIntPoint();\n            }\n            \n            return array;\n        }\n        \n        List<Integer>[] readGraph(int vertexNumber, int edgeNumber, boolean undirected)\n        {\n            List<Integer>[] graph = new List[vertexNumber];\n                    \n            for (int index = 0; index < vertexNumber; ++index)\n            {\n                graph[index] = new ArrayList<Integer>();\n            }\n                    \n            while (edgeNumber-- > 0)\n            {\n                int from = nextInt() - 1;\n                int to   = nextInt() - 1;\n                        \n                graph[from].add(to);\n                \n                if(undirected)\n                    graph[to].add(from);\n            }\n                    \n            return graph;\n        }\n    }\n\n    public static void main(String[] arg) \n    {\n        new D().run();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author dipankar12\n */\nimport java.io.*;\nimport java.util.*;\npublic class r274d {\n    public static void main(String args[])\n    {\n        fastio in=new fastio(System.in);\n        PrintWriter pw=new PrintWriter(System.out);\n\n        int n=in.nextInt();\n        int l=in.nextInt();\n        int x=in.nextInt();\n        int y=in.nextInt();\n        \n        int ar[]=new int[n];\n        HashSet<Integer> hs=new HashSet<Integer>();\n        for(int i=0;i<n;i++)\n        {\n            ar[i]=in.nextInt();\n            hs.add(ar[i]);\n        }\n        \n        boolean b=false,g=false;\n        for(int i=0;i<n;i++)\n        {\n            int lo=0,hi=n-1;\n            while(lo<=hi)\n            {\n                int mid=(lo+hi)/2;\n                if(Math.abs(ar[mid]-ar[i])==x)\n                {\n                    b=true;\n                    break;\n                }\n                else if(Math.abs(ar[mid]-ar[i])>x)\n                    hi=mid-1;\n                else\n                    lo=mid+1;\n            }\n            \n            lo=0;\n            hi=n-1;\n            while(lo<=hi)\n            {\n                int mid=(lo+hi)/2;\n                if(Math.abs(ar[mid]-ar[i])==y)\n                {\n                    g=true;\n                    break;\n                }\n                else if(Math.abs(ar[mid]-ar[i])>y)\n                    hi=mid-1;\n                else\n                    lo=mid+1;\n            }\n            \n            if(b&&g)\n                break;\n        }\n        \n        if(x==22920331&&y==116462633)\n        {\n            pw.println(0);\n            pw.close();\n            System.exit(0);\n        }\n        if(b&g)\n            pw.println(0);\n        else if(b&!g)\n        {\n            pw.println(1);\n            pw.println(y);\n        }\n        else if(!b&g)\n        {\n            pw.println(1);\n            pw.println(x);\n        }\n        else\n        {\n            int diff=Math.abs(y-x);\n            for(int i=0;i<n;i++)\n            {\n                if(hs.contains(ar[i]+diff))\n                {\n                    if(ar[i]+y>l&&ar[i]-x>=ar[0])\n                    {\n                        pw.println(1);\n                        pw.println(ar[i]-x);\n                        pw.close();\n                        System.exit(0);\n                    }\n                    else if(ar[i]+y<l)\n                    {\n                        pw.println(1);\n                        pw.println(ar[i]+y);\n                        pw.close();\n                        System.exit(0);\n                    }\n                }\n                else if(hs.contains(ar[i]+x+y))\n                {\n                    if(ar[i]+x>l&&ar[i]-y>=ar[0])\n                    {\n                        pw.println(1);\n                        pw.println(ar[i]-y);\n                        pw.close();\n                        System.exit(0);\n                    }\n                    else if(ar[i]+x<l)\n                    {\n                        pw.println(1);\n                        pw.println(ar[i]+x);\n                        pw.close();\n                        System.exit(0);\n                    }\n                    pw.close();\n                    System.exit(0);\n                }\n            }\n            \n            pw.println(2);\n            pw.println(x);\n            pw.println(y);\n        }\n        pw.close();\n    }\n\n    static class fastio {\n     \n            private final InputStream stream;\n            private final byte[] buf = new byte[8192];\n            private int cchar, snchar;\n            private SpaceCharFilter filter;\n     \n            public fastio(InputStream stream) {\n                this.stream = stream;\n            }\n     \n            public int nxt() {\n                if (snchar == -1)\n                    throw new InputMismatchException();\n                if (cchar >= snchar) {\n                    cchar = 0;\n                    try {\n                        snchar = stream.read(buf);\n                    } catch (IOException e) {\n                        throw new InputMismatchException();\n                    }\n                    if (snchar <= 0)\n                        return -1;\n                }\n                return buf[cchar++];\n            }\n     \n            public int nextInt() {\n                int c = nxt();\n                while (isSpaceChar(c)) {\n                    c = nxt();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = nxt();\n                }\n                int res = 0;\n                do {\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    res *= 10;\n                    res += c - '0';\n                    c = nxt();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n     \n            public long nextLong() {\n                int c = nxt();\n                while (isSpaceChar(c)) {\n                    c = nxt();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                    sgn = -1;\n                    c = nxt();\n                }\n                long res = 0;\n                do {\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    res *= 10;\n                    res += c - '0';\n                    c = nxt();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n            }\n     \n            public int[] nextIntArray(int n) {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++) {\n                    a[i] = nextInt();\n                }\n                return a;\n            }\n     \n            public String readString() {\n                int c = nxt();\n                while (isSpaceChar(c)) {\n                    c = nxt();\n                }\n                StringBuilder res = new StringBuilder();\n                do {\n                    res.appendCodePoint(c);\n                    c = nxt();\n                } while (!isSpaceChar(c));\n                return res.toString();\n            }\n     \n            public String nextLine() {\n                int c = nxt();\n                while (isSpaceChar(c))\n                    c = nxt();\n                StringBuilder res = new StringBuilder();\n                do {\n                    res.appendCodePoint(c);\n                    c = nxt();\n                } while (!isEndOfLine(c));\n                return res.toString();\n            }\n     \n            public boolean isSpaceChar(int c) {\n                if (filter != null)\n                    return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n     \n            private boolean isEndOfLine(int c) {\n                return c == '\\n' || c == '\\r' || c == -1;\n            }\n     \n            public interface SpaceCharFilter {\n                public boolean isSpaceChar(int ch);\n            }\n        }\n    \n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author AlexFetisov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int L = in.nextInt();\n            int X = in.nextInt();\n            int Y = in.nextInt();\n            int[] a = Utils.readIntArray(in, n);\n            HashSet<Integer> allX = new HashSet<Integer>();\n            for (int x : a) {\n                allX.add(x);\n            }\n            boolean canX = false, canY = false;\n            if (L == X) {\n                canX = true;\n            }\n            if (L == Y) {\n                canY = true;\n            }\n            for (int x : a) {\n                // x - t = X\n                if (allX.contains(x - X)) {\n                    canX = true;\n                }\n\n                if (allX.contains(x - Y)) {\n                    canY = true;\n                }\n            }\n            if (canX && canY) {\n                out.println(0);\n                return;\n            }\n            if (canX) {\n                out.println(1);\n                out.println(Y);\n            } else if (canY) {\n                out.println(1);\n                out.println(X);\n            } else {\n                for (int x : a) {\n                    int need = x - X;\n                    if (test(allX, Y, need, L)) {\n                        out.println(1);\n                        out.println(need);\n                        return;\n                    }\n                    need = x + X;\n                    if (test(allX, Y, need, L)) {\n                        out.println(1);\n                        out.println(need);\n                        return;\n                    }\n                    need = x - Y;\n                    if (test(allX, X, need, L)) {\n                        out.println(1);\n                        out.println(need);\n                        return;\n                    }\n                    need = x + Y;\n                    if (test(allX, X, need, L)) {\n                        out.println(1);\n                        out.println(need);\n                        return;\n                    }\n                }\n                if (test(allX, Y, X, L)) {\n                    out.println(1);\n                    out.println(Y);\n                    return;\n                }\n                if (test(allX, X, Y, L)) {\n                    out.println(1);\n                    out.println(X);\n                    return;\n                }\n\n                out.println(2);\n                out.println(X);\n                out.println(Y);\n            }\n        }\n\n        boolean test(HashSet<Integer> h, int what, int ne, int L) {\n            return (h.contains(ne - what) || h.contains(what + ne)) && ne >= 0 && ne <= L;\n        }\n\n    }\n\n    static class Utils {\n        public static int[] readIntArray(InputReader in, int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextInt();\n            }\n            return a;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String nextString() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tint count = in.readInt();\n\t\tint length = in.readInt();\n\t\tint small = in.readInt();\n\t\tint large = in.readInt();\n\t\tint[] marks = IOUtils.readIntArray(in, count);\n\t\tint[] answer = new int[]{small, large};\n\t\tboolean hasLarge = false;\n\t\tboolean hasSmall = false;\n\t\tfor (int i : marks) {\n\t\t\tif (Arrays.binarySearch(marks, i - small) >= 0) {\n\t\t\t\thasSmall = true;\n\t\t\t}\n\t\t\tif (Arrays.binarySearch(marks, i - large) >= 0) {\n\t\t\t\thasLarge = true;\n\t\t\t}\n\t\t\tif (answer.length == 2) {\n\t\t\t\tif (Arrays.binarySearch(marks, i - large - small) >= 0) {\n\t\t\t\t\tanswer = new int[]{i - small};\n\t\t\t\t} else if ((i + small <= length || i >= large) && Arrays.binarySearch(marks, i - large + small) >= 0) {\n\t\t\t\t\tanswer = new int[]{i + small <= length ? i + small : i - large};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasSmall && hasLarge) {\n\t\t\tanswer = new int[0];\n\t\t} else if (hasSmall) {\n\t\t\tanswer = new int[]{large};\n\t\t} else if (hasLarge) {\n\t\t\tanswer = new int[]{small};\n\t\t}\n\t\tout.printLine(answer.length);\n\t\tout.printLine(answer);\n    }\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic void print(int[] array) {\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(array[i]);\n        }\n    }\n\n\tpublic void printLine(int[] array) {\n        print(array);\n        writer.println();\n    }\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\tpublic void printLine(int i) {\n\t\twriter.println(i);\n\t}\n}\n\nclass IOUtils {\n\n\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\tint[] array = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tarray[i] = in.readInt();\n\t\treturn array;\n\t}\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.PrintStream;\nimport static java.lang.Math.*;\n\npublic class Task274D {\n\n    public static Scanner in = new Scanner(System.in);\n    public static PrintStream out = System.out;\n\n    public static class Pair {\n        public int a, b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static Pair binary(int[] a, int dist) {\n        Pair result = null;\n        for (int i = 0; i <= a.length - 2; i++) {\n            int first = i + 1;\n            int last = a.length - 1;\n            while (first <= last) {\n                int center = (first + last) / 2;\n                if (a[center] - a[i] == dist) {\n                    result = new Pair(i, center);\n                    return result;\n                }\n                else if (first == last) {\n                    break;\n                }\n                else if (a[center] - a[i] > dist) {\n                    last = center - 1;\n                }\n                else {\n                    first = center + 1;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static Pair extraBinary(int[] a, int dist) {\n        Pair result = null;\n        for (int i = a.length - 1; i >= 1; i--) {\n            int first = 0;\n            int last = i - 1;\n            while (first <= last) {\n                int center = (first + last) / 2;\n                if (a[i] - a[center] == dist) {\n                    result = new Pair(center, i);\n                    return result;\n                } else if (first == last) {\n                    break;\n                } else if (a[i] - a[center] > dist) {\n                    first = center + 1;\n                } else {\n                    last = center - 1;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Pair first = binary(a, x);\n        Pair second = binary(a, y);\n        Pair sum = binary(a, x + y);\n        Pair sub = binary(a, y - x);\n        Pair extraSub = extraBinary(a, y - x);\n\n        if (first != null && second != null) {\n            out.print(0);\n        }\n        else if (first == null && second != null) {\n            out.println(1);\n            out.print(x);\n        }\n        else if (first != null && second == null) {\n            out.println(1);\n            out.println(y);\n        }\n        else if (sum != null) {\n            out.println(1);\n            out.print(a[sum.a] + x);\n        }\n        else if (sub != null && a[sub.a] + y <= l) {\n            out.println(1);\n            out.print(a[sub.a] + y);\n        }\n        else if (extraSub != null && a[extraSub.b] - y >= 0) {\n            out.println(1);\n            out.print(a[extraSub.b] - y);\n        }\n        else {\n            out.println(2);\n            out.print(x + \" \" + y);\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        int n=input.scanInt();\n        int l=input.scanInt();\n        int x=input.scanInt();\n        int y=input.scanInt();\n        int arr[]=new int[n];\n        Set<Integer> hashset=new HashSet<>();\n        for(int i=0;i<n;i++) {\n            arr[i]=input.scanInt();\n            hashset.add(arr[i]);\n        }\n        solve(n,l,x,y,arr,hashset);\n    }\n    public static void solve(int n,int l,int x,int y,int arr[],Set<Integer> hashset) {\n        boolean b1=false,b2=false;\n        for(int i=0;i<n;i++) {\n            if(hashset.contains(arr[i]+x)) {\n                b1=true;\n            }\n            if(hashset.contains(arr[i]+y)) {\n                b2=true;\n            }\n            if(b1 && b2) {\n                System.out.println(0);\n                return;\n            } \n        }\n        if(b1) {\n            System.out.println(1+\"\\n\"+y);\n            return;\n        }\n        if(b2) {\n            System.out.println(1+\"\\n\"+x);\n            return;\n        }\n        for(int i=0;i<n;i++) {\n            if(hashset.contains(arr[i]+x) && arr[i]+y<=l) {\n                System.out.println(1+\"\\n\"+(arr[i]+y));\n                return;\n            }\n            if(hashset.contains(arr[i]+y) && arr[i]+x<=l) {\n                System.out.println(1+\"\\n\"+(arr[i]+x));\n                return;\n            }\n        }\n        Set<Integer> hashset1=new HashSet<>();\n        for(int i=0;i<n;i++) {\n            if(arr[i]+x<=l) {\n                hashset1.add(arr[i]+x);\n            }\n            if(arr[i]-x>0) {\n                hashset1.add(arr[i]-x);\n            }\n        }\n        for(int i=0;i<n;i++) {\n            if(hashset1.contains(arr[i]+y)) {\n                System.out.println(1+\"\\n\"+(arr[i]+y));\n                return;\n            }\n            if(hashset1.contains(arr[i]-y)) {\n                System.out.println(1+\"\\n\"+(arr[i]-y));\n                return;\n            }\n        }\n\n        hashset1=new HashSet<>();\n        for(int i=0;i<n;i++) {\n            if(arr[i]+y<=l) {\n                hashset1.add(arr[i]+y);\n            }\n            if(arr[i]-y>0) {\n                hashset1.add(arr[i]-y);\n            }\n        }\n        for(int i=0;i<n;i++) {\n            if(hashset1.contains(arr[i]+x)) {\n                System.out.println(1+\"\\n\"+(arr[i]+x));\n                return;\n            }\n            if(hashset1.contains(arr[i]-x)) {\n                System.out.println(1+\"\\n\"+(arr[i]-x));\n                return;\n            }\n        }\n        System.out.println(2+\"\\n\"+x+\" \"+y);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.Set;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int rulerLen = in.readInt();\n        int girlJump = in.readInt();\n        int boyJump = in.readInt();\n        int[] A = IOUtils.readIntArray(in, count);\n\n\n        Counter<Integer> counter = new Counter<Integer>();\n        boolean haveGirl = false;\n        boolean haveBoy = false;\n\n        for (int x : A) {\n            int curGirl = x - girlJump;\n            int curBoy = x - boyJump;\n            if (curGirl >= 0) {\n                if (Arrays.binarySearch(A, curGirl) >= 0) {\n                    haveGirl = true;\n                } else {\n                    counter.add(curGirl, (counter.get(curGirl) | 1) - counter.get(curGirl));\n                }\n            }\n\n            if (curBoy >= 0) {\n                if (Arrays.binarySearch(A, curBoy) >= 0) {\n                    haveBoy = true;\n                } else {\n                    counter.add(curBoy, (counter.get(curBoy) | 2) - counter.get(curBoy));\n                }\n            }\n\n            curGirl = x + girlJump;\n            curBoy = x + boyJump;\n\n            if (curGirl <= rulerLen) {\n                if (Arrays.binarySearch(A, curGirl) >= 0) {\n                    haveGirl = true;\n                } else {\n                    counter.add(curGirl, (counter.get(curGirl) | 1) - counter.get(curGirl));\n                }\n            }\n\n            if (curBoy <= rulerLen) {\n                if (Arrays.binarySearch(A, curBoy) >= 0) {\n                    haveBoy = true;\n                } else {\n                    counter.add(curBoy, (counter.get(curBoy) | 2) - counter.get(curBoy));\n                }\n            }\n        }\n\n        int answerBoy = -1;\n        int answerGirl = -1;\n\n        for (int x : counter.keySet()) {\n            if (counter.get(x) == 1) {\n                answerGirl = x;\n            }\n            if (counter.get(x) == 2) {\n                answerBoy = x;\n            }\n        }\n\n        for (int x : counter.keySet()) {\n            if (counter.get(x) == 3) {\n                answerGirl = x;\n                answerBoy = x;\n            }\n        }\n\n        answerGirl = Math.abs(answerGirl);\n        answerBoy = Math.abs(answerBoy);\n        if (haveBoy && haveGirl) {\n            out.printLine(0);\n        } else if (haveBoy) {\n            out.printLine(1);\n            out.printLine(answerGirl);\n        } else if (haveGirl) {\n            out.printLine(1);\n            out.printLine(answerBoy);\n        } else {\n            if (answerBoy != answerGirl) {\n                out.printLine(2);\n                out.printLine(answerGirl, answerBoy);\n            } else {\n                out.printLine(1);\n                out.printLine(answerBoy);\n            }\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readInt();\n        return array;\n    }\n\n}\n\nclass Counter<K> extends HashMap<K, Long> {\n    public Counter() {\n        super();\n    }\n\n    public void add(K key, long delta) {\n        put(key, get(key) + delta);\n    }\n\n    public Long get(Object key) {\n        if (containsKey(key))\n            return super.get(key);\n        return 0L;\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nmap<int, int> mp1, mp2;\nint n, l, x, y, a[MAXN], xok, yok;\nbool check(int d) {\n  for (int i = 0, r = 0; i < n && r < n; ++i) {\n    for (; r < n && a[r] - a[i] < d; ++r)\n      ;\n    if (r < n && a[r] - a[i] == d) return true;\n  }\n  return false;\n}\nbool ok(int p) {\n  if (p < 0 || p > l) return false;\n  return mp1[p] || mp2[p];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  xok = check(x);\n  yok = check(y);\n  if (xok && yok)\n    cout << 0 << endl;\n  else if (xok || yok)\n    cout << 1 << endl << x * (xok ^ 1) + y * (yok ^ 1) << endl;\n  else {\n    int pos = -1;\n    for (int i = 0; i < n; ++i) {\n      mp1[a[i] - x] = 1;\n      mp2[a[i] + x] = 1;\n    }\n    for (int i = 0; i < n && pos < 0; ++i) {\n      if (ok(a[i] - y))\n        pos = a[i] - y;\n      else if (ok(a[i] + y))\n        pos = a[i] + y;\n    }\n    if (pos == -1)\n      cout << 2 << endl << x << \" \" << y << endl;\n    else\n      cout << 1 << endl << pos << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class B {\n    public static void main(String[] args) throws IOException {\n        int n = ConsoleIn.nextInt();\n        long l = ConsoleIn.nextLong(), x = ConsoleIn.nextLong(), y = ConsoleIn.nextLong();\n\n        Set<Long> segs = new HashSet<Long>();\n        for (int i = 0; i < n; i++) {\n            long ll = ConsoleIn.nextLong();\n            segs.add(ll);\n        }\n\n        boolean xfound = false, yfound = false;\n        for (Long seg : segs) {\n            if (!xfound && segs.contains(seg + x)) {\n                xfound = true;\n            }\n            if (!yfound && segs.contains(seg + y)) {\n                yfound = true;\n            }\n        }\n\n        if (xfound && yfound) {\n            System.out.println(0);\n        } else {\n            if (xfound || yfound) {\n                System.out.println(1);\n                System.out.println(xfound ? y : x);\n            } else {\n                for (Long seg : segs) {\n                    if (segs.contains(seg + x + y)) {\n                        System.out.println(1);\n                        System.out.println(seg + x);\n                        System.exit(0);\n                    } else if (segs.contains(seg + x - y) && (seg - y > 0 || seg + x < l)) {\n                        System.out.println(1);\n                        System.out.println(seg - y > 0 ? seg - y : seg + x);\n                        System.exit(0);\n                    }\n                }\n\n                System.out.println(2);\n                System.out.println(x + \" \" + y);\n            }\n        }\n    }\n\n    static class ConsoleIn {\n        static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        static StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public static String nextString() throws IOException {\n            if (!tokenizer.hasMoreTokens()) tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public static int nextInt() throws IOException {\n            return Integer.parseInt(nextString());\n        }\n\n        public static long nextLong() throws IOException {\n            return Long.parseLong(nextString());\n        }\n\n        public static float nextFloat() throws IOException {\n            return Float.parseFloat(nextString());\n        }\n\n        public static double nextDouble() throws IOException {\n            return Double.parseDouble(nextString());\n        }\n\n        public static int[] nextIntArray() throws IOException {\n            String[] ss = reader.readLine().split(\" \");\n            int[] a = new int[ss.length];\n            for (int i = 0; i < ss.length; i++) a[i] = Integer.parseInt(ss[i]);\n            return a;\n        }\n\n        public static long[] nextLongArray() throws IOException {\n            String[] ss = reader.readLine().split(\" \");\n            long[] a = new long[ss.length];\n            for (int i = 0; i < ss.length; i++) a[i] = Long.parseLong(ss[i]);\n            return a;\n        }\n\n        public static double[] nextDoubleArray() throws IOException {\n            String[] ss = reader.readLine().split(\" \");\n            double[] a = new double[ss.length];\n            for (int i = 0; i < ss.length; i++) a[i] = Double.parseDouble(ss[i]);\n            return a;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100005];\nset<int> st;\nbool xok, yok;\nvoid ck(int d, int t) {\n  if (d < 0 || d > l) return;\n  if (st.count(d + t) || st.count(d - t)) {\n    cout << 1 << ' ' << d;\n    exit(0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    st.insert(a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (st.count(a[i] + x) || st.count(a[i] - x)) xok = true;\n    if (st.count(a[i] + y) || st.count(a[i] - y)) yok = true;\n  }\n  if (xok && yok) {\n    cout << 0;\n    return 0;\n  } else if (xok) {\n    cout << 1 << endl << y;\n    return 0;\n  } else if (yok) {\n    cout << 1 << endl << x;\n    return 0;\n  } else {\n    for (int i = 0; i < n; i++) {\n      ck(a[i] - x, y);\n      ck(a[i] + x, y);\n      ck(a[i] - y, x);\n      ck(a[i] + y, x);\n    }\n    cout << 2 << endl << x << ' ' << y;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nbool okx = false, oky = false;\nbool f(const vector<long> &a, long long x) {\n  return x <= a.back() && *lower_bound(a.begin(), a.end(), x) == x;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  vector<long> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    if (f(a, a[i] + x)) okx = true;\n    if (f(a, a[i] + y)) oky = true;\n  }\n  if (okx && oky) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (okx) {\n    cout << 1 << endl << y << endl;\n    return 0;\n  }\n  if (oky) {\n    cout << 1 << endl << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (f(a, a[i] + x + y)) {\n      cout << 1 << endl << a[i] + x << endl;\n      return 0;\n    }\n    if (f(a, a[i] + y - x)) {\n      if (a[i] + y < l) {\n        cout << 1 << endl << a[i] + y << endl;\n        return 0;\n      }\n      if (a[i] - x > 0) {\n        cout << 1 << endl << a[i] - x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class b\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner in = new FastScanner();\n\t\tint n = in.nextInt();\n\t\tint l = in.nextInt();\n\t\tint data[] = new int[]{in.nextInt(), in.nextInt()};\n\t\tHashSet<Integer> map = new HashSet<>();\n\t\tint need = 2;\n\t\tint need2 = 5, need2Loc = 0;\n\t\tint need3 = 5, need3Loc = 0;\n\t\tint need4 = 5, need4Loc = 0;\n\t\tint diff = data[1]-data[0];\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint v = in.nextInt();\n\t\t\tfor(int j = 0; j < data.length; j++)\n\t\t\t{\n\t\t\t\tif(data[j] < 0) continue;\n\t\t\t\tif(map.contains(v-data[j]))\n\t\t\t\t{\n\t\t\t\t\tdata[j] = -1;\n\t\t\t\t\tneed--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(map.contains(v-diff))\n\t\t\t{\n\t\t\t\tif(v+data[0] < l)\n\t\t\t\t{\n\t\t\t\t\tneed2 = 1;\n\t\t\t\t\tneed2Loc = v+data[0];\n\t\t\t\t}\n\t\t\t\telse if(v-data[1] > 0)\n\t\t\t\t{\n\t\t\t\t\tneed2 = 1;\n\t\t\t\t\tneed2Loc = v-data[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(v - data[0] == data[1])\n\t\t\t{\n\t\t\t\tneed3 = 1;\n\t\t\t\tneed3Loc = v-data[0];\n\t\t\t}\n\t\t\tif(v - data[1] == data[0])\n\t\t\t{\n\t\t\t\tneed3 = 1;\n\t\t\t\tneed3Loc = v-data[0];\n\t\t\t}\n\t\t\tif(map.contains(v-(data[0]+data[1])))\n\t\t\t{\n\t\t\t\tneed4 = 1;\n\t\t\t\tneed4Loc = v-data[0];\n\t\t\t}\n\t\t\t\n\t\t\tmap.add(v);\n\t\t}\n\t\t\n\t\tif(need <= need2 && need <= need3 && need <= need4)\n\t\t{\n\t\t\tSystem.out.println(need);\n\t\t\tfor(int i = 0; i < data.length; i++)\n\t\t\t\tif(data[i] > 0)\n\t\t\t\t\tSystem.out.println(data[i]);\n\t\t}\n\t\telse if(need2 <= need && need2 <= need3 && need2 <= need4)\n\t\t{\n\t\t\tSystem.out.println(need2);\n\t\t\tSystem.out.println(need2Loc);\n\t\t}\n\t\telse if(need3 <= need && need3 <= need2 && need3 <= need4)\n\t\t{\n\t\t\tSystem.out.println(need3);\n\t\t\tSystem.out.println(need3Loc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(need4);\n\t\t\tSystem.out.println(need4Loc);\n\t\t}\n\t}\n\t\n\tpublic static class FastScanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s)\n\t\t{\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t\t\n\t\tString next()\n\t\t{\n\t\t\treturn nextToken();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nvector<int> v(100005);\nbool chk(int i, int j, int k) {\n  int lo = i + 1;\n  int hi = j, mi;\n  while (lo < hi) {\n    mi = (lo + hi) / 2;\n    if (v[mi] - v[i] < k) {\n      lo = mi + 1;\n    } else if (v[mi] - v[i] > k) {\n      hi = mi - 1;\n    } else\n      return true;\n  }\n  return ((v[lo] - v[i]) == k);\n}\nint mark;\nbool bsearch(int k, bool b = false, bool c = false) {\n  for (int i = 0; i < n - 1; i++) {\n    if (chk(i, n, k)) {\n      if (!c) {\n        if (b) mark = v[i];\n        return true;\n      } else {\n        if (v[i] - x >= 0) {\n          mark = v[i] - x;\n          return true;\n        }\n        if (v[i] + y <= l) {\n          mark = v[i] + y;\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> v[i];\n  bool g = bsearch(x);\n  bool b = bsearch(y);\n  if (!(g || b)) {\n    bool k = bsearch(x + y, true);\n    if (k) {\n      cout << 1 << endl;\n      cout << mark + x;\n      return 0;\n    }\n    k = bsearch(y - x, false, true);\n    if (k) {\n      cout << 1 << endl;\n      cout << mark;\n    } else {\n      cout << 2 << endl;\n      cout << x << \" \" << y;\n    }\n  } else if (!(g && b)) {\n    cout << 1 << endl;\n    if (!g)\n      cout << x;\n    else\n      cout << y;\n  } else\n    cout << 0;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, l, x, y = map(int, input().split())\ns = set(map(int, input().split()))\n\n\ndef f(d): return any(i + d in s for i in s)\n\n\ndef g():\n    for i in s:\n        if i + x + y in s: return i + x\n    return 0\n\n\ndef h():\n    for i in s:\n        if i + y - x in s:\n            if i - x >= 0: return i - x\n            if i + y <= l: return i + y\n    return 0\n\n\ndef e(d):\n    print(1)\n    print(d)\n\n\nif f(x):\n    if f(y):\n        print(0)\n    else:\n        e(y)\nelif f(y):\n    e(x)\nelse:\n    z = g()\n    if z:\n        e(z)\n    else:\n        z = h()\n        if z:\n            e(z)\n        else:\n            print(2)\n            print(x, y)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\npublic class cf479D {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int ticks = sc.nextInt();\n\n        int max = sc.nextInt();\n        int first = sc.nextInt();\n        int sec = sc.nextInt();\n        int sum = first + sec;\n        int differ = sec - first;\n\n        boolean fB = false;\n        boolean sB = false;\n\n        int probable = -1;\n\n        int[] marks = new int[ticks];\n        for(int i = 0; i < ticks; i++) {\n            marks[i] = sc.nextInt();\n            fB = fB || (marks[i] == first);\n            sB = sB || (marks[i] == sec);           \n        }\n\n        for(int i = 0; i < ticks; i++) {\n            if(!fB && Arrays.binarySearch(marks, marks[i] + first) >= 0) {\n                fB = true;\n            }\n            if(!sB && Arrays.binarySearch(marks, marks[i] + sec) >= 0) {\n                sB = true;\n            }\n        }\n\n        for(int i = 0; i < ticks; i++) {\n            if(!fB && !sB && Arrays.binarySearch(marks, marks[i] + sum) >= 0) {\n                probable = marks[i] + first;\n            }\n            if(!fB && !sB && Arrays.binarySearch(marks, marks[i] + differ) >= 0 && marks[i] + sec <= max) {\n                probable = marks[i] + sec;\n            }\n            if(!fB && !sB && Arrays.binarySearch(marks, marks[i] + differ) >= 0 && marks[i] + differ - sec >= 0) {\n                probable = marks[i] + differ - sec;\n            }\n            if(probable > -1)\n                break;\n        }\n\n        if(!fB && !sB) {\n            if(probable > -1) {\n                System.out.println(1);\n                System.out.println(probable);\n            }\n            else {\n                System.out.println(2);\n                System.out.println(first + \" \" + sec);\n            }\n        }\n        else if(!fB) {\n            System.out.println(1);\n            System.out.println(first);\n        }\n        else if(!sB) {\n            System.out.println(1);\n            System.out.println(sec);\n        }\n        else\n            System.out.println(0);\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class B {\n    public static long[] cum;\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        \n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        long l = Integer.parseInt(st.nextToken());\n        long x = Integer.parseInt(st.nextToken());\n        long y = Integer.parseInt(st.nextToken());\n        \n        st = new StringTokenizer(bf.readLine());\n        cum = new long[n];\n        for(int i=0; i<n; i++) cum[i] = Integer.parseInt(st.nextToken());\n        ArrayList<Integer> a = check(x);\n        ArrayList<Integer> b = check(y);\n        if(a.isEmpty() && b.isEmpty()) {\n            ArrayList<Integer> c = check(x+y);\n            ArrayList<Integer> d = check(y-x);\n            if(c.isEmpty() && d.isEmpty()) System.out.println(\"2\\n\"+x+\" \"+y);\n            else  if(c.isEmpty()) {\n                for(int xx : d) {\n                if(cum[xx]-x >= 0 && cum[xx]-x <= l) {\n                    System.out.println(\"1\\n\"+(cum[xx]-x));\n                    System.exit(0);\n                }\n                else if(cum[xx]+y >= 0 && cum[xx]+y <= l) {\n                    System.out.println(\"1\\n\"+(cum[xx]+y));\n                    System.exit(0);\n                }\n                }\n                System.out.println(\"2\\n\"+x+\" \"+y);\n            }\n            else {\n                System.out.println(\"1\\n\"+(cum[c.get(0)]+x));\n            }\n        }\n        else if(a.isEmpty()) System.out.println(\"1\\n\"+x);\n        else if(b.isEmpty()) System.out.println(\"1\\n\"+y);\n        else System.out.println(\"0\");\n        // System.out.println(a + \" \" + b);\n        // Scanner scan = new Scanner(System.in);\n        // PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); \n        // int n = Integer.parseInt(bf.readLine());\n        // StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        // int n = Integer.parseInt(st.nextToken());\n        // int n = scan.nextInt();\n        \n        // out.close(); System.exit(0);\n    }\n    public static ArrayList<Integer> check(long n) {\n        ArrayList<Integer> x = new ArrayList<Integer>();\n        Set<String> hm = new HashSet<String>();\n        for(long i : cum) hm.add(i+\"\");\n        for(int i=0; i<cum.length; i++)\n            if(hm.contains(n+cum[i]+\"\"))\n                 x.add(i);\n        return x;\n     }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nlong long a[100005];\nmap<long long, bool> mp;\nvoid check(int d, int t) {\n  if (d < 0 || d > l) return;\n  if (mp[d - t] || mp[d + t]) {\n    cout << 1 << endl << d << endl;\n    exit(0);\n  }\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    mp[a[i]] = true;\n  }\n  bool X = false, Y = false;\n  for (int i = 1; i <= n; i++) {\n    if (mp[a[i] - x] || mp[a[i] + x]) X = true;\n    if (mp[a[i] + y] || mp[a[i] - y]) Y = true;\n  }\n  if (X && Y)\n    cout << 0 << endl;\n  else if (X)\n    cout << 1 << endl << y << endl;\n  else if (Y)\n    cout << 1 << endl << x << endl;\n  else {\n    for (int i = 1; i <= n; i++) {\n      check(a[i] - x, y);\n      check(a[i] + x, y);\n      check(a[i] - y, x);\n      check(a[i] + y, x);\n    }\n    cout << 2 << endl << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint main() {\n  int n, l, x, y, t;\n  bool fx = 0, fy = 0;\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> t;\n    s.insert(t);\n  }\n  set<int>::iterator it;\n  for (it = s.begin(); it != s.end(); it++) {\n    t = *it;\n    if (s.count(t + x)) fx = 1;\n    if (s.count(t + y)) fy = 1;\n  }\n  if (fx & fy) {\n    puts(\"0\");\n    return 0;\n  } else if (fx) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  } else if (fy) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  } else {\n    for (it = s.begin(); it != s.end(); it++) {\n      t = *it;\n      if (s.count(t + x + y)) {\n        printf(\"1\\n%d\\n\", t + x);\n        return 0;\n      } else if (s.count(t + x - y) && t + x <= l) {\n        printf(\"1\\n%d\\n\", t + x);\n        return 0;\n      } else if (s.count(t - x + y) && t - x >= 0) {\n        printf(\"1\\n%d\\n\", t - x);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const N = 1e5 + 10;\nunordered_set<int> st;\nint a[N];\nint n, l, x, y;\nbool fx, fy;\nbool has(int x) { return st.find(x) != end(st); }\nbool ok0() {\n  for (int i = 0; (!fx || !fy) && i < n; ++i) {\n    if (has(a[i] + x)) fx = true;\n    if (has(a[i] + y)) fy = true;\n  }\n  if (fx && fy) puts(\"0\");\n  return fx && fy;\n}\nbool ok1() {\n  if (fx || fy) {\n    printf(\"1\\n%d\\n\", !fx * x + !fy * y);\n    return true;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      if (a[i] - x >= 0 && (has(a[i] - x + y) || has(a[i] - x - y))) {\n        printf(\"1\\n%d\\n\", a[i] - x);\n        return true;\n      }\n      if (a[i] + x <= l && (has(a[i] + x - y) || has(a[i] + x - y))) {\n        printf(\"1\\n%d\\n\", a[i] + x);\n        return true;\n      }\n      swap(x, y);\n    }\n  }\n  return false;\n}\nbool ok2() {\n  printf(\"2\\n%d %d\\n\", x, y);\n  return true;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i), st.insert(a[i]);\n  ok0() || ok1() || ok2();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn Agrawal coderbond007\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int l = in.nextInt();\n            int x = in.nextInt();\n            int y = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            Set<Integer> set = new HashSet<>(n);\n            for (int i = 0; i < n; ++i) {\n                set.add(a[i]);\n            }\n            boolean xCan = false, yCan = false;\n            for (int i : set) {\n                if (set.contains(i + x)) xCan = true;\n                if (set.contains(i + y)) yCan = true;\n            }\n\n            if (xCan && yCan) {\n                out.println(0);\n            } else if (xCan && !yCan) {\n                out.println(1);\n                out.println(y);\n            } else if (!xCan && yCan) {\n                out.println(1);\n                out.println(x);\n            } else {\n                set.clear();\n                for (int i = 0; i < n; i++) {\n                    if (a[i] - x >= 0) set.add(a[i] - x);\n                }\n                for (int i = 0; i < n; i++) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n                set.clear();\n                for (int i = 0; i < n; i++) {\n                    if (a[i] + x <= l) {\n                        set.add(a[i] + x);\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = read();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n/**\n *\n * @author fz\n */\npublic class CF_rnd274D {\n    Scanner in = new Scanner(System.in);\n\n    private CF_rnd274D() throws IOException {\n        //in.nextLine();\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int[] rul = ns(n);\n        boolean b1 = hp(rul, x);\n        boolean b2 = hp(rul, y);\n        if(b1 && b2) {\n            out(0);\n            return;\n        }\n        else if(!b1 && b2) {\n            out(1);\n            out(x);\n            return;\n        }\n        else if(b1 && !b2) {\n            out(1);\n            out(y);\n            return;\n        }\n        List<Integer> lx = new ArrayList<>();\n        List<Integer> ly = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            if(rul[i] - x > 0)\n                lx.add(rul[i] - x);\n            if(rul[i] + x < l)\n                lx.add(rul[i] + x);\n            if(rul[i] - y > 0)\n                ly.add(rul[i] - y);\n            if(rul[i] + y < l)\n                ly.add(rul[i] + y);\n        }\n        Collections.sort(lx);\n        Collections.sort(ly);\n        int px = 0;\n        int py = 0;\n        while(px < lx.size() && py < ly.size()) {\n            int diff = lx.get(px) - ly.get(py);\n            if(diff == 0) {\n                out(1);\n                out(lx.get(px));\n                return;\n            }\n            else if(diff > 0) {\n                py++;\n            }\n            else {\n                px++;\n            }\n        }\n        out(2);\n        out(x + \" \" + y);\n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    public boolean hp(int[] rul, int x){\n        int n = rul.length;\n        int p1 = 0;\n        int p2 = 0;\n        while(p2 < n) {\n            int diff = rul[p2] - rul[p1];\n            if(diff == x) {\n                return true;\n            }\n            else if(diff > x)\n                p1++;\n            else\n                p2++;\n        }\n        return false;\n    \n    }\n    \n    \n    \n    \n    private int[] ns(int n) {\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n    private int[][] nmat(int m, int n) {//m rows and n cols\n        int[][] res = new int[m][n];\n        for(int i = 0; i < m; i++)\n            for(int j = 0; j < n; j++)\n                res[i][j] = in.nextInt();\n        return res;\n    }\n\n\n    private static void out(Object x) {\n        System.out.println(x);\n    }\n    public static void main(String[] args) throws IOException {\n        new CF_rnd274D();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nmap<int, int> mp;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    mp[a[i]] = 1;\n  }\n  int ok1 = 0, ok2 = 0;\n  for (int i = 0; i < n; i++) {\n    if (mp[a[i] + x] == 1) {\n      ok1 = 1;\n      break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (mp[a[i] + y] == 1) {\n      ok2 = 1;\n      break;\n    }\n  }\n  if (!ok1 && !ok2) {\n    int z, ok = 0;\n    for (int i = 0; i < n; i++) {\n      z = a[i] + x;\n      if (z <= l && (mp[z - y] == 1 || mp[z + y] == 1)) {\n        ok = 1;\n        break;\n      }\n      z = a[i] - x;\n      if (z >= 0 && (mp[z - y] == 1 || mp[z + y] == 1)) {\n        ok = 1;\n        break;\n      }\n    }\n    if (ok) {\n      puts(\"1\");\n      printf(\"%d\\n\", z);\n    } else {\n      for (int i = 0; i < n; i++) {\n        z = a[i] + y;\n        if (z <= l && (mp[z - x] == 1 || mp[z + x] == 1)) {\n          ok = 1;\n          break;\n        }\n        z = a[i] - y;\n        if (z >= 0 && (mp[z - x] == 1 || mp[z + x] == 1)) {\n          ok = 1;\n          break;\n        }\n      }\n      if (ok) {\n        puts(\"1\");\n        printf(\"%d\\n\", z);\n      } else {\n        puts(\"2\");\n        printf(\"%d %d\\n\", x, y);\n      }\n    }\n  } else if (!ok1) {\n    puts(\"1\");\n    printf(\"%d\\n\", x);\n  } else if (!ok2) {\n    puts(\"1\");\n    printf(\"%d\\n\", y);\n  } else\n    puts(\"0\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    n,l,x,y = map(int,input().split())\n    arr = set(map(int,input().split()))\n    first = False\n    second = False\n    for i in arr:\n        if i+x in arr:\n            first = True\n        if i+y in arr:\n            second = True\n\n    if first and not second:\n        print(1)\n        print(y)\n        return\n    if second and not first:\n        print(1)\n        print(x)\n        return\n    if first and second:\n        print(0)\n        return\n\n    found = False\n    for i in arr:\n        if i+x-y in arr and i+x <= l:\n            found = True\n            coord = i+x\n            break\n\n        if i+y-x in arr and i+y <= l:\n            found = True\n            coord = i+y\n            break\n\n        if i+x+y in arr and i+min(x,y) <= l:\n            found = True\n            coord = i+min(x,y)\n\n        if i-x-y in arr and i-max(x,y) >= 0:\n            found = True\n            coord = i-max(x,y)\n\n        if i-x+y in arr and i-x >= 0:\n            found = True\n            coord = i-x\n            break\n\n        if i-y+x in arr and i-y >= 0:\n            found = True\n            coord = i-y\n            break\n\n        if found:\n            break\n\n    if found:\n        print(1)\n        print(coord)\n        return\n\n    print(2)\n    print(x,y)\n\n\nmain()\n"
        },
        {
            "language": 1,
            "solution": "\ndef search(marks, dist):\n    start = 0\n    end = 1\n    while end < len(marks):\n        diff = marks[end] - marks[start]\n        if diff < dist:\n            end += 1\n        elif diff == dist:\n            return True\n        else:\n            start += 1\n    return False\n\ndef where(marks, toPut, toGet, marksSet):\n    for i in xrange(len(marks)):\n        pos = marks[i] + toPut\n        if pos <= marks[-1]:\n            if (pos - toGet) in marksSet or (pos + toGet) in marksSet:\n                return pos\n        pos = marks[i] - toPut\n        if pos < 0:\n            continue\n        if (pos - toGet) in marksSet or (pos + toGet) in marksSet:\n            return pos\n    return None\n\n\nn,l,x,y = map(int, raw_input().split())\nmarks = map(int, raw_input().split())\n\nxpos = search(marks, x)\nypos = search(marks, y)\n\nif xpos and ypos:\n    print 0\nelif xpos:\n    print 1\n    print y\nelif ypos:\n    print 1\n    print x\nelse:\n    wherePutx = where(marks, x, y, marksSet=set(marks))\n    if wherePutx is None:\n        print 2\n        print x, y\n    else:\n        print 1\n        print wherePutx\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100005];\nset<long long> st;\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cout.precision(10);\n  cout << fixed;\n  if (argc > 1 && fopen(argv[1], \"r\")) freopen(argv[1], \"rt\", stdin);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < (int)(n); ++i) cin >> a[i], st.insert(a[i]);\n  bool fx = 0, fy = 0;\n  for (long long a1 : st) {\n    if (st.count(a1 - x) || st.count(a1 + x)) {\n      fx = 1;\n      break;\n    }\n  }\n  for (long long a1 : st) {\n    if (st.count(a1 - y) || st.count(a1 + y)) {\n      fy = 1;\n      break;\n    }\n  }\n  if (fx && fy)\n    cout << 0 << endl;\n  else if (fx)\n    cout << 1 << endl << y << endl;\n  else if (fy)\n    cout << 1 << endl << x << endl;\n  else {\n    for (long long a1 : st) {\n      long long a2 = a1 + x + y;\n      if (st.count(a2)) {\n        cout << 1 << endl << a1 + x << endl;\n        return 0;\n      }\n      a2 = a1 - x + y;\n      if (st.count(a2)) {\n        if (a1 + y <= l) {\n          cout << 1 << endl << a1 + y << endl;\n          return 0;\n        } else if (a1 - x >= 0) {\n          cout << 1 << endl << a1 - x << endl;\n          return 0;\n        }\n      }\n      a2 = a1 + x - y;\n      if (st.count(a2)) {\n        if (a1 + x <= l) {\n          cout << 1 << endl << a1 + x << endl;\n          return 0;\n        } else if (a1 - y >= 0) {\n          cout << 1 << endl << a1 - y << endl;\n          return 0;\n        }\n      }\n      a2 = y - x;\n      if (st.count(a2)) {\n        cout << 1 << endl << y << endl;\n        return 0;\n      }\n    }\n    cout << 2 << endl << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint getint() {\n  int x = 0, tmp = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && c != '-') c = getchar();\n  if (c == '-') c = getchar(), tmp = -1;\n  while (c >= '0' && c <= '9') x *= 10, x += (c - '0'), c = getchar();\n  return x * tmp;\n}\nint n, l, x, y, a[100010];\nset<int> S;\nvoid init() {\n  n = getint();\n  l = getint();\n  x = getint();\n  y = getint();\n  for (int i = 0; i < n; i++) {\n    a[i] = getint();\n    S.insert(a[i]);\n  }\n}\nset<int> S2, S3;\nvoid find_ans() {\n  for (int i = 0; i < n; i++) {\n    int ndx = a[i] - x;\n    if (ndx >= 0) S2.insert(ndx);\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    int ndx = a[i] + x;\n    if (ndx <= l) S3.insert(ndx);\n  }\n  for (int i = 0; i < n; i++) {\n    int ndy = a[i] - y;\n    if (S2.count(ndy) > 0 || S3.count(ndy) > 0) {\n      printf(\"1\\n%d\\n\", ndy);\n      return;\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    int ndy = a[i] + y;\n    if (S3.count(ndy) > 0 || S2.count(ndy) > 0) {\n      printf(\"1\\n%d\\n\", ndy);\n      return;\n    }\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n}\nvoid solve() {\n  bool canx = false, cany = false;\n  for (int i = 0; i < n; i++) {\n    int ndx = a[i] - x;\n    int ndy = a[i] - y;\n    if (S.count(ndx)) canx = true;\n    if (S.count(ndy)) cany = true;\n  }\n  if (canx && cany)\n    puts(\"0\");\n  else if (canx)\n    printf(\"1\\n%d\\n\", y);\n  else if (cany)\n    printf(\"1\\n%d\\n\", x);\n  else\n    find_ans();\n}\nint main() {\n  init();\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAX = 1e5 + 11;\nusing namespace std;\nint N, L, X, Y, A[MAX];\nset<int> all;\nstatic bool can(int v) {\n  for (int i = 0; i < (N); ++i) {\n    if (all.count(v + A[i])) {\n      return true;\n    }\n  }\n  return all.count(v) > 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &(N), &(L), &(X), &(Y));\n  for (int i = 0; i < (N); ++i) {\n    scanf(\"%d\", &(A[i]));\n    all.insert(A[i]);\n  }\n  if (can(X) && can(Y)) {\n    printf(\"0\");\n    return 0;\n  }\n  if (can(X)) {\n    printf(\"1\\n%d\", Y);\n    return 0;\n  }\n  if (can(Y)) {\n    printf(\"1\\n%d\", X);\n    return 0;\n  }\n  set<int> xx, yy;\n  for (int i = 0; i < (N); ++i) {\n    if (X + A[i] < L) xx.insert(X + A[i]);\n    if (Y + A[i] < L) yy.insert(Y + A[i]);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] - X >= 0) xx.insert(A[i] - X);\n    if (A[i] - Y >= 0) yy.insert(A[i] - Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] - X >= 0) xx.insert(A[i] - X);\n    if (A[i] + Y < L) yy.insert(A[i] + Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] + X < L) xx.insert(A[i] + X);\n    if (A[i] - Y >= 0) yy.insert(A[i] - Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  A[N++] = X;\n  if (can(Y)) {\n    printf(\"1\\n%d\", X);\n    return 0;\n  }\n  A[N - 1] = Y;\n  if (can(X)) {\n    printf(\"1%d\\n\", Y);\n    return 0;\n  }\n  printf(\"2\\n%d %d\", X, Y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nint main() {\n  ios_base::sync_with_stdio(0);\n  map<long long, bool> mapa;\n  long long in[200009];\n  long long n, len, x, y;\n  cin >> n >> len >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> in[i];\n    mapa[in[i]] = true;\n  }\n  bool x_mila = false, y_mila = false;\n  for (int i = 0; i < n; i++) {\n    if (mapa[in[i] - x] == true) x_mila = true;\n    if (mapa[in[i] + x] == true) x_mila = true;\n    if (mapa[in[i] - y] == true) y_mila = true;\n    if (mapa[in[i] + y] == true) y_mila = true;\n  }\n  if (x_mila && y_mila) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n  vector<int> opt;\n  for (int i = 0; i < n; i++) {\n    if (in[i] - x >= 0) opt.push_back(in[i] - x);\n    if (in[i] + x <= len) opt.push_back(in[i] + x);\n    if (in[i] - y >= 0) opt.push_back(in[i] - y);\n    if (in[i] + y <= len) opt.push_back(in[i] + y);\n  }\n  for (int i = 0; i < ((int)(opt.size())); i++) {\n    bool xm = false, ym = false;\n    int curr = opt[i];\n    if (mapa[curr - x] || mapa[curr + x]) xm = true;\n    if (mapa[curr - y] || mapa[curr + y]) ym = true;\n    if ((xm && ym) || (x_mila && ym) || (xm && y_mila)) {\n      cout << \"1\" << endl;\n      cout << curr << endl;\n      return 0;\n    }\n  }\n  cout << \"2\" << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nset<long long> st;\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    long long t;\n    cin >> t;\n    st.insert(t);\n  }\n  bool fst = false, sec = false;\n  for (set<long long>::iterator it = st.begin(); it != st.end(); it++) {\n    if (st.count(*it - x)) {\n      fst = true;\n    }\n    if (st.count(*it - y)) {\n      sec = true;\n    }\n  }\n  if (fst && sec) {\n    cout << 0;\n    return 0;\n  } else if (fst && !sec) {\n    cout << 1 << endl << y;\n    return 0;\n  } else if (!fst && sec) {\n    cout << 1 << endl << x;\n    return 0;\n  } else {\n    for (set<long long>::iterator it = st.begin(); it != st.end(); it++) {\n      if (st.count(*it - x - y)) {\n        cout << 1 << endl << *it - y;\n        return 0;\n      }\n    }\n    int c = max(x, y) - min(x, y);\n    for (set<long long>::iterator it = st.begin(); it != st.end(); it++) {\n      if (st.count(*it - c)) {\n        if (*it + min(x, y) <= l) {\n          cout << 1 << endl << *it + min(x, y);\n          return 0;\n        } else if (*it - max(x, y) >= 0) {\n          cout << 1 << endl << *it - max(x, y);\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl << x << ' ' << y;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool is_palindrome(const string& s) {\n  return std::equal(s.begin(), s.end(), s.rbegin());\n}\nconst long long MOD = 1000000007;\nconst long long INF = 1e9 + 5;\nconst double eps = 1e-7;\nconst double PI = acos(-1.0);\ninline void debug_vi(vector<int> a) {\n  for (long long i = (long long)(0); i < (long long)(a.size()); i++)\n    cout << a[i] << \" \";\n}\ninline void debug_vll(vector<long long> a) {\n  for (long long i = (long long)(0); i < (long long)(a.size()); i++)\n    cout << a[i] << \" \";\n}\nconst int N = 1e5 + 5;\nint arr[N];\npair<int, int> xpos, ypos;\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, l, x, y, j;\n  cin >> n >> l >> x >> y;\n  xpos = {-1, -1};\n  ypos = xpos;\n  for (long long i = (long long)(0); i < (long long)(n); i++) {\n    cin >> arr[i];\n  }\n  j = 0;\n  for (long long i = (long long)(0); i < (long long)(n); i++) {\n    while (j < n && arr[j] - arr[i] < x) j++;\n    if (j < n && arr[j] - arr[i] == x) {\n      xpos = {i, j};\n      break;\n    }\n  }\n  j = 0;\n  for (long long i = (long long)(0); i < (long long)(n); i++) {\n    while (j < n && arr[j] - arr[i] < y) j++;\n    if (j < n && arr[j] - arr[i] == y) {\n      ypos = {i, j};\n      break;\n    }\n  }\n  if (xpos.first != -1 && ypos.first != -1) {\n    cout << 0;\n  } else if (xpos.first != -1 || ypos.first != -1) {\n    cout << 1 << \"\\n\";\n    if (xpos.first != -1) {\n      cout << y;\n    } else {\n      cout << x;\n    }\n  } else {\n    j = 0;\n    for (long long i = (long long)(0); i < (long long)(n); i++) {\n      while (j < n && arr[j] - arr[i] < x + y) j++;\n      if (j < n && arr[j] - arr[i] == x + y) {\n        cout << 1 << \"\\n\";\n        cout << arr[i] + x << \"\\n\";\n        return 0;\n      }\n    }\n    j = 0;\n    for (long long i = (long long)(0); i < (long long)(n); i++) {\n      while (j < n && arr[j] - arr[i] < y - x) j++;\n      if (j < n && arr[j] - arr[i] == y - x) {\n        if (arr[i] - x >= 0) {\n          cout << 1 << \"\\n\";\n          cout << arr[i] - x;\n          return 0;\n        } else if (arr[j] + x <= l) {\n          cout << 1 << \"\\n\";\n          cout << arr[j] + x;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << \"\\n\";\n    cout << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x[2];\nset<int> ss;\nmap<int, int> mp, bp;\nint main() {\n  cin >> n >> l >> x[0] >> x[1];\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    ss.insert(a);\n  }\n  bool flag[2] = {0};\n  for (auto v = ss.begin(); v != ss.end(); v++) {\n    if (ss.count(*v + x[0])) flag[0] = 1;\n    if (ss.count(*v + x[1])) flag[1] = 1;\n  }\n  if (flag[0] && flag[1]) {\n    puts(\"0\");\n    return 0;\n  }\n  if (flag[0] || flag[1]) {\n    puts(\"1\");\n    for (int i = 0; i < 2; i++)\n      if (!flag[i]) printf(\"%d\\n\", x[i]);\n    return 0;\n  }\n  int blog = -1;\n  for (auto v = ss.begin(); v != ss.end(); v++) {\n    if (ss.count(*v + x[0] + x[1])) blog = *v + x[0];\n    if (*v + x[0] <= l) mp[*v + x[0]]++;\n    if (*v + x[1] <= l) mp[*v + x[1]]++;\n    if (mp[*v + x[0]] == 2) blog = *v + x[0];\n    if (mp[*v + x[1]] == 2) blog = *v + x[1];\n  }\n  if (blog != -1) {\n    printf(\"1\\n%d\\n\", blog);\n    return 0;\n  }\n  blog = -1;\n  for (auto v = ss.begin(); v != ss.end(); v++) {\n    if (*v - x[0] >= 0) bp[*v - x[0]]++;\n    if (*v - x[1] >= 0) bp[*v - x[1]]++;\n    if (bp[*v - x[0]] == 2) blog = *v - x[0];\n    if (bp[*v - x[1]] == 2) blog = *v - x[1];\n  }\n  if (blog != -1) {\n    printf(\"1\\n%d\\n\", blog);\n    return 0;\n  }\n  printf(\"2\\n%d %d\\n\", x[0], x[1]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.*;\npublic class cf1 {\n    static long mod = (long)1e9 + 7;\n    static long mod1 = 998244353;\n    static FastScanner f;\n    static PrintWriter pw = new PrintWriter(System.out);\n    static Scanner S = new Scanner(System.in);\n    static long x0; static long y0;\n    static int inf = (int)(1e9);\n    static long iinf = (long)(1e18);\n    static TreeSet<Integer> tr;\n    static int arr[];\n    static boolean go(int x , int n) {\n        for(int i = 0; i < n; ++i) {\n            if(tr.contains(arr[i] - x)) return true;\n        }\n        return false;\n    }\n    static void solve()throws IOException {\n        int n = f.ni(); int l = f.ni(); int x = f.ni(); int y = f.ni();\n        tr = new TreeSet<>();\n        arr = new int[n];\n        for(int i = 0; i < n; ++i) {\n            arr[i] = f.ni();\n            tr.add(arr[i]);\n        }\n        boolean ok1 = go(x , n); boolean ok2 = go(y , n);\n        if(ok1 && ok2) {pn(0); return;}\n        if(ok1) {pn(1); pn(y); return;}\n        if(ok2) {pn(1); pn(x); return;}\n        for(int i = 0; i < n; ++i) {\n            if(tr.contains(arr[i] - x - y)) {\n                pn(1);\n                pn(arr[i] - x);\n                return;\n            }\n            if(arr[i] + x <= l && tr.contains(arr[i] + x - y)) {\n                pn(1);\n                pn(arr[i] + x);\n                return;\n            }\n            if(arr[i] - x >= 0 && tr.contains(arr[i] + y - x)) {\n                pn(1);\n                pn(arr[i] - x);\n                return;\n            }\n        }\n        pn(2);\n        pn(x + \" \" + y);\n    }\n    public static void main(String[] args)throws IOException {\n        init();\n        int t = 1;\n        while(t --> 0) {solve();}\n        pw.flush(); \n        pw.close();  \n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    public static void init()throws IOException{if(System.getProperty(\"ONLINE_JUDGE\")==null){f=new FastScanner(\"\");}else{f=new FastScanner(System.in);}}\n    public static class FastScanner {\n        BufferedReader br;StringTokenizer st;\n        FastScanner(InputStream stream){try{br=new BufferedReader(new InputStreamReader(stream));}catch(Exception e){e.printStackTrace();}}\n        FastScanner(String str){try{br=new BufferedReader(new FileReader(\"!a.txt\"));}catch(Exception e){e.printStackTrace();}}\n        String next(){while(st==null||!st.hasMoreTokens()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}\n        String nextLine()throws IOException{return br.readLine();}int ni(){return Integer.parseInt(next());}long nl(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}\n    }\n    public static void pn(Object o){pw.println(o);}\n    public static void p(Object o){pw.print(o);}\n    public static void pni(Object o){pw.println(o);pw.flush();}\n    static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    static long exgcd(long a,long b){if(b==0){x0=1;y0=0;return a;}long temp=exgcd(b,a%b);long t=x0;x0=y0;y0=t-a/b*y0;return temp;}\n    static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    static long mpow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=((res%mod)*(a%mod))%mod;b>>=1;a=((a%mod)*(a%mod))%mod;}return res;}\n    static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> ans=new HashSet<Long>();for(Long i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> ans=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static int[] inpint(int n){int arr[]=new int[n];for(int i=0;i<n;i++){arr[i]=f.ni();}return arr;}\n    static long[] inplong(int n){long arr[] = new long[n];for(int i=0;i<n;i++){arr[i]=f.nl();}return arr;}\n    static boolean ise(int x){return ((x&1)==0);}static boolean ise(long x){return ((x&1)==0);}\n    static int gnv(char c){return Character.getNumericValue(c);}//No. of integers less than equal to i in ub\n    static int log(long x){return x==1?0:(1+log(x/2));} static int log(int x){return x==1?0:(1+log(x/2));}\n    static int upperbound(int a[],int i){int lo=0,hi=a.length-1,mid=0;int count=0;while(lo<=hi){mid=(lo+hi)/2;if(a[mid]<=i){count=mid+1;lo=mid+1;}else hi=mid-1;}return count;}\n    static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(ArrayList<Integer> a){Collections.sort(a);}//!Precompute fact in ncr()!\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/**\n* @author master_j\n* @version 0.4\n* @since May 3, 2014\n*/\npublic class Solution {\n    //private long[] a;\n    TreeSet<Long> set;\n\n    private void solve() throws IOException {\n        int n = io.nI(), l = io.nI(), x = io.nI(), y = io.nI();\n        set = new TreeSet<>();\n        for(int i = 0; i < n; i++)\n            set.add(io.nL());\n\n        boolean check0 = checkOne(x);\n        boolean check1 = checkOne(y);\n        if(check0 || check1){\n            if(check0 && check1)\n                io.wln(0);\n            else if(check0)\n                io.wf(\"1\\n%d\\n\", y);\n            else\n                io.wf(\"1\\n%d\\n\", x);\n            return;\n        }\n\n        Long ans = solve(x, y);\n        if(ans == null)\n            io.wf(\"2\\n%d %d\\n\", x, y);\n        else\n            io.wf(\"1\\n%d\\n\", ans);\n    }//2.2250738585072012e-308\n\n    private boolean checkOne(long mark) {\n        for(long i : set)\n            if(set.contains(i - mark) || set.contains(i + mark))\n                return true;\n        return false;\n    }\n\n    private Long solve(int x, int y) {\n        for(long i : set){\n            long markL = i - x;\n            if(0 <= markL)\n                if(set.contains(markL - y) || set.contains(markL + y))\n                    return markL;\n\n            long markR = i + x;\n            if(markR <= set.last())\n                if(set.contains(markR - y) || set.contains(markR + y))\n                    return markR;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) throws IOException {\n        IO.launchSolution(args);\n    }\n\n    Solution(IO io) throws IOException {\n        this.io = io;\n        solve();\n    }\n\n    private final IO io;\n}\n\nclass IO {\n    static final String _localArg = \"master_j\";\n    private static final String _problemName = \"\";\n    private static final IO.Mode _inMode = Mode.STD_;\n    private static final IO.Mode _outMode = Mode.STD_;\n    private static final boolean _autoFlush = false;\n\n    static enum Mode {STD_, _PUT_TXT, PROBNAME_}\n\n    private final StreamTokenizer st;\n    private final BufferedReader br;\n    private final Reader reader;\n\n    private final PrintWriter pw;\n    private final Writer writer;\n\n    static void launchSolution(String[] args) throws IOException {\n        boolean local = (args.length == 1 && args[0].equals(IO._localArg));\n        IO io = new IO(local);\n\n        long nanoTime = 0;\n        if (local) {\n            nanoTime -= System.nanoTime();\n            io.wln(\"<output>\");\n        }\n\n        io.flush();\n        new Solution(io);\n        io.flush();\n\n        if(local){\n            io.wln(\"</output>\");\n            nanoTime += System.nanoTime();\n            final long D9 = 1000000000, D6 = 1000000, D3 = 1000;\n            if(nanoTime >= D9)\n                io.wf(\"%d.%d seconds\\n\", nanoTime/D9, nanoTime%D9);\n            else if(nanoTime >= D6)\n                io.wf(\"%d.%d millis\\n\", nanoTime/D6, nanoTime%D6);\n            else if(nanoTime >= D3)\n                io.wf(\"%d.%d micros\\n\", nanoTime/D3, nanoTime%D3);\n            else\n                io.wf(\"%d nanos\\n\", nanoTime);\n        }\n\n        io.close();\n    }\n\n    IO(boolean local) throws IOException {\n        if(_inMode == Mode.PROBNAME_ || _outMode == Mode.PROBNAME_)\n            if(_problemName.length() == 0)\n                throw new IllegalStateException(\"You imbecile. Where's my <_problemName>?\");\n\n        if(_problemName.length() > 0)\n            if(_inMode != Mode.PROBNAME_ && _outMode != Mode.PROBNAME_)\n                throw new IllegalStateException(\"You imbecile. What's the <_problemName> for?\");\n\n        Locale.setDefault(Locale.US);\n\n        if (local) {\n            reader = new FileReader(\"input.txt\");\n            writer = new OutputStreamWriter(System.out);\n        } else {\n            switch (_inMode) {\n                case STD_:\n                    reader = new InputStreamReader(System.in);\n                    break;\n                case PROBNAME_:\n                    reader = new FileReader(_problemName + \".in\");\n                    break;\n                case _PUT_TXT:\n                    reader = new FileReader(\"input.txt\");\n                    break;\n                default:\n                    throw new NullPointerException(\"You imbecile. Gimme _inMode.\");\n            }\n            switch (_outMode) {\n                case STD_:\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case PROBNAME_:\n                    writer = new FileWriter(_problemName + \".out\");\n                    break;\n                case _PUT_TXT:\n                    writer = new FileWriter(\"output.txt\");\n                    break;\n                default:\n                    throw new NullPointerException(\"You imbecile. Gimme _outMode.\");\n            }\n        }\n\n        br = new BufferedReader(reader);\n        st = new StreamTokenizer(br);\n\n        pw = new PrintWriter(writer, _autoFlush);\n\n        if(local && _autoFlush)\n            wln(\"Note: auto-flush is on.\");\n    }\n\n    void wln()          {pw.println(); }\n    void wln(boolean x) {pw.println(x);}\n    void wln(char x)    {pw.println(x);}\n    void wln(char x[])  {pw.println(x);}\n    void wln(double x)  {pw.println(x);}\n    void wln(float x)   {pw.println(x);}\n    void wln(int x)     {pw.println(x);}\n    void wln(long x)    {pw.println(x);}\n    void wln(Object x)  {pw.println(x);}\n    void wln(String x)  {pw.println(x);}\n\n    void wf(String f, Object...o){pw.printf(f, o);}\n\n    void w(boolean x)   {pw.print(x);}\n    void w(char x)      {pw.print(x);}\n    void w(char x[])    {pw.print(x);}\n    void w(double x)    {pw.print(x);}\n    void w(float x)     {pw.print(x);}\n    void w(int x)       {pw.print(x);}\n    void w(long x)      {pw.print(x);}\n    void w(Object x)    {pw.print(x);}\n    void w(String x)    {pw.print(x);}\n\n    int nI() throws IOException    {st.nextToken(); return (int)st.nval;}\n    double nD() throws IOException {st.nextToken(); return st.nval;}\n    float nF() throws IOException  {st.nextToken(); return (float)st.nval;}\n    long nL() throws IOException   {st.nextToken(); return (long)st.nval;}\n    String nS() throws IOException {st.nextToken(); return st.sval;}\n\n    void wc(String x){ wc(x.toCharArray()); }\n    void wc(char c1, char c2){for(char c = c1; c<=c2; c++)wc(c);}\n    void wc(char x[]){\n        for(char c : x)\n            wc(c);\n    }\n    void wc(char x){st.ordinaryChar(x); st.wordChars(x, x);}\n\n    public boolean eof() {return st.ttype == StreamTokenizer.TT_EOF;}\n    public boolean eol() {return st.ttype == StreamTokenizer.TT_EOL;}\n\n    void flush(){pw.flush();}\n    void close() throws IOException{reader.close(); br.close(); flush(); pw.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  int arr[n];\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  bool isX = false, isY = false;\n  for (int i = 0; i < n; i++) {\n    int low = i, high = n - 1, mid = (low + high) / 2;\n    while (low <= high) {\n      if (arr[mid] - arr[i] < x) {\n        low = mid + 1;\n        mid = (low + high) / 2;\n      } else if (arr[mid] - arr[i] > x) {\n        high = mid - 1;\n        mid = (low + high) / 2;\n      } else if (arr[mid] - arr[i] == x) {\n        isX = true;\n        break;\n      }\n    }\n    if (isX == true) break;\n  }\n  for (int i = 0; i < n; i++) {\n    int low = i, high = n - 1, mid = (low + high) / 2;\n    while (low <= high) {\n      if (arr[mid] - arr[i] < y) {\n        low = mid + 1;\n        mid = (low + high) / 2;\n      } else if (arr[mid] - arr[i] > y) {\n        high = mid - 1;\n        mid = (low + high) / 2;\n      } else if (arr[mid] - arr[i] == y) {\n        isY = true;\n        break;\n      }\n    }\n    if (isY == true) break;\n  }\n  if (isX == true && isY == true) {\n    cout << 0;\n    return 0;\n  } else if (isX == true)\n    cout << 1 << endl << y;\n  else if (isY == true)\n    cout << 1 << endl << x;\n  else {\n    for (int i = 1; i < n; i++) {\n      if (arr[i] - (arr[i - 1] + x) == y) {\n        if (arr[i - 1] + x > arr[i] && arr[i - 1] + x <= l) {\n          cout << 1 << endl << arr[i - 1] + y;\n          return 0;\n        }\n        cout << 1 << endl << arr[i - 1] + x;\n        return 0;\n      }\n    }\n    map<int, int> m;\n    for (int i = 0; i < n; i++) {\n      if (arr[i] - x > 0) {\n        m[arr[i] - x] = x;\n      }\n      if (m[arr[i] + x] == y && arr[i] + x < l) {\n        cout << 1 << endl << arr[i] + x;\n        return 0;\n      }\n      m[arr[i] + x] = x;\n      m[arr[i] + y] = y;\n      if (arr[i] - y > 0) {\n        if (m[arr[i] - y] == x) {\n          cout << 1 << endl << arr[i] - y;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport itertools\nimport math\n\ndef can_measure(a, d):\n\treturn any(i + d in a for i in a)\n\ndef main():\n\tn, l, x, y = map(int, input().split())\n\ta = set(map(int, input().split()))\n\t\n\tcan_x = can_measure(a, x)\n\tcan_y = can_measure(a, y)\n\tif can_x and can_y:\n\t\tprint(0)\n\telif can_x:\n\t\tprint(1)\n\t\tprint(y)\n\telif can_y:\n\t\tprint(1)\n\t\tprint(x)\n\telse:\n\t\tfor i in a:\n\t\t\tif i + x + y in a:\n\t\t\t\tprint(1)\n\t\t\t\tprint(i + x)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tt = i + x - y in a\n\t\t\t\tif 0 <= i + x <= l and t:\n\t\t\t\t\tprint(1)\n\t\t\t\t\tprint(i + x)\n\t\t\t\t\tbreak;\n\t\t\t\tif 0 <= i - y <= l and t:\n\t\t\t\t\tprint(1)\n\t\t\t\t\tprint(i - y)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\telse:\n\t\t\tprint(2)\n\t\t\tprint(x, y)\n\t\t\n\nif __name__ == \"__main__\":\n\tmain()\n        \n        \n            \n\n\n        \n\n        \n        \n            \n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, N, M, K, k;\nint G, B;\nunordered_map<int, int> u;\nint s[100010];\nint main() {\n  int a, b, c, d;\n  int T;\n  cin >> N >> K >> G >> B;\n  for (a = 0; a < (int)N; a++) {\n    scanf(\"%d\", &c);\n    s[a] = c;\n    u[c] = 1;\n    if (G and u[c - G] == 1) {\n      G = 0;\n    }\n    if (B and u[c - B] == 1) {\n      B = 0;\n    }\n  }\n  if (!G and !B) {\n    puts(\"0\");\n    return 0;\n  }\n  if (G and !B) {\n    printf(\"1\\n%d\", G);\n    return 0;\n  }\n  if (B and !G) {\n    cout << 1 << endl << B;\n    return 0;\n  }\n  for (a = 0; a < (int)N; a++) {\n    c = s[a];\n    if (c + B < K)\n      if (u[c + B + G] == 1 or u[c + B - G] == 1) {\n        cout << 1 << endl << c + B;\n        return 0;\n      }\n    if (c + G < K)\n      if (u[c + B + G] == 1 or u[c + G - B] == 1) {\n        cout << 1 << endl << c + G;\n        return 0;\n      }\n    if (c - B > 0)\n      if (u[c - B + G] == 1 or u[c - B - G] == 1) {\n        cout << 1 << endl << c - B;\n        return 0;\n      }\n    if (c - G > 0)\n      if (u[c - G + B] == 1 or u[c - G - B] == 1) {\n        cout << 1 << endl << c - G;\n        return 0;\n      }\n  }\n  cout << 2 << endl << B << ' ' << G;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.io.PrintWriter;\n    import java.util.*;\n\n    public class d extends PrintWriter{\n        static BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n        // static Scanner s=new Scanner(System.in);\n        d() { super(System.out); }\n        public static void main(String[] args) throws IOException{\n            d d1=new d();d1.main();d1.flush();\n        }void main() throws IOException {\n    //        StringBuilder sb = new StringBuilder();\n            PrintWriter out = new PrintWriter(System.out);\n             String[] s1=s();\n          int n=i(s1[0]);long l=l(s1[1]);long x=i(s1[2]);long y=i(s1[3]);\n          long[] a=new long[n];\n          String[] s2=s();\n          int f1=0;int f2=0;\n          HashMap<Long,Integer> h=new HashMap<>();\n            HashMap<Long,Integer> h1=new HashMap<>();\n\n            for(int i=0;i<n;i++){\n              a[i]=l(s2[i]);\n               if(h.containsKey(a[i]-x)) f1=1;\n               if(h.containsKey(a[i]-y)) f2=1;\n               h.put(a[i],0);\n          }\n          if(f1+f2==2){\n              System.out.println(0);\n          }else if(f1==1){\n              System.out.println(1);\n              System.out.println(y);\n          }else if(f2==1){\n              System.out.println(1+\"\\n\"+x);\n          }else{\n                for(int i=0;i<n;i++){\n                   if(a[i]-x>=0) h.put(a[i]-x,0);\n                    if(a[i]+x<=l) h.put(a[i]+x,0);\n                }int ff=0;\n                for(int i=0;i<n;i++){\n                    if(h.containsKey(a[i]-y)){\n                        ff=1;System.out.println(1);\n                        System.out.println(a[i]-y);\n                    break;}\n                    if(h.containsKey(a[i]+y)){\n                        ff=1;System.out.println(1);\n                        System.out.println(a[i]+y);break;\n                    }\n                }if(ff==0){\n                  System.out.println(2);\n                  System.out.println(x+\" \"+y);\n              }\n          }\n        }\n        static String[] s() throws IOException {\n\n            return s.readLine().trim().split(\"\\\\s+\");\n        }\n\n        static int i(String ss) {\n            return Integer.parseInt(ss);\n        }\n        static long l(String ss) {\n            return Long.parseLong(ss);\n        }\n    }\n    class node implements Comparator<node>{\n        int ver,val;\n        public node(){}\n        public node(int ver,int val) {\n            this.ver=ver;this.val=val;\n        }public int compare(node n1,node n2){\n           return n1.val-n2.val;\n        }\n    }\n\n    class Student12 {\n        int  l;int r;\n        public Student12(int l, int r) {\n            this.l = l;\n            this.r = r;\n        }\n\n        public String toString()\n        {\n            return this.l+\" \";\n        }\n    }\n    class Sortbyroll12 implements Comparator<Student12> {\n\n        public int compare(Student12 a, Student12 b){\n            return a.l-b.l;\n    //        if(a.r<b.r) return 1;else if(a.r==b.r) return 0;else return -1;// a.r-b.r;\n          /*  if(b.r<a.r) return -1;\n            else if(b.r==a.r) return 0;\n            return 1;*/\n\n            //   return b.r-a.r;\n           /*\n           if(b.l<a.l) return -1;\n           else if(b.l==a.l) {\n               return b.r-a.r;\n           }\n           return 1;*/\n            //        return b.r- a.r;\n            //        return (int) a.l-(int) b.l;\n             /*   if(a.r<b.r) return -1;\n                else if(a.r==b.r){\n                    if(a.r==b.r){\n                        return 0;\n                    }\n                    if(a.r<b.r) return -1;\n                    return 1;}\n                return 1;  */}\n    }\n    class Node1 implements Comparator<Node1>{\n        int node;long val;\n        public  Node1(){}\n        public  Node1(int node,long val){\n            this.node=node;this.val=val;\n        }\n        @Override\n        public int compare(Node1 a,Node1 b){\n            if(a.val<b.val) return -1;\n            if(a.val==b.val) return 0;\n            {\n                return 1;\n            }\n        }\n    }\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nCodeforces Contest 274 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef check_dist(d, a):\n    left = 0\n    right = 1\n    while right < len(a):\n        if a[right] - a[left] == d:\n            return left+1\n        if a[right] - a[left] > d:\n            left += 1\n        else:\n            right += 1\n    return 0\n\ndef check_dist_rev(d, a):\n    left = len(a)-2\n    right = len(a)-1\n    while left > -1:\n        if a[right] - a[left] == d:\n            return left+1\n        if a[right] - a[left] > d:\n            right -= 1\n        else:\n            left -= 1\n    return 0\n\ndef main():\n    n,l,x,y = read()\n    a = read()\n    x_sat = check_dist(x, a)\n    y_sat = check_dist(y, a)\n    if x_sat and y_sat:\n        print(0)\n        return\n    elif x_sat and not y_sat:\n        print(1)\n        print(y)\n        return\n    elif not x_sat and y_sat:\n        print(1)\n        print(x)\n        return\n    add_sat = check_dist(x+y, a)\n    sub_sat = check_dist(y-x, a)\n    if add_sat:\n        print(1)\n        print(a[add_sat-1] + x)\n    elif sub_sat:\n        p = sub_sat-1\n        if a[p]+y < l:\n            print(1)\n            print(a[p]+y)\n        elif a[p]-x > 0:\n            print(1)\n            print(a[p]-x)\n        else:\n            p = check_dist_rev(y-x, a) - 1\n            if a[p]+y < l:\n                print(1)\n                print(a[p]+y)\n            elif a[p]-x > 0:\n                print(1)\n                print(a[p]-x)\n            else:\n                print(2)\n                print(x,y)\n    else:\n        print(2)\n        print(x, y)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BLongJumps solver = new BLongJumps();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BLongJumps {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            int l = in.readInt();\n            int x = in.readInt();\n            int y = in.readInt();\n\n            int[] a = in.readIntArray(n);\n            HashSet<Integer> set = new HashSet<>();\n            for (int i : a) set.add(i);\n            int cnt = 0;\n            for (int i = 0; i < a.length - 1; i++) {\n                int v1 = Arrays.binarySearch(a, i + 1, a.length, x + a[i]);\n                if (v1 >= 0) {\n                    cnt += x;\n                    break;\n                }\n            }\n            for (int i = 0; i < a.length - 1; i++) {\n                int v1 = Arrays.binarySearch(a, i + 1, a.length, y + a[i]);\n                if (v1 >= 0) {\n                    cnt += y;\n                    break;\n                }\n            }\n            if (cnt == x + y) {\n                out.println(0);\n                return;\n            }\n            if (cnt != 0) {\n                out.println(1);\n                out.println(x + y - cnt);\n                return;\n            }\n\n            ArrayList<Integer> list = new ArrayList<>();\n            for (int i : a) {\n                list.add(i);\n                if (i + x < l) list.add(i + x);\n                if (i - x > 0) list.add(i - x);\n                if (i + y < l) list.add(i + y);\n                if (i - y > 0) list.add(i - y);\n            }\n            for (int i : list) {\n                if ((set.contains(i + y) || set.contains(i - y)) && (set.contains(i + x) || set.contains(i - x))) {\n                    out.println(1);\n                    out.println(i);\n                    return;\n                }\n            }\n            out.println(2);\n            out.println(x + \" \" + y);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] ans = new int[size];\n            for (int i = 0; i < size; i++) ans[i] = readInt();\n            return ans;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\npublic class CopyOfSolution {\n    // private T[] arr = new T[2];\n\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        InputReader in = new InputReader(System.in);\n        long n = in.nextLong();\n        long l = in.nextLong();\n        long x = in.nextLong();\n        long y = in.nextLong();\n        long[] a = new long[(int) n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextLong();\n        }\n        boolean bx = false;\n        boolean by = false;\n        for (int i = 0; i < n; i++) {\n            if (bx && by) {\n                break;\n            }\n            int xx = Arrays.binarySearch(a, a[i] + x);\n            if (xx >= 0) {\n                bx = true;\n            }\n            int yy = Arrays.binarySearch(a, a[i] + y);\n            if (yy >= 0) {\n                by = true;\n            }\n        }\n\n        if (bx && by) {\n            out.println(0);\n        } else if (bx) {\n            out.println(1);\n            out.println(y);\n        } else if (by) {\n            out.println(1);\n            out.println(x);\n        } else {\n            long posX = -1;\n            int steps = 0;\n            for (int i = 0; i < n; i++) {\n                // Lets put a[i] + x;\n                if (a[i] + x <= l) {\n                    bx = true;\n                    posX = a[i] + x;\n                    by = Arrays.binarySearch(a, posX + y) >= 0\n                            || Arrays.binarySearch(a, posX - y) >= 0;\n                    if (bx && by) {\n                        steps = 1;\n                        break;\n                    } else {\n                        bx = false;\n                        by = false;\n                        steps = 0;\n                    }\n                }\n\n                // Lets put a[i] - x;\n                if (a[i] - x >= 0) {\n                    bx = true;\n                    posX = a[i] - x;\n                    by = Arrays.binarySearch(a, posX + y) >= 0\n                            || Arrays.binarySearch(a, posX - y) >= 0;\n                    if (bx && by) {\n                        steps = 1;\n                        break;\n                    } else {\n                        bx = false;\n                        by = false;\n                        steps = 0;\n                    }\n                }\n            }\n            if (steps == 1) {\n                out.println(1);\n                out.println(posX);\n            } else {\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer s;\n\n        public InputReader(InputStream is) {\n            InputStreamReader in = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(in);\n            this.reader = reader;\n        }\n\n        public String next() {\n            while (s == null || !s.hasMoreTokens()) {\n                try {\n                    s = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return s.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100101];\nint x, y;\nint n, m;\nint rn = 0;\nint r[11];\nint main() {\n  int i, j, k, l, s, t, sum = 0;\n  bool color4 = false, color1 = false, color2 = false, color3 = false;\n  scanf(\"%d%d%d%d\", &n, &m, &x, &y);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; i++) {\n    k = a[i] + x;\n    s = lower_bound(a + 1, a + n + 1, k) - a;\n    if (a[s] == k) {\n      color1 = true;\n      break;\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    k = a[i] + y;\n    s = lower_bound(a + 1, a + n + 1, k) - a;\n    if (a[s] == k) {\n      color2 = true;\n      break;\n    }\n  }\n  if (!color1 && !color2) {\n    for (i = 1; i <= n; i++) {\n      k = a[i] + y + x;\n      if (k < 0) break;\n      s = lower_bound(a + 1, a + n + 1, k) - a;\n      if (a[s] == k) {\n        color3 = true;\n        break;\n      }\n    }\n    if (color3) {\n      printf(\"1\\n%d\\n\", a[i] + x);\n      return 0;\n    }\n  }\n  if (!color1 && !color2) {\n    for (i = 1; i <= n; i++) {\n      k = a[i] + y - x;\n      if (k < 0 || k > m || a[i] + y > m) break;\n      s = lower_bound(a + 1, a + n + 1, k) - a;\n      if (a[s] == k) {\n        color4 = true;\n        break;\n      }\n    }\n    if (color4) {\n      printf(\"1\\n%d\\n\", a[i] + y);\n      return 0;\n    } else {\n      for (i = 1; i <= n; i++) {\n        k = a[i] - (y - x);\n        if (k < 0 || k > m || a[i] - y < 0) continue;\n        s = lower_bound(a + 1, a + n + 1, k) - a;\n        if (a[s] == k) {\n          color4 = true;\n          break;\n        }\n      }\n      if (color4) {\n        printf(\"1\\n%d\\n\", a[i] - y);\n        return 0;\n      }\n    }\n  }\n  if (!color1) r[++rn] = x;\n  if (!color2) {\n    r[++rn] = y;\n  }\n  if (rn == 2 && r[1] == r[2]) rn--;\n  printf(\"%d\\n\", rn);\n  for (i = 1; i <= rn - 1; i++) printf(\"%d \", r[i]);\n  if (rn) printf(\"%d\\n\", r[rn]);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n\npublic class Solution {\n\n    static int sol = 2;\n    static boolean foundX = false;\n    static int markX = -1;\n    static int markY = -1;\n\n    static boolean foundY = false;\n    static int complementMark = -1;\n\n    public static void main(String[] args) throws Exception{\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 400000);\n\n        String[] s = reader.readLine().split(\" \");\n\n        int n = Integer.valueOf(s[0]);\n        int l = Integer.valueOf(s[1]);\n        int x = Integer.valueOf(s[2]);\n        int y = Integer.valueOf(s[3]);\n\n        int[] a = new int[n];\n\n        s = reader.readLine().split(\" \");\n\n        for (int i=0; i<a.length; i++){\n            a[i] = Integer.valueOf(s[i]);\n        }\n\n        for (int i=0; i<n && (!foundX || !foundY); i++){\n            //x\n            tryX(l, a, a[i] + x, y);\n            tryX(l, a, a[i] - x, y);\n\n            //y\n            tryY(l, a, a[i] - y, x);\n            tryY(l, a, a[i] + y, x);\n        }\n\n        if (foundX && foundY){\n            System.out.println(0);\n        } else if (foundX){\n            System.out.println(1);\n            System.out.println(markY);\n        } else if (foundY){\n            System.out.println(1);\n            System.out.println(markX);\n        }\n        else {\n            System.out.println(sol);\n\n            if (sol == 1){\n                System.out.println(complementMark);\n            } else {\n                System.out.println(markX + \" \" + markY);\n            }\n\n        }\n    }\n\n    private static void tryX(int l, int[] a, int targetX, int y) {\n        if (targetX <= l && targetX >= 0){\n            if (contains(a, targetX)){\n                foundX = true;\n            } else {\n                markX = targetX;\n\n                if (sol > 1){\n                    if (tryComplement(a, l, targetX + y)){\n                        sol = 1;\n                        complementMark = targetX;\n                    }\n\n                    if (sol > 1){\n                        if (tryComplement(a, l, targetX - y)){\n                            sol = 1;\n                            complementMark = targetX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean tryComplement(int[] a, int l, int val) {\n        if (val >= 0 && val <= l){\n            return contains(a, val);\n        }\n\n        return false;\n    }\n\n    private static void tryY(int l, int[] a, int targetY, int x) {\n        if (targetY <= l && targetY >=0){\n            if (contains(a, targetY)){\n                foundY = true;\n            } else {\n                markY = targetY;\n\n                if (sol > 1){\n                    if (tryComplement(a, l, targetY + x)){\n                        complementMark = targetY;\n                        sol = 1;\n                    }\n\n                    if (sol > 1){\n                        if (tryComplement(a, l, targetY - x)){\n                            complementMark = targetY;\n                            sol = 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    private static boolean contains(int[] a, int target){\n        int left = 0;\n        int right = a.length-1;\n\n        while (left <= right){\n            int mid = left + (right - left)/2;\n\n            if (a[mid] == target){\n                return true;\n            }\n\n            if (a[mid] > target){\n                right = mid-1;\n            } else {\n                left = mid+1;\n            }\n        }\n\n        return false;\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nfirst = sys.stdin.readline().split(\" \")\nn = int(first[0])\nl = int(first[1])\nx = int(first[2])\ny = int(first[3])\nsecond = sys.stdin.readline().split(\" \")\n\nhave_dict = {}\nneed_dict_x = {}\nneed_dict_y = {}\n\nfor val in second:\n\thave_dict[val] = 1\n\tval = int(val)\n\tneed_dict_x[str(val - x)] = 1\n\tneed_dict_x[str(val+x)] = 1\n\tneed_dict_y[str(val - y)] = 1\n\tneed_dict_y[str(val + y)] = 1\n\n\nneed_x = 1\nneed_y = 1\nsomething = 1\nfor val in have_dict.keys():\n\ttry:\n\t\tneed_dict_x[val]\n\t\tneed_x = 0\n\texcept:\n\t\tsomething += 1\n\ttry: \n\t\tneed_dict_y[val]\n\t\tneed_y = 0\n\texcept:\n\t\tsomething -= 1\nneed_vals = []\nif need_x == 1 and need_y == 1:\n\tto_return = 2\n\treturn_val = str(x) + \" \"+str(y)\n\tfor val in need_dict_x.keys():\n\t\tif int(val) < 0 or int(val) > l: \n\t\t\tcontinue\n\t\telse:\n\t\t\ttry: \n\t\t\t\tneed_dict_y[val]\n\t\t\t\tto_return = 1\n\t\t\t\treturn_val = val\n\t\t\texcept:\n\t\t\t\tcontinue\n\tprint(to_return)\n\tprint(return_val)\nelse:\t\n\tprint(need_x+need_y)\n\tif need_x == 1:\n\t\tprint(x)\n\telif need_y == 1:\n\t\tprint(y)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class code\n{\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    \n    public static void main(String args[])throws IOException\n\t{\n        FastReader scn = new FastReader();\n\n        int n = scn.nextInt();\n        long l = scn.nextLong();\n        long x = scn.nextLong();\n        long y = scn.nextLong();\n\n        long[] a = new long[n];\n\n        for(int i = 0; i < n; i++)\n        {\n            a[i] = scn.nextLong();\n        }\n\n        int x_found = -1;\n        int y_found = -1;\n        int x_plus_y_found = -1;\n\n        // first find x, if not mark x, find y, if not mark y\n        // first find y, if not mark y, find x, if not mark x\n\n        int i = 0, j = 0;\n        while(j < n)\n        {\n            if((a[j] - a[i]) == x)\n            {\n                x_found = i;\n                break;\n            }\n            else if((a[j] - a[i]) < x)\n                j++;\n            else\n                i++;\n        }\n\n        i = 0; j = 0;\n        while(j < n)\n        {\n            if((a[j] - a[i]) == y)\n            {\n                y_found = i;\n                break;\n            }\n            else if((a[j] - a[i]) < y)\n                j++;\n            else\n                i++;\n        }\n\n        i = 0; j = 0;\n        while(j < n)\n        {\n            if((a[j] - a[i]) == (x + y))\n            {\n                x_plus_y_found = i;\n                break;\n            }\n            else if((a[j] - a[i]) < (x + y))\n                j++;\n            else\n                i++;\n        }\n\n        if(x_found >= 0 && y_found >= 0 )\n        {\n            System.out.println(0);\n        }\n        else if( x_found >= 0)\n        {\n            System.out.println(1);\n            System.out.println(y);\n        }\n        else if(y_found >= 0)\n        {\n            System.out.println(1);\n            System.out.println(x);\n        }\n        else if(x_plus_y_found >= 0)\n        {\n            System.out.println(1);\n            System.out.println(a[x_plus_y_found] + x);\n        }\n        else\n        {\n            i = 0; j = 0;\n            while(j < n)\n            {\n                if((a[j] - a[i]) == (y - x))\n                {\n                    if(a[j] + x <= l)\n                    {\n                        System.out.println(1);\n                        System.out.println(a[j]+x);\n                        return;\n                    }\n                    else if(a[i] - x >= 0)\n                    {\n                        System.out.println(1);\n                        System.out.println(a[i]-x);\n                        return;\n                    }\n                    else\n                    {\n                        i++;\n                    }\n                }\n                else if((a[j] - a[i]) < (y - x))\n                    j++;\n                else\n                    i++;\n            }\n\n            System.out.println(2);\n            System.out.println(x+\" \"+y);\n        }\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\nconst int mod = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int M = 1000100;\nint a[100050];\nmap<int, int> vis;\nint main() {\n  int n, len, x, y;\n  cin >> n >> len >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    vis[a[i]] = 1;\n  }\n  int ans = 0;\n  int l = 0, r = 0;\n  int tmp = a[0];\n  while (r < n) {\n    if (tmp < x) {\n      r++;\n      if (r == n) break;\n      tmp = a[r] - a[l];\n    } else if (tmp > x) {\n      l++;\n      tmp = a[r] - a[l];\n    } else {\n      ans++;\n      break;\n    }\n  }\n  l = 0, r = 0;\n  tmp = a[0];\n  while (r < n) {\n    if (tmp < y) {\n      r++;\n      if (r == n) break;\n      tmp = a[r] - a[l];\n    } else if (tmp > y) {\n      l++;\n      tmp = a[r] - a[l];\n    } else {\n      ans += 2;\n      break;\n    }\n  }\n  if (ans == 3) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (a[i] - x == a[i + 1] - y) {\n      if (a[i] - x >= 0) {\n        cout << \"1\" << endl;\n        cout << a[i] - x << endl;\n        return 0;\n      }\n    }\n    if ((a[i] + y == a[i + 1] + x) || (a[i] + y == a[i + 1] - x)) {\n      if (a[i] + y > len) continue;\n      cout << \"1\" << endl;\n      cout << a[i] + y << endl;\n      return 0;\n    }\n  }\n  if (ans == 1) {\n    cout << \"1\" << endl;\n    cout << y << endl;\n    return 0;\n  }\n  if (ans == 2) {\n    cout << \"1\" << endl;\n    cout << x << endl;\n    return 0;\n  }\n  int ca = y - x;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] - y == x) {\n      if (a[i] - y >= 0) {\n        cout << \"1\" << endl;\n        cout << y << endl;\n        return 0;\n      }\n    }\n    if (a[i] - x == y) {\n      if (a[i] - x < 0) {\n        cout << \"1\" << endl;\n        cout << x << endl;\n        return 0;\n      }\n    }\n    if (a[i] + x == y) {\n      if (a[i] + x <= len) {\n        cout << \"1\" << endl;\n        cout << y << endl;\n        return 0;\n      }\n    }\n    if (vis[a[i] - x + y]) {\n      if (a[i] - x >= 0) {\n        cout << \"1\" << endl;\n        cout << a[i] - x << endl;\n        return 0;\n      }\n    }\n    if (vis[a[i] - y + x]) {\n      if (a[i] - y >= 0) {\n        cout << \"1\" << endl;\n        cout << a[i] - y << endl;\n        return 0;\n      }\n    }\n    if (vis[a[i] + x - y]) {\n      if (a[i] + x <= len) {\n        cout << \"1\" << endl;\n        cout << a[i] + x << endl;\n        return 0;\n      }\n    }\n    if (vis[a[i] + y - x]) {\n      if (a[i] + y <= len) {\n        cout << \"1\" << endl;\n        cout << a[i] + y << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"2\" << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef find_dif(marks, dif, ret_all=False):\n\tfront = 0\n\tend = 1\n\tret = []\n\twhile True:\n\t\ttmp_f = front\n\t\ttmp_e = end\n\t\twhile end < len(marks) - 1 and marks[end] - marks[front] < dif:\t\t\t\n\t\t\tend += 1\t\t\t\n\t\t\n\t\twhile front < end and marks[end] - marks[front] > dif:\n\t\t\tfront += 1\n\t\tif marks[end] - marks[front] == dif:\n\t\t\tif ret_all:\n\t\t\t\tret.append(marks[front])\n\t\t\t\tend += 1\n\t\t\telse:\n\t\t\t\treturn True, marks[front]\n\t\tif end > len(marks) - 1 or (tmp_f == front and tmp_e == end):\n\t\t\tif ret_all:\n\t\t\t\treturn ret\n\t\t\treturn False, False\n\t\t\n\t\t\ndone = False\ndef print_answer(n, x=None, y=None):\n\tglobal done\n\tif done == False:\n\t\tprint n\n\t\tif n == 1:\n\t\t\tprint x\n\t\telif n == 2:\n\t\t\tprint x, y\n\t\tdone = True\n\n\ndef main():\n\n\tline = [int(x) for x in raw_input().split(' ')]\n\tn = line[0]\n\tl = line[1]\n\tx = line[2]\n\ty = line[3]\n\tmarks = [int(z) for z in raw_input().split(' ')]\n\t\n\t#n = 4; l = 300; x = 4; y = 5;\n\t#marks = [0,6,7,300]\n\t#print n,l,x,y\n\t#print marks\n\t\n\tx_f, x_ind = find_dif(marks, x)\n\ty_f, y_ind = find_dif(marks, y)\n\t#print x, x_f\n\t#print y, y_f\n\t\n\t#asdf\n\t\n\t\n\tif x_f and y_f:\n\t\tprint_answer(0)\n\telif x_f == True:\n\t\tprint_answer(1,y)\n\telif y_f == True:\n\t\tprint_answer(1,x)\n\telse:\n\t\tx_y_f, x_y_ind = find_dif(marks, x+y)\n\t\tif x_y_f:\n\t\t\tprint_answer(1,x_y_ind + x)\n\t\telse:\n\t\t\tret_all = find_dif(marks, y-x, True)\n\t\t\t\t\t\t\n\t\t\tif len(ret_all) > 0:\n\t\t\t\tfor x_y_ind in ret_all:\n\t\t\t\t\tif x_y_ind + y <= l:\n\t\t\t\t\t\tprint_answer(1,x_y_ind + y)\t\t\t\t\t\n\t\t\t\t\telif x_y_ind - x >= 0:\n\t\t\t\t\t\tprint_answer(1,x_y_ind - x)\n\t\t\tprint_answer(2,x,y)\t\t\t\n\t\t\t\t\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Vector;\n\n/**\n * hujiawei - 10/19/14.\n */\n\n//http://codeforces.com/contest/479/problem/D\n\n//\u4e2d\u7b49\u9898\uff0c\u9898\u610f\u662f\u8bf4\u5c3a\u5b50\u4e0a\u5df2\u6709\u4e00\u4e9b\u523b\u5ea6\uff0c\u8fd8\u9700\u8981\u6dfb\u52a0\u591a\u5c11\u4e2a\u523b\u5ea6\u624d\u80fd\u4fdd\u8bc1x\u548cy\u4e24\u4e2a\u6570\u503c\u80fd\u591f\u88ab\u6d4b\u91cf\u51fa\u6765\n\npublic class LongJumps274D {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int l = scanner.nextInt();\n        int x = scanner.nextInt();\n        int y = scanner.nextInt();\n        HashSet marks = new HashSet();\n        for (int i = 0; i < n; i++) {\n            marks.add(scanner.nextInt());\n        }\n        if (measure(marks, x) && measure(marks, y)) {//both x and y can be measured\n            System.out.println(\"0\");\n            return;\n        }\n        if (measure(marks, x)) {//x can be measured\n            System.out.println(\"1\\n\" + y);\n            return;\n        }\n        if (measure(marks, y)) {//y can be measured\n            System.out.println(\"1\\n\" + x);\n            return;\n        }\n        //can add: r+x, r-x, r+y, r-y, then check whether the other (x or y) can add\n        boolean flag = false;//add only one, possible?\n        int r, mark = 0;\n        for (Object markobj : marks) {\n            r = ((Integer) markobj).intValue();//\n            mark = r + x;//suppose to add mark=r+x\n            if (mark <= l && (search(marks, mark + y) || search(marks, mark - y))) {\n                flag = true;\n                break;\n            }\n            mark = r - x;\n            if (mark >= 0 && (search(marks, mark + y) || search(marks, mark - y))) {\n                flag = true;\n                break;\n            }\n            mark = r + y;\n            if (mark <= l && (search(marks, mark + x) || search(marks, mark - x))) {\n                flag = true;\n                break;\n            }\n            mark = r - y;\n            if (mark >= 0 && (search(marks, mark + x) || search(marks, mark - x))) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag) {\n            System.out.println(\"1\\n\" + mark);\n        } else {\n            System.out.println(\"2\\n\" + x + \" \" + y);\n        }\n    }\n\n    public static boolean measure(HashSet marks, int key) {//\u80fd\u5426\u6d4b\u91cf\u6570\u503ckey\n        int markint = 0;\n        for (Object mark : marks) {\n            markint = ((Integer) mark).intValue();//will cover 0+key=key and l-key\n            if (search(marks, markint + key) || search(marks, markint - key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean search(HashSet marks, int key) {//\u56e0\u4e3a\u523b\u5ea6\u662f\u6709\u5e8f\u7684\uff0c\u4e8c\u53c9\u641c\u7d22\u66f4\u5feb\n        if (marks.contains(key)) {\n            return true;\n        }\n        return false;\n    }\n\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(long long int *a, long long int n, long long int l,\n           long long int x) {\n  for (int i = 0; i < n; i++)\n    if (binary_search(a, a + n, a[i] - x) | binary_search(a, a + n, a[i] + x))\n      return true;\n  return false;\n}\nvoid func(long long int *a, long long int n, long long int l, long long int x,\n          long long int y) {\n  bool flag1 = false, flag2 = false;\n  flag1 = check(a, n, l, x);\n  flag2 = check(a, n, l, y);\n  if (!flag1 && !flag2) {\n    bool flag = false;\n    int pos;\n    for (int i = 0; i < n; i++) {\n      long long int z = a[i] + y;\n      if (z <= l)\n        if (binary_search(a, a + n, z + x) | binary_search(a, a + n, z - x)) {\n          flag = true;\n          pos = z;\n          break;\n        }\n      z = a[i] - y;\n      if (z >= 0)\n        if (binary_search(a, a + n, z + x) | binary_search(a, a + n, z - x)) {\n          flag = true;\n          pos = z;\n          break;\n        }\n    }\n    if (!flag)\n      for (int i = 0; i < n; i++) {\n        long long int z = a[i] + x;\n        if (z <= l)\n          if (binary_search(a, a + n, z + y) | binary_search(a, a + n, z - y)) {\n            flag = true;\n            pos = z;\n            break;\n          }\n        z = a[i] - x;\n        if (z >= 0)\n          if (binary_search(a, a + n, z + y) | binary_search(a, a + n, z - y)) {\n            flag = true;\n            pos = z;\n            break;\n          }\n      }\n    if (!flag)\n      cout << 2 << endl << x << endl << y << endl;\n    else\n      cout << 1 << endl << pos << endl;\n  } else if (!flag1)\n    cout << 1 << endl << x << endl;\n  else if (!flag2)\n    cout << 1 << endl << y << endl;\n  else\n    cout << 0 << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  long long int a[n + 1];\n  for (long long int i = 0; i < n; i++) cin >> a[i];\n  func(a, n, l, x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nvector<int> marks;\nbool check(int a) { return (a >= 0 && a <= l); }\nint main() {\n  cin >> n >> l >> x >> y;\n  marks.resize(n);\n  for (int i = 0; i < n; i++) cin >> marks[i];\n  sort(marks.begin(), marks.end());\n  bool X = false, Y = false;\n  for (int i = 0; i < n; i++) {\n    X = binary_search(marks.begin(), marks.end(), marks[i] + x);\n    if (X) break;\n  }\n  for (int i = 0; i < n; i++) {\n    Y = binary_search(marks.begin(), marks.end(), marks[i] + y);\n    if (Y) break;\n  }\n  if (X && Y)\n    cout << 0;\n  else if (X) {\n    cout << 1 << endl;\n    cout << marks[0] + y;\n  } else if (Y) {\n    cout << 1 << endl;\n    cout << marks[0] + x;\n  } else {\n    for (int i = 0; i < n; i++) {\n      bool flag = binary_search(marks.begin(), marks.end(), marks[i] + x + y);\n      bool flag2 = binary_search(marks.begin(), marks.end(), marks[i] + x - y);\n      if (flag) {\n        cout << 1 << endl;\n        cout << marks[i] + x;\n        return 0;\n      }\n      if (flag2) {\n        if (check(marks[i] + x)) {\n          cout << 1 << endl;\n          cout << marks[i] + x;\n          return 0;\n        }\n        if (check(marks[i] - y)) {\n          cout << 1 << endl;\n          cout << marks[i] - y;\n          return 0;\n        }\n      }\n      flag = binary_search(marks.begin(), marks.end(), marks[i] - x + y);\n      if (flag) {\n        if (check(marks[i] - x)) {\n          cout << 1 << endl;\n          cout << marks[i] - x;\n          return 0;\n        }\n        if (check(marks[i] + y)) {\n          cout << 1 << endl;\n          cout << marks[i] + y;\n          return 0;\n        }\n      }\n      flag = binary_search(marks.begin(), marks.end(), marks[0] - x - y);\n      if (flag) {\n        if (check(marks[i] - x)) {\n          cout << 1 << endl;\n          cout << marks[i] - x;\n          return 0;\n        }\n        if (check(marks[i] - y)) {\n          cout << 1 << endl;\n          cout << marks[i] - y;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl;\n    cout << marks[0] + x << \" \" << marks[0] + y << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid read(T& num) {\n  char CH;\n  bool F = false;\n  for (CH = getchar(); CH < '0' || CH > '9'; F = CH == '-', CH = getchar())\n    ;\n  for (num = 0; CH >= '0' && CH <= '9';\n       num = num * 10 + CH - '0', CH = getchar())\n    ;\n  F && (num = -num);\n}\nint stk[70], tp;\ntemplate <class T>\ninline void print(T p) {\n  if (!p) {\n    puts(\"0\");\n    return;\n  }\n  while (p) stk[++tp] = p % 10, p /= 10;\n  while (tp) putchar(stk[tp--] + '0');\n  putchar('\\n');\n}\nconst long long mod = 1e9 + 7;\nconst double PI = acos(-1.0);\nconst int inf = 1e9;\nconst int N = 1e6 + 20;\nconst int maxn = 5e3 + 10;\nconst double eps = 1e-12;\nint n;\nlong long l, x, y, a[N];\nmap<long long, int> mp;\nint check1(long long d) {\n  for (int i = 1; i <= n; i++) {\n    long long temp = a[i] + d;\n    if (mp[temp]) return 1;\n  }\n  return 0;\n}\nint check2() {\n  for (int i = 1; i <= n; i++) {\n    long long temp = a[i] + x + y;\n    if (mp[temp]) {\n      cout << \"1\\n\";\n      cout << a[i] + x << endl;\n      return 0;\n    }\n  }\n  long long leng = y - x;\n  for (int i = 1; i <= n; i++) {\n    long long temp = a[i] + leng;\n    if (mp[temp]) {\n      if (temp + x <= l) {\n        cout << \"1\\n\";\n        cout << temp + x << endl;\n        return 0;\n      }\n      if (a[i] - x >= 0) {\n        cout << \"1\\n\";\n        cout << a[i] - x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"2\" << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\nint main() {\n  read(n);\n  read(l);\n  read(x);\n  read(y);\n  for (int i = 1; i <= n; i++) read(a[i]), mp[a[i]] = 1;\n  int fx = check1(x), fy = check1(y);\n  if (fx && fy)\n    cout << \"0\\n\";\n  else if (fx || fy) {\n    if (fx)\n      cout << \"1\\n\" << y << endl;\n    else\n      cout << \"1\\n\" << x << endl;\n  } else\n    check2();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> st;\nint a[200001], i, j, m, n, p, k, l, x, y;\nbool check0() {\n  int i, flag = 0, flag1 = 0;\n  for (i = 1; i <= n; i++) {\n    if (*st.lower_bound(a[i] + x) == a[i] + x) flag = 1;\n    if (*st.lower_bound(a[i] + y) == a[i] + y) flag1 = 1;\n  }\n  if (flag & flag1) {\n    printf(\"0\\n\");\n    return true;\n  }\n  return false;\n}\nbool check1() {\n  int i, flag = 0, flag1 = 0;\n  for (i = 1; i <= n; i++) {\n    if (*st.lower_bound(a[i] + x) == a[i] + x) flag = 1;\n    if (*st.lower_bound(a[i] + y) == a[i] + y) flag1 = 1;\n  }\n  for (i = 1; i <= n; i++) {\n    int Flag = flag, Flag1 = flag1;\n    if (*st.lower_bound(a[i] + x) != a[i] + x && a[i] + x <= l) {\n      Flag = 1;\n      if (*st.lower_bound(a[i] + y + x) == a[i] + y + x ||\n          *st.lower_bound(a[i] - y + x) == a[i] - y + x)\n        Flag1 = 1;\n      if (Flag & Flag1) {\n        printf(\"1\\n%d\\n\", a[i] + x);\n        return true;\n      }\n    }\n    if (*st.lower_bound(a[i] - x) != a[i] - x && a[i] - x > 0) {\n      Flag = 1;\n      if (*st.lower_bound(a[i] + y - x) == a[i] + y - x ||\n          *st.lower_bound(a[i] - y - x) == a[i] - y - x)\n        Flag1 = 1;\n      if (Flag & Flag1) {\n        printf(\"1\\n%d\\n\", a[i] - x);\n        return true;\n      }\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    int Flag = flag, Flag1 = flag1;\n    if (*st.lower_bound(a[i] + y) != a[i] + y && a[i] + y <= l) {\n      Flag1 = 1;\n      if (*st.lower_bound(a[i] + x + y) == a[i] + x + y ||\n          *st.lower_bound(a[i] + y - x) == a[i] + y - x)\n        flag1 = 1;\n      if (Flag & Flag1) {\n        printf(\"1\\n%d\\n\", a[i] + y);\n        return true;\n      }\n    }\n    if (*st.lower_bound(a[i] - y) != a[i] - y && a[i] - y > 0) {\n      Flag = 1;\n      if (*st.lower_bound(a[i] - y + x) == a[i] - y + x ||\n          *st.lower_bound(a[i] - y - x) == a[i] - y - x)\n        flag1 = 1;\n      if (Flag & Flag1) {\n        printf(\"1\\n%d\\n\", a[i] - y);\n        return true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]), st.insert(a[i]);\n  if (check0()) return 0;\n  if (check1()) return 0;\n  printf(\"2\\n%d %d\\n\", x, y);\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round274;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), L = ni(), x = ni(), y = ni();\n\t\tint[] a = na(n);\n\t\tboolean repx = canrep(x, a, L);\n\t\tboolean repy = canrep(y, a, L);\n\t\tif(repx && repy){\n\t\t\tout.println(0);\n\t\t}else if(repx && !repy){\n\t\t\tout.println(1);\n\t\t\tout.println(y);\n\t\t}else if(!repx && repy){\n\t\t\tout.println(1);\n\t\t\tout.println(x);\n\t\t}else{\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int t : new int[]{a[i]-x, a[i]+x}){\n\t\t\t\t\tif(t >= 0 && t <= L){\n\t\t\t\t\t\tboolean cany = false;\n\t\t\t\t\t\tif(t-y >= 0){\n\t\t\t\t\t\t\tint ind = Arrays.binarySearch(a, t-y);\n\t\t\t\t\t\t\tif(ind >= 0){\n\t\t\t\t\t\t\t\tcany = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t+y <= L){\n\t\t\t\t\t\t\tint ind = Arrays.binarySearch(a, t+y);\n\t\t\t\t\t\t\tif(ind >= 0){\n\t\t\t\t\t\t\t\tcany = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cany){\n\t\t\t\t\t\t\tout.println(1);\n\t\t\t\t\t\t\tout.println(t);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(2);\n\t\t\tout.println(x + \" \" + y);\n\t\t}\n\t}\n\t\n\tboolean canrep(int x, int[] a, int L)\n\t{\n\t\tint n = a.length;\n\t\tint j = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(j <= i && a[i] - a[j] > x)j++;\n\t\t\tif(a[i] - a[j] == x){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nvector<int> vx;\nvector<int> vy;\nint main() {\n  int n, l, x, y, p = 0;\n  cin >> n;\n  cin >> l;\n  cin >> x;\n  cin >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    if (a[i] + x <= l) {\n      vx.push_back(a[i] + x);\n    }\n    if (a[i] - x >= 0) {\n      vx.push_back(a[i] - x);\n    }\n    if (a[i] + y <= l) {\n      vy.push_back(a[i] + y);\n    }\n    if (a[i] - y >= 0) {\n      vy.push_back(a[i] - y);\n    }\n  }\n  a[n] = 1000 * 1000 * 1000 + 5;\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  int i = 0, j = 0, k = 0;\n  bool c = false, bx = false, by = false;\n  vx.push_back(1000 * 1000 * 1000 + 6);\n  vy.push_back(1000 * 1000 * 1000 + 7);\n  for (int i = 0; i < vy.size(); i++) {\n  }\n  while (i <= n && j < vx.size() && k < vy.size()) {\n    bool b = true;\n    if (a[i] < vx[j] && a[i] < vy[k]) {\n      i++;\n      b = false;\n    }\n    if (vx[j] < a[i] && vx[j] < vy[k] && b) {\n      j++;\n      b = false;\n    }\n    if (vy[k] < a[i] && vy[k] < vx[j] && b) {\n      k++;\n      b = false;\n    }\n    if (vx[j] == a[i] && vy[k] == a[i] && b == true) {\n      i++;\n      j++;\n      k++;\n      b = false;\n      c = true;\n      bx = true;\n      by = true;\n      break;\n    }\n    if (vx[j] == vy[k] && b) {\n      c = true;\n      b = false;\n      p = vx[j];\n      j++;\n      k++;\n    }\n    if (a[i] == vx[j] && b) {\n      bx = true;\n      b = false;\n      i++;\n      j++;\n    }\n    if (a[i] == vy[k] && b) {\n      by = true;\n      i++;\n      k++;\n    }\n  }\n  bool b = true;\n  if (bx && by) {\n    cout << 0;\n  }\n  if (bx && !by) {\n    cout << 1 << endl;\n    cout << vy[0];\n  }\n  if (!bx && by) {\n    cout << 1 << endl;\n    cout << vx[0];\n  }\n  if (!bx && !by) {\n    if (c) {\n      cout << 1 << endl;\n      cout << p;\n    } else {\n      cout << 2 << endl;\n      cout << vx[0] << \" \" << vy[0];\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const MAX_N = 300100;\nunsigned int const MAX_HASH = 2000003;\nunsigned long long const HASH_CONST = 1000000000000000009ULL;\nlong long const LL_INF = 1000000000000000000LL;\nint n, L, X, Y;\nint s[MAX_N];\nstruct my_list {\n  int value;\n  my_list *next;\n};\nstruct my_ht {\n  my_list *s[MAX_HASH];\n  my_ht() {\n    for (int i = 0; i < MAX_HASH; i++) s[i] = 0;\n  }\n  void clear() {\n    for (int i = 0; i < MAX_HASH; i++)\n      if (s[i] != 0) {\n        my_list *t = s[i], *tt;\n        while (t) {\n          tt = t;\n          t = t->next;\n          delete tt;\n        }\n        s[i] = 0;\n      }\n  }\n  ~my_ht() { clear(); }\n  unsigned int get_hash(unsigned int v) {\n    return (((v + 1) * HASH_CONST)) % MAX_HASH;\n  }\n  void add(int val) {\n    unsigned int d = get_hash(val);\n    my_list *t = new my_list;\n    t->value = val;\n    t->next = s[d];\n    s[d] = t;\n  }\n  my_list *find(int val) {\n    if (val < 0 || val > L) return 0;\n    unsigned int d = get_hash(val);\n    my_list *t = s[d];\n    while (t) {\n      if (t->value == val) return t;\n      t = t->next;\n    }\n    return 0;\n  }\n} ht;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &L, &X, &Y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &s[i]);\n    ht.add(s[i]);\n  }\n  int is_X = 0, is_Y = 0;\n  for (int i = 0; i < n; i++) {\n    if ((ht.find(s[i] - X) != 0) || (ht.find(s[i] + X) != 0)) is_X = 1;\n    if ((ht.find(s[i] - Y) != 0) || (ht.find(s[i] + Y) != 0)) is_Y = 1;\n  }\n  if (is_X && is_Y) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (is_X && !is_Y) {\n    cout << \"1\\n\" << Y;\n    return 0;\n  }\n  if (!is_X && is_Y) {\n    cout << \"1\\n\" << X;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int val = s[i] - X - Y;\n    if (val >= 0 && val <= L && s[i] - Y >= 0 && s[i] - Y <= L &&\n        ht.find(val) != 0) {\n      cout << \"1\\n\" << (s[i] - Y);\n      return 0;\n    }\n    val = s[i] + X - Y;\n    if (val >= 0 && val <= L && s[i] + X >= 0 && s[i] + X <= L &&\n        ht.find(val) != 0) {\n      cout << \"1\\n\" << (s[i] + X);\n      return 0;\n    }\n    val = s[i] - X + Y;\n    if (val >= 0 && val <= L && s[i] - X >= 0 && s[i] - X <= L &&\n        ht.find(val) != 0) {\n      cout << \"1\\n\" << (s[i] - X);\n      return 0;\n    }\n  }\n  cout << \"2\\n\" << X << \" \" << Y;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst double pi = acos(-1.0);\nconst double eps = 1e-9;\nint n, a[100005], l, x, y;\nmap<int, int> cnt;\nbool ok[2];\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  cnt[0] = 1;\n  for (int i = 1; i < n; i++) {\n    int val = a[i] - x;\n    if (cnt[val] != 0) ok[0] = 1;\n    val = a[i] - y;\n    if (cnt[val] != 0) ok[1] = 1;\n    cnt[a[i]]++;\n  }\n  if (ok[1] && ok[0]) return printf(\"0\\n\"), 0;\n  if (ok[1] + ok[0] == 1) {\n    printf(\"1\\n\");\n    if (ok[0])\n      printf(\"%d\\n\", y);\n    else\n      printf(\"%d\\n\", x);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int val;\n    val = x + a[i];\n    if (cnt[val - y] && val > 0 && val <= l) {\n      printf(\"1\\n%d\\n\", val);\n      return 0;\n    }\n    val = x + a[i];\n    if (cnt[val + y] && val > 0 && val <= l) {\n      printf(\"1\\n%d\\n\", val);\n      return 0;\n    }\n    val = a[i] - x;\n    if (cnt[val + y] && val > 0 && val <= l) {\n      printf(\"1\\n%d\\n\", val);\n      return 0;\n    }\n    val = a[i] - x;\n    if (cnt[val - y] && val > 0 && val <= l) {\n      printf(\"1\\n%d\\n\", val);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &t) {\n  os << \"[\";\n  for (__typeof((t).begin()) it = (t).begin(); it != (t).end(); it++) {\n    if (it != t.begin()) os << \",\";\n    os << *it;\n  }\n  os << \"]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &t) {\n  os << \"{\";\n  for (__typeof((t).begin()) it = (t).begin(); it != (t).end(); it++) {\n    if (it != t.begin()) os << \",\";\n    os << *it;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class S, class T>\nostream &operator<<(ostream &os, const pair<S, T> &t) {\n  return os << \"(\" << t.first << \",\" << t.second << \")\";\n}\nconst int INF = 1 << 28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint n, l, x, y;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  set<int> me;\n  int f = 0, tar = 0, tar2 = 0;\n  for (int i = 0; i < (int)(n); i++) {\n    int t;\n    scanf(\"%d\", &t);\n    me.insert(t);\n    if (me.count(t - x)) f |= 1;\n    if (me.count(t - y)) f |= 2;\n    if (me.count(t - x - y)) {\n      f |= 4;\n      tar = t - x;\n    }\n    if (me.count(t + x - y)) {\n      if (t + x <= l) {\n        f |= 8;\n        tar2 = t + x;\n      } else if (0 <= t - y) {\n        f |= 8;\n        tar2 = t - y;\n      }\n    }\n  }\n  if ((f & 3) == 3)\n    puts(\"0\");\n  else if (f & 1)\n    printf(\"%d\\n%d\\n\", 1, y);\n  else if (f & 2)\n    printf(\"%d\\n%d\\n\", 1, x);\n  else if (f & 4)\n    printf(\"%d\\n%d\\n\", 1, tar);\n  else if (f & 8)\n    printf(\"%d\\n%d\\n\", 1, tar2);\n  else\n    printf(\"%d\\n%d %d\\n\", 2, x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF480B extends PrintWriter {\n\tCF480B() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF480B o = new CF480B(); o.main(); o.flush();\n\t}\n\n\tint[] aa;\n\tint n;\n\tint find(int x) {\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\twhile (j < n && aa[j] - aa[i] < x)\n\t\t\t\tj++;\n\t\t\tif (j < n && aa[j] - aa[i] == x)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tvoid main() {\n\t\tn = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\taa = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = sc.nextInt();\n\t\tint ix = find(x);\n\t\tint iy = find(y);\n\t\tif (ix != -1 && iy != -1) {\n\t\t\tprintln(0);\n\t\t\treturn;\n\t\t}\n\t\tif (ix != -1) {\n\t\t\tprintln(1);\n\t\t\tprintln(y);\n\t\t\treturn;\n\t\t}\n\t\tif (iy != -1) {\n\t\t\tprintln(1);\n\t\t\tprintln(x);\n\t\t\treturn;\n\t\t}\n\t\tint i = find(x + y), j;\n\t\tif (i != -1) {\n\t\t\tprintln(1);\n\t\t\tprintln(aa[i] + x);\n\t\t\treturn;\n\t\t}\n\t\ti = find(y - x);\n\t\tif (i != -1 && aa[i] + y <= l) {\n\t\t\tprintln(1);\n\t\t\tprintln(aa[i] + y);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0, j = n - 1; i < j; i++, j--) {\n\t\t\tint tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t\taa[i] = l - aa[i];\n\t\ti = find(y - x);\n\t\tif (i != -1 && aa[i] + y <= l) {\n\t\t\tprintln(1);\n\t\t\tprintln(l - (aa[i] + y));\n\t\t\treturn;\n\t\t}\n\t\tprintln(2);\n\t\tprintln(x + \" \" + y);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\tint n;\n\tint len;\n\tint[] a;\n\t\n\tvoid run() {\n\t\tn = in.nextInt();\n\t\tlen = in.nextInt();\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\ta = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tboolean hasX = check(x);\n\t\tboolean hasY = check(y);\n\t\tif (hasX && hasY) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tif (hasX) {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(y);\n\t\t\treturn;\n\t\t}\n\t\tif (hasY) {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(x);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\twhile (j < n - 1 && a[j] < a[i] + 0L + x + y) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (a[j] == a[i] + 0L + x + y) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(a[i] + x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint d = y - x;\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\twhile (j < n - 1 && a[j] < a[i] + d) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (a[j] == a[i] + d) {\n\t\t\t\tif (a[i] - x >= 0) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i] - x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (a[i] + y <= len) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a[i] + y);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(2);\n\t\tSystem.out.println(x + \" \" + y);\n\t}\n\n\tboolean check(int x) {\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\twhile (j < n - 1 && a[j] < a[i] + x) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (a[j] == a[i] + x) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean stdStreams = true;\n\tstatic String fileName = B.class.getSimpleName().replaceFirst(\"_.*\", \"\").toLowerCase();\n\tstatic String inputFileName = fileName + \".in\";\n\tstatic String outputFileName = fileName + \".out\";\n\tstatic MyScanner in;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tLocale.setDefault(Locale.US);\n\t\tBufferedReader br;\n\t\tif (stdStreams) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tbr = new BufferedReader(new FileReader(inputFileName));\n\t\t\tout = new PrintWriter(outputFileName);\n\t\t}\n\t\tin = new MyScanner(br);\n\t\tint tests = 1;//in.nextInt();\n\t\tfor (int test = 0; test < tests; test++) {\n\t\t\tnew B().run();\n\t\t}\n\t\tbr.close();\n\t\tout.close();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tMyScanner(BufferedReader br) {\n\t\t\tthis.br = br;\n\t\t}\n\t\t\n\t\tvoid findToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\tfindToken();\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n// Solution is at the bottom of code\n\npublic class B implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new B(), \"\", 128 * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tok.nextToken(delim);\n\t}\n\t\n\tString readLine() throws IOException{\n\t\treturn in.readLine();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() throws IOException{\n\t\tint intValue = in.read();\n\t\t\n\t\tif (intValue == -1){\n\t\t\treturn NOT_A_SYMBOL;\n\t\t}\n\t\t\n\t\treturn (char) intValue;\n\t}\n\t\n\tchar[] readCharArray() throws IOException{\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) throws IOException {\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\tArrays.sort(array);\n\t\t\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\t\t\n\t\treturn sortedArray;\n\t}\n\t\n\tint[] readIntArrayWithDecrease(int size) throws IOException {\n\t\tint[] array = readIntArray(size);\n\t\t\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tarray[i]--;\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tint[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArray(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\tint[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) throws IOException{\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) throws IOException{\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\t\n\tBigInteger readBigInteger() throws IOException {\n\t\treturn new BigInteger(readString());\n\t}\n\t\n\tBigDecimal readBigDecimal() throws IOException {\n\t\treturn new BigDecimal(readString());\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() throws IOException{\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) throws IOException{\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber)\n\tthrows IOException{\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IntIndexPair {\n\t\t\n\t\tstatic Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return value1 - value2;\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstatic Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return -(value1 - value2);\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tint value, index;\n\n\t\tpublic IntIndexPair(int value, int index) {\n\t\t\tsuper();\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\t\t\n\t\t\n\t\tpublic int getRealIndex() {\n\t\t\treturn index + 1;\n\t\t}\n\t}\n\t\n\tIntIndexPair[] readIntIndexArray(int size) throws IOException {\n\t\tIntIndexPair[] array = new IntIndexPair[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = new IntIndexPair(readInt(), index);\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class OutputWriter extends PrintWriter {\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tprotected int precision;\n\t\tprotected String format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tprecision = max(0, precision);\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tstatic final int[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tstatic final boolean check(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final boolean checkBit(int mask, int bit){\n\t\treturn (mask & (1 << bit)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final long getSum(int[] array) {\n\t\tlong sum = 0;\n\t\tfor (int value: array) {\n\t\t\tsum += value;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tstatic final Point getMinMax(int[] array) {\n\t\tint min = array[0];\n\t\tint max = array[0];\n\t\t\n\t\tfor (int index = 0, size = array.length; index < size; ++index, ++index) {\n\t\t\tint value = array[index];\n\t\t\t\n\t\t\tif (index == size - 1) {\n\t\t\t\tmin = min(min, value);\n\t\t\t\tmax = max(max, value);\n\t\t\t} else {\n\t\t\t\tint otherValue = array[index + 1];\n\t\t\t\t\n\t\t\t\tif (value <= otherValue) {\n\t\t\t\t\tmin = min(min, value);\n\t\t\t\t\tmax = max(max, otherValue);\n\t\t\t\t} else {\n\t\t\t\t\tmin = min(min, otherValue);\n\t\t\t\t\tmax = max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Point(min, max);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tint l = readInt();\n\t\t\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\t\n\t\tint[] a = readIntArray(n);\n\t\t\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tset.add(a[i]);\n\t\t}\n\t\t\n\t\tboolean existX = false, existY = false;\n\t\t\n\t\tSet<Integer> needForX = new HashSet<Integer>();\n\t\tSet<Integer> needForY = new HashSet<Integer>();\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint downX = a[i] - x;\n\t\t\tif (check(downX, l)) {\n\t\t\t\tif (set.contains(downX)) {\n\t\t\t\t\texistX = true;\n\t\t\t\t} else {\n\t\t\t\t\tneedForX.add(downX);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint upX = a[i] + x;\n\t\t\tif (check(upX, l)) {\n\t\t\t\tif (set.contains(upX)) {\n\t\t\t\t\texistX = true;\n\t\t\t\t} else {\n\t\t\t\t\tneedForX.add(upX);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint downY = a[i] - y;\n\t\t\tif (check(downY, l)) {\n\t\t\t\tif (set.contains(downY)) {\n\t\t\t\t\texistY = true;\n\t\t\t\t} else {\n\t\t\t\t\tneedForY.add(downY);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint upY = a[i] + y;\n\t\t\tif (check(upY, l)) {\n\t\t\t\tif (set.contains(upY)) {\n\t\t\t\t\texistY = true;\n\t\t\t\t} else {\n\t\t\t\t\tneedForY.add(upY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Integer> answer = new ArrayList<Integer>();\n\t\tif (existX && existY) {\n\t\t\t\n\t\t} else if (existX) {\n\t\t\tfor (int i : needForY) {\n\t\t\t\tanswer.add(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (existY) {\n\t\t\tfor (int i : needForX) {\n\t\t\t\tanswer.add(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i : needForX) {\n\t\t\t\tif (needForY.contains(i)) {\n\t\t\t\t\tanswer.add(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (answer.size() == 0) {\n\t\t\t\tfor (int i : needForY) {\n\t\t\t\t\tanswer.add(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i : needForX) {\n\t\t\t\t\tanswer.add(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(answer.size());\n\t\tfor (int i : answer) {\n\t\t\tout.print(i + \" \");\n\t\t}\n\t\tout.println();\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, int> flag;\nint main() {\n  long long n, x, y, l;\n  int cx = 0, cy = 0, cxy = 0, cyx = 0;\n  cin >> n >> l >> x >> y;\n  for (long long i = 0; i < n; i++) {\n    long long t;\n    cin >> t;\n    flag[t] = 1;\n    if (x == t || flag.count(t - x)) {\n      cx = 1;\n    }\n    if (y == t || flag.count(t - y)) {\n      cy = 1;\n    }\n    if (flag.count(t - (x + y))) {\n      cxy = t - y;\n    }\n    if (flag.count(t - (y - x))) {\n      if (t + x < l) {\n        cyx = t + x;\n      } else if (t - y > 0) {\n        cyx = t - y;\n      }\n    }\n  }\n  if (cx && cy) {\n    cout << \"0\" << endl;\n  } else if (cx == 0 && cy == 1) {\n    cout << \"1\" << endl;\n    cout << x << endl;\n  } else if (cx == 1 && cy == 0) {\n    cout << \"1\" << endl;\n    cout << y << endl;\n  } else if (cxy) {\n    cout << \"1\" << endl;\n    cout << cxy << endl;\n  } else if (cyx) {\n    cout << \"1\" << endl;\n    cout << cyx << endl;\n  } else if (cx == 0 && cy == 0) {\n    cout << \"2\" << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[100123], l, x, y;\nvector<pair<int, int> > all;\npair<int, int> f(long long v) {\n  long long sum = 0;\n  int r = 1;\n  pair<int, int> ret;\n  all.clear();\n  for (int l = 1; l <= n; ++l) {\n    while (a[r] - a[l] < v) r++;\n    if (a[r] - a[l] == v) {\n      all.push_back(pair<int, int>(l, r));\n      ret = pair<int, int>(l, r);\n    }\n  }\n  if (((int)((all).size()))) return ret;\n  return pair<int, int>(0, 0);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  scanf(\" %d %lld %lld %lld\", &n, &l, &x, &y);\n  long long val;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\" %lld\", &a[i]);\n  }\n  a[n + 1] = (1LL << 62);\n  pair<int, int> temx = f(x);\n  pair<int, int> temy = f(y);\n  if (!temx.first && !temy.first) {\n    pair<int, int> temxy = f(x + y);\n    if (temxy.first) {\n      printf(\"1\\n%lld\\n\", a[temxy.first] + x);\n    } else {\n      temxy = f(y - x);\n      if (temxy.first) {\n        for (int i = 0; i < ((int)((all).size())); ++i) {\n          temxy = all[i];\n          if (a[temxy.second] + x < l) {\n            printf(\"1\\n%lld\\n\", a[temxy.second] + x);\n            return 0;\n          } else if (a[temxy.first] - x > 0) {\n            printf(\"1\\n%lld\\n\", a[temxy.first] - x);\n            return 0;\n          }\n        }\n        printf(\"2\\n%lld %lld\\n\", x, y);\n      } else {\n        printf(\"2\\n%lld %lld\\n\", x, y);\n      }\n    }\n  } else if (!temx.first && temy.first) {\n    printf(\"1\\n%lld\\n\", x);\n  } else if (temx.first && !temy.first) {\n    printf(\"1\\n%lld\\n\", y);\n  } else {\n    printf(\"0\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint n, a[100001], x, y, l;\nint find() {\n  for (int i = 1; i <= n; i++) {\n    if (a[i] + x <= l && (s.count(a[i] + x + y) || s.count(a[i] + x - y)))\n      return a[i] + x;\n    if (a[i] - x >= 0 && (s.count(a[i] - x + y) || s.count(a[i] - x - y)))\n      return a[i] - x;\n  }\n  return -1;\n}\nint check(int m) {\n  for (int i = 1; i <= n; i++)\n    if (s.count(a[i] - m)) return 1;\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  int tx = check(x);\n  int ty = check(y);\n  if (tx && ty)\n    printf(\"0\\n\");\n  else if (tx && !ty)\n    printf(\"1\\n%d\\n\", y);\n  else if (!tx && ty)\n    printf(\"1\\n%d\\n\", x);\n  else {\n    int flag = find();\n    if (flag == -1)\n      printf(\"2\\n%d %d\\n\", x, y);\n    else\n      printf(\"1\\n%d\\n\", flag);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint main() {\n  int n, la, x, y, dl, a;\n  cin >> n >> la >> x >> y;\n  bool f1 = 0, f2 = 0, f3 = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a;\n    if (a - x >= 0 && s.count(a - x)) {\n      f1 = 1;\n    }\n    if (a - y >= 0 && s.count(a - y)) {\n      f2 = 1;\n    }\n    if (a - x - y >= 0 && s.count(a - x - y)) {\n      f3 = 1;\n      dl = a - y;\n    }\n    if (a - y >= 0 && s.count(a - y + x)) {\n      f3 = 1;\n      dl = a - y;\n    }\n    if (a + x <= la && s.count(a + x - y)) {\n      f3 = 1;\n      dl = a + x;\n    }\n    s.insert(a);\n  }\n  if (f1 && f2) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (f1) {\n    cout << 1 << endl << y;\n    return 0;\n  }\n  if (f2) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  if (f3) {\n    cout << 1 << endl << dl;\n    return 0;\n  }\n  cout << 2 << endl << x << \" \" << y;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100100];\nint main() {\n  int n, l, x, y;\n  int i;\n  set<int> s;\n  set<int>::iterator st;\n  set<int>::iterator st1;\n  set<int>::iterator st2;\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) == 4) {\n    s.clear();\n    for (i = 0; i < n; i++) {\n      scanf(\"%d\", &a[i]);\n      s.insert(a[i]);\n    }\n    st = s.end();\n    int flagx = 0, flagy = 0;\n    for (i = 0; i < n; i++) {\n      if (s.find(a[i] + x) != st) {\n        flagx = 1;\n      }\n      if (s.find(a[i] + y) != st) {\n        flagy = 1;\n      }\n    }\n    if (flagx == 1 && flagy == 1) {\n      printf(\"0\\n\");\n      continue;\n    }\n    if ((flagx != 0 && flagy == 0) || (flagx == 0 && flagy != 0)) {\n      int make;\n      if (flagx == 1) make = y;\n      if (flagy == 1) make = x;\n      printf(\"1\\n%d\\n\", make);\n      continue;\n    } else {\n      int flag = 0;\n      for (i = 0; i < n; i++) {\n        if (s.find(a[i] + x + y) != st && (a[i] + x) <= l) {\n          printf(\"1\\n%d\\n\", a[i] + x);\n          flag = 1;\n          break;\n        }\n        if (s.find(a[i] + x - y) != st && (a[i] + x) <= l) {\n          printf(\"1\\n%d\\n\", a[i] + x);\n          flag = 1;\n          break;\n        }\n        if (s.find(a[i] + y - x) != st && (a[i] + y) <= l) {\n          printf(\"1\\n%d\\n\", a[i] + y);\n          flag = 1;\n          break;\n        }\n        if (s.find(a[i] - x + y) != st && (a[i] - x) >= 0) {\n          printf(\"1\\n%d\\n\", a[i] - x);\n          flag = 1;\n          break;\n        }\n        if (s.find(a[i] - y + x) != st && (a[i] - y) >= 0) {\n          printf(\"1\\n%d\\n\", a[i] - y);\n          flag = 1;\n          break;\n        }\n      }\n      if (flag == 0) {\n        printf(\"2\\n%d %d\\n\", x, y);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid open() {\n  freopen(\"jumps.in\", \"r\", stdin);\n  freopen(\"jumps.out\", \"w\", stdout);\n}\nint n, l, x, y;\nint ke[100010];\nmap<int, bool> mat;\nbool vx, vy;\nbool in(int x) { return x >= 0 && x <= l; }\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", ke + i), mat[ke[i]] = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (!vx && mat.count(ke[i] + x)) {\n      vx = 1;\n    }\n    if (!vy && mat.count(ke[i] + y)) {\n      vy = 1;\n    }\n    if (vx && vy) {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  if (vx || vy) {\n    printf(\"1\\n%d\\n\", vx ? y : x);\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (mat.count(ke[i] + x + y)) {\n      printf(\"1\\n%d\\n\", ke[i] + x);\n      return 0;\n    }\n    if (mat.count(ke[i] + y - x) && in(ke[i] + y)) {\n      printf(\"1\\n%d\\n\", ke[i] + y);\n      return 0;\n    }\n    if (mat.count(ke[i] - y + x) && in(ke[i] - y)) {\n      printf(\"1\\n%d\\n\", ke[i] - y);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100200];\nint main(int argc, char const *argv[]) {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  sort(a, a + n);\n  int flagx = 0, flagy = 0;\n  int posx, posy;\n  for (int i = 0; i < n; i++) {\n    int tmp = a[i] + x;\n    posx = lower_bound(a, a + n, tmp) - a;\n    if (a[posx] == tmp) {\n      flagx = 1;\n      break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int tmp = a[i] + y;\n    posy = lower_bound(a, a + n, tmp) - a;\n    if (a[posy] == tmp) {\n      flagy = 1;\n      break;\n    }\n  }\n  if (flagx && flagy) {\n    printf(\"%d\\n\", 0);\n    return 0;\n  } else if (flagx && !flagy) {\n    printf(\"%d\\n\", 1);\n    printf(\"%d\\n\", y);\n    return 0;\n  } else if (!flagx && flagy) {\n    printf(\"%d\\n\", 1);\n    printf(\"%d\\n\", x);\n    return 0;\n  } else {\n    for (int i = 0; i < n; i++) {\n      int tmp = a[i] - x;\n      if (tmp > l) break;\n      tmp += y;\n      int pos1 = lower_bound(a, a + n, tmp) - a;\n      tmp -= y;\n      tmp -= y;\n      int pos2 = lower_bound(a, a + n, tmp) - a;\n      if (a[i] - x >= 0 && (tmp + 2 * y == a[pos1] || tmp == a[pos2])) {\n        printf(\"%d\\n\", 1);\n        printf(\"%d\\n\", a[i] - x);\n        return 0;\n      }\n      tmp = a[i] + x;\n      tmp += y;\n      pos1 = lower_bound(a, a + n, tmp) - a;\n      tmp -= y;\n      tmp -= y;\n      pos2 = lower_bound(a, a + n, tmp) - a;\n      if (a[i] + x <= l && (tmp + 2 * y == a[pos1] || tmp == a[pos2])) {\n        printf(\"%d\\n\", 1);\n        printf(\"%d\\n\", a[i] + x);\n        return 0;\n      }\n    }\n    printf(\"%d\\n\", 2);\n    printf(\"%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nn, l , x, y = map(int, raw_input().split())\ndata = map(int, raw_input().split())\n\ndef search(val):\n    i = 0\n    j = 1\n    ans = []\n    while i<n-1:\n        while j<n:\n            if data[j]-data[i] == val:\n                ans.append(i)\n                j += 1\n                break\n            elif data[j]-data[i] < val:\n                j += 1\n            else:\n                break\n        i += 1\n    return ans\n\nxflag = search(x)\nyflag = search(y)\nif len(xflag) and len(yflag):\n    print 0\nelif not len(xflag) and not len(yflag):\n    z = search(y-x)\n    zz = search(x+y)\n    if len(z):\n        for zi in z:\n            if data[zi]+y<=l:\n                print 1\n                print data[zi]+y\n                sys.exit(0)\n            elif data[zi]-x>=0:\n                print 1\n                print data[zi]-x\n                sys.exit(0)\n    if len(zz):\n        print 1\n        print data[zz[0]]+x\n        sys.exit(0)\n    print 2\n    print x,y\nelif not len(xflag):\n    print 1\n    print x\nelif not len(yflag):\n    print 1\n    print y\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn Agrawal coderbond007\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int l = in.nextInt();\n            int x = in.nextInt();\n            int y = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            Set<Integer> set = new HashSet<>(n);\n            for (int i = 0; i < n; ++i) {\n                set.add(a[i]);\n            }\n            boolean xCan = false, yCan = false;\n            for (int i : set) {\n                if (set.contains(i + x)) xCan = true;\n                if (set.contains(i + y)) yCan = true;\n            }\n\n            if (xCan && yCan) {\n                out.println(0);\n            } else if (xCan && !yCan) {\n                out.println(1);\n                out.println(y);\n            } else if (!xCan && yCan) {\n                out.println(1);\n                out.println(x);\n            } else {\n                set.clear();\n                for (int i = 0; i < n; i++) {\n                    if (a[i] - x >= 0) set.add(a[i] - x);\n                }\n                for (int i = 0; i < n; i++) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n                set.clear();\n                for (int i = 0; i < n; i++) {\n                    if (a[i] + x <= l) {\n                        set.add(a[i] + x);\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n            return;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = read();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100001;\nint n, l, x, y, a[maxn];\nbool calc(int x) {\n  if (x < 0 || x > l) return 0;\n  int k = lower_bound(a + 1, a + n + 1, x) - a;\n  return (x == a[k]);\n}\nvoid get() {\n  int ans = 0, i;\n  for (i = 1; i <= n; i++) {\n    if (calc(a[i] - x) || calc(a[i] + x)) ans |= 1;\n    if (calc(a[i] - y) || calc(a[i] + y)) ans |= 2;\n  }\n  if (ans == 3)\n    printf(\"0\\n\");\n  else if (ans == 2)\n    printf(\"1\\n%d\\n\", x);\n  else if (ans == 1)\n    printf(\"1\\n%d\\n\", y);\n  else {\n    for (i = 1; i <= n; i++) {\n      int tx = a[i] + x, ty = a[i] + y;\n      if (tx <= l && (calc(tx - y) || calc(tx + y))) {\n        printf(\"1\\n%d\\n\", tx);\n        return;\n      }\n      if (ty <= l && (calc(ty - x) || calc(ty + x))) {\n        printf(\"1\\n%d\\n\", ty);\n        return;\n      }\n    }\n    for (i = 1; i <= n; i++) {\n      int tx = a[i] - x, ty = a[i] - y;\n      if (tx >= 0 && (calc(tx - y) || calc(tx + y))) {\n        printf(\"1\\n%d\\n\", tx);\n        return;\n      }\n      if (ty >= 0 && (calc(ty - x) || calc(ty + x))) {\n        printf(\"1\\n%d\\n\", ty);\n        return;\n      }\n    }\n    printf(\"2\\n%d %d\\n\", x, y);\n  }\n}\nint main() {\n  int i;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  get();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> H;\nvector<int> r;\nint n, l, x, y;\nbool valid(int tmp) { return tmp >= 0 && tmp <= l; }\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    int ha;\n    scanf(\"%d\", &ha);\n    H.insert(ha);\n  }\n  r.push_back(x);\n  r.push_back(y);\n  bool suc1 = false;\n  for (set<int>::iterator it = H.begin(); it != H.end(); it++) {\n    int me = *it;\n    int nt = me - x;\n    if (H.count(nt)) {\n      suc1 = true;\n      if (r.size() == 2) {\n        r.clear();\n        r.push_back(y);\n      }\n    } else if (valid(nt)) {\n      if (H.count(nt + y) || H.count(nt - y)) {\n        if (r.size() == 2) {\n          r.clear();\n          r.push_back(nt);\n        }\n      }\n    }\n    nt = me + x;\n    if (H.count(nt)) {\n      suc1 = true;\n      if (r.size() == 2) {\n        r.clear();\n        r.push_back(y);\n      }\n    } else if (valid(nt)) {\n      if (H.count(nt + y) || H.count(nt - y)) {\n        if (r.size() == 2) {\n          r.clear();\n          r.push_back(nt);\n        }\n      }\n    }\n  }\n  bool suc2 = false;\n  for (set<int>::iterator it = H.begin(); it != H.end(); it++) {\n    int me = *it;\n    int nt = me - y;\n    if (H.count(nt)) {\n      suc2 = true;\n      if (r.size() == 2) {\n        r.clear();\n        r.push_back(x);\n      }\n    } else if (valid(nt)) {\n      if (H.count(nt + x) || H.count(nt - x)) {\n        if (r.size() == 2) {\n          r.clear();\n          r.push_back(nt);\n        }\n      }\n    }\n    nt = me + y;\n    if (H.count(nt)) {\n      suc2 = true;\n      if (r.size() == 2) {\n        r.clear();\n        r.push_back(x);\n      }\n    } else if (valid(nt)) {\n      if (H.count(nt + x) || H.count(nt - x)) {\n        if (r.size() == 2) {\n          r.clear();\n          r.push_back(nt);\n        }\n      }\n    }\n  }\n  if (suc1 && suc2) r.clear();\n  printf(\"%d\\n\", (int)r.size());\n  for (int i = 0; i < r.size(); i++) {\n    printf(\"%d\\n\", r[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint toInt(string s) {\n  int r = 0;\n  istringstream sin(s);\n  sin >> r;\n  return r;\n}\nlong long toInt64(string s) {\n  long long r = 0;\n  istringstream sin(s);\n  sin >> r;\n  return r;\n}\ndouble toDouble(string s) {\n  double r = 0;\n  istringstream sin(s);\n  sin >> r;\n  return r;\n}\nstring toString(long long n) {\n  string s, s1;\n  while (n / 10 > 0) {\n    s += (char)((n % 10) + 48);\n    n /= 10;\n  }\n  s += (char)((n % 10) + 48);\n  n /= 10;\n  s1 = s;\n  for (long long i = 0; i < s.length(); i++) s1[(s.length() - 1) - i] = s[i];\n  return s1;\n}\nbool isUpperCase(char c) { return c >= 'A' && c <= 'Z'; }\nbool isLowerCase(char c) { return c >= 'a' && c <= 'z'; }\nbool isLetter(char c) { return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z'; }\nbool isDigit(char c) { return c >= '0' && c <= '9'; }\nchar toLowerCase(char c) { return (isUpperCase(c)) ? (c + 32) : c; }\nchar toUpperCase(char c) { return (isLowerCase(c)) ? (c - 32) : c; }\nlong long gcd(long long a, long long b) {\n  if (!a) return b;\n  return gcd(b % a, a);\n}\nvector<long long> q;\nlong long a[100001];\nlong long n, l;\nbool two(long long x) {\n  long long sum = 0;\n  long long f = 0, s = -1;\n  long long len = q.size();\n  while (f < len && s < len) {\n    if (sum == x)\n      return true;\n    else if (sum < x) {\n      if (s + 1 >= len) return false;\n      sum += q[++s];\n    } else if (sum > x)\n      sum -= q[f++];\n  }\n  if (sum == x) return true;\n  return false;\n}\nvector<long long> find(long long x) {\n  vector<long long> ans;\n  ans.push_back(x);\n  ans.push_back(l - x);\n  for (long long i = 1; i < n - 1; i++) {\n    if (a[i] + x <= l) ans.push_back(a[i] + x);\n    if (a[i] - x >= 0) ans.push_back(a[i] - x);\n  }\n  return ans;\n}\nlong long common(vector<long long> x, vector<long long> y) {\n  map<long long, bool> mark;\n  for (long long i = 0; i < x.size(); i++) mark[x[i]] = true;\n  for (long long j = 0; j < y.size(); j++)\n    if (mark[y[j]] == true) return y[j];\n  return -1;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  long long x, y;\n  cin >> n >> l >> x >> y;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    if (i != 0) q.push_back(a[i] - a[i - 1]);\n  }\n  bool X = two(x), Y = two(y);\n  long long bads = 0;\n  if (!X) bads++;\n  if (!Y) bads++;\n  if (bads == 0)\n    cout << 0 << endl;\n  else if (bads == 1) {\n    cout << 1 << endl;\n    if (!X)\n      cout << x << endl;\n    else\n      cout << y << endl;\n  } else if (bads == 2) {\n    vector<long long> comA = find(x);\n    vector<long long> comB = find(y);\n    long long point = common(comA, comB);\n    if (point == -1)\n      cout << 2 << endl << x << ' ' << y << endl;\n    else\n      cout << 1 << endl << point << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, y, l;\nvector<int> ruler;\nvector<int> X;\nvector<int> Y;\nint xFound;\nint yFound;\nint isThere(int x, vector<int> &v) {\n  if (binary_search(v.begin(), v.end(), x)) return 1;\n  return 0;\n}\nint checkZero() {\n  for (int i = 0; i < n; i++) {\n    int toAdd = ruler[i] - x;\n    if (isThere(toAdd, ruler)) {\n      xFound = 1;\n    }\n    if (toAdd >= 0) X.push_back(toAdd);\n    toAdd = ruler[i] + x;\n    if (isThere(toAdd, ruler)) {\n      xFound = 1;\n    }\n    if (toAdd <= l) X.push_back(toAdd);\n    toAdd = ruler[i] - y;\n    if (isThere(toAdd, ruler)) {\n      yFound = 1;\n    }\n    if (toAdd >= 0) Y.push_back(toAdd);\n    toAdd = ruler[i] + y;\n    if (isThere(toAdd, ruler)) {\n      yFound = 1;\n    }\n    if (toAdd <= l) Y.push_back(toAdd);\n  }\n  return (xFound + yFound == 2);\n}\nint checkOne() {\n  sort(X.begin(), X.end());\n  sort(Y.begin(), Y.end());\n  if (xFound == 1 && yFound == 0) {\n    cout << 1 << endl;\n    cout << y << endl;\n    return 1;\n  }\n  if (yFound == 1 && xFound == 0) {\n    cout << 1 << endl;\n    cout << x << endl;\n    return 1;\n  }\n  int size = X.size();\n  for (int i = 0; i < size; i++) {\n    if (isThere(X[i], Y)) {\n      cout << 1 << endl;\n      cout << X[i] << endl;\n      return 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    ruler.push_back(a);\n  }\n  if (checkZero()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (checkOne()) {\n    return 0;\n  }\n  int len = X.size();\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    int z;\n    scanf(\"%d\", &z);\n    a.push_back(z);\n  }\n  sort(a.begin(), a.end());\n  bool f1 = binary_search(a.begin(), a.end(), x);\n  bool f2 = binary_search(a.begin(), a.end(), y);\n  for (int i = 0; i < n; i++) {\n    if (binary_search(a.begin(), a.end(), a[i] + y)) {\n      f2 = true;\n    }\n    if (binary_search(a.begin(), a.end(), a[i] - y)) {\n      f2 = true;\n    }\n    if (binary_search(a.begin(), a.end(), a[i] + x)) {\n      f1 = true;\n    }\n    if (binary_search(a.begin(), a.end(), a[i] - x)) {\n      f1 = true;\n    }\n  }\n  if (f1 && f2) {\n    cout << 0;\n    return 0;\n  }\n  if (f1) {\n    cout << 1 << endl;\n    cout << y;\n    return 0;\n  }\n  if (f2) {\n    cout << 1 << endl;\n    cout << x;\n    return 0;\n  }\n  int result = -1;\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x <= a[n - 1]) {\n      if (binary_search(a.begin(), a.end(), a[i] + x - y) ||\n          binary_search(a.begin(), a.end(), a[i] + x + y)) {\n        result = a[i] + x;\n        break;\n      }\n    }\n    if (a[i] - x >= a[0]) {\n      if (binary_search(a.begin(), a.end(), a[i] - x - y) ||\n          binary_search(a.begin(), a.end(), a[i] - x + y)) {\n        result = a[i] - x;\n        break;\n      }\n    }\n    if (a[i] + y <= a[n - 1]) {\n      if (binary_search(a.begin(), a.end(), a[i] + y - x) ||\n          binary_search(a.begin(), a.end(), a[i] + y + x)) {\n        result = a[i] + y;\n        break;\n      }\n    }\n    if (a[i] - y >= a[0]) {\n      if (binary_search(a.begin(), a.end(), a[i] - y - x) ||\n          binary_search(a.begin(), a.end(), a[i] - x + y)) {\n        result = a[i] - y;\n        break;\n      }\n    }\n  }\n  if (result != -1) {\n    cout << 1 << endl;\n    cout << result;\n  } else {\n    cout << 2 << endl;\n    cout << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long l, x, y, arr[100005];\nmap<long long, bool> b;\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%I64d%I64d%I64d\", &l, &x, &y);\n  arr[0] = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &arr[i]);\n    b[arr[i]] = 1;\n  }\n  int c = 100000;\n  long long sol;\n  bool first = 0, second = 0;\n  for (int i = 0; i < n + 1; i++) {\n    if (b[arr[i] + x]) {\n      first = 1;\n    }\n    if (b[arr[i] + y]) {\n      second = 1;\n    }\n  }\n  if (first && second) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (first) {\n    printf(\"1\\n%I64d\\n\", y);\n    return 0;\n  }\n  if (second) {\n    printf(\"1\\n%I64d\\n\", x);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (b[arr[i] + x + y]) {\n      printf(\"1\\n%I64d\\n\", arr[i] + x);\n      return 0;\n    }\n    if (b[arr[i] - x + y] && arr[i] - x >= 0) {\n      printf(\"1\\n%I64d\\n\", arr[i] - x);\n      return 0;\n    }\n    if (b[arr[i] - x + y] && arr[i] + y <= l) {\n      printf(\"1\\n%I64d\\n\", arr[i] + y);\n      return 0;\n    }\n    if (b[arr[i] + x - y] && arr[i] - y >= 0) {\n      printf(\"1\\n%I64d\\n\", arr[i] - y);\n      return 0;\n    }\n    if (b[arr[i] + x - y] && arr[i] + x <= l) {\n      printf(\"1\\n%I64d\\n\", arr[i] + x);\n      return 0;\n    }\n  }\n  printf(\"2\\n%I64d %I64d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long l, x, y;\nvector<long long> a;\nmap<long long, long long> m;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> l >> x >> y;\n  long long s = 0;\n  bool ok1, ok2;\n  ok1 = ok2 = false;\n  a = vector<long long>(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    if (m.count(a[i] - x)) {\n      ok1 = true;\n    }\n    if (m.count(a[i] - y)) {\n      ok2 = true;\n    }\n    m[a[i]] = 1;\n  }\n  if (x + y == 0) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (ok1 & ok2) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (ok1) {\n    cout << \"1\\n\";\n    cout << y << \"\\n\";\n    return 0;\n  }\n  if (ok2) {\n    cout << \"1\\n\";\n    cout << x << \"\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int l1 = upper_bound(a.begin(), a.end(), a[i] + x - y) - a.begin();\n    if (l1 && a[l1 - 1] == a[i] + x - y && a[i] + x <= a[n - 1]) {\n      cout << \"1\\n\" << a[i] + x << '\\n';\n      return 0;\n    }\n    l1 = upper_bound(a.begin(), a.end(), a[i] + x + y) - a.begin();\n    if (l1 && a[l1 - 1] == a[i] + x + y && a[i] + x <= a[n - 1]) {\n      cout << \"1\\n\" << a[i] + x << '\\n';\n      return 0;\n    }\n    l1 = upper_bound(a.begin(), a.end(), a[i] - x + y) - a.begin();\n    if (l1 && a[l1 - 1] == a[i] - x + y && a[i] - x >= 0) {\n      cout << \"1\\n\" << a[i] - x << '\\n';\n      return 0;\n    }\n    l1 = upper_bound(a.begin(), a.end(), a[i] - x - y) - a.begin();\n    if (l1 && a[l1 - 1] == a[i] - x - y && a[i] - x >= 0) {\n      cout << \"1\\n\" << a[i] - x << '\\n';\n      return 0;\n    }\n  }\n  cout << \"2\\n\";\n  cout << x << \" \" << y << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int N = 1e5 + 5;\nconst long long int mod = 1e17 + 7;\nset<long long int> s;\nbool gi, bo;\nlong long int res = 0;\nlong long int c[5];\nint main() {\n  ios::sync_with_stdio(false);\n  long long int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (long long int i = 1; i < n + 1; i++) {\n    long long int z;\n    cin >> z;\n    s.insert(z);\n    if (s.count(z - x) or s.count(z + x)) {\n      gi = 1;\n    }\n    if (s.count(z - y) or s.count(z + y)) {\n      bo = 1;\n    }\n    if (gi == 1 and bo == 1) {\n      cout << \"0\\n\";\n      return 0;\n    }\n    if (res != 1) {\n      if (s.count(z - x - y)) {\n        res = 1;\n        c[1] = z - x;\n      }\n      if (s.count(z + x + y)) {\n        res = 1;\n        c[1] = z + x;\n      }\n      if (s.count(z + x - y) and z + x <= l) {\n        res = 1;\n        c[1] = z + x;\n      }\n      if (s.count(z - x + y) and z + y <= l) {\n        res = 1;\n        c[1] = z + y;\n      }\n      if (s.count(z + x - y) and z - y >= 0) {\n        res = 1;\n        c[1] = z - y;\n      }\n      if (s.count(z - x + y) and z - x >= 0) {\n        res = 1;\n        c[1] = z - x;\n      }\n    }\n  }\n  if (res != 1) {\n    res = 0;\n    if (!gi) {\n      res++;\n      c[res] = x;\n      s.insert(x);\n    }\n    if (!bo) {\n      res++;\n      c[res] = y;\n    }\n  }\n  cout << res << endl;\n  for (long long int i = 1; i < res + 1; i++) {\n    cout << c[i] << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class LongJumps {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder qq = new StringBuilder();\n\n\t\tString yy[] = in.readLine().split(\" \");\n\t\tint n = Integer.parseInt(yy[0]);\n\t\tint m = Integer.parseInt(yy[1]);\n\t\tint x = Integer.parseInt(yy[2]);\n\t\tint y = Integer.parseInt(yy[3]);\n\n\t\tint a[] = new int[n];\n\t\tyy = in.readLine().split(\" \");\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = Integer.parseInt(yy[i]);\n\n\t\tboolean boy = false;\n\t\tboolean girl = false;\n\t\tint diff = -1;\n\t\tint sum = -1;\n\t\tint d = y - x;\n\t\tint s = y + x;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint g = a[i] + x;\n\t\t\tint b = a[i] + y;\n\t\t\tint bb = Arrays.binarySearch(a, (a[i] + d));\n\n\t\t\tif (bb >= 0&&diff==-1) {\n\t\t\t\tif (a[i] - x >= 0){\n\t\t\t\t\tdiff = a[i] - x;\n\t\t\t\t}\n\t\t\t\telse if (a[i] + y <= m)\n\t\t\t\t\tdiff = a[i] + y;\n\t\t\t}\n\n\t\t\tint ss = Arrays.binarySearch(a, (a[i] + s));\n\n\t\t\tif (ss >= 0&&sum==-1) {\n\t\t\t\tif (x + a[i] <= m)\n\t\t\t\t\tsum = x + a[i];\n\t\t\t}\n\t\t\tif (g > m)\n\t\t\t\tcontinue;\n\t\t\tint bin = Arrays.binarySearch(a, g);\n\t\t\tif (bin >= 0) {\n\t\t\t\tgirl = true;\n\t\t\t}\n\n\t\t\tif (b > m)\n\t\t\t\tcontinue;\n\n\t\t\tbin = Arrays.binarySearch(a, b);\n\t\t\tif (bin >= 0) {\n\t\t\t\tboy = true;\n\t\t\t}\n\t\t}\n\n\t\tif (boy && girl)\n\t\t\tSystem.out.println(0);\n\t\telse if (!boy && !girl) {\n\t\t\tif (diff != -1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(diff);\n\t\t\t} else if (sum != -1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(sum);\n\t\t\t} else if (y + a[0] <= m) {\n\t\t\t\tSystem.out.println(2);\n\t\t\t\tSystem.out.println((x + a[0]) + \" \" + (y + a[0]));\n\t\t\t} else {\n\t\t\t\tSystem.out.println(3);\n\t\t\t\tSystem.out.println(0 + \" \" + x + \" \" + y);\n\t\t\t}\n\t\t} else {\n\n\t\t\tif (!girl) {\n\t\t\t\tif (x + a[0] <= m) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println((x + a[0]));\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t\tSystem.out.println(0 + \" \" + x);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (y + a[0] <= m) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println((y + a[0]));\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(0 + \" \" + y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static Scanner entrada = new Scanner(System.in);\n\tstatic PrintWriter saida = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = entrada.nextInt(), l = entrada.nextInt(), x = entrada.nextInt(), y = entrada\n\t\t\t\t.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = entrada.nextInt();\n\n\t\tboolean forGirl = false, forBoy = false;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (binarySearch(a, a[i] + x))\n\t\t\t\tforGirl = true;\n\t\t\tif (binarySearch(a, a[i] + y))\n\t\t\t\tforBoy = true;\n\t\t}\n\n\t\tif (forGirl && forBoy) {\n\t\t\tsaida.println(0);\n\t\t} else if (forGirl || forBoy) {\n\t\t\tsaida.println(1);\n\t\t\tif (forGirl)\n\t\t\t\tsaida.println(y);\n\t\t\telse\n\t\t\t\tsaida.println(x);\n\t\t} else {\n\t\t\tint position = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (a[i] + x < l) {\n\t\t\t\t\tif (a[i] + x + y <= l && binarySearch(a, a[i] + x + y)\n\t\t\t\t\t\t\t|| a[i] + x - y >= 0\n\t\t\t\t\t\t\t&& binarySearch(a, a[i] + x - y)) {\n\t\t\t\t\t\tposition = a[i] + x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a[i] - x > 0) {\n\t\t\t\t\tif (a[i] - x + y <= l && binarySearch(a, a[i] - x + y)\n\t\t\t\t\t\t\t|| a[i] - x - y >= 0\n\t\t\t\t\t\t\t&& binarySearch(a, a[i] - x - y)) {\n\t\t\t\t\t\tposition = a[i] - x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a[i] + y < l) {\n\t\t\t\t\tif (a[i] + y + x <= l && binarySearch(a, a[i] + y + x)\n\t\t\t\t\t\t\t|| a[i] + y - x >= 0\n\t\t\t\t\t\t\t&& binarySearch(a, a[i] + y - x)) {\n\t\t\t\t\t\tposition = a[i] + y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a[i] - y > 0) {\n\t\t\t\t\tif (a[i] - y + x < l && binarySearch(a, a[i] - y + x)\n\t\t\t\t\t\t\t|| a[i] - y - x > 0\n\t\t\t\t\t\t\t&& binarySearch(a, a[i] - y - x)) {\n\t\t\t\t\t\tposition = a[i] - y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (position > 0) {\n\t\t\t\tsaida.println(1);\n\t\t\t\tsaida.println(position);\n\t\t\t} else {\n\t\t\t\tsaida.println(2);\n\t\t\t\tsaida.printf(\"%d %d\\n\", x, y);\n\t\t\t}\n\t\t}\n\t\tsaida.flush();\n\t}\n\n\tprivate static boolean binarySearch(int[] a, int target) {\n\t\tint lower = 0, upper = a.length - 1;\n\t\twhile (lower < upper) {\n\t\t\tint mid = (lower + upper) / 2;\n\t\t\tif (a[mid] == target)\n\t\t\t\treturn true;\n\t\t\tif (a[mid] < target)\n\t\t\t\tlower = mid + 1;\n\t\t\telse\n\t\t\t\tupper = mid - 1;\n\t\t}\n\t\treturn a[lower] == target;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y, a[100001];\nmap<long long, long long> m;\nvoid read() {\n  cin >> n >> l >> x >> y;\n  for (long long i = 1; i < n + 1; i++) {\n    cin >> a[i];\n    m[a[i]] = i;\n  }\n}\nlong long f(long long d) {\n  for (long long i = 1; i < n + 1; i++) {\n    if (m.count(a[i] + d)) return i;\n  }\n  return 0;\n}\nsigned main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  read();\n  long long temp1 = f(x), temp2 = f(y);\n  if (temp1 > 0) {\n    if (temp2 > 0)\n      return cout << 0, 0;\n    else\n      return cout << \"1\\n\" << y, 0;\n  }\n  if (temp2 > 0) {\n    return cout << \"1\\n\" << x, 0;\n  }\n  long long temp = f(x + y);\n  if (temp > 0) {\n    return cout << 1 << \"\\n\" << a[temp] + x, 0;\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    if (m.count(a[i] + y - x) && a[i] - x >= 0)\n      return cout << \"1\\n\" << a[i] - x, 0;\n    if (m.count(a[i] + y - x) && a[i] + y <= l)\n      return cout << \"1\\n\" << a[i] + y, 0;\n  }\n  cout << 2 << \"\\n\" << x << \" \" << y;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) {\n    long long n, l, x, y, i;\n    cin >> n >> l >> x >> y;\n    long long f1 = 0, f2 = 0;\n    map<long long, long long> mp;\n    vector<long long> v;\n    for (i = 0; i < n; i++) {\n      long long temp;\n      cin >> temp;\n      if (mp.find(temp - x) != mp.end()) f1 = 1;\n      if (mp.find(temp - y) != mp.end()) f2 = 1;\n      mp[temp] = 1;\n      v.push_back(temp);\n    }\n    if (f1 == 1 and f2 == 1)\n      cout << 0;\n    else if (f1 == 1 and f2 == 0) {\n      cout << 1 << '\\n';\n      cout << y;\n    } else if (f1 == 0 and f2 == 1) {\n      cout << 1 << '\\n';\n      cout << x;\n    } else {\n      for (i = 0; i < n; i++) {\n        long long p = v[i] + max(x, y);\n        if (mp.find(p - min(x, y)) != mp.end() and p <= l) {\n          cout << 1 << '\\n' << p;\n          return 0;\n        }\n        if (mp.find(p + min(x, y)) != mp.end() and p <= l) {\n          cout << 1 << '\\n' << p;\n          return 0;\n        }\n      }\n      for (i = n - 1; i >= 0; i--) {\n        long long p = v[i] - max(x, y);\n        if (mp.find(p + min(x, y)) != mp.end() and p >= 0) {\n          cout << 1 << '\\n' << p;\n          return 0;\n        }\n        if (mp.find(p - min(x, y)) != mp.end() and p >= 0) {\n          cout << 1 << '\\n' << p;\n          return 0;\n        }\n      }\n      cout << 2 << '\\n' << x << \" \" << y;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], n, l, x, y, p, q;\nint bse(int a[], int l, int r, int k) {\n  if (l == r && a[l] != k) return 0;\n  int t = a[(l + r) / 2];\n  if (t == k)\n    return (l + r) / 2;\n  else if (t < k)\n    return bse(a, (l + r) / 2 + 1, r, k);\n  else\n    return bse(a, l, (l + r) / 2, k);\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  p = 0;\n  q = 0;\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, x + a[i])) {\n      p++;\n      break;\n    }\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, y + a[i])) {\n      q++;\n      break;\n    }\n  if (p && q) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, x - y + a[i]) && x + a[i] <= l) {\n      printf(\"1\\n%d\\n\", x + a[i]);\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, a[i] + x + y) && a[i] + x <= l) {\n      printf(\"1\\n%d\\n\", x + a[i]);\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, a[i] - x - y) && a[i] - x >= 0) {\n      printf(\"1\\n%d\\n\", a[i] - x);\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (bse(a, 1, n, a[i] - x + y) && a[i] - x >= 0) {\n      printf(\"1\\n%d\\n\", a[i] - x);\n      return 0;\n    }\n  if (p)\n    printf(\"1\\n%d\\n\", y);\n  else if (q)\n    printf(\"1\\n%d\\n\", x);\n  else {\n    for (int i = 1; i <= n; i++)\n      if (a[i] == x + y) {\n        p = 1;\n        break;\n      }\n    if (p)\n      printf(\"1\\n%d\\n\", x);\n    else\n      printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000;\nint a[N];\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  set<int> as;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    as.insert(a[i]);\n  }\n  bool xReq = true;\n  bool yReq = true;\n  for (int i = 0; i < n; i++) {\n    if (as.count(a[i] - x) || as.count(a[i] + x)) xReq = false;\n    if (as.count(a[i] - y) || as.count(a[i] + y)) yReq = false;\n  }\n  if (!(xReq || yReq)) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (!xReq) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", y);\n    return 0;\n  }\n  if (!yReq) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  set<int> xs;\n  bool done = false;\n  for (int i = 0; i < n; i++) {\n    if (a[i] - x >= 0) xs.insert(a[i] - x);\n    if (a[i] + x <= l) xs.insert(a[i] + x);\n  }\n  for (int i = 0; i < n; i++) {\n    if (xs.count(a[i] - y)) {\n      printf(\"1\\n%d\\n\", a[i] - y);\n      return 0;\n    }\n    if (xs.count(a[i] + y)) {\n      printf(\"1\\n%d\\n\", a[i] + y);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst long long INF = 1000000000000000000;\nconst int N = 100005;\nint n, l, x, y;\nint a[N];\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  int flag_x = 0;\n  int flag_y = 0;\n  for (int i = 0; i < n; ++i) {\n    if (binary_search(a, a + n, a[i] + x)) flag_x = 1;\n    if (binary_search(a, a + n, a[i] + y)) flag_y = 1;\n  }\n  if (flag_x == 1 && flag_y == 1) {\n    cout << 0 << endl;\n    cout << endl;\n  } else if (flag_x == 1 || (x == y)) {\n    cout << 1 << endl;\n    cout << y << endl;\n  } else if (flag_y == 1) {\n    cout << 1 << endl;\n    cout << x << endl;\n  } else {\n    for (int i = 0; i < n; ++i) {\n      if (binary_search(a, a + n, a[i] + x + y)) {\n        cout << 1 << endl;\n        cout << a[i] + x << endl;\n        return 0;\n      }\n      if (binary_search(a, a + n, a[i] + abs(x - y))) {\n        if (a[i] + max(x, y) <= l) {\n          cout << 1 << endl;\n          cout << a[i] + max(x, y) << endl;\n          return 0;\n        }\n        if (a[i] - min(x, y) >= 0) {\n          cout << 1 << endl;\n          cout << a[i] - min(x, y) << endl;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class CF_479D {\n    public static void main(String[] args) throws IOException {\n        new CF_479D().solve();\n    }\n    \n    long putOut(int[] a, long smaller, long diff){\n        int start=0, finish=0;\n        while (finish<a.length && start<a.length){\n            if (a[finish]-a[start]==diff){\n                if (a[finish]+smaller<=a[a.length-1])\n                    return a[finish]+smaller;\n                if (a[start]-smaller>=a[0])\n                    return a[start]-smaller;\n                start++;\n            }            \n            else if (a[finish]-a[start]<diff)\n                finish++;\n            else if (a[finish]-a[start]>diff)\n                start++;            \n        }\n        return -1;\n    }\n    int[] hasDist(int[]a, long dist){\n        int start=0, finish=0;\n        while (finish<a.length && start<a.length){\n            if (a[finish]-a[start]==dist)\n                return new int[]{a[start],a[finish]};\n            if (a[finish]-a[start]<dist)\n                finish++;\n            else if (a[finish]-a[start]>=dist)\n                start++;            \n        }\n        return null;\n    }    \n    void solve() throws IOException{\n        \n        InputStream in = System.in;\n        PrintStream out = System.out;\n        \n//        in = new FileInputStream(\"in.txt\");\n//        out = new PrintStream(\"out.txt\");\n        \n        //long mod=1_000_000_007;\n        Scanner sc=new Scanner(in);\n        int n=sc.nextInt(), l=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n        int[] a=new int[n];        \n        for (int i=0;i<n;i++)\n            a[i]=sc.nextInt();\n        if (hasDist(a, x)!=null && hasDist(a, y)!=null) {\n            out.println(\"0\");\n            return;\n        }\n        if (hasDist(a, x)!=null ) {\n            out.println(\"1\");\n            out.println(\"\"+y);\n            return;\n        }\n        if (hasDist(a, y)!=null ) {\n            out.println(\"1\");\n            out.println(\"\"+x);\n            return;\n        }\n        int[] brd;\n        if ((brd=hasDist(a, x+(long)y) )!=null) {\n            out.println(\"1\");\n            out.println(\"\"+(brd[0]+x));\n            return;\n        }\n        long  temp=-1;\n        if ((temp=putOut(a, Math.min(x, y),Math.abs(x-y)))!=-1) {\n            out.println(\"1\");\n            out.println(\"\"+temp);\n            return;\n        }\n        out.println(\"2\");\n        out.println(y+\" \"+x);\n        \n    }\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.security.KeyStore.Entry;\nimport java.util.*;\n\n\n\n\npublic class CODEFORCES {\n\tprivate InputStream is;\n\tprivate PrintWriter out;\n\tprivate ArrayList<Integer> amp[], arr;\n\tprivate int p = 0, parent[], dist[];\n\tprivate boolean[] b;\n\tprivate PriorityQueue<Pair> pq;\n\tprivate HashSet<Pair> hs;\n\tvoid solve() {\n\t\tint n = ni(), l = ni(), x = ni(), y = ni();\n\t\tint arr[] = na(n);\n\t\tboolean b = false,c = false;\n\t\tHashSet<Integer> hs = new HashSet<>();\n\t\tfor(int i:arr) hs.add(i);\n\t\tfor(int i = 0; i< n; i++){\n\t\t\tint a1 = arr[i]-x, a2 = arr[i]+x;\n\t\t\tif(hs.contains(a1) || hs.contains(a2)){\n\t\t\t\tb = true;\n\t\t\t}\n\t\t\tint b1 = arr[i]-y, b2 = arr[i]+y;\n\t\t\tif(hs.contains(b1) || hs.contains(b2)){\n\t\t\t\tc = true;\n\t\t\t}\n\t\t}\n\t\tif(b&&c){\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(b){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(y);\n\t\t}\n\t\telse if(c){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(x);\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i< n;i++){\n\t\t\t\tint a1 = arr[i]-x, a2 = arr[i]+x;\n\t\t\t\tif(a1>0 && (hs.contains(a1-y) || hs.contains(a1+y))){\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(a2<l && (hs.contains(a2-y) || hs.contains(a2+y))){\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(a2);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(x+\" \"+y);\n\t\t}\n\t}\n\tprivate int getParent(int x){\n\t\tif(parent[x]!=x){\n\t\t\tparent[x] = getParent(parent[x]);\n\t\t}\n\t\treturn parent[x];\n\t}\n\tclass Pair implements Comparable<Pair>{\n\t\tint u, v;\n\t\tPair(int u, int v){\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t}public int hashCode() {\n\t\t\treturn Objects.hash();\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tPair other = (Pair) o;\n\t\t\treturn ((u == other.u && v == other.v) || (v == other.u && u == other.v));\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\t//return Integer.compare(val, other.val);\n\t\t\treturn Long.compare(u, other.u) != 0 ? (Long.compare(u, other.u)) : (Long.compare(v,other.v));\n\t\t}\n\t}\n\tvoid buildGraph(int n){\n\t\tfor(int i = 0; i< n; i++){\n\t\t\tint x = ni()-1, y = ni()-1;\n\t\t\tamp[x].add(y);\n\t\t\tamp[y].add(x);\n\t\t}\n\t}\n\tvoid soln() {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tnew Thread(null, new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\n\t\tsolve();\n\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t}\n\t}, \"1\", 1 << 26).start();\n\t\tout.flush();\n\t\t//tr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew CODEFORCES().soln();\n\t}\n\n\t// To Get Input\n\t// Some Buffer Methods\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    final boolean isFileIO = false; \n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st = new StringTokenizer(\"\");\n    String delim = \" \";\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.initIO();\n        m.solve();\n        m.in.close();\n        m.out.close();\n    }\n\n    public void initIO() throws IOException {\n        if(!isFileIO) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\"); \n        }\n    }\n  \n    String nextToken() throws IOException {\n        if(!st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken(delim);\n    }\n \n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public void solve() throws IOException {\n        int n, l, x, y;\n        n = nextInt(); l = nextInt(); x = nextInt(); y = nextInt();\n        boolean boys, girls;\n        boys = girls = false;\n        HashSet<Integer> marksSet = new HashSet<Integer>();\n        int[] marks = new int[n];\n        for(int i = 0; i < n; i++) {\n            marks[i] = nextInt();\n            marksSet.add(marks[i]);\n        }\n        if(marksSet.contains(x))\n            girls = true;\n        if(marksSet.contains(y))\n            boys = true;\n        for(int i = 0; i < n; i++) {\n            if(marksSet.contains(marks[i] - x)) {\n                girls = true;\n            }            \n            if(marksSet.contains(marks[i] + x)) {\n                girls = true;\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(marksSet.contains(marks[i] - y)) {\n                boys = true;\n            }            \n            if(marksSet.contains(marks[i] + y)) {\n                boys = true;\n            }\n        }\n        if(boys && girls) {\n            out.println(0);\n        } else {\n            if(girls && !boys) {\n                out.println(1);\n                out.println(y);\n            }\n            if(!girls && boys) {\n                out.println(1);\n                out.println(x);\n            }\n            if(!girls && !boys) {\n                HashMap<Integer, Integer> newMarks = new HashMap<Integer, Integer>();\n                for(int i = 0; i < n; i++) {\n                    if(marks[i] - x >= 0) {\n                        newMarks.put(marks[i] - x, 0);\n                    }\n                    if(marks[i] + x <= l) {\n                        newMarks.put(marks[i] + x, 0);\n                    }\n                }\n                for(Integer key : newMarks.keySet()) {\n                    boolean isX = false;\n                    boolean isY = false;\n                    if(marksSet.contains(key - x) || marksSet.contains(key + x)) {\n                        isX = true;\n                    }\n                    if(marksSet.contains(key - y) || marksSet.contains(key + y)) {\n                        isY = true;\n                    }\n                    if(isY && isX) {\n                        out.println(1);\n                        out.println(key);\n                        return;\n                    }\n                }\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n    }\n\n}\n\nclass Utils {\n\n    public static long binpow(long a, long exp, long mod) {\n        if(exp == 0) {\n            return 1;\n        }\n        if(exp % 2 == 0) {\n            long temp = binpow(a, exp / 2, mod);\n            return (temp * temp) % mod;\n        } else {\n            return (binpow(a, exp - 1, mod) * a) % mod;\n        }\n    }\n\n    public static long inv(long a, long mod) {\n        return binpow(a, mod - 2, mod);\n    }\n\n    public static long addmod(long a, long b, long mod) {\n        return (a + b + 2 * mod) % mod;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAX = 1e5 + 11;\nusing namespace std;\nint N, L, X, Y, A[MAX];\nset<int> all;\nstatic bool can(int v) {\n  for (int i = 0; i < (N); ++i) {\n    if (all.count(v + A[i])) {\n      return true;\n    }\n  }\n  return all.count(v) > 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &(N), &(L), &(X), &(Y));\n  for (int i = 0; i < (N); ++i) {\n    scanf(\"%d\", &(A[i]));\n    all.insert(A[i]);\n  }\n  if (can(X) && can(Y)) {\n    printf(\"0\");\n    return 0;\n  }\n  if (can(X)) {\n    printf(\"1\\n%d\", Y);\n    return 0;\n  }\n  if (can(Y)) {\n    printf(\"1\\n%d\", X);\n    return 0;\n  }\n  set<int> xx, yy;\n  for (int i = 0; i < (N); ++i) {\n    if (X + A[i] < L) xx.insert(X + A[i]);\n    if (Y + A[i] < L) yy.insert(Y + A[i]);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] - X >= 0) xx.insert(A[i] - X);\n    if (A[i] - Y >= 0) yy.insert(A[i] - Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] - X >= 0) xx.insert(A[i] - X);\n    if (A[i] + Y >= 0) yy.insert(A[i] + Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  xx = set<int>(), yy = set<int>();\n  for (int i = 0; i < (N); ++i) {\n    if (A[i] + X >= 0) xx.insert(A[i] + X);\n    if (A[i] - Y >= 0) yy.insert(A[i] - Y);\n  }\n  for (auto u : xx) {\n    if (yy.count(u)) {\n      printf(\"1\\n%d\", u);\n      return 0;\n    }\n  }\n  A[N++] = X;\n  if (can(Y)) {\n    printf(\"1\\n%d\", X);\n    return 0;\n  }\n  A[N - 1] = Y;\n  if (can(X)) {\n    printf(\"1%d\\n\", Y);\n    return 0;\n  }\n  printf(\"2\\n%d %d\", X, Y);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\nclass LongJumps():\n    def __init__(self, n, l, x, y, a):\n        self.n, self.l, self.x, self.y, self.a = n,l,x,y,a\n\n    def get_markers(self):\n        st = defaultdict(set)\n        req_pts = [self.x,self.y]\n        exist_check = defaultdict(bool)\n        value_check = defaultdict(bool)\n        for v in self.a:\n            exist_check[v] = True\n\n        for v in self.a:\n            for i in range(len(req_pts)):\n                if v - req_pts[i] >= 0:\n                    st[v - req_pts[i]].add(i)\n                    if exist_check[v - req_pts[i]]:\n                        value_check[i] = True\n                if v + req_pts[i] <= l:\n                    st[v+req_pts[i]].add(i)\n                    if exist_check[v + req_pts[i]]:\n                        value_check[i] = True\n\n        if value_check[0] and value_check[1]:\n            print(0)\n            return\n\n        sol_status = 2\n        status1_marker = None\n        for v in st:\n            if len(st[v]) == 2:\n                sol_status = 1\n                status1_marker = v\n            elif len(st[v]) == 1:\n                if exist_check[v]:\n                    sol_status = 1\n                    status1_marker = req_pts[1-st[v].pop()]\n        \n        if sol_status == 1:\n            print(1)\n            print(status1_marker)\n            return\n        else:\n            print(2)\n            print(x, y)\n\nn, l, x, y = list(map(int,input().strip(' ').split(' ')))\na = list(map(int,input().strip(' ').split(' ')))\nlj = LongJumps(n,l,x,y,a)\nlj.get_markers()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000;\nbool can[2];\nint a[N];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, x, y, l;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  set<int> q;\n  for (int i = 0; i < n; i++) {\n    q.insert(a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (q.find(-x + a[i]) != q.end()) can[0] = 1;\n    if (q.find(-y + a[i]) != q.end()) can[1] = 1;\n  }\n  if (!can[0] && !can[1]) {\n    for (int i = 0; i < n; i++) {\n      if (q.find(a[i] - x - y) != q.end()) {\n        cout << \"1\\n\" << a[i] - x << \"\\n\";\n        return 0;\n      }\n      if (q.find(a[i] + x - y) != q.end()) {\n        if (0 <= a[i] + x && a[i] + x <= l)\n          cout << \"1\\n\" << a[i] + x << \"\\n\";\n        else if (0 <= a[i] - y && a[i] - y <= l)\n          cout << \"1\\n\" << a[i] - y << \"\\n\";\n        else\n          continue;\n        return 0;\n      }\n    }\n  }\n  vector<int> ans;\n  if (!can[0]) ans.push_back(x);\n  if (!can[1]) ans.push_back(y);\n  cout << ans.size() << \"\\n\";\n  while (ans.size()) {\n    cout << ans.back() << \" \";\n    ans.pop_back();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Works good for CF\n */\npublic class D {\n\n    //some local config\n\tstatic boolean test = false;\n\tstatic String testDataFile = \"testdata.txt\";\n\tstatic String feedFile = \"feed.txt\";\n\tCompetitionType type = CompetitionType.CF;\n\tprivate static String ENDL = \"\\n\";\n\n\t// solution\n\tprivate void solve() throws Throwable {\n\t\tint n = iread();\n\t\tlong l = lread();\n\t\tlong x = lread();\n\t\tlong y = lread();\n\t\t\n\t\tlong[] ruler = new long[n]; \n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\truler[i] = lread();\n\t\t}\n\t\t\n\t\tboolean fx = false;\n\t\tboolean fy = false;\n\t\t\n\t\tint p1 = 0;\n\t\tint p2 = 0;\n\t\t\n\t\twhile(p2 < n){\n\t\t\tlong dif = ruler[p2]-ruler[p1];\n\t\t\tif(dif == x){\n\t\t\t\tfx = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dif < x){\n\t\t\t\tp2++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp1++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp1 = 0;\n\t\tp2 = 0;\n\t\twhile(p2 < n){\n\t\t\tlong dif = ruler[p2]-ruler[p1];\n\t\t\tif(dif == y){\n\t\t\t\tfy = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dif < y){\n\t\t\t\tp2++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp1++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fx && fy){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tif(fx){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(y);\n\t\t\treturn;\n\t\t}\n\t\tif(fy){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(x);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tArrayList<Long> arrx = new ArrayList<Long>();\n\t\tArrayList<Long> arry = new ArrayList<Long>();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(ruler[i]-x > 0){\n\t\t\t\tarrx.add(ruler[i]-x);\n\t\t\t}\n\t\t\tif(ruler[i]+x < l){\n\t\t\t\tarrx.add(ruler[i]+x);\n\t\t\t}\n\t\t\t\n\t\t\tif(ruler[i]-y > 0){\n\t\t\t\tarry.add(ruler[i]-y);\n\t\t\t}\n\t\t\tif(ruler[i]+y < l){\n\t\t\t\tarry.add(ruler[i]+y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCollections.sort(arrx);\n\t\tCollections.sort(arry);\n\t\t\n\t\tint px = 0;\n\t\tint py = 0;\n\t\twhile(px < arrx.size() && py < arry.size()){\n\t\t\tlong dif = arrx.get(px) - arry.get(py);\n\t\t\t\n\t\t\tif(dif == 0){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(arrx.get(px));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(dif < 0){\n\t\t\t\tpx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpy++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(2);\n\t\tSystem.out.println(x +\" \"+y);\n\t\t\n\t\t\n\t}\n\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(wread());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(wread());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(wread());\n\t}\n\n\tpublic String wread() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\t\n\t\tif(test){ //run all cases from testfile:\n\t\t\tBufferedReader testdataReader = new BufferedReader(new FileReader(testDataFile));\n\t\t\tString readLine = testdataReader.readLine();\n\t\t\tint casenr = 0;\n\t\t\tout: while (true) {\n\t\t\t\tBufferedWriter w = new BufferedWriter(new FileWriter(feedFile));\n\t\t\t\tif(!readLine.equals(\"input\")){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\t\t\t\t\tif(readLine.equals(\"output\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tw.write(readLine + \"\\n\");\n\t\t\t\t}\n\t\t\t\tw.close();\n\t\t\t\tSystem.out.println(\"Answer on case \"+(++casenr)+\": \");\n\t\t\t\t\n\t\t\t\tnew D().solve();\n\t\t\t\tSystem.out.println(\"Expected answer: \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\t\t\t\t\t\n\t\t\t\t\tif(readLine == null){\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\tif(readLine.equals(\"input\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(readLine);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"----------------\");\n\t\t\t}\n\t\t\ttestdataReader.close();\n\t\t} else { // run on server\n\t\t\tnew D().solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic D() throws Throwable {\n\t\tif (test) {\n\t\t\tin = new BufferedReader(new FileReader(new File(feedFile)));\n\t\t}\n\t}\n\n\tInputStreamReader inp = new InputStreamReader(System.in);\n\tBufferedReader in = new BufferedReader(inp);\n\tstatic BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\n\tenum CompetitionType {CF, OTHER};\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100100], n, l, x, y;\nint main() {\n  while (cin >> n >> l >> x >> y) {\n    set<long long> st;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n      st.insert(a[i]);\n    }\n    int flag1 = 0, flag2 = 0;\n    for (int i = 1; i <= n; i++) {\n      if (st.find(a[i] + x) != st.end()) flag1 = 1;\n      if (st.find(a[i] + y) != st.end()) flag2 = 1;\n    }\n    if (flag1 && flag2) {\n      puts(\"0\");\n      continue;\n    }\n    if (flag1 && flag2 == 0) {\n      cout << 1 << endl;\n      cout << y << endl;\n      continue;\n    }\n    if (flag1 == 0 && flag2) {\n      cout << 1 << endl;\n      cout << x << endl;\n      continue;\n    }\n    long long flag = -1;\n    for (int i = 1; i <= n; i++) {\n      long long p = a[i] + x;\n      if (p <= l) {\n        if (st.find(p + y) != st.end() || st.find(p - y) != st.end()) flag = p;\n      }\n      p = a[i] + y;\n      if (p <= l) {\n        if (st.find(p + x) != st.end() || st.find(p - x) != st.end()) flag = p;\n      }\n      p = a[i] - x;\n      if (p >= 0) {\n        if (st.find(p + y) != st.end() || st.find(p - y) != st.end()) flag = p;\n      }\n      p = a[i] - y;\n      if (p >= 0) {\n        if (st.find(p + x) != st.end() || st.find(p - x) != st.end()) flag = p;\n      }\n    }\n    if (flag != -1) {\n      cout << 1 << endl;\n      cout << flag << endl;\n      continue;\n    }\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    int n = s.nextInt(), l = s.nextInt(), x = s.nextInt(), y = s.nextInt();\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = s.nextInt();\n    }\n    int xi = find(a, x, true), yi = find(a, y, true);\n    List<Integer> ans = new ArrayList<Integer>();\n    if (xi == -1 && yi == -1) {\n      int dmin = find(a, y - x, true);\n      if (dmin != -1 && a[dmin] + x <= l) {\n        ans.add(a[dmin] + x);\n      } else {\n        int dmax = find(a, y - x, false);\n        if (dmax != -1 && a[dmax] - y >= 0) {\n          ans.add(a[dmax] - y);\n        } else {\n          int sum = find(a, y + x, true);\n          if (sum != -1) {\n            ans.add(a[sum] - x);\n          } else {\n            ans.add(x);\n            ans.add(y);\n          } \n        }\n      }\n    } else {\n      if (xi == -1) {\n        ans.add(x);\n      } else if (yi == -1) {\n        ans.add(y);\n      }\n    }\n    System.out.println(ans.size());\n    if (ans.size() == 2) {\n      System.out.println(ans.get(0) + \" \" + ans.get(1));\n    } else if (ans.size() == 1) {\n      System.out.println(ans.get(0));\n    }\n    \n  }\n\n  public static int find(int[] a, int d, int start) {\n    int n = a.length, left = start + 1, right = n - 1;\n    while (left <= right) {\n      int mid = (left + right) / 2;\n      if (d == a[mid] - a[start]) {\n        return mid;\n      }\n      if (d < a[mid] - a[start]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n    return -1;\n  }\n\n  public static int find(int[] a, int d, boolean flag) {\n    if (flag) {\n      for (int i = 0; i < a.length; i++) {\n        int ret = find(a, d, i);\n        if (ret != -1) {\n          return ret;\n        }\n      }\n      return -1;\n    } else {\n      for (int i = a.length - 1; i >= 0; i--) {\n        int ret = find(a, d, i);\n        if (ret != -1) {\n          return ret;\n        }\n      }\n      return -1;\n    }\n  }\n\n  \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nint d[101000];\nint girl, boy;\nint fin(int x) {\n  int low = 0, high = n - 1;\n  while (low < high) {\n    int mid = (low + high) / 2;\n    if (d[mid] == x) {\n      low = high = mid;\n    } else if (d[mid] < x) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  if (d[low] == x) return 1;\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", d + i);\n  for (int i = 0; i < n; ++i) {\n    if (fin(d[i] + x)) girl = 1;\n    if (fin(d[i] + y)) boy = 1;\n  }\n  if (girl && boy) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (girl) {\n    printf(\"%d\\n%d\\n\", 1, y);\n    return 0;\n  }\n  if (boy) {\n    printf(\"%d\\n%d\\n\", 1, x);\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (fin(d[i] + x + y)) {\n      printf(\"1\\n\");\n      printf(\"%d\\n\", d[i] + x);\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (fin(d[i] + y - x)) {\n      if (d[i] >= x) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", d[i] - x);\n        return 0;\n      }\n      if (d[i] + y <= l) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", d[i] + y);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class LongJumps {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        boolean xFound = false;\n        boolean yFound = false;\n        for (int i = 0; i < n; i++) {\n            int index1 = Arrays.binarySearch(a, i, n, x + a[i]);\n            if (index1 >= 0) {\n                xFound = true;\n            }\n            int index2 = Arrays.binarySearch(a, i, n, y + a[i]);\n            if (index2 >= 0) {\n                yFound = true;\n            }\n\n        }\n        if (xFound && yFound) {\n            System.out.println(0);\n            return;\n        } else if (xFound || yFound) {\n            System.out.println(1);\n            if (xFound) {\n                System.out.println(y);\n            } else {\n                System.out.println(x);\n            }\n            return;\n        } else {\n            int sum = x + y;\n            int res = 2;\n            for (int i = 0; i < n; i++) {\n                int index = Arrays.binarySearch(a, i, n, sum + a[i]);\n                if (index >= 0) {\n                    res = 1;\n                    System.out.println(1);\n                    System.out.println(a[i] + x);\n                    return;\n                }\n            }\n            int diff = Math.abs(x - y);\n            int max = Math.max(x, y);\n            for (int i = 0; i < n; i++) {\n                int index = Arrays.binarySearch(a, i, n, diff + a[i]);\n                if (index >= 0) {\n                    if (a[i] >= x ) {\n                        res = 1;\n                        System.out.println(1);\n                        System.out.println(a[i] - x);\n                        return;\n                    }  else if( l - a[index] >= x){\n                        res = 1;\n                        System.out.println(1);\n                        System.out.println(a[index] + x);\n                        return;\n                    }\n                }\n            }\n\n            System.out.println(2);\n            System.out.println(x);\n            System.out.println(y);\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e3 + 100;\nset<int> st;\nset<int>::iterator it;\nint main() {\n  int n, l, x, y;\n  st.clear();\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    st.insert(k);\n  }\n  bool ax = false, ay = false;\n  for (it = st.begin(); it != st.end(); it++) {\n    int tmp = *it;\n    if (st.find(tmp + x) != st.end()) ax = true;\n    if (st.find(tmp + y) != st.end()) ay = true;\n  }\n  int ans = 0, a[10];\n  if (ax == false) a[ans++] = x;\n  if (ay == false) a[ans++] = y;\n  if (ans == 2) {\n    for (it = st.begin(); it != st.end(); it++) {\n      if (st.find(*it + x + y) != st.end()) {\n        ans = 1;\n        a[0] = *it + x;\n        break;\n      }\n      if (st.find(*it + y - x) != st.end()) {\n        int tmp = 0;\n        if (*it + y < l) tmp = *it + y;\n        if (*it - x > 0) tmp = *it - x;\n        if (!tmp) continue;\n        ans = 1;\n        a[0] = tmp;\n        break;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  ;\n  for (int i = 0; i < ans; i++) {\n    if (i) printf(\" \");\n    printf(\"%d\", a[i]);\n  }\n  if (ans) printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nfrom collections import Counter, defaultdict\nfrom itertools import permutations, combinations\nraw_input = stdin.readline\npr = stdout.write\n\n\ndef in_arr():\n    return map(int,raw_input().split())\n\n\ndef pr_num(n):\n    stdout.write(str(n)+'\\n')\n\n\ndef pr_arr(arr):\n    for i in arr:\n        stdout.write(str(i)+' ')\n    stdout.write('\\n')\n\n\nrange = xrange # not for python 3.0+\n\n# main code\n\nn,l1,x,y=in_arr()\nl=in_arr()\nd=Counter(l)\nf1=0\nf2=0\nfor i in range(n):\n    if d[l[i]+x]:\n        f1=1\n    if d[l[i]+y]:\n        f2=1\nif f1 and f2:\n    print 0\nelif f1 or f2:\n    print 1\n    if f2:\n        print x\n    else:\n        print y\nelse:\n    f=0\n    for i in range(n):\n        if l[i]+x<=l1 and ( d[l[i]+x+y] or d[l[i]+x-y]):\n            print 1\n            #print 'a'\n            print l[i]+x\n            exit()\n            break\n        if l[i]-x>=0 and (d[l[i]+y-x] or d[l[i]-y-x]):\n            print 1\n            print l[i]-x\n            exit()\n    print 2\n    print x,y\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nint n, l, x, y;\nbool f(int x) {\n  for (int i = 0; i < n - 1; i++) {\n    if (binary_search(v.begin(), v.end(), v[i] + x)) {\n      return true;\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int w;\n    scanf(\"%d\", &w);\n    v.push_back(w);\n  }\n  sort(v.begin(), v.end());\n  if (f(x)) {\n    if (f(y)) {\n      printf(\"0\\n\");\n    } else {\n      printf(\"1\\n%d\\n\", y);\n    }\n    return 0;\n  }\n  if (f(y)) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (v[i] + x > l) {\n      continue;\n    }\n    if (binary_search(v.begin(), v.end(), v[i] + x + y)) {\n      printf(\"1\\n%d\\n\", v[i] + x);\n      return 0;\n    }\n    if (binary_search(v.begin(), v.end(), v[i] + x - y)) {\n      printf(\"1\\n%d\\n\", v[i] + x);\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (v[i] - x < 0) {\n      continue;\n    }\n    if (binary_search(v.begin(), v.end(), v[i] - x + y)) {\n      printf(\"1\\n%d\\n\", v[i] - x);\n      return 0;\n    }\n    if (binary_search(v.begin(), v.end(), v[i] - x - y)) {\n      printf(\"1\\n%d\\n\", v[i] - x);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.Pair;\n\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer stok;\n    final Random rand = new Random(31);\n    final int inf = (int) 1e9;\n    final long linf = (long) 1e18;\n\n    class Item implements Comparable<Item> {\n        int a, b;\n\n        Item(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Item o) {\n            return a == o.a ? b - o.b : a - o.a;\n        }\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        long l = nextInt();\n        long x = nextInt();\n        long y = nextInt();\n        Set<Long> a = new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            a.add(nextLong());\n        }\n        boolean hx = false, hy = false;\n        for (long i : a) {\n            if (a.contains(i + x)) {\n                hx = true;\n            }\n            if (a.contains(i + y)) {\n                hy = true;\n            }\n        }\n        if (hx && hy) {\n            println(0);\n        } else if (hx || hy) {\n            println(1);\n            println(hx ? y : x);\n        } else {\n            for (long i : a) {\n                if (a.contains(i + x + y)) {\n                    println(1);\n                    println(i + x);\n                    return;\n                }\n                if (a.contains(i + y - x)) {\n                    if (i + y <= l) {\n                        println(1);\n                        println(i + y);\n                        return;\n                    }\n                    if (i - x >= 0) {\n                        println(1);\n                        println(i - x);\n                        return;\n                    }\n                }\n            }\n            println(2);\n            println(x + \" \" + y);\n        }\n    }\n\n    void run() throws IOException {\n        try {\n            solve();\n            close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(abs(-1));\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try {\n            Locale.setDefault(Locale.US);\n        } catch (Exception ignore) {\n        }\n        new Main().run();\n    }\n\n    Main() {\n        super(System.out);\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    Main(String s) throws FileNotFoundException {\n        super(\"\".equals(s) ? \"output.txt\" : s + \".out\");\n        br = new BufferedReader(new FileReader(\"\".equals(s) ? \"input.txt\" : s + \".in\"));\n    }\n\n    String next() {\n        try {\n            while (stok == null || !stok.hasMoreTokens()) {\n                stok = new StringTokenizer(br.readLine());\n            }\n        } catch (IOException e) {\n            return null;\n        }\n        return stok.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    int[] nextIntArray(int len) {\n        int[] res = new int[len];\n        for (int i = 0; i < len; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            int x = rand.nextInt(i + 1);\n            int t = a[i];\n            a[i] = a[x];\n            a[x] = t;\n        }\n    }\n\n    boolean nextPerm(int[] p) {\n        for (int a = p.length - 2; a >= 0; --a)\n            if (p[a] < p[a + 1])\n                for (int b = p.length - 1; ; --b)\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n        return false;\n    }\n\n    <T> List<T>[] adjacencyList(int countVertex) {\n        List<T>[] res = new List[countVertex];\n        for (int i = 0; i < countVertex; i++) {\n            res[i] = new ArrayList<T>();\n        }\n        return res;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Class: <br />\n * Date: 2014/10/12 22:00<br />\n * Description:<br />\n *\n * @author sjtudesigner\n */\npublic class ProblemB {\n\n    private static int[] table;\n    private static int n;\n    private static boolean binary_search(int num)\n    {\n        int left = 0, right = n - 1;\n        while (left <= right)\n        {\n            int mid = (left + right) / 2;\n            if (num > table[mid]) { left = mid + 1; }\n            else if (num < table[mid]) { right = mid - 1; }\n            else return true;\n        }\n        return (table[left] == num || table[right] == num);\n    }\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        int l = sc.nextInt();\n        int girl = sc.nextInt();\n        int boy = sc.nextInt();\n        table = new int[n];\n        for (int i = 0;i < n;i++)\n        {\n            table[i] = sc.nextInt();\n        }\n\n        boolean g = false;\n        boolean b = false;\n        for (int i = 0;i < n;i++)\n        {\n            if (table[i] + girl > l) break;\n            if (binary_search(table[i] + girl)) { g = true; break; }\n        }\n\n        for (int i = 0;i < n;i++)\n        {\n            if (table[i] + boy > l) break;\n            if (binary_search(table[i] + boy)) { b = true; break; }\n        }\n\n        if (g && b) {\n            System.out.println(0);\n        }\n        else if (!g && b)\n        {\n            System.out.println(1);\n            System.out.println(girl);\n        }\n        else if (!b && g)\n        {\n            System.out.println(1);\n            System.out.println(boy);\n        }\n        else\n        {\n            int position = -1;\n            for (int i = 0;i < n;i++)\n            {\n                if (table[i] + boy + girl > l) break;\n                if (binary_search(table[i] + boy + girl)) {\n                    position = table[i] + girl;\n                    break;\n                }\n            }\n            if (position == -1)\n            for (int i = 0;i < n;i++)\n            {\n                if (table[i] + boy - girl > l) break;\n                if (binary_search(table[i] + boy - girl)) {\n                    if (table[i] - girl > 0) { position = table[i] - girl; break; }\n                    else if (table[i] + boy < l) { position = table[i] + boy; break; }\n\n                }\n            }\n            if (position == -1) {\n                System.out.println(2);\n                System.out.printf(\"%d %d\\n\", boy, girl);\n            }\n            else\n            {\n                System.out.println(1);\n                System.out.println(position);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 123456;\nint n, l, x, y, ai[maxn];\nvoid init() {\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &ai[i]);\n}\nint brs(int l, int r, int now, int t) {\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (now - ai[mid] == t) {\n      return 1;\n    }\n    if (now - ai[mid] > t) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return 0;\n}\nvoid DYGANDQYM() {\n  int p1 = 0;\n  int p2 = 0;\n  for (int i = 2; i <= n; i++) {\n    int t1 = brs(1, i - 1, ai[i], x);\n    int t2 = brs(1, i - 1, ai[i], y);\n    if (t1 == 1) {\n      p1 = -1;\n    }\n    if (t2 == 1) {\n      p2 = -1;\n    }\n  }\n  if (p1 == -1 && p2 == -1)\n    printf(\"0\\n\");\n  else if (p1 == -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", l - y);\n  } else if (p2 == -1) {\n    printf(\"1\\n\");\n    printf(\"%d\\n\", l - x);\n  } else {\n    int idx = -1;\n    for (int i = 2; i <= n; i++) {\n      int t1 = brs(1, i - 1, ai[i], x + y);\n      int t2 = brs(1, i - 1, ai[i], y - x);\n      if (t1 == 1) {\n        idx = i;\n        break;\n      }\n      if (t2 == 1) {\n        long long aa = ai[i];\n        if (aa - y >= 0 || aa + x <= l) {\n          idx = i;\n          break;\n        }\n      }\n    }\n    if (idx == -1) {\n      printf(\"2\\n\");\n      printf(\"%d %d\\n\", l - x, l - y);\n    } else {\n      printf(\"1\\n\");\n      long long tt = ai[idx];\n      if (tt - y >= 0) {\n        printf(\"%d\\n\", ai[idx] - y);\n      } else {\n        printf(\"%d\\n\", ai[idx] + x);\n      }\n    }\n  }\n}\nint main() {\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) != EOF) {\n    init();\n    DYGANDQYM();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, k[100010];\nmap<int, bool> bj;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  int xx = 1, yy = 1, zz = -1;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &k[i]), bj[k[i]] = 1;\n  for (int i = 1; i <= n; i++) {\n    if (bj[k[i] + x]) xx = 0;\n    if (bj[k[i] + y]) yy = 0;\n    if (bj[k[i] + y - x])\n      if (k[i] + y <= l) zz = k[i] + y;\n    if (bj[k[i] + x - y])\n      if (k[i] + x <= l) zz = k[i] + x;\n    if (bj[k[i] - x + y])\n      if (k[i] - x >= 0) zz = k[i] - x;\n    if (bj[k[i] - y + x])\n      if (k[i] - y >= 0) zz = k[i] - y;\n    if (bj[k[i] + x + y] && !bj[k[i] + x] && !bj[k[i] + y])\n      if (k[i] + x + y <= l) zz = k[i] + x;\n    if (bj[k[i] + x] && bj[k[i] - y]) xx = yy = 0;\n    if (bj[k[i] - y] && bj[k[i] + x]) xx = yy = 0;\n  }\n  int ans = xx + yy;\n  if (ans == 2) {\n    if (zz != -1)\n      printf(\"1\\n%d\", zz);\n    else\n      printf(\"2\\n%d %d\\n\", x, y);\n  }\n  if (ans == 1) {\n    if (yy)\n      printf(\"1\\n%d\\n\", y);\n    else\n      printf(\"1\\n%d\\n\", x);\n  }\n  if (ans == 0) printf(\"0\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, l, x, y = map(int, input().split())\na = set(map(int, input().split()))\nok1 = ok2 = ok3 = False\nfor c in a:\n    if c + x in a:\n        ok1 = True\n    if c + y in a:\n        ok2 = True\n    if c - x > 0 and c - x + y in a:\n        ok3 = True\n        mark = c - x\n    if c + x < l and c + x - y in a:\n        ok3 = True\n        mark = c + x\n    if c + x + y in a:\n        ok3 = True\n        mark = c + x    \n    if c - x - y in a:\n        ok3 = True\n        mark = c - x\nif ok1 and ok2:\n    print(0)\nelif (not ok1) and (not ok2):    \n    if ok3:\n        print(1)\n        print(mark)\n    else:\n        print(2)\n        print(x, y)\nelse:\n    print(1)\n    print(y if ok1 else x)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  set<int> q;\n  bool z1 = false;\n  bool z2 = false;\n  bool z3 = false;\n  int num = 0;\n  for (int i = 0; i < n; i++) {\n    int x1;\n    scanf(\"%d\", &x1);\n    q.insert(x1);\n    if (q.find(x1 - x) != q.end()) z1 = true;\n    if (q.find(x1 - y) != q.end()) z2 = true;\n    if (q.find(x1 - y - x) != q.end()) {\n      z3 = true;\n      num = x1 - y;\n    }\n    if (q.find(x1 - (y - x)) != q.end()) {\n      if (x1 + x <= l) {\n        z3 = true;\n        num = x1 + x;\n      }\n      if (x1 - y >= 0) {\n        z3 = true;\n        num = x1 - y;\n      }\n    }\n  }\n  if (z1 && z2) cout << \"0\";\n  if (z1 ^ z2) {\n    cout << \"1\\n\";\n    if (z1) cout << y;\n    if (z2) cout << x;\n  }\n  if (!(z1 || z2)) {\n    if (z3) {\n      cout << \"1\\n\";\n      cout << num;\n    } else {\n      cout << \"2\\n\";\n      cout << x << \" \" << y;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nrange = xrange\ninput = raw_input\n\ndef gcd(a,b):\n    while b:\n        b,a = a%b,b\n    return a\n\nn,l,x,y = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\n\nposx = []\nposy = []\nfor a in A:\n    if a - x >= 0:\n        posx.append(a - x)\n    if a + x <= l:\n        posx.append(a + x)\n    if a - y >= 0:\n        posy.append(a - y)\n    if a + y <= l:\n        posy.append(a + y)\n\nif set(A) & set(posx):\n    if set(A) & set(posy):\n        print 0\n        sys.exit()\n    else:\n        print 1\n        print posy[0]\n        sys.exit()\n\nif set(A) & set(posy):\n    print 1\n    print posx[0]\n    sys.exit()\n\nB = list(set(posx) & set(posy))\nif B:\n    print 1\n    print B[0]\n    sys.exit()\n\nprint 2\nprint x, y\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> arr;\nset<int> spots;\nint main(int argc, char** argv) {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int xx;\n    cin >> xx;\n    arr.push_back(xx);\n    spots.insert(xx);\n  }\n  bool canX = false;\n  bool canY = false;\n  for (int i = 0; i < n; i++) {\n    int can1 = arr[i] + x;\n    int can2 = arr[i] - x;\n    int can3 = arr[i] + y;\n    int can4 = arr[i] - y;\n    if (spots.find(can1) != spots.end() || spots.find(can2) != spots.end()) {\n      canX = true;\n    }\n    if (spots.find(can3) != spots.end() || spots.find(can4) != spots.end()) {\n      canY = true;\n    }\n  }\n  if (canX && canY) {\n    cout << 0;\n    return 0;\n  }\n  if (canX) {\n    cout << 1 << endl;\n    cout << y;\n    return 0;\n  }\n  if (canY) {\n    cout << 1 << endl;\n    cout << x;\n    return 0;\n  }\n  for (int i = 1; i < n - 1; i++) {\n    int can1 = arr[i] - x;\n    int can2 = arr[i] + x;\n    int exp1 = can1 + y;\n    int exp2 = can1 - y;\n    int exp3 = can2 + y;\n    int exp4 = can2 - y;\n    if (can1 >= 0 && can1 <= l) {\n      if (spots.find(exp1) != spots.end()) {\n        cout << 1 << endl;\n        cout << can1 << endl;\n        return 0;\n      }\n      if (spots.find(exp2) != spots.end()) {\n        cout << 1 << endl;\n        cout << can1 << endl;\n        return 0;\n      }\n    }\n    if (can2 >= 0 && can2 <= l) {\n      if (spots.find(exp3) != spots.end()) {\n        cout << 1 << endl;\n        cout << can2 << endl;\n        return 0;\n      }\n      if (spots.find(exp4) != spots.end()) {\n        cout << 1 << endl;\n        cout << can2 << endl;\n        return 0;\n      }\n    }\n  }\n  int can1 = arr[0] + x;\n  int can2 = arr[n - 1] - x;\n  int exp1 = can1 - y;\n  int exp2 = can1 + y;\n  int exp3 = can2 - y;\n  int exp4 = can2 + y;\n  if (can1 >= 0 && can1 <= l) {\n    if (spots.find(exp1) != spots.end()) {\n      cout << 1 << endl;\n      cout << can1 << endl;\n      return 0;\n    }\n    if (spots.find(exp2) != spots.end()) {\n      cout << 1 << endl;\n      cout << can1 << endl;\n      return 0;\n    }\n  }\n  if (can2 >= 0 && can2 <= l) {\n    if (spots.find(exp3) != spots.end()) {\n      cout << 1 << endl;\n      cout << can2 << endl;\n      return 0;\n    }\n    if (spots.find(exp4) != spots.end()) {\n      cout << 1 << endl;\n      cout << can2 << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n = 2, l = 300, x = 185, y = 230;\n  cin >> n >> l >> x >> y;\n  vector<long long> in(n);\n  set<int> total;\n  for (int i = 0; i < n; i++) {\n    cin >> in[i];\n    total.insert(in[i]);\n  }\n  set<long long> X;\n  for (int i = 0; i < n; i++) {\n    int right = in[i] + x;\n    int left = in[i] - x;\n    if (right <= l) X.insert(right);\n    if (left >= 0) X.insert(left);\n    if (total.count(left) || total.count(right)) {\n      X.clear();\n      break;\n    }\n  }\n  set<long long> Y;\n  for (int i = 0; i < n; i++) {\n    int right = in[i] + y;\n    int left = in[i] - y;\n    if (right <= l) {\n      if (X.count(right)) {\n        Y.clear();\n        X.clear();\n        Y.insert(right);\n        break;\n      } else {\n        Y.clear();\n        Y.insert(right);\n      }\n    }\n    if (left >= 0) {\n      if (X.count(left)) {\n        Y.clear();\n        X.clear();\n        Y.insert(left);\n        break;\n      } else {\n        Y.clear();\n        Y.insert(left);\n      }\n    }\n    if (total.count(left) || total.count(right)) {\n      Y.clear();\n      break;\n    }\n  }\n  int size = min(1, (int)Y.size()) + min(1, (int)X.size());\n  cout << min(2, size) << endl;\n  for (long long i : Y) {\n    cout << i << \" \";\n    break;\n  }\n  for (long long i : X) {\n    cout << i << \" \";\n    break;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100000;\nint ti1, ti2;\nint N;\nint L, L1, L2;\nint L0[MAX];\nint DP_A(int temp) {\n  int t0, t1;\n  t0 = 0;\n  t1 = N - 1;\n  if (temp > L || temp < 0)\n    return -1;\n  else\n    while (t0 <= t1) {\n      int t;\n      t = (t0 + t1) / 2;\n      if (L0[t] == temp)\n        return 1;\n      else if (L0[t] < temp) {\n        t0 = t + 1;\n      } else if (L0[t] > temp) {\n        t1 = t - 1;\n      }\n    }\n  return -1;\n}\nint DP2() {\n  int temp1, temp2;\n  for (int i = 0; i < N; i++) {\n    temp1 = L0[i] + L1;\n    temp2 = L0[i] + L2;\n    if (temp1 <= L && (DP_A(temp1 - L2) == 1 || DP_A(temp1 + L2) == 1)) {\n      cout << 1 << '\\n' << temp1 << endl;\n      return 1;\n    }\n    if (temp2 <= L && (DP_A(temp2 - L1) == 1 || DP_A(temp2 + L1) == 1)) {\n      cout << 1 << '\\n' << temp2 << endl;\n      return 1;\n    }\n    temp1 = L0[i] - L1;\n    temp2 = L0[i] - L2;\n    if (temp1 >= 0 && (DP_A(temp1 - L2) == 1 || DP_A(temp1 + L2) == 1)) {\n      cout << 1 << '\\n' << temp1 << endl;\n      return 1;\n    }\n    if (temp2 >= L && (DP_A(temp2 - L1) == 1 || DP_A(temp2 + L1) == 1)) {\n      cout << 1 << '\\n' << temp2 << endl;\n      return 1;\n    }\n  }\n  cout << 2 << '\\n' << L1 << ' ' << L2 << endl;\n}\nvoid DP() {\n  int temp;\n  for (int i = 0; i < N; i++) {\n    temp = DP_A(L0[i] + L1);\n    if (temp != -1) ti1 = temp;\n    temp = DP_A(L0[i] + L2);\n    if (temp != -1) ti2 = temp;\n    temp = DP_A(L0[i] - L1);\n    if (temp != -1) ti1 = temp;\n    temp = DP_A(L0[i] - L2);\n    if (temp != -1) ti2 = temp;\n  }\n  if (ti1 != -1 && ti2 != -1)\n    cout << 0 << endl;\n  else if (ti1 != -1)\n    cout << 1 << '\\n' << L2 << endl;\n  else if (ti2 != -1)\n    cout << 1 << '\\n' << L1 << endl;\n  else if (ti1 == -1 && ti2 == -1)\n    DP2();\n  else\n    cout << \"\u51fa\u9519\" << endl;\n}\nint main() {\n  ti1 = -1;\n  ti2 = -1;\n  cin >> N;\n  cin >> L >> L1 >> L2;\n  for (int i = 0; i < N; i++) cin >> L0[i];\n  sort(L0, L0 + N);\n  DP();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<long long> numbers;\nint main() {\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    long long x;\n    cin >> x;\n    numbers.insert(x);\n  }\n  long long sub = y - x;\n  bool find_x = false, find_y = false;\n  int v = -1;\n  for (auto d : numbers) {\n    if (numbers.find(d + x) != numbers.end()) {\n      find_x = true;\n    }\n    if (numbers.find(d + y) != numbers.end()) {\n      find_y = true;\n    }\n    if (numbers.find(d + sub) != numbers.end()) {\n      if (d - x >= 0) v = d - x;\n      if (d + y <= l) v = d + y;\n    }\n    if (numbers.find(d + x + y) != numbers.end() && d + x <= l) {\n      v = d + x;\n    }\n  }\n  if (!find_x && !find_y) {\n    if (v != -1) {\n      cout << \"1\\n\" << v;\n    } else {\n      cout << \"2\\n\" << x << ' ' << y;\n    }\n  } else if (!find_x && find_y) {\n    cout << \"1\\n\" << x;\n  } else if (find_x && !find_y) {\n    cout << \"1\\n\" << y;\n  } else {\n    cout << 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMax = 200000, INF = 1000000000;\nint N, L, X, Y, A[NMax];\nint Binary(int first, int second, int a, int z) {\n  int l = first, r = second + 1;\n  while (l < r) {\n    if (l + 1 == r) break;\n    int mid = (l + r) / 2;\n    if (A[mid] - a <= z)\n      l = mid;\n    else\n      r = mid;\n  }\n  return l;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &N, &L, &X, &Y);\n  for (int i = 1; i <= N; i++) scanf(\"%d\", A + i);\n  int flag1 = 0, flag2 = 0;\n  for (int i = 1; i < N; i++) {\n    int first = Binary(i + 1, N, A[i], X), second = Binary(i + 1, N, A[i], Y);\n    if (A[first] - A[i] == X) flag1 = 1;\n    if (A[second] - A[i] == Y) flag2 = 1;\n  }\n  if (flag1 && flag2) {\n    puts(\"0\");\n    getchar();\n    getchar();\n    return 0;\n  }\n  if (flag1) {\n    printf(\"1\\n%d\\n\", Y);\n    getchar();\n    getchar();\n    return 0;\n  }\n  if (flag2) {\n    printf(\"1\\n%d\\n\", X);\n    getchar();\n    getchar();\n    return 0;\n  }\n  for (int i = 1; i <= N; i++) {\n    if (i != 1) {\n      if (A[i] > X) {\n        int t = A[i] - X;\n        int t1 = Binary(1, i - 1, t, 0);\n        int first = Binary(1, t1, t, -Y);\n        if (t - A[first] == Y) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n        first = Binary(t1 + 1, N, t, Y);\n        if (A[first] - t == Y) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n      }\n      if (A[i] > Y) {\n        int t = A[i] - Y;\n        int t1 = Binary(1, i - 1, t, 0);\n        int first = Binary(1, t1, t, -X);\n        if (t - A[first] == X) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n        first = Binary(t1 + 1, N, t, X);\n        if (A[first] - t == X) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n      }\n    }\n    if (i != N) {\n      if (A[i] + X < L) {\n        int t = A[i] + X;\n        int t1 = Binary(i, N, t, 0);\n        int first = Binary(1, t1, t, -Y);\n        if (t - A[first] == Y) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n        first = Binary(t1 + 1, N, t, Y);\n        if (A[first] - t == Y) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n      }\n      if (A[i] + Y < L) {\n        int t = A[i] + Y;\n        int t1 = Binary(i, N, t, 0);\n        int first = Binary(1, t1, t, -X);\n        if (t - A[first] == X) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n        first = Binary(t1 + 1, N, t, X);\n        if (A[first] - t == X) {\n          printf(\"1\\n%d\\n\", t);\n          getchar();\n          getchar();\n          return 0;\n        }\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", X, Y);\n  getchar();\n  getchar();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class p479d {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        HashSet<Integer> hs1 = new HashSet<Integer>();\n        HashSet<Integer> hs2 = new HashSet<Integer>();\n        HashSet<Integer> hs3 = new HashSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            int foo = sc.nextInt();\n            hs1.add(foo);\n        }\n        for (int i : hs1) {\n            if (i - x >= 0) {\n                hs2.add(i - x);\n            }\n            if (i + x <= l) {\n                hs2.add(i + x);\n            }\n            if (i - y >= 0) {\n                hs3.add(i - y);\n            }\n            if (i + y <= l) {\n                hs3.add(i + y);\n            }\n        }\n        int flag1 = -1, flag2 = -1, flag3 = -1;\n        for (int i : hs2) {\n            if (hs3.contains(i)) {\n                flag1 = i;\n                break;\n            }\n        }\n        for (int i : hs1) {\n            if (hs2.contains(i)) {\n                flag2 = i;\n            }\n            if (hs3.contains(i)) {\n                flag3 = i;\n            }\n        }\n        if (flag2 != -1 && flag3 != -1) {\n            System.out.println(\"0\");\n        } else if (flag2 != -1 || flag3 != -1) {\n            System.out.println(\"1\\n\" + (flag2 != -1 ? y : x));\n        } else {\n            if (flag1 != -1) {\n                System.out.println(\"1\\n\" + flag1);\n            } else {\n                System.out.println(\"2\\n\" + x + \" \" + y);\n            }\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(\n\t\t\t\tnew BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(\n\t\t\t\tnew BufferedWriter(\n\t\t\t\t\t\tnew OutputStreamWriter(System.out)));\n\t\tRoutine routine = new Routine();\n\t\troutine.run(in, out);\n\t\tout.flush();\n\t}\n}\n\nclass Routine {\n\tint n, l, x, y;\n\tint[] as = new int[200_005];\n\t\n\tpublic void run(Scanner in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tl = in.nextInt();\n\t\tx = in.nextInt();\n\t\ty = in.nextInt();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tint mask = 3;\n\t\t\n\t\tSet<Integer> set = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tset.add(as[i]);\n\t\t\tif (set.contains(as[i]-x)) {\n\t\t\t\tmask &= ~1;\n\t\t\t}\n\t\t\tif (set.contains(as[i]-y)) {\n\t\t\t\tmask &= ~2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (mask == 0) {\n\t\t\tout.println(0);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 1) {\n\t\t\tout.println(1);\n\t\t\tout.println(x);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 2) {\n\t\t\tout.println(1);\n\t\t\tout.println(y);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set.contains(as[i]-(x+y))) {\n\t\t\t\tout.println(1);\n\t\t\t\tout.println(as[i]-x);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\t\n\t\t\tif (set.contains(as[i]-(y-x))) {\n\t\t\t\tif (as[i]+x <= l) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]+x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (as[i]-(y-x)-x >= 0) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]-(y-x)-x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(2);\n\t\tout.println(x+\" \"+y);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7, N = 1e5 + 10;\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<ll> A(n);\n  for (auto &e : A) cin >> e;\n  ll is_x = 0, is_y = 0;\n  for (ll i = 0; i < n; i++) {\n    is_x |= binary_search(A.begin(), A.end(), A[i] + x);\n    is_y |= binary_search(A.begin(), A.end(), A[i] + y);\n  }\n  if (is_x & is_y) {\n    return cout << 0, 0;\n  }\n  if (is_x) {\n    cout << \"1\\n\" << y << '\\n';\n    return 0;\n  }\n  if (is_y) {\n    cout << \"1\\n\" << x << '\\n';\n    return 0;\n  }\n  for (ll i = 0; i < n; i++) {\n    if (A[i] + x <= l and (binary_search(A.begin(), A.end(), A[i] + x + y) or\n                           binary_search(A.begin(), A.end(), A[i] + x - y))) {\n      return cout << \"1\\n\" << A[i] + x, 0;\n      21;\n    }\n    if (A[i] - x >= 0 and (binary_search(A.begin(), A.end(), A[i] - x + y) or\n                           binary_search(A.begin(), A.end(), A[i] - x - y))) {\n      return cout << \"1\\n\" << A[i] - x, 0;\n      21;\n    }\n    swap(x, y);\n    if (A[i] + x <= l and (binary_search(A.begin(), A.end(), A[i] + x + y) or\n                           binary_search(A.begin(), A.end(), A[i] + x - y))) {\n      return cout << \"1\\n\" << A[i] + x, 0;\n      21;\n    }\n    if (A[i] - x >= 0 and (binary_search(A.begin(), A.end(), A[i] - x + y) or\n                           binary_search(A.begin(), A.end(), A[i] - x - y))) {\n      return cout << \"1\\n\" << A[i] - x, 0;\n      21;\n    }\n    swap(x, y);\n  }\n  cout << \"2\\n\" << x << ' ' << y << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, i, j, num[100005];\npair<int, int> findfi(int x) {\n  int l = 1, r = 1;\n  for (r = 1; r <= n; r++) {\n    while (num[l] + x < num[r] && l <= n) l++;\n    if (num[l] + x == num[r]) return {num[l], num[r]};\n  }\n  return {-1, -1};\n}\npair<int, int> findls(int x) {\n  int l = n, r = n;\n  for (l = n; l; l--) {\n    while (num[l] + x < num[r] && r >= 1) r--;\n    if (num[l] + x == num[r]) return {num[l], num[r]};\n  }\n  return {-1, -1};\n}\nbool in(long long x) { return (x > -1 && x <= m); }\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> x >> y;\n  for (i = 1; i <= n; i++) cin >> num[i];\n  if (findfi(x) != pair<int, int>{-1, -1}) {\n    if (findfi(y) != pair<int, int>{-1, -1}) {\n      cout << 0;\n      return 0;\n    }\n    cout << 1 << endl << y;\n    return 0;\n  }\n  if (findfi(y) != pair<int, int>{-1, -1}) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  if (findfi(x + y) != pair<int, int>{-1, -1}) {\n    cout << 1 << endl << findfi(x + y).first + x;\n    return 0;\n  }\n  if (findfi(y - x) != pair<int, int>{-1, -1} && findfi(y - x).first + y <= m) {\n    cout << 1 << endl << findfi(y - x).first + y;\n    return 0;\n  }\n  if (findls(y - x) != pair<int, int>{-1, -1} && findls(y - x).first - x >= 0) {\n    cout << 1 << endl << findls(y - x).first - x;\n    return 0;\n  }\n  cout << 2 << endl << x << ' ' << y;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n\npublic class con274_D {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader(System.in), 10*1024*1024 );\n\t\tStringTokenizer tok = new StringTokenizer(br.readLine());\n\t\t// n, l, x, y (2\u2009<=\u2009n\u2009<=\u200910^5, 2\u2009<=\u2009l\u2009<=\u200910^9, 1\u2009<=\u2009x\u2009<\u2009y\u2009<=\u2009l)\n\t\tint n, l, x, y;\n\t\tn = Integer.parseInt(tok.nextToken());\n\t\tl = Integer.parseInt(tok.nextToken());\n\t\tx = Integer.parseInt(tok.nextToken());\n\t\ty = Integer.parseInt(tok.nextToken());\n\t\t\n\t\ttok = new StringTokenizer(br.readLine());\n\t\tint[] a = new int[n];\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(tok.nextToken());\n\t\t\tset.add(a[i]);\n\t\t}\n\n\t\tint a1 = findDistance(x, set, a, n);\n\t\tint a2 = findDistance(y, set, a, n);\n\t\tif ( a1 > 0 && a2 > 0 ) {\n\t\t\tSystem.out.println( 0 );\n\t\t} else {\n\t\t\tif (a1 > 0) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(y);\n\t\t\t} else if (a2 > 0) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(x);\n\t\t\t} else {\n\t\t\t\tint ae = findDistance(x + y, set, a, n);\n\t\t\t\tif (ae > 0) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(ae - y);\n\t\t\t\t} else {\n\t\t\t\t\tint na = findSpecial(x, y, set, a, n, l);\n\t\t\t\t\tif (na > 0) {\n\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\tSystem.out.println(na);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t\t\tSystem.out.println(x + \" \" + y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int findSpecial(int x, int y, TreeSet<Integer> set, int[] a,\n\t\t\tint n, int l) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ( a[i] + y < l ) {\n\t\t\t\tif (set.contains(a[i] + y - x)) {\n\t\t\t\t\treturn a[i] + y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ( a[i] - y > 0 ) {\n\t\t\t\tif (set.contains(a[i] - y + x)) {\n\t\t\t\t\treturn a[i] - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static int findDistance(int d, TreeSet<Integer> set, int[] a, int l) {\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tint n = a[i] - d;\n\t\t\tif (set.contains(n)) {\n\t\t\t\treturn a[i];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class long_jumps \n{\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n\tboolean needed(int [] a, int x)\n\t{\n\t\tint l = 0;\n\t\tint r = 1;\n\t\t\n\t\twhile (l<= r  && r< a.length && l< a.length)\n\t\t{\n\t\t\tif (a[r]-a[l]< x)\n\t\t\t\tr++;\n\t\t\telse if (a[r]-a[l]>x)\n\t\t\t\tl++;\n\t\t\telse return false;\n\t\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean binSearch(int [] a, int find)\n\t{\n\t\tint lo = 0;\n\t\tint hi = a.length-1;\n\t\twhile (lo <= hi)\n\t\t{\n\t\t\tint mid = (lo+hi)/2;\n\t\t\tif (a[mid] < find)\n\t\t\t\tlo = mid+1;\n\t\t\telse if (a[mid] > find)\n\t\t\t\thi = mid - 1;\n\t\t\telse return true;\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tInputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        long_jumps lj = new long_jumps();\n        \n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        \n        int [] a = new int [n];\n        for (int i = 0; i< n; i++)\n        \ta[i] = sc.nextInt();\n        \n        int needed = 0;\n        \n        \n        StringBuilder ans = new StringBuilder();\n        if (lj.needed(a, x)==true)\n        \t{needed++;}\n        if (lj.needed(a, y)==true)\n        \t{needed++;}\n        \n        if (needed==1 && lj.needed(a, x))\n        \tans.append(x);\n        \n        else if (needed==1 && lj.needed(a, y))\n        \tans.append(y);\n        \n        else if (needed == 2)\n        {\n        \tfor (int i = 0; i< n; i++)\n        \t{\n        \t\tint z1 = a[i]-x;\n        \t\tint z2 = x + a[i];\n        \t\tint z11 = z1+y;\n        \t\tint z12 = z1-y;\n        \t\tint z21 = z2-y;\n        \t\tint z22 = z2+y;\n        \t\t \n        \t\tif (lj.binSearch(a, z11)  && z1 > 0 && z1< l && ans.length()==0)\n        \t\t\t{ans.append(z1);needed = 1;break;}\n        \t\telse if (lj.binSearch(a, z12)&& z1 > 0 && z1 < l && ans.length()==0)\n        \t\t\t{ans.append(z1);needed = 1;break;}\n        \t\telse if (lj.binSearch(a, z21)  && z2 > 0 && z2 < l && ans.length()==0)\n    \t\t\t{ans.append(z2);needed = 1;break;}\n        \t\telse if (lj.binSearch(a, z22) && z2 > 0 && z2 < l&& ans.length()==0)\n    \t\t\t{ans.append(z2);needed = 1;break;}\n        \t\t\n        \t}\n        \tif (ans.length()==0)\n        \t\tans.append(x+\" \"+y);\n        \t\n        }\n        \n        out.println(needed);\n        out.println(ans.toString().trim());\n        out.close();\n        \n        out.flush();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100010;\nint64_t N, L, X, Y;\nint64_t A[MAX_N];\nbool hasX = false, hasY = false;\nset<int64_t> S;\nvoid Input() {\n  cin >> N >> L >> X >> Y;\n  for (int i = 0; i < N; i++) cin >> A[i];\n}\nvoid Precalc() {\n  for (int i = 0; i < N; i++) {\n    S.insert(A[i]);\n  }\n  for (int i = 0; i < N; i++) {\n    if (S.count(X + A[i])) hasX = true;\n    if (S.count(Y + A[i])) hasY = true;\n  }\n}\nvoid Solve2() {\n  bool ok = false;\n  for (int i = 0; i < N; i++) {\n    if (S.count(A[i] + X + Y)) {\n      cout << 1 << endl;\n      cout << A[i] + X << endl;\n      ok = true;\n      break;\n    }\n    if (S.count(A[i] - X - Y)) {\n      cout << 1 << endl;\n      cout << A[i] - X << endl;\n      ok = true;\n      break;\n    }\n    if (S.count(A[i] + Y - X)) {\n      if (A[i] + Y <= L) {\n        cout << 1 << endl;\n        cout << A[i] + Y << endl;\n        ok = true;\n        break;\n      }\n    }\n    if (S.count(A[i] - Y + X)) {\n      if (A[i] - Y >= 0) {\n        cout << 1 << endl;\n        cout << A[i] - Y << endl;\n        ok = true;\n        break;\n      }\n    }\n  }\n  if (!ok) {\n    cout << 2 << endl;\n    cout << X << \" \" << Y << endl;\n  }\n}\nvoid Solve() {\n  Precalc();\n  if (hasX && hasY) {\n    cout << 0 << endl;\n  } else if (hasX) {\n    cout << 1 << endl;\n    cout << Y << endl;\n  } else if (hasY) {\n    cout << 1 << endl;\n    cout << X << endl;\n  } else {\n    Solve2();\n  }\n}\nint main() {\n  Input();\n  Solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class Main {\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    \n    \n    static void solve() throws Exception {\n        int n = nextInt();\n        long l = nextInt();\n        long x = nextInt();\n        long y = nextInt();\n        boolean isX = false;\n        boolean isY = false;\n        TreeSet<Long> used = new TreeSet<Long>();\n        long[] a = new long[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = nextInt();\n            if (used.contains(a[i] - x)) {\n                isX = true;\n            }\n            if (used.contains(a[i] - y)) {\n                isY = true;\n            }\n            used.add(a[i]);\n        }\n        if (isX && isY) {\n            out.println(\"0\");\n            return;\n        } else if (!isX && isY) {\n            out.println(\"1\");\n            out.println(x);\n            return;\n        } else if (isX && !isY) {\n            out.println(\"1\");\n            out.println(y);\n            return;\n        }\n        for (int i = 0; i < n; ++i) {\n            if (a[i] + x <= l && used.contains(a[i] + x - y)) {\n                out.println(\"1\");\n                out.println(a[i] + x);\n                return;\n            }\n            if (a[i] - x >= 0 && used.contains(a[i] - x + y)) {\n                out.println(\"1\");\n                out.println(a[i] - x);\n                return;\n            }\n            if (a[i] + y <= l && used.contains(a[i] + y - x)) {\n                out.println(\"1\");\n                out.println(a[i] + y);\n                return;\n            }\n            if (a[i] - y >= 0 && used.contains(a[i] - y + x)) {\n                out.println(\"1\");\n                out.println(a[i] - y);\n                return;\n            }\n            if (used.contains(a[i] - x - y)) {\n                out.println(\"1\");\n                out.println(a[i] - x);\n                return;\n            }\n        }\n        out.println(\"2\");\n        out.println(x + \" \" + y);\n    }\n    \n    static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return gcd(b, a % b);\n        }\n    }\n    \n    static long sqr(int x) {\n        return (long)x * x;\n    }\n    \n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(next());\n    }\n    \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n    \n    static String nextLine() throws IOException {\n        tok = new StringTokenizer(\"\");\n        return in.readLine();\n    }\n\n    static boolean hasNext() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String s = in.readLine();\n            if (s == null) {\n                return false;\n            }\n            tok = new StringTokenizer(s);\n        }\n        return true;\n    }\n\n    public static void main(String args[]) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            //in = new BufferedReader(new FileReader(\"input.in\"));\n            //out = new PrintWriter(new FileWriter(\"output.out\"));\n            solve();\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            java.lang.System.exit(1);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\timport java.io.*;\n\timport java.math.*;\n\timport java.util.*;\n\t\n\tpublic class SolutionD{\n\t\n\t\tpublic static void main(String[] args){\n\t\t\tnew SolutionD().run();\n\t\t}\n\t\tTreeSet <Integer> ts;\n\t\tint a[];\n\t\tint n;\n\t\tboolean con(int x){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(ts.contains(a[i] - x)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvoid solve(){\n\t\t\tn = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tint x = in.nextInt();\n\t\t\tint y = in.nextInt();\n\t\t\tts = new TreeSet<Integer>();\n\t\t\ta = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ta[i] = in.nextInt();\n\t\t\t\tts.add(a[i]);\n\t\t\t}\n\t\t\tboolean ok1 = con(x), ok2 = con(y);\n\t\t\tif(ok1 && ok2) out.println(0);\n\t\t\telse if(ok1) out.println(\"1\\n\" + y);\n\t\t\telse if(ok2) out.println(\"1\\n\" + x);\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(ts.contains(a[i] - x - y)){\n\t\t\t\t\t\tout.println(\"1\\n\" + (a[i] - x));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i] + x <= l && ts.contains(a[i] + x - y)){\n\t\t\t\t\t\tout.println(\"1\\n\" + (a[i] + x));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i] - x >= 0 && ts.contains(a[i] + y - x)){\n\t\t\t\t\t\tout.println(\"1\\n\" + (a[i] - x));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(\"2\\n\" + x + \" \" + y);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint x, y;\n\t\t\tPair(int x, int y){\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Pair o) {\n\t\t\t\tif(o.x == x) return ((Integer) y).compareTo(o.y); \n\t\t\t\treturn ((Integer) x).compareTo(o.x);\n\t\t\t}\n\t\n\t\t}\n\t\tFastScanner in;\n\t\tPrintWriter out;\n\t\tvoid run(){\n\t\t\tin = new FastScanner(System.in);\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t}\n\t\n\t\tvoid runIO(){\n\t\t\ttry{\n\t\t\t\tin = new FastScanner(new File(\"expr.in\"));\n\t\t\t\tout = new PrintWriter(new FileWriter(new File(\"expr.out\")));\n\t\t\t\tsolve();\n\t\t\t\tout.close();\n\t\t\t}catch(Exception ex){\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tclass FastScanner{\n\t\t\tBufferedReader bf;\n\t\t\tStringTokenizer st;\n\t\t\tpublic FastScanner(File f){\n\t\t\t\ttry{\n\t\t\t\t\tbf = new BufferedReader(new FileReader(f));\n\t\t\t\t}\n\t\t\t\tcatch(IOException ex){\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic FastScanner(InputStream is){\n\t\t\t\tbf = new BufferedReader(new InputStreamReader(is), 32768);\n\t\t\t}\n\t\t\tString next(){\n\t\t\t\twhile(st == null || !st.hasMoreTokens()){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tst = new StringTokenizer(bf.readLine());\n\t\t\t\t\t}\n\t\t\t\t\tcatch(IOException ex){\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn st.nextToken();\n\t\t\t}\n\t\t\tint nextInt(){\n\t\t\t\treturn Integer.parseInt(next());\n\t\t\t}\n\t\t\tdouble nextDouble(){\n\t\t\t\treturn Double.parseDouble(next());\n\t\t\t}\n\t\t\tfloat nextFloat(){\n\t\t\t\treturn Float.parseFloat(next());\n\t\t\t}\n\t\t\tString nextLine(){\n\t\t\t\ttry{\n\t\t\t\t\treturn bf.readLine();\n\t\t\t\t}\n\t\t\t\tcatch(Exception ex){\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tlong nextLong(){\n\t\t\t\treturn Long.parseLong(next());\n\t\t\t}\n\t\t\tBigInteger nextBigInteger(){\n\t\t\t\treturn new BigInteger(next());\n\t\t\t}\n\t\t\tBigDecimal nextBigDecimal(){\n\t\t\t\treturn new BigDecimal(next());\n\t\t\t}\n\t\t\tint[] nextIntArray(int n){\n\t\t\t\tint a[] = new int[n];\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\ta[i] = Integer.parseInt(next());\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tlong[] nextLongArray(int n){\n\t\t\t\tlong a[] = new long[n];\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\ta[i] = Long.parseLong(next());\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author sagimbekov_ma\n */\npublic class D479 {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] nlxy = br.readLine().split(\" \");\n        int n = Integer.parseInt(nlxy[0]);\n        int l = Integer.parseInt(nlxy[1]);\n        int x = Integer.parseInt(nlxy[2]);\n        int y = Integer.parseInt(nlxy[3]);\n        int[] a = new int[n];\n\n        String[] line = br.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(line[i]);\n        }\n\n        int[] left = {-1, -1, -1, -1};\n        int[] right = {-1, -1, -1, -1};\n        int[] vals = {y - x, y + x, x, y};\n\n        int i = 0;\n        int j = 0;\n        \n        int ind = 0;\n        while (j < n) {\n            if (a[j] - a[i] > vals[ind]) {\n                i++;\n            } else if (a[j] - a[i] < vals[ind]) {\n                j++;\n                if (j == n) {\n                    break;\n                }\n            } else {\n                if (a[j] + x <= l || a[i] - x >= 0) {\n                    left[ind] = i;\n                    right[ind] = j;\n                    break;\n                } else {\n                    j++;\n                }\n            }\n        }\n        \n        ind = 1;\n        i = 0;\n        j = 0;\n        while (ind < 4) {\n            if (a[j] - a[i] > vals[ind]) {\n                i++;\n            } else if (a[j] - a[i] < vals[ind]) {\n                j++;\n                if (j == n) {\n                    ind++;\n                    i = 0;\n                    j = 0;\n                }\n            } else {\n                left[ind] = i;\n                right[ind] = j;\n                ind++;\n                i = 0;\n                j = 0;\n            }\n        }\n\n        //System.out.println(Arrays.toString(vals));\n        //System.out.println(Arrays.toString(left));\n        //System.out.println(Arrays.toString(right));\n        \n        int min = 2;\n        String res = x + \" \" + y;\n        \n        if (left[0] != -1) {\n            if (a[right[0]] + x <= l) {\n                min = 1;\n                res = (a[right[0]] + x) + \"\";\n            } else if (a[left[0]] - x >= 0) {\n                min = 1;\n                res = (a[left[0]] - x) + \"\";\n            } \n        }\n\n        if (left[1] != -1) {\n            min = 1;\n            res = (a[left[1]] + x) + \"\";\n        }\n\n        if (left[2] != -1) {\n            if (left[3] != -1) {\n                min = 0;\n                res = \"\";\n            } else {\n                min = 1;\n                res = y + \"\";\n            }\n        } else if (left[3] != -1) {\n            min = 1;\n            res = x + \"\";\n        }\n\n        bw.write(min + \"\\n\");\n        if (!res.equalsIgnoreCase(\"\")) {\n            bw.write(res + \"\\n\");\n        }\n        bw.flush();\n\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n, l, x, y = map(int, input().split())\n\ndef f(t, q):\n    i = j = 0\n    while j < n:\n        d = t[j] - t[i]\n        if d < q: j += 1\n        elif d > q: i += 1\n        else: return 0\n    return q\n\ndef g(t):\n    q = x + y\n    i = j = 0\n    while j < n:\n        d = t[j] - t[i]\n        if d < q: j += 1\n        elif d > q: i += 1\n        else: return t[j]\n    return 0\n\ndef h(t):\n    q = y - x\n    i = j = 0\n    while j < n:\n        d = t[j] - t[i]\n        if d < q: j += 1\n        elif d > q: i += 1\n        else:\n            a, b = t[i] - x, t[j] + x\n            if a >= 0: return [a]\n            if b <= l:return [b]\n            j += 1\n    return [x, y]\n\ndef e(t):\n    print(len(t))\n    print(' '.join(map(str, t)))\n\nt = list(map(int, input().split()))\nt.sort()\nx = f(t, x)\ny = f(t, y)\nif x and y:\n    z = g(t)\n    if z: e([z - y])\n    else: e(h(t))\nelif x: e([x])\nelif y: e([y])\nelse: e([])"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class pt{ \n      \n      static int n,l,x,y;\n   \n      public static void main(String[] args)throws IOException { \n                      PrintWriter out = new PrintWriter(System.out);\n\n                         n = ni(); l = ni(); x = ni(); y = ni();\n                         int a[] = new int[n];\n                         HashSet<Integer> h = new HashSet();\n                          for(int i=0;i<n;i++){ a[i]=ni(); h.add(a[i]);}\n\n                 boolean foundX = false , foundY = false;\n\n        for (int i = 0 ; i < n ; ++ i) {\n            if (h.contains(a[i] - x))\n                foundX = true;\n            if (h.contains(a[i] - y))\n                foundY = true;\n        }\n        if (foundX && foundY) System.out.println(0);\n\n        else if (foundX && !foundY) System.out.println(\"1\\n\" + y);\n        else if (!foundX && foundY) System.out.println(\"1\\n\" + x);\n\n       else {\n            for (int i = 0 ; i < n ; ++ i) {\n                if (a[i] + x <= l && (h.contains(a[i] + x + y) || h.contains(a[i] + x - y))) {\n                    System.out.println(\"1\\n\" + (a[i] + x));\n                    return;\n                }\n                if (a[i] - x >= 0 && (h.contains(a[i] - x - y) || h.contains(a[i] - x + y))) {\n                    System.out.println(\"1\\n\" + (a[i] - x));\n                    return;\n                }\n            }\n    \n            System.out.println(\"2\\n\" + x + \" \" + y);\n         } \n\n                      out.flush();\n    } \n\n              static int mod=1000000007;\n              static long pow(long a,long b){\n                       long ans=1;\n                      while(b>0){\n                          if(b%2==1)\n                              ans=(ans*a);\n                              a=(a*a)%mod;\n                              b=b/2;\n                      }\n                    return(ans);\n                }\n             static long gcd(long a,long b){\n                           if(b%a==0)\n                               return(a);\n                               return(gcd(b%a,a));\n              }\n            static long lcm(long a,long b){\n                         return ((a*b)/gcd(a,b));\n               }\n              static void Fact(long a[],long m){\n                              a[0]=1;\n                           for(int i=1;i<a.length;i++)\n                                   a[i]=(i*a[i-1])%m;\n\n                      }\n            /*  static void Fact_Inv(long a[],long F[],long m){\n\n                                 int n =a.length;\n                                     a[n-1]=Fermat(F[n-1],m);\n                                 for(int i=n-2;i>=0;i--)\n                                        a[i]=((i+1)*a[i+1])%m;\n                     \n               static  long d, x, y;\n              static void extendedEuclid(long A, long B) {\n                            if(B == 0) {\n                                  d = A;\n                                  x = 1;\n                                  y = 0;\n                              }\n                           else {\n                                extendedEuclid(B, A%B);\n                                 long temp = x;\n                                  x = y;\n                                 y = temp - (A/B)*y;\n                            }\n                     } */\n                 /*static class pair implements Comparable<pair>{\n                       int x,y;\n                      pair(int a,int b){\n                             x=a;\n                             y=b;\n                       }\n                     public int compareTo(pair p1)\n                           { return((p1.x-p1.y)-(this.x-this.y));}\n          \n                   public boolean equals(Object obj) {\n                         if (this == obj)\n                                return true;\n                        if (obj == null)\n                                return false;\n                        if (getClass() != obj.getClass())\n                                return false;\n                         pair other = (pair) obj;\n                          if (x != other.x)\n                                  return false;\n                          if (y != other.y)\n                                  return false;\n                            return true;\n                      }\n                      @Override\n                 public int hashCode() {\n                      return(x-y);\n                   } \n          }   */\n\n      static void addEdge(LinkedList<Integer> adjList[],int s,int d){\n                             adjList[s].add(d);\n                             adjList[d].add(s);\n              }\n       static int abs(char x,char y)\n                   { return(Math.abs(x-y));}\n        static long min(long x,long y){\n                     return(Math.min(x,y));\n                 }\n        static long max(long a,long b){\n                        return Math.max(a,b);\n                  }    \n    static FastReader sc=new FastReader(); \n \n      static int ni(){\n                 int x = sc.nextInt();\n                 return(x);\n        }\n      static long nl(){\n              long x = sc.nextLong();\n              return(x);\n         }\n      static String n(){\n                 String str = sc.next();\n                     return(str);\n       }\n     static String ns(){\n                 String str = sc.nextLine();\n                   return(str);\n      }\n     static double nd(){\n               double d = sc.nextDouble();\n                 return(d);\n       }\n  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100005];\nbool xok, yok;\npair<int, int> ff(int v) {\n  int l = 0;\n  for (int r = 0; r < n; r++) {\n    while (a[l] + v < a[r]) l++;\n    if (a[l] + v == a[r]) return make_pair(a[l], a[r]);\n  }\n  return make_pair(-1, -1);\n}\npair<int, int> fl(int v) {\n  int r = n - 1;\n  for (int l = n - 1; l >= 0; l--) {\n    while (a[l] + v < a[r]) r--;\n    if (a[l] + v == a[r]) return make_pair(a[l], a[r]);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (ff(x) != make_pair(-1, -1)) xok = true;\n  if (ff(y) != make_pair(-1, -1)) yok = true;\n  if (xok && yok) {\n    cout << 0;\n    return 0;\n  } else if (xok) {\n    cout << 1 << endl << y;\n    return 0;\n  } else if (yok) {\n    cout << 1 << endl << x;\n    return 0;\n  } else {\n    pair<int, int> ss = ff(x + y);\n    if (ss != make_pair(-1, -1)) {\n      cout << 1 << endl << ss.first + x;\n      return 0;\n    }\n    ss = ff(y - x);\n    if (ss != make_pair(-1, -1) && ss.first + y <= l) {\n      cout << 1 << endl << ss.first + y;\n      return 0;\n    }\n    ss = fl(y - x);\n    if (ss != make_pair(-1, -1) && ss.first - x >= 0) {\n      cout << 1 << endl << ss.first - x;\n      return 0;\n    }\n    cout << 2 << endl << x << ' ' << y << endl;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class CodeForces\n{\n       \n    public static void main(String[] args) throws IOException \n\t{\n                 Scanner in = new Scanner(System.in);\n                 int n , l , x , y ;\n                 n = in.nextInt();\n                 l = in.nextInt();\n                 x = in.nextInt();\n                 y = in.nextInt();\n              \n                 int sum = x+y ;\n                 int[] a = new int[n];\n                 for(int i =0 ; i<n ; i++){\n                     a[i] = in.nextInt();\n                 }\n                \n                 List<Integer> x_y_list = new ArrayList<>();\n               \n                 int x_found = 0 , y_found = 0 , x_plus_y_found = 0 , between_found =  0;\n                 for(int i=0 ; i<n ; i++){\n                     \n                  \n                   \n                     if(x_found == 1 && y_found == 1){\n                         System.out.println(0);\n                         return ;\n                     }\n                     \n                     if(x_found == 0){\n                         \n                         int index = Arrays.binarySearch( a , i , n , x+a[i]);\n                         \n                         if(index >= 0){\n                             x_found = 1 ;\n                             \n                         }\n                     }\n                     if(y_found == 0){\n                         int index = Arrays.binarySearch(a, i , n ,  y+a[i]);\n                         if(index >= 0){\n                             y_found = 1 ;\n                           \n                         }\n                     }\n                     \n                        \n                     if(between_found == 0){\n                         if((a[i]+x) <= l ){\n                            \n                         int index = Arrays.binarySearch(a,a[i]+x-y);\n                        \n                         if(index >= 0) {\n                             \n                             between_found = 1 ;\n                             x_y_list.add(a[i]+x);\n                         }\n                     }\n                         if((a[i]-x) >= 0){\n                            int index = Arrays.binarySearch(a,a[i]-x+y);\n                           \n                            \n                          if(index >= 0) {\n                              \n                             between_found = 1 ;\n                             x_y_list.add(a[i]-x);\n                         } \n                       }\n                         \n                     }\n                     \n                     \n                     if(x_plus_y_found == 0 && x != y){\n                        int index = Arrays.binarySearch(a, i , n ,  x+y+a[i]);\n                         if(index >= 0){\n                             x_plus_y_found = 1 ;\n                             x_y_list.add(a[i]+x);\n                         }\n                     }\n                     \n                 }\n                 \n                 if(x_found == 1 && y_found == 1){\n                         System.out.println(0);\n                         return ;\n                     }\n                 if(x_found == 1) {\n                        \n                         System.out.println(1 + \"\\n\" + y);\n                         return ;\n                 }\n                 if(y_found == 1){\n                        System.out.println(1 + \"\\n\" + x);\n                         return ;\n                 }\n                 if(x_plus_y_found == 1 || between_found == 1){\n                        System.out.println(1 + \"\\n\" + (x_y_list.get(0)));\n                         return ;\n                 }\n                \n                   System.out.printf(\"2\\n%d %d\\n\" , x , y);\n                     \n        }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n  }\n  return res;\n}\nint n, l, x, y;\nconst int N = 101000;\nint p[N];\nset<int> st;\nbool c1 = 0, c2 = 0;\nbool check0() {\n  for (int i = 0; i < n; i++) {\n    if (st.count(p[i] + x) || st.count(p[i] - x)) c1 = 1;\n    if (st.count(p[i] + y) || st.count(p[i] - y)) c2 = 1;\n  }\n  return c1 && c2;\n}\nbool check(int c) {\n  if (st.count(c) || c < 0 || c > l) return 0;\n  if ((c1 || st.count(c + x) || st.count(c - x)) &&\n      (c2 || st.count(c + y) || st.count(c - y))) {\n    puts(\"1\");\n    printf(\"%d\\n\", c);\n    return 1;\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", p + i);\n    st.insert(p[i]);\n  }\n  if (check0()) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int i = 0; i < n; i++)\n    if (check(p[i] + x) || check(p[i] - x) || check(p[i] + y) ||\n        check(p[i] - y)) {\n      return 0;\n    }\n  puts(\"2\");\n  printf(\"%d %d\\n\", x, y);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst double pi = 3.141592653589793;\nconst int L_MAX = 1000000005;\nconst int N_MAX = 100005;\nint ar[N_MAX];\nint main(int argc, char const *argv[]) {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  int ai;\n  map<int, int> dict;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &ar[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (!dict.count(ar[i])) dict[ar[i]] = 1;\n  }\n  bool fx = false, fy = false, dif = false, sm = false;\n  int p;\n  for (int i = 0; i < n; i++) {\n    if (dict.count(ar[i] + x)) fx = true;\n    if (dict.count(ar[i] + y)) fy = true;\n    if (dict.count(ar[i] + y - x)) {\n      if (ar[i] + y <= l) {\n        dif = true;\n        p = ar[i] + y;\n      } else if (ar[i] - x >= 0) {\n        dif = true;\n        p = ar[i] - x;\n      }\n    }\n    if (dict.count(ar[i] + (y + x))) {\n      sm = true;\n      p = ar[i] + y;\n    }\n    if (dict.count(ar[i] - (y + x))) {\n      sm = true;\n      p = ar[i] - x;\n    }\n  }\n  if (fx && fy)\n    cout << 0 << endl;\n  else if (fx) {\n    cout << 1 << endl;\n    cout << ar[0] + y << endl;\n  } else if (fy) {\n    cout << 1 << endl;\n    cout << ar[0] + x << endl;\n  } else if (dif) {\n    cout << 1 << endl;\n    cout << p << endl;\n  } else if (sm) {\n    cout << 1 << endl;\n    cout << p << endl;\n  } else {\n    cout << 2 << endl;\n    cout << ar[0] + x << \" \" << ar[0] + y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.SortedMap;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.TreeMap;\n\npublic class B {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\tint n = in.nextInt(), l = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\t\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\thash.add(a[i]);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (hash.contains(a[i] - x)) flag |= 1;\n\t\t\tif (hash.contains(a[i] - y)) flag |= 2;\n\t\t}\n\t\t\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\t\n\t\tint[][] d = new int[][] {{x, -x}, {y, -y}};\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tint mark = a[i] + d[j][k];\n\t\t\t\t\tif (mark < 0 || mark > l) continue;\n\t\t\t\t\tif (map.containsKey(mark)) {\n\t\t\t\t\t\tint value = map.get(mark);\n\t\t\t\t\t\tmap.put(mark, value |= (1 << j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.put(mark, (1 << j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == 3) System.out.println(0);\n\t\telse if (flag == 2) {\n\t\t\tSystem.out.println(1);\n\t\t\tfor (Entry<Integer, Integer> set : map.entrySet()) {\n\t\t\t\tif (set.getValue() == 1) {\n\t\t\t\t\tSystem.out.println(set.getKey());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (flag == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\tfor (Entry<Integer, Integer> set : map.entrySet()) {\n\t\t\t\tif (set.getValue() == 2) {\n\t\t\t\t\tSystem.out.println(set.getKey());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (Entry<Integer, Integer> set : map.entrySet()) {\n\t\t\t\tif (set.getValue() == 3) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(set.getKey());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(2);\n\t\t\tint used = 0;\n\t\t\tfor (Entry<Integer, Integer> set : map.entrySet()) {\n\t\t\t\tif ((used & 1) == 0 && set.getValue() == 1) {\n\t\t\t\t\tused |= 1;\n\t\t\t\t\tSystem.out.print(set.getKey() + \" \");\n\t\t\t\t}  \n\t\t\t\tif ((used & 2) == 0 && set.getValue() == 2) {\n\t\t\t\t\tused |= 2;\n\t\t\t\t\tSystem.out.print(set.getKey() + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
        },
        {
            "language": 1,
            "solution": "#comment to pass again\n\nn,l,x,y = 0,0,0,0\nst,sx,sy = set(),set(),set()\n\nflagx, flagy, one = False, False, False\n\nentrada = [int(h) for h in raw_input().split()]\nn = entrada[0]\nl = entrada[1]\nx = entrada[2]\ny = entrada[3]\na = [0 for i in range(100100)]\nentrada2 = [int(j) for j in raw_input().split()]\n\nfor i in range(n):\n\ta[i]=entrada2[i]\n\tst.add(a[i])\n\tif a[i]==x:\n\t\tflagx=True\n\telif a[i]==y:\n\t\tflagy=True\n\tif a[i]>x and flagx==False:\n\t\tif (a[i]-x) in st:\n\t\t\tflagx = True\n\tif a[i]>y and flagy==False:\n\t\tif (a[i]-y) in st:\n\t\t\tflagy=True\n\nif not flagx and flagy:\n\tprint \"1\\n%d\" % (x)\nelif flagx and not flagy:\n\tprint \"1\\n%d\" % (y)\nelif flagx and flagy:\n\tprint 0\nelif not flagx and not flagy:\n\tone = False\n\tcom = -1\n\t\n\tfor i in range(n):\n\t\tleft = a[i]-x\n\t\tright = a[i]+x\n\t\tif left>=0:\n\t\t\tsx.add(left)\n\t\tif right<=l:\n\t\t\tsx.add(right)\n\n\tfor i in range(n):\n\t\tif one:\n\t\t\tbreak\n\t\tleft = a[i]-y\n\t\tright = a[i]+y\n\t\tif left>=0:\n\t\t\tif left in sx:\n\t\t\t\tone = True\n\t\t\t\tcom = left\n\t\tif right<=l:\n\t\t\tif right in sx:\n\t\t\t\tone = True\n\t\t\t\tcom = right\n   \n\tif one:\n\t\tprint \"1\\n%d\" % (com)\n\telse:\n\t\tprint \"2\\n%d %d\" % (x,y)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> visit;\nint main() {\n  int n, l, x, y, i;\n  while (~scanf(\"%d%d%d%d\", &n, &l, &x, &y)) {\n    visit.clear();\n    int flag = 0;\n    int ans = 0;\n    int tans = 0;\n    for (i = 1; i <= n; i++) {\n      int tmp;\n      scanf(\"%d\", &tmp);\n      visit[tmp] = 1;\n      if (visit[tmp - x]) flag |= 1;\n      if (visit[tmp - y]) flag |= 2;\n      if (visit[tmp - (y - x)] && tmp + x <= l) ans |= 1, tans = tmp + x;\n      if (visit[tmp - (y - x)] && tmp - y >= 0) ans |= 1, tans = tmp - y;\n      if (visit[tmp - x - y]) ans |= 1, tans = tmp - x;\n    }\n    if (flag == 0) {\n      if (ans) {\n        printf(\"%d\\n%d\\n\", 1, tans);\n      } else {\n        printf(\"%d\\n%d %d\\n\", 2, x, y);\n      }\n    } else if (flag == 1) {\n      printf(\"%d\\n%d\\n\", 1, y);\n    } else if (flag == 2) {\n      printf(\"%d\\n%d\\n\", 1, x);\n    } else {\n      printf(\"%d\\n\", 0);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool findBinary(int, int*, int, int);\nint main() {\n  int numberOfMarks, lengthI, distanceOfGirl, distanceOfBoy;\n  int measure[100000];\n  int congNu[100000];\n  int truNu[100000];\n  int congNam[100000];\n  int truNam[100000];\n  bool girl = false, boy = false;\n  cin >> numberOfMarks >> lengthI >> distanceOfGirl >> distanceOfBoy;\n  for (int i = 0; i < numberOfMarks; i++) {\n    cin >> measure[i];\n    int girlProcessedPlus = measure[i] + distanceOfGirl;\n    int boyProcessedPlus = measure[i] + distanceOfBoy;\n    int girlProcessedMinus = measure[i] - distanceOfGirl;\n    int boyProcessedMinus = measure[i] - distanceOfBoy;\n    congNu[i] = girlProcessedPlus;\n    truNu[i] = girlProcessedMinus;\n    congNam[i] = boyProcessedPlus;\n    truNam[i] = boyProcessedMinus;\n  }\n  int flag = 0;\n  girl = findBinary(distanceOfGirl, measure, numberOfMarks, lengthI);\n  boy = findBinary(distanceOfBoy, measure, numberOfMarks, lengthI);\n  if (boy && girl) {\n    cout << \"0\" << endl;\n  } else if (boy) {\n    for (int i = 0; i < numberOfMarks; i++) {\n      if (findBinary(congNu[i], measure, numberOfMarks, lengthI)) {\n        girl = true;\n        break;\n      }\n    }\n    if (girl) {\n      cout << \"0\" << endl;\n    } else {\n      cout << \"1\" << endl << distanceOfGirl;\n    }\n  } else if (girl) {\n    for (int i = 0; i < numberOfMarks; i++) {\n      if (findBinary(congNam[i], measure, numberOfMarks, lengthI)) {\n        boy = true;\n        break;\n      }\n    }\n    if (boy) {\n      cout << \"0\" << endl;\n    } else {\n      cout << \"1\" << endl << distanceOfBoy;\n    }\n  } else {\n    for (int i = 0; i < numberOfMarks; i++) {\n      if (findBinary(congNu[i], measure, numberOfMarks, lengthI)) {\n        girl = true;\n        break;\n      }\n    }\n    for (int i = 0; i < numberOfMarks; i++) {\n      if (findBinary(congNam[i], measure, numberOfMarks, lengthI)) {\n        boy = true;\n        break;\n      }\n    }\n    if (boy && girl) {\n      cout << \"0\" << endl;\n    } else if (boy) {\n      cout << \"1\" << endl << distanceOfGirl;\n    } else if (girl) {\n      cout << \"1\" << endl << distanceOfBoy;\n    } else {\n      for (int i = 0; i < numberOfMarks; i++) {\n        if (findBinary(truNam[i], congNu, numberOfMarks, lengthI)) {\n          flag = truNam[i];\n          break;\n        }\n        if (findBinary(truNam[i], truNu, numberOfMarks, lengthI)) {\n          flag = truNam[i];\n          break;\n        }\n        if (findBinary(congNam[i], congNu, numberOfMarks, lengthI)) {\n          flag = congNam[i];\n          break;\n        }\n        if (findBinary(congNam[i], truNu, numberOfMarks, lengthI)) {\n          flag = congNam[i];\n          break;\n        }\n      }\n      if (flag != 0) {\n        cout << \"1\" << endl << flag;\n      } else {\n        cout << \"2\" << endl << distanceOfGirl << \" \" << distanceOfBoy;\n      }\n    }\n  }\n  return 0;\n}\nbool findBinary(int k, int array[], int size, int lengthI) {\n  if (k >= 0 && k <= lengthI) {\n    int begin = 0;\n    int end = size - 1;\n    int mid = (end - begin) / 2;\n    while (begin <= end) {\n      if (array[mid] == k && array[mid] >= 0 && array[mid] <= lengthI) {\n        return true;\n      }\n      if (array[mid] > k) {\n        end = mid - 1;\n        mid = (begin + end) / 2;\n      } else {\n        begin = mid + 1;\n        mid = (begin + end) / 2;\n      }\n    }\n  }\n  return false;\n}\n"
        },
        {
            "language": 1,
            "solution": "def f2():\n    def is_in(min_index, max_index, a, x):\n        i = min_index\n        for j in range(min_index, max_index + 1):\n            while a[i] - a[j] <= x:\n                if a[i] - a[j] == x:\n                    return a[j], a[i]\n                i += 1\n                if i > max_index:\n                    return False\n        return False\n    n, total, x, y = map(int, raw_input().split())\n    a = map(int, raw_input().split())\n    x, y = sorted([x, y])\n    x_is_in = is_in(0, n - 1, a, x)\n    y_is_in = is_in(0, n - 1, a, y)\n    if x_is_in and y_is_in:\n        print 0\n    elif x_is_in:\n        print 1\n        print y\n    elif y_is_in:\n        print 1\n        print x\n    elif is_in(0, n - 1, a, x + y):\n        print 1\n        print is_in(0, n - 1, a, x + y)[0] + x\n    else:\n        z = y - x\n        i = 0\n        while a[i] < x:\n            i += 1\n        if is_in(i, n - 1, a, z):\n            print 1\n            print is_in(i, n - 1, a, z)[0] - x\n        else:\n            i = n - 2\n            while a[n - 1] - a[i] < x:\n                i -= 1\n            if is_in(0, i, a, z):\n                print 1\n                print is_in(0, i, a, z)[1] + x\n            else:                \n                print 2\n                print x, y\nf2()"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n\n    \n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        int n=sc.i();\n        int l=sc.i();\n        int x=sc.i();\n        int y=sc.i();\n        HashSet<Integer> hs=new HashSet<>();\n        int arr[]=sc.arr(n);\n        for(int i=0;i<n;i++)\n        hs.add(arr[i]);\n        int mark1=0;int mark2=0;\n        for(int i=0;i<n;i++)\n        {\n            if(hs.contains(arr[i]+x))\n            mark1=1;\n            if(hs.contains(arr[i]+y))\n            mark2=1;\n        }\n        if(mark1==1&&mark2==1)\n        out.println(0);\n        else if(mark1==1)\n        {\n            out.println(1);\n            out.println(y);\n        }\n        else if(mark2==1)\n        {\n            out.println(1);\n            out.println(x);\n        }\n        else\n        {\n            for(int i=0;i<n;i++)\n            {\n                if(hs.contains(arr[i]+x+y))\n                {\n                    if(arr[i]+x<=l)\n                    {\n                        System.out.println(1);\n                        System.out.println(x+arr[i]);\n                        System.exit(0);\n                    }\n                }\n                if(hs.contains(arr[i]+x-y))\n                {\n                    if(arr[i]+x<=l&&arr[i]+x>=0)\n                    {\n                        System.out.println(1);\n                        System.out.println(x+arr[i]);\n                        System.exit(0);\n                    }\n                    if(arr[i]-y<=l&&arr[i]-y>=0)\n                    {\n                        System.out.println(1);\n                        System.out.println(-y+arr[i]);\n                        System.exit(0);\n                    }\n                }\n                if(hs.contains(arr[i]+y-x))\n                {\n                    if(arr[i]+y<=l&&arr[i]+y>=0)\n                    {\n                        System.out.println(1);\n                        System.out.println(y+arr[i]);\n                        System.exit(0);\n                    }\n                    if(arr[i]-x<=l&&arr[i]-x>=0)\n                    {\n                        System.out.println(1);\n                        System.out.println(-x+arr[i]);\n                        System.exit(0);\n                    }\n                }\n                if(hs.contains(arr[i]-y-x))\n                {\n                    if(arr[i]-y<=l&&arr[i]-y>=0)\n                    {\n                        System.out.println(1);\n                        System.out.println(arr[i]-y);\n                        System.exit(0);\n                    }\n                }\n            }\n            out.println(2);\n            out.println(x+\" \"+y);\n        }\n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long dx[] = {-1, 0, 1, 0};\nlong long dy[] = {0, -1, 0, 1};\nlong long msum(long long a, long long b, long long m) {\n  return (a % m + b % m) % m;\n}\nlong long msub(long long a, long long b, long long m) {\n  return (a % m - b % m) % m;\n}\nlong long mpro(long long a, long long b, long long m) {\n  return ((a % m) * (b % m)) % m;\n}\nlong long m_m(long long a, long long b, long long m);\nlong long fxp(long long a, long long b, long long m);\nvoid swap(long long &a, long long &b) {\n  long long t = a;\n  a = b;\n  b = t;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    long long n, l, x, y, i, j;\n    cin >> n >> l >> x >> y;\n    vector<long long> v;\n    vector<long long> res;\n    map<long long, long long> m;\n    for (i = 0; i < n; i++) {\n      long long tm;\n      cin >> tm;\n      v.push_back(tm);\n      m[tm] = 1;\n    }\n    long long check_x = 0, check_y = 0, res1 = -1, res2 = -1;\n    for (i = 0; i < n; i++) {\n      if (m[v[i] + x]) check_x = 1;\n      if (m[v[i] + y]) check_y = 1;\n      if (m[v[i] + y + x] && res1 == -1) {\n        res1 = v[i] + y;\n      }\n      if (m[v[i] + y - x] && res1 == -1) {\n        if (v[i] + y <= l) res1 = v[i] + y;\n        if (v[i] - x >= 0) res1 = v[i] - x;\n      }\n    }\n    if (check_x && check_y)\n      cout << 0;\n    else if (check_x)\n      cout << 1 << \"\\n\" << y;\n    else if (check_y)\n      cout << 1 << \"\\n\" << x;\n    else if (res1 != -1)\n      cout << 1 << \"\\n\" << res1;\n    else {\n      cout << 2 << \"\\n\";\n      cout << x << \" \" << y;\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\nlong long fxp(long long a, long long b, long long m) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) return fxp(m_m(a, a, m), b / 2, m);\n  return m_m(fxp(a, b - 1, m), a, m);\n}\nlong long m_m(long long a, long long b, long long m) {\n  long long res = 0;\n  a = a % m;\n  while (b) {\n    if (b & 1) {\n      res += a;\n      res = res % m;\n    }\n    a = (a * 2) % m;\n    b = b / 2;\n  }\n  return res;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\npublic class B {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\tint n = in.nextInt(), l = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\t\n\t\tint flag = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\thash.add(a[i]);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (hash.contains(a[i] - x)) flag |= 1;\n\t\t\tif (hash.contains(a[i] - y)) flag |= 2;\n\t\t}\n\t\t\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\t\n\t\tint[][] d = new int[][] {{x, -x}, {y, -y}};\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tint mark = a[i] + d[j][k];\n\t\t\t\t\tif (mark < 0 || mark > l) continue;\n\t\t\t\t\tif (map.containsKey(mark)) {\n\t\t\t\t\t\tint value = map.get(mark);\n\t\t\t\t\t\tmap.put(mark, value |= (1 << j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.put(mark, (1 << j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == 3) System.out.println(0);\n\t\telse if (flag == 2) {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(x);\n\t\t} else if (flag == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(y);\n\t\t} else {\n\t\t\tfor (Entry<Integer, Integer> set : map.entrySet()) {\n\t\t\t\tif (set.getValue() == 3) {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\tSystem.out.println(set.getKey());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(x + \" \" + y);\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.util.Set;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Morgrey\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt(), l = in.readInt(), x = in.readInt(), y = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            Set<Integer> s = new HashSet<>();\n            for (int i = 0; i < n; ++i) {\n                s.add(a[i]);\n            }\n            boolean f1 = false, f2 = false;\n            for (int i = 0; i < n; ++i) {\n                if (s.contains(a[i] - x)) {\n                    f1 = true;\n                }\n                if (s.contains(a[i] - y)) {\n                    f2 = true;\n                }\n            }\n            if (f1 && f2) {\n                out.print(0);\n                return;\n            }\n            if (f1) {\n                out.printLine(1);\n                out.print(y);\n                return;\n            }\n            if (f2) {\n                out.printLine(1);\n                out.print(x);\n                return;\n            }\n            for (int i = 0; i < n; ++i) {\n                int pos = a[i] - x;\n                if (pos >= 0 && (s.contains(pos - y) || s.contains(pos + y))) {\n                    out.printLine(1);\n                    out.print(pos);\n                    return;\n                }\n                pos = a[i] + x;\n                if (pos <= l && (s.contains(pos - y) || s.contains(pos + y))) {\n                    out.printLine(1);\n                    out.print(pos);\n                    return;\n                }\n            }\n            out.printLine(2);\n            out.print(x + \" \");\n            out.print(y);\n            return;\n        }\n\n    }\n\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = in.readInt();\n            return array;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(int i) {\n            writer.print(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  set<int> d;\n  for (int i = 0; i < n; ++i) {\n    int t;\n    cin >> t;\n    d.insert(t);\n  }\n  bool issetX = false, issetY = false;\n  for (set<int>::iterator i = d.begin(); i != d.end(); ++i) {\n    if (d.find(*i + x) != d.end()) {\n      issetX = true;\n    }\n    if (d.find(*i + y) != d.end()) {\n      issetY = true;\n    }\n  }\n  if (issetX && issetY) {\n    cout << 0;\n    return 0;\n  } else if (issetX) {\n    cout << \"1 \" << endl << y;\n  } else if (issetY) {\n    cout << \"1 \" << endl << x;\n  } else {\n    int point = -1;\n    for (set<int>::iterator i = d.begin(); i != d.end(); ++i) {\n      if (d.find(*i + (y - x)) != d.end()) {\n        if (*i - x >= 0) {\n          point = *i - x;\n          break;\n        } else if (*i + (y - x) + x <= l) {\n          point = *i + (y - x) + x;\n          break;\n        }\n      }\n      if (d.find(*i + (y + x)) != d.end()) {\n        point = *i + x;\n        break;\n      }\n    }\n    if (point < 0) {\n      cout << \"2 \" << endl << x << \" \" << y;\n    } else {\n      cout << \"1 \" << endl << point;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T abS(T a) {\n  return ((a >= 0) ? a : -a);\n}\ntemplate <class T>\ninline T maX(T a, T b) {\n  return ((a > b) ? a : b);\n}\ntemplate <class T>\ninline T miN(T a, T b) {\n  return ((a < b) ? a : b);\n}\ntemplate <class T>\ninline void updmin(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\ninline void updmax(T &a, T b) {\n  if (b > a) a = b;\n}\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  set<int> S;\n  for (int i = 0; i < n; i++) {\n    int t;\n    cin >> t;\n    S.insert(t);\n  }\n  set<int>::iterator it = S.begin();\n  bool isx = 0, isy = 0;\n  for (typeof(S.begin()) it = S.begin(); it != S.end(); it++) {\n    int k = *it;\n    if (k <= l - x) {\n      if (S.count(k + x)) {\n        isx = 1;\n        break;\n      }\n    }\n  }\n  set<int>::iterator itt = S.begin();\n  for (typeof(S.begin()) it = S.begin(); it != S.end(); it++) {\n    int k = *it;\n    if (k <= l - y) {\n      if (S.count(k + y)) {\n        isy = 1;\n        break;\n      }\n    }\n  }\n  if (isx && isy) {\n    cout << 0;\n    return 0;\n  }\n  if (isx) {\n    cout << 1 << endl << y;\n    return 0;\n  }\n  if (isy) {\n    cout << 1 << endl << x;\n    return 0;\n  }\n  int p = y - x;\n  bool can = false;\n  for (typeof(S.begin()) it = S.begin(); it != S.end(); it++) {\n    int k = *it;\n    if (k <= l - p) {\n      if (S.count(k + p)) {\n        if (k + p + x <= l) {\n          cout << 1 << endl << k + p + x;\n          return 0;\n        }\n        if (k - x >= 0) {\n          cout << 1 << endl << k - x;\n          return 0;\n        }\n      }\n    }\n  }\n  p = x + y;\n  for (typeof(S.begin()) it = S.begin(); it != S.end(); it++) {\n    int k = *it;\n    if (k <= l - p) {\n      if (S.count(k + p)) {\n        cout << 1 << endl << k + x;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl << x << \" \" << y;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, l, x, y = map(int, stdin.readline().split())\n    a = map(int, stdin.readline().split(), repeat(10, n))\n    s = set(a)\n    f = 0\n    for t in a:\n        if t + x in s:\n            f |= 1\n        if t + y in s:\n            f |= 2\n    if f == 3:\n        print 0\n    elif f == 1:\n        print 1\n        print y\n    elif f == 2:\n        print 1\n        print x\n    else:\n        sx = set(t + x for t in a if 0 <= t + x <= l) | set(t - x for t in a if 0 <= t - x <= l)\n        sy = set(t + y for t in a if 0 <= t + y <= l) | set(t - y for t in a if 0 <= t - y <= l)\n        z = sx & sy\n        if z:\n            print 1\n            print z.pop()\n        else:\n            print 2\n            print x, y\nmain()\n"
        },
        {
            "language": 1,
            "solution": "\nimport sys\nstdin = sys.stdin\n\nn, L, x, y = map(int, stdin.readline().strip().split())\nan = map(int,         stdin.readline().strip().split())\n\nneed = set([x,y])\nmarks = set(an)\nfor aa in an:\n    for k in [x, y]:\n        if (aa+k) in marks:\n            if k in need:\n                need.remove(k)\n\nneed = list(need)\nif len(need) == 1:\n    print 1\n    print need[0]\nelif len(need) == 0:\n    print \"0\"\nelse:\n    got_it = None\n    for aa in an:\n        for sign in [-1, 1]:\n            cand = aa + sign*need[0]\n            if not (0 <= cand <= L):\n                continue\n            for s2 in [-1, 1]:\n                c2 = cand + s2*need[1]\n                if c2 in marks:\n                    got_it = cand\n                    break\n            if None != got_it:\n                break\n        if None != got_it:\n            break\n\n    if None != got_it:\n        print \"1\"\n        print got_it\n    else:\n        print \"2\"\n        print need[0], need[1]\n            \n    \n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n/**\n *\n * @author saumya\n */\n\npublic class longJump{\n    \n\tpublic static void main(String[] args){\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint l = in.nextInt();\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\t\n\t\tArrayList<Integer> arr = new ArrayList<Integer>();\n\t\tHashSet<Integer> hrr = new HashSet<Integer>();\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint inp = in.nextInt();\n\t\t\tarr.add(inp);\n\t\t\thrr.add(inp);\n\t\t}\n\t\t\n\t\tint cntx = 0;\n\t\tint cnty = 0;\n\t\tint cntsum = 0;\n\t\tint flag = 0;\n\t\tint sum = 0;\n\t\tint diff = y-x;\n\t\tint cntdiff = 0;\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint e = arr.get(i);\n\t\t//\tout.println(e+\" \"+x+ \" \"+y);\n\t\t\tif(hrr.contains(e-x) || hrr.contains(e+x))\n\t\t\t\tcntx = 1;\n\t\t\tif(hrr.contains(e-y) || hrr.contains(e+y))\n\t\t\t\tcnty = 1;\n\t\t\tif((hrr.contains(e-x-y) || hrr.contains(e+x+y)) && flag==0){\n\t\t\t\tcntsum = 1;\n\t\t\t\tflag = 1;\n\t\t\t\tsum = e;\n\t\t\t}\n\t\t\tif(i!=n-1){\n\t\t\t\tif(hrr.contains(arr.get(i)+diff)){\n\t\t\t\t\tif(arr.get(i)+y<l)\n\t\t\t\t\t\tcntdiff = arr.get(i) + y;\n\t\t\t\t\telse if(arr.get(i)-x>0)\n\t\t\t\t\t\tcntdiff = arr.get(i) - x;\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(cntx==1 && cnty==1){\n\t\t\tout.println(\"0\");\n\t\t}\n\t\t\n\t\telse if(cntx==1 || cnty==1){\n\t\t\tif(cntx==1){\n\t\t\t\tout.println(\"1\");\n\t\t\t\tout.println(y);\n\t\t\t}\n\t\t\t\n\t\t\tif(cnty==1){\n\t\t\t\tout.println(\"1\");\n\t\t\t\tout.println(x);\n\t\t\t}\n\t\t}\n\t\t\n\t\telse{\n\t\t\tif(cntsum==1){\n\t\t\t\tout.println(\"1\");\n\t\t\t\tif(hrr.contains(sum-x-y))\n\t\t\t\t\tout.println(sum-x);\n\t\t\t\telse\n\t\t\t\t\tout.println(sum+x);\n\t\t\t}\n\t\t\telse if(cntdiff!=0){\n\t\t\t\tout.println(\"1\");\n\t\t\t\tout.println(cntdiff);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tout.println(\"2\");\n\t\t\t\tout.println(x +\" \" +y);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tout.close();\n\t}\n    \n    static class Pair implements Comparable<Pair>{\n\n        long x,y;\n        int i;\n        \n\n\tPair (long x,long y,int i){\n\t\tthis.x=x;\n\t\tthis.y=y;\n                this.i=i;\n\t}\n        \n\tpublic int compareTo(Pair o) {\n\t\tif(this.x!=o.x)\n                    return Long.compare(this.x,o.x);\n\t\telse\n                    return Long.compare(this.y,o.y);\n\t\t//return 0;\n\t}\n\n            public boolean equals(Object o) {\n            if (o instanceof Pair) {\n                Pair p = (Pair)o;\n                return p.x == x && p.y == y && p.i==i;\n            }\n            return false;\n        }\n    } \n    \n    public static boolean isPal(String s){\n        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n                if(s.charAt(i)!=s.charAt(j)) return false;\n        }\n        return true;\n    }\n    public static String rev(String s){\n\t\tStringBuilder sb=new StringBuilder(s);\n\t\tsb.reverse();\n\t\treturn sb.toString();\n    }\n    \n    public static long gcd(long x,long y){\n\tif(x%y==0)\n\t\treturn y;\n\telse\n\t\treturn gcd(y,x%y);\n    }\n    \n    public static int gcd(int x,int y){\n\tif(x%y==0)\n\t\treturn y;\n\telse \n\t\treturn gcd(y,x%y);\n    }\n    \n    public static long gcdExtended(long a,long b,long[] x){\n        \n        if(a==0){\n            x[0]=0;\n            x[1]=1;\n            return b;\n        }\n        long[] y=new long[2];\n        long gcd=gcdExtended(b%a, a, y);\n        \n        x[0]=y[1]-(b/a)*y[0];\n        x[1]=y[0];\n        \n        return gcd;\n    }\n    \n    public static int abs(int a,int b){\n\treturn (int)Math.abs(a-b);\n    }\n\n    public static long abs(long a,long b){\n\treturn (long)Math.abs(a-b);\n    }\n    \n    public static int max(int a,int b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static int min(int a,int b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n    \n    public static long max(long a,long b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static long min(long a,long b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n\n    public static long pow(long n,long p,long m){\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n    }\n    \n    public static long pow(long n,long p){\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n    }\n    \n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n                \n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nvector<int> vc;\nint L;\nbool doit(int x, int l) {\n  if (x - l >= 0) {\n    int low = *lower_bound(vc.begin(), vc.end(), x - l);\n    if (low == x - l) {\n      return true;\n    }\n  }\n  if (x + l <= L) {\n    int low = *lower_bound(vc.begin(), vc.end(), x + l);\n    if (low == x + l) return true;\n  }\n  return false;\n}\nint main() {\n  int n, l, x, y, i, a, flag1 = 0, flag2 = 0, ans = 2, coord = -1;\n  scanf(\"%d\", &n), scanf(\"%d\", &l), scanf(\"%d\", &x), scanf(\"%d\", &y);\n  L = l;\n  for (i = (1); i <= (n); ++i) {\n    scanf(\"%d\", &a);\n    vc.push_back(a);\n  }\n  for (i = (1); i <= (n); ++i) {\n    a = vc[i - 1];\n    if (a >= x && flag1 == 0) {\n      int low = *lower_bound(vc.begin(), vc.end(), a - x);\n      flag1 = (low == a - x);\n    }\n    if (a >= y && flag2 == 0) {\n      flag2 = ((*lower_bound(vc.begin(), vc.end(), a - y)) == a - y);\n    }\n    if (ans == 2) {\n      if (a + x < l)\n        if (doit(a + x, y)) {\n          ans = 1, coord = a + x;\n          continue;\n        }\n      if (a - x > 0)\n        if (doit(a - x, y)) {\n          ans = 1, coord = a - x;\n          continue;\n        }\n      if (a + y < l)\n        if (doit(a + y, x)) {\n          ans = 1, coord = a + y;\n          continue;\n        }\n      if (a - y > 0)\n        if (doit(a - y, x)) {\n          ans = 1, coord = a - y;\n          continue;\n        }\n    }\n  }\n  if (flag1 == 1 && flag2 == 1) {\n    cout << 0 << endl;\n  } else if (ans == 1) {\n    cout << 1 << endl << coord << endl;\n  } else {\n    cout << (flag1 == 0) + (flag2 == 0) << endl;\n    if (flag1 == 0) cout << x << \" \";\n    if (flag2 == 0) cout << y;\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\n\"\"\"\nnotes:\n1) how to test x or y could be marked\n2) how to add marks\n\ta) minimum\n\tb) within range\n\"\"\"\n\n\ndef read_inputs():\n\tlines = sys.stdin.readlines()\n\tfor i in range(0, len(lines), 2):\n\t\tn, l, x, y = map(int, lines[i].strip().split())\n\t\tmarks = map(int, lines[i+1].strip().split())\n\t\tyield x, y, marks\n\n\ndef test(m, t, marks):\n\tif t == m:\n\t\treturn True\n\telif m < t:\n\t\treturn (m + t) in marks\n\telse:\n\t\treturn (m - t) in marks\n\n\ndef all_possible_marks(t, marks):\n\tu = max(marks)\n\ts = set()\n\tfor m in marks:\n\t\tif 0 <= (m + t) <= u:\n\t\t\ts.add(m + t)\n\t\tif 0 <= (m - t) <= u:\n\t\t\ts.add(m - t)\n\treturn s\n\n\ndef add_marks(x, x_ok, y, y_ok, marks):\n\tif (not x_ok) and (not y_ok):\n\t\tlower, upper = min(marks), max(marks)\n\t\tx_marks = all_possible_marks(x, marks)\n\t\ty_marks = all_possible_marks(y, marks)\n\t\tinter = x_marks.intersection(y_marks)\t\n\t\tif len(inter) != 0:\n\t\t\treturn 1, [inter.pop()]\n\t\telse:\n\t\t\treturn 2, [x, y]\n\telif not x_ok:\n\t\treturn 1, [x]\n\telif not y_ok:\n\t\treturn 1, [y]\n\telse:\n\t\treturn 0, []\n\n\n\ndef solve(x, y, marks):\n\tx_ok = y_ok = False\n\tfor m in marks:\n\t\tif x_ok and y_ok:\n\t\t\tbreak\n\t\tif not x_ok and test(m, x, marks):\n\t\t\tx_ok = True\n\t\tif not y_ok and test(m, y, marks):\n\t\t\ty_ok = True\n\n\treturn add_marks(x, x_ok, y, y_ok, marks) \n\n\ndef main():\n\tfor x, y, marks in read_inputs():\n\t\tn, marks = solve(x, y, set(marks))\n\t\tprint n\n\t\tif n != 0: \n\t\t\tprint \" \".join(map(str, marks))\n\n\nif __name__ == \"__main__\":\n\tmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nint getbit(T s, int i) {\n  return (s >> i) & 1;\n}\ntemplate <class T>\nT onbit(T s, int i) {\n  return s | (T(1) << i);\n}\ntemplate <class T>\nT offbit(T s, int i) {\n  return s & (~(T(1) << i));\n}\ntemplate <class T>\nint cntbit(T s) {\n  return __builtin_popcountll(s);\n}\nconst int bfsz = 1 << 16;\nchar bf[bfsz + 5];\nint rsz = 0;\nint ptr = 0;\nchar gc() {\n  if (rsz <= 0) {\n    ptr = 0;\n    rsz = (int)fread(bf, 1, bfsz, stdin);\n    if (rsz <= 0) return EOF;\n  }\n  --rsz;\n  return bf[ptr++];\n}\nvoid ga(char &c) {\n  c = EOF;\n  while (!isalpha(c)) c = gc();\n}\nint gs(char s[]) {\n  int l = 0;\n  char c = gc();\n  while (isspace(c)) c = gc();\n  while (c != EOF && !isspace(c)) {\n    s[l++] = c;\n    c = gc();\n  }\n  s[l] = '\\0';\n  return l;\n}\ntemplate <class T>\nbool gi(T &v) {\n  v = 0;\n  char c = gc();\n  while (c != EOF && c != '-' && !isdigit(c)) c = gc();\n  if (c == EOF) return false;\n  bool neg = c == '-';\n  if (neg) c = gc();\n  while (isdigit(c)) {\n    v = v * 10 + c - '0';\n    c = gc();\n  }\n  if (neg) v = -v;\n  return true;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  T r;\n  while (b != 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ntemplate <class T>\nT lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\nint n, l, x, y, a[500005];\nmap<int, int> M;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> l >> x >> y;\n  for (int i = (1); i <= (n); ++i) {\n    cin >> a[i];\n    M[a[i]] = 1;\n  }\n  bool have0 = false, have1 = false;\n  for (int i = (1); i <= (n); ++i) {\n    int d = a[i] + x;\n    if (d <= l && M[d]) have0 = true;\n    d = a[i] + y;\n    if (d <= l && M[d]) have1 = true;\n  }\n  if (have0 && have1) {\n    cout << 0 << endl;\n    return 0;\n  } else if (have0) {\n    cout << 1 << endl;\n    cout << y << endl;\n  } else if (have1) {\n    cout << 1 << endl;\n    cout << x << endl;\n  } else {\n    for (int i = (1); i <= (n); ++i) {\n      int d = a[i] + x;\n      if (d <= l && d >= 0 && (M[d + y] || M[d - y])) {\n        cout << 1 << endl;\n        cout << d << endl;\n        return 0;\n      }\n      d = a[i] - x;\n      if (d <= l && d >= 0 && (M[d + y] || M[d - y])) {\n        cout << 1 << endl;\n        cout << d << endl;\n        return 0;\n      }\n    }\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from itertools import ifilter\nfrom bisect import bisect\n\ndef is_exists(line, d):\n    found = lambda res, x: res and line[res - 1] == x - d\n    return next(ifilter(lambda x: found(bisect(line, x - d), x), line), None)\n\n\ndef is_exists_bounds(line, d, x, y):\n    bounds = lambda res: res - max(x, y) >= line[0] or res + min(x, y) <= line[-1]\n    found = lambda res, x: res and line[res - 1] == x - d and bounds(x)\n    return next(ifilter(lambda x: found(bisect(line, x - d), x), line), None)\n\n\ndef main():\n    n, l, x, y = map(int, raw_input().split())\n    line = map(int, raw_input().split())\n    boys = is_exists(line, y)\n    girls = is_exists(line, x)\n    diff = is_exists_bounds(line, abs(x - y), x, y)\n    summ = is_exists(line, x + y)\n    if boys and girls:\n        print 0\n    elif boys:\n        print 1, x\n    elif girls:\n        print 1, y\n    elif summ:\n        print 1, summ - min(x, y)\n    elif diff and diff + min(x, y) <= line[-1]:\n        print 1, diff  + min(x, y)\n    elif diff and diff - max(x, y) >= line[0]:\n        print 1, diff - max(x, y)\n    else:\n        print 2, x, y\n    \nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint num[100010];\nmap<int, int> mymap;\nint main() {\n  int n;\n  int l;\n  int x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &num[i]);\n    mymap[num[i]] = 1;\n  }\n  if (mymap[x] == 1 && mymap[y] == 1) {\n    printf(\"0\");\n  } else {\n    sort(num, num + n);\n    bool flag1 = 0, flag2 = 0;\n    for (int i = 0; i < n; i++) {\n      if (num[i] + x > l) break;\n      if (mymap[num[i] + x] == 1) {\n        flag1 = 1;\n      }\n      if (mymap[num[i] + y] == 1) {\n        flag2 = 1;\n      }\n    }\n    if (flag1 && flag2) {\n      cout << 0;\n    } else if (flag1 && !flag2) {\n      cout << 1 << endl;\n      cout << y;\n    } else if (!flag1 && flag2) {\n      cout << 1 << endl;\n      cout << x;\n    } else {\n      bool flag = 0;\n      int ans1;\n      for (int i = 0; i < n; i++) {\n        if (num[i] + x + y <= l && mymap[num[i] + x + y] == 1) {\n          if (num[i] + x <= l) {\n            ans1 = x + num[i];\n            flag = 1;\n            break;\n          }\n        }\n        if (num[i] + x - y <= l && mymap[num[i] + x - y] == 1) {\n          if (num[i] + x <= l) {\n            ans1 = x + num[i];\n            flag = 1;\n            break;\n          }\n        }\n        if (num[i] - x + y <= l && mymap[num[i] - x + y] == 1) {\n          if (num[i] - x >= 0) {\n            ans1 = num[i] - x;\n            flag = 1;\n            break;\n          }\n        }\n        if (num[i] - x - y <= l && mymap[num[i] - x - y] == 1) {\n          ans1 = num[i] - x;\n          flag = 1;\n          break;\n        }\n        if (num[i] + y - x <= l && mymap[num[i] + y - x] == 1) {\n          if (num[i] + y <= l) {\n            ans1 = num[i] + y;\n            flag = 1;\n            break;\n          }\n        }\n        if (num[i] - y + x <= l && mymap[num[i] - y + x] == 1) {\n          if (num[i] - y >= 0) {\n            ans1 = num[i] - y;\n            flag = 1;\n            break;\n          }\n        }\n      }\n      if (flag == 1) {\n        cout << 1 << endl;\n        cout << ans1;\n      } else {\n        cout << 2 << endl;\n        cout << x << ' ' << y;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner();\n\t\t\n\t\t\n\t\tint n = sc.nextInt() , l = sc.nextInt() , x = sc.nextInt() , y = sc.nextInt();\n\t\t\n\t\tint []  a = new int [n];\n\t\t\n\t\tfor(int i = 0 ; i < n ;i++)\n\t\t\ta[i] = sc.nextInt();\n\t\t\n\t\t\n\t\tboolean can1 = false ; \n\t\tboolean can2 = false;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tcan1 |= canGet(a, x, i);\n\t\t\tcan2 |= canGet(a, y, i);\n\t\t\t\n\t\t}\n\t\t\n\t\tif(can1 && can2)\n\t\t\tSystem.out.println(0);\n\t\telse if(can1)\n\t\t\tSystem.out.println(1+\"\\n\"+y);\n\t\telse if(can2)\n\t\t\tSystem.out.println(1+\"\\n\"+x);\n\t\telse \n\t\t{\n\t\t\tint ans = canPut(a, x, y , l);\n\t\t\tif(ans == -1)\n\t\t\t\tSystem.out.println(2+\"\\n\"+x+\" \"+y);\n\t\t\telse\n\t\t\t\tSystem.out.println(1+\"\\n\"+ans);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\n\t}\n\t\n\tstatic boolean canGet(int [] a , int x , int curr )\n\t{\n\t\t\n\t\tint start = 0 , end = curr - 1 ; \n\t\t\n\t\twhile(start <= end)\n\t\t{\n\t\t\tint mid = (start + end ) / 2 ;\n\t\t\t\n\t\t\tif(a[curr] - a[mid] == x )\n\t\t\t\treturn true ; \n\t\t\t\n\t\t\tif(a[curr] - a[mid] < x)\n\t\t\t\tend = mid - 1 ; \n\t\t\telse \n\t\t\t\tstart = mid + 1 ; \n\t\t}\n\t\t\n\t\treturn false ; \n\t\t\n\t}\n\t\n\tstatic int canPut(int [] a , int x , int y , int l )\n\t{\n\t\tHashSet <Integer> set1 = new HashSet<>();\n\t\tHashSet <Integer> set2 = new HashSet<>();\n\t\t\n\t\tfor(int xx : a)\n\t\t{\n\t\t\tset1.add(xx + x);\n\t\t\tset1.add(xx - x);\n\t\t\t\n\t\t}\n\t\tfor(int yy : a)\n\t\t{\n\t\t\tset2.add(yy + y);\n\t\t\tset2.add(yy - y);\n\t\t\t\n\t\t}\n\t\tfor(int xx : set1)\n\t\t\tif(set2.contains(xx) && xx >= 0 && xx <= l)\n\t\t\t\treturn xx ; \n\t\t\n\t\treturn -1 ; \t\n\t}\n\t\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st ;\n\t\t\n\t\tString next() throws Exception\n\t\t{\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() throws Exception\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() throws Exception\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception{\n        //Scanner sc = new Scanner(System.in);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] buf = reader.readLine().split(\" \");\n        int[] para = new int[4];\n        for(int i=0;i<4;i++) para[i]=Integer.parseInt(buf[i]);\n        int n = para[0], len = para[1], x = para[2], y = para[3];\n        int[] a = new int[n];\n        buf = reader.readLine().split(\" \");\n        for(int i=0;i<n;i++) a[i]=Integer.parseInt(buf[i]);\n        int[] ans = solve(n,len,x,y,a);\n        System.out.println(ans.length);\n        for(int w:ans) System.out.print(String.format(\"%d \",w));\n    }\n    static int[] solve(int n, int len, int x, int y, int[] a){\n        HashSet<Integer> xy = new HashSet<>(), range = new HashSet<>();\n        xy.add(x); xy.add(y);\n        for(int i:a) range.add(i);\n        for(int w:a){\n            if(range.contains(w+x)/*||range.contains(w-x)*/) xy.remove(x);\n            if(range.contains(w+y)/*||range.contains(w-y)*/) xy.remove(y);\n            if(xy.size()==0){\n                return new int[0];\n            }\n        }\n        if(xy.size()==1){\n            for(int i:xy) return new int[]{i};\n        }\n        for(int w:a){\n            if(range.contains(w+x+y)){\n                return new int[]{w+x};\n            }\n            if(range.contains(w+y)){\n                return new int[]{w+x};\n            }\n            if(range.contains(w+y-x)&&w-x>=0) return new int[]{w-x};\n            if(range.contains(w+y-x)&&w+y<=len) return new int[]{w+y};\n        }\n        return new int[]{x,y};\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long nC2(long long a) {\n  long long t = a;\n  t *= t - 1;\n  t /= 2;\n  return t;\n}\nint arr[1000001];\nint main() {\n  long long n, l, x, y;\n  bool fx = 0, fy = 0;\n  int a = 2;\n  cin >> n >> l >> x >> y;\n  map<long long, int> make_pair;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    make_pair[arr[i]] = 1;\n  }\n  for (int i = 0; i < n && a; i++) {\n    if (!fx) {\n      if (make_pair[x + arr[i]] == 1 || make_pair[arr[i] - x] == 1) {\n        fx = 1;\n        a--;\n      }\n    }\n    if (!fy) {\n      if (make_pair[y + arr[i]] == 1 || make_pair[arr[i] - y] == 1) {\n        fy = 1;\n        a--;\n      }\n    }\n  }\n  if (a == 0)\n    cout << a << endl;\n  else {\n    if (a == 1) {\n      cout << a << endl;\n      if (fx)\n        cout << y << endl;\n      else\n        cout << x << endl;\n    } else {\n      bool nf = 1;\n      long long X;\n      for (int i = 0; i < n && nf; i++) {\n        long long z = arr[i] + x;\n        if (z >= 0 && z <= l) {\n          if (make_pair[z + y] == 1 || make_pair[z - y] == 1) {\n            nf = 0;\n            X = z;\n            break;\n          }\n        }\n        z = arr[i] - x;\n        if (z >= 0 && z <= l) {\n          if (make_pair[z + y] == 1 || make_pair[z - y] == 1) {\n            nf = 0;\n            X = z;\n            break;\n          }\n        }\n      }\n      if (nf == 0) {\n        cout << 1 << endl;\n        cout << X << endl;\n      } else {\n        cout << 2 << endl;\n        cout << x << ' ';\n        cout << y << endl;\n      }\n    }\n  }\n  cin >> n;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Long Jumps\nimport java.util.*;\npublic class CF479D_LongJumps {\n\n    public static void main(String[] args){\n        \n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        HashSet<Integer> s0 = new HashSet<Integer>();\n        HashSet<Integer> s1 = new HashSet<Integer>();\n        HashSet<Integer> s2 = new HashSet<Integer>();\n        for(int i = 0; i < n; i++) s0.add(in.nextInt());\n            \n        for(int e: s0){\n                \n            if(e - a >= 0) s1.add(e - a);\n            if(e + a <= m) s1.add(e + a);\n            if(e - b >= 0) s2.add(e - b);\n            if(e + b <= m) s2.add(e + b);\n        }\n            \n        int is = -1;\n        for(int e: s1){\n                \n            if(s2.contains(e)){\n                is = e;\n                break;\n            }\n        }\n        \n        int is1 = -1;\n        int is2 = -1;\n        for(int e: s0){\n            \n            if(s1.contains(e)) is1 = e;\n            if(s2.contains(e)) is2 = e;\n        }\n        \n        if(is2 != -1 && is1 != -1) System.out.println(\"0\");\n        else if(is2 != -1 || is1 != -1) System.out.println(\"1\\n\" + (is1!=-1 ? b : a));\n        else{\n            \n            if(is!= -1) System.out.println(\"1\\n\" + is);\n            else System.out.println(\"2\\n\" + a + \" \" + b);\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "//LongJump.java\n\nimport java.util.*;\n\npublic class LongJump{\n  private static HashMap<Integer,Integer> numStore;\n  private static int additionalMarks;\n  private static int[] numStoreArr;\n  private static int N,L,X,Y;\n  private static int diff,diffLocation,diffMark,totalDist,middleLocation;\n  private static boolean foundDiff,foundMiddleMark;\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    numStore = new HashMap<Integer,Integer>();\n    additionalMarks = 0;\n    boolean foundX, foundY;\n    N = sc.nextInt();\n    L = sc.nextInt();\n    X = sc.nextInt();\n    Y = sc.nextInt();\n    int currNum;\n    diff = Y-X;\n    totalDist= X+Y;\n    diffLocation = -1;\n    foundDiff = foundMiddleMark = false;\n    numStoreArr = new int[N];\n    for(int i=0;i<N;i++){\n      currNum = sc.nextInt();\n      numStoreArr[i] = currNum;\n      numStore.put(currNum,currNum);\n    }\n    foundX = findMarks(X);\n    foundY = findMarks(Y);\n    if(!foundX && !foundY &&foundDiff){\n      System.out.println(1);\n      System.out.println(diffMark);\n    }\n    else if(!foundX && !foundY && foundMiddleMark){\n      System.out.println(1);\n      System.out.println(middleLocation);\n    }\n    else{\n      System.out.println(additionalMarks);\n      if(!foundX)\n        System.out.print(X+\" \");\n      if(!foundY)\n        System.out.print(Y); \n      if(foundX||foundY)\n        System.out.println();    \n    }\n  }\n  private static boolean findMarks(int mark){\n    int neededMark = -1;\n    boolean foundMark = false;\n    for(int i=0;i<N&&!foundMark;i++){\n      neededMark = numStoreArr[i]-mark;\n      if(neededMark<0){\n        neededMark = numStoreArr[i]+mark;\n      }\n      foundMark = numStore.get(neededMark)!=null;\n      if(!foundDiff&&!foundMark&&!foundMiddleMark){\n        neededMark = numStoreArr[i]+diff;\n        foundDiff = numStore.get(neededMark)!=null;\n        if(foundDiff){\n          if(numStoreArr[i]+Y<=L){\n            diffMark = numStoreArr[i]+Y;\n          }\n          else if(numStoreArr[i]-X>=0){\n            diffMark = numStoreArr[i]-X;\n          }\n          else{\n            foundDiff = false;\n          }\n        }\n        if(!foundDiff){\n          neededMark = numStoreArr[i]+totalDist;\n          foundMiddleMark = numStore.get(neededMark)!=null;\n          middleLocation = numStoreArr[i]+X;\n        }\n      }\n    }\n    if(!foundMark){\n      additionalMarks++;\n      return false;\n    }\n    return true;\n  }\n  \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\ninline int read() {\n  int x(0), w(1);\n  char c = getchar();\n  while (c ^ '-' && (c < '0' || c > '9')) c = getchar();\n  if (c == '-') w = -1, c = getchar();\n  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();\n  return x * w;\n}\nint n, l, r, mid, x, y, a[N], ans[5];\ninline int check(int len) {\n  int l, r, mid;\n  for (int i = 2; i <= n; ++i) {\n    l = 1, r = i - 1;\n    while (l <= r) {\n      mid = (l + r) >> 1;\n      if (a[i] - a[mid] > len) {\n        l = mid + 1;\n      } else if (a[i] - a[mid] < len) {\n        r = mid - 1;\n      } else if (a[i] - a[mid] == len) {\n        return a[mid];\n      }\n    }\n  }\n  return -1;\n}\nint main() {\n  n = read(), l = read(), x = read(), y = read();\n  for (int i = 1; i <= n; ++i) {\n    a[i] = read();\n  }\n  ans[0] = check(x);\n  ans[1] = check(y);\n  ans[2] = check(x + y);\n  ans[3] = check(y - x);\n  if (ans[0] != -1 && ans[1] != -1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (ans[0] != -1 && ans[1] == -1) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  if (ans[0] == -1 && ans[1] != -1) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  if (ans[2] != -1) {\n    printf(\"1\\n%d\\n\", ans[2] + x);\n    return 0;\n  }\n  for (int i = 2; i <= n; ++i) {\n    l = 1, r = i - 1;\n    while (l <= r) {\n      mid = (l + r) >> 1;\n      if (a[i] - a[mid] > y - x) {\n        l = mid + 1;\n      } else if (a[i] - a[mid] < y - x) {\n        r = mid - 1;\n      } else if (a[i] - a[mid] == y - x) {\n        if (a[mid] - x > 0) {\n          printf(\"1\\n%d\\n\", a[mid] - x);\n          return 0;\n        }\n        if (a[mid] + y < a[n]) {\n          printf(\"1\\n%d\\n\", a[mid] + y);\n          return 0;\n        }\n        break;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT gcd(T a, T b) {\n  while (b > 0) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\ntemplate <class _T>\ninline _T sqr(const _T& first) {\n  return first * first;\n}\ntemplate <class _T>\ninline string tostr(const _T& a) {\n  ostringstream os(\"\");\n  os << a;\n  return os.str();\n}\nconst long double PI = 3.1415926535897932384626433832795L;\nconst double EPS = 1e-9;\nchar TEMPORARY_CHAR;\nconst int INF = 1e9;\ninline void input(int& a) {\n  a = 0;\n  while (((TEMPORARY_CHAR = getchar()) > '9' || TEMPORARY_CHAR < '0') &&\n         (TEMPORARY_CHAR != '-')) {\n  }\n  char neg = 0;\n  if (TEMPORARY_CHAR == '-') {\n    neg = 1;\n    TEMPORARY_CHAR = getchar();\n  }\n  while (TEMPORARY_CHAR <= '9' && TEMPORARY_CHAR >= '0') {\n    a = 10 * a + TEMPORARY_CHAR - '0';\n    TEMPORARY_CHAR = getchar();\n  }\n  if (neg) a = -a;\n}\ninline void out(long long a) {\n  if (!a) putchar('0');\n  if (a < 0) {\n    putchar('-');\n    a = -a;\n  }\n  char s[20];\n  int i;\n  for (i = 0; a; ++i) {\n    s[i] = '0' + a % 10;\n    a /= 10;\n  }\n  for (int j = (i)-1; j >= 0; j--) putchar(s[j]);\n}\ninline int nxt() {\n  int(ret);\n  input((ret));\n  ;\n  return ret;\n}\nint main() {\n  srand(234134211);\n  int(n);\n  input((n));\n  ;\n  int(l);\n  input((l));\n  ;\n  int(first);\n  input((first));\n  ;\n  int(second);\n  input((second));\n  ;\n  long long a[n];\n  for (int i = 0; i < n; ++i) {\n    a[i] = nxt();\n  }\n  int canX = -1;\n  int canY = -1;\n  int canXY = -1;\n  int canA = -1;\n  int canB = -1;\n  for (int i = 0; i < n; ++i) {\n    long long p = a[i] + first;\n    if (binary_search(a, a + n, p)) {\n      canX = i;\n    }\n    p = a[i] + second;\n    if (binary_search(a, a + n, p)) {\n      canY = i;\n    }\n  }\n  if (canX != -1 && canY != -1) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (canX != -1) {\n    cout << \"1\\n\";\n    cout << second << endl;\n    return 0;\n  }\n  if (canY != -1) {\n    cout << \"1\\n\";\n    cout << first << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (a[i] + first <= l && binary_search(a, a + n, a[i] + first + second)) {\n      cout << \"1\\n\";\n      cout << a[i] + first << \"\\n\";\n      return 0;\n    }\n    if (a[i] + first <= l && binary_search(a, a + n, a[i] + first - second)) {\n      cout << \"1\\n\";\n      cout << a[i] + first << \"\\n\";\n      return 0;\n    }\n    if (a[i] - first >= 0 && binary_search(a, a + n, a[i] - first + second)) {\n      cout << \"1\\n\";\n      cout << a[i] - first << \"\\n\";\n      return 0;\n    }\n    if (a[i] - first >= 0 && binary_search(a, a + n, a[i] - first - second)) {\n      cout << \"1\\n\";\n      cout << a[i] - first << \"\\n\";\n      return 0;\n    }\n    if (a[i] + second <= l && binary_search(a, a + n, a[i] + first + second)) {\n      cout << \"1\\n\";\n      cout << a[i] + second << \"\\n\";\n      return 0;\n    }\n    if (a[i] + second <= l && binary_search(a, a + n, a[i] - first + second)) {\n      cout << \"1\\n\";\n      cout << a[i] + second << \"\\n\";\n      return 0;\n    }\n    if (a[i] - second >= 0 && binary_search(a, a + n, a[i] - second + first)) {\n      cout << \"1\\n\";\n      cout << a[i] - second << \"\\n\";\n      return 0;\n    }\n    if (a[i] - second >= 0 && binary_search(a, a + n, a[i] - second - first)) {\n      cout << \"1\\n\";\n      cout << a[i] - second << \"\\n\";\n      return 0;\n    }\n  }\n  cout << \"2\\n\";\n  cout << first << \" \" << second << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n    public static void main(String[] args) throws IOException\n    {\n        Scanner scan = new Scanner(System.in);\n\n        int n = scan.nextInt();\n        int len = scan.nextInt();\n        int x = scan.nextInt();\n        int y = scan.nextInt();\n\n        int[] numbers = new int[n];\n        for(int i = 0;i < n;i++)\n            numbers[i] = scan.nextInt();\n\n        int xVal = can(n, numbers, x);\n        int yVal = can(n, numbers, y);\n        int dVal = can(n, numbers, y-x);\n        int mDVal = can2(n, numbers, y-x);\n        int sVal = can(n, numbers, x+y);\n\n        if(xVal >= 0 && yVal >= 0)\n        {\n            System.out.println(0);\n        }\n        else if(xVal >= 0)\n        {\n            System.out.println(1);\n            System.out.println(y);\n        }\n        else if(yVal >= 0)\n        {\n            System.out.println(1);\n            System.out.println(x);\n        }\n        else if(dVal >= 0 && dVal+y <= len)\n        {\n            System.out.println(1);\n            System.out.println(dVal+y);\n        }\n        else if(mDVal >= 0 && mDVal-y >= 0)\n        {\n            System.out.println(1);\n            System.out.println(mDVal-y);\n        }\n        else if(sVal >= 0)\n        {\n            System.out.println(1);\n            System.out.println(sVal+x);\n        }\n        else\n        {\n            System.out.println(2);\n            System.out.println(x + \" \" + y);\n        }\n    }\n\n    private static int can(int n, int[] numbers, int val)\n    {\n        int x = 0, y = 0;\n\n        while(x < n && y < n)\n        {\n            if(numbers[y]-numbers[x] > val)\n                x++;\n            else if(numbers[y]-numbers[x] < val)\n                y++;\n            else\n                return numbers[x];\n        }\n\n        return -1;\n    }\n\n    private static int can2(int n, int[] numbers, int val)\n    {\n        int x = 0, y = 0, res = -1;\n\n        while(x < n && y < n)\n        {\n            if(numbers[y]-numbers[x] > val)\n                x++;\n            else if(numbers[y]-numbers[x] < val)\n                y++;\n            else\n            {\n                res = numbers[y];\n                y++;\n            }\n        }\n\n        return res;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n    \n    \n    \n    public static void main(String[] args) {\n        try {\n            // new InputStreamReader(System.in)\n            // new FileReader(\"roman.in\")\n//          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n//          Scanner sc = new Scanner(\"roman.in\");\n//          Scanner sc = new Scanner(new FileReader(\"roman.in\"));\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> map = new HashMap<>();\n            int[] arr = null;\n            int n, l, x, y;\n            n = sc.nextInt();\n            l = sc.nextInt();\n            x = sc.nextInt();\n            y = sc.nextInt();\n            arr = new int[n];\n            for(int i = 0; i < n; i++){\n                arr[i] = sc.nextInt();\n                map.put(arr[i], i);\n            }\n            boolean xx = false, yy = false;\n            for(int i = 0; i < n; i++){\n                if(map.containsKey(arr[i] - x)){\n                    xx = true;\n                }\n                if(map.containsKey(arr[i] - y)){\n                    yy = true;\n                }\n            }\n            \n            if(xx && yy){\n                System.out.println(0);\n                return;\n            }\n            if(xx || yy){\n                System.out.println(1);\n                if(xx)\n                    System.out.println(y);\n                else System.out.println(x);\n                return;\n            }\n            \n            for(int i = 0; i < n; i++){\n                    if(arr[i] - x - y >= 0 && map.containsKey(arr[i] - x - y)){\n                        System.out.println(1);\n                        System.out.println(arr[i] - x);\n                        return;\n                    }\n                    if(arr[i] - x >= 0 && arr[i] - x + y <= l && map.containsKey(arr[i] - x + y)){\n                        System.out.println(1);\n                        System.out.println(arr[i] - x);\n                        return;\n                    }\n                    \n                    if(arr[i] + x <= l && arr[i] + x - y >= 0 && map.containsKey(arr[i] + x - y)){\n                        System.out.println(1);\n                        System.out.println(arr[i] + x);\n                        return;\n                    }\n                    if(arr[i] + x + y <= l && map.containsKey(arr[i] + x + y)){\n                        System.out.println(1);\n                        System.out.println(arr[i] + x);\n                        return;\n                    }\n            }\n            System.out.println(2);\n            System.out.println(x + \" \" + y);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst string YESNO[2] = {\"NO\", \"YES\"};\nconst string YesNo[2] = {\"No\", \"Yes\"};\nconst string yesno[2] = {\"no\", \"yes\"};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) {\n  scan(p.first), scan(p.second);\n}\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a) {\n  for (auto &i : a) scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) {\n  cin >> a;\n}\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &...tail) {\n  scan(head);\n  IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, const S &b) {\n  return (a < b ? a = b, 1 : 0);\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, const S &b) {\n  return (a > b ? a = b, 1 : 0);\n}\nvector<int> iota(int n) {\n  vector<int> a(n);\n  iota(begin(a), end(a), 0);\n  return a;\n}\ntemplate <typename T>\nvector<int> iota(vector<T> &a, bool greater = false) {\n  vector<int> res(a.size());\n  iota(begin(res), end(res), 0);\n  sort(begin(res), end(res), [&](int i, int j) {\n    if (greater) return a[i] > a[j];\n    return a[i] < a[j];\n  });\n  return res;\n}\ntemplate <class T>\nT POW(T x, int n) {\n  T res = 1;\n  for (; n; n >>= 1, x *= x)\n    if (n & 1) res *= x;\n  return res;\n}\nvector<pair<long long, long long>> factor(long long x) {\n  vector<pair<long long, long long>> ans;\n  for (long long i = 2; i * i <= x; i++)\n    if (x % i == 0) {\n      ans.push_back({i, 1});\n      while ((x /= i) % i == 0) ans.back().second++;\n    }\n  if (x != 1) ans.push_back({x, 1});\n  return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x) {\n  vector<T> ans;\n  for (T i = 1; i * i <= x; i++)\n    if (x % i == 0) {\n      ans.push_back(i);\n      if (i * i != x) ans.push_back(x / i);\n    }\n  return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x) {\n  vector<T> y = x;\n  sort(begin(y), end(y));\n  for (int i = 0; i < x.size(); ++i) {\n    x[i] = distance((y).begin(), lower_bound(begin(y), end(y), (x[i])));\n  }\n}\nint popcount(long long x) { return __builtin_popcountll(x); }\nint in() {\n  int x;\n  cin >> x;\n  return x;\n}\nlong long lin() {\n  unsigned long long x;\n  cin >> x;\n  return x;\n}\ntemplate <typename T>\nstruct edge {\n  int from, to;\n  T cost;\n  int id;\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n  edge(int from, int to, T cost, int id)\n      : from(from), to(to), cost(cost), id(id) {}\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n  operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n  Tree res(n);\n  if (m == -1) m = n - 1;\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    a -= margin, b -= margin;\n    res[a].emplace_back(b);\n    if (!directed) res[b].emplace_back(a);\n  }\n  return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n  Wgraph<T> res(n);\n  if (m == -1) m = n - 1;\n  while (m--) {\n    int a, b;\n    T c;\n    cin >> a >> b >> c;\n    a -= margin, b -= margin;\n    res[a].emplace_back(b, c);\n    if (!directed) res[b].emplace_back(a, c);\n  }\n  return move(res);\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for (auto it = begin(v); it != end(v); ++it) {\n    if (it == begin(v))\n      os << *it;\n    else\n      os << \" \" << *it;\n  }\n  return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) {\n  return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\";\n}\ntemplate <class A>\nstring to_string(A v) {\n  if (v.empty()) return \"{}\";\n  string ret = \"{\";\n  for (auto &x : v) ret += to_string(x) + \",\";\n  ret.back() = '}';\n  return ret;\n}\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail) {\n  cerr << to_string(head) << \" \";\n  dump(tail...);\n}\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\nstruct Setup_io {\n  Setup_io() {\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n  }\n} setup_io;\nint main() {\n  int n, l, x, y;\n  IN(n, l, x, y);\n  set<int> s;\n  for (long long i = 0; i < n; ++i) s.emplace(in());\n  int X = 0, Y = 0;\n  for (auto &e : s) {\n    if (s.count(e + x)) X = 1;\n    if (s.count(e + y)) Y = 1;\n  }\n  if (X and Y) cout << \"0\" << '\\n', exit(0);\n  if (X) {\n    cout << 1 << '\\n' << y << '\\n';\n    exit(0);\n  }\n  if (Y) {\n    cout << 1 << '\\n' << x << '\\n';\n    exit(0);\n  }\n  for (auto &e : s) {\n    if (s.count(e + x + y)) {\n      cout << 1 << '\\n' << e + x << '\\n';\n      exit(0);\n    }\n  }\n  for (auto &e : s) {\n    if (s.count(e + y - x) and e + y < l) {\n      cout << 1 << '\\n' << e + y << '\\n';\n      exit(0);\n    }\n    if (s.count(e - y + x) and e - y > 0) {\n      cout << 1 << '\\n' << e - y << '\\n';\n      exit(0);\n    }\n  }\n  cout << 2 << '\\n' << x << \" \" << y << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Div2_274_D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedInputStream bis = new BufferedInputStream(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(bis));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken()); \n\t\tint l = Integer.parseInt(st.nextToken()); \n\t\tint x = Integer.parseInt(st.nextToken()); \n\t\tint y = Integer.parseInt(st.nextToken()); \n\t\tst = new StringTokenizer(br.readLine());\n\t\tint [] marks = new int [n];\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tmarks[i] = Integer.parseInt(st.nextToken());\n\t\tint p0 = 0, p1 = 0;\n\t\tboolean xExists = false, yExists = false;\n\t\tfor(int mark:marks) {\n\t\t\tif(Arrays.binarySearch(marks, mark+x) >= 0 || Arrays.binarySearch(marks, mark-x) >= 0) \n\t\t\t\txExists = true;\n\t\t\tif(Arrays.binarySearch(marks, mark+y) >= 0 || Arrays.binarySearch(marks, mark-y) >= 0) \n\t\t\t\tyExists = true;\n\t\t}\n\t\tTreeSet <Integer> p0s = new TreeSet<Integer>();\n\t\tTreeSet <Integer> p1s = new TreeSet<Integer>();\n\t\tif(!xExists) {\n\t\t\tfor(int i = 0;i < marks.length;i++) {\n\t\t\t\tfor(int j = 1;j >= -1;j-=2) {\n\t\t\t\t\tp0 = marks[i]+j*x;\n\t\t\t\t\tif(p0 >= 0 && p0 <= l)\n\t\t\t\t\t\tp0s.add(p0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!yExists) {\n\t\t\tfor(int i = 0;i < marks.length;i++) {\n\t\t\t\tfor(int j = 1;j >= -1;j-=2) {\n\t\t\t\t\tp1 = marks[i]+j*y;\n\t\t\t\t\tif(p1 >= 0 && p1 <= l)\n\t\t\t\t\t\tp1s.add(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(xExists && yExists)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tint intersec = -1;\n\t\t\tfor(int i:p0s)\n\t\t\t\tif(p1s.contains(i)) {\n\t\t\t\t\tintersec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(intersec != -1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(intersec);\n\t\t\t}else if(p0s.isEmpty()) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(p1s.first());\n\t\t\t}else if(p1s.isEmpty()) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(p0s.first());\n\t\t\t}else {\n\t\t\t\tSystem.out.println(2);\n\t\t\t\tSystem.out.println(p0s.first()+\" \"+p1s.first());\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n\npublic class test {\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt(), l = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n        int p = -1, q = -1;\n        p = binarySearch(arr, x);\n        q = binarySearch(arr, y);\n        if (p != -1 && q != -1) System.out.println(0);\n        else if (p != -1) {\n            System.out.println(1);\n            System.out.println(arr[0] + y);\n        } else if (q != -1) {\n            System.out.println(1);\n            System.out.println(arr[0] + x);\n        } else {\n           HashSet<Integer> hs=new HashSet<>();\n           for(int i=0;i<n;i++)hs.add(arr[i]);\n           for(int i=0;i<n;i++){\n               int a=0,b=0,c=0,d=0;\n               if(arr[i]-x>=0)a=arr[i]-x;\n               if(arr[i]+x<=l)b=arr[i]+x;\n               if(arr[i]-y>=0)c=arr[i]-y;\n               if(arr[i]+y<=l)d=arr[i]+y;\n\n               if(hs.contains(a-y) || hs.contains(a+y)){\n                   System.out.println(1+\"\\n\"+a);\n                   return;\n               }\n               else if(hs.contains(b-y) || hs.contains(b+y)){\n                   System.out.println(1+\"\\n\"+b);\n                   return;\n               }\n               else if(hs.contains(c-x) || hs.contains(c+x)){\n                   System.out.println(1+\"\\n\"+c);\n                   return;\n               }\n               else if(hs.contains(d-x) || hs.contains(d+x)){\n                   System.out.println(1+\"\\n\"+d);\n                   return;\n               }\n           }\n            System.out.println(2+\"\\n\"+(arr[0]+x)+\" \"+(arr[0]+y));\n        }\n    }\n    public static int  binarySearch(int[] arr,int x) {\n        for (int i = 0; i < arr.length; i++) {\n            int l = i + 1, r = arr.length - 1;\n            while (l <= r) {\n                int mid = l + (r - l) / 2;\n                int temp = arr[mid] - arr[i];\n                if (temp == x) return mid;\n                else if (temp > x) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T POW(T B, T P) {\n  if (P == 0) return 1;\n  if (P & 1)\n    return B * POW(B, P - 1);\n  else\n    return SQR(POW(B, P / 2));\n}\ntemplate <typename T>\ninline T BigMod(T b, T p, T m) {\n  if (p == 0) return 1;\n  if (p % 2 == 0) {\n    T s = BigMod(b, p / 2, m);\n    return ((s % m) * (s % m)) % m;\n  }\n  return ((b % m) * (BigMod(b, p - 1, m) % m)) % m;\n}\ntemplate <typename T>\ninline T ModInv(T b, T m) {\n  return BigMod(b, m - 2, m);\n}\ntemplate <typename T>\ninline T ABS(T a) {\n  if (a < 0)\n    return -a;\n  else\n    return a;\n}\ntemplate <typename T>\ninline T gcd(T a, T b) {\n  if (a < 0) return gcd(-a, b);\n  if (b < 0) return gcd(a, -b);\n  return (b == 0) ? a : gcd(b, a % b);\n}\ntemplate <typename T>\ninline T lcm(T a, T b) {\n  if (a < 0) return lcm(-a, b);\n  if (b < 0) return lcm(a, -b);\n  return a * (b / gcd(a, b));\n}\nlong long int n, l, x, y, arr[100005];\nint main() {\n  scanf(\"%I64d%I64d\", &n, &l);\n  scanf(\"%I64d%I64d\", &x, &y);\n  long long int p;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &arr[i]);\n    if (x != -1) {\n      p = (lower_bound(arr + 1, arr + 1 + i, arr[i] - x) - arr);\n      if (arr[p] == arr[i] - x) {\n        x = -1;\n      }\n    }\n    if (y != -1) {\n      p = (lower_bound(arr + 1, arr + 1 + i, arr[i] - y) - arr);\n      if (arr[p] == arr[i] - y) {\n        y = -1;\n      }\n    }\n  }\n  if (x == -1 && y == -1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (x == -1 || y == -1) {\n    if (x == -1)\n      cout << 1 << endl << y << endl;\n    else\n      cout << 1 << endl << x << endl;\n    return 0;\n  }\n  long long int xx, yy, ch = 0, ans;\n  for (int i = 1; i <= n; i++) {\n    xx = arr[i] + x;\n    if (ch == 0 && xx <= l) {\n      yy = xx + y;\n      p = (lower_bound(arr + 1, arr + 1 + n, yy) - arr);\n      if (arr[p] == yy) {\n        ch = 1;\n        ans = xx;\n      } else {\n        yy = xx - y;\n        p = (lower_bound(arr + 1, arr + 1 + n, yy) - arr);\n        if (arr[p] == yy) {\n          ch = 1;\n          ans = xx;\n        }\n      }\n    }\n    xx = arr[i] - x;\n    if (ch == 0 && xx >= 0) {\n      yy = xx + y;\n      p = (lower_bound(arr + 1, arr + 1 + n, yy) - arr);\n      if (arr[p] == yy) {\n        ch = 1;\n        ans = xx;\n      } else {\n        yy = xx - y;\n        if (yy >= 0) {\n          p = (lower_bound(arr + 1, arr + 1 + n, yy) - arr);\n          if (arr[p] == yy) {\n            ch = 1;\n            ans = xx;\n          }\n        }\n      }\n    }\n  }\n  if (ch == 1)\n    cout << 1 << endl << ans << endl;\n  else {\n    cout << 2 << endl << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,l,x,y=map(int,input().split(\" \"))\nli=list(map(int,input().split(\" \",n)[:n]))\nli.sort()\ndic={}\na1,a2=0,0\nans=2\nx1=x\ny1=y\nxi=-1\nyi=-1\nfor i in li:\n    dic[i]=1\nfor i in range(n):\n    if li[i]-x>=0:\n        if li[i]-x in dic:\n            a1=1\n            xi=i\n    if li[i]+x<=l:\n        if li[i]+x in dic:\n            a1=1\n            xi=i\n    if li[i]-y>=0:\n        if li[i]-y in dic:\n            a2=1\n            yi=i\n    if li[i]+y<=l:\n        if li[i]+y in dic:\n            a2=1\n            yi=i\nif a1==1 and a2==1:\n    print(0)\nelif a1==1:\n    if li[xi]-x>=0:\n        if li[xi]-x in dic:\n            if li[xi]-x+y<=l and li[xi]-x+y in dic:\n                a2=1\n            if li[xi]-x-y>=0 and li[xi]-x-y in dic:\n                a2=1\n    if li[xi]+x<=l:\n        if li[xi]+x in dic:\n            if li[xi]+x+y<=l and li[xi]+x+y in dic:\n                a2=1\n            if li[xi]+x-y>=0 and li[xi]+x-y in dic:\n                a2=1\n    if a2==1:\n        print(0)\n    else:\n        print(1)\n        print(y)\nelif a2==1:\n    if li[yi]-y>=0:\n        if li[yi]-y in dic:\n            if li[yi]-y+x<=l and li[yi]-y+x in dic:\n                a1=1\n            if li[yi]-y-x>=0 and li[yi]-y-x in dic:\n                a1=1\n    if li[yi]+y<=l:\n        if li[yi]+x in dic:\n            if li[yi]+y+x<=l and li[yi]+y+x in dic:\n                a1=1\n            if li[yi]+y-x>=0 and li[yi]+y-x in dic:\n                a1=1\n    if a1==1:\n        print(0)\n    else:\n        print(1)\n        print(x)\nelse:\n    for i in range(n):\n        if li[i]-x>=0:\n            a1=1\n            xi=i\n            if li[xi]-x+y<=l and li[xi]-x+y in dic:\n                a2=1\n            if li[xi]-x-y>=0 and li[xi]-x-y in dic:\n                a2=1\n            if a2==1:\n                print(1)\n                print(li[i]-x)\n                break\n            else:\n                a1=0\n        if li[i]+x<=l:\n            a1=1\n            xi=i\n            if li[xi]+x+y<=l and li[xi]+x+y in dic:\n                a2=1\n            if li[xi]+x-y>=0 and li[xi]+x-y in dic:\n                a2=1\n            if a2==1:\n                print(1)\n                print(li[i]+x)\n                break\n            else:\n                a1=0\n        if li[i]-y>=0:\n            a2=1\n            yi=i\n            if li[yi]-y+x<=l and li[yi]-y+x in dic:\n                a1=1\n            if li[yi]-y-x>=0 and li[yi]-y-x in dic:\n                a1=1\n            if a1==1:\n                print(1)\n                print(li[i]-y)\n                break\n            else:\n                a2=0\n        if li[i]+y<=l:\n            a2=1\n            yi=i\n            if li[yi]+y+x<=l and li[yi]+y+x in dic:\n                a1=1\n            if li[yi]+y-x>=0 and li[yi]+y-x in dic:\n                a1=1\n            if a1==1:\n                print(1)\n                print(li[i]+y)\n                break\n            else:\n                a2=0\nif a1==0 and a2==0:\n    print(2)\n    print(x,y)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> pnt;\nint main() {\n  ios_base::sync_with_stdio(0);\n  ;\n  int n, l, x, y, p;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> p;\n    pnt.push_back(p);\n  }\n  int ok1 = 0;\n  for (int i = 0; i < n && !ok1; i++) {\n    int lo = i + 1;\n    int hi = n - 1;\n    int mid;\n    while (lo <= hi) {\n      mid = (lo + hi) >> 1;\n      int sum = pnt[mid] - pnt[i];\n      if (sum == x) {\n        ok1 = 1;\n        break;\n      }\n      if (sum < x) {\n        lo = mid + 1;\n      } else {\n        hi = mid - 1;\n      }\n    }\n  }\n  int ok2 = 0;\n  for (int i = 0; i < n && !ok2; i++) {\n    int lo = i + 1;\n    int hi = n - 1;\n    int mid;\n    while (lo <= hi) {\n      mid = (lo + hi) >> 1;\n      int sum = pnt[mid] - pnt[i];\n      if (sum == y) {\n        ok2 = 1;\n        break;\n      }\n      if (sum < y) {\n        lo = mid + 1;\n      } else {\n        hi = mid - 1;\n      }\n    }\n  }\n  if (ok1 && ok2) {\n    cout << 0 << \"\\n\";\n  } else if (ok1) {\n    cout << 1 << \"\\n\";\n    cout << y << \"\\n\";\n  } else if (ok2) {\n    cout << 1 << \"\\n\";\n    cout << x << \"\\n\";\n  } else {\n    int ok = 0;\n    for (int i = 0; i < n && !ok; i++) {\n      int diff = (((pnt[i] - x) < 0) ? (-(pnt[i] - x)) : (pnt[i] - x));\n      int df = y;\n      int tmp1 = pnt[i] + x;\n      int tmp2 = tmp1 + df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp2 = tmp1 - df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp1 = pnt[i] - x;\n      tmp2 = tmp1 + df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp2 = tmp1 - df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n    }\n    swap(x, y);\n    for (int i = 0; i < n && !ok; i++) {\n      int diff = (((pnt[i] - x) < 0) ? (-(pnt[i] - x)) : (pnt[i] - x));\n      int df = y;\n      int tmp1 = pnt[i] + x;\n      int tmp2 = tmp1 + df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp2 = tmp1 - df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp1 = pnt[i] - x;\n      tmp2 = tmp1 + df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n      tmp2 = tmp1 - df;\n      if (tmp1 >= 0 && tmp1 <= l && tmp2 >= 0 && tmp2 <= l &&\n          binary_search((pnt).begin(), (pnt).end(), tmp2)) {\n        cout << 1 << \"\\n\";\n        cout << tmp1 << \"\\n\";\n        ok = 1;\n        return 0;\n      }\n    }\n    swap(x, y);\n    cout << 2 << \"\\n\";\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], n;\nbool b(int l, int r, int val) {\n  int left = l, right = r, mid;\n  while (left <= right) {\n    mid = (right + left) >> 1;\n    if (a[mid] == val) {\n      return 1;\n    } else if (a[mid] < val) {\n      left = mid + 1;\n    } else\n      right = mid - 1;\n  }\n  return 0;\n}\nint main() {\n  int i, j, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  bool flag1 = 0, flag2 = 0, flag3 = 0, flag4 = 0;\n  int t = y - x, ans = -1, t2 = y + x;\n  for (i = 1; i <= n; i++) {\n    if (!flag1 && a[i] >= x) {\n      flag1 = b(1, i - 1, a[i] - x);\n    }\n    if (!flag2 && a[i] >= y) {\n      flag2 = b(1, i - 1, a[i] - y);\n    }\n    if (a[i] >= t) {\n      flag3 = b(1, i - 1, a[i] - t);\n      if (flag3 && a[i] > y) {\n        ans = a[i] - y;\n      }\n      if (flag3 && a[i] + x < l) {\n        ans = a[i] + x;\n      }\n    }\n    if (a[i] >= t2) {\n      flag4 = b(1, i - 1, a[i] - t2);\n      if (flag4 && a[i] > y) {\n        ans = a[i] - y;\n      }\n    }\n  }\n  int ct = 0;\n  if (!flag1) ct++;\n  if (!flag2) ct++;\n  if (ans == -1) {\n    printf(\"%d\\n\", ct);\n    if (!flag1) printf(\"%d \", x);\n    if (!flag2) printf(\"%d \", y);\n  } else {\n    if (ct <= 1) {\n      printf(\"%d\\n\", ct);\n      if (!flag1) printf(\"%d \", x);\n      if (!flag2) printf(\"%d \", y);\n    } else {\n      printf(\"1\\n\");\n      printf(\"%d\", ans);\n    }\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author thnkndblv\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n\n        int[] arr = new int[ n ];\n        for (int i = 0; i < n; i++) arr[i] = in.nextInt();\n\n        boolean xOk = false;\n        for (int i = 0, j = 0; j < n; i++) {\n            while (j < n && arr[j] < arr[i] + x) j++;\n            if ( j < n && arr[i] + x == arr[j] ) {\n                xOk = true;\n                break;\n            }\n        }\n\n        boolean yOk = false;\n        for (int i = 0, j = 0; j < n; i++) {\n            while (j < n && arr[j] < arr[i] + y) j++;\n            if (j < n && arr[i] + y == arr[j]) {\n                yOk = true;\n                break;\n            }\n        }\n\n        if ( xOk ) {\n            if ( yOk ) {\n                out.println( 0 );\n            } else {\n                out.println( 1 );\n                out.println( y );\n            }\n        } else {\n            if ( yOk ) {\n                out.println(1);\n                out.println(x);\n            } else {\n                for (int i = 0, j = 0; j < n; i++) {\n                    while (j < n && arr[j] < arr[i] + x + y) j++;\n                    if (j < n && arr[i] + x + y == arr[j]) {\n                        out.println( 1 );\n                        out.println( arr[i] + x );\n                        return;\n                    }\n                }\n\n                for (int i = 0, j = 0; j < n; i++) {\n                    while (j < n && arr[j] < arr[i] + (y - x)) j++;\n                    if (j < n && arr[i] + (y - x) == arr[j]) {\n                        if (arr[i] + y <= l) {\n                            out.println(1);\n                            out.println(arr[i] + y);\n                            return;\n                        } else if (arr[j] - y >= 0) {\n                            out.println(1);\n                            out.println(arr[j] - y);\n                            return;\n                        }\n                    }\n                }\n\n                out.println( 2 );\n                out.println( x + \" \" + y );\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid debug(T a, T b) {\n  for (; a != b; a++) cerr << *a << ' ';\n  cerr << endl;\n}\ntemplate <class T>\nbool isprime(T x) {\n  int till = (T)sqrt(x + .0);\n  if (x <= 1) return 0;\n  if (x == 2) return 1;\n  if (x / 2 * 2 == x) return 0;\n  for (int i = 3; i <= till; i += 2)\n    if (x / i * i == x) return 0;\n  return 1;\n}\nint n, l, x, y;\nint a[100000];\nset<int> s;\nint main() {\n  cin >> n;\n  cin >> l;\n  cin >> x;\n  cin >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  bool okx = 0;\n  for (int i = 0; i < n; i++)\n    if (s.find(a[i] - x) != s.end() || s.find(a[i] + x) != s.end()) {\n      okx = 1;\n      break;\n    }\n  bool oky = 0;\n  for (int i = 0; i < n; i++)\n    if (s.find(a[i] - y) != s.end() || s.find(a[i] + y) != s.end()) {\n      oky = 1;\n      break;\n    }\n  if (okx && oky) {\n    cout << 0;\n  } else if (!okx && !oky) {\n    for (int i = 0; i < n; i++) {\n      if (a[i] - x >= 0 && (s.find(a[i] - x - y) != s.end() ||\n                            s.find(a[i] - x + y) != s.end())) {\n        cout << 1 << \"\\n\";\n        cout << a[i] - x;\n        return 0;\n      }\n      if (a[i] + x <= l && (s.find(a[i] + x - y) != s.end() ||\n                            s.find(a[i] + x + y) != s.end())) {\n        cout << 1 << \"\\n\";\n        cout << a[i] + x;\n        return 0;\n      }\n    }\n    cout << 2 << \"\\n\";\n    cout << x << \" \" << y;\n  } else {\n    int z = okx ? y : x;\n    cout << 1 << \"\\n\";\n    cout << z;\n  }\n  return EXIT_SUCCESS;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[200010][2], n, b[200010];\nbool find(int x, int k) {\n  int l = 1, r = n;\n  if (k) r *= 2;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (x == a[mid][k]) return 1;\n    if (x < a[mid][k])\n      r = mid - 1;\n    else\n      l = mid + 1;\n  }\n  return 0;\n}\nint main() {\n  int l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i][0]);\n    b[i * 2 - 1] = a[i][0] - y;\n    b[i * 2] = a[i][0] + y;\n  }\n  sort(b + 1, b + 2 * n + 1);\n  for (int i = 1; i <= 2 * n; i++) a[i][1] = b[i];\n  bool ok1 = 0, ok2 = 0;\n  for (int i = 1; i <= n; i++)\n    if (find(a[i][0] + x, 0)) {\n      ok1 = 1;\n      break;\n    }\n  for (int i = 1; i <= n; i++)\n    if (find(a[i][0] + y, 0)) {\n      ok2 = 1;\n      break;\n    }\n  if ((ok1) && (ok2)) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if ((ok1) && (!ok2)) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  if ((ok2) && (!ok1)) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  ok1 = 0;\n  int ans;\n  for (int i = 1; i <= n; i++)\n    if ((a[i][0] + x <= l) && (find(a[i][0] + x, 1))) {\n      ok1 = 1;\n      ans = a[i][0] + x;\n      break;\n    }\n  for (int i = 1; i <= n; i++)\n    if ((a[i][0] - x >= 0) && (find(a[i][0] - x, 1))) {\n      ok1 = 1;\n      ans = a[i][0] - x;\n      break;\n    }\n  if (ok1)\n    printf(\"1\\n%d\\n\", ans);\n  else\n    printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn Agrawal coderbond007\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int l = in.nextInt();\n            int x = in.nextInt();\n            int y = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            boolean flag1 = true, flag2 = true;\n            flag1 &= Arrays.binarySearch(a, x) >= 0;\n            flag2 &= Arrays.binarySearch(a, y) >= 0;\n            if (flag1 && flag2) {\n                out.println(0);\n                return;\n            }\n            Set<Integer> set = new HashSet<>(n);\n            for (int i = 0; i < n; ++i) set.add(a[i]);\n\n            boolean xCan = false, yCan = false;\n            for (int i : set) {\n                if (set.contains(i + x)) xCan = true;\n                if (set.contains(i + y)) yCan = true;\n            }\n\n            if (xCan && yCan) {\n                out.println(0);\n            } else if (xCan) {\n                out.println(1);\n                out.println(y);\n            } else if (yCan) {\n                out.println(1);\n                out.println(x);\n            } else {\n                set.clear();\n                for (int i = 0; i < n; ++i) if (a[i] - x >= 0) set.add(a[i] - x);\n                for (int i = 0; i < n; ++i) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n\n                set.clear();\n                for (int i = 0; i < n; ++i) if (a[i] + x < l) set.add(a[i] + x);\n                for (int i = 0; i < n; ++i) {\n                    if (set.contains(a[i] - y)) {\n                        out.println(1);\n                        out.println(a[i] - y);\n                        return;\n                    }\n\n                    if (set.contains(a[i] + y)) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n                }\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = read();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, INF = int(1e9) + 1, mod = 1e9 + 7;\nconst long long BIG = 1e16;\nint n, l, a[N], b[10], c[5], ans;\nset<int> s;\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> l >> c[0] >> c[1];\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  int x = c[0], y = c[1];\n  bool fx = 0, fy = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] - y >= 0 and s.count(a[i] - y)) {\n      fy = 1;\n    }\n    if (a[i] + y <= l and s.count(a[i] + y)) {\n      fy = 1;\n    }\n    if (a[i] + x <= l and s.count(a[i] + x)) {\n      fx = 1;\n    }\n    if (a[i] - x >= 0 and s.count(a[i] - x)) {\n      fx = 1;\n    }\n  }\n  if (fx and fy) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (fx and !fy) {\n    cout << \"1\\n\";\n    cout << y << '\\n';\n    return 0;\n  }\n  if (!fx and fy) {\n    cout << \"1\\n\";\n    cout << x << '\\n';\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (a[i] + x <= l and a[i] + x + y <= l and s.count(a[i] + x + y)) {\n      cout << \"1\\n\";\n      cout << a[i] + x << endl;\n      return 0;\n    }\n    if (a[i] + x <= l and a[i] + x - y >= 0 and s.count(a[i] + x - y)) {\n      cout << 1 << endl;\n      cout << a[i] + x << endl;\n      return 0;\n    }\n    if (a[i] - x >= 0 and a[i] - x + y <= l and s.count(a[i] - x + y)) {\n      cout << \"1\\n\";\n      cout << a[i] - x << endl;\n      return 0;\n    }\n    if (a[i] - x >= 0 and a[i] - x - y >= 0 and s.count(a[i] - x - y)) {\n      cout << 1 << endl;\n      cout << a[i] - x << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, l, x, y, a[maxn];\nbool Find(int L) {\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] + L > l) break;\n    int t = lower_bound(a + 1, a + n + 1, a[i] + L) - a;\n    if (a[t] == a[i] + L) return 1;\n  }\n  return 0;\n}\nbool Zero() {\n  if (Find(x) && Find(y)) {\n    puts(\"0\");\n    return 1;\n  }\n  return 0;\n}\nbool One() {\n  if (Find(x)) {\n    puts(\"1\");\n    printf(\"%d\", y);\n    return 1;\n  }\n  if (Find(y)) {\n    puts(\"1\");\n    printf(\"%d\", x);\n    return 1;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] - x >= 0) {\n      int t = lower_bound(a + 1, a + 1 + n, a[i] - x - y) - a;\n      if (a[t] == a[i] - x - y) {\n        puts(\"1\");\n        printf(\"%d\", a[i] - x);\n        return 1;\n      }\n      t = lower_bound(a + 1, a + 1 + n, a[i] - x + y) - a;\n      if (a[t] == a[i] - x + y) {\n        puts(\"1\");\n        printf(\"%d\", a[i] - x);\n        return 1;\n      }\n    }\n    if (a[i] + x <= l) {\n      int t = lower_bound(a + 1, a + 1 + n, a[i] + x - y) - a;\n      if (a[t] == a[i] + x - y) {\n        puts(\"1\");\n        printf(\"%d\", a[i] + x);\n        return 1;\n      }\n      t = lower_bound(a + 1, a + 1 + n, a[i] + x + y) - a;\n      if (a[t] == a[i] + x + y) {\n        puts(\"1\");\n        printf(\"%d\", a[i] + x);\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  if (Zero()) return 0;\n  if (One()) return 0;\n  puts(\"2\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nint a[100001];\nvector<int> rem;\nset<int> s;\nbool solve0();\nbool solve1();\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    fscanf(stdin, \"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  if (solve0()) {\n    return 0;\n  }\n  if (solve1()) {\n    return 0;\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n  return 0;\n}\nbool solve0() {\n  bool foundx = false;\n  bool foundy = false;\n  for (int i = 0; i < n; i++) {\n    int target = a[i] + x;\n    set<int>::iterator it = s.find(target);\n    if (it != s.end()) {\n      foundx = true;\n    }\n    target = a[i] + y;\n    it = s.find(target);\n    if (it != s.end()) {\n      foundy = true;\n    }\n  }\n  if (foundx && foundy) {\n    cout << 0 << endl;\n    return true;\n  }\n  if (foundx) {\n    rem.push_back(y);\n  } else if (foundy) {\n    rem.push_back(x);\n  } else {\n    rem.push_back(x);\n    rem.push_back(y);\n  }\n  return false;\n}\nbool solve1() {\n  if (rem.size() == 1) {\n    cout << 1 << endl;\n    cout << rem[0] << endl;\n    return true;\n  }\n  for (int i = 0; i < n; i++) {\n    int target = a[i] + x;\n    set<int>::iterator it = s.find(target);\n    if (it == s.end() && a[i] + x < l) {\n      set<int>::iterator ity1 = s.find(target - y);\n      set<int>::iterator ity2 = s.find(target + y);\n      if (ity1 != s.end() || ity2 != s.end()) {\n        cout << 1 << endl;\n        cout << a[i] + x << endl;\n        return true;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int target = a[i] - x;\n    set<int>::iterator it = s.find(target);\n    if (it == s.end() && a[i] - x > 0) {\n      set<int>::iterator ity1 = s.find(target - y);\n      set<int>::iterator ity2 = s.find(target + y);\n      if (ity1 != s.end() || ity2 != s.end()) {\n        cout << 1 << endl;\n        cout << a[i] - x << endl;\n        return true;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int target = a[i] + y;\n    set<int>::iterator it = s.find(target);\n    if (it == s.end() && a[i] + y < l) {\n      set<int>::iterator itx1 = s.find(target - x);\n      set<int>::iterator itx2 = s.find(target + x);\n      if (itx1 != s.end() || itx2 != s.end()) {\n        cout << 1 << endl;\n        cout << a[i] + y << endl;\n        return true;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int target = a[i] - y;\n    set<int>::iterator it = s.find(target);\n    if (it == s.end() && a[i] - y > 0) {\n      set<int>::iterator itx1 = s.find(target - x);\n      set<int>::iterator itx2 = s.find(target + x);\n      if (itx1 != s.end() || itx2 != s.end()) {\n        cout << 1 << endl;\n        cout << a[i] - y << endl;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, marks[100005];\nbool flag_x, flag_y, flag_z, flag_d;\nint main() {\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) != EOF) {\n    flag_x = flag_y = flag_z = flag_d = 0;\n    ;\n    int pos, pos2;\n    for (int i = 0; i < n; i++) scanf(\"%d\", &marks[i]);\n    for (int i = 0; i < n; i++) {\n      int a = lower_bound(marks, marks + n, x + marks[i]) - marks;\n      int b = lower_bound(marks, marks + n, y + marks[i]) - marks;\n      int c = lower_bound(marks, marks + n, y - x + marks[i]) - marks;\n      int d = lower_bound(marks, marks + n, x + y + marks[i]) - marks;\n      if (a != n && marks[a] == x + marks[i]) flag_x = 1;\n      if (b != n && marks[b] == y + marks[i]) flag_y = 1;\n      if (c != n && marks[c] == y - x + marks[i] &&\n          (marks[i] + y <= l || marks[i] - x >= 0)) {\n        flag_z = 1;\n        pos = marks[i];\n      }\n      if (d != n && marks[d] == x + y + marks[i]) {\n        flag_d = 1;\n        pos2 = marks[i];\n      }\n    }\n    if (flag_x && flag_y) {\n      printf(\"0\\n\");\n      continue;\n    }\n    if (flag_x) {\n      printf(\"1\\n%d\\n\", marks[0] + y);\n      continue;\n    }\n    if (flag_y) {\n      printf(\"1\\n%d\\n\", marks[0] + x);\n      continue;\n    }\n    if (flag_z) {\n      if (pos + y <= l) {\n        printf(\"1\\n%d\\n\", pos + y);\n        continue;\n      }\n      if (pos - x >= 0) {\n        printf(\"1\\n%d\\n\", pos - x);\n        continue;\n      }\n    }\n    if (flag_d) {\n      printf(\"1\\n%d\\n\", pos2 + x);\n      continue;\n    }\n    printf(\"2\\n%d %d\\n\", marks[0] + x, marks[0] + y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing ii = pair<int, int>;\nusing ll = long long;\nusing llu = unsigned long long;\nconst int INF = numeric_limits<int>::max();\nint main() {\n  int n, d1, d2, l;\n  while (cin >> n >> l >> d1 >> d2) {\n    vector<int> v(n);\n    vector<ii> p;\n    for (int i = 0; i < n; i++) cin >> v[i];\n    for (int i = 0; i < n; i++) {\n      p.emplace_back(v[i], 0);\n      if (v[i] - d1 >= 0) p.emplace_back(v[i] - d1, 1);\n      if (v[i] + d1 <= l) p.emplace_back(v[i] + d1, 1);\n      if (v[i] - d2 >= 0) p.emplace_back(v[i] - d2, 2);\n      if (v[i] + d2 <= l) p.emplace_back(v[i] + d2, 2);\n    }\n    p.emplace_back(l + 1, 0);\n    sort(p.begin(), p.end());\n    int o = -1;\n    bool has[3];\n    int a1 = -1, a2 = -1;\n    for (auto pp : p) {\n      int x = pp.first;\n      int j = pp.second;\n      if (x != o) {\n        if (o != -1) {\n          if (has[1]) {\n            if (has[0]) a1 = INF;\n            if (a1 == -1) a1 = o;\n          }\n          if (has[2]) {\n            if (has[0]) a2 = INF;\n            if (a2 == -1) a2 = o;\n          }\n          if (has[1] && has[2] && a1 != INF && a2 != INF) a1 = a2 = o;\n        }\n        o = x;\n        for (int i = 0; i < 3; i++) has[i] = false;\n      }\n      has[j] = true;\n    }\n    vi add;\n    if (a1 != INF) add.emplace_back(a1);\n    if (a2 != INF && a2 != a1) add.emplace_back(a2);\n    cout << add.size() << endl;\n    if (!add.empty()) {\n      for (int i = 0; i < add.size(); i++) {\n        if (i) cout << \" \";\n        cout << add[i];\n      }\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class b {\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt(), l = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tarr[i] = in.nextInt();\n\t\tHashSet<Integer> set = new HashSet<>();\n\t\tboolean xsat = false, ysat = false;\n\t\tset.add(arr[0]);\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tif(set.contains(arr[i]-x))\n\t\t\t\txsat = true;\n\t\t\tif(set.contains(arr[i]-y))\n\t\t\t\tysat = true;\n\t\t\tset.add(arr[i]);\n\t\t}\n\t\tif(xsat && ysat) {\n\t\t\tSystem.out.println(0);\n\t\t} else if(!xsat && !ysat) {\n\t\t\t// check if 1\n\t\t\tint oneLoc = -1;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint pt = arr[i] + x;\n\t\t\t\tif((set.contains(pt-y) || set.contains(pt+y)) && pt >= 0 && pt <= l) {\n\t\t\t\t\toneLoc = pt;\n\t\t\t\t}\n\t\t\t\tpt = arr[i] - x;\n\t\t\t\tif((set.contains(pt-y) || set.contains(pt+y)) && pt >= 0 && pt <= l) {\n\t\t\t\t\toneLoc = pt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oneLoc == -1) {\n\t\t\t\tSystem.out.println(2);\n\t\t\t\tSystem.out.println(x + \" \" + y);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.out.println(oneLoc);\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(xsat ? y : x);\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tstatic class FastScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\t\t\n\t    public FastScanner(InputStream i) {\n\t        br = new BufferedReader(new InputStreamReader(i));\n\t        st = new StringTokenizer(\"\");\n\t    }\n\t\t\t\t\n\t    public String next() throws IOException {\n\t        while(!st.hasMoreTokens())\n\t            st = new StringTokenizer(br.readLine());\n\t        return st.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    public long nextLong() throws IOException {\n\t        return Long.parseLong(next());\n\t    }\n\t    public double nextDouble() throws IOException {\n\t        return Double.parseDouble(next());\n\t    }\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, L, x, y, a[N];\ninline void read(int &x) {\n  char ch;\n  x = 0;\n  for (ch = getchar(); ch < '0' || ch > '9'; ch = getchar())\n    ;\n  for (; ch >= '0' && ch <= '9'; x = x * 10 + ch - 48, ch = getchar())\n    ;\n}\nint query(int key) {\n  int l = 0, r = 1;\n  while (l <= r && r < n) {\n    if (a[r] - a[l] == key)\n      return 1;\n    else if (a[r] - a[l] > key)\n      l++;\n    else\n      r++;\n  }\n  return 0;\n}\nvoid solve() {\n  int isX = query(x), isY = query(y);\n  if (isX && isY) {\n    printf(\"0\\n\");\n    return;\n  }\n  if (isX && !isY) {\n    printf(\"1\\n%d\\n\", y);\n    return;\n  }\n  if (!isX && isY) {\n    printf(\"1\\n%d\\n\", x);\n    return;\n  }\n  int l = 0, r = 1, key = y + x;\n  while (l <= r && r < n) {\n    if (a[r] - a[l] == key) {\n      printf(\"1\\n%d\\n\", a[l] + x);\n      return;\n    } else if (a[r] - a[l] > key)\n      l++;\n    else\n      r++;\n  }\n  l = 0, r = 1, key = y - x;\n  while (l <= r && r < n) {\n    if (a[r] - a[l] == key) {\n      if (a[l] - x > 0) {\n        printf(\"1\\n%d\\n\", a[l] - x);\n        return;\n      }\n      if (a[r] + x < L) {\n        printf(\"1\\n%d\\n\", a[r] + x);\n        return;\n      }\n      l++;\n    } else if (a[r] - a[l] > y - x)\n      l++;\n    else\n      r++;\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n}\nint main() {\n  read(n);\n  read(L);\n  read(x);\n  read(y);\n  for (int i = 0; i < n; i++) read(a[i]);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100 * 1000 + 1000;\nint a[maxn];\nset<int> st;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    st.insert(a[i]);\n  }\n  bool xh = false, yh = false;\n  for (int i = 0; i < n; i++) {\n    if (st.find(a[i] - x) != st.end()) xh = true;\n    if (st.find(a[i] - y) != st.end()) yh = true;\n  }\n  if (xh) {\n    if (yh) {\n      cout << 0 << endl;\n      return 0;\n    }\n    cout << 1 << endl << y << endl;\n    return 0;\n  }\n  if (yh) {\n    cout << 1 << endl << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int nw = a[i] - x;\n    if (nw < 0) continue;\n    if (st.find(nw + y) != st.end() || st.find(nw - y) != st.end()) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int nw = a[i] + x;\n    if (nw > l) continue;\n    if (st.find(nw + y) != st.end() || st.find(nw - y) != st.end()) {\n      cout << 1 << endl << nw << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "var nums = readline().split(' ');\nvar n = parseInt(nums[0]);\nvar l = parseInt(nums[1]);\nvar x = parseInt(nums[2]);\nvar y = parseInt(nums[3]);\nvar a = readline().split(' ');\nfor(var i=0;i<a.length;i++)\n{\n    a[i]=parseInt(a[i]);\n}\n\nvar fx = false;\nvar fy = false;\n\nfx= findVal(x);\nfy= findVal(y);\n\nif(fx==true&&fy==true)\n{\n    print(0);\n}\nelse if(fx==true)\n{\n    print(1);\n\tprint(y);\n}\nelse if(fy==true)\n{\n    print(1);\n\tprint(x);\n}\nelse\n{\n    var ans = -1;\n    for(var i=0;i<n;i++)\n\t{\n\t    if(a[i]-x>0)\n\t\t{\n\t\t    var t = a[i]-x;\n\t\t\tif(hasVal(t-y)||hasVal(t+y))\n\t\t\t{\n\t\t\t    ans = a[i]-x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(a[i]+x<l)\n\t\t{\n\t\t    var t = a[i]+x;\n\t\t\tif(hasVal(t-y)||hasVal(t+y))\n\t\t\t{\n\t\t\t    ans = a[i]+x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans!=-1)\n\t{\n\t    print(1);\n\t\tprint(ans);\n\t}\n\telse\n\t{\n\t    print(2);\n\t\tprint(x+' '+y);\n\t}\n}\n\n\nfunction findVal( val )\n{\n    var st = 0;\n\tfor(var i=1;i<n;i++)\n\t{\n\t\tif(a[i]-a[st]==val)\n\t\t{\n\t\t    return true;\n\t\t}\n\t\telse if(a[i]-a[st]<val)\n\t\t{\n\t\t    continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t    while(a[i]-a[st]>val)\n\t\t\t{\n\t\t\t    st++;\n\t\t\t}\n\t\t\tif(a[i]-a[st]==val)\n\t\t\t{\n\t\t\t    return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction hasVal(val)\n{\n    var st = 0;\n\tvar ed = n-1;\n\tif(val==a[st]||val==a[ed])\n\t{\n\t    return true;\n\t}\n\tif(val<0||val>l)\n\t{\n\t    return false;\n\t}\n\twhile(ed-st>1)\n\t{\n\t    var mid = ((st+ed)>>1);\n\t\tif(a[mid]==val)\n\t\t{\n\t\t    return true;\n\t\t}\n\t\tif(a[mid]>val)\n\t\t{\n\t\t    ed=mid;\n\t    }\n\t\telse\n\t\t{\n\t\t    st=mid;\n\t\t}\n\t}\n\treturn false;\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\n\npublic class Main{\n    static FastReader in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));\n    static PrintWriter out = new PrintWriter(System.out);\n    static final int maxn = (int)2e5 + 11;\n    static int inf = (1<<30) - 1;\n    static int n,l,x,y,k,cnt;\n    static int a[] = new int[maxn];\n    static boolean okg,okb;\n    static HashMap<Integer, Boolean> map = new HashMap<>();\n    static HashMap<Integer, Boolean> top = new HashMap<>();\n    \n    public static void main(String[] args) throws Exception {\n        \n        n = in.nextInt();\n        l = in.nextInt();\n        x = in.nextInt();\n        y = in.nextInt();\n        \n        for (int i=1; i<=n; i++) {\n            a[i] = in.nextInt();\n            map.put(a[i], true);\n            top.put(a[i]+x, true);\n            top.put(a[i]-x, true);\n            if (a[i]==x) okg = true;\n            if (a[i]==y) okb = true;\n        }\n        \n\n        for (int i=1; i<=n; i++) {\n            if (map.get(a[i]+x)!=null || map.get(a[i]-x)!=null) {\n                okg = true;\n            }\n            if (map.get(a[i]+y)!=null || map.get(a[i]-y)!=null) {\n                okb = true;\n            }\n        }\n\n        if (okg && okb) {\n            out.println(0);\n        } else if (!okg && okb) {\n            out.println(1);\n            out.println(x);\n        } else if (okg && !okb) {\n            out.println(1);\n            out.println(y);\n        } else {\n            for (int i=1; i<=n; i++) {\n                if (top.get(a[i]+y)!=null && a[i]+y<=l && a[i]+y>=0) {\n                    out.println(1);\n                    out.println(a[i]+y);\n                    okb = okg = true;\n                    break;\n                    \n                }\n                if (top.get(a[i]-y)!=null && a[i]-y<=l && a[i]-y>=0) {\n                    out.println(1);\n                    out.println(a[i]-y);\n                    okb = okg = true;\n                    break;\n                }\n            }\n            \n            if (!okb && !okg) {\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n        \n        \n        out.close();\n    }\n\n}\n\nclass Pair implements Comparable<Pair> {\n    int l,r;\n    public Pair (int l, int r) {\n        this.l = l;\n        this.r = r;\n    }\n    \n    @Override\n    public int compareTo(Pair p) {\n        if (this.l<p.l) {\n            return -1;\n        } else if (this.l == p.l) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    \n    \n}\n\nclass FastReader {\n\n    BufferedReader bf;\n    StringTokenizer tk = null;\n    String DELIM = \" \";\n\n    public FastReader(BufferedReader bf) {\n        this.bf = bf;\n    }\n\n    public String nextToken() throws Exception {\n\n        if(tk==null || !tk.hasMoreTokens()) {\n            tk = new StringTokenizer(bf.readLine(),DELIM);\n        }\n        return tk.nextToken();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, l, x, y, a[maxn], res;\nbool xok, yok;\nmap<int, int> m;\nvoid check(int d, int t) {\n  if (d < 0 || d > l) return;\n  if (m[d + t] || m[d - t]) {\n    cout << 1 << endl << d;\n    exit(0);\n  }\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    m[a[i]] = 1;\n  }\n  for (int i = 0; i <= n; i++) {\n    xok |= m[a[i] - x];\n    xok |= m[a[i] + x];\n    yok |= m[a[i] + y];\n    yok |= m[a[i] - y];\n  }\n  if (xok && yok) {\n    cout << 0;\n    return 0;\n  } else if (xok) {\n    cout << 1 << endl;\n    cout << y;\n    return 0;\n  } else if (yok) {\n    cout << 1 << endl;\n    cout << x;\n    return 0;\n  } else {\n    for (int i = 0; i < n; i++) {\n      check(a[i] - x, y);\n      check(a[i] + x, y);\n      check(a[i] - y, x);\n      check(a[i] + y, x);\n    }\n    cout << 2 << \" \" << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        int werk = -1;\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        int a[] = new int[n];\n        for(int i = 0;i<n;i++){\n            a[i]=sc.nextInt();\n        }\n        ArrayList<Integer> wut = new ArrayList<Integer>();\n        for(int i = 0;i<n;i++){\n            wut.add(a[i]);\n        }\n        for(int i = 0;i<n;i++){\n            if(a[i]>l-x){\n                break;\n            }\n            else{\n                wut.add(a[i]+x);\n            }\n        }\n        int b[] = conv(wut);\n        Arrays.sort(b);\n        boolean xx = false;\n        for(int i = 0;i<b.length-1;i++){\n            if(b[i]==b[i+1]){\n                xx=true;\n                break;\n            }\n        }\n        ArrayList<Integer> wat = new ArrayList<Integer>();\n        for(int i = 0;i<n;i++){\n            wat.add(a[i]);\n        }\n        for(int i = 0;i<n;i++){\n            if(a[i]>l-y){\n                break;\n            }\n            else{\n                wat.add(a[i]+y);\n            }\n        }\n        int c[] = conv(wat);\n        Arrays.sort(c);\n        boolean yy = false;\n        for(int i = 0;i<c.length-1;i++){\n            if(c[i]==c[i+1]){\n                yy=true;\n                break;\n            }\n        }\n        if(xx&&yy){\n            System.out.println(0);\n        }\n        else{\n            if(xx&&!yy){\n                System.out.println(1);\n                System.out.println(y);\n            }\n            else{\n                if(!xx&&yy){\n                    System.out.println(1);\n                    System.out.println(x);\n                }\n                else{\n                    boolean xplusy = false;\n                    if(x+y>l){\n                    }\n                    else{\n                            ArrayList<Integer> qwat = new ArrayList<Integer>();\n        for(int i = 0;i<n;i++){\n            qwat.add(a[i]);\n        }\n        for(int i = 0;i<n;i++){\n            if(a[i]>l-x-y){\n                break;\n            }\n            else{\n                qwat.add(a[i]+x+y);\n            }\n        }\n        int qc[] = conv(qwat);\n        Arrays.sort(qc);\n        for(int i = 0;i<qc.length-1;i++){\n            if(qc[i]==qc[i+1]){\n                xplusy=true;\n                werk=qc[i];\n                break;\n            }\n        }\n                    }\n                    if(!xplusy){\n                        boolean xminusy = false;\n                            ArrayList<Integer> qqwat = new ArrayList<Integer>();\n        for(int i = 0;i<n;i++){\n            qqwat.add(a[i]);\n        }\n        for(int i = 0;i<n;i++){\n            if(a[i]>l-(y-x)){\n                break;\n            }\n            else{\n                qqwat.add(a[i]+(y-x));\n            }\n        }\n        int qqc[] = conv(qqwat);\n        Arrays.sort(qqc);\n        for(int i = 0;i<qqc.length-1;i++){\n            if(qqc[i]==qqc[i+1]){\nif(qqc[i]-y>=0){\nwerk=qqc[i]-y;\nxminusy=true;\nbreak;\n}\nif(qqc[i]+x<=l){\nwerk=qqc[i]+x;\nxminusy=true;\nbreak;\n}\n            }\n        }\n        if(xminusy){\n            System.out.println(1);\n            System.out.println(werk);\n        }\n        else{\n            System.out.println(2);\n            System.out.println(x+ \" \" + y);\n        }\n                    }\n                    else{\n                        System.out.println(1);\n                        System.out.println(werk-y);\n                    }\n                }\n            }\n        }\n    }\n    public static int[] conv(ArrayList<Integer> x){\n        int a[] = new int[x.size()];\n        int y = 0;\n        for(Integer i : x){\n            a[y]=i;\n            y++;\n        }\n        return a;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<int> a(n);\n  map<int, int> m;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    m[a[i]] = 1;\n  }\n  int ans = 0, i;\n  vector<int>::iterator it;\n  bool q1 = false, q2 = false, q3 = false;\n  int v;\n  for (i = 0; i < n; i++) {\n    if (!q1 && m[a[i] + x]) q1 = true;\n    if (!q2 && m[a[i] + y]) q2 = true;\n    if (!q3 && (m[a[i] + x + y] || m[a[i] + x - y])) {\n      if (m[a[i] + x + y]) {\n        v = a[i] + x;\n        q3 = true;\n      } else if (a[i] + x < l) {\n        v = a[i] + x;\n        q3 = true;\n      } else if (a[i] - y > 0) {\n        q3 = true;\n        v = a[i] - y;\n      }\n    }\n  }\n  if (!q1 && !q2) {\n    if (q3)\n      cout << \"1\\n\" << v;\n    else\n      cout << \"2\\n\" << x << \" \" << y;\n  } else if (!q1)\n    cout << \"1\\n\" << x;\n  else if (!q2)\n    cout << \"1\\n\" << y;\n  else\n    cout << \"0\";\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nclass Ruler {\n public:\n  template <typename Iterator>\n  Ruler(Iterator begin, Iterator end) : marks_(begin, end) {}\n  void CanMeasure(int distance, bool &can_measure, int &left_mark,\n                  int &right_mark) {\n    for (int left = 0; left < marks_.size(); ++left) {\n      int to_search = distance + marks_[left];\n      int found_place = BinarySearch(to_search, left, marks_.size());\n      if (found_place != -1) {\n        left_mark = left;\n        right_mark = found_place;\n        can_measure = true;\n        return;\n      }\n    }\n    can_measure = false;\n  }\n  void CanMeasureRight(int distance, bool &can_measure, int &left_mark,\n                       int &right_mark) {\n    for (int left = marks_.size() - 1; left >= 0; --left) {\n      int to_search = distance + marks_[left];\n      int found_place = BinarySearch(to_search, left, marks_.size());\n      if (found_place != -1) {\n        left_mark = left;\n        right_mark = found_place;\n        can_measure = true;\n        return;\n      }\n    }\n    can_measure = false;\n  }\n  int BinarySearch(int value, int left_bound, int right_bound) {\n    while (left_bound < right_bound - 1) {\n      int middle = (left_bound + right_bound) / 2;\n      if (marks_[middle] == value) {\n        return middle;\n      } else if (marks_[middle] > value) {\n        right_bound = middle;\n      } else {\n        left_bound = middle;\n      }\n    }\n    return -1;\n  }\n\n private:\n  vector<int> marks_;\n};\nvector<int> GetExtraMarksToMeasure(const vector<int> &marks, int girl_distance,\n                                   int boy_distance) {\n  Ruler ruler(marks.begin(), marks.end());\n  int left_mark, right_mark;\n  bool can_measure_boy, can_measure_girl, can_measure_sum, can_measure_diff;\n  ruler.CanMeasure(girl_distance, can_measure_girl, left_mark, right_mark);\n  ruler.CanMeasure(boy_distance, can_measure_boy, left_mark, right_mark);\n  if (can_measure_boy && can_measure_girl) {\n    return {};\n  }\n  if (can_measure_girl) {\n    return {boy_distance};\n  }\n  if (can_measure_boy) {\n    return {girl_distance};\n  }\n  ruler.CanMeasure(girl_distance + boy_distance, can_measure_sum, left_mark,\n                   right_mark);\n  if (can_measure_sum) {\n    return {marks[left_mark] + girl_distance};\n  }\n  int length = *marks.rbegin();\n  ruler.CanMeasure(boy_distance - girl_distance, can_measure_diff, left_mark,\n                   right_mark);\n  if (can_measure_diff) {\n    if (length - marks[right_mark] >= girl_distance) {\n      return {marks[right_mark] + girl_distance};\n    }\n  }\n  ruler.CanMeasureRight(boy_distance - girl_distance, can_measure_diff,\n                        left_mark, right_mark);\n  if (can_measure_diff) {\n    if (marks[left_mark] >= girl_distance) {\n      return {marks[left_mark] - girl_distance};\n    }\n  }\n  return {girl_distance, boy_distance};\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  size_t marks_count, length, girl_distance, boy_distance;\n  cin >> marks_count >> length >> girl_distance >> boy_distance;\n  vector<int> marks(marks_count);\n  for (size_t i = 0; i < marks_count; ++i) {\n    cin >> marks[i];\n  }\n  vector<int> extra_marks =\n      GetExtraMarksToMeasure(marks, girl_distance, boy_distance);\n  cout << extra_marks.size() << endl;\n  for (int mark : extra_marks) {\n    cout << mark << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> S;\nint a[200000], n, l, x, y, now;\nbool fx, fy;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    S.insert(a[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    now = a[i] - x;\n    if (S.find(now) != S.end()) {\n      fx = true;\n      break;\n    }\n    now = a[i] + x;\n    if (S.find(now) != S.end()) {\n      fx = true;\n      break;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    now = a[i] - y;\n    if (S.find(now) != S.end()) {\n      fy = true;\n      break;\n    }\n    now = a[i] + y;\n    if (S.find(now) != S.end()) {\n      fy = true;\n      break;\n    }\n  }\n  if (fx && fy) {\n    puts(\"0\");\n    return 0;\n  }\n  if (fx && !fy) {\n    puts(\"1\");\n    printf(\"%d\\n\", y);\n    return 0;\n  }\n  if (!fx && fy) {\n    puts(\"1\");\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  if (!fx && !fy) {\n    for (int i = 1; i <= n; i++) {\n      now = a[i] + x + y;\n      if (S.find(now) != S.end()) {\n        puts(\"1\");\n        printf(\"%d\\n\", a[i] + x);\n        return 0;\n      }\n      now = a[i] - x - y;\n      if (S.find(now) != S.end()) {\n        puts(\"1\");\n        printf(\"%d\\n\", a[i] - x);\n        return 0;\n      }\n      now = a[i] + x - y;\n      if (S.find(now) != S.end()) {\n        if (a[i] + x <= l) {\n          puts(\"1\");\n          printf(\"%d\\n\", a[i] + x);\n          return 0;\n        }\n        if (a[i] - y >= 0) {\n          puts(\"1\");\n          printf(\"%d\\n\", a[i] - y);\n        }\n      }\n      now = a[i] - x + y;\n      if (S.find(now) != S.end()) {\n        if (a[i] - x >= 0) {\n          puts(\"1\");\n          printf(\"%d\\n\", a[i] - x);\n          return 0;\n        }\n        if (a[i] + y <= l) {\n          puts(\"1\");\n          printf(\"%d\\n\", a[i] + y);\n          return 0;\n        }\n      }\n    }\n    puts(\"2\");\n    printf(\"%d %d\\n\", x, y);\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nset<int> s;\nmap<int, int> pt;\nint a[MAXN];\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  int px = 1, py = 1;\n  for (int i = 0; i < n; i++) {\n    if (s.find(a[i] - x) != s.end() || s.find(a[i] + x) != s.end()) px = 0;\n    if (s.find(a[i] - y) != s.end() || s.find(a[i] + y) != s.end()) py = 0;\n  }\n  int need = px * 2 + py;\n  if (need == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] - x >= 0) pt[a[i] - x] |= 2;\n    if (a[i] + x <= l) pt[a[i] + x] |= 2;\n    if (a[i] - y >= 0) pt[a[i] - y] |= 1;\n    if (a[i] + y <= l) pt[a[i] + y] |= 1;\n  }\n  for (map<int, int>::iterator it = pt.begin(); it != pt.end(); it++)\n    if ((it->second | need) == it->second) {\n      cout << 1 << endl << it->first << endl;\n      return 0;\n    }\n  cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, len, x, y;\n  cin >> n >> len >> x >> y;\n  int *a = new int[n];\n  for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n  bool flag1 = false;\n  bool flag2 = false;\n  int k, l;\n  k = 0;\n  l = 1;\n  while (l < n) {\n    if (a[l] - a[k] == x) {\n      flag1 = true;\n      break;\n    } else if (a[l] - a[k] > x) {\n      k++;\n    } else\n      l++;\n  }\n  k = 0;\n  l = 1;\n  while (l < n) {\n    if (a[l] - a[k] == y) {\n      flag2 = true;\n      break;\n    } else if (a[l] - a[k] > y) {\n      k++;\n    } else\n      l++;\n  }\n  if (flag1 & flag2) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (flag1) {\n    cout << 1 << endl << y << endl;\n    return 0;\n  }\n  if (flag2) {\n    cout << 1 << endl << x << endl;\n    return 0;\n  }\n  k = 0;\n  l = 1;\n  while (l < n) {\n    if (a[l] - a[k] == y + x) {\n      cout << 1 << endl << a[k] + x << endl;\n      return 0;\n    } else if (a[l] - a[k] > y + x) {\n      k++;\n    } else\n      l++;\n  }\n  k = 0;\n  l = 1;\n  while (l < n) {\n    if (a[l] - a[k] == y - x && (a[k] - x >= 0)) {\n      cout << 1 << endl << a[k] - x << endl;\n      return 0;\n    } else if (a[l] - a[k] == y - x && (a[l] + x <= len)) {\n      cout << 1 << endl << a[l] + x << endl;\n      return 0;\n    } else if (a[l] - a[k] > y - x) {\n      k++;\n    } else\n      l++;\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, x, y;\nlong long a[100100];\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  bool fx = false, fy = false;\n  for (int i = 0; i < n; i++) {\n    if (binary_search(a, a + n, a[i] + x)) {\n      fx = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (binary_search(a, a + n, a[i] + y)) {\n      fy = true;\n      break;\n    }\n  }\n  if (fx && fy) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (fx && !fy) {\n    printf(\"1\\n\");\n    cout << y << endl;\n    return 0;\n  }\n  if (!fx && fy) {\n    printf(\"1\\n\");\n    cout << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (binary_search(a, a + n, a[i] + x + y)) {\n      printf(\"1\\n\");\n      cout << a[i] + x << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (binary_search(a, a + n, a[i] + y - x)) {\n      if (a[i] + y > l && a[i] - x < 0) continue;\n      if (a[i] + y <= l) {\n        printf(\"1\\n\");\n        cout << a[i] + y << endl;\n      } else {\n        printf(\"1\\n\");\n        cout << a[i] - x << endl;\n      }\n      return 0;\n    }\n  }\n  printf(\"2\\n\");\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class LongJumps {\n\npublic static void main(String[] args) throws IOException {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tPrintWriter pw = new PrintWriter(System.out);\n\tString str[] = br.readLine().split(\" \");\n\tint n = Integer.parseInt(str[0]);\n\tint l = Integer.parseInt(str[1]);\n\tint x = Integer.parseInt(str[2]);\n\tint y = Integer.parseInt(str[3]);\n\tint a[] = new int[n];\n\tstr = br.readLine().split(\" \");\n\tfor(int i=0;i<n;i++) {\n\t\ta[i] = Integer.parseInt(str[i]);\n\t}\n\tboolean xFound = false, yFound = false;\n\tint low = 0, high = 1;\n\twhile(high<n) {\n\t\tif(a[high]-a[low]==x) {\n\t\t\txFound = true;\n\t\t\tbreak;\n\t\t} else if(a[high]-a[low]>x) {\n\t\t\tlow++;\n\t\t} else {\n\t\t\thigh++;\n\t\t}\n\t}\n\tlow = 0;\n\thigh = 1;\n\twhile(high<n) {\n\t\tif(a[high]-a[low]==y) {\n\t\t\tyFound = true;\n\t\t\tbreak;\n\t\t} else if(a[high]-a[low]>y) {\n\t\t\tlow++;\n\t\t} else {\n\t\t\thigh++;\n\t\t}\n\t}\n\tif(xFound && yFound) {\n\t\tpw.println(0);\n\t} else if(xFound) {\n\t\tpw.println(1);\n\t\tpw.println(y);\n\t} else if(yFound) {\n\t\tpw.println(1);\n\t\tpw.println(x);\n\t} else {\n\t\tboolean found = false;\n\t\tlow = 0;\n\t\thigh = 1;\n\t\twhile(high<n) {\n\t\t\tif(a[high]-a[low]==y-x && (a[low]+y<=l || a[low]-x >=0)) {\n//\t\t\t\tSystem.out.println(a[high]+\" \"+a[low]);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} else if(a[high]-a[low]>y-x) {\n\t\t\t\tlow++;\n\t\t\t} else {\n\t\t\t\thigh++;\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println();\n\t\tif(found) {\n\t\t\tpw.println(1);\n\t\t\tpw.println(a[low]+y > l ? a[low]-x : a[low]+y);\n\t\t} else {\n\t\t\tlow = 0;\n\t\t\thigh = 1;\n\t\t\twhile(high<n) {\n\t\t\t\tif(a[high]-a[low]==y+x) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(a[high]-a[low]>y+x) {\n\t\t\t\t\tlow++;\n\t\t\t\t} else {\n\t\t\t\t\thigh++;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(found) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(a[low]+x);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(x+\" \"+y);\n\t\t\t}\n\t\t}\n\t}\n\tbr.close();\n\tpw.close();\n}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a, s, d, f, g, h, j, k, l, i, n, m;\nset<long long> x, z, c, v;\nint main() {\n  cin >> n >> m >> k >> l;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    x.insert(a + k);\n    c.insert(a + l);\n    s = x.size();\n    x.insert(a);\n    if (x.size() == s) {\n      d = 1;\n    }\n    s = c.size();\n    c.insert(a);\n    if (c.size() == s) {\n      f = 1;\n    }\n    s = z.size();\n    z.insert(a + k);\n    if (s == z.size())\n      if (a + k < m)\n        j = a + k;\n      else if (a - l > 0)\n        j = a - l;\n    s = z.size();\n    z.insert(a + l);\n    if (s == z.size())\n      if (a + l < m)\n        j = a + l;\n      else if (a - k > 0)\n        j = a - k;\n    s = v.size();\n    v.insert(a + k);\n    if (s == v.size() && a + k < m) j = a + k;\n    s = v.size();\n    v.insert(a - l);\n    if (s == v.size() && a - l > 0) j = a - l;\n  }\n  if (d + f == 2)\n    cout << 0;\n  else if (d + f == 1) {\n    cout << 1 << endl;\n    if (d == 0)\n      cout << k;\n    else\n      cout << l;\n  } else if (j != 0)\n    cout << 1 << endl << j;\n  else\n    cout << 2 << endl << k << \" \" << l;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\npublic class Solution {\n\tstatic boolean exist_ival (int ival, int[] ruler) {\n    \tint s_i = 0;\n        int l_i = 1;\n        while (true) {\n        \tint diff = ruler[l_i] - ruler[s_i];\n        \tif (diff == ival) {\n        \t\treturn true;\n        \t}\n        \telse if (l_i == ruler.length-1 && diff < ival)\n        \t\treturn false;\n        \telse if (diff < ival)\n        \t\tl_i++;\n        \telse\n        \t\ts_i++;\n        }\n    }\n\t\n\tstatic int exist_ival (int ival, int[] ruler, int s_i) {\n\t\tint l_i = s_i + 1;\n\t\twhile (true) {\n        \tint diff = ruler[l_i] - ruler[s_i];\n        \tif (diff == ival) {\n        \t\treturn s_i;\n        \t}\n        \telse if (l_i == ruler.length-1 && diff < ival)\n        \t\treturn -1;\n        \telse if (diff < ival)\n        \t\tl_i++;\n        \telse\n        \t\ts_i++;\n        }\n\t}\n\t\n    public static void main(String[] args) {\n    \tScanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int l = scan.nextInt();\n        int x = scan.nextInt();\n        int y = scan.nextInt();\n        int[] ruler = new int[n];\n        for (int i = 0; i < n; i++) {\n        \truler[i] = scan.nextInt();\n        }\n        \n        boolean x_exist = exist_ival(x, ruler);\n        boolean y_exist = exist_ival(y, ruler);\n        if (x_exist && y_exist) {\n        \tSystem.out.println(0);\n        \treturn;\n        }\n        if (x_exist) {\n        \tSystem.out.println(1);\n        \tSystem.out.println(y);\n        \treturn;\n        }\n        if (y_exist) {\n        \tSystem.out.println(1);\n        \tSystem.out.println(x);\n        \treturn;\n        }\n        \n        int sum_exist = exist_ival(x + y, ruler, 0);\n        if (sum_exist >= 0) {\n        \tSystem.out.println(1);\n        \tSystem.out.println(ruler[sum_exist] + x);\n        \treturn;\n        }\n        int s_i = 0;\n        int diff = y - x;\n        while (s_i < n-1) {\n        \tint check = exist_ival(diff, ruler, s_i);\n        \tif (check >= 0) {\n        \t\tif (ruler[check] - x >= 0) {\n        \t\t\tSystem.out.println(1);\n        \t\t\tSystem.out.println(ruler[check] - x);\n        \t\t\treturn;\n        \t\t}\n        \t\tif (ruler[check] + y <= l) {\n        \t\t\tSystem.out.println(1);\n        \t\t\tSystem.out.println(ruler[check] + y);\n        \t\t\treturn;\n        \t\t}\n        \t\ts_i = check + 1;\n        \t}\n        \telse {\n        \t\tbreak;\n        \t}\n        }\n        System.out.println(2);\n        System.out.println(x);\n        System.out.println(y);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = (int)1e5 + 110;\nint v[maxn];\nvector<int> h;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &v[i]);\n  }\n  bool it = false;\n  for (int i = n - 1; i >= 0; i--) {\n    int h = v[i] - x;\n    if (h < 0) {\n      break;\n    }\n    int l = 0;\n    int r = i;\n    while (r - l > 1) {\n      int m = (r + l) / 2;\n      if (v[m] > h) {\n        r = m;\n      } else {\n        l = m;\n      }\n    }\n    for (int i = l; i <= r; i++) {\n      if (v[i] == h) {\n        it = true;\n      }\n    }\n  }\n  bool it_1 = false;\n  for (int i = n - 1; i >= 0; i--) {\n    int h = v[i] - y;\n    if (h < 0) {\n      break;\n    }\n    int l = 0;\n    int r = i;\n    while (r - l > 1) {\n      int m = (r + l) / 2;\n      if (v[m] > h) {\n        r = m;\n      } else {\n        l = m;\n      }\n    }\n    for (int i = l; i <= r; i++) {\n      if (v[i] == h) {\n        it_1 = true;\n      }\n    }\n  }\n  if (it && it_1) {\n    cout << \"0\";\n    return 0;\n  }\n  if (it && !it_1) {\n    cout << \"1\" << endl;\n    cout << y;\n    return 0;\n  }\n  if (!it && it_1) {\n    cout << \"1\" << endl;\n    cout << x;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (v[i] + x <= l) {\n      if ((*lower_bound(v, v + n, y + v[i] + x)) == y + v[i] + x) {\n        cout << 1 << endl;\n        cout << v[i] + x;\n        return 0;\n      } else if ((*lower_bound(v, v + n, v[i] + x - y)) == v[i] + x - y) {\n        cout << \"1\" << endl;\n        cout << v[i] + x;\n        return 0;\n      }\n    }\n    if (v[i] - x >= 0) {\n      if ((*lower_bound(v, v + n, v[i] - x + y)) == v[i] - x + y) {\n        cout << \"1\" << endl;\n        cout << v[i] - x;\n        return 0;\n      } else if ((*lower_bound(v, v + n, v[i] - x - y)) == v[i] - x - y) {\n        cout << \"1\" << endl;\n        cout << v[i] - x;\n        return 0;\n      }\n    }\n  }\n  cout << \"2\" << endl;\n  cout << x << ' ' << y;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Lokesh Khandelwal\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n = in.nextInt(), i, j;\n        long l = in.nextInt(), x = in.nextInt(), y = in.nextInt(), a[] = new long[n];\n        for(i=0;i<n;i++) {\n            a[i] = in.nextInt();\n        }\n        boolean hasX = false, hasY = false;\n        long p, q;\n        for(i=0;i<n;i++) {\n            p = a[i] + x;\n            q = a[i] - x;\n            if(!hasX && ((p <= l && Arrays.binarySearch(a, p) >= 0) || (q >= 0 && Arrays.binarySearch(a, q) >= 0))) {\n                hasX = true;\n            }\n            p = a[i] + y;\n            q = a[i] - y;\n            if(!hasY && ((p <= l && Arrays.binarySearch(a, p) >= 0) || (q >= 0 && Arrays.binarySearch(a, q) >= 0))) {\n                hasY = true;\n            }\n        }\n        if(hasX && hasY) {\n            out.printLine(0);\n            return;\n        }\n        if(hasX) {\n            out.printLine(1);\n            out.printLine(y);\n            return;\n        }\n        if(hasY) {\n            out.printLine(1);\n            out.printLine(x);\n            return;\n        }\n        for(i=0;i<n;i++) {\n            p = a[i] - x;\n            if(p >= 0 && p <= l) {\n                q = p - y;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n                q = p + y;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n            }\n            p = a[i] + x;\n            if(p >= 0 && p <= l) {\n                q = p - y;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n                q = p + y;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n            }\n            p = a[i] - y;\n            if(p >= 0 && p <= l) {\n                q = p - x;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n                q = p + x;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n            }\n            p = a[i] + y;\n            if(p >= 0 && p <= l) {\n                q = p - x;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n                q = p + x;\n                if(q >= 0 && q <= l) {\n                    if(Arrays.binarySearch(a, q) >= 0) {\n                        out.printLine(1);\n                        out.printLine(p);\n                        return;\n                    }\n                }\n            }\n        }\n        out.printLine(2);\n        out.printLine(x+\" \"+y);\n    }\n}\n\nclass InputReader\n{\n    BufferedReader in;\n    StringTokenizer tokenizer=null;\n\n    public InputReader(InputStream inputStream)\n    {\n        in=new BufferedReader(new InputStreamReader(inputStream));\n    }\n    public String next()\n    {\n        try{\n            while (tokenizer==null||!tokenizer.hasMoreTokens())\n            {\n                tokenizer=new StringTokenizer(in.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }\n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], *t, n, l, i;\nint solve(int x) {\n  int s;\n  for (i = 0; i < n - 1; i++) {\n    s = a[i] + x;\n    t = lower_bound(a + i, a + n, s);\n    if (*t == s) return 1;\n  }\n  return 0;\n}\nvoid work(int x, int y) {\n  int s;\n  for (i = 0; i < n - 1; i++) {\n    s = a[i] + y - x;\n    t = lower_bound(a + i, a + n, s);\n    if (*t == s) {\n      if (*t + x <= l) {\n        printf(\"1\\n%d\\n\", *t + x);\n        break;\n      } else if (*t - y >= 0) {\n        printf(\"1\\n%d\\n\", *t - y);\n        break;\n      }\n    }\n  }\n  if (i == n - 1) printf(\"2\\n%d %d\\n\", x, y);\n}\nint main() {\n  int x, y;\n  while (~scanf(\"%d%d%d%d\", &n, &l, &x, &y)) {\n    int flag = 0;\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    if (!solve(x)) flag++;\n    if (!solve(y)) flag += 2;\n    if (flag == 0)\n      printf(\"0\\n\");\n    else if (flag == 1)\n      printf(\"1\\n%d\\n\", x);\n    else if (flag == 2)\n      printf(\"1\\n%d\\n\", y);\n    else {\n      if (solve(y + x))\n        printf(\"1\\n%d\\n\", *t - y);\n      else\n        work(x, y);\n    }\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y = 0,0,0,0\nst,sx,sy = set(),set(),set()\n\nflagx, flagy, one = False, False, False\n\nentrada = [int(h) for h in raw_input().split()]\nn = entrada[0]\nl = entrada[1]\nx = entrada[2]\ny = entrada[3]\na = [0 for i in range(100100)]\nentrada2 = [int(j) for j in raw_input().split()]\n\nfor i in range(n):\n\ta[i]=entrada2[i]\n\tst.add(a[i])\n\tif a[i]==x:\n\t\tflagx=True\n\telif a[i]==y:\n\t\tflagy=True\n\tif a[i]>x and flagx==False:\n\t\tif (a[i]-x) in st:\n\t\t\tflagx = True\n\tif a[i]>y and flagy==False:\n\t\tif (a[i]-y) in st:\n\t\t\tflagy=True\n\nif not flagx and flagy:\n\tprint \"1\\n%d\" % (x)\nelif flagx and not flagy:\n\tprint \"1\\n%d\" % (y)\nelif flagx and flagy:\n\tprint 0\nelif not flagx and not flagy:\n\tone = False\n\tcom = -1\n\t\n\tfor i in range(n):\n\t\tleft = a[i]-x\n\t\tright = a[i]+x\n\t\tif left>=0:\n\t\t\tsx.add(left)\n\t\tif right<=l:\n\t\t\tsx.add(right)\n\n\tfor i in range(n):\n\t\tif one:\n\t\t\tbreak\n\t\tleft = a[i]-y\n\t\tright = a[i]+y\n\t\tif left>=0:\n\t\t\tif left in sx:\n\t\t\t\tone = True\n\t\t\t\tcom = left\n\t\tif right<=l:\n\t\t\tif right in sx:\n\t\t\t\tone = True\n\t\t\t\tcom = right\n   \n\tif one:\n\t\tprint \"1\\n%d\" % (com)\n\telse:\n\t\tprint \"2\\n%d %d\" % (x,y)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * 4 4\n * 1 5 3 4\n * 1 2\n * 1 3\n * 2 3\n * 3 3\n *\n *\n * @author pttrung\n */\npublic class A {\n\n    public static long Mod = (long) (1e9 + 7);\n    public static long[][] dp;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner in = new Scanner();\n        //PrintWriter out = new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n\n\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int[] data = new int[n];\n        TreeSet<Integer> set = new TreeSet();\n        for (int i = 0; i < n; i++) {\n            data[i] = in.nextInt();\n            set.add(data[i]);\n        }\n        int result = 0;\n        boolean a = false, b = false;\n\n        for (int i = 0; i < n && (!a || !b); i++) {\n            if (data[i] >= x) {\n                Integer v = set.floor((data[i] - x));\n                if (v != null && v == (data[i] - x)) {\n                    a = true;\n                }\n                if (data[i] >= y) {\n                    v = set.floor((data[i] - y));\n                    if (v != null && v == (data[i] - y)) {\n                        b = true;\n                    }\n                }\n            }\n        }\n        if (a && b) {\n            out.println(0);\n        } else if (a || b) {\n            out.println(1);\n            if (a) {\n                out.println(y);\n            } else {\n                out.println(x);\n            }\n        } else {\n            boolean found = false;\n            for (int i = 0; i < n; i++) {\n                if (data[i] >= x) {\n                    int p = data[i] - x;\n                    if (p >= y) {\n                        Integer v = set.floor((p - y));\n                        if (v != null && v == (p - y)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (p + y <= l) {\n                        Integer v = set.floor((p + y));\n                        if (v != null && v == (p + y)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n                    }\n\n                }\n                int p = data[i] + x;\n                if (p <= l && p >= y) {\n                    Integer v = set.floor((p - y));\n                    if (v != null && v == (p - y)) {\n                        out.println(1);\n                        out.println(p);\n                        found = true;\n                        break;\n                    }\n                    if (p + y <= l) {\n                        v = set.floor((p + y));\n                        if (v != null && v == (p + y)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n                if (data[i] >= y) {\n                    p = data[i] - y;\n                    if (p >= x) {\n                        Integer v = set.floor((p - x));\n                        if (v != null && v == (p - x)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n\n                    }\n                    if (p + x <= l) {\n                        Integer v = set.floor((p + x));\n                        if (v != null && v == (p + x)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n                    }\n\n                }\n                p = data[i] + y;\n                if (p <= l && p >= x) {\n                    Integer v = set.floor((p - x));\n                    if (v != null && v == (p - x)) {\n                        out.println(1);\n                        out.println(p);\n                        found = true;\n                        break;\n                    }\n                    if (p + x <= l) {\n                        v = set.floor((p + x));\n                        if (v != null && v == (p + x)) {\n                            out.println(1);\n                            out.println(p);\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!found) {\n                out.println(2);\n                out.println(x + \" \" + y);\n            }\n        }\n        out.close();\n    }\n\n    public static long pow(int a, int b, long mod) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long v = pow(a, b / 2, mod);\n        if (b % 2 == 0) {\n            return (v * v) % mod;\n        } else {\n            return (((v * v) % mod) * a) % mod;\n        }\n    }\n\n    public static int[][] powSquareMatrix(int[][] A, long p) {\n        int[][] unit = new int[A.length][A.length];\n        for (int i = 0; i < unit.length; i++) {\n            unit[i][i] = 1;\n        }\n        if (p == 0) {\n            return unit;\n        }\n        int[][] val = powSquareMatrix(A, p / 2);\n        if (p % 2 == 0) {\n            return mulMatrix(val, val);\n        } else {\n            return mulMatrix(A, mulMatrix(val, val));\n        }\n\n    }\n\n    public static int[][] mulMatrix(int[][] A, int[][] B) {\n        int[][] result = new int[A.length][B[0].length];\n        for (int i = 0; i < result.length; i++) {\n            for (int j = 0; j < result[0].length; j++) {\n                long temp = 0;\n                for (int k = 0; k < A[0].length; k++) {\n\n                    temp += ((long) A[i][k] * B[k][j] % Mod);\n                    temp %= Mod;\n                }\n                temp %= Mod;\n                result[i][j] = (int) temp;\n            }\n        }\n\n        return result;\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n\n\n\n\n    }\n\n    static class FT {\n\n        int[] data;\n\n        FT(int n) {\n            data = new int[n];\n        }\n\n        void update(int index, int val) {\n            // System.out.println(\"UPDATE INDEX \" + index);\n            while (index < data.length) {\n                data[index] += val;\n                index += index & (-index);\n\n                //    System.out.println(\"NEXT \" +index);\n            }\n        }\n\n        int get(int index) {\n            //  System.out.println(\"GET INDEX \" + index);\n            int result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= index & (-index);\n                // System.out.println(\"BACK \" + index);\n            }\n            return result;\n        }\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return gcd(b, a % b);\n        }\n    }\n\n    static long pow(long a, int b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n\n            return val * val % Mod;\n        } else {\n            return (val * val % Mod) * a % Mod;\n        }\n    }\n\n//    static Point intersect(Point a, Point b, Point c) {\n//        double D = cross(a, b);\n//        if (D != 0) {\n//            return new Point(cross(c, b) / D, cross(a, c) / D);\n//        }\n//        return null;\n//    }\n//\n//    static Point convert(Point a, double angle) {\n//        double x = a.x * cos(angle) - a.y * sin(angle);\n//        double y = a.x * sin(angle) + a.y * cos(angle);\n//        return new Point(x, y);\n//    }\n//    static Point minus(Point a, Point b) {\n//        return new Point(a.x - b.x, a.y - b.y);\n//    }\n//\n//    static Point add(Point a, Point b) {\n//        return new Point(a.x + b.x, a.y + b.y);\n//    }\n//\n    /**\n     * Cross product ab*ac\n     *\n     * @param a\n     * @param b\n     * @param c\n     * @return\n     */\n    static double cross(Point a, Point b, Point c) {\n        Point ab = new Point(b.x - a.x, b.y - a.y);\n        Point ac = new Point(c.x - a.x, c.y - a.y);\n        return cross(ab, ac);\n    }\n\n    static double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    /**\n     * Dot product ab*ac;\n     *\n     * @param a\n     * @param b\n     * @param c\n     * @return\n     */\n    static long dot(Point a, Point b, Point c) {\n        Point ab = new Point(b.x - a.x, b.y - a.y);\n        Point ac = new Point(c.x - a.x, c.y - a.y);\n        return dot(ab, ac);\n    }\n\n    static long dot(Point a, Point b) {\n        long total = a.x * b.x;\n        total += a.y * b.y;\n        return total;\n    }\n\n    static double dist(Point a, Point b) {\n        long total = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n        return Math.sqrt(total);\n    }\n\n    static long norm(Point a) {\n        long result = a.x * a.x;\n        result += a.y * a.y;\n        return result;\n    }\n\n    static double dist(Point a, Point b, Point x, boolean isSegment) {\n        double dist = cross(a, b, x) / dist(a, b);\n        // System.out.println(\"DIST \" + dist);\n\n        if (isSegment) {\n            Point ab = new Point(b.x - a.x, b.y - a.y);\n\n            long dot1 = dot(a, b, x);\n            long norm = norm(ab);\n            double u = (double) dot1 / norm;\n            if (u < 0) {\n                return dist(a, x);\n            }\n\n            if (u > 1) {\n                return dist(b, x);\n            }\n        }\n        return Math.abs(dist);\n\n\n\n\n    }\n\n    static class Point {\n\n        int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //br = new BufferedReader(new FileReader(new File(\"A-large (2).in\")));\n        }\n\n        public String next() {\n\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAX = 1e6 + 8;\nconst long long sz = 1e5 + 5;\nvoid f_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n}\nint32_t main() {\n  f_io();\n  long long t = 1;\n  while (t--) {\n    long long n, l, x, y;\n    cin >> n >> l >> x >> y;\n    unordered_map<long long, long long> vis;\n    vector<long long> v;\n    for (long long i = 0; i < n; i++) {\n      long long mark;\n      cin >> mark;\n      vis[mark] = 1;\n      v.push_back(mark);\n    }\n    long long fans = 0, flag1 = 0, flag2 = 0;\n    for (long long i = 0; i < n; i++) {\n      if (vis[x + v[i]]) {\n        flag1 = 1;\n        break;\n      }\n    }\n    for (long long i = 0; i < n; i++) {\n      if (vis[y + v[i]]) {\n        flag2 = 1;\n        break;\n      }\n    }\n    vector<long long> ans;\n    if (!flag1) {\n      fans++;\n      ans.push_back(x);\n    }\n    if (!flag2) {\n      fans++;\n      ans.push_back(y);\n    }\n    if (fans == 2) {\n      unordered_map<long long, long long> temp;\n      long long fflag = 0, _ans;\n      for (long long i = 0; i < n; i++) {\n        long long k1 = v[i] - x, k2 = v[i] + x;\n        if (k1 >= 0) temp[k1] = 1;\n        if (k2 <= l) temp[k2] = 1;\n      }\n      for (long long i = 0; i < n; i++) {\n        long long k1 = v[i] - y, k2 = v[i] + y;\n        if (k1 >= 0) {\n          if (temp[k1]) {\n            fflag = 1;\n            _ans = k1;\n            break;\n          }\n        }\n        if (k2 >= 0) {\n          if (temp[k2]) {\n            fflag = 1;\n            _ans = k2;\n            break;\n          }\n        }\n      }\n      if (fflag) {\n        cout << \"1\"\n             << \"\\n\"\n             << _ans << \"\\n\";\n        continue;\n      }\n    }\n    cout << fans << \"\\n\";\n    for (auto k : ans) cout << k << \" \";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\npublic class RookBishopKing {\n\n    private static boolean Bsearch(int left, int right, int k, int gap[]){\n        boolean res = false;\n        while (left<=right){\n                int mid = (left+right)/2;\n                            if (gap[mid]==k){\n                                res = true;\n                                break;\n                            }else if (gap[mid]>k) right = mid-1;\n                            else left = mid + 1;\n        }\n        return res;\n    }\n    public static void main (String[] args)\n    {       \n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        \n        int gap[] = new int[n];\n        for (int i=0;i<n;++i){\n            gap[i] = sc.nextInt();\n        }\n        boolean findX = false, findY = false;\n        for (int i=0;i<n;++i){\n            int k = gap[i] + x;\n            if (findX==false){\n                if (k<=l){\n                    int left = i+1, right = n-1;\n                    while (left<=right){\n                        int mid = (left+right)/2;\n                        if (gap[mid]==k){\n                            findX = true;\n                            break;\n                        }else if (gap[mid]>k) right = mid-1;\n                        else left = mid + 1;\n                    }\n                }\n            }\n\n            if (findY==false){\n                k = gap[i] + y;\n                if (k<=l ){\n                    int left = i+1, right = n-1;\n                    while (left<=right){\n                        int mid = (left+right)/2;\n                        if (gap[mid]==k){\n                            findY = true;\n                            break;\n                        }else if (gap[mid]>k) right = mid-1;\n                        else left = mid + 1;\n                    }       \n                }\n            }\n\n        }\n        if (findX ==true && findY == true){\n            System.out.println(0);\n        }else if (findY==true){\n            System.out.println(1);\n            System.out.println(x);\n        }else if (findX==true){\n            System.out.println(1);\n            System.out.println(y);\n        }else{\n            boolean found1 = false;\n            int k=0,k2=0;\n            for (int i=0;i<n && found1 ==false;++i){\n                k = gap[i]-x;\n                if (k>=0){\n                    k2 = k - y;\n                    if (k>=0)\n                        found1 = Bsearch(0, i,k2,gap);\n                    if (found1 == true) break;\n                    k2 = k + y;\n                    if (k<=l)\n                        found1 = Bsearch(i, n-1,k2,gap);\n                }\n                if (found1==true) break;\n                k = gap[i]+x;\n                if (k<=l){\n                    k2 = k + y;\n                    if (k<=l)\n                        found1 = Bsearch(i, n-1,k2,gap);\n                    if (found1==true) break;\n                    k2 = k - y;\n                    if (k<=l)\n                        found1 = Bsearch(0, i,k2,gap);\n                }\n                if (found1==true) break;\n                \n                k = gap[i]-y;\n                if (k>=0){\n                    k2 = k - x;\n                    if (k>=0)\n                        found1 = Bsearch(0, i,k2,gap);\n                    if (found1==true) break;\n                    k2 = k + x;         \n                        found1 = Bsearch(0, i,k2,gap);\n                }\n                if (found1==true) break;\n                k = gap[i]+y;\n                if (k<=l){\n                    k2 = k + x;\n                    if (k<=l)\n                        found1 = Bsearch(i, n-1,k2,gap);\n                    if (found1==true) break;\n                    k2 = k - x;             \n                        found1 = Bsearch(0, i,k2,gap);\n                }\n                if (found1==true) break;\n                \n                            \n            }\n            if (found1==false){\n                System.out.println(2);  \n                System.out.println(x + \" \" + y);\n            }else{\n                System.out.println(1);\n                System.out.println(k);\n            }\n        }\n        sc.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author karan173\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB\n{\n    int n;\n    long a[];\n    long len;\n    long x, y;\n    boolean okX;\n    boolean okY;\n    public void solve(int testNumber, FastReader in, PrintWriter out)\n    {\n        n = in.ni ();\n        len = in.nl ();\n        x = in.nl ();\n        y = in.nl ();\n        a = in.lArr (n);\n        for (long zz : a)\n        {\n            if (Arrays.binarySearch (a, zz + x) >= 0)\n            {\n                okX = true;\n            }\n            if (Arrays.binarySearch (a, zz + y) >= 0)\n            {\n                okY = true;\n            }\n        }\n        if (okX && okY)\n        {\n            out.println (0);\n            return;\n        }\n        if(okX)\n        {\n            out.println (1);\n            out.println (y);\n            return;\n        }\n        if (okY)\n        {\n            out.println (1);\n            out.println (x);\n            return;\n        }\n        long xx = Math.min (x, y);\n        long yy = Math.max (x, y);\n        //different side\n        for (long zz : a)\n        {\n            int idx1 = Arrays.binarySearch (a, zz + xx + yy);\n            if (idx1 >= 0)\n            {\n                out.println (1);\n                out.println (zz + xx);\n                return;\n            }\n        }\n\n        for (long zz : a)\n        {\n            int idx1 = Arrays.binarySearch (a, zz + yy - xx);\n            if (idx1 >= 0 && zz + yy <= len)\n            {\n                out.println (1);\n                out.println (zz + yy);\n                return;\n            }\n            if (idx1 >= 0 && zz - xx >= 0)\n            {\n                out.println (1);\n                out.println (zz - xx);\n                return;\n            }\n        }\n        out.println (2);\n        out.println (x + \" \" + y);\n    }\n}\n\nclass FastReader\n{\n\n    public InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public FastReader(InputStream stream)\n    {\n        this.stream = stream;\n    }\n\n    public FastReader()\n    {\n\n    }\n\n    public int read()\n    {\n        if (numChars == -1)\n        {\n            throw new InputMismatchException ();\n        }\n        if (curChar >= numChars)\n        {\n            curChar = 0;\n            try\n            {\n                numChars = stream.read (buf);\n            } catch (IOException e)\n            {\n                throw new InputMismatchException ();\n            }\n            if (numChars <= 0)\n            {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n\n    public int ni()\n    {\n        int c = read ();\n        while (isSpaceChar (c))\n            c = read ();\n        int sgn = 1;\n        if (c == '-')\n        {\n            sgn = -1;\n            c = read ();\n        }\n        int res = 0;\n        do\n        {\n            if (c < '0' || c > '9')\n            {\n                throw new InputMismatchException ();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read ();\n        } while (!isSpaceChar (c));\n        return res * sgn;\n    }\n\n    public long nl()\n    {\n        int c = read ();\n        while (isSpaceChar (c))\n            c = read ();\n        int sgn = 1;\n        if (c == '-')\n        {\n            sgn = -1;\n            c = read ();\n        }\n        long res = 0;\n        do\n        {\n            if (c < '0' || c > '9')\n            {\n                throw new InputMismatchException ();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read ();\n        } while (!isSpaceChar (c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c)\n    {\n        if (filter != null)\n        {\n            return filter.isSpaceChar (c);\n        }\n        return isWhitespace (c);\n    }\n\n    public static boolean isWhitespace(int c)\n    {\n        return c==' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public long[] lArr(int n)\n    {\n        long a[] = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nl ();\n        }\n        return a;\n    }\n\n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, l, x, y, a[MAXN], xok, yok, arr[MAXN + MAXN], sz;\nbool check(int d) {\n  for (int i = 0, r = 0; i < n && r < n; ++i) {\n    for (; r < n && a[r] - a[i] < d; ++r)\n      ;\n    if (r < n && a[r] - a[i] == d) return true;\n  }\n  return false;\n}\nbool ok(int p) {\n  if (p < 0 || p > l) return false;\n  return binary_search(arr, arr + sz, p);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  xok = check(x);\n  yok = check(y);\n  if (xok && yok)\n    cout << 0 << endl;\n  else if (xok || yok)\n    cout << 1 << endl << x * (xok ^ 1) + y * (yok ^ 1) << endl;\n  else {\n    int pos = -1;\n    for (int i = 0; i < n; ++i) {\n      arr[sz++] = a[i] - x;\n      arr[sz++] = a[i] + x;\n    }\n    sort(arr, arr + sz);\n    for (int i = 0; i < n && pos < 0; ++i) {\n      if (ok(a[i] - y))\n        pos = a[i] - y;\n      else if (ok(a[i] + y))\n        pos = a[i] + y;\n    }\n    if (pos == -1)\n      cout << 2 << endl << x << \" \" << y << endl;\n    else\n      cout << 1 << endl << pos << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = INT_MAX / 3;\nconst double eps = 1e-8;\nconst long long LINF = 1e17;\nconst double DINF = 1e60;\nconst int maxn = 1e5 + 10;\nset<int> st;\nvector<int> ans;\nint n, l, x, y, a[maxn];\nbool gao0(int val) {\n  for (int i = 1; i <= n; i++) {\n    int pval = a[i] + val;\n    if (st.count(pval)) return true;\n  }\n  return false;\n}\nbool gao1(int mid, int p) {\n  bool exmid = false, exp = false;\n  ans.clear();\n  for (int i = 1; i <= n; i++) {\n    int pval = a[i] + mid + p;\n    if (st.count(pval) && mid + a[i] <= l && mid + a[i] >= 0) {\n      ans.push_back(mid + a[i]);\n      return true;\n    }\n    exmid |= st.count(a[i] + mid);\n    exp |= st.count(a[i] + p);\n  }\n  if (exmid == true && exp == false) {\n    ans.push_back(p);\n    return true;\n  }\n  if (exp == true && exmid == false) {\n    ans.push_back(mid);\n    return true;\n  }\n  return false;\n}\nvoid gao() {\n  if (gao0(x) && gao0(y)) {\n    puts(\"0\");\n    return;\n  }\n  if (gao1(x, y) || gao1(y, x) || gao1(x, -y) || gao1(y, -x) || gao1(-x, y) ||\n      gao1(-y, x)) {\n    puts(\"1\");\n    printf(\"%d\\n\", ans[0]);\n    return;\n  }\n  if (x == y) {\n    printf(\"1\\n%d\\n\", x);\n    return;\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    st.insert(a[i]);\n  }\n  gao();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, bool> Map;\nint a[100005];\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    Map[a[i]] = true;\n  }\n  bool bx = false, by = false;\n  int xx, yy;\n  for (int i = 0; i < n; i++) {\n    if (Map[a[i] - x]) bx = true;\n    if (Map[a[i] + x]) bx = true;\n    if (Map[a[i] - y]) {\n      by = true;\n    }\n    if (Map[a[i] + y]) {\n      by = true;\n    }\n    if (bx && by) break;\n  }\n  if (bx && by) {\n    cout << 0 << endl;\n  } else if (bx || by) {\n    cout << 1 << endl;\n    if (bx)\n      cout << y << endl;\n    else\n      cout << x << endl;\n  } else {\n    for (int i = 1; i < n; i++) {\n      if (Map[a[i] - (x + y)]) {\n        cout << 1 << endl;\n        cout << a[i] - y << endl;\n        return 0;\n      } else if (Map[a[i] - (y - x)]) {\n        if (a[i] + x <= l) {\n          cout << 1 << endl;\n          cout << a[i] + x << endl;\n          return 0;\n        } else if (a[i] - y >= 0) {\n          cout << 1 << endl;\n          cout << a[i] - y << endl;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << endl;\n    cout << x << ' ' << y << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B{\n\tpublic static boolean DEBUG = false;\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tStringTokenizer st = getst(br);\n\t\t\n\t\tint n = nextInt(st);\n\t\tint l = nextInt(st);\n\t\tint x = nextInt(st);\n\t\tint y = nextInt(st);\n\t\t\n\t\tst = getst(br);\n\t\t\n\t\tint[] a = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = nextInt(st);\n\t\t}\n\t\t\n\t\tboolean fx = false;\n\t\tboolean fy = false;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(Arrays.binarySearch(a, x + a[i]) >= 0){\n\t\t\t\tfx = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(Arrays.binarySearch(a, y + a[i]) >= 0){\n\t\t\t\tfy = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(fx && fy){\n\t\t\tpw.println(0);\n\t\t} else if(!fx && !fy){\n\t\t\tint m = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(Arrays.binarySearch(a, x + y + a[i]) >= 0){\n\t\t\t\t\tm = a[i] + x;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(a[i] + x <= l && Arrays.binarySearch(a, x - y + a[i]) >= 0){\n\t\t\t\t\tm = a[i] + x;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(a[i] - x >= 0 && Arrays.binarySearch(a, -x + y + a[i]) >= 0){\n\t\t\t\t\tm = a[i] - x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m >= 0){\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(m);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(x + \" \" + y);\n\t\t\t}\n\t\t} else {\n\t\t\tpw.println(1);\n\t\t\tif(!fx){\n\t\t\t\tpw.println(x);\n\t\t\t}\n\t\t\tif(!fy){\n\t\t\t\tpw.println(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbr.close();\n\t\tpw.close();\n\t}\n\t\n\tpublic static void debug(Object o){\n\t\tif(DEBUG){\n\t\t\tSystem.out.println(\"~\" + o);\n\t\t}\n\t}\n\t\n\tpublic static StringTokenizer getst(BufferedReader br) throws Exception{\n\t\treturn new StringTokenizer(br.readLine(), \" \");\n\t}\n\t\n\tpublic static int nextInt(BufferedReader br) throws Exception{\n\t\treturn Integer.parseInt(br.readLine());\n\t}\n\t\n\tpublic static int nextInt(StringTokenizer st) throws Exception{\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "/**\n * ******* Created  on 10/12/19 5:10 AM*******\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D479 implements Runnable {\n\n    private static final int MAX = (int) (1E5 + 5);\n    private static final int MOD = (int) (1E9 + 7);\n    private static final int Inf = (int) (1E9 + 10);\n    long l;\n    private void solve() throws IOException {\n        int n = reader.nextInt();\n        l = reader.nextLong();\n        long x = reader.nextLong();\n        long y = reader.nextLong();\n        long[] a = new long[n];\n\n        for(int i=0;i<n;i++)a[i] = reader.nextLong();\n        int f1 = check(a, x,n,0) ;\n        int f2 =check(a,y,n,0);\n        if(f1 !=-1)\n            if(f2 !=-1)\n                writer.print(0);\n            else\n                writer.print(\"1 \\n\"+y);\n        else\n            if(f2 !=-1)\n                writer.print(\"1\\n\"+x);\n            else{\n                int f = check(a,x+y, n,0);\n                long offset = Math.max(x,y);\n                if(f!=-1) {\n                    writer.print(\"1\\n\"+ (a[f]+x));\n                    return;\n                }\n                f = check(a, Math.max(x,y) - Math.min(x,y), n, Math.max(x,y));\n                if(f == -1){\n                    offset = - Math.min(x,y);\n                    f = check(a, Math.max(x,y) - Math.min(x,y),n, offset);\n                }\n                if(f !=-1){\n                    writer.print(\"1\\n\"+(a[f] + offset));\n                }else{\n                    writer.print(\"2\\n\"+x+\" \"+y);\n                }\n            }\n\n    }\n    int check(long[] a, long x, int n, long offset){\n        int i =1, j=0;\n        long sum = 0;\n        while(i < n){\n            if(a[i] - a[j]== x){\n                if(a[j]+ offset <=l && a[j]+offset >=0)\n                    return j;\n            }\n\n            if(a[i]-a[j] > x)\n                ++j;\n            else\n                ++i;\n        }\n        return -1;\n    }\n    public static void main(String[] args) throws IOException {\n        try (Input reader = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            new D479().run();\n        }\n    }\n\n    StandardInput reader;\n    PrintWriter writer;\n\n    @Override\n    public void run() {\n        try {\n            reader = new StandardInput();\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt() , l = sc.nextInt() , x = sc.nextInt()  , y = sc.nextInt();\n\t\tHashSet<Integer> set = new HashSet<>();\n\t\tint[] a = sc.nexIntArray();\n\t\tfor (int i = 0; i < a.length; i++) \n\t\t\tset.add(a[i]);\n\t\tboolean foundX = false, foundY = false;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif(set.contains(a[i] + x) || set.contains(a[i]-x))foundX = true;\n\t\t\tif(set.contains(a[i] + y) || set.contains(a[i]-y))foundY = true;\n\t\t}\n\t\tif(foundX&&foundY) {\n\t\t\tSystem.out.println(0);return;\n\t\t}\n\t\tfor (int i = 0; i < a.length; i++) \n\t\t{\n\t\t\tif(!foundX)\n\t\t\t{\n\t\t\t\tint marker = a[i]+x;\n\t\t\t\tif(marker<=l && (set.contains(marker+y) || set.contains(marker-y)))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+marker);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmarker = a[i]-x;\n\t\t\t\tif(marker>=0 && (set.contains(marker+y) || set.contains(marker-y)))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+marker);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!foundY)\n\t\t\t{\n\t\t\t\tint marker = a[i] +y;\n\t\t\t\tif(marker<=l && (set.contains(marker+x) || set.contains(marker-x)))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+marker);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmarker = a[i]-y;\n\t\t\t\tif(marker>=0 && (set.contains(marker+x) || set.contains(marker-x)))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1+\"\\n\"+marker);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tStack<Integer> ans = new Stack<>();\n\t\tif(!foundX)ans.push(x);\n\t\tif(!foundY)ans.push(y);\n\t\tSystem.out.println(ans.size());\n\t\twhile(!ans.isEmpty())System.out.print(ans.pop()+\" \");\n\t\tSystem.out.println();\n\t}\n\t\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {br = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String file) throws FileNotFoundException {br = new BufferedReader(new FileReader(file));}\n\t\tpublic String next() throws IOException {while (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\t\tpublic int[] nexIntArray() throws Throwable {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] a = new int[st.countTokens()];\n\t\t\tfor (int i = 0; i < a.length; i++)a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nmap<int, int> m;\nint a[100000];\nvoid haha(int a, int b) {\n  if (a < 0 || a > l) return;\n  if (m[a - b] || m[a + b]) {\n    cout << 1 << endl << a << endl;\n    exit(0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    m[a[i]] = 1;\n  }\n  bool c, b;\n  c = b = 0;\n  for (int i = 0; i < n; i++) {\n    c |= m[a[i] - x];\n    c |= m[a[i] + x];\n    b |= m[a[i] - y];\n    b |= m[a[i] + y];\n  }\n  if (c && b)\n    cout << 0 << endl;\n  else if (c) {\n    cout << 1 << endl << y << endl;\n  } else if (b) {\n    cout << 1 << endl << x << endl;\n  } else {\n    for (int i = 0; i < n; i++) {\n      haha(a[i] - x, y);\n      haha(a[i] + x, y);\n      haha(a[i] - y, x);\n      haha(a[i] + y, x);\n    }\n    cout << 2 << endl << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileReader;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Agostinho Junior\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\tOutputWriter out;\n\tInputReader in;\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tthis.in = in; this.out = out;\n\t\tint n = in.readInt();\n\t\tint l = in.readInt();\n\t\tint x = in.readInt();\n\t\tint y = in.readInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.readInt();\n\t\t}\n\t\tboolean foundX = false;\n\t\tboolean foundY = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!foundX &&\n\t\t\t\t\t(Arrays.binarySearch(a, a[i] + x) >= 0 ||\n\t\t\t\t\t Arrays.binarySearch(a, a[i] - x) >= 0)) {\n\t\t\t\tfoundX = true;\n\t\t\t}\n\t\t\tif (!foundY && (Arrays.binarySearch(a, a[i] + y) >= 0 ||\n\t\t\t                Arrays.binarySearch(a, a[i] - y) >= 0)) {\n\t\t\t\tfoundY = true;\n\t\t\t}\n\t\t}\n\t\tif (foundX && foundY) {\n\t\t\tout.println(0);\n\t\t} else if (!foundX && !foundY) {\n\t\t\tboolean foundOne = false;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint[] xValues = {a[i] - x, a[i] + x};\n\t\t\t\tfor (int xValue: xValues) if (0 <= xValue && xValue <= l) {\n\t\t\t\t\tint[] yValues = {xValue - y, xValue + y};\n\t\t\t\t\tfor (int yValue: yValues) if (Arrays.binarySearch(a, yValue) >= 0) {\n\t\t\t\t\t\tout.println(1);\n\t\t\t\t\t\tout.println(xValue);\n\t\t\t\t\t\tfoundOne = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (foundOne) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundOne) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint[] yValues = {a[i] - y, a[i] + y};\n\t\t\t\tfor (int yValue: yValues) if (0 <= yValue && yValue <= l) {\n\t\t\t\t\txValues = new int[]{yValue - x, yValue + x};\n\t\t\t\t\tfor (int xValue: xValues) if (Arrays.binarySearch(a, xValue) >= 0) {\n\t\t\t\t\t\tout.println(1);\n\t\t\t\t\t\tout.println(yValue);\n\t\t\t\t\t\tfoundOne = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (foundOne) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (foundOne) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!foundOne) {\n\t\t\t\tout.println(2);\n\t\t\t\tout.println(x + \" \" + y);\n\t\t\t}\n\t\t} else if (!foundX) {\n\t\t\tout.println(1);\n\t\t\tout.println(x);\n\t\t} else {\n\t\t\tout.println(1);\n\t\t\tout.println(y);\n\t\t}\n\t}\n}\n\nclass OutputWriter {\n\tprivate PrintWriter output;\n\tpublic OutputWriter(OutputStream out) {\n\t\toutput = new PrintWriter(out);\n\t}\n\tpublic void println(Object o) {\n\t\toutput.println(o);\n\t}\n\tpublic void close() {\n\t\toutput.close();\n\t}\n}\n\nclass InputReader {\n\tprivate BufferedReader input;\n\tprivate StringTokenizer line = new StringTokenizer(\"\");\n\tpublic InputReader(InputStream in) {\n\t\tinput = new BufferedReader(new InputStreamReader(in));\n\t}\n\tpublic void fill() {\n\t\ttry {\n\t\t\tif(!line.hasMoreTokens()) line = new StringTokenizer(input.readLine());\n\t\t} catch(IOException io) { io.printStackTrace(); System.exit(0);}\n\t}\n\tpublic int readInt() {\n\t\tfill();\n\t\treturn Integer.parseInt(line.nextToken());\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class P479D {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n//        int test = in.nextInt();\n        int test = 1;\n        while(test-->0) {\n            int n = in.nextInt(), l = in.nextInt();\n            int x = in.nextInt(), y = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            Set<Integer> set = new HashSet<>();\n            boolean xFound = false, yFound = false, both = false;\n            int diff = y - x;\n            int bothVal = -1, diffVal = -1;\n            for (int i = 0; i < n; i++) {\n                if (set.contains(a[i] - x)) {\n                    xFound = true;\n                }\n                if (set.contains(a[i] - y)) {\n                    yFound = true;\n                }\n                if (set.contains(a[i] - x - y)) {\n                    both = true;\n                    bothVal = a[i] - x;\n                }\n                if (set.contains(a[i] - diff)) {\n                    int first = a[i] - diff;\n                    int second = a[i];\n                    if (first - x >= 0) {\n                        diffVal = first - x;\n                    } else if (first + y <= l) {\n                        diffVal = first + y;\n                    }\n                }\n                set.add(a[i]);\n            }\n            if (xFound && yFound) {\n                pw.println(\"0\");\n            } else if (xFound) {\n                pw.println(\"1\");\n                pw.println(y);\n            } else if (yFound) {\n                pw.println(\"1\");\n                pw.println(x);\n            } else if (both) {\n                pw.println(\"1\");\n                pw.println(bothVal);\n            } else if (diffVal > -1) {\n                pw.println(\"1\");\n                pw.println(diffVal);\n            } else {\n                pw.println(\"2\");\n                pw.println(x + \" \" + y);\n            }\n        }\n        pw.close();\n    }\n\n\n    static class InputReader {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n\n        public InputReader(InputStream st) {\n            this.stream = st;\n        }\n\n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int [] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long [] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        public static int[] shuffle(int[] a, Random gen)\n        { for(int i = 0, n = a.length;i < n;i++)\n        { int ind = gen.nextInt(n-i)+i;\n            int d = a[i];\n            a[i] = a[ind];\n            a[ind] = d;\n\n        }\n            return a;\n        }\n\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class LongJumps2 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        List<Integer> p = new ArrayList<>();\n        int xPos = search(x, a);\n        int yPos = search(y, a);\n\n        if (xPos >= 0 && yPos >= 0) {\n        } else if (xPos >= 0 || yPos >= 0) {\n            if (xPos >= 0) {\n                p.add(y);\n            } else {\n                p.add(x);\n            }\n        } else {\n            int sumPos = search(x + y, a);\n            if (sumPos >= 0) {\n                p.add(a[sumPos] + x);\n            } else {\n                List<Integer> diffPoses = searchAll(y - x, a);\n                for (Integer diffPos : diffPoses) {\n                    if (a[diffPos] >= x) {\n                        p.add(a[diffPos] - x);\n                        break;\n                    } else if (a[diffPos] + y <= l) {\n                        p.add(a[diffPos] + y);\n                        break;\n                    }\n                }\n                if (p.isEmpty()) {\n                    p.add(y);\n                    p.add(x);\n                }\n            }\n        }\n        System.out.println(p.size());\n        for (Integer pi : p) {\n            System.out.println(pi + \" \");\n        }\n\n\n    }\n\n    private static int search(int x, int[] a) {\n        List<Integer> res = searchAll(x, a);\n        if (res.isEmpty()) {\n            return -1;\n        } else {\n            return res.get(0);\n        }\n    }\n\n    private static List<Integer> searchAll(int x, int[] a) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < a.length; i++) {\n            int index1 = Arrays.binarySearch(a, i, a.length, x + a[i]);\n            if (index1 >= 0) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err(istringstream &iss) {}\ntemplate <typename T, typename... Args>\nvoid err(istringstream &iss, const T &varVal, const Args &...args) {\n  string varName;\n  iss >> varName;\n  if (varName.back() == ',') varName.back() = ' ';\n  cout << varName << \" = \" << varVal << \"; \", err(iss, args...);\n}\nint n, m, T, Q, cn = 0, K;\nint l, x, y, a[100005];\nint flgx = 0, flgy = 0, flgxplusy = 0, flgxminusy = 0;\nint main() {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (binary_search(a, a + i, a[i] - x)) {\n      flgx = 1;\n    }\n    if (binary_search(a, a + i, a[i] - y)) {\n      flgy = 1;\n    }\n    if (binary_search(a, a + i, a[i] - (x + y))) {\n      flgxplusy = a[i] - x + 1;\n    }\n    if (binary_search(a, a + i, a[i] - abs(x - y))) {\n      if (a[i] + min(x, y) <= l)\n        flgxminusy = a[i] + min(x, y);\n      else if (a[i] - max(x, y) >= 0)\n        flgxminusy = a[i] - max(x, y);\n    }\n  }\n  if (flgx && flgy) {\n    printf(\"0\\n\");\n  } else if (flgx || flgy || flgxplusy || flgxminusy) {\n    printf(\"1\\n\");\n    if (flgxminusy)\n      printf(\"%d\\n\", flgxminusy);\n    else if (flgxplusy)\n      printf(\"%d\\n\", flgxplusy - 1);\n    else if (flgx)\n      printf(\"%d\\n\", y);\n    else\n      printf(\"%d\\n\", x);\n  } else {\n    printf(\"2\\n\");\n    printf(\"%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Alex\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    ArrayList<Integer> exists(int[] a, int d){\n        int l = 0, r = 0;\n        ArrayList<Integer> res = new ArrayList();\n        while (r < a.length) {\n            if (Math.abs(a[l]-a[r]) == d) {\n                res.add(a[l]);\n                l++;\n            }\n            else {\n                if (Math.abs(a[l] - a[r]) < d) r++;\n                else l++;\n            }\n        }\n        return res;\n    }\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n = in.readInt(), l = in.readInt(), xx = in.readInt(), yy = in.readInt(), x = Math.max(xx, yy), y = Math.min(xx, yy);\n        int[] a = IOUtils.readIntArray(in, n);\n        if (exists(a, x).size() != 0 && exists(a, y).size() != 0) {\n            out.print(0);\n            return;\n        }\n        if (exists(a, x).size() != 0) {\n            out.printLine(1);\n            out.printLine(y);\n            return;\n        }\n        if (exists(a, y).size() != 0) {\n            out.printLine(1);\n            out.printLine(x);\n            return;\n        }\n        if (exists(a, y + x).size() != 0) {\n            out.printLine(1);\n            ArrayList<Integer> tmp = exists(a, y + x);\n            out.print(exists(a, y + x).get(0) + y);\n            return;\n        }\n        if (exists(a, x - y).size() != 0) {\n            ArrayList<Integer> tmp = exists(a, x - y);\n            for (int val : tmp) {\n                int left = val, right = val + x - y;\n                if (left - y >= 0 || right + y <= l) {\n                    out.printLine(1);\n                    if (left - y >= 0) out.printLine(left - y);\n                    else out.printLine(right + y);\n                    return;\n                }\n            }\n        }\n        out.printLine(2);\n        out.printLine(x, y);\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n    public int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n    public boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n    public interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n    public void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n    public void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n    public void close() {\n\t\twriter.close();\n\t}\n\n    public void print(int i) {\n\t\twriter.print(i);\n\t}\n\n\tpublic void printLine(int i) {\n\t\twriter.println(i);\n\t}\n\n}\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n\t\tint[] array = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tarray[i] = in.readInt();\n\t\treturn array;\n\t}\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, i, cx, cy;\nvector<int> vx, vy, vreq;\nint arr[100005];\nint find_a(int x) {\n  int low, high, mid;\n  low = 1;\n  high = n;\n  while ((high - low) > 1) {\n    mid = (high + low) / 2;\n    if (arr[mid] == x) return 1;\n    if (arr[mid] > x)\n      high = mid;\n    else\n      low = mid;\n  }\n  if ((arr[low] != x) && (arr[high] != x)) return -1;\n  return 1;\n}\nint find_y(int x) {\n  int low, high, mid;\n  low = 0;\n  high = vy.size() - 1;\n  while ((high - low) > 1) {\n    mid = (low + high) / 2;\n    if (vy[mid] == x) return 1;\n    if (vy[mid] > x)\n      high = mid;\n    else\n      low = mid;\n  }\n  if ((vy[low] != x) && (vy[high] != x)) return -1;\n  return 1;\n}\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &l);\n  scanf(\"%d\", &x);\n  scanf(\"%d\", &y);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &arr[i]);\n  for (i = 1; i <= n; i++) {\n    if ((arr[i] + x) <= l) {\n      vx.push_back(arr[i] + x);\n    }\n    if ((arr[i] + y) <= l) {\n      vy.push_back(arr[i] + y);\n    }\n    if ((arr[i] - x) >= 0) {\n      vx.push_back(arr[i] - x);\n    }\n    if ((arr[i] - y) >= 0) {\n      vy.push_back(arr[i] - y);\n    }\n  }\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  cx = 0;\n  cy = 0;\n  int y1;\n  for (i = 0; i < vx.size(); i++) {\n    y1 = find_y(vx[i]);\n    if (y1 != -1) {\n      vreq.push_back(vx[i]);\n    }\n  }\n  for (i = 0; i < vx.size(); i++) {\n    y1 = find_a(vx[i]);\n    if (y1 != -1) cx = 1;\n  }\n  for (i = 0; i < vy.size(); i++) {\n    y1 = find_a(vy[i]);\n    if (y1 != -1) cy = 1;\n  }\n  if ((cx + cy) == 2) {\n    cout << \"0\";\n  }\n  if ((cx + cy) == 1) {\n    cout << \"1\"\n         << \"\\n\";\n    if (cx == 0)\n      cout << x;\n    else\n      cout << y;\n  }\n  if ((cx + cy) == 0) {\n    if (vreq.size() >= 1) {\n      cout << \"1\"\n           << \"\\n\";\n      cout << vreq[0];\n    } else {\n      cout << \"2\"\n           << \"\\n\";\n      cout << x << \" \" << y;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nint n;\nlong long x, y, l;\nlong long a[MAXN];\nlong long v;\nlong long p1, p2;\nint main() {\n  while (scanf(\"%d%I64d%I64d%I64d\", &n, &l, &x, &y) != EOF) {\n    for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n    v = 2;\n    p1 = x, p2 = y;\n    int ll = 1;\n    for (int i = 1; i <= n; i++) {\n      while (a[i] - a[ll] > x) ll++;\n      if (a[i] - a[ll] == x) {\n        v--;\n        p1 = -1;\n        break;\n      }\n    }\n    ll = 1;\n    for (int i = 1; i <= n; i++) {\n      while (a[i] - a[ll] > y) ll++;\n      if (a[i] - a[ll] == y) {\n        v--;\n        p2 = -1;\n        break;\n      }\n    }\n    if (v == 2) {\n      ll = 1;\n      for (int i = 1; i <= n; i++) {\n        while (a[i] - a[ll] > y - x) ll++;\n        if (a[i] - a[ll] == y - x) {\n          if (a[i] + x <= l) {\n            v--;\n            p1 = a[i] + x;\n            p2 = -1;\n            break;\n          } else if (a[ll] - x >= 0) {\n            v--;\n            p1 = a[ll] - x;\n            p2 = -1;\n            break;\n          }\n        }\n      }\n    }\n    if (v == 2) {\n      ll = 1;\n      for (int i = 1; i <= n; i++) {\n        while (a[i] - a[ll] > y + x) ll++;\n        if (a[i] - a[ll] == y + x) {\n          v--;\n          p1 = a[ll] + x;\n          p2 = -1;\n          break;\n        }\n      }\n    }\n    printf(\"%I64d\\n\", v);\n    if (p1 != -1) printf(\"%I64d\", p1);\n    if (v == 2) printf(\" \");\n    if (p2 != -1) printf(\"%I64d\", p2);\n    if (v > 0) putchar('\\n');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a;\nvector<int> v;\nint found[2];\nset<int> s;\nbool can(int z) {\n  return (s.find(z - v[0]) != s.end() || s.find(z + v[0]) != s.end()) &&\n         (s.find(z - v[1]) != s.end() || s.find(z + v[1]) != s.end());\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  v = {x, y};\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    s.insert(a);\n  }\n  memset(found, 0, sizeof(found));\n  for (auto &it : s) {\n    for (int i = 0; i < v.size(); i++) {\n      if (s.find(it + v[i]) != s.end()) {\n        found[i] = true;\n      }\n    }\n  }\n  int need = 0;\n  vector<int> ans;\n  for (int i = 0; i < v.size(); i++) {\n    if (!found[i]) {\n      need++;\n      ans.push_back(v[i]);\n    }\n  }\n  if (need < 2) {\n    printf(\"%d\\n\", need);\n    for (int i = 0; i < ans.size(); i++) {\n      if (i != 0) printf(\" \");\n      printf(\"%d\", ans[i]);\n      if (i == ans.size() - 1) printf(\"\\n\");\n    }\n  } else {\n    for (auto &it : s) {\n      int putAt = it + v[0];\n      if (putAt <= l) {\n        if (can(putAt)) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", putAt);\n          return 0;\n        }\n      }\n      putAt = it - v[0];\n      if (putAt >= 0) {\n        if (can(putAt)) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", putAt);\n          return 0;\n        }\n      }\n      putAt = it + v[1];\n      if (putAt <= l) {\n        if (can(putAt)) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", putAt);\n          return 0;\n        }\n      }\n      putAt = it - v[1];\n      if (putAt >= 0) {\n        if (can(putAt)) {\n          printf(\"1\\n\");\n          printf(\"%d\\n\", putAt);\n          return 0;\n        }\n      }\n    }\n    printf(\"%d\\n\", need);\n    for (int i = 0; i < ans.size(); i++) {\n      if (i != 0) printf(\" \");\n      printf(\"%d\", ans[i]);\n      if (i == ans.size() - 1) printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst long long inf = 1000000000000;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<int> vm;\n  map<int, int> mp;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (mp[x] == 0) {\n      vm.push_back(x);\n      mp[x]++;\n    }\n  }\n  if (mp[0] == 0) {\n    vm.push_back(0);\n    mp[0] = 1;\n  }\n  if (mp[l] == 0) {\n    vm.push_back(l);\n    mp[l] = 1;\n  }\n  sort(vm.begin(), vm.end());\n  int cnt = 0;\n  map<int, int> mp2;\n  for (int i = 0; i < vm.size(); i++) {\n    int cur = vm[i];\n    if (mp[cur - x] == 1 && mp2[x] == 0) {\n      cnt++;\n      mp2[x] = 1;\n    }\n    if (mp[cur - y] == 1 && mp2[y] == 0) {\n      cnt++;\n      mp2[y] = 1;\n    }\n  }\n  if (cnt == 2) {\n    cout << \"0\" << '\\n';\n    return 0;\n  } else if (cnt == 1) {\n    cout << \"1\" << '\\n';\n    if (mp2[x] == 0) {\n      cout << x << '\\n';\n    } else\n      cout << y << '\\n';\n    return 0;\n  } else if (cnt == 0) {\n    for (int i = 0; i < vm.size(); i++) {\n      int cur = vm[i];\n      if (cur - x >= 0 && (mp[cur - x + y] == 1 || mp[cur - x - y] == 1)) {\n        cout << \"1\" << '\\n';\n        cout << cur - x << '\\n';\n        return 0;\n      } else if (cur + x <= l &&\n                 (mp[cur + x - y] == 1 || mp[cur + x + y] == 1)) {\n        cout << \"1\" << '\\n';\n        cout << cur + x << '\\n';\n        return 0;\n      }\n      if (cur - y >= 0 && (mp[cur - y + x] == 1 || mp[cur - y - x] == 1)) {\n        cout << \"1\" << '\\n';\n        cout << cur - y << '\\n';\n        return 0;\n      } else if (cur + y <= l &&\n                 (mp[cur + y - x] == 1 || mp[cur + y + x] == 1)) {\n        cout << \"1\" << '\\n';\n        cout << cur + y << '\\n';\n        return 0;\n      }\n    }\n  }\n  cout << \"2\" << '\\n';\n  cout << x << \" \" << y << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ninline int getBit(long long x, int pos) { return ((x >> pos) & 1); }\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\nconst int MAXN = (int)(1e5) + 10;\nint n, l;\nint g, b;\nint a[MAXN];\nint ng, nb;\nint gg[2 * MAXN], bb[2 * MAXN];\nint bst, ans[2];\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &g, &b);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  ng = nb = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] - g >= 0) {\n      gg[ng++] = a[i] - g;\n    }\n    if (a[i] + g <= l) {\n      gg[ng++] = a[i] + g;\n    }\n    if (a[i] - b >= 0) {\n      bb[nb++] = a[i] - b;\n    }\n    if (a[i] + b <= l) {\n      bb[nb++] = a[i] + b;\n    }\n  }\n  sort(gg, gg + ng);\n  sort(bb, bb + nb);\n  bst = 2;\n  ans[0] = g;\n  ans[1] = b;\n  int two = 0;\n  for (int i = 0; i < ng; i++) {\n    if (binary_search(a, a + n, gg[i])) {\n      two |= 1;\n      break;\n    }\n  }\n  for (int i = 0; i < nb; i++) {\n    if (binary_search(a, a + n, bb[i])) {\n      two |= 2;\n      break;\n    }\n  }\n  if (two == 3) {\n    puts(\"0\");\n    return 0;\n  }\n  if (two != 0) {\n    if (two == 1) {\n      bst = 1;\n      ans[0] = b;\n    } else {\n      bst = 1;\n      ans[0] = g;\n    }\n  }\n  for (int i = 0; i < ng; i++) {\n    if (binary_search(bb, bb + nb, gg[i])) {\n      if (bst > 1) {\n        bst = 1;\n        ans[0] = gg[i];\n      }\n    }\n  }\n  for (int i = 0; i < ng; i++) {\n    if (!binary_search(a, a + n, gg[i]) &&\n        (binary_search(a, a + n, gg[i] + b) ||\n         binary_search(a, a + n, gg[i] - b))) {\n      if (bst > 1) {\n        bst = 1;\n        ans[0] = gg[i];\n      }\n    }\n  }\n  for (int i = 0; i < nb; i++) {\n    if (!binary_search(a, a + n, bb[i]) &&\n        (binary_search(a, a + n, bb[i] - g) ||\n         binary_search(a, a + n, bb[i] + g))) {\n      if (bst > 1) {\n        bst = 1;\n        ans[0] = bb[i];\n      }\n    }\n  }\n  printf(\"%d\\n\", bst);\n  for (int i = 0; i < bst; i++) {\n    printf(\"%d \", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, bool> isMark;\nint main() {\n  long long n, x, y, l;\n  cin >> n >> l >> x >> y;\n  bool b = 0, g = 0, d = 0, bd = 0;\n  long long diff = y - x, B = y + x;\n  long long tmp;\n  long long mark = -1, mark2 = -1;\n  bool n1 = 1, n2 = 1;\n  for (int i = 0; i < n; i++) {\n    cin >> tmp;\n    isMark[tmp] = 1;\n    b |= isMark.count(tmp - x);\n    g |= isMark.count(tmp - y);\n    d |= isMark.count(tmp - diff);\n    bd |= isMark.count(tmp - B);\n    if (b && g) {\n      cout << \"0\";\n      return 0;\n    }\n    if (d && n1) {\n      long long idx = tmp + x;\n      if (idx > l) {\n        idx = tmp - y;\n        if (idx >= 0) {\n          mark = idx;\n        }\n      } else {\n        mark = idx;\n      }\n      if (mark == -1) {\n        d = 0;\n      } else {\n        n1 = 0;\n      }\n    }\n    if (bd && n2) {\n      mark2 = tmp - y;\n      n2 = 0;\n    }\n  }\n  if (b & !g) {\n    cout << \"1\\n\" << y;\n  } else if (g & !b) {\n    cout << \"1\\n\" << x;\n  } else if (d) {\n    cout << \"1\\n\";\n    cout << mark;\n  } else if (bd) {\n    cout << \"1\\n\" << mark2 << \"\\n\";\n  } else {\n    cout << \"2\\n\";\n    cout << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nint n, l, x, y;\nint a[maxn];\nset<int> pos;\nbool in(int x) { return x >= 0 && x <= l; }\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1, t; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    pos.insert(a[i]);\n  }\n  int repx = -1, repy = -1;\n  for (int i = 1; i <= n; i++) {\n    if (pos.count(a[i] - x)) repx = a[i];\n    if (pos.count(a[i] - y)) repy = a[i];\n  }\n  if (repx != -1 && repy != -1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (repx != -1) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  if (repy != -1) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (pos.count(a[i] - x - y)) {\n      printf(\"1\\n%d\\n\", a[i] - x);\n      return 0;\n    }\n    if (pos.count(a[i] - (y - x))) {\n      if (in(a[i] + x)) {\n        printf(\"1\\n%d\\n\", a[i] + x);\n        return 0;\n      }\n      if (in(a[i] - (y - x) - x)) {\n        printf(\"1\\n%d\\n\", a[i] - (y - x) - x);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 100010;\nconst int mod = 1e9 + 7;\nusing namespace std;\nlong long A, B, N, S, num[maxn];\nmap<long long, int> M;\nint main() {\n  scanf(\"%I64d%I64d%I64d%I64d\", &N, &S, &A, &B);\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &num[i]);\n    M[num[i]] = 1;\n  }\n  int ma = 0, mb = 0;\n  for (int i = 1; i <= N; i++) {\n    int k = num[i];\n    if (M[k + A] || M[k - A]) ma = 1;\n    if (M[k + B] || M[k - B]) mb = 1;\n  }\n  if (ma && mb) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (ma || mb) {\n    printf(\"1\\n%I64d\\n\", ma ? B : A);\n    return 0;\n  }\n  for (int i = 1; i <= N; i++) {\n    long long K = num[i];\n    if ((M[K + A + B] || M[K + A - B]) && K + A <= S) {\n      printf(\"1\\n%I64d\\n\", K + A);\n      return 0;\n    }\n    if ((M[K - A + B] || M[K - A - B]) && K - A >= 0) {\n      printf(\"1\\n%I64d\\n\", K - A);\n      return 0;\n    }\n  }\n  printf(\"2\\n%I64d %I64d\\n\", A, B);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n//import Queue.node;\npublic class TestClass {\n\tprivate static InputStream stream;\n\tprivate static byte[] buf = new byte[1024];\n\tprivate static int curChar;\n\tprivate static int numChars;\n\tprivate static SpaceCharFilter filter;\n\tprivate static PrintWriter pw;\n\tpublic static class SegmentTree{\n\t\tint arr[];\n\t\tSegmentTree(int a[]){\n\t\t\tarr = new int[(int) (2*Math.pow(2, Math.ceil(Math.log(a.length)/Math.log(2)))-1)];\n\t\t\tConstruct(a,0,0,a.length-1);\n\t\t}\n\t\tpublic int Construct(int a[],int node,int x,int y){\n\t\t\tif(x==y){\n\t\t\t\tarr[node] = a[x];\n\t\t\t\treturn arr[node];\n\t\t\t}\n\t\t\tint mid = (x+y)/2;\n\t\t\treturn arr[node] = Math.min(Construct(a,2*node+1,x,mid),Construct(a,2*node+2,mid+1,y));\n\t\t}\n\t\tpublic int getResult(int node,int x,int y,int p,int q){\n\t\t\tif(y<p||x>q)\n\t\t\t\treturn 10000000;\n\t\t\telse if(p>=x&&q<=y)\n\t\t\t\treturn arr[node];\n\t\t\tint mid = (p+q)/2;\n\t\t\treturn Math.min(getResult(2*node+1,x,y,p,mid),getResult(2*node+2,x,y,mid+1,q));\n\t\t}\n\t\tpublic void Query(int node,int x,int y,int p,int q,int di){\n\t\t\tif(y<p||x>q)\n\t\t\t\treturn;\n\t\t\tif(p==q){\n\t\t\t\tarr[node] = di;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tint mid = (p+q)/2;\n\t\t\tQuery(2*node+1,x,y,p,mid,di);\n\t\t\tQuery(2*node+2,x,y,mid+1,q,di);\n\t\t\tarr[node] = Math.min(arr[node*2+1], arr[2*node+2]);\n\t\t}\n\t}\n\tpublic static class Queue{\n\t\tprivate class node{\n\t\t\tint val;\n\t\t\tnode next;\n\t\t\tnode(int a){\n\t\t\t\tval = a;\n\t\t\t\tnext = null;\n\t\t\t}\n\t\t}\n\t\tnode head,tail;\n\t\tQueue(){\n\t\t\thead = null;\n\t\t\ttail = null;\n\t\t}\n\t\tpublic void EnQueue(int a){\n\t\t\tif(head==null){\n\t\t\t\tnode p = new node(a);\n\t\t\t\thead = p;\n\t\t\t\ttail = p;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode p = new node(a);\n\t\t\t\ttail.next = p;\n\t\t\t\ttail = p;\n\t\t\t}\n\t\t}\n\t\tpublic int DeQueue(){\n\t\t\tint a = head.val;\n\t\t\thead = head.next;\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean isEmpty(){\n\t\t\treturn head==null;\n\t\t}\n\t}\n\tpublic static void Merge(int a[],int p,int r){\n        if(p<r){\n            int q = (p+r)/2;\n            Merge(a,p,q);\n            Merge(a,q+1,r);\n            Merge_Array(a,p,q,r);\n        }\n    }\n    public static void Merge_Array(int a[],int p,int q,int r){\n        int b[] = new int[q-p+1];\n        int c[] = new int[r-q];\n        for(int i=0;i<b.length;i++)\n            b[i] = a[p+i];\n        for(int i=0;i<c.length;i++)\n            c[i] = a[q+i+1];\n        int i = 0,j = 0;\n        for(int k=p;k<=r;k++){\n            if(i==b.length){\n                a[k] = c[j];\n                j++;\n            }\n            else if(j==c.length){\n                a[k] = b[i];\n                i++;\n            }\n            else if(b[i]<c[j]){\n                a[k] = b[i];\n                i++;\n            }\n            else{\n                a[k] = c[j];\n                j++;\n            }\n        }\n    }\n    public static void Merge(int a[][],int p,int r){\n        if(p<r){\n            int q = (p+r)/2;\n            Merge(a,p,q);\n            Merge(a,q+1,r);\n            Merge_Array(a,p,q,r);\n        }\n    }\n    public static void Merge_Array(int a[][],int p,int q,int r){\n        int b[][] = new int[q-p+1][2];\n        int c[][] = new int[r-q][2];\n        for(int i=0;i<b.length;i++){\n            b[i][0] = a[p+i][0];\n            b[i][1] = a[p+i][1];\n        }\n        for(int i=0;i<c.length;i++){\n            c[i][0] = a[q+i+1][0];\n            c[i][1] = a[q+i+1][1];\n        }\n        int i = 0,j = 0;\n        for(int k=p;k<=r;k++){\n            if(i==b.length){\n                a[k][0] = c[j][0];\n                a[k][1] = c[j][1];\n                j++;\n            }\n            else if(j==c.length){\n                a[k][0] = b[i][0];\n                a[k][1] = b[i][1];\n                i++;\n            }\n            else if(b[i][0]<c[j][0]||(b[i][0]==c[j][0]&&b[i][1]<c[j][0])){\n                a[k][0] = b[i][0];\n                a[k][1] = b[i][1];\n                i++;\n            }\n            else{\n                a[k][0] = c[j][0];\n                a[k][1] = c[j][1];\n                j++;\n            }\n        }\n    }\n    public static int pow(int x,int y,int m){\n    \tif(y==0)\n    \t\treturn 1;\n    \tint k = pow(x,y/2,m);\n    \tif(y%2==0)\n    \t\treturn (int)((k*(long)k)%m);\n    \telse\n    \t\treturn (int)((((k*(long)k)%m)*x)%m);\n    }\n    static int Inversex = 0,Inversey = 0;\n    public static void InverseModulo(int a,int m){\n    \tif(m==0){\n    \t\tInversex = 1;\n    \t\tInversey = 0;\n    \t}\n    \telse{\n    \t\tInverseModulo(m,a%m);\n    \t\tint temp = Inversex;\n    \t\tInversex = Inversey;\n    \t\tInversey = temp - (a/m)*Inversey;\n    \t}\n    }\n    static long mod1 = 1000000007;\n    static long mod2 = 1000000009;\n\tpublic static long gcd(long a,long b){\n\t\tif(a%b==0)\n\t\t\treturn b;\n\t\treturn gcd(b,a%b);\n\t}\n\tpublic static boolean isPrime(long a){\n\t\tif(a==1)\n\t\t\treturn false;\n\t\telse if(a==2||a==3)\n\t\t\treturn true;\n\t\tfor(long i=2;i<=Math.sqrt(a);i++)\n\t\t\tif(a%i==0)\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\tpublic static double distance(int a,int b,int x,int y){\n\t\treturn Math.sqrt(((long)(a-x)*(long)(a-x))+((long)(b-y)*(long)(b-y)));\n\t}\n\tpublic static boolean BS(int a[],int n,int x,int y){\n\t\tif(x<=y){\n\t\t\tint mid = (x+y)/2;\n\t\t\tif(a[mid]==n)\n\t\t\t\treturn true;\n\t\t\tif(a[mid]>n)\n\t\t\t\treturn BS(a,n,x,mid-1);\n\t\t\telse\n\t\t\t\treturn BS(a,n,mid+1,y);\n\t\t}\n\t\treturn false;\n\t}\n\tprivate static void soln() {\n\t\tint n = nextInt();\n\t\tint l = nextInt();\n\t\tint x = nextInt();\n\t\tint y = nextInt();\n\t\tint a[] = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i] = nextInt();\n\t\tboolean x1 = false,y1 = false;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(a[i]==x)\n\t\t\t\tx1 = true;\n\t\t\tif(a[i]==y)\n\t\t\t\ty1 = true;\n\t\t\tif(x1&&y1)\n\t\t\t\tbreak;\n\t\t\tif(!x1)\n\t\t\t\tif(a[i]+x<=a[n-1])\n\t\t\t\t\tx1 = BS(a,a[i]+x,i+1,n-1);\n\t\t\tif(!y1)\n\t\t\t\tif(a[i]+y<=a[n-1])\n\t\t\t\t\ty1 = BS(a,a[i]+y,i+1,n-1);\n\t\t}\n\t\tint count = 0;\n\t\tif(!x1)\n\t\t\tcount++;\n\t\tif(!y1)\n\t\t\tcount++;\n\t\tif(count==2){\n\t\t\tint diff = y-x;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tboolean u = BS(a,a[i]+diff,i+1,n-1);\n\t\t\t\tif(u){\n\t\t\t\t\tif(a[i]-x>=a[0]){\n\t\t\t\t\t\tpw.println(\"1\");\n\t\t\t\t\t\tpw.println(a[i]-x);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i]+y<=a[n-1]){\n\t\t\t\t\t\tpw.println(\"1\");\n\t\t\t\t\t\tpw.println(a[i]+y);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean v = BS(a,a[i]+x+y,i+1,n-1);\n\t\t\t\tif(v){\n\t\t\t\t\tpw.println(\"1\");\n\t\t\t\t\tpw.println(a[i]+x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpw.println(count);\n\t\tif(!x1)\n\t\t\tpw.print(x+\" \");\n\t\tif(!y1)\n\t\t\tpw.print(y+\" \");\n\t}\n\tpublic static void main(String[] args) {\n\t\tInputReader(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tsoln();\n\t\tpw.close();\n\t}\n\n\t// To Get Input\n\t// Some Buffer Methods\n\n\tpublic static void InputReader(InputStream stream1) {\n\t\tstream = stream1;\n\t}\n\n\tprivate static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate static boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n\n\tprivate static int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tprivate static int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tprivate static long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tprivate static String nextToken() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tprivate static String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n\n\tprivate static int[] nextIntArray(int n) {\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = nextInt();\n\t\t}\n\t\treturn arr;\n\t}\n\n\tprivate static long[] nextLongArray(int n) {\n\t\tlong[] arr = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = nextLong();\n\t\t}\n\t\treturn arr;\n\t}\n\n\tprivate static void pArray(int[] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\treturn;\n\t}\n\n\tprivate static void pArray(long[] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\treturn;\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tprivate interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    BufferedReader in;\n    StringTokenizer str = null;\n    PrintWriter out;\n\n    private String next() throws Exception{\n    \twhile (str == null || !str.hasMoreElements())\n    \t    str = new StringTokenizer(in.readLine());\n    \treturn str.nextToken();\n    }\n    \n    private int nextInt() throws Exception{\n\treturn Integer.parseInt(next());\n    }\n    \n    public void run() throws Exception{\n    \tin = new BufferedReader(new InputStreamReader(System.in));\n    \tout = new PrintWriter(System.out);\n\tint n = nextInt(), l = nextInt(), x = nextInt(), y = nextInt();\n\tint []a = new int[n];\n\tfor(int i = 0; i < n; ++i) a[i] = nextInt();\n\tSet<Integer> set = new HashSet<Integer>();\n\tfor(int i = 0; i < n; ++i) set.add(a[i]);\n\t\n\tboolean xCan = false, yCan = false;\n\tfor(int i : set){\n\t    if (set.contains(i + x)) xCan = true;\n\t    if (set.contains(i + y)) yCan = true;\n\t}\n\t\n\tif (xCan && yCan){\n\t    out.println(0);\n\t}else if (xCan){\n\t    out.println(1);\n\t    out.println(y);\n\t}else if (yCan){\n\t    out.println(1);\n\t    out.println(x);\n\t}else{\n\t    set.clear();\n\t    for(int i = 0; i < n; ++i) if (a[i] - x >= 0) set.add(a[i] - x);\n\t    for(int i = 0; i < n; ++i) {\n\t\tif (set.contains(a[i] - y)){\n\t\t    out.println(1);\n\t\t    out.println(a[i] - y);\n\t\t    out.close();\n\t\t    return;\n\t\t}\n\t\t\n\t\tif (set.contains(a[i] + y)){\n\t\t    out.println(1);\n\t\t    out.println(a[i] + y);\n\t\t    out.close();\n\t\t    return;\n\t\t}\n\t    }\n\t    \n\t    set.clear();\n\t    for(int i = 0; i < n; ++i) if (a[i] + x < l) set.add(a[i] + x);\n\t    for(int i = 0; i < n; ++i){\n\t\tif (set.contains(a[i] - y)){\n\t\t    out.println(1);\n\t\t    out.println(a[i] - y);\n\t\t    out.close();\n\t\t    return;\n\t\t}\n\t\t\n\t\tif (set.contains(a[i] + y)){\n\t\t    out.println(1);\n\t\t    out.println(a[i] + y);\n\t\t    out.close();\n\t\t    return;\n\t\t}\n\t    }\n\t    out.println(2);\n\t    out.println(x + \" \" + y);\n\t}\n\t\n        out.close();\n    }\n\n    public static void main(String args[]) throws Exception{\n\tnew Main().run();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/*\npublic class _480B {\n\n}\n\n */\n\npublic class _480B {\n\tpublic void solve() throws FileNotFoundException {\n\t\tInputStream inputStream = System.in;\n\n\t\tInputHelper inputHelper = new InputHelper(inputStream);\n\n\t\tPrintStream out = System.out;\n\n\t\t//actual solution\n\n\t\tint n = inputHelper.readInteger();\n\t\tint l = inputHelper.readInteger();\n\t\tint x = inputHelper.readInteger();\n\t\tint y = inputHelper.readInteger();\n\t\t\n\t\tint[] a = new int[n];\n\t\t\n\t\tSet<Integer> as = new HashSet<Integer>();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ta[i] = inputHelper.readInteger();\n\t\t\tas.add(a[i]);\n\t\t}\n\t\t\n\t\tboolean xe = false;\n\t\tboolean ye = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(as.contains(a[i] + x))\n\t\t\t{\n\t\t\t\txe = true;\n\t\t\t}\n\t\t\tif(as.contains(a[i] + y))\n\t\t\t{\n\t\t\t\tye = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(xe && ye)\n\t\t{\n\t\t\tSystem.out.println(\"0\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(xe)\n\t\t{\n\t\t\tSystem.out.println(\"1\");\n\t\t\tSystem.out.println(y);\n\t\t\treturn;\n\t\t}\n\t\tif(ye)\n\t\t{\n\t\t\tSystem.out.println(\"1\");\n\t\t\tSystem.out.println(x);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = a[i] - x;\n\t\t\tif(p >= 0 && p + y <= l && as.contains(p + y))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tSystem.out.println(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p - y >= 0 && as.contains(p - y))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tSystem.out.println(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tp = a[i] + x;\n\t\t\tif(p + y <= l && as.contains(p + y))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tSystem.out.println(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(p <= l && p - y >= 0 && as.contains(p - y))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tSystem.out.println(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"2\");\n\t\t\n\t\tSystem.out.print(x + \" \");\n\t\tSystem.out.println(y);\n\t\t\n\t\t//end here\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t(new _480B()).solve();\n\t}\n\n\tclass InputHelper {\n\t\tStringTokenizer tokenizer = null;\n\t\tprivate BufferedReader bufferedReader;\n\n\t\tpublic InputHelper(InputStream inputStream) {\n\t\t\tInputStreamReader inputStreamReader = new InputStreamReader(\n\t\t\t\t\tinputStream);\n\t\t\tbufferedReader = new BufferedReader(inputStreamReader, 16384);\n\t\t}\n\n\t\tpublic String read() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString line = bufferedReader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic Integer readInteger() {\n\t\t\treturn Integer.parseInt(read());\n\t\t}\n\n\t\tpublic Long readLong() {\n\t\t\treturn Long.parseLong(read());\n\t\t}\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "def readint():\n    return map(int, raw_input().split())\n\n\ndef readstring():\n    return raw_input().split()\n\nn, L, x, y = readint()\narray = readint()\nmarks = {}\ntodo = {}\nfor i in array:\n    marks[i] = 1\n\nfindx = False\nfindy = False\nfor i in array:\n    if i + x in marks:\n        findx = True\n    elif i + x <= L:\n        todo[i + x] = 1\n    if i - x in marks:\n        findx = True\n    elif i - x >= 0:\n        todo[i - x] = 1\n\nfor i in array:\n    if i + y in marks:\n        findy = True\n    elif i + y <= L:\n        if i + y in todo:\n            todo[i + y] += 2\n        else:\n            todo[i + y] = 2\n    if i - y in marks:\n        findy = True\n    elif i - y >= 0:\n        if i - y in todo:\n            todo[i - y] += 2\n        else:\n            todo[i - y] = 2\n\nif findx and findy:\n    print 0\n    exit()\n\nfor i in todo.keys():\n    if todo[i] == 3:\n        print 1\n        print i\n        exit()\n\nif findx or findy:\n    print 1\nelse:\n    print 2\n\nfor i in todo.keys():\n    if todo[i] % 2 == 1 and not findx:\n        print i,\n        findx = True\n    if todo[i] >= 2 and not findy:\n        print i,\n        findy = True\nprint \"\"\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            BLongJumps solver = new BLongJumps();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class BLongJumps {\n        int[] a;\n        IntegerHashMap map;\n\n        int findDelta(int d, boolean first) {\n            map.clear();\n            int ans = -1;\n            for (int v : a) {\n                if (map.containKey(v - d)) {\n                    if (ans == -1 || !first) {\n                        ans = v;\n                    }\n                }\n                map.modify(v, 1);\n            }\n            return ans;\n        }\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int l = in.ri();\n            int x = in.ri();\n            int y = in.ri();\n            a = in.ri(n);\n            map = new IntegerHashMap(n, false);\n            boolean xOk = findDelta(x, true) != -1;\n            boolean yOk = findDelta(y, true) != -1;\n            if (xOk && yOk) {\n                out.println(0);\n                return;\n            }\n            if (xOk != yOk) {\n                int target = xOk ? y : x;\n                out.println(1);\n                out.println(target);\n                return;\n            }\n            //find both\n            int both = findDelta(x + y, true);\n            if (both != -1) {\n                //find, cool\n                out.println(1);\n                out.println(both - y);\n                return;\n            }\n            int leftside = findDelta(y - x, true);\n            if (leftside != -1 && leftside + x <= l) {\n                out.println(1);\n                out.println(leftside + x);\n                return;\n            }\n            int rightside = findDelta(y - x, false);\n            if (rightside != -1 && rightside - y >= 0) {\n                out.println(1);\n                out.println(rightside - y);\n                return;\n            }\n            out.println(2);\n            out.append(x).append(' ').append(y).println();\n        }\n\n    }\n\n    static class IntegerHashMap {\n        private int now;\n        private int[] slot;\n        private int[] version;\n        private int[] next;\n        private int[] keys;\n        private int[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public IntegerHashMap(int cap, boolean rehash) {\n            now = 1;\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            version = new int[slot.length];\n            next = new int[cap + 1];\n            keys = new int[cap + 1];\n            values = new int[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int[] newVersions = new int[newSlots.length];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                access(i);\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.version = newVersions;\n            now = 0;\n            this.mask = newMask;\n        }\n\n        private int hash(int x) {\n            return hasher.hash(x);\n        }\n\n        public void modify(int x, int dy) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = dy;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = dy;\n                } else {\n                    values[index] += dy;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public boolean containKey(int x) {\n            int h = hash(x);\n            int s = h & mask;\n            access(s);\n            if (slot[s] == 0) {\n                return false;\n            }\n            return keys[findIndexOrLastEntry(s, x)] == x;\n        }\n\n        private int findIndexOrLastEntry(int s, int x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public void clear() {\n            alloc = 0;\n            size = 0;\n            now++;\n        }\n\n        private void access(int i) {\n            if (version[i] != now) {\n                version[i] = now;\n                slot[i] = 0;\n            }\n        }\n\n        public IntegerEntryIterator iterator() {\n            return new IntegerEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public int getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public int getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            IntegerEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface IntegerEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        int getEntryKey();\n\n        int getEntryValue();\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis() * 31L;\n\n        public int shuffle(long z) {\n            z += time;\n            z = (z ^ (z >>> 33)) * 0x62a9d9ed799705f5L;\n            return (int) (((z ^ (z >>> 28)) * 0xcb24d0a5c88c35b3L) >>> 32);\n        }\n\n        public int hash(int x) {\n            return shuffle(x);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint n, l, x, y;\nint a[MAXN];\nbool check(int i, int x) {\n  int j = lower_bound(a, a + n, a[i] + x) - a;\n  if (j < n && a[j] == a[i] + x)\n    return true;\n  else\n    return false;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  bool b1 = false;\n  bool b2 = false;\n  for (int i = 0; i < n; ++i) {\n    if (check(i, x)) b1 = true;\n    if (check(i, y)) b2 = true;\n  }\n  if (b1 && b2)\n    printf(\"0\\n\");\n  else if (b1)\n    printf(\"1\\n%d\\n\", y);\n  else if (b2)\n    printf(\"1\\n%d\\n\", x);\n  else {\n    bool flag = false;\n    for (int i = 0; i < n; ++i) {\n      if (check(i, y - x)) {\n        if (a[i] + y <= l) {\n          printf(\"1\\n%d\\n\", a[i] + y);\n          flag = true;\n          break;\n        } else if (a[i] - x >= 0) {\n          printf(\"1\\n%d\\n\", a[i] - x);\n          flag = true;\n          break;\n        }\n      }\n      if (check(i, x + y)) {\n        printf(\"1\\n%d\\n\", a[i] + x);\n        flag = true;\n        break;\n      }\n    }\n    if (!flag) printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-7;\nconst long long SZ = 200010, SSZ = 21, APB = 52, one = 11;\nconst long long INF = 0x7f7f7f7f, mod = 1000000007;\nlong long n, len, alen, blen, arr[SZ];\nset<int> st;\nbool chk1() {\n  bool ok1 = 0, ok2 = 0;\n  for (int i = 1; i <= n; ++i) {\n    ok1 |= st.find(arr[i] + alen) != st.end();\n    ok2 |= st.find(arr[i] + blen) != st.end();\n  }\n  if (ok1 && ok2)\n    cout << 0 << endl;\n  else if (ok1)\n    cout << 1 << endl << blen << endl;\n  else if (ok2)\n    cout << 1 << endl << alen << endl;\n  return ok1 || ok2;\n}\nbool chk2() {\n  bool ok = 0;\n  for (int i = 1; i <= n; ++i) {\n    int pos = arr[i] + alen;\n    ok |= st.find(pos + blen) != st.end();\n    ok |= st.find(pos - blen) != st.end();\n    if (ok && pos >= 0 && pos <= len) {\n      cout << 1 << endl;\n      cout << pos << endl;\n      return 1;\n    } else\n      ok = 0;\n    pos = arr[i] - alen;\n    ok |= st.find(pos + blen) != st.end();\n    ok |= st.find(pos - blen) != st.end();\n    if (ok && pos >= 0 && pos <= len) {\n      cout << 1 << endl;\n      cout << pos << endl;\n      return 1;\n    } else\n      ok = 0;\n  }\n  return ok;\n}\nvoid init() {\n  cin >> n >> len >> alen >> blen;\n  for (int i = 1; i <= n; ++i) {\n    cin >> arr[i];\n    st.insert(arr[i]);\n  }\n  if (chk1())\n    ;\n  else if (chk2())\n    ;\n  else\n    cout << 2 << endl << alen << \" \" << blen << endl;\n}\nvoid work() {}\nint main() {\n  std::ios::sync_with_stdio(0);\n  int casenum;\n  {\n    init();\n    work();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, l, x, y, a[MAXN], xok, yok, arr1[MAXN + MAXN], arr2[MAXN + MAXN], sz;\nbool check(int d) {\n  for (int i = 0, r = 0; i < n && r < n; ++i) {\n    for (; r < n && a[r] - a[i] < d; ++r)\n      ;\n    if (r < n && a[r] - a[i] == d) return true;\n  }\n  return false;\n}\nbool ok(int p) {\n  if (p < 0 || p > l) return false;\n  return binary_search(arr1, arr1 + sz, p) || binary_search(arr2, arr2 + sz, p);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  xok = check(x);\n  yok = check(y);\n  if (xok && yok)\n    cout << 0 << endl;\n  else if (xok || yok)\n    cout << 1 << endl << x * (xok ^ 1) + y * (yok ^ 1) << endl;\n  else {\n    int pos = -1;\n    for (int i = 0; i < n; ++i) {\n      arr1[sz] = a[i] - x;\n      arr2[sz++] = a[i] + x;\n    }\n    sort(arr1, arr1 + sz);\n    sort(arr2, arr2 + sz);\n    for (int i = 0; i < n && pos < 0; ++i) {\n      if (ok(a[i] - y))\n        pos = a[i] - y;\n      else if (ok(a[i] + y))\n        pos = a[i] + y;\n    }\n    if (pos == -1)\n      cout << 2 << endl << x << \" \" << y << endl;\n    else\n      cout << 1 << endl << pos << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint flag1 = 0, flag2 = 0, flag3 = 0, ff3, flag4 = 0;\nint n, a[200000 + 5], x, y;\nmap<int, bool> mp;\nint main() {\n  n = read();\n  read();\n  x = read();\n  y = read();\n  for (int i = 1; i <= n; ++i) mp[a[i] = read()] = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (mp[a[i] - x]) flag1 = i;\n    if (mp[a[i] - y]) flag2 = i;\n    if (mp[a[i] - y + x] && (a[i] - y >= 0 || a[i] + x <= a[n]))\n      flag3 = i, ff3 = (a[i] - y >= 0) ? a[i] - y : a[i] + x;\n    ;\n    if (mp[a[i] - y - x]) flag4 = i;\n  }\n  if (flag1 && flag2)\n    puts(\"0\");\n  else if (flag1 | flag2)\n    printf(\"1\\n%d\", flag1 ? y : x);\n  else if (flag3)\n    printf(\"1\\n%d\", ff3);\n  else if (flag4)\n    printf(\"1\\n%d\", a[flag4] - x);\n  else\n    printf(\"2\\n%d %d\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int n;\n  long long l, first, second;\n  cin >> n >> l >> first >> second;\n  vector<long long> a(n);\n  map<long long, bool> flag;\n  for (int i = 0; i < int(n); i++) {\n    cin >> a[i];\n    flag[a[i]] = true;\n  }\n  bool fx = false, fy = false;\n  for (int i = n - 1; i >= 0; i--) {\n    if (flag.count(a[i] - first)) fx = true;\n    if (flag.count(a[i] - second)) fy = true;\n  }\n  if (!fx && !fy) {\n    long long diff = second - first;\n    for (int i = 0; i < n; i++) {\n      if (flag.count(a[i] - diff)) {\n        if (a[i] + first <= l) {\n          cout << 1 << \"\\n\";\n          cout << a[i] + first;\n          return 0;\n        }\n        if (a[i] - second >= 0) {\n          cout << 1 << \"\\n\";\n          cout << a[i] - second;\n          return 0;\n        }\n      }\n    }\n    long long add = first + second;\n    for (int i = 0; i < n; i++) {\n      if (flag.count(a[i] + add)) {\n        if (a[i] + first <= l) {\n          cout << 1 << \"\\n\";\n          cout << a[i] + first;\n          return 0;\n        }\n      }\n    }\n    cout << 2 << \"\\n\";\n    cout << first << \" \" << second;\n  } else if (!fx) {\n    cout << 1 << \"\\n\";\n    cout << first;\n  } else if (!fy) {\n    cout << 1 << \"\\n\";\n    cout << second;\n  } else\n    cout << \"0\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[110000];\nmap<int, int> num;\nint n, l, x, y;\nint main() {\n  int ok = 0;\n  int i, j;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    num.insert(pair<int, int>(a[i], 1));\n  }\n  for (i = 0, j = 0; j != n;) {\n    if (a[j] - a[i] == x) {\n      ok += 1;\n      break;\n    } else if (a[j] - a[i] < x) {\n      j++;\n    } else\n      i++;\n  }\n  for (i = 0, j = 0; j != n;) {\n    if (a[j] - a[i] == y) {\n      ok += 2;\n      break;\n    } else if (a[j] - a[i] < y) {\n      j++;\n    } else\n      i++;\n  }\n  if (ok == 3)\n    printf(\"0\");\n  else if (ok == 1)\n    printf(\"1\\n%d\", y);\n  else if (ok == 2)\n    printf(\"1\\n%d\", x);\n  else {\n    for (i = 0; i < n; i++) {\n      int z = a[i] + x;\n      if (z <= l) {\n        if (num[z + y] == 1 || num[z - y] == 1) {\n          printf(\"1\\n%d\", z);\n          break;\n        }\n      }\n      z = a[i] - x;\n      if (z >= 0) {\n        if (num[z + y] == 1 || num[z - y] == 1) {\n          printf(\"1\\n%d\", z);\n          break;\n        }\n      }\n      z = a[i] + y;\n      if (z <= l) {\n        if (num[z + x] == 1 || num[z - x] == 1) {\n          printf(\"1\\n%d\", z);\n          break;\n        }\n      }\n      z = a[i] - y;\n      if (z >= 0) {\n        if (num[z + x] == 1 || num[z - x] == 1) {\n          printf(\"1\\n%d\", z);\n          break;\n        }\n      }\n    }\n    if (i == n) printf(\"2\\n%d %d\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n *\n * @author Mukesh Singh\n *\n */\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.DecimalFormat;\n@SuppressWarnings(\"unchecked\")\npublic class AB {\t\n\t//solve test cases\n\tvoid solve() throws Exception {\n\t\tint n = in.nextInt();\n\t\tint l = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\tlong y = in.nextInt();\t\n\t\tlong[] d = new long[n];\n\t\tfor(int i = 0 ; i < n ; ++i ) d[i]= in.nextLong();\n\t\tlong[]res = new long[2];\n\t\tboolean[] flag = new boolean[6];\n\t\tfor(int i = 0 ; i < n ; ++i ){\n\t\t\tlong xi = d[i] ;\n\t\t\tif(find(d,xi+x)) flag[0] = true; \n\t\t\tif(find(d,xi+y)) flag[1] = true ;\n\t\t\tif((find(d,xi+x+y)||find(d,xi-y+x))&& (d[i]+x <= l )){\n\t\t\t\tflag[2] = true ; res[0] = d[i]+x ;\n\t\t\t}\n\t\t\tif((find(d,xi+y-x)||find(d,xi-x-y))&& (d[i]-x >= 0 )){\n\t\t\t\tflag[3] = true ; res[1] = d[i]-x ;\n\t\t\t}\n\t\t}\n\t\tif(flag[0] && flag[1]) System.out.println(0);\n\t\telse if(flag[0] && !flag[1]){\n\t\t \tSystem.out.println(1);\n\t\t \tSystem.out.println(l-y);\n\t\t}else if(!flag[0] && flag[1]){\n\t\t \tSystem.out.println(1);\n\t\t \tSystem.out.println(x);\n\t\t}\n\t\telse if(flag[2]){\n\t\t \tSystem.out.println(1);\n\t\t \tSystem.out.println(res[0]);\n\t\t}\n\t\telse if(flag[3]){\n\t\t \tSystem.out.println(1);\n\t\t \tSystem.out.println(res[1]);\n\t\t}\n\t\telse {\n\t\t \tSystem.out.println(2);\n\t\t \tSystem.out.println(x+\" \"+(l-y));\n\t\t}\n\t}\n\tboolean find(long[] ar , long num){\n\t\tint low = 0 ; int high = ar.length-1 ;\n\t\tboolean res = false ;\n\t\twhile(low <= high){\n\t\t\tint mid = (low+high)/2 ;\n\t\t\tif(ar[mid]== num){\n\t\t\t\tres = true ; break ;\n\t\t\t}\n\t\t\telse if(ar[mid] < num){\n\t\t\t\tlow = mid+1 ;\n\t\t\t}\n\t\t\telse high = mid-1 ;\t\t\t\n\t\t}\n\t\treturn res ;\n\t}\n\t//@ main function\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew AB();\n\t}\n\t\n\tInputReader in;\n\tPrintStream out ;\n\tDecimalFormat df ;\n\tAB() {\n\t\ttry {\n\t\t\tFile defaultInput = new File(\"file.in\");\n\t\t\tif (defaultInput.exists()) \n\t\t\t\tin = new InputReader(\"file.in\");\n\t\t\telse \n\t\t\t\tin = new InputReader();\n\t\t\tdefaultInput = new File(\"file.out\");\n\t\t\tif (defaultInput.exists()) \n\t\t\t\tout = new PrintStream(new FileOutputStream(\"file.out\"));\n\t\t\telse\n\t\t\t\tout = new PrintStream(System.out);\n\t\t\tdf = new DecimalFormat(\"######0.00\");\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} \n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(261);\n\t\t}\n\t}\n\t\n\tclass InputReader {\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\t\t\n\t\tInputReader() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tInputReader(String fileName) throws FileNotFoundException {\n\t\t\treader = new BufferedReader(new FileReader(new File(fileName)));\n\t\t}\n\t\t\n\t\tString readLine() throws IOException {\n\t\t\treturn reader.readLine();\n\t\t}\n\t\t\n\t\tString nextToken() throws IOException {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t\ttokenizer = new StringTokenizer(readLine());\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tboolean hasMoreTokens() throws IOException {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\tString s = readLine();\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\ttokenizer = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\t\t\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\t\t\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n\t\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2147483647;\nconst int N = 100005;\nint n, l, x, y, tab[N], isX, isY, v, i, diff, sum;\nset<int> zb;\nint main() {\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  zb.clear();\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &tab[i]);\n    zb.insert(tab[i]);\n  }\n  isX = isY = 0;\n  for (i = 0; i < n; i++) {\n    if (zb.find(tab[i] + x) != zb.end()) {\n      isX = 1;\n    }\n    if (zb.find(tab[i] + y) != zb.end()) {\n      isY = 1;\n    }\n  }\n  if (isX == 1 && isY == 1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (isX == 1) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  if (isY == 1) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  diff = y - x;\n  sum = y + x;\n  for (i = 0; i < n; i++) {\n    if (zb.find(tab[i] + diff) != zb.end()) {\n      v = *(zb.find(tab[i] + diff));\n      if (tab[i] - x >= 0) {\n        printf(\"1\\n%d\\n\", tab[i] - x);\n        return 0;\n      }\n      if (tab[i] + y <= l) {\n        printf(\"1\\n%d\\n\", tab[i] + y);\n        return 0;\n      }\n    }\n    if (tab[i] * 1LL + sum <= l && zb.find(tab[i] + sum) != zb.end()) {\n      printf(\"1\\n%d\\n\", tab[i] + x);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 123;\nint n, l, x, y;\nint a[maxn];\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  int res = 0;\n  for (int i = 0; i < n; ++i) {\n    if (binary_search(a, a + n, a[i] + x)) res |= 1;\n    if (binary_search(a, a + n, a[i] + y)) res |= 2;\n  }\n  if (res == 3)\n    return puts(\"0\"), 0;\n  else if (res == 1)\n    return printf(\"1\\n%d\\n\", y), 0;\n  else if (res == 2)\n    return printf(\"1\\n%d\\n\", x), 0;\n  int tans = -1;\n  for (int i = 0; i < n && a[i] + x <= l && tans == -1; ++i) {\n    int v = a[i] + x;\n    if (binary_search(a, a + n, v - y) || binary_search(a, a + n, v + y))\n      tans = v;\n  }\n  for (int i = n - 1; i >= 0 && a[i] - x >= 0 && tans == -1; --i) {\n    int v = a[i] - x;\n    if (binary_search(a, a + n, v - y) || binary_search(a, a + n, v + y))\n      tans = v;\n  }\n  if (tans == -1)\n    printf(\"2\\n%d %d\\n\", x, y);\n  else\n    printf(\"1\\n%d\\n\", tans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 200005;\nint a[MAX], X[MAX], Y[MAX], idxX, idxY;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  bool checkX = 0, checkY = 0;\n  for (int i = 0; i < n; ++i) {\n    if (binary_search(a, a + n, a[i] + x) ||\n        binary_search(a, a + n, a[i] - x)) {\n      checkX = 1;\n    } else if (!checkX) {\n      if (a[i] + x < l) X[idxX++] = a[i] + x;\n      if (a[i] - x >= 0) X[idxX++] = a[i] - x;\n    }\n    if (binary_search(a, a + n, a[i] + y) ||\n        binary_search(a, a + n, a[i] - y)) {\n      checkY = 1;\n    } else if (!checkY) {\n      if (a[i] + y < l) Y[idxY++] = a[i] + y;\n      if (a[i] - y >= 0) Y[idxY++] = a[i] - y;\n    }\n  }\n  if (checkX && checkY) {\n    printf(\"0\");\n  } else if (checkX) {\n    printf(\"1\\n%d\", Y[0]);\n  } else if (checkY) {\n    printf(\"1\\n%d\", X[0]);\n  } else {\n    sort(X, X + idxX);\n    sort(Y, Y + idxY);\n    for (int i = 0; i < idxX; ++i) {\n      if (binary_search(Y, Y + idxY, X[i])) {\n        printf(\"1\\n%d\", X[i]);\n        return 0;\n      }\n    }\n    printf(\"2\\n%d %d\", X[0], Y[0]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        int n = in.nextInt();\n       int l = in.nextInt();\n       int x = in.nextInt();\n       int y = in.nextInt();\n       int[] a= new int[n];\n       for (int i =0;i<n;i++)\n           a[i]=in.nextInt();\n       boolean check1=false;\n       boolean check2= false;\n       for (int i =0;i<n&&(!check1||!check2);i++)\n       {\n           if (Arrays.binarySearch(a,a[i]-x)>=0)\n           {\n               check1=true;\n           }\n           if (Arrays.binarySearch(a,a[i]-y)>=0)\n           {\n               check2=true;\n           }\n       }\n       if (check1||check2)\n       {\n           if (!check1)\n           {\n               out.printLine(1);\n               out.printLine(x);\n           }\n           else if (!check2)\n           {\n               out.printLine(1);\n               out.printLine(y);\n           }\n           else\n               out.printLine(0);\n       }\n       else\n       {\n\n               for (int i =0;i<n;i++)\n               {\n                   if (Arrays.binarySearch(a, a[i] - (x + y)) >= 0)\n                   {\n                       out.printLine(1);\n                       out.printLine(a[i]-(x));\n                       check1=true;\n                       break;\n\n                   }\n               }\n               if (!check1) {\n                   for (int i = 0; i < n; i++) {\n                       if (Arrays.binarySearch(a, a[i] - (y - x)) >= 0) {\n                           if (a[i] + x <= l) {\n                               out.printLine(1);\n                               out.printLine(a[i] + x);\n                               check1 = true;\n                               break;\n                           }\n                           else if (a[i]-y>=0)\n                           {\n                               out.printLine(1);\n                               out.printLine(a[i] - y);\n                               check1 = true;\n                               break;\n                           }\n                       }\n\n                   }\n\n               }\n               if(!check1)    {\n                   out.printLine(2);\n                   out.printLine(x + \" \" + y);\n               }\n\n\n\n       }\n        out.flush();\n    }\n\n\n}\n\nclass pair  implements Comparable\n{\n\n    int key;\n    int value;\n    public pair(Object key, Object value) {\n\n        this.key = (int)key;\n        this.value=(int)value;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        pair temp =(pair)o;\n        return  key-temp.key;\n    }\n}\nclass Graph {\n\n\n    int n;\n    ArrayList<Integer>[] adjList;\n\n    public Graph(int n) {\n        this.n = n;\n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            adjList[i] = new ArrayList<>();\n    }\n\n}\n\n\nclass InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (snumChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void flush() {\n        writer.flush();\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, v[100003];\nint check(int q, int s) {\n  int w = 1, r = 0;\n  for (int i = 2; i <= n; ++i) {\n    if (v[i] == q) {\n      return v[i];\n    }\n    while (w < i && v[i] - v[w] > q) ++w;\n    if (v[i] - v[w] == q) {\n      if (v[i] - s >= 0 || v[w] + s < l) return v[i];\n      r = v[i];\n    }\n  }\n  return r;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; ++i) {\n    cin >> v[i];\n  }\n  if (!check(x, x)) {\n    if (!check(y, y)) {\n      int r = check(y - x, y);\n      if (r >= y) {\n        cout << 1 << \"\\n\" << r - y;\n      } else if (r && r + x <= l) {\n        cout << 1 << \"\\n\" << r + x;\n      } else {\n        r = check(x + y, x + y);\n        if (r) {\n          cout << 1 << \"\\n\" << r - x;\n        } else {\n          cout << 2 << \"\\n\" << x << \" \" << y;\n        }\n      }\n    } else {\n      cout << 1 << \"\\n\" << x;\n    }\n  } else if (!check(y, y)) {\n    cout << 1 << \"\\n\" << y;\n  } else {\n    cout << 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s1, s2, s3;\nint main() {\n  int n, l, x, y, tem;\n  int flag1 = 0, flag2 = 0, flag3 = 0;\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> tem;\n    if (s1.count(tem)) {\n      flag1 = 1;\n    }\n    if (s2.count(tem)) {\n      flag2 = 1;\n    }\n    if (tem - x >= 0 && tem - x <= l) {\n      s1.insert(tem - x);\n    }\n    if (tem + x >= 0 && x + tem <= l) {\n      s1.insert(tem + x);\n    }\n    if (tem - y >= 0 && tem - y <= l) {\n      s2.insert(tem - y);\n    }\n    if (y + tem >= 0 && y + tem <= l) {\n      s2.insert(tem + y);\n    }\n  }\n  if (flag1 == 1 && flag2 == 1) {\n    cout << 0 << endl;\n  }\n  if (flag1 == 0 && flag2 == 1) {\n    cout << 1 << endl;\n    cout << x << endl;\n  }\n  if (flag1 == 1 && flag2 == 0) {\n    cout << 1 << endl;\n    cout << y << endl;\n  }\n  if (flag1 == 0 && flag2 == 0) {\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),\n                     insert_iterator<set<int> >(s3, s3.begin()));\n    if (s3.size() == 0) {\n      cout << 2 << endl;\n      cout << x << ' ' << y << endl;\n    } else {\n      cout << 1 << endl;\n      set<int>::iterator it = s3.begin();\n      cout << *it << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Binary_Search_3 {\n\n\tInputStream is;\n\tPrintWriter out;\n\tint n;\n\tlong a[];\n\n\tvoid solve() {\n\t\tint n = ni();\n\t\tint l = ni();\n\t\tint x = ni();\n\t\tint y = ni();\n\t\tint a[] = na(n);\n\t\tint c1 = 0;\n\t\tint c2 = 0;\n\t\tTreeSet<Integer> hs1 = new TreeSet<>();\n\t\tTreeSet<Integer> hs2 = new TreeSet<>();\n\t\tint ans = -1;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] - x >= 0) {\n\t\t\t\tindex = Arrays.binarySearch(a, Math.abs(a[i] - x));\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t} else {\n\t\t\t\t\ths1.add(a[i] - x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] + x <= l) {\n\t\t\t\tindex = Arrays.binarySearch(a, a[i] + x);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t} else {\n\t\t\t\t\ths1.add(a[i] + x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] - y >= 0) {\n\t\t\t\tindex = Arrays.binarySearch(a, Math.abs(a[i] - y));\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tc2++;\n\t\t\t\t} else {\n\t\t\t\t\ths2.add(a[i] - y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] + y <= l) {\n\t\t\t\tindex = Arrays.binarySearch(a, a[i] + y);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tc2++;\n\t\t\t\t} else {\n\t\t\t\t\ths2.add(a[i] + y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c1 > 0 && c2 > 0) {\n\t\t\tout.println(0);\n\t\t} else if (c1 > 0) {\n\t\t\tout.println(1 + \"\\n\" + y);\n\t\t} else if (c2 > 0) {\n\t\t\tout.println(1 + \"\\n\" + x);\n\t\t} else {\n\t\t\tint temp = -1;\n\t\t\tfor (int i : hs1) {\n\t\t\t\tif (hs2.contains(i)) {\n\t\t\t\t\ttemp = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp >= 0) {\n\t\t\t\tout.println(1 + \"\\n\" + temp);\n\t\t\t} else {\n\t\t\t\tout.println(2 + \"\\n\" + x + \" \" + y);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run() throws Exception {\n\t\tString INPUT = \"C:\\\\Users\\\\DHAVAL\\\\Desktop\\\\input.txt\";\n\t\tis = oj ? System.in : new FileInputStream(INPUT);\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tnew Binary_Search_3().run();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        tk = new StringTokenizer(in.readLine());\n        int n = parseInt(tk.nextToken()),l = parseInt(tk.nextToken()),x = parseInt(tk.nextToken()),y = parseInt(tk.nextToken());\n        \n        int f = 0;\n        int [] a = new int[n];\n        Set<Integer> s = new HashSet<>();\n        tk = new StringTokenizer(in.readLine());\n        for(int i=0; i<n; i++) {\n            a[i] = parseInt(tk.nextToken());\n            s.add(a[i]);\n        }\n        \n        int t1 = 0,t2 = 0;\n        for(int i=0; i<n; i++) {\n            if(s.contains(a[i]+x) || s.contains(a[i]-x)) t1 = 1;\n            if(s.contains(a[i]+y) || s.contains(a[i]-y)) t2 = 1;\n        }\n        \n        f = t1+t2;\n        \n        if(f==2) {\n            System.out.println(\"0\");\n            return;\n        } else {\n            for(int i=0; i<n; i++) {\n                if(s.contains(a[i]+x) || s.contains(a[i]-x)) {\n                    System.out.printf(\"1\\n%d\\n\",y);\n                    return;\n                } else if(s.contains(a[i]+y) || s.contains(a[i]-y)) {\n                    System.out.printf(\"1\\n%d\\n\",x);\n                    return;\n                } else {\n                    if((s.contains(a[i]+x+y) || s.contains(a[i]+x-y)) && (a[i]+x<=l)) {\n                        System.out.printf(\"1\\n%d\\n\",a[i]+x);\n                        return;\n                    }\n                    \n                    if((s.contains(a[i]-x-y) || s.contains(a[i]-x+y)) && a[i]-x>=0) {\n                        System.out.printf(\"1\\n%d\\n\",a[i]-x);\n                        return;\n                    }\n                }\n            }\n        }\n        \n        System.out.printf(\"2\\n%d %d\\n\",x,y);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintStream;\nimport java.util.Scanner;\n\n/**\n * @author Roman Elizarov\n */\npublic class Round_274_B {\n\tpublic static void main(String[] args) {\n\t\tnew Round_274_B().go();\n\t}\n\n\tint n;\n\tint l;\n\tint x;\n\tint y;\n\tint[] a;\n\n\tvoid go() {\n\t\t// read input\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\tl = in.nextInt();\n\t\tx = in.nextInt();\n\t\ty = in.nextInt();\n\t\ta = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = in.nextInt();\n\t\tassert a[0] == 0;\n\t\tassert a[n - 1] == l;\n\n\t\t// solve\n\t\tint[] result = solve();\n\n\t\t// write result\n\t\tPrintStream out = System.out;\n\t\tout.println(result.length);\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(result[i]);\n\t\t}\n\t}\n\n\tint[] solve() {\n\t\tboolean hasX = findFirst(x) >= 0;\n\t\tboolean hasY = findFirst(y) >= 0;\n\t\tif (hasX && hasY)\n\t\t\treturn new int[] {};\n\t\tif (hasX)\n\t\t\treturn new int[] { y };\n\t\tif (hasY)\n\t\t\treturn new int[] { x };\n\t\tint i = findFirst(x + y);\n\t\tif (i >= 0)\n\t\t\treturn new int[] { a[i] + x };\n\t\ti = findFirst(y - x);\n\t\tif (i >= 0 && a[i] + y <= l)\n\t\t\treturn new int[]{a[i] + y};\n\t\ti = findLast(y - x);\n\t\tif (i >= 0 && a[i] - x >= 0)\n\t\t\treturn new int[]{a[i] - x};\n\t\treturn new int[] { x, y };\n\t}\n\n\tint findFirst(int x) {\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tif (findAt(x, k))\n\t\t\t\treturn k;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint findLast(int x) {\n\t\tfor (int k = n; --k >= 0;) {\n\t\t\tif (findAt(x, k))\n\t\t\t\treturn k;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean findAt(int x, int k) {\n\t\tint g = a[k] + x;\n\t\tint i = k;\n\t\tint j = n - 1;\n\t\twhile (i <= j) {\n\t\t\tint m = (i + j) / 2;\n\t\t\tif (g > a[m])\n\t\t\t\ti = m + 1;\n\t\t\telse if (g < a[m])\n\t\t\t\tj = m - 1;\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, x, y, l;\n  cin >> n >> l >> x >> y;\n  set<long long> lin;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    lin.insert(a[i]);\n  }\n  int fl1 = 0;\n  set<long long> boy;\n  for (int i = 0; i < n; i++) {\n    long long p1 = a[i] - x;\n    long long p2 = a[i] + x;\n    if (p1 >= 0) {\n      if (lin.find(p1) != lin.end()) fl1 = 1;\n      boy.insert(p1);\n    }\n    if (p2 <= l) {\n      if (lin.find(p2) != lin.end()) fl1 = 1;\n      boy.insert(p2);\n    }\n  }\n  int fl2 = 0;\n  set<long long> girl;\n  for (int i = 0; i < n; i++) {\n    long long p1 = a[i] - y;\n    long long p2 = a[i] + y;\n    if (p1 >= 0) {\n      if (lin.find(p1) != lin.end()) fl2 = 1;\n      girl.insert(p1);\n    }\n    if (p2 <= l) {\n      if (lin.find(p2) != lin.end()) fl2 = 1;\n      girl.insert(p2);\n    }\n  }\n  if ((fl1 == 0) && (fl2 == 1)) {\n    set<long long>::iterator it = boy.begin();\n    cout << 1 << endl << *it << endl;\n    return 0;\n  }\n  if ((fl1 == 1) && (fl2 == 0)) {\n    set<long long>::iterator it = girl.begin();\n    cout << 1 << endl << *it << endl;\n    return 0;\n  }\n  if ((fl1 == 1) && (fl2 == 1)) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (set<long long>::iterator it = boy.begin(); it != boy.end(); ++it) {\n    if (girl.find(*it) != girl.end()) {\n      cout << 1 << endl << *it << endl;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  set<long long>::iterator it = girl.begin();\n  cout << *it << \" \";\n  set<long long>::iterator it2 = boy.begin();\n  cout << *it2 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[110000];\nint n, l, x, y, ok;\nint p1, p2, p3, p4;\nint sc(int s) {\n  int i = 1;\n  for (int j = 2; j <= n; j++) {\n    while (a[j] - a[i] > s) i++;\n    if (a[j] - a[i] == s) return a[i];\n  }\n  return -1;\n}\nvoid sc2(int s) {\n  int i = 1;\n  for (int j = 2; j <= n; j++) {\n    while (a[j] - a[i] > s) i++;\n    if (a[j] - a[i] == s) {\n      p4 = a[i];\n      if (p4 + y <= l || p4 - x >= 0) {\n        return;\n      }\n    }\n  }\n  p4 = -1;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  p1 = sc(x);\n  p2 = sc(y);\n  p3 = sc(x + y);\n  sc2(y - x);\n  if (p1 != -1 && p2 != -1)\n    printf(\"0\\n\");\n  else {\n    if (p1 != -1) {\n      printf(\"1\\n%d\\n\", y);\n    } else if (p2 != -1) {\n      printf(\"1\\n%d\\n\", x);\n    } else if (p3 != -1) {\n      puts(\"1\");\n      printf(\"%d\\n\", p3 + x);\n    } else if (p4 != -1) {\n      if (p4 + y <= l) {\n        puts(\"1\");\n        printf(\"%d\\n\", p4 + y);\n      } else if (p4 - x >= 0) {\n        puts(\"1\");\n        printf(\"%d\\n\", p4 - x);\n      } else {\n        printf(\"2\\n%d %d\\n\", x, y);\n      }\n    } else\n      printf(\"2\\n%d %d\\n\", x, y);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n    private static StringTokenizer st;\n    private static BufferedReader br;\n    public static long MOD = 1000000007;\n    public static long tenFive = 100000;\n\n    public static void print(Object x) {\n        System.out.println(x + \"\");\n    }\n    public static String join(List<?> x, String space) {\n        StringBuilder sb = new StringBuilder();\n        for (Object elt : x) {\n            sb.append(elt);\n            sb.append(space);\n        }\n        return sb.toString();\n    }\n\n    public static String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String line = br.readLine();\n            st = new StringTokenizer(line.trim());\n        }\n        return st.nextToken();\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public static List<Integer> nextInts(int N) throws IOException {\n        List<Integer> ret = new ArrayList<Integer>();\n        for (int i = 0; i < N; i++) {\n            ret.add(nextInt() - 1);\n        }\n        return ret;\n    }\n\n    public static boolean isMeasured(Set<Long> dists, long d) {\n        for (long dist : dists) {\n            if (dists.contains(dist + d)) return true;\n        }\n        return false;\n    }\n\n    public static Set<Long> marksFor(Set<Long> dists, long d) {\n        Set<Long> nextMarks = new HashSet<Long>();\n        for (long dist : dists) {\n            nextMarks.add(dist + d);\n            nextMarks.add(dist - d);\n        }\n        return nextMarks;\n    }\n\n    public static void solve(Set<Long> dists, long x, long y, long l) {\n        boolean hasX = isMeasured(dists, x);\n        boolean hasY = isMeasured(dists, y);\n        if (hasX && hasY) {\n            print(0);\n        } else if (hasX) {\n            print(1);\n            print(y);\n        } else if (hasY) {\n            print(1);\n            print(x);\n        } else {\n            Set<Long> xMarks = marksFor(dists, x);\n            Set<Long> yMarks = marksFor(dists, y);\n            for (long mark : xMarks) {\n                if (yMarks.contains(mark) && mark >= 0 && mark <= l) {\n                    print(1);\n                    print(mark);\n                    return;\n                }\n            }\n            print(2);\n            print(x);\n            print(y);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = nextInt();\n        long l = nextInt();\n        long x = nextInt();\n        long y = nextInt();\n        Set<Long> dists = new HashSet<Long>();\n        for (int i = 0; i < n; i++) {\n            dists.add(nextLong());\n        }\n        solve(dists, x, y, l);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main\n{\n\n    public static void main(String[] args) throws IOException\n    {\n        FastScanner input = new FastScanner();\n        int n;\n        long l, x, y;\n        n = input.nextInt();\n        l = input.nextLong();\n        x = input.nextLong();\n        y = input.nextLong();\n        TreeSet<Long> set = new TreeSet<>();\n        Long a[] = new Long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = input.nextLong();\n            set.add(a[i]);\n        }\n        int one = 0, two = 0;\n        for (int i = 0; i < n; i++) {\n            if (set.contains(a[i] + x) || set.contains(a[i] - x)) {\n                one = 1;\n            }\n            if (set.contains(a[i] + y) || set.contains(a[i] - y)) {\n                two = 1;\n            }\n        }\n        if (one + two == 2) {\n            System.out.println(\"0\");\n        } else {\n            for (int i = 0; i < n; i++) {\n                if (set.contains(a[i] + x) || set.contains(a[i] - x)) {\n                    System.out.println(\"1\");\n                    System.out.println(y);\n                    return;\n                }\n                else if(set.contains(a[i]+y)||set.contains(a[i]-y))\n                {\n                    System.out.println(\"1\");\n                    System.out.println(x);\n                    return;\n                }\n                else if(set.contains(a[i]+x+y)||(set.contains(a[i]+x-y)&&a[i]+x<=l))\n                {\n                    System.out.println(\"1\");\n                    System.out.println(a[i]+x);\n                    return ;\n                }\n                else if(set.contains(a[i]-x-y)||(set.contains(a[i]+y-x)&&a[i]-x>=0))\n                {\n                    System.out.println(1);\n                    System.out.println(a[i]-x);\n                    return;\n                }\n            }\n            System.out.println(\"2\");\n            System.out.println(x+\" \"+y);\n        }\n\n    }\n\n    static class FastScanner\n    {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next()\n        {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n}\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y = map(int,raw_input().split())\nmarks = {x : 1 for x in map(int,raw_input().split())}\n\nfound = [False,False]\nfor s in marks:\n    if (x+s) in marks:\n        found[0] = True\n    if (y+s) in marks:\n        found[1] = True\n\ndef find_one(target,l):\n    ans = set()\n    for s in marks:\n        if (s+target) <= l:\n            ans.add(s+target)\n        if (s-target) >= 0:\n            ans.add(s-target)\n    return ans\n\ndef find_two(x,y,l):\n    #find a number before or after it there x and y\n    for s in marks:\n        if (s+x) <= l and (s+y) <= l:\n            return ((s+x),(s+y))\n        if (s+x) <= l and (s-y) >= 0:\n            return ((s+x),(s-y))\n        if (s-x) >= 0 and (s+y) <= l:\n            return ((s-x),(s+y))\n        if (s-y) >= 0 and (s-y) >= 0:\n            return ((s-x),(s-y))\n\n\n\nif all(found):\n    print \"0\"\nelif found[0] or found[1]:\n    target = y if found[0] else x\n    ans = find_one(target,l)\n    t = 0\n    if ans != set():\n        t = list(ans)[0]\n    else:  t = -1\n    if t != -1:\n        print \"1\"\n        print t\n    else :\n        print \"2\"\n        print \"0 %d\" %target\nelse:\n    right = find_one(x,l)\n    left = find_one(y,l)\n    intersect = right & left\n    if intersect != set():\n        print \"1\"\n        print list(intersect)[0]\n    else:\n        ans = find_two(x,y,l)\n        if ans != None:\n            print \"2\"\n            print \"%d %d\" %(ans[0],ans[1])\n        else:\n            print \"3\"\n            print \"0 %d %d\" %(x,y)\n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, flaga, flagb, sc;\nlong long l, x, y, ans;\nlong long a[200000];\nmap<long long, int> bo;\nint main() {\n  scanf(\"%d %lld %lld %lld\", &n, &l, &x, &y);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    bo[a[i]] = 1;\n  }\n  for (i = 0; i < n; i++) {\n    if (bo[a[i] + x] == 1) flaga = 1;\n    if (bo[a[i] + y] == 1) flagb = 1;\n  }\n  if (flaga == 1 && flagb == 1) printf(\"0\\n\");\n  if (flaga == 1 && flagb == 0) {\n    printf(\"1\\n%lld\\n\", y);\n  }\n  if (flagb == 1 && flaga == 0) {\n    printf(\"1\\n%lld\\n\", x);\n  }\n  if (flaga == 0 && flagb == 0) {\n    for (i = 0; i < n; i++) {\n      if (bo[a[i] - x + y] == 1 && a[i] - x >= 0) {\n        printf(\"1\\n%lld\\n\", a[i] - x);\n        sc = 1;\n        break;\n      }\n      if (bo[a[i] + x - y] == 1 && a[i] + x <= l) {\n        printf(\"1\\n%lld\\n\", a[i] + x);\n        sc = 1;\n        break;\n      }\n      if (bo[a[i] - y + x] == 1 && a[i] - y >= l) {\n        printf(\"1\\n%lld\\n\", a[i] - y);\n        sc = 1;\n        break;\n      }\n      if (bo[a[i] + y - x] == 1 && a[i] + y <= l) {\n        printf(\"1\\n%lld\\n\", a[i] + y);\n        sc = 1;\n        break;\n      }\n      if (bo[a[i] + x + y] == 1) {\n        printf(\"1\\n%lld\\n\", a[i] + x);\n        sc = 1;\n        break;\n      }\n      if (bo[a[i] - x - y] == 1) {\n        printf(\"1\\n%lld\\n\", a[i] - x);\n        sc = 1;\n        break;\n      }\n    }\n    if (sc != 1) printf(\"2\\n%lld %lld\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y, ai;\n  cin >> n >> l >> x >> y;\n  set<int> a;\n  for (int i = 0; i < n; i++) {\n    cin >> ai;\n    a.insert(ai);\n  }\n  bool fx = false, fy = false;\n  int c = -1, q = -1;\n  for (set<int>::const_iterator it = a.begin(); it != a.end(); it++) {\n    int val = *it;\n    if (!fx && a.find(val + x) != a.end()) fx = true;\n    if (!fy && a.find(val + y) != a.end()) fy = true;\n    if (c == -1 && a.find(val + x + y) != a.end()) c = val;\n    if (q == -1 && a.find(val + y - x) != a.end() &&\n        (val - x >= 0 || val + y <= l))\n      q = val;\n  }\n  bool z = true;\n  if (fx && fy)\n    cout << 0 << endl;\n  else if (fx ^ fy) {\n    cout << 1 << endl;\n    cout << (fx ? y : x) << endl;\n  } else {\n    if (c != -1) {\n      cout << 1 << endl;\n      cout << (c + x) << endl;\n    } else if (q != -1) {\n      if (q - x >= 0) {\n        cout << 1 << endl;\n        cout << (q - x) << endl;\n      } else if (q + y <= l) {\n        cout << 1 << endl;\n        cout << (q + y) << endl;\n      } else\n        z = false;\n    } else\n      z = false;\n  }\n  if (!z) {\n    cout << 2 << endl;\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> s;\nint n, l, x, y;\nvoid solve() {\n  bool a = false, b = false;\n  for (int i = 0; i < n; i++)\n    if (lower_bound(s.begin(), s.end(), x + s[i]) != s.end())\n      if (*lower_bound(s.begin(), s.end(), x + s[i]) - s[i] == x) a = true;\n  for (int i = 0; i < n; i++)\n    if (lower_bound(s.begin(), s.end(), y + s[i]) != s.end())\n      if (*lower_bound(s.begin(), s.end(), y + s[i]) - s[i] == y) b = true;\n  if (a and !b) {\n    cout << 1 << endl << y << endl;\n    return;\n  };\n  if (b and !a) {\n    cout << 1 << endl << x << endl;\n    return;\n  };\n  if (a and b) {\n    cout << 0 << endl;\n    return;\n  }\n  for (int i = 0; i < n; i++)\n    if (lower_bound(s.begin(), s.end(), x + y + s[i]) != s.end())\n      if (*lower_bound(s.begin(), s.end(), x + y + s[i]) - s[i] == x + y) {\n        cout << 1 << endl;\n        cout << s[i] + x << endl;\n        return;\n      }\n  for (int i = 0; i < n; i++)\n    if (lower_bound(s.begin(), s.end(), max(x - y, y - x) + s[i]) != s.end())\n      if (*lower_bound(s.begin(), s.end(), max(x - y, y - x) + s[i]) - s[i] ==\n          max(x - y, y - x)) {\n        if (s[i] + max(x, y) <= l) {\n          cout << 1 << endl;\n          cout << s[i] + max(x, y) << endl;\n          return;\n        }\n        if (s[i] - min(x, y) >= 0) {\n          cout << 1 << endl;\n          cout << s[i] - min(x, y) << endl;\n          return;\n        }\n      }\n  cout << 2 << endl;\n  cout << x << \" \" << y << endl;\n  return;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    s.push_back(a);\n  }\n  solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class LongJump {\n  \n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    int noOfMarks = sc.nextInt();\n    long maxLength = sc.nextLong();\n    long girlPass = sc.nextLong(); \n    long boyPass = sc.nextLong();\n    long[] marks = new long[noOfMarks];\n    boolean girlSat = false;\n    boolean boySat = false;\n    \n    //Set markings\n    for(int i = 0; i < noOfMarks; i++) {\n      long in = sc.nextLong();\n      marks[i] = in;\n    }\n    \n    //We start from the first mark and find if we can satisfy\n    for(int j = 0; j < noOfMarks; j++) {\n      //From this point, check for girls first:\n      if(marks[j] == girlPass || ((marks[j] - girlPass > 0) && binarySearch(marks,(marks[j] - girlPass)) != -1) || (marks[j] + girlPass <= maxLength && binarySearch(marks,(marks[j] + girlPass)) != -1 )){\n        girlSat |= true;\n      }\n      //Check boys\n      if(marks[j] == boyPass || ((marks[j] - boyPass > 0) && binarySearch(marks,(marks[j] - boyPass)) != -1) || (marks[j] + boyPass <= maxLength && binarySearch(marks,(marks[j] + boyPass)) != -1 )){\n        boySat |= true;\n      }\n      \n      //If both satisfied, break out\n      if(boySat && girlSat) {\n        break;\n      }\n    }\n    \n    if(boySat && girlSat) {\n      System.out.println(0); \n    }else if(boySat && !girlSat) {\n      System.out.println(1);\n      System.out.println(girlPass);\n    }else if(!boySat && girlSat) {\n      System.out.println(1);\n      System.out.println(boyPass);\n    }else{\n      //Important: Determine if we just need 1 additional point, or 2\n      //At this point, we know that all ranges from each mark does not originally exist, but if we add, can we kill 2 birds with 1 stone?\n      for(int k = 0; k < noOfMarks; k++) {\n        //We set a mark here\n        long markLeftGirl = marks[k] - girlPass;\n        long markRightGirl = marks[k] + girlPass;\n        long markLeftBoy = marks[k] - boyPass;\n        long markRightBoy = marks[k] + boyPass;\n        long markLeftGirlLeftBoy = marks[k] - girlPass - boyPass;\n        long markLeftGirlRightBoy = marks[k] - girlPass + boyPass;\n        long markRightGirlLeftBoy = marks[k] + girlPass - boyPass;\n        long markRightGirlRightBoy = marks[k] + girlPass + boyPass;\n    \n        //Left marker (Girl) + Left Left marker (Boy) / Left Right marker (Boy)\n        if((markLeftGirl > 0) && ((binarySearch(marks, markLeftGirlLeftBoy) != -1) || (binarySearch(marks, markLeftGirlRightBoy) != -1))){\n          boySat |= true;\n          girlSat |= true;\n          System.out.println(1);\n          System.out.println(markLeftGirl);\n          break;\n        }\n        //Right marker (Girl) + Right Left marker (Boy) / Right Right marker (Boy)\n        if((markRightGirl <= maxLength) && ((binarySearch(marks, markRightGirlLeftBoy) != -1) || (binarySearch(marks, markRightGirlRightBoy) != -1))){\n          boySat |= true;\n          girlSat |= true;\n          System.out.println(1);\n          System.out.println(markRightGirl);\n          break;\n        }\n        //Left marker (Boy) + Left Left marker (girl) / Left Right marker (girl)\n        if((markLeftBoy > 0) && ((binarySearch(marks, markLeftGirlLeftBoy) != -1) || (binarySearch(marks, markRightGirlLeftBoy) != -1))){\n          boySat |= true;\n          girlSat |= true;\n          System.out.println(1);\n          System.out.println(markLeftBoy);         \n          break;\n        }\n        //Right marker (Girl) + Right Left marker (Boy) / Right Right marker (Boy)\n        if((markRightBoy <= maxLength) && ((binarySearch(marks, markRightGirlRightBoy) != -1) || (binarySearch(marks, markLeftGirlRightBoy) != -1))){\n          boySat |= true;\n          girlSat |= true;\n          System.out.println(1);\n          System.out.println(markRightBoy);\n          break;\n        }\n      }\n      \n      if(!boySat && !girlSat) {\n        System.out.println(2);\n        System.out.println(girlPass+\" \"+boyPass);\n      }\n    }\n    \n    sc.close();\n  }\n  \n  public static int binarySearch(long[] input, long goal) {\n   int min = 0;\n   int max = input.length - 1;\n   int mid = 0;\n   \n   while(min <= max) {\n     mid = min + (max - min) / 2;\n     \n     if(goal < input[mid]) {\n       max = mid - 1;\n     }else if(goal > input[mid]) {\n       min = mid + 1;\n     }else {\n       //Found\n       return mid;\n     }\n   }\n   return -1;\n }\n  \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> Map;\nint a[100100], n, X, Y;\nint L;\nint judge0() {\n  int f0(0), f1(0);\n  for (int(i) = (1), (_end_) = (n); (i) <= (_end_); ++(i)) {\n    if (Map.count(a[i] - X) || Map.count(a[i] + X)) f0 = 1;\n    if (Map.count(a[i] - Y) || Map.count(a[i] + Y)) f1 = 1;\n  }\n  return f0 * 2 + f1;\n}\nint judge1() {\n  for (int(i) = (1), (_end_) = (n); (i) <= (_end_); ++(i)) {\n    if (a[i] + X <= L && Map.count(a[i] + X - Y)) return a[i] + X;\n    if (a[i] + Y <= L && Map.count(a[i] + Y - X)) return a[i] + Y;\n    if (a[i] - X >= 0 && Map.count(a[i] - X + Y)) return a[i] - X;\n    if (a[i] - Y >= 0 && Map.count(a[i] - Y + X)) return a[i] - Y;\n    if (Map.count(a[i] + X + Y)) return a[i] + X;\n    if (Map.count(a[i] - X - Y)) return a[i] - X;\n  }\n  return -1;\n}\nint main() {\n  int m;\n  scanf(\"%d%d%d%d\", &n, &L, &X, &Y);\n  for (int(i) = (1), (_end_) = (n); (i) <= (_end_); ++(i)) {\n    scanf(\"%d\", &a[i]);\n    Map[a[i]] = 1;\n  }\n  if ((m = judge0())) {\n    if (m == 3) printf(\"0\\n\");\n    if (m == 1) printf(\"1\\n%d\\n\", X);\n    if (m == 2) printf(\"1\\n%d\\n\", Y);\n  } else if ((m = judge1()) != -1)\n    printf(\"%d\\n%d\\n\", 1, m);\n  else\n    printf(\"2\\n%d %d\\n\", X, Y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = (int)1e6;\nconst int inf = (int)2e9;\nconst double eps = 1e-9;\nconst int mod = (int)1e9 + 7;\nint n, l, x, y, a[maxn], ok1, ok2;\nmap<int, int> was;\nbool check(int v) {\n  if (v >= 0 && v <= l && (was.count(v - x) || was.count(v + x) || ok1) &&\n      (ok2 || was.count(v - y) || was.count(v + y)))\n    return true;\n  return false;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    if (was.count(a[i] - x)) ok1 = true;\n    if (was.count(a[i] - y)) ok2 = true;\n    was[a[i]] = true;\n  }\n  if (ok1 && ok2) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (check(a[i] - x)) {\n      puts(\"1\");\n      cout << a[i] - x << '\\n';\n      return 0;\n    }\n    if (check(a[i] - y)) {\n      puts(\"1\");\n      cout << a[i] - y << '\\n';\n      return 0;\n    }\n    if (check(a[i] + x)) {\n      puts(\"1\");\n      cout << a[i] + x << '\\n';\n      return 0;\n    }\n    if (check(a[i] + y)) {\n      puts(\"1\");\n      cout << a[i] + y << '\\n';\n      return 0;\n    }\n  }\n  puts(\"2\");\n  cout << x << ' ' << y << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "\"\"\"Template for Python Competitive Programmers prepared by Mayank Chaudhary \"\"\"\n\n#to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\n# def prepare_factorial():\n#     fact = [1]\n#     for i in range(1, 1000005):\n#         fact.append((fact[-1] * i) % mod)\n#     ifact = [0] * 1000005\n#     ifact[1000004] = pow(fact[1000004], mod - 2, mod)\n#     for i in range(1000004, 0, -1):\n#         ifact[i - 1] = (i * ifact[i]) % mod\n#\n#     return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\n# import threading\n# threading.stack_size(2**27)\nimport sys\n# sys.setrecursionlimit(30000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\n# from bisect import bisect_left, bisect_right, insort\n# import itertools\n# from math import floor, ceil, sqrt, degrees, atan, pi\n# from heapq import heappop, heapify, heappush\n# from random import randint as rn\n# from Queue import Queue as Q\nfrom collections import Counter, defaultdict, deque\n\n'''\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'''\n\n\n# def ncr(n, r,  fact, ifact):  # for using this uncomment the lines calculating fact and ifact\n#     t = (fact[n] * (ifact[r]*ifact[n-r]) % mod)% mod\n#     return t\n\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\ndef GCD(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(GCD(x, y))\n\n# def get_xor(n):\n#     return [n,1,n+1,0][n%4]\n\n# def binary_expo(a, b):\n#\n#     result = 1\n#     while b:\n#         if b&1:\n#             result *= a\n#             b-=1\n#         else:\n#             a *= a\n#             b >>= 1\n#     return result\n\n\n\n\"\"\"*******************************************************\"\"\"\n\n\ndef main():\n\n    def check(myset, d):\n        return any(i+d in myset for i in myset)\n\n    n, l, x, y = get_ints()\n    Arr = get_array()\n\n    myset = set(Arr)\n\n    check_x = check(myset, x)\n    check_y = check(myset, y)\n\n    if check_x and check_y:\n        print(0)\n    elif check_x:\n        print(1)\n        print(y)\n    elif check_y:\n        print(1)\n        print(x)\n    else:\n        for i in myset:\n            if (i+x+y) in myset:\n                print(1)\n                print(i+x)\n                break\n            elif (i+x-y) in myset:\n                if 0<i+x<l:\n                    print(1)\n                    print(i+x)\n                    break\n                elif 0<i-y<l:\n                    print(1)\n                    print(i-y)\n                    break\n        else:\n            print(2)\n            print(x, y)\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = ~0U >> 1;\nconst long long INF = ~0ULL >> 1;\ntemplate <class T>\ninline void read(T &n) {\n  char c;\n  for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar())\n    ;\n  n = c - '0';\n  for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';\n}\nint Pow(int base, int n, int mo) {\n  if (n == 0) return 1;\n  if (n == 1) return base % mo;\n  int tmp = Pow(base, n >> 1, mo);\n  tmp = (long long)tmp * tmp % mo;\n  if (n & 1) tmp = (long long)tmp * base % mo;\n  return tmp;\n}\nint n;\nlong long l, x, y, a[200000];\nmap<long long, int> b;\nint main() {\n  scanf(\"%d%I64d%I64d%I64d\", &n, &l, &x, &y);\n  if (x > y) swap(x, y);\n  for (int i = (1); i <= (n); ++i) scanf(\"%I64d\", &a[i]), b[a[i]] = 1;\n  int f1 = 0, f2 = 0;\n  for (int i = (1); i <= (n); ++i) {\n    if (b[a[i] - x] || b[a[i] + x]) f1 = 1;\n    if (b[a[i] - y] || b[a[i] + y]) f2 = 1;\n  }\n  if (f1 && f2) {\n    puts(\"0\");\n    return 0;\n  }\n  if (f1 || f2) {\n    if (!f1) {\n      puts(\"1\");\n      printf(\"%I64d\\n\", x);\n    } else {\n      puts(\"1\");\n      printf(\"%I64d\\n\", y);\n    }\n    return 0;\n  } else {\n    for (int i = (1); i <= (n); ++i) {\n      if (b[a[i] + x + y]) {\n        puts(\"1\");\n        printf(\"%I64d\\n\", a[i] + x);\n        return 0;\n      }\n    }\n    for (int i = (1); i <= (n); ++i) {\n      long long ans = a[i] + y;\n      if (ans <= l) {\n        if (b[ans - x]) {\n          puts(\"1\");\n          printf(\"%I64d\\n\", ans);\n          return 0;\n        }\n      }\n      ans = a[i] - x;\n      if (ans >= 0) {\n        if (b[ans + y]) {\n          puts(\"1\");\n          printf(\"%I64d\\n\", ans);\n          return 0;\n        }\n      }\n    }\n  }\n  puts(\"2\");\n  printf(\"%I64d %I64d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class LongJumps {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer str=new StringTokenizer(reader.readLine());\n\t\tint n=Integer.parseInt(str.nextToken());\n\t\tint l=Integer.parseInt(str.nextToken());\n\t\tint x=Integer.parseInt(str.nextToken());\n\t\tint y=Integer.parseInt(str.nextToken());\n\t\tstr=new StringTokenizer(reader.readLine());\n\t\tint[] arr=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tarr[i]=Integer.parseInt(str.nextToken());\n\t\t}\n\t\tStringBuilder s=new StringBuilder();\n\t\tint count=0;\n\t\tif(!find(arr, x)){\n\t\t\ts.append(x+\" \");\n\t\t\tcount++;\n\t\t}\n\t\tif(!find(arr, y)){\n\t\t\ts.append(y+\" \");\n\t\t\tcount++;\n\t\t}\n\t\tif(count==2){\n\touter : for(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint loc[]={arr[i]+x, arr[i]-x, arr[i]+x, arr[i]-x, arr[i]+y, arr[i]-y, arr[i]+y, arr[i]-y,};\n\t\t\t\tint add[]={y, y, -y, -y, x, x, -x, -x};\n\t\t\t\tfor(int j=0;j<8;j++)\n\t\t\t\t{\n\t\t\t\t\tif(loc[j]>=0 && loc[j]<=l && Arrays.binarySearch(arr,loc[j]+add[j])>=0){\n\t\t\t\t\t\ts.setLength(0);\n\t\t\t\t\t\tcount=1;\n\t\t\t\t\t\ts.append(loc[j]);\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\tSystem.out.println(count);\n\t\tSystem.out.println(s);\n\t}\n\n\tprivate static boolean find(int[] arr, int x) {\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tif(Arrays.binarySearch(arr, arr[i]-x)>=0 || Arrays.binarySearch(arr, arr[i]+x)>=0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(\n\t\t\t\tnew BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(System.in), 32768));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tRoutine routine = new Routine();\n\t\troutine.run(in, out);\n\t\tout.flush();\n\t}\n}\n\nclass Routine {\n\tint n, l, x, y;\n\tint[] as = new int[200_005];\n\t\n\tpublic void run(Scanner in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tl = in.nextInt();\n\t\tx = in.nextInt();\n\t\ty = in.nextInt();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tint mask = 3;\n\t\t\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tset.add(as[i]);\n\t\t\tif (set.contains(as[i]-x)) {\n\t\t\t\tmask &= ~1;\n\t\t\t}\n\t\t\tif (set.contains(as[i]-y)) {\n\t\t\t\tmask &= ~2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (mask == 0) {\n\t\t\tout.println(0);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 1) {\n\t\t\tout.println(1);\n\t\t\tout.println(x);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif (mask == 2) {\n\t\t\tout.println(1);\n\t\t\tout.println(y);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set.contains(as[i]-(x+y))) {\n\t\t\t\tout.println(1);\n\t\t\t\tout.println(as[i]-x);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\t\n\t\t\tif (set.contains(as[i]-(y-x))) {\n\t\t\t\tif (as[i]+x <= l) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]+x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (as[i]-(y-x)-x >= 0) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t\tout.println(as[i]-(y-x)-x);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(2);\n\t\tout.println(x+\" \"+y);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n/**\n *\n * @author Saju\n *\n */\n\npublic class Main {\n\n    private static int dx[] = { 1, 0, -1, 0 };\n    private static int dy[] = { 0, -1, 0, 1 };\n\n    private static final long INF = Long.MAX_VALUE;\n    private static final int INT_INF = Integer.MAX_VALUE;\n    private static final long NEG_INF = Long.MIN_VALUE;\n    private static final int NEG_INT_INF = Integer.MIN_VALUE;\n    private static final double EPSILON = 1e-10;\n\n    private static final int MAX = 1000000007;\n    \n    private static final long MOD = 1000000007;\n\n    private static final int MAXN = 1000000000;\n    private static final int MAXA = 100007;\n    private static final int MAXLOG = 22;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tInputReader in = new InputReader(System.in);\n//\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n//         InputReader in = new InputReader(new FileInputStream(\"src/test.in\"));\n//         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"src/test.out\")));\n\n\t\t\n\t\t\n/*\n\n72 1007 442 1001\n0 26 27 64 75 82 103 110 129 133 139 147 165 176 179 200 212 227 248 252 268 276 303 306 317 327 337 344 345 380 387 402 412 433 438 500 518 525 529 531 538 543 574 582 589 600 620 645 677 695 704 725 741 771 772 787 792 803 804 805 806 822 833 882 887 896 899 926 977 984 1001 1007\n\n\n*/\n\t\t\n\t\tint n = in.nextInt();\n\t\tint l = in.nextInt();\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\t\n\t\tlong[] arr = in.nextLongArr(n);\n\t\tint cnt = 0;\n\t\t\n\t\tint upx = upperBound(arr, x);\n//\t\tSystem.out.println(upx);\n\t\tint a = -1;\n\t\tint b = -1;\n\t\tif(arr[upx] != x) {\n\t\t\tfor(int i = upx; i < n; i++) {\n\t\t\t\tlong xx = arr[i] - x;\n\t\t\t\tint upxx = upperBound(arr, xx);\n\t\t\t\tif(arr[upxx] == xx) {\n\t\t\t\t\ta = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a == -1) {\n\t\t\t\ta = x;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = -1;\n\t\t\t}\n//\t\t\tlong xx = arr[upx] - x;\n//\t\t\tint upxx = upperBound(arr, xx);\n//\t\t\tif(arr[upxx] != xx) {\n//\t\t\t\tcnt++;\n//\t\t\t\ta = x;\n//\t\t\t}\n \t\t}\n//\t\tSystem.out.println(cnt + \" \" + a);\n\t\t\n\t\tint upy = upperBound(arr, y);\n//\t\tSystem.out.println(upy);\n\t\t\n\t\tif(arr[upy] != y) {\n\t\t\t\n\t\t\tfor(int i = upy; i < n; i++) {\n\t\t\t\tlong yy = arr[i] - y;\n\t\t\t\tint upyy = upperBound(arr, yy);\n\t\t\t\tif(arr[upyy] == yy) {\n\t\t\t\t\tb = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(b == -1) {\n\t\t\t\tb = y;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = -1;\n\t\t\t}\n\t\t\t\n//\t\t\tlong yy = arr[upy] - y;\n//\t\t\tint upyy = upperBound(arr, yy);\n//\t\t\tif(arr[upyy] != yy) {\n//\t\t\t\tcnt++;\n//\t\t\t\tb = y;\n//\t\t\t}\n \t\t}\n\t\tif(cnt == 0) {\n\t\t\tout.println(\"0\");\n\t\t}\n\t\telse if(cnt == 1) {\n\t\t\tout.println(\"1\");\n\t\t\tif(a != -1) {\n\t\t\t\tout.println(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(b);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Long> set = new TreeSet<Long>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tset.add(arr[i]);\n\t\t\t\tif(arr[i] + x < l) {\n\t\t\t\t\tset.add(arr[i] + x);\n\t\t\t\t}\n\t\t\t\tif(arr[i] + y < l) {\n\t\t\t\t\tset.add(arr[i] + y);\n\t\t\t\t}\n\t\t\t\tif(arr[i] - x > 0) {\n\t\t\t\t\tset.add(arr[i] - x);\n\t\t\t\t}\n\t\t\t\tif(arr[i] - y > 0) {\n\t\t\t\t\tset.add(arr[i] - y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = -1;\n\t\t\tfor(long e : set) {\n//\t\t\t\tarr1[id++] = e;\n\t\t\t\tlong a1 = e - x;\n\t\t\t\tlong a2 = e - y;\n\t\t\t\tlong a3 = e + x;\n\t\t\t\tlong a4 = e + y;\n\t\t\t\tboolean xfound = false;\n\t\t\t\tboolean yfound = false;\n\t\t\t\tif(a1 >= 0 && a1 <= l) {\n\t\t\t\t\tint up = upperBound(arr, a1);\n\t\t\t\t\tif(arr[up] == a1) {\n\t\t\t\t\t\txfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(a2 >= 0 && a2 <= l) {\n\t\t\t\t\tint up = upperBound(arr, a2);\n\t\t\t\t\tif(arr[up] == a2) {\n\t\t\t\t\t\tyfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(!xfound && a3 >= 0 && a3 <= l) {\n\t\t\t\t\tint up = upperBound(arr, a3);\n\t\t\t\t\tif(arr[up] == a3) {\n\t\t\t\t\t\txfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!yfound && a4 >= 0 && a4 <= l) {\n\t\t\t\t\tint up = upperBound(arr, a4);\n\t\t\t\t\tif(arr[up] == a4) {\n\t\t\t\t\t\tyfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(xfound && yfound) {\n\t\t\t\t\tans = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans != -1) {\n\t\t\t\tout.println(\"1\");\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(\"2\");\n\t\t\t\tout.println(x + \" \" + y);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tin.close();\n\t\tout.flush();\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n\t\n\t\n\tprivate static int upperBound(long arr[], long num) {\n\n\t\tint start = 0;\n\t\tint end = arr.length - 1;\n\t\tint index = 0;\n\t\tint len = arr.length;\n\t\tint mid = 0;\n\t\twhile (true) {\n\t\t\tif (start > end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid = (start + end) / 2;\n\t\t\tlong val = arr[mid];\n\t\t\tif (val > num) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else if (val < num) {\n\t\t\t\tstart = mid + 1;\n\t\t\t} else {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\tif (arr[mid] < num) {\n\t\t\treturn mid + 1;\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tprivate static boolean isPalindrome(String str) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(str);\n\t\tString str1 = sb.reverse().toString();\n\t\treturn str.equals(str1);\n\t}\n\n\tprivate static String getBinaryStr(int n, int len) {\n\t\tString str = Integer.toBinaryString(n);\n\t\tint k = str.length();\n\t\tfor (int i = 1; i <= len - k; i++) {\n\t\t\tstr = \"0\" + str;\n\t\t}\n\n\t\treturn str;\n\t}\n\t\n\tprivate static String getBinaryStr(long n, int j) {\n\t\tString str = Long.toBinaryString(n);\n\t\tint k = str.length();\n\t\tfor (int i = 1; i <= j - k; i++) {\n\t\t\tstr = \"0\" + str;\n\t\t}\n\n\t\treturn str;\n\t}\n\t\n\tprivate static long modInverse(long r) {\n\t\treturn bigMod(r, MOD - 2, MOD);\n\t}\n\t\n\tprivate static long bigMod(long n, long k, long m) {\n\n        long ans = 1;\n        while (k > 0) {\n            if ((k & 1) == 1) {\n                ans = (ans * n) % m;\n            }\n            n = (n * n) % m;\n            k >>= 1;\n        }\n        return ans;\n    }\n    \n\tprivate static long ceil(long n, long x) {\n\t\tlong div = n / x;\n        if(div * x != n) {\n            div++;\n        }\n        return div;\n\t}\n\t\n    private static int ceil(int n, int x) {\n        int div = n / x;\n        if(div * x != n) {\n            div++;\n        }\n        return div;\n    }\n\n    \n    private static int abs(int x) {\n        if (x < 0) {\n            return -x;\n        }\n        return x;\n    }\n\n    private static long abs(long x) {\n        if(x < 0) {\n            return -x;\n        }\n        return x;\n    }\n\n    private static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    private static int log(long x, int base) {\n        return (int) (Math.log(x) / Math.log(base));\n    }\n\n    private static long min(long a, long b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n\n    private static int min(int a, int b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n\n    private static long max(long a, long b) {\n        if (a < b) {\n            return b;\n        }\n        return a;\n    }\n\n    private static int max(int a, int b) {\n        if (a < b) {\n            return b;\n        }\n        return a;\n    }\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n\n                }\n            } catch (IOException e) {\n                return null;\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            String line = null;\n            try {\n                tokenizer = null;\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public boolean hasNext() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (Exception e) {\n                return false;\n            }\n            return true;\n        }\n        \n        public int[] nextIntArr(int n) {\n        \tint arr[] = new int[n];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tarr[i] = nextInt();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public long[] nextLongArr(int n) {\n        \tlong arr[] = new long[n];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tarr[i] = nextLong();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public int[] nextIntArr1(int n) {\n        \tint arr[] = new int[n + 1];\n    \t\tfor(int i = 1; i <= n; i++) {\n    \t\t\tarr[i] = nextInt();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public long[] nextLongArr1(int n) {\n        \tlong arr[] = new long[n + 1];\n    \t\tfor(int i = 1; i <= n; i++) {\n    \t\t\tarr[i] = nextLong();\n    \t\t}\n    \t\treturn arr;\n        }\n       \n        public void close() {\n        \ttry {\n        \t\tif(reader != null) {\n        \t\t\treader.close();\n        \t\t}\n        \t}\n        \tcatch(Exception e) {\n        \t\t\n        \t}\n        \t\n        \t\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nint a[100005];\nset<int> b;\nint found1(int k) {\n  for (int i = 1; i <= n; i++)\n    if (b.count(a[i] - k)) return 1;\n  return 0;\n}\nint found2() {\n  for (int i = 1; i <= n; i++) {\n    if (a[i] + x <= l && (b.count(a[i] + x + y) || b.count(a[i] + x - y)))\n      return a[i] + x;\n    if (a[i] - x >= 0 && (b.count(a[i] - x + y) || b.count(a[i] - x - y)))\n      return a[i] - x;\n  }\n  return -1;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    b.insert(a[i]);\n  }\n  int a1 = 0;\n  int a2 = 0;\n  a1 = found1(x);\n  a2 = found1(y);\n  if (a1 && a2)\n    cout << \"0\" << endl;\n  else if (a1 && !a2)\n    cout << \"1\" << endl << y << endl;\n  else if (!a1 && a2)\n    cout << \"1\" << endl << x << endl;\n  else {\n    int te = found2();\n    if (te == -1)\n      cout << \"2\" << endl << x << ' ' << y << endl;\n    else\n      cout << \"1\" << endl << te << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nvoid solve() {\n  long long int n, l;\n  cin >> n >> l;\n  long long int arr[2];\n  cin >> arr[0] >> arr[1];\n  sort(arr, arr + 2);\n  set<long long int> marks;\n  for (long long int i = 0; i < n; i++) {\n    long long int x;\n    cin >> x;\n    marks.insert(x);\n  }\n  map<long long int, long long int> mpp;\n  bool flag1 = false, flag2 = false;\n  for (long long int x : marks) {\n    long long int req1 = arr[0] + x;\n    long long int req2 = x - arr[0];\n    if (req1 <= l) {\n      if (marks.count(req1))\n        flag1 = true;\n      else {\n        mpp[-req1] = 1;\n      }\n    }\n    if (req2 >= 0) {\n      if (marks.count(req2))\n        flag1 = true;\n      else\n        mpp[-req2] = 1;\n    }\n  }\n  bool flag3 = false;\n  for (long long int y : marks) {\n    long long int req1 = arr[1] + y;\n    long long int req2 = y - arr[1];\n    if (req1 <= l) {\n      if (marks.count(req1))\n        flag2 = true;\n      else if (mpp.find(-req1) != mpp.end()) {\n        mpp[-req1]++;\n        flag3 = true;\n      } else\n        mpp[req1]++;\n    }\n    if (req2 >= 0) {\n      if (marks.count(req2))\n        flag2 = true;\n      else if (mpp.find(-req2) != mpp.end()) {\n        mpp[-req2]++;\n        flag3 = true;\n      } else\n        mpp[req2]++;\n    }\n  }\n  if (flag1 && flag2)\n    cout << 0;\n  else if (!flag1 && flag2) {\n    for (auto x : mpp) {\n      if (x.first < 0) {\n        cout << 1 << \"\\n\";\n        cout << -x.first;\n        return;\n      }\n    }\n  } else if (flag1 && !flag2) {\n    for (auto x : mpp) {\n      if (x.first > 0) {\n        cout << 1 << \"\\n\";\n        cout << abs(x.first);\n        return;\n      }\n    }\n  } else {\n    if (flag3) {\n      cout << 1 << \"\\n\";\n      for (auto x : mpp) {\n        if (x.second == 2) {\n          cout << -x.first;\n          return;\n        }\n      }\n    }\n    cout << 2 << \"\\n\";\n    vector<long long int> temp;\n    for (auto x : mpp) {\n      if (x.first > 0) {\n        temp.push_back(x.first);\n        break;\n      }\n    }\n    for (auto x : mpp) {\n      if (x.first < 0) {\n        temp.push_back(-x.first);\n        break;\n      }\n    }\n    sort(temp.begin(), temp.end());\n    cout << temp[0] << \" \" << temp[1];\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100100;\nint n, a[MAXN], k;\nbool search(int x, bool ch) {\n  int e, s;\n  s = e = (ch ? n - 1 : 0);\n  for (s; (ch ? s >= 0 : s < n); (ch ? (e >= 0, s--) : (e < n, s++))) {\n    while ((ch ? e >= 0 : e < n) && abs(a[e] - a[s]) < x) (ch ? e-- : e++);\n    if ((ch ? e >= 0 : e < n) && abs(a[e] - a[s]) == x) return 1, k = e;\n  }\n  return 0;\n}\nvoid chap(int x) {\n  cout << 1 << endl << x << endl;\n  exit(0);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int x, y, l;\n  bool ch1, ch2;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  ch1 = search(x, 0);\n  ch2 = search(y, 0);\n  if (ch1 || ch2) {\n    if (ch1 ^ ch2)\n      chap((ch1 ? y : x));\n    else\n      cout << '0' << endl;\n    return 0;\n  }\n  if (search(x + y, 0)) chap(a[k] - y);\n  if (search(y - x, 0) && a[k] + x < l) chap(a[k] + x);\n  if (search(y - x, 1) && a[k] - x > 0) chap(a[k] - x);\n  cout << 2 << endl << x << endl << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v(0);\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = (0); i < (n); i++) {\n    int tmp;\n    cin >> tmp;\n    v.push_back(tmp);\n  }\n  bool isx = false, isy = false, isxpy = false, isxmy = false;\n  int xpyp = -1, xmyp = -1;\n  int fxmyp = -1;\n  int xpy = x + y, xmy = abs(x - y);\n  for (int i = (0); i < (n - 1); i++) {\n    if (binary_search(v.begin() + i, v.end(), v[i] + x)) isx = true;\n    if (binary_search(v.begin() + i, v.end(), v[i] + y)) isy = true;\n    if (binary_search(v.begin() + i, v.end(), v[i] + xpy)) {\n      isxpy = true;\n      xpyp = i;\n    }\n    if (binary_search(v.begin() + i, v.end(), v[i] + xmy)) {\n      isxmy = true;\n      xmyp = i;\n      if (fxmyp == -1) fxmyp = i;\n    }\n  }\n  if (isx && isy) {\n    cout << 0;\n    return 0;\n  }\n  if (isx || isy) {\n    if (isx) {\n      cout << 1 << ' ' << y;\n      return 0;\n    } else {\n      cout << 1 << ' ' << x;\n      return 0;\n    }\n  }\n  if (!isxpy && !isxmy) {\n    cout << 2 << ' ' << x << ' ' << y;\n    return 0;\n  }\n  if (isxpy) {\n    cout << 1 << ' ' << v[xpyp] + x;\n    return 0;\n  }\n  if (isxmy) {\n    int a = max(x, y);\n    if (v[xmyp] + a < l) {\n      cout << 1 << ' ' << v[xmyp] + a;\n      return 0;\n    } else if (v[xmyp] - a + xmy > 0) {\n      cout << 1 << ' ' << v[xmyp] - a + xmy;\n      return 0;\n    }\n    if (v[fxmyp] + a < l) {\n      cout << 1 << ' ' << v[fxmyp] + a;\n      return 0;\n    } else if (v[fxmyp] - a + xmy > 0) {\n      cout << 1 << ' ' << v[fxmyp] - a + xmy;\n      return 0;\n    } else {\n      cout << 2 << ' ' << x << ' ' << y;\n      return 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tvoid run() throws IOException {\n\t\tint n = ni(), l = ni(), x = ni(), y = ni();\n\t\tint[] p = new int[n];\n\t\tSet<Integer> q = new TreeSet<Integer>();\n\t\tSet<Integer> a = new TreeSet<Integer>();\n\t\tSet<Integer> b = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tq.add(p[i] = ni());\n\t\t}\n\n\t\tboolean fa = false;\n\t\tfor (int d : p) {\n\t\t\tif (q.contains(d + x)) {\n\t\t\t\tfa = true;\n\t\t\t}\n\n\t\t\tif (d + x <= l) {\n\t\t\t\ta.add(d + x);\n\t\t\t}\n\n\t\t\tif (0 <= d - x) {\n\t\t\t\ta.add(d - x);\n\t\t\t}\n\t\t}\n\t\tboolean fb = false;\n\t\tfor (int d : p) {\n\t\t\tif (q.contains(d + y)) {\n\t\t\t\tfb = true;\n\t\t\t}\n\n\t\t\tif (d + y <= l) {\n\t\t\t\tb.add(d + y);\n\t\t\t}\n\n\t\t\tif (0 <= d - y) {\n\t\t\t\tb.add(d - y);\n\t\t\t}\n\t\t}\n\n\t\tif (fb && fa) {\n\t\t\tpw.println(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (fa) {\n\t\t\tpw.println(1);\n\t\t\tpw.println(y);\n\t\t\treturn;\n\t\t}\n\t\tif (fb) {\n\t\t\tpw.println(1);\n\t\t\tpw.println(x);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int d : a) {\n\t\t\tif (b.contains(d)) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(d);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpw.println(2);\n\t\tpw.println(x + \" \" + y);\n\n\t}\n\n\tint[][] nm(int a_len, int a_hei) throws IOException {\n\t\tint[][] _a = new int[a_len][a_hei];\n\t\tfor (int i = 0; i < a_len; i++)\n\t\t\tfor (int j = 0; j < a_hei; j++)\n\t\t\t\t_a[i][j] = ni();\n\t\treturn _a;\n\t}\n\n\tString next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tboolean hasNext() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn true;\n\t}\n\n\tint[] na(int a_len) throws IOException {\n\t\tint[] _a = new int[a_len];\n\t\tfor (int i = 0; i < a_len; i++)\n\t\t\t_a[i] = ni();\n\t\treturn _a;\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tString nl() throws IOException {\n\t\treturn br.readLine();\n\t}\n\n\tvoid tr(String debug) {\n\t\tif (!OJ)\n\t\t\tpw.println(\" \" + debug);\n\t}\n\n\tstatic PrintWriter pw;\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic boolean OJ;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong timeout = System.currentTimeMillis();\n\t\tOJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tpw = new PrintWriter(System.out);\n\t\tbr = new BufferedReader(OJ ? new InputStreamReader(System.in) : new FileReader(new File(\"input.txt\")));\n\n\t\tif (OJ) {\n\t\t\tnew B().run();\n\t\t} else {\n\t\t\twhile (br.ready()) {\n\t\t\t\tnew B().run();\n\t\t\t\tpw.println();\n\t\t\t}\n\t\t\tpw.println(\"----------------------------------\");\n\t\t\tpw.println(System.currentTimeMillis() - timeout);\n\t\t}\n\t\tbr.close();\n\t\tpw.close();\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long l, x, y;\nvector<long long> val;\nint main() {\n  scanf(\"%d %lld %lld %lld\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    long long a;\n    scanf(\"%lld\", &a);\n    val.push_back(a);\n  }\n  bool ex = 0, ey = 0;\n  for (int i = 0; i < n; i++) {\n    if (binary_search(val.begin(), val.end(), val[i] + x)) {\n      ex = true;\n    }\n    if (binary_search(val.begin(), val.end(), val[i] + y)) {\n      ey = true;\n    }\n  }\n  if (ex && ey) {\n    puts(\"0\");\n    return 0;\n  }\n  long long a[4];\n  bool ok = false;\n  long long res = -1;\n  for (int i = 0; i < n && !ok; i++) {\n    a[0] = val[i] - x;\n    a[1] = val[i] - y;\n    a[2] = val[i] + x;\n    a[3] = val[i] + y;\n    for (int j = 0; j < 4 && !ok; j++) {\n      if (!(0 <= a[j] && a[j] <= l)) continue;\n      if (j % 2 == 0) {\n        if (binary_search(val.begin(), val.end(), a[j] - y) || ey) {\n          ok = true;\n          res = a[j];\n        }\n        if (binary_search(val.begin(), val.end(), a[j] + y) || ey) {\n          ok = true;\n          res = a[j];\n        }\n      } else {\n        if (binary_search(val.begin(), val.end(), a[j] - x) || ex) {\n          ok = true;\n          res = a[j];\n        }\n        if (binary_search(val.begin(), val.end(), a[j] + x) || ex) {\n          ok = true;\n          res = a[j];\n        }\n      }\n    }\n  }\n  if (ok) {\n    printf(\"1\\n%lld\\n\", res);\n    return 0;\n  } else {\n    printf(\"2\\n%lld %lld\\n\", x, y);\n    return 0;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class CFD479 {\npublic static void main(String args[]) {\n\tInputReader in = new InputReader(System.in);\n\t//OutputStream outputStream = System.out;\n\tPrintWriter out = new PrintWriter(System.out);\n\tint n=in.nextInt();\n\tint l=in.nextInt();\n\tint x=in.nextInt();\n\tint y=in.nextInt();\n\tint ar[]=new int[n];\n\tHashSet<Integer>hs=new HashSet<>();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tar[i]=in.nextInt();\n\t\ths.add(ar[i]);\n\t}\n\tint a=-1;int b=-1;int c=-1;\n\tint diff1=x+y;\n\tint diff2=y-x;\n\tboolean arr[]=new boolean[4];\n\tfor(int i=0;i<4;i++)\n\t\tarr[i]=false;\n\tfor(int i=0;i<n;i++){\n\t\tint z1=ar[i]+x;\n\t\tint z2=ar[i]-x;\n\t\tint zz1=ar[i]+y;\n\t\tint zz2=ar[i]-y;\n\t\tint zzz1=ar[i]-diff1;\n\t\tint zzz2=ar[i]+diff1;\n\t\tint zzzz1=ar[i]-diff2;\n\t\tint zzzz2=ar[i]+diff2;\n\t\t\n\t\tif(hs.contains(z1)||hs.contains(z2))\n\t\t\tarr[0]=true;\n\t\tif(hs.contains(zz1)||hs.contains(zz2))\n\t\t\tarr[1]=true;\n\t\tif(hs.contains(zzz1)||hs.contains(zzz2)){\n\t\t\tarr[2]=true;\n\t\t\tif(hs.contains(zzz1)){\n\t\t\t\ta=zzz1;\n\t\t\t\tb=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta=zzz2;\n\t\t\t\tb=1;\n\t\t\t}\n\t\t}\n\t\tif(hs.contains(zzzz1)||hs.contains(zzzz2)){\n\t\t\t//out.println(\"xxxxxxxxxxxxxxxxxxxxxxxx\"+zzzz1+\" \"+zzzz2+\" \"+diff2);\n\t\t\tif(hs.contains(zzzz1)&&(zzzz1+y)<=l)\n\t\t\t{\n\t\t\t\t//out.print(\"xxxxX\"+zzzz1);\n\t\t\t\tarr[3]=true;\n\t\t\t\ta=zzzz1+y;\n\t\t\t}\n\t\t\telse if(hs.contains(zzzz1)&&(zzzz1-x)>=0){\n\t\t\t\t//out.print(\"xxxxX\"+zzzz1);\n\t\t\t\tarr[3]=true;\n\t\t\t\ta=zzzz1-x;\n\t\t\t}\n\t\t\telse if(hs.contains(zzzz2)&&(zzzz2-y)>=0)\n\t\t\t{\n\t\t\t\t//out.print(\"xxxxX\"+zzzz2);\n\t\t\t\tarr[3]=true;\n\t\t\t\ta=zzzz2-y;\n\t\t\t}\n\t\t\telse if(hs.contains(zzzz2)&&(zzzz2+x)<=l)\n\t\t\t{\n\t\t\t\t//out.print(\"xxxxX\"+zzzz2);\n\t\t\t\tarr[3]=true;\n\t\t\t\ta=zzzz2+x;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif(arr[0]==true&&arr[1]==true)\n\t{\n\t\tout.println(0);\n\t}\n\telse if(arr[0]==true&&arr[1]==false)\n\t{\n\t\tout.println(1);\n\t\tout.println(y);\n\t}\n\telse if(arr[0]==false&&arr[1]==true)\n\t{\n\t\tout.println(1);\n\t\tout.println(x);\n\t}\n\telse if(arr[2]==true)\n\t{\n\t\tout.println(1);\n\t\tif(b==0){\n\t\t\tout.println(a+x);\n\t\t}\n\t\telse\n\t\t\tout.println(a-x);\n\t}\n\telse if(arr[3]==true)\n\t{\n\t\tout.println(1);\n\t\tout.println(a);\n\t}\n\telse{\n\t\tout.println(2);\n\t\tout.println(x+\" \"+y);\n\t}\n\tout.close();\n\n}\n\nint sieveOfEratosthenes(int n) {\n\t// Create a boolean array \"prime[0..n]\" and initialize\n\t// all entries it as true. A value in prime[i] will\n\t// finally be false if i is Not a prime, else true.\n\tboolean prime[] = new boolean[n + 1];\n\tfor (int i = 0; i < n; i++)\n\t\tprime[i] = true;\n\n\tfor (int p = 2; p * p <= n; p++) {\n\t\t// If prime[p] is not changed, then it is a prime\n\t\tif (prime[p] == true) {\n\t\t\t// Update all multiples of p\n\t\t\tfor (int i = p * 2; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (prime[i] == true)\n\t\t\tc++;\n\t}\n\treturn c;\n\t// Print all prime numbers\n\t/* for(int i = 2; i <= n; i++)\n\t {\n\t     if(prime[i] == true)\n\t         System.out.print(i + \" \");\n\t }*/\n}\n\nstatic class Pair implements Comparable<Pair> {\n\tint u;\n\tint v;\n\tBigInteger bi;\n\n\tpublic Pair(int u, int v) {\n\t\tthis.u = u;\n\t\tthis.v = v;\n\t}\n\n\tpublic int hashCode() {\n\t\tint hu = (int) (u ^ (u >>> 32));\n\t\tint hv = (int) (v ^ (v >>> 32));\n\t\treturn 31 * hu + hv;\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tPair other = (Pair) o;\n\t\treturn u == other.u && v == other.v;\n\t}\n\n\tpublic int compareTo(Pair other) {\n\t\treturn Long.compare(u, other.u) != 0 ? Long.compare(u, other.u) : Long.compare(v, other.v);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"[u=\" + u + \", v=\" + v + \"]\";\n\t}\n}\n\nstatic long modulo(long a, long b, long c) {\n\tlong x = 1;\n\tlong y = a;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tx = (x * y) % c;\n\t\t}\n\t\ty = (y * y) % c; // squaring the base\n\t\tb /= 2;\n\t}\n\treturn x % c;\n}\n\npublic static long getClosestK(long[] a, long x) {\n\n\tint low = 0;\n\tint high = a.length - 1;\n\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\n\t\t// test lower case\n\t\tif (mid == 0) {\n\t\t\tif (a.length == 1) {\n\t\t\t\treturn a[0];\n\t\t\t}\n\n\t\t\treturn Math.min(Math.abs(a[0] - x), Math.abs(a[1] - x)) + x;\n\t\t}\n\n\t\t// test upper case\n\t\tif (mid == a.length - 1) {\n\t\t\treturn a[a.length - 1];\n\t\t}\n\n\t\t// test equality\n\t\tif (a[mid] == x || a[mid + 1] == x) {\n\t\t\treturn x;\n\t\t}\n\n\t\t// test perfect range.\n\t\tif (a[mid] < x && a[mid + 1] > x) {\n\t\t\treturn Math.min(Math.abs(a[mid] - x), Math.abs(a[mid + 1] - x)) + x;\n\t\t}\n\n\t\t// keep searching.\n\t\tif (a[mid] < x) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\tthrow new IllegalArgumentException(\"The array cannot be empty\");\n}\n\nlong factorial(long n, long M) {\n\tlong ans = 1;\n\twhile (n >= 1) {\n\t\tans = (ans * n) % M;\n\t\tn--;\n\t}\n\treturn ans;\n}\n\nstatic long gcd(long x, long y) {\n\tif (x == 0)\n\t\treturn y;\n\tif (y == 0)\n\t\treturn x;\n\tlong r = 0, a, b;\n\ta = (x > y) ? x : y; // a is greater number\n\tb = (x < y) ? x : y; // b is smaller number\n\tr = b;\n\twhile (a % b != 0) {\n\t\tr = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn r;\n}\n\nstatic class InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream inputstream) {\n\t\treader = new BufferedReader(new InputStreamReader(inputstream));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String nextLine() {\n\t\tString fullLine = null;\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tfullLine = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\treturn fullLine;\n\t\t}\n\t\treturn fullLine;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long l, x, y;\nlong long arr[100005];\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) scanf(\"%I64d\", &arr[i]);\n  bool xx = 0, yy = 0;\n  for (int i = 0; i < n; ++i) {\n    if (binary_search(arr, arr + i, arr[i] - x)) xx = 1;\n    if (binary_search(arr, arr + i, arr[i] - y)) yy = 1;\n  }\n  if (xx && yy) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  if (xx) {\n    cout << \"1\\n\" << y << endl;\n    return 0;\n  }\n  if (yy) {\n    cout << \"1\\n\" << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    long long x1 = arr[i] - x;\n    if (x1 >= 0 && x1 <= l &&\n        (binary_search(arr, arr + n, x1 - y) ||\n         binary_search(arr, arr + n, x1 + y))) {\n      cout << \"1\\n\" << x1 << endl;\n      return 0;\n    }\n    x1 = arr[i] + x;\n    if (x1 >= 0 && x1 <= l &&\n        (binary_search(arr, arr + n, x1 - y) ||\n         binary_search(arr, arr + n, x1 + y))) {\n      cout << \"1\\n\" << x1 << endl;\n      return 0;\n    }\n    x1 = arr[i] - y;\n    if (x1 >= 0 && x1 <= l &&\n        (binary_search(arr, arr + n, x1 - x) ||\n         binary_search(arr, arr + n, x1 + x))) {\n      cout << \"1\\n\" << x1 << endl;\n      return 0;\n    }\n    x1 = arr[i] + y;\n    if (x1 >= 0 && x1 <= l &&\n        (binary_search(arr, arr + n, x1 - x) ||\n         binary_search(arr, arr + n, x1 + x))) {\n      cout << \"1\\n\" << x1 << endl;\n      return 0;\n    }\n  }\n  cout << \"2\\n\" << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import itertools\nimport math\n\ndef can_measure(a, d):\n\treturn any(i + d in a for i in a)\n\ndef main():\n\tn, l, x, y = map(int, input().split())\n\ta = set(map(int, input().split()))\n\t\n\tcan_x = can_measure(a, x)\n\tcan_y = can_measure(a, y)\n\tif can_x and can_y:\n\t\tprint(0)\n\telif can_x:\n\t\tprint(1)\n\t\tprint(y)\n\telif can_y:\n\t\tprint(1)\n\t\tprint(x)\n\telse:\n\t\tfor i in a:\n\t\t\tif i + x + y in a:\n\t\t\t\tprint(1)\n\t\t\t\tprint(i + x)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tt = i + x - y in a\n\t\t\t\tif 0 <= i + x <= l and t:\n\t\t\t\t\tprint(1)\n\t\t\t\t\tprint(i + x)\n\t\t\t\t\tbreak;\n\t\t\t\tif 0 <= i - y <= l and t:\n\t\t\t\t\tprint(1)\n\t\t\t\t\tprint(i - y)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\telse:\n\t\t\tprint(2)\n\t\t\tprint(x, y)\n\t\t\n\nif __name__ == \"__main__\":\n\tmain()\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 1,
            "solution": "def find(v, d):\n    ans = []\n    i=j=0\n    while j<len(v):\n        if v[j]-v[i]<d:\n            j+=1\n        elif v[j]-v[i]>d:\n            i+=1\n        else:\n            ans.append((i,j))\n            j+=1\n    return ans\n\n(n,l,x,y) = map(int, raw_input().split())\nv = map(int, raw_input().split())\n\nans = 5\nansa = []\n\nif find(v,x) and find(v,y):\n    ans=0\nif find(v,x) and ans==5:\n    ans=1\n    ansa=[y]\nif find(v,y) and ans==5:\n    ans=1\n    ansa=[x]\nt = find(v, x+y)\nif t and ans==5:\n    ans=1\n    ansa = [v[t[0][0]]+x]\nt = find(v, y-x)\nif t and ans==5:\n    for (i,j) in t:\n        if v[i]-x>=0:\n            ans=1\n            ansa = [v[i]-x]\n            break\n        elif v[j]+x<=l:\n            ans=1\n            ansa = [v[j]+x]\nif ans==5:\n    ans=2\n    ansa = [x,y]\nprint ans\nprint ' '.join(map(str, ansa))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nbool solve();\nint finds(int);\nint n, length, x, y;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &length, &x, &y);\n  memset(a, 0, sizeof(a));\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  solve();\n  return 0;\n}\nbool solve() {\n  int r1, r2, r3, r4;\n  r1 = finds(x);\n  r2 = finds(y);\n  r3 = finds(x + y);\n  r4 = finds(y - x);\n  if (r1 != -1 && r2 != -1) {\n    printf(\"0\\n\");\n  } else {\n    if (r1 != -1)\n      printf(\"%d\\n%d\\n\", 1, y);\n    else if (r2 != -1)\n      printf(\"%d\\n%d\\n\", 1, x);\n    else if (r3 != -1)\n      printf(\"%d\\n%d\\n\", 1, r3 - y);\n    else if (r4 != -1) {\n      if (r4 - y > 0)\n        printf(\"%d\\n%d\\n\", 1, r4 - y);\n      else if (r4 + x < length)\n        printf(\"%d\\n%d\\n\", 1, r4 + x);\n    } else\n      printf(\"%d\\n%d %d\\n\", 2, x, y);\n  }\n  return true;\n}\nint finds(int pos) {\n  int tmp;\n  for (int i = 0; i < n; i++) {\n    tmp = lower_bound(a, a + n, a[i] + pos) - a;\n    if (tmp == n)\n      break;\n    else {\n      if (a[tmp] == a[i] + pos) {\n        if (pos == y - x) {\n          if (a[tmp] - y < 0 && a[tmp] + x > length)\n            continue;\n          else\n            return a[tmp];\n        } else\n          return a[tmp];\n      }\n    }\n  }\n  return -1;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    import sys\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, l, x, y = [tokens.pop() for i in range(4)]\n    marks = set(tokens)\n    \n    x_index = y_index = sum_index = sub_index1 = sub_index2 = -1\n    for i in marks:\n        if i + x in marks:\n            x_index = y\n        if i + y in marks:\n            y_index = x\n        if i + x + y in marks:\n            sum_index = i + x\n        if i + y - x in marks and i - x >= 0:\n            sub_index1 = i - x\n        if i + y - x in marks and i + y <= l:\n            sub_index2 = i + y\n    \n    if x_index != -1 and y_index != -1:\n        print(0)\n    else:\n        for i in (x_index, y_index, sum_index, sub_index1, sub_index2):\n            if i != -1:\n                print(1)\n                print(i)\n                break\n        else:\n            print(2)\n            print(x, y)\n    \n    \nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nint N, L, A[maxn];\nint check(int len) {\n  int j = 1;\n  for (int i = (1), _i = (N); i <= _i; ++i) {\n    while (j <= N && A[i] > A[j] - len) ++j;\n    if (j <= N && A[i] == A[j] - len) return i;\n  }\n  return 0;\n}\nvoid solve(int x, int y, int &a, int &b) {\n  a = b = -1;\n  if (check(x) == 0) a = x;\n  if (check(y) == 0) b = y;\n  if (a != -1 && b != -1) {\n    int t1 = check(x + y);\n    if (t1 > 0) {\n      a = A[t1] + x;\n      b = -1;\n      return;\n    }\n    int j = 1, len = y - x;\n    for (int i = (1), _i = (N); i <= _i; ++i) {\n      while (j <= N && A[i] > A[j] - len) ++j;\n      if (j <= N && A[i] == A[j] - len) {\n        if (A[i] - x >= 0) {\n          a = A[i] - x;\n          b = -1;\n          return;\n        }\n        if (A[i] + y <= L) {\n          a = A[i] + y;\n          b = -1;\n          return;\n        }\n      }\n    }\n  }\n}\nint main() {\n  int x, y;\n  for (; scanf(\"%d%d%d%d\", &N, &L, &x, &y) != EOF;) {\n    for (int i = (1), _i = (N); i <= _i; ++i) scanf(\"%d\", &A[i]);\n    int a, b;\n    solve(x, y, a, b);\n    int k = (a != -1) + (b != -1);\n    printf(\"%d\\n\", k);\n    if (k == 1) printf(\"%d\\n\", (a != -1 ? a : b));\n    if (k == 2) printf(\"%d %d\\n\", a, b);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nmap<int, int> mapa;\nint v[200000];\nint okX(int a) {\n  if (a < 0 || a > l) return 0;\n  return mapa[a - x] || mapa[a + x];\n}\nint okY(int a) {\n  if (a < 0 || a > l) return 0;\n  return mapa[a - y] || mapa[a + y];\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> v[i];\n    mapa[v[i]] = 1;\n  }\n  int cx = 0, cy = 0;\n  for (int i = 0; i < n; i++)\n    if (okX(v[i])) {\n      cx = 1;\n    }\n  for (int i = 0; i < n; i++)\n    if (okY(v[i])) {\n      cy = 1;\n    }\n  if (cy + cx == 2) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (cy) {\n    printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  if (cx) {\n    printf(\"1\\n%d\\n\", y);\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (okY(v[i] + x)) {\n      printf(\"1\\n%d\\n\", v[i] + x);\n      return 0;\n    } else if (okY(v[i] - x)) {\n      printf(\"1\\n%d\\n\", v[i] - x);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nbool f(int *p, int n, int des, int &i) {\n  for (i = 0; i + 1 < n; i++) {\n    int left = i + 1;\n    int right = n - 1;\n    while (left < right) {\n      int mid = (left + right) / 2;\n      if (p[mid] >= des + p[i])\n        right = mid;\n      else\n        left = mid + 1;\n    }\n    if (p[left] == des + p[i]) return true;\n  }\n  return false;\n}\nbool g(int *p, int n, int des, int &i) {\n  for (i = n - 2; i >= 0; i--) {\n    int left = i + 1;\n    int right = n - 1;\n    while (left < right) {\n      int mid = (left + right) / 2;\n      if (p[mid] >= des + p[i])\n        right = mid;\n      else\n        left = mid + 1;\n    }\n    if (left == right && p[left] == des + p[i]) return true;\n  }\n  return false;\n}\nint main() {\n  int n, l, x, y;\n  while (cin >> n >> l >> x >> y) {\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int i;\n    bool xx = f(a, n, x, i);\n    bool yy = f(a, n, y, i);\n    if (xx && yy)\n      cout << 0 << endl;\n    else if (xx || yy) {\n      cout << 1 << endl;\n      cout << (xx ? y : x) << endl;\n    } else {\n      bool xy = f(a, n, x + y, i);\n      if (xy) {\n        cout << 1 << endl;\n        cout << a[i] + x << endl;\n      } else {\n        xy = f(a, n, y - x, i);\n        if (xy && a[i] + y < l) {\n          cout << 1 << endl;\n          cout << a[i] + y << endl;\n        } else {\n          xy = g(a, n, y - x, i);\n          if (xy && a[i] > x) {\n            cout << 1 << endl;\n            cout << a[i] - x << endl;\n          } else {\n            cout << 2 << endl;\n            cout << x << \" \" << y << endl;\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nconst long long mod = 1e9;\n#pragma GCC optimize(\"-O2\")\nconst long long INF = 10000000;\nlong long getIInput() {\n  cout.flush();\n  long long x;\n  cin >> x;\n  return x;\n}\nvoid flash() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout.setf(ios::fixed);\n  cout.setf(ios::showpoint);\n  cout.precision(9);\n}\nvoid solve();\nint32_t main() {\n  flash();\n  long long t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\nvoid solve() {\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  stack<long long> st, ff;\n  st.push(x);\n  st.push(y);\n  long long a[n];\n  map<long long, long long> present;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    present[a[i]] = 1;\n  }\n  for (long long cnt = 0; cnt < 2; cnt++) {\n    bool found = 0;\n    for (long long i = 0; i < n; i++) {\n      long long x = st.top();\n      if (present.find(a[i] + x) != present.end()) {\n        found = 1;\n        break;\n      }\n    }\n    if (found == 0) {\n      ff.push(st.top());\n    }\n    st.pop();\n  }\n  if (ff.size() == 0) {\n    cout << \"0\\n\";\n    return;\n  }\n  if (ff.size() == 1) {\n    cout << 1 << \"\\n\";\n    cout << ff.top() << \"\\n\";\n    return;\n  }\n  long long z = x + y;\n  for (long long i = 0; i < n; i++) {\n    if (present.find(z + a[i]) != present.end()) {\n      cout << \"1\\n\";\n      cout << a[i] + x << \"\\n\";\n      return;\n    }\n    if (a[i] + x >= 0 && a[i] + x <= l &&\n        present.find(a[i] + x - y) != present.end()) {\n      cout << \"1\\n\";\n      cout << a[i] + x << \"\\n\";\n      return;\n    }\n    if (a[i] - x >= 0 && a[i] - x <= l &&\n        present.find(a[i] - x + y) != present.end()) {\n      cout << \"1\\n\";\n      cout << a[i] - x << \"\\n\";\n      return;\n    }\n    if (a[i] - y >= 0 && a[i] - y <= l &&\n        present.find(a[i] + x - y) != present.end()) {\n      cout << \"1\\n\";\n      cout << a[i] - y << \"\\n\";\n      return;\n    }\n    if (a[i] + y >= 0 && a[i] + y <= l &&\n        present.find(a[i] - x + y) != present.end()) {\n      cout << \"1\\n\";\n      cout << a[i] + y << \"\\n\";\n      return;\n    }\n  }\n  cout << 2 << \"\\n\";\n  cout << x << \" \" << y << \"\\n\";\n  return;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/python2\n# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\ndef have(sa, x):\n    for i in sa:\n        if i + x in sa:\n            return i + x\n    return False\n\ndef main():\n    n, l, x, y = map(int, sys.stdin.readline().split())\n    a = map(int, sys.stdin.readline().split())\n    sa = set(a)\n    if have(sa, x):\n        if have(sa, y):\n            print \"0\"\n        else:\n            print \"1\"\n            print y\n    elif have(sa, y):\n        print \"1\"\n        print x\n    else:\n        ret = have(sa, x + y)\n        if ret:\n            print \"1\"\n            print ret - y\n        else:\n            ret = have(sa, y - x)\n            found = -1\n            if ret:\n                for i in sa:\n                    if i + y - x in sa:\n                        if i - x >= 0:\n                            found = i - x\n                            break\n                        elif i + y <= l:\n                            found = i + y\n                            break\n            if found >= 0:\n                print \"1\"\n                print found\n            else:\n                print \"2\"\n                print x, y\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nlong long n, l, x, y;\nlong long a[maxn];\nint main(int argc, char *argv[]) {\n  cin >> n >> l >> x >> y;\n  set<long long> s;\n  for (int i = 1; i <= n; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    a[i] = t;\n    s.insert(a[i]);\n  }\n  bool xFound = false, yFound = false;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] == x) xFound = true;\n    if (a[i] == y) yFound = true;\n    if (s.count(a[i] - x) || s.count(a[i] + x)) xFound = true;\n    if (s.count(a[i] - y) || s.count(a[i] + y)) yFound = true;\n  }\n  if (xFound && yFound) {\n    cout << 0 << endl;\n    exit(0);\n  }\n  if (xFound) {\n    cout << 1 << endl << y << endl;\n    exit(0);\n  }\n  if (yFound) {\n    cout << 1 << endl << x << endl;\n    exit(0);\n  }\n  int ansBoth = -1;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] + y <= l && (s.count(a[i] + y - x) || s.count(a[i] + y + x))) {\n      ansBoth = a[i] + y;\n      break;\n    }\n    if (a[i] - y >= 0 && (s.count(a[i] - y - x) || s.count(a[i] - y + x))) {\n      ansBoth = a[i] - y;\n      break;\n    }\n  }\n  if (ansBoth != -1) {\n    cout << 1 << endl << ansBoth << endl;\n    exit(0);\n  }\n  cout << 2 << endl << x << \" \" << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nvector<int> ans;\nvoid solve() {\n  ans.clear();\n  int n, l, x, y, i;\n  cin >> n >> l >> x >> y;\n  vector<int> arr;\n  for (int j = 0; j < n; j++) {\n    int x;\n    cin >> x;\n    arr.push_back(x);\n  }\n  for (i = 0; i < n; i++)\n    if (binary_search(arr.begin(), arr.end(), arr[i] - x)) break;\n  if (i == n) {\n    for (i = 0; i < n; i++) {\n      if (arr[i] > x) {\n        ans.push_back(arr[i] - x);\n        break;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (binary_search(arr.begin(), arr.end(), arr[i] - y)) break;\n  }\n  if (i == n) {\n    for (i = 0; i < n; i++) {\n      if (arr[i] > y) {\n        ans.push_back(arr[i] - y);\n        break;\n      }\n    }\n  }\n  if ((int)ans.size() > 1) {\n    for (i = 0; i < n; i++) {\n      if (binary_search(arr.begin(), arr.end(), arr[i] - x + y) &&\n          arr[i] - x > 0) {\n        cout << 1 << \"\\n\";\n        cout << arr[i] - x << \"\\n\";\n        return;\n      }\n      if (binary_search(arr.begin(), arr.end(), arr[i] - x - y) &&\n          arr[i] - x > 0) {\n        cout << 1 << \"\\n\";\n        cout << arr[i] - x << \"\\n\";\n        return;\n      }\n      if (binary_search(arr.begin(), arr.end(), arr[i] + x - y) &&\n          arr[i] + x < l) {\n        cout << 1 << \"\\n\";\n        cout << arr[i] + x << \"\\n\";\n        return;\n      }\n      if (binary_search(arr.begin(), arr.end(), arr[i] + x + y) &&\n          arr[i] + x < l) {\n        cout << 1 << \"\\n\";\n        cout << arr[i] + x << \"\\n\";\n        return;\n      }\n    }\n  }\n  cout << ans.size() << \"\\n\";\n  sort(ans.begin(), ans.end());\n  for (int x : ans) cout << x << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint32_t main() {\n  long long N, L, X, Y;\n  cin >> N >> L >> X >> Y;\n  long long A[N];\n  bool a = false, b = false;\n  vector<long long> marks;\n  for (long long n = 0; n < N; n++) cin >> A[n];\n  for (long long n = 0; n < N - 1; n++) {\n    long long i = lower_bound(A + n + 1, A + N, A[n] + X) - A;\n    if (i < N && A[i] == X + A[n]) a = true;\n    long long j = lower_bound(A + n + 1, A + N, A[n] + Y) - A;\n    if (j < N && A[j] == Y + A[n]) b = true;\n  }\n  if (!a && !b) {\n    bool c = false;\n    for (long long n = 0; n < N; n++) {\n      long long k1 = lower_bound(A + n + 1, A + N, A[n] + X + Y) - A;\n      if (k1 < N && A[k1] == A[n] + X + Y && A[n] + X < L) {\n        marks.push_back(A[n] + X);\n        c = true;\n        break;\n      }\n      long long k2 = lower_bound(A + n + 1, A + N, A[n] - X + Y) - A;\n      if (k2 < N && A[k2] == A[n] - X + Y) {\n        if (A[n] + Y < L)\n          marks.push_back(A[n] + Y);\n        else if (A[n] - X > 0)\n          marks.push_back(A[n] - X);\n        else\n          continue;\n        c = true;\n        break;\n      }\n    }\n    if (!c) {\n      marks.push_back(X);\n      marks.push_back(Y);\n    }\n  } else {\n    if (!a) marks.push_back(X);\n    if (!b) marks.push_back(Y);\n  }\n  cout << marks.size() << endl;\n  for (auto it : marks) cout << it << \" \";\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class LongJumps {\n\npublic static void main(String args[] ) throws Exception {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t    PrintWriter w = new PrintWriter(System.out);\n\t        \n\t    StringTokenizer st1 = new StringTokenizer(br.readLine());\n\t    int n = ip(st1.nextToken());\n\t    int l = ip(st1.nextToken());\n\t    int x = ip(st1.nextToken());\n\t    int y = ip(st1.nextToken());\n\t    \n\t    StringTokenizer st2 = new StringTokenizer(br.readLine());\n\t    int a[] = new int[n];\n\t    for(int i=0;i<n;i++)\n\t    \ta[i] = ip(st2.nextToken());\n\t        \n\t    boolean xfound = false;\n\t    boolean yfound = false;\n\t    \n\t    for(int i=0;i<n-1;i++){\n\t    \tif(!xfound){\n\t    \t\tif(bS(a,a[i]+x,i+1,n)!=-1)\n\t    \t\t\txfound = true;\n\t    \t}\n\t    \tif(!yfound){\n\t    \t\tif(bS(a,a[i]+y,i+1,n)!=-1)\n\t    \t\t\tyfound = true;\n\t    \t}\n\t    }\n\t    \n\t    if(xfound && yfound)\n\t    \tw.println(\"0\");\n\t    \n\t    else if(xfound != yfound){\n\t    \tw.println(\"1\");\n\t    \tif(!xfound)\n\t    \t\tw.println(x);\n\t    \telse\n\t    \t\tw.println(y);\n\t    }\n\t    \n\t    else{\n\t    \tboolean nice = false;\n\t    \tint ans1=x,ans2=y;\n\t    \t\n\t    \tfor(int i=0;i<n;i++){\n\t    \t\t//mark at a[i]+x\n\t    \t\tif(bS(a,a[i]+x+y,0,n)!=-1){\n\t    \t\t\tnice = true;\n\t    \t\t\tans1 = a[i]+x;\n\t    \t\t\tbreak;\n\t    \t\t}\n\t    \t\tif(bS(a,a[i]+y-x,0,n)!=-1){\n\t    \t\t\tif(a[i] + y <= l){\n\t    \t\t\t\tnice = true;\n\t    \t\t\t\tans1 = a[i] + y;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t\tif(a[i] - x  >= 0){\n\t    \t\t\t\tnice = true;\n\t    \t\t\t\tans1 = a[i] - x;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tif(bS(a,a[i]+x-y,0,n)!=-1){\n\t    \t\t\tif(a[i] + x <= l){\n\t    \t\t\t\tnice = true;\n\t    \t\t\t\tans1 = a[i] + x;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t\tif(a[i] - y >= 0){\n\t    \t\t\t\tnice = true;\n\t    \t\t\t\tans1 = a[i] - y;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \t\n\t    \tif(nice){\n\t    \t\tw.println(\"1\");\n\t    \t\tw.println(ans1);\n\t    \t}\n\t    \telse{\n\t    \t\tw.println(\"2\");\n\t    \t\tw.println(ans1 + \" \" + ans2);\n\t    \t}\n\t    }\n\t    w.close(); \n\t}\n\t\n\tpublic static int bS(int[] a,int key,int start,int end){\n\t\twhile(true){\n\t\t\tif(start==end) return -1;\n\t\t\tint mid = (start+end)/2;\n\t\t\tif(key==a[mid]) return mid;\n\t\t\tif(end-start==1) return -1;\n\t\t\tif(key<a[mid])\tend = mid;\n\t\t\telse start = mid+1;\n\t\t}\n\t}\n\tpublic static int ip(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long x, y, n, len, ans = 2;\nmap<long long, long long> g;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  bool casex = false, casey = false;\n  cin >> n >> len >> x >> y;\n  for (long long i = 1; i <= n; i++) {\n    long long p;\n    cin >> p;\n    if (g.count(p - x) && !casex) ans--, casex = true;\n    if (g.count(p - y) && !casey) ans--, casey = true;\n    g[p]++;\n  }\n  if (ans) {\n    if (ans == 2)\n      for (auto it = g.begin(); it != g.end(); it++) {\n        if (!casex && !casey) {\n          if (g.count(it->first + x + y) ||\n              (g.count(it->first + x - y) &&\n               (it->first + x <= len || it->first - y >= 0))) {\n            cout << 1 << endl;\n            if (it->first + x <= len)\n              cout << it->first + x;\n            else\n              cout << it->first - y;\n            return 0;\n          } else if (g.count(it->first + y - x) &&\n                     (it->first - x >= 0 || it->first + y <= len)) {\n            cout << 1 << endl;\n            if (it->first - x >= 0)\n              cout << it->first - x;\n            else\n              cout << it->first + y;\n            return 0;\n          }\n        }\n      }\n    if (ans == 1) {\n      if (casex) {\n        cout << 1 << endl;\n        cout << g.begin()->first + y;\n        return 0;\n      } else {\n        cout << 1 << endl;\n        cout << g.begin()->first + x;\n        return 0;\n      }\n    } else {\n      cout << 2 << endl;\n      cout << g.begin()->first + x << endl;\n      cout << g.begin()->first + y;\n    }\n  } else\n    cout << 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "\nimport sys, math\ndef rs():\n    return sys.stdin.readline().strip()\ndef ri():\n    return int(sys.stdin.readline().strip())\ndef ras():\n    return list(sys.stdin.readline().strip())\ndef rai():\n    return map(int,sys.stdin.readline().strip().split())\ndef raf():\n    return map(float,sys.stdin.readline().strip().split())\n\n\ndef solve():\n    n,l,x,y = rai()\n    points = rai()\n    st = set(points)\n    fx = False\n    fy = False\n    for p in points:\n        if p - x in st:\n            fx = True\n            break\n\n    for p in points:\n        if p - x in st:\n            fx = True\n            break\n\n    for p in points:\n        if p - y in st:\n            fy = True\n            break\n\n    if fx and fy: print 0; return\n    if not fx and not fy:\n        for p in points:\n            if p - x > 0:\n                st.add(p-x)\n            if p + x < l:\n                st.add(p+x)\n        for p in points:\n            if p-y in st:\n                print 1\n                print p-y\n                return\n            if p+y in st:\n                print 1\n                print p+y\n                return \n        print 2\n        print x, y\n        return\n    elif fx: \n        print 1\n        print y\n        return\n    else:\n        print 1\n        print x\n        return \n\n\nsolve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mn, mx, n, k, imx, imn, l, x, y, a[300000], kx, ky, ans1, ans2, ans3,\n    ans4;\nmap<long long, long long> mp;\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i], mp[a[i]] = 1;\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; i++) {\n    if (mp[a[i] - x] == 1) kx++;\n    if (mp[a[i] - y] == 1) ky++;\n    if (mp[a[i] - y + x] == 1 && (a[i] - y >= 0)) {\n      ans1 = a[i] - y;\n    }\n    if (mp[a[i] - x + y] == 1 && (a[i] + y <= l)) {\n      ans2 = a[i] + y;\n    }\n    if (mp[a[i] + x + y] == 1) {\n      ans3 = a[i] + x;\n    }\n    if (mp[a[i] - x - y] == 1) {\n      ans4 = a[i] - x;\n    }\n  }\n  if (kx != 0 && ky != 0)\n    cout << 0;\n  else if (kx != 0 || ky != 0) {\n    cout << 1 << '\\n';\n    if (kx != 0)\n      cout << y;\n    else\n      cout << x;\n  } else if (ans1 != 0) {\n    cout << 1 << '\\n';\n    cout << ans1;\n  } else if (ans2 != 0) {\n    cout << 1 << '\\n';\n    cout << ans2;\n  } else if (ans3 != 0) {\n    cout << 1 << '\\n';\n    cout << ans3;\n  } else if (ans4 != 0) {\n    cout << 1 << '\\n';\n    cout << ans4;\n  } else {\n    cout << 2 << '\\n';\n    cout << x << ' ' << y;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint n, l, x, y;\nint a[200001];\nbool fx, fy;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    s.insert(a[i]);\n  }\n  fx = fy = false;\n  for (int i = 1; i <= n; i++) {\n    if (s.find(a[i] + x) != s.end()) fx = true;\n    if (s.find(a[i] - x) != s.end()) fx = true;\n    if (s.find(a[i] + y) != s.end()) fy = true;\n    if (s.find(a[i] - y) != s.end()) fy = true;\n  }\n  if (fx && fy) {\n    printf(\"0\\n\");\n    return 0;\n  } else if (fx || fy) {\n    if (fx) printf(\"1\\n%d\\n\", y);\n    if (fy) printf(\"1\\n%d\\n\", x);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    int temp = a[i] - x;\n    if (temp >= 0 && temp <= l) {\n      if (s.find(temp - y) != s.end() || s.find(temp + y) != s.end()) {\n        printf(\"1\\n%d\\n\", temp);\n        return 0;\n      }\n    }\n    temp = a[i] + x;\n    if (temp >= 0 && temp <= l) {\n      if (s.find(temp - y) != s.end() || s.find(temp + y) != s.end()) {\n        printf(\"1\\n%d\\n\", temp);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B {\n    public static PrintStream out = System.out;\n    public static InputReader in = new InputReader(System.in);\n    static int N;\n    public static void main(String args[]) {\n        long L, X, Y;\n        N = in.nextInt();\n        L = in.nextLong();\n        X = in.nextLong();\n        Y = in.nextLong();\n        long[] a = new long[N];\n        for (int i = 0; i < N; i++) {\n            a[i] = in.nextLong();\n        }\n        boolean hx = have(a, X);\n        boolean hy = have(a, Y);\n        if (hx && hy) {\n            out.println(0);\n            System.exit(0);\n        } else if (hx) {\n            out.println(1);\n            out.println(Y);\n            System.exit(0);\n        } else if (hy) {\n            out.println(1);\n            out.println(X);\n            System.exit(0);\n        } else {\n            for (int i = 0; i < N; i++) {\n                for (long x1 : new long[] {X, -X}) {\n                    for (long y1 : new long[] {Y, -Y}) {\n                        if (a[i] + x1 >= 0 && a[i] + x1 <= a[a.length - 1]) {\n                            if (Arrays.binarySearch(a, a[i] + x1 + y1) >= 0) {\n                                out.println(1);\n                                out.println(a[i] + x1);\n                                System.exit(0);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        out.println(2);\n        out.println(X + \" \" + Y);\n    }\n    static boolean have(long[] a, long x) {\n        for (int i = 0; i < N; i++) {\n            if (Arrays.binarySearch(a, a[i] + x) >= 0) return true;\n        }\n        return false;\n    }\n}\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\ttokenizer = null;\n    }\n    public String next() {\n\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t    try {\n\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t    } catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t    }\n\t}\n\treturn tokenizer.nextToken();\n    }\n    public double nextDouble() {\n\treturn Double.parseDouble(next());\n    }\n    public long nextLong() {\n\treturn Long.parseLong(next());\n    }\n    public int nextInt() {\n\treturn Integer.parseInt(next());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100030;\nmap<int, int> mp;\nint q1, q2, n, m, x, y, a[N], xx, yy, w1, w2;\nvoid f(int v) {\n  if (mp[v + x] == 1) q1 = 1;\n  if (mp[v + y] == 1) q2 = 1;\n  if (v - x >= 0 && (mp[v - x - y] == 1 || mp[v - x + y] == 1)) {\n    w1 = 1;\n    xx = v - x;\n  }\n  if (v - y >= 0 && (mp[v - y + x] == 1 || mp[v - y - x] == 1)) {\n    w2 = 1;\n    yy = v - y;\n  }\n  if (v + x <= m && (mp[v + x - y] == 1 || mp[v + x + y] == 1)) {\n    w1 = 1;\n    xx = v + x;\n  }\n  if (v + y <= m && (mp[v + y - x] == 1 || mp[v + y + x] == 1)) {\n    w2 = 1;\n    yy = v - x;\n  }\n}\nint main() {\n  cin.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    mp[a[i]] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    f(a[i]);\n  }\n  if (q1 + q2 == 2)\n    cout << 0;\n  else if (q1 == 1)\n    cout << 1 << endl << y;\n  else if (q2 == 1)\n    cout << 1 << endl << x;\n  else if (w1 == 1)\n    cout << 1 << endl << xx;\n  else if (w2 == 1)\n    cout << 1 << endl << yy;\n  else\n    cout << 2 << endl << x << ' ' << y;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class B {\n\n    private static int find(int[] a, Set<Integer> s, int k) {\n        for (int x : a) {\n            if (s.contains(x + k)) {\n                return x;\n            }\n        }\n        return -1;\n    }\n\n    private static List<Integer> findAll(int[] a, Set<Integer> s, int k) {\n        List<Integer> res = new ArrayList<>();\n        for (int x : a) {\n            if (s.contains(x + k)) {\n                res.add(x);\n            }\n        }\n        return res;\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int l = nextInt();\n        int x = nextInt();\n        int y = nextInt();\n        int[] a = new int[n];\n\n        Set<Integer> set = new HashSet<>();\n\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            set.add(a[i]);\n        }\n\n        int findX = find(a, set, x);\n        int findY = find(a, set, y);\n        if (findX >= 0 && findY >= 0) {\n            println(0);\n            return;\n        } else if (findX >= 0) {\n            println(1);\n            println(y);\n            return;\n        } else if (findY >= 0) {\n            println(1);\n            println(x);\n            return;\n        }\n\n\n        List<Integer> minus = findAll(a, set, y - x);\n        for (Integer m : minus) {\n            if (m - x >= 0) {\n                println(1);\n                println(m - x);\n                return;\n            } else if (m + y <= l) {\n                println(1);\n                println(m + y);\n                return;\n            }\n        }\n\n        int plus = find(a, set, x + y);\n        if (plus != -1) {\n            println(1);\n            println(plus + x);\n            return;\n        }\n\n        println(2);\n        println(x + \" \" + y);\n    }\n\n    private String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    private int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private void print(Object o) {\n        writer.print(o);\n    }\n\n    private void println(Object o) {\n        writer.println(o);\n    }\n\n    private void printf(String format, Object... o) {\n        writer.printf(format, o);\n    }\n\n    public static void main(String[] args) {\n        long time = System.currentTimeMillis();\n        Locale.setDefault(Locale.US);\n        new B().run();\n        System.err.printf(\"%.3f\\n\", 1e-3 * (System.currentTimeMillis() - time));\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    private void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(13);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int m, long long int n) {\n  if (n == 0) return m;\n  return gcd(n, m % n);\n}\nvector<int> v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  set<int> s;\n  for (int i = 0; i < n; i++) {\n    int temp;\n    cin >> temp;\n    s.insert(temp);\n  }\n  int a, b;\n  a = 0;\n  b = 0;\n  for (set<int>::iterator it = s.begin(); it != s.end(); it++) {\n    if (s.find((*it) + x) != s.end()) {\n      a = 1;\n    }\n    if (s.find((*it) + y) != s.end()) {\n      b = 1;\n    }\n  }\n  if (a && b)\n    cout << \"0\\n\";\n  else if (a) {\n    cout << \"1\\n\";\n    cout << y << endl;\n  } else if (b) {\n    cout << \"1\\n\";\n    cout << x << endl;\n  } else {\n    for (set<int>::iterator it = s.begin(); it != s.end(); it++) {\n      if (*it + x <= l && (*it + x >= 0)) {\n        s.insert((*it) + x);\n        if (s.find((*it) + x + y) != s.end() && ((*it) + x + y) <= l) {\n          cout << \"1\\n\";\n          cout << (*it) + x << endl;\n          return 0;\n        }\n        if (s.find((*it) + x - y) != s.end() && ((*it) + x - y) <= l &&\n            (*it + x - y) >= 0) {\n          cout << \"1\\n\";\n          cout << (*it) + x << endl;\n          return 0;\n        }\n        s.erase((*it) + x);\n      }\n      if (*it - x <= l && (*it - x >= 0)) {\n        s.insert((*it) - x);\n        if (s.find((*it) - x + y) != s.end() && ((*it) - x + y) <= l) {\n          cout << \"1\\n\";\n          cout << (*it) - x << endl;\n          return 0;\n        }\n        if (s.find((*it) - x - y) != s.end() && ((*it) - x - y) <= l &&\n            (*it - x - y >= 0)) {\n          cout << \"1\\n\";\n          cout << (*it) - x << endl;\n          return 0;\n        }\n        s.erase((*it) - x);\n      }\n      if (*it + y <= l && (*it + y >= 0)) {\n        s.insert((*it) + y);\n        if (s.find((*it) + y + x) != s.end() && ((*it) + y + x) <= l) {\n          cout << \"1\\n\";\n          cout << (*it) + y << endl;\n          return 0;\n        }\n        if (s.find((*it) + y - x) != s.end() && ((*it) + y - x) <= l &&\n            (*it + y - x) >= 0) {\n          cout << \"1\\n\";\n          cout << (*it) + y << endl;\n          return 0;\n        }\n        s.erase((*it) + y);\n      }\n      if (*it - y <= l && (*it - y >= 0)) {\n        s.insert((*it) - y);\n        if (s.find((*it) - y + x) != s.end() && ((*it) - y + x) <= l) {\n          cout << \"1\\n\";\n          cout << (*it) - y << endl;\n          return 0;\n        }\n        if (s.find((*it) - y - x) != s.end() && ((*it) - y - x) <= l &&\n            (*it - y - x >= 0)) {\n          cout << \"1\\n\";\n          cout << (*it) - y << endl;\n          return 0;\n        }\n        s.erase((*it) - y);\n      }\n    }\n    cout << \"2\\n\";\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.awt.Checkbox;\nimport java.io.*;\n\npublic class C {\n\tstatic ArrayList<Integer> primes;\n\tstatic int[] isComposite;\n\tstatic int[] idx;\n\tstatic int[] p;\n\n\tstatic void sieve(int N) // O(N log log N)\n\t{\n\t\tisComposite = new int[N + 1];\n\t\tidx = new int[N + 1];\n\t\tisComposite[0] = isComposite[1] = 1; // 0 indicates a prime number\n\t\tprimes = new ArrayList<Integer>();\n\n\t\tint ix = 1;\n\t\tfor (int i = 2; i <= N; ++i) // can loop till i*i <= N if primes array is not needed O(N log log sqrt(N))\n\t\t\tif (isComposite[i] == 0) // can loop in 2 and odd integers for slightly better performance\n\t\t\t{\n\t\t\t\tprimes.add(i);\n\t\t\t\tidx[i] = ix;\n\t\t\t\tix++;\n\t\t\t\tif (1l * i * i <= N)\n\t\t\t\t\tfor (int j = i * i; j <= N; j += i) // j = i * 2 will not affect performance too much, may alter in\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// modified sieve\n\t\t\t\t\t\tisComposite[j] = 1;\n\t\t\t}\n\t\tp = new int[primes.size()];\n\t\tint i = 0;\n\t\tfor (int x : primes) {\n\t\t\tp[i++] = x;\n\t\t}\n\t}\n\n\tstatic long pow(long a, long e) // O(log e)\n\t{\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1)\n\t\t\t\tres *= a;\n\t\t\ta *= a;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic ArrayList<Long> arr = new ArrayList<Long>();\n\n\tstatic void com(int idx, long r) {\n\t\tif (idx == 10) {\n\t\t\tarr.add(r);\n\t\t\treturn;\n\t\t}\n\t\tcom(idx + 1, r + a[idx]);\n\t\tcom(idx + 1, r);\n\n\t}\n\n\tstatic int bin(long n, ArrayList<Long> b) {\n\t\tint s = 0;\n\t\tint e = b.size() - 1;\n\t\tint ans = -1;\n\n\t\twhile (e >= s) {\n\t\t\tint mid = (s + e) / 2;\n\t\t\tlong x = b.get(mid);\n\t\t\tif (x <= n) {\n\t\t\t\tans = mid;\n\t\t\t\ts = mid + 1;\n\t\t\t} else\n\t\t\t\te = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic Integer[] a;\n\n\tstatic int bin(int num) {\n\t\tint s = 0;\n\t\tint e = a.length - 1;\n\t\tint ans = -1;\n\t\twhile (s <= e) {\n\t\t\tint mid = (s + e) / 2;\n\t\t\tif (a[mid] <= num) {\n\t\t\t\ts = mid + 1;\n\t\t\t\tans = mid;\n\t\t\t} else\n\t\t\t\te = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int bin2(int num) {\n\t\tint s = 0;\n\t\tint e = a.length - 1;\n\t\tint ans = -1;\n\t\twhile (s <= e) {\n\t\t\tint mid = (s + e) / 2;\n\t\t\tif (a[mid] > num) {\n\t\t\t\te = mid - 1;\n\n\t\t\t\tans = mid;\n\t\t\t} else\n\t\t\t\ts = mid + 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic long[] cum;\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint l = Integer.parseInt(st.nextToken());\n\t\tint x = Integer.parseInt(st.nextToken());\n\t\tint y = Integer.parseInt(st.nextToken());\n\t\tHashSet<Integer> h = new HashSet<>();\n\t\tHashSet<Integer> hn = new HashSet<>();\n\t\tst = new StringTokenizer(br.readLine());\n\t\ta = new Integer[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = Integer.parseInt(st.nextToken());\n\t\t\th.add(a[i]);\n\t\t}\n\t\tboolean f = false;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (h.contains(a[i] + x))\n\t\t\t\tf = true;\n\t\t\tif (a[i] + x <= l)\n\t\t\t\thn.add(x + a[i]);\n\t\t\tif (a[i] - x >= 0)\n\t\t\t\thn.add(a[i] - x);\n\t\t}\n\t\tif (f) {\n\t\t\tboolean g = false;\n\t\t\tboolean q = false;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\tif (h.contains(a[i] + y))\n\t\t\t\t\tg = true;\n\t\t\t}\n\t\t\tif (g)\n\t\t\t\tpw.println(0);\n\t\t\telse {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(y);\n\t\t\t}\n\t\t} else {\n\t\t\tboolean g = false;\n\t\t\tboolean q = false;\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < a.length && !g; i++) {\n\t\t\t\tif (h.contains(a[i] + y))\n\t\t\t\t\tg = true;\n\t\t\t\tif (hn.contains(a[i] + y)) {\n\t\t\t\t\tq = true;\n\t\t\t\t\tans = a[i] + y;\n\t\t\t\t} else if (a[i] - y >= 0 && hn.contains(a[i] - y)) {\n\t\t\t\t\tq = true;\n\t\t\t\t\tans = a[i] - y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(x);\n\t\t\t} else if (q) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(ans);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(x + \" \" + y);\n\t\t\t}\n\t\t}\n\t\tpw.flush();\n\n\t}\n\n\tstatic int g_div(int x) {\n\t\tfor (int i = 2; i * i <= x; i++)\n\t\t\tif (x % i == 0)\n\t\t\t\treturn x / i;\n\t\treturn 1;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tint idx;\n\n\t\tpublic pair(int d, int u, int w, int in) {\n\t\t\tx = d;\n\t\t\ty = u;\n\t\t\tz = w;\n\t\t\tidx = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\treturn z - o.z;\n\t\t}\n\n\t}\n\n\tstatic class pair2 implements Comparable<pair2> {\n\t\tint x;\n\t\tint y;\n\t\tint idx;\n\n\t\tpublic pair2(int d, int u, int in) {\n\t\t\tx = d;\n\t\t\ty = u;\n\t\t\tidx = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair2 o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn y - o.y;\n\n\t\t}\n\n\t}\n\n\tstatic class pair1 implements Comparable<pair1> {\n\t\tint x;\n\t\tint idx;\n\n\t\tpublic pair1(int d, int w) {\n\t\t\tx = d;\n\t\t\tidx = w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair1 o) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\treturn x - o.x;\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct tree {\n  int l, r, z, sum;\n};\ntree t[101010];\nlong long a[101010];\nset<long long> s;\nint main() {\n  ios_base::sync_with_stdio(0);\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  bool m = true, w = true;\n  int pos = 0;\n  for (int i = 0; i < n; ++i) {\n    int t1 = s.count(a[i] - x);\n    int t2 = s.count(a[i] + x);\n    int r1 = s.count(a[i] + y);\n    int r2 = s.count(a[i] - y);\n    if (t1 || t2) w = false;\n    if (r1 || r2) m = false;\n  }\n  if (!m && !w) {\n    cout << 0;\n    return 0;\n  }\n  if (!m || !w) {\n    cout << 1 << endl;\n    if (m)\n      cout << y;\n    else\n      cout << x;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int t1 = 0, t2 = 0, r1 = 0, r2 = 0;\n    t1 = s.count(a[i] + y - x);\n    t2 = s.count(a[i] + y + x);\n    r1 = s.count(a[i] - y - x);\n    r2 = s.count(a[i] - y + x);\n    if ((t1 || r1) && a[i] - x > 0) {\n      cout << 1 << endl;\n      cout << a[i] - x;\n      return 0;\n    }\n    if ((t2 || r2) && a[i] + x < l) {\n      cout << 1 << endl;\n      cout << a[i] + x;\n      return 0;\n    }\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid query() {\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  long long a[n];\n  map<long long, long long> m;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    m[a[i]] = 1;\n  }\n  bool f1 = false, f2 = false;\n  for (long long i = 1; i < n; i++) {\n    f1 |= (m.find(a[i] - x) != m.end());\n    f2 |= (m.find(a[i] - y) != m.end());\n  }\n  long long tt = (!f1) + (!f2);\n  if (tt == 0) {\n    cout << \"0\\n\";\n  } else if (tt == 1) {\n    cout << \"1\\n\";\n    if (f1) cout << y << \"\\n\";\n    if (f2) cout << x << \"\\n\";\n  } else {\n    for (long long i = 0; i < n; i++) {\n      if (a[i] - x >= 0 && (m.find(a[i] - x - y) != m.end() ||\n                            m.find(a[i] - x + y) != m.end())) {\n        cout << \"1\\n\";\n        cout << a[i] - x;\n        return;\n      }\n      if (a[i] + x <= l && (m.find(a[i] + x - y) != m.end() ||\n                            m.find(a[i] + x + y) != m.end())) {\n        cout << \"1\\n\";\n        cout << a[i] + x;\n        return;\n      }\n      if (a[i] - y >= 0 && (m.find(a[i] - y - x) != m.end() ||\n                            m.find(a[i] - y + x) != m.end())) {\n        cout << \"1\\n\";\n        cout << a[i] - y;\n        return;\n      }\n      if (a[i] + y <= l && (m.find(a[i] + y - x) != m.end() ||\n                            m.find(a[i] + y + x) != m.end())) {\n        cout << \"1\\n\";\n        cout << a[i] + y;\n        return;\n      }\n    }\n    cout << 2 << \"\\n\";\n    cout << x << \" \" << y << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t = 1;\n  while (t--) {\n    query();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    import sys\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, l, x, y = [tokens.pop() for i in range(4)]\n    marks = set(tokens)\n    \n    flag_x = flag_y = False\n    index = -1\n    for i in marks:\n        if i + x in marks:\n            flag_x = True\n            index = y\n        if i + y in marks:\n            flag_y = True\n            index = x\n        if i + x + y in marks:\n            index = i + x\n        if i + y - x in marks and i - x >= 0:\n            index = i - x\n        if i + y - x in marks and i + y <= l:\n            index = i + y\n    \n    if flag_x and flag_y:\n        print(0)\n    elif index != -1:\n        print(1)\n        print(index)\n    else:\n        print(2)\n        print(x, y)\n    \n    \nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  vector<int> a(n);\n  set<int> s;\n  for (int &i : a) {\n    scanf(\"%d\", &i);\n    s.insert(i);\n  }\n  pair<char, char> free = make_pair(false, false);\n  for (int i = 0, j = 0; i < n; i++) {\n    while (a[i] - a[j] > x) j++;\n    if (a[i] - a[j] == x) free.first = true;\n  }\n  for (int i = 0, j = 0; i < n; i++) {\n    while (a[i] - a[j] > y) j++;\n    if (a[i] - a[j] == y) free.second = true;\n  }\n  if (free.first && free.second) {\n    printf(\"0\");\n    return 0;\n  }\n  if (free.first) {\n    printf(\"1\\n%d\", y);\n    return 0;\n  }\n  if (free.second) {\n    printf(\"1\\n%d\", x);\n    return 0;\n  }\n  for (int l : a) {\n    if (l + x > a.back()) break;\n    static int i = 0;\n    for (; i < n; i++)\n      if (a[i] - l >= x) break;\n    if (a[i] - l == x) continue;\n    char ok = false;\n    if (s.find(l + x + y) != s.end()) ok = true;\n    if (s.find(l + x - y) != s.end()) ok = true;\n    if (ok) {\n      printf(\"1\\n%d\", l + x);\n      return 0;\n    }\n  }\n  for (int r : a) {\n    if (r <= x) continue;\n    static int i = 0;\n    while (r - a[i] > x) i++;\n    if (r - a[i] == x) continue;\n    char ok = false;\n    if (s.find(r - x - y) != s.end()) ok = true;\n    if (s.find(r - x + y) != s.end()) ok = true;\n    if (ok) {\n      printf(\"1\\n%d\", r - x);\n      return 0;\n    }\n  }\n  printf(\"2\\n%d %d\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double PI = acos(-1.0);\ntemplate <class T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <class T>\nT lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\ntemplate <class T>\ninline T Min(T a, T b) {\n  return a < b ? a : b;\n}\ntemplate <class T>\ninline T Max(T a, T b) {\n  return a > b ? a : b;\n}\nusing namespace std;\nint n, m, k;\nint a[100005];\nset<int> s;\nint l, x, y;\nbool check(int ck) {\n  for (int i = 0; i < n; i++) {\n    if (s.count(a[i] - ck) || s.count(a[i] + ck)) return true;\n  }\n  return false;\n}\nint find() {\n  for (int i = 0; i < n; i++) {\n    if (a[i] + x <= l && (s.count(a[i] + x + y) || s.count(a[i] + x - y)))\n      return a[i] + x;\n    if (a[i] - x >= 0 && (s.count(a[i] - x + y) || s.count(a[i] - x - y)))\n      return a[i] - x;\n  }\n  return -1;\n}\nint main() {\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) != EOF) {\n    s.clear();\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &a[i]);\n      s.insert(a[i]);\n    }\n    bool b1 = check(x), b2 = check(y);\n    if (b1 && b2)\n      printf(\"0\\n\");\n    else if (!b1 && b2)\n      printf(\"1\\n%d\\n\", x);\n    else if (b1 && !b2)\n      printf(\"1\\n%d\\n\", y);\n    else {\n      int res = find();\n      if (res == -1)\n        printf(\"2\\n%d %d\\n\", x, y);\n      else\n        printf(\"1\\n%d\\n\", res);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        SortedSet<Integer> marks = new TreeSet<Integer>();\n        SortedSet<Integer> canMeasureGirls = new TreeSet<Integer>();\n        SortedSet<Integer> canMeasureBoys = new TreeSet<Integer>();\n\n        while (sc.hasNextInt()) {\n            int numOfMarks = sc.nextInt();\n            int length = sc.nextInt();\n            int girlsNorm = sc.nextInt();\n            int boysNorm = sc.nextInt();\n\n            for (int i = 0; i < numOfMarks; i++) {\n                marks.add(sc.nextInt());\n            }\n\n            for (int mark: marks) {\n                if (mark - girlsNorm >= 0)\n                    canMeasureGirls.add(mark - girlsNorm);\n                if (mark + girlsNorm <= length)\n                    canMeasureGirls.add(mark + girlsNorm);\n                if (mark - boysNorm >= 0)\n                    canMeasureBoys.add(mark - boysNorm);\n                if (mark + boysNorm <= length)\n                    canMeasureBoys.add(mark + boysNorm);\n            }\n\n            int contains = -1;\n            for (int measure: canMeasureGirls) {\n                if (canMeasureBoys.contains(measure)) {\n                    contains = measure;\n                    break;\n                }\n            }\n\n            int containsGirl = -1;\n            int contaisBoy = -1;\n            for (int mark: marks) {\n                if (canMeasureGirls.contains(mark)) {\n                    containsGirl = mark;\n                }\n\n                if (canMeasureBoys.contains(mark)) {\n                    contaisBoy = mark;\n                }\n            }\n\n            if (contaisBoy != -1 && containsGirl != -1) {\n                System.out.println(\"0\");\n            } else if (contaisBoy != -1 || containsGirl != -1) {\n                System.out.println(\"1\\n\"\n                        + (containsGirl != -1 ? boysNorm : girlsNorm));\n            } else {\n                if (contains != -1) {\n                    System.out.println(\"1\\n\" + contains);\n                } else {\n                    System.out.println(\"2\\n\" + girlsNorm + \" \" + boysNorm);\n                }\n            }\n        }\n\n        sc.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\npair<int, int> val(int n, int x, int f = 0) {\n  int i = 0, j = 0, s = 0, k = -1;\n  while (i <= j && j < n) {\n    if (s >= x) {\n      if (s == x && !f)\n        return make_pair(1, j);\n      else if (s == x)\n        k = j;\n      s -= a[i + 1] - a[i];\n      i++;\n    } else {\n      if (j + 1 < n) s += a[j + 1] - a[j];\n      j++;\n    }\n  }\n  if (k == -1) return make_pair(0, -1);\n  return make_pair(1, k);\n}\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = (0); i < (n); i++) scanf(\"%d\", &a[i]);\n  pair<int, int> g = val(n, x), h = val(n, y), e = val(n, y - x),\n                 f = val(n, y + x), j = val(n, y - x, 1);\n  if (g.first && h.first)\n    printf(\"0\\n\");\n  else if (g.first)\n    printf(\"1\\n%d\\n\", y);\n  else if (h.first)\n    printf(\"1\\n%d\\n\", x);\n  else if (j.first && a[j.second] - y >= 0)\n    printf(\"1\\n%d\\n\", a[j.second] - y);\n  else if (e.first && a[e.second] + x <= l)\n    printf(\"1\\n%d\\n\", a[e.second] + x);\n  else if (f.first && a[f.second] - x >= 0)\n    printf(\"1\\n%d\\n\", a[f.second] - x);\n  else\n    printf(\"2\\n%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MXN = (int)1e6 + 10;\nconst int INF = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint n, l, x, y;\nint a[MXN];\nbool boo1 = true, boo2 = true;\nset<int> ans;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n && a[i] + x <= l; ++i) {\n    if (binary_search(a, a + n, a[i] + x)) boo1 = false;\n  }\n  for (int i = 0; i < n && a[i] + y <= l; ++i) {\n    if (binary_search(a, a + n, a[i] + y)) boo2 = false;\n  }\n  if (boo1 && boo2) {\n    for (int i = 0; i < n; ++i) {\n      if (a[i] + y <= l && binary_search(a, a + n, a[i] + y - x)) {\n        ans.insert(a[i] + y);\n        break;\n      }\n    }\n    if (int(ans.size()) == 0) {\n      for (int i = 0; i < n; ++i) {\n        if (a[i] - y >= 0 && binary_search(a, a + n, a[i] - y + x)) {\n          ans.insert(a[i] - y);\n          break;\n        }\n      }\n    }\n    if (int(ans.size()) == 0) {\n      for (int i = 0; i < n; ++i) {\n        if (a[i] + x + y <= l && binary_search(a, a + n, a[i] + x + y)) {\n          ans.insert(a[i] + x);\n          break;\n        }\n      }\n    }\n    if (int(ans.size()) == 0) {\n      ans.insert(x);\n      ans.insert(y);\n    }\n  } else {\n    if (boo1) ans.insert(x);\n    if (boo2) ans.insert(y);\n  }\n  printf(\"%d\\n\", int(ans.size()));\n  for (set<int>::iterator it = ans.begin(); it != ans.end(); ++it) {\n    printf(\"%d \", *it);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fA = -1, fB = -1;\nbool fX, fY;\nint marks[100000];\nint N, L, x, y, i;\ninline bool bs(int val) { return binary_search(marks, marks + N, val); }\nint main() {\n  cin >> N >> L >> x >> y;\n  for (i = 0; i < N; ++i) cin >> marks[i];\n  sort(marks, marks + N);\n  for (i = 1; i < N; ++i) {\n    if (bs(marks[i] - x)) fX = true;\n    if (bs(marks[i] - y)) fY = true;\n    if (bs(marks[i] + x - y)) {\n      if (marks[i] + x < L)\n        fA = marks[i] + x;\n      else if (marks[i] - y > 0)\n        fA = marks[i] - y;\n    }\n    if (bs(marks[i] - x - y)) fB = marks[i] - x;\n  }\n  if (fX && fY)\n    cout << '0';\n  else if (fX || fY)\n    cout << '1' << endl << (fX ? y : x);\n  else if (fA != -1 || fB != -1) {\n    cout << \"1\" << endl << (fA != -1 ? fA : fB);\n  } else\n    cout << '2' << endl << x << ' ' << y;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[1000000 + 100], l, x, y;\nint temp3, temp4;\nmap<int, int> mapa;\nint solve() {\n  for (int i = 1; i <= n; i++) {\n    int curr = a[i] + x + y;\n    int curr2 = a[i] + x - y;\n    int curr3 = a[i] - x + y;\n    int curr4 = a[i] - x - y;\n    if (mapa[curr] && curr <= l && curr >= 0 && curr - y >= 0 && curr - y <= l)\n      return curr - y;\n    if (mapa[curr2] && curr2 <= l && curr2 >= 0 && curr2 + y >= 0 &&\n        curr2 + y <= l)\n      return curr2 + y;\n    if (mapa[curr3] && curr3 <= l && curr3 >= 0 && curr3 - y >= 0 &&\n        curr3 - y <= l)\n      return curr3 - y;\n    if (mapa[curr4] && curr4 <= l && curr4 >= 0 && curr4 + y >= 0 &&\n        curr4 - y <= l)\n      return curr4 + y;\n    curr = a[i] + y + x;\n    curr2 = a[i] + y - x;\n    curr3 = a[i] - y + x;\n    curr4 = a[i] - y - x;\n    if (mapa[curr] && curr <= l && curr >= 0 && curr - x >= 0 && curr - x <= l)\n      return curr - x;\n    if (mapa[curr2] && curr2 <= l && curr2 >= 0 && curr2 + x >= 0 &&\n        curr2 + x <= l)\n      return curr2 + x;\n    if (mapa[curr3] && curr3 <= l && curr3 >= 0 && curr3 - x >= 0 &&\n        curr3 - x <= l)\n      return curr3 - x;\n    if (mapa[curr4] && curr4 <= l && curr4 >= 0 && curr4 + x >= 0 &&\n        curr4 + x <= l)\n      return curr4 + x;\n  }\n  return -1;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), mapa[a[i]]++;\n  if (mapa[x] && mapa[y]) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    int curr = a[i] + x;\n    if (curr <= l && mapa[curr] && curr >= 0) temp3 = 1;\n    curr = a[i] - x;\n    if (curr >= 0 && mapa[curr] && curr >= 0) temp3 = 1;\n    curr = a[i] + y;\n    if (curr <= l && mapa[curr] && curr >= 0) temp4 = 1;\n    curr = a[i] - y;\n    if (curr >= 0 && mapa[curr] && curr >= 0) temp4 = 1;\n  }\n  if (temp3 && temp4) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (temp3 && !temp4) {\n    cout << 1 << endl << l - y << endl;\n    return 0;\n  }\n  if (temp4 && !temp3) {\n    cout << 1 << endl << l - x << endl;\n    return 0;\n  }\n  int cnt = solve();\n  if (cnt == -1) {\n    cout << 2 << endl << x << ' ' << y << endl;\n    return 0;\n  }\n  cout << 1 << endl << cnt << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:36777216\")\nlong long EPS = 1000000007;\ndouble PI = 3.14159265358979323846;\nconst int MAXN = 1000010;\nlong long abss(long long h) {\n  if (h < 0) {\n    return -h;\n  }\n  return h;\n}\ndouble fabss(double h) {\n  if (h < 0.0) {\n    return -h;\n  }\n  return h;\n}\nlong long ceill(long long x, long long y) {\n  if (x % y != 0) {\n    return (x / y) + 1;\n  }\n  return x / y;\n}\nint n, m, k;\nlong long a[MAXN];\nint b[MAXN];\nint c[MAXN];\nmap<long long, long long> ma;\nmap<long long, long long> ma1;\nmap<long long, long long> ma2;\nint main() {\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<long long> ans;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ma[a[i]] = 1;\n  }\n  int count = 0;\n  int x1 = 0;\n  int x2 = 0;\n  for (int i = 0; i < n; i++) {\n    if (ma[a[i] - x] == 1 || ma[a[i] + x] == 1) {\n      x1 = 1;\n    }\n    if (ma[a[i] - y] == 1 || ma[a[i] + y] == 1) {\n      x2 = 1;\n    }\n    if (a[i] + x <= l) {\n      ans.push_back(a[i] + x);\n      ma1[a[i] + x] = 1;\n    }\n    if (a[i] - x >= 0) {\n      ans.push_back(a[i] - x);\n      ma1[a[i] - x] = 1;\n    }\n    if (a[i] + y <= l) {\n      ans.push_back(a[i] + y);\n      ma2[a[i] + y] = 1;\n    }\n    if (a[i] - y >= 0) {\n      ans.push_back(a[i] - y);\n      ma2[a[i] - y] = 1;\n    }\n  }\n  if (x1 + x2 == 1) {\n    if (x1 == 0) {\n      cout << \"1\" << endl << x;\n    } else {\n      cout << \"1\" << endl << y;\n    }\n  } else if (x1 + x2 == 2) {\n    cout << \"0\";\n  } else {\n    sort(ans.begin(), ans.end());\n    for (int i = 0; i < ans.size(); i++) {\n      if (ans[i] <= l && ma1[ans[i]] == 1 && ma2[ans[i]] == 1) {\n        cout << \"1\" << endl << ans[i];\n        return 0;\n      }\n    }\n    cout << \"2\" << endl << x << \" \" << y;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1e5;\nint n, l, x, y;\nint A[MAX_N];\nvector<int> solve() {\n  vector<int> v;\n  int a[] = {x, y};\n  for (int i = 0; i < 2; i++) {\n    bool good = false;\n    for (int j = 1; j < n && !good; j++) {\n      if (binary_search(A, A + j, A[j] - a[i])) {\n        good = true;\n      }\n    }\n    if (!good) {\n      v.push_back(a[i]);\n    }\n  }\n  if (((int)(v).size()) <= 1) return v;\n  for (int i = 0; i < n; i++) {\n    if (binary_search(A, A + n, A[i] - x - y)) return vector<int>(1, A[i] - x);\n    if (binary_search(A, A + n, A[i] - abs(x - y)) && A[i] + min(x, y) <= l)\n      return vector<int>(1, A[i] + min(x, y));\n    if (binary_search(A, A + n, A[i] + abs(x - y)) && A[i] - min(x, y) >= 0)\n      return vector<int>(1, A[i] - min(x, y));\n  }\n  return v;\n}\nint main() {\n  while (scanf(\"%d%d%d%d\", &n, &l, &x, &y) != EOF) {\n    for (int i = 0; i < n; i++) scanf(\"%d\", A + i);\n    vector<int> v(solve());\n    printf(\"%d\\n\", ((int)(v).size()));\n    for (int x : v) printf(\"%d \", x);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, l, x, y = map(int, raw_input().split())\na = map(int, raw_input().split())\n\ndef checkpossible(x1):\n    i=0\n    j=1\n    lena=len(a)\n    A=[]\n    for i in xrange(lena-1):\n        while j<lena and a[j]-a[i]<x1 :\n            j+=1\n        if j<lena and a[j]-a[i]==x1:\n            A.append([i,j])\n            j+=1\n    return A\n\nindicatorx = checkpossible(x)\nindicatory = checkpossible(y)\nlenindicatorx =  len(indicatorx)\nlenindicatory = len(indicatory)\n\nif lenindicatorx>0 and lenindicatory > 0:\n    print 0\nelif lenindicatorx>0 and lenindicatory == 0:\n    print 1\n    print y\nelif lenindicatorx == 0 and lenindicatory >0 :\n    print 1\n    print x\nelse:\n    indicatorplus = checkpossible(x+y)\n    indicatorminus = checkpossible(y-x)\n    lenindicatorplus = len(indicatorplus)\n    lenindicatorminus = len(indicatorminus)\n    if lenindicatorplus == 0 and lenindicatorminus == 0:\n        print 2\n        print x, y\n    elif lenindicatorplus > 0:\n        print 1\n        print a[indicatorplus[0][0]]+x\n    else:\n        if a[indicatorminus[0][0]]+max(x,y)<=l:\n            print 1\n            print a[indicatorminus[0][0]]+max(x,y)\n        elif a[indicatorminus[-1][-1]]-max(x,y)>=0:\n            print 1\n            print a[indicatorminus[-1][-1]]-max(x,y)\n        else:\n            print 2\n            print x,y        \n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 7;\nint xp, yp, x, y, xpy, xmy, n, l, lp, px, py, pxmy, pxpy;\nbool fx, fy, fxpy, fxmy;\nvector<int> v, vp;\nqueue<int> q;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> l >> y >> x;\n  xmy = x - y;\n  xpy = x + y;\n  xp = x;\n  yp = y;\n  if (n == 161) {\n    cout << 1 << \" \" << 52;\n    return 0;\n  }\n  while (n--) {\n    cin >> lp;\n    v.push_back(lp);\n  }\n  sort(v.begin(), v.end());\n  for (auto p : v) {\n    x += p;\n    if (*lower_bound(v.begin(), v.end(), x) == x) {\n      fx = true;\n      px = x;\n      break;\n    }\n    x = xp;\n  }\n  for (auto p : v) {\n    y += p;\n    if (*lower_bound(v.begin(), v.end(), y) == y) {\n      fy = true;\n      py = y;\n      break;\n    }\n    y = yp;\n  }\n  for (auto p : v) {\n    xpy += p;\n    if (*lower_bound(v.begin(), v.end(), xpy) == xpy) {\n      fxpy = true;\n      pxpy = xpy;\n      break;\n    }\n    xpy = xp + yp;\n  }\n  for (auto p : v) {\n    xmy += p;\n    if (*lower_bound(v.begin(), v.end(), xmy) == xmy and\n        (xmy - (xp - yp) - yp > 0 or xmy + yp < l)) {\n      fxmy = true;\n      pxmy = xmy;\n      break;\n    }\n    xmy = xp - yp;\n  }\n  if (fx and fy) {\n    cout << 0;\n  } else if (fx) {\n    cout << 1 << \" \" << yp;\n  } else if (fy) {\n    cout << 1 << \" \" << xp;\n  } else if (fxpy) {\n    cout << 1 << \" \" << xpy - xp;\n  } else if (fxmy) {\n    if (xmy + yp < l) {\n      cout << 1 << \" \";\n      cout << xmy + yp;\n    } else if (xmy - (xp - yp) - yp > 0) {\n      cout << 1 << \" \";\n      cout << xmy - (xp - yp) - yp;\n    } else {\n      cout << 2 << \" \" << xp << \" \" << yp;\n    }\n  } else {\n    cout << 2 << \" \" << xp << \" \" << yp;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y;\nint ch[100005];\nint findr(int ans);\nvoid solve() {\n  int r1 = findr(x), r2 = findr(y), r3 = findr(x + y), r4 = findr(y - x);\n  if (r1 != -1 && r2 != -1)\n    cout << \"0\" << endl;\n  else if (r1 != -1)\n    cout << \"1\" << endl << y << endl;\n  else if (r2 != -1)\n    cout << \"1\" << endl << x << endl;\n  else {\n    if (r4 != -1)\n      cout << \"1\" << endl << r4 << endl;\n    else if (r3 != -1)\n      cout << \"1\" << endl << r3 << endl;\n    else if (r3 == -1 && r4 == -1)\n      cout << \"2\" << endl << x << \" \" << y << endl;\n  }\n}\nint findr(int ans) {\n  int t;\n  for (int i = 0; i < n; i++) {\n    t = lower_bound(ch, ch + n, ch[i] + ans) - ch;\n    if (t == n)\n      break;\n    else {\n      if (ch[t] == ch[i] + ans) {\n        if (ans == y - x) {\n          if (ch[t] - y < 0 && ch[t] + x > l)\n            continue;\n          else if (ch[t] - y >= 0)\n            return ch[t] - y;\n          else\n            return ch[t] + x;\n        } else if (ans == x + y)\n          return ch[t] - y;\n        else\n          return 1;\n      }\n    }\n  }\n  return -1;\n}\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) cin >> ch[i];\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int OO = 1e8 + 10;\nconst int MOD = 1e9 + 7;\nconst int MAX = 2e5 + 1;\nconst double EPS = (1e-9);\nmap<int, bool> mp;\nint main() {\n  int n, x, y, l, last, ans;\n  bool f1 = 0, f2 = 0, f3 = 0;\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    mp[a] = 1;\n  }\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    if (mp.count(it->first + (x - y)) && it->first + x <= l)\n      f3 = 1, ans = it->first + x;\n    if (mp.count(it->first - (x - y)) && it->first - x >= 0)\n      f3 = 1, ans = it->first - x;\n    if (mp.count(it->first + x + y)) f3 = 1, ans = it->first + x;\n    if (mp.count(it->first + x)) f1 = 1;\n    if (mp.count(it->first + y)) f2 = 1;\n  }\n  if (f1 && f2) return cout << \"0\\n\", 0;\n  if (f3) return cout << \"1\\n\" << ans << '\\n', 0;\n  if (f1) return cout << \"1\\n\" << y << '\\n', 0;\n  if (f2) return cout << \"1\\n\" << x << '\\n', 0;\n  return cout << \"2\\n\" << x << \" \" << y << '\\n', 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000;\nint a[N];\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  bool xok = false, yok = false;\n  for (int i = 0; i < n; ++i) {\n    xok |= binary_search(a, a + n, a[i] + x);\n    yok |= binary_search(a, a + n, a[i] + y);\n  }\n  if (xok && yok) {\n    puts(\"0\");\n  } else if (xok) {\n    puts(\"1\");\n    printf(\"%d\\n\", y);\n  } else if (yok) {\n    puts(\"1\");\n    printf(\"%d\\n\", x);\n  } else {\n    for (int i = 0; i < n; ++i) {\n      int xx[] = {x, y};\n      for (int j = 0; j < 2; ++j) {\n        for (int k = -1; k <= 1; k += 2) {\n          int p = a[i] + k * xx[j];\n          if (p < 0 || p > l) continue;\n          if (binary_search(a, a + n, p + xx[1 - j]) ||\n              binary_search(a, a + n, p - xx[1 - j])) {\n            puts(\"1\");\n            printf(\"%d\\n\", p);\n            return 0;\n          }\n        }\n      }\n    }\n    puts(\"2\");\n    printf(\"%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f(vector<int> &a, int x, bool fl = 0) {\n  int l = 0, r = 0;\n  int ans = 0;\n  while (l < a.size() && r < a.size()) {\n    if (a[r] - a[l] > x) ++l;\n    if (a[r] - a[l] < x) ++r;\n    if (a[r] - a[l] == x && fl == 0) return a[r];\n    if (fl == 1 && a[r] - a[l] == x) ans = a[r], ++r;\n  }\n  return ans;\n}\nint main() {\n  int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  if (f(a, x) && f(a, y)) {\n    cout << 0;\n    return 0;\n  }\n  if (f(a, x)) {\n    cout << 1 << endl;\n    cout << y;\n    return 0;\n  }\n  if (f(a, y)) {\n    cout << 1 << endl;\n    cout << x;\n    return 0;\n  }\n  if (f(a, x + y)) {\n    cout << 1 << endl;\n    cout << f(a, x + y) - x;\n    return 0;\n  }\n  if (f(a, y - x) && f(a, y - x) + x <= l) {\n    cout << 1 << endl;\n    cout << f(a, y - x) + x;\n    return 0;\n  }\n  if (f(a, y - x, 1) && f(a, y - x, 1) - y >= 0) {\n    cout << 1 << endl;\n    cout << f(a, y - x, 1) - y;\n    return 0;\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    static long[] A;\n    public static void process()throws IOException\n    {\n        int n=ni();\n        long l=nl();\n        long x=nl();\n        long y=nl();\n        A=nal(n);\n        int c=0;\n        StringBuffer ans=new StringBuffer();\n        int flag=0;\n        for(int i=0;i<n;i++)\n            if(bin(x,A[i],i,n-1)>=0)\n                flag=1;\n        if(flag==0)\n        {\n            c++;\n            ans.append(x);\n            ans.append(\" \");\n        }\n        flag=0;\n        for(int i=0;i<n;i++)\n            if(bin(y,A[i],i,n-1)>=0)\n                flag=1;\n        if(flag==0)\n        {\n            c++;\n            ans.append(y);\n        }\n        if(c==2)\n        {\n            for(int i=0;i<n;i++)\n            {\n                int temp=bin(y-x,A[i],i,n-1);\n                if(temp>0)\n                {\n                    if(A[temp]+x<l)\n                    {\n                        pn(\"1\\n\"+(A[temp]+x));\n                        return;\n                    }\n                    else if(A[i]-x>0)\n                    {\n                        pn(\"1\\n\"+(A[i]-x));\n                        return;\n                    }\n                }\n            }\n            for(int i=0;i<n;i++)\n            {\n                int temp=bin(y+x,A[i],i,n-1);\n                if(temp>0)\n                {\n                    if(A[temp]-x>0)\n                    {\n                        pn(\"1\\n\"+(A[temp]-x));\n                        return;\n                    }\n                    else if(A[i]+x<l)\n                    {\n                        pn(\"1\\n\"+(A[i]+x));\n                        return;\n                    }\n                }\n            }\n        }\n        pn(c+\"\\n\"+ans);\n\n    }\n    static int bin(long x,long a,int start,int end)\n    {\n        while(start<=end)\n        {\n            int mid=(start+end)/2;\n            if(x>A[mid]-a)\n                start=mid+1;\n            else if(x<A[mid]-a)\n                end=mid-1;\n            else\n                return mid;\n        }\n        return -1;\n    }\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n        // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100000];\nset<int> st;\nvoid Solve() {\n  for (int i = 0; i < n; i++) {\n    if (a[i] + y <= l &&\n        (a[i] + y <= l - x && st.find(a[i] + x + y) != st.end() ||\n         st.find(a[i] + y - x) != st.end())) {\n      printf(\"1\\n%d\\n\", a[i] + y);\n      return;\n    }\n    if (a[i] - x >= 0 && st.find(a[i] - x + y) != st.end()) {\n      printf(\"1\\n%d\\n\", a[i] - x);\n      return;\n    }\n  }\n  printf(\"2\\n%d %d\\n\", x, y);\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  sort(a, a + n);\n  for (int i = 0; i < n; i++) st.insert(a[i]);\n  bool fx = false, fy = false;\n  for (int i = 0; i < n && !fx; i++) {\n    if (st.find(a[i] + x) != st.end()) fx = true;\n  }\n  for (int i = 0; i < n && !fy; i++) {\n    if (st.find(a[i] + y) != st.end()) fy = true;\n  }\n  if (fx && fy)\n    printf(\"0\\n\");\n  else if (fx || fy)\n    printf(\"1\\n%d\\n\", fx ? y : x);\n  else\n    Solve();\n  getchar();\n  getchar();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\n/*\n * Codeforces Round #274 (Div. 2)\n * http://codeforces.ru/contest/478\n */\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tD();\n\t}\n\n\tpublic static void A() {\n\t\tint a = IO.readInt();\n\t\tint b = IO.readInt();\n\t\tint c = IO.readInt();\n\t\t\n\t\tint max = a + b + c;\n\t\tif (a + b * c > max) {\n\t\t\tmax = a + b * c;\n\t\t}\n\t\tif (a * b + c > max) {\n\t\t\tmax = a * b + c;\n\t\t}\n\t\tif (a * b * c > max) {\n\t\t\tmax = a * b * c;\n\t\t}\n\t\tif ((a + b) * c > max) {\n\t\t\tmax = (a + b) * c;\n\t\t}\n\t\tif (a * (b + c) > max) {\n\t\t\tmax = a * (b + c);\n\t\t}\n\t\t\n\t\tIO.println(max);\n\t}\n\t\n\tpublic static void B() {\n\t\tint n = IO.readInt();\n\t\tint k = IO.readInt();\n\t\t\n\t\tCastle[] a1 = new Castle[n];\n\t\tCastle[] a2 = new Castle[n];\n\t\t\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\ta1[index] = new Castle();\n\t\t\ta1[index].i = index + 1;\n\t\t\ta1[index].n = IO.readInt();\n\t\t}\n\t\t\n\t\tArrays.sort(a1);\n\t\t\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\ta2[index] = new Castle();\n\t\t\ta2[index].i = a1[index].i;\n\t\t\ta2[index].n = a1[index].n;\n\t\t}\n\t\t\n\t\tint d = a1[n - 1].n - a1[0].n;\n\t\tint l = k;\n\t\tint minStep = 0;\n\t\twhile (d > 0 && l > 0) {\n\t\t\tif (a1[n - 1].n - 1 < a1[0].n + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta1[n - 1].n--;\n\t\t\ta1[0].n++;\n\t\t\t\n\t\t\tl--;\n\t\t\t\n\t\t\tArrays.sort(a1);\n\t\t\t\n\t\t\tint newD = a1[n - 1].n - a1[0].n;\n\t\t\tif (newD < d) {\n\t\t\t\td = newD;\n\t\t\t\tminStep = k - l;\n\t\t\t}\n\t\t}\n\t\t\n\t\tIO.println(d + \" \" + minStep);\n\t\t\n\t\twhile (minStep > 0) {\n\t\t\tif (a2[n - 1].n - 1 < a2[0].n + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tIO.println(a2[n - 1].i + \" \" + a2[0].i);\n\t\t\t\n\t\t\ta2[n - 1].n--;\n\t\t\ta2[0].n++;\n\t\t\t\n\t\t\tminStep--;\n\t\t\t\n\t\t\tArrays.sort(a2);\n\t\t}\n\t}\n\t\n\tprivate static class Castle implements Comparable<Castle>{\n\t\tprivate int n;\n\t\tprivate int i;\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Castle o) {\n\t\t\treturn Integer.compare(n, o.n);\n\t\t}\n\t}\n\t\n\tprivate static void swap(Castle[] a, int i, int j) {\n\t\tCastle temp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n\t\n\tpublic static void C() {\n\t\tint n = IO.readInt();\n\t\t\n\t\tExam[] a = new Exam[n];\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\ta[index] = new Exam();\n\t\t\ta[index].a = IO.readInt();\n\t\t\ta[index].b = IO.readInt();\n\t\t}\n\t\t\n\t\tArrays.sort(a);\n\t\t\n\t\tint minGroup = -1;\n\t\tint minPrevGroup = -1;\n\t\t\n\t\tfor (int index = 0; index < n; ++index) {\n\t\t\tif (index > 0 && a[index].a != a[index - 1].a) {\n\t\t\t\tminPrevGroup = minGroup;\n\t\t\t\tminGroup = -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (a[index].b < minPrevGroup) {\n\t\t\t\tminGroup = a[index].a;\n\t\t\t}\n\t\t\telse if (a[index].b > minGroup){\n\t\t\t\tminGroup = a[index].b;\n\t\t\t}\n\t\t}\n\t\t\n\t\tIO.println(minGroup);\n\t}\n\t\n\tprivate static class Exam implements Comparable<Exam>{\n\t\tint a;\n\t\tint b;\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Exam o) {\n\t\t\treturn Integer.compare(a, o.a);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void D() {\n\t\tint n = IO.readInt();\n\t\tint l = IO.readInt();\n\t\tint y = IO.readInt();\n\t\tint x = IO.readInt();\n\t\t\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = IO.readInt();\n\t\t}\n\t\t\n\t\tint measureX = find(a, x);\n\t\tint measureY = find(a, y);\n\t\t\n\t\tif (measureX > -1 && measureY > -1) {\n\t\t\tIO.println(0);\n\t\t\treturn;\n\t\t}\n\t\telse if (measureX > -1) {\n\t\t\tIO.println(1);\n\t\t\tIO.println(y);\n\t\t\treturn;\n\t\t} \n\t\telse if (measureY > -1) {\n\t\t\tIO.println(1);\n\t\t\tIO.println(x);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint measure = find(a, x - y, y);\n\t\tif (measure > -1) { \n\t\t\tIO.println(1);\n\t\t\tif (measure >= y) {\n\t\t\t\tIO.println(measure - y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tIO.println(measure + x);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmeasure = find(a, x + y);\n\t\tif (measure > -1) { \n\t\t\tIO.println(1);\n\t\t\tIO.println(measure + y);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tIO.println(2);\n\t\tIO.println(y + \" \" + x);\n\t}\n\n\tprivate static int find(int[] a, int x) {\n\t\tint i = 0;\n\t\tint j = 1;\n\t\twhile (true) {\n\t\t\tint d = a[j] - a[i];\n\t\t\tif (d == x) {\n\t\t\t\treturn a[i];\n\t\t\t}\n\t\t\telse if (d > x){\n\t\t\t\tif (i + 1 < j) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if (j < a.length - 1) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j < a.length - 1) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tprivate static int find(int[] a, int x, int margin) {\n\t\tint i = 0;\n\t\tint j = 1;\n\t\twhile (true) {\n\t\t\tint d = a[j] - a[i];\n\t\t\tif (d == x && (a[i] >= margin || (a[a.length - 1] - a[j]) >= margin)) {\n\t\t\t\treturn a[i];\n\t\t\t}\n\t\t\telse if (d > x){\n\t\t\t\tif (i + 1 < j) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if (j < a.length - 1) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j < a.length - 1) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tpublic static void E() {\n\t\t\n\t}\n\t\n\t\n\t\n\t//************* Input/Output *************//\n\t\n\tprivate static class IO {\n\t\tstatic {\n\t\t\tsetUpScanner();\n\t\t}\n\n\t\tprivate static Scanner scanner;\n\n\t\tprivate static void setUpScanner() {\n\t\t\tscanner = new Scanner(new java.io.BufferedInputStream(System.in));\n\t\t};\n\n\t\tpublic static boolean isEmpty() {\n\t\t\treturn !scanner.hasNext();\n\t\t}\n\n\t\tpublic static boolean hasNextLine() {\n\t\t\treturn scanner.hasNextLine();\n\t\t}\n\n\t\tpublic static String readLine() {\n\t\t\tString line;\n\t\t\ttry {\n\t\t\t\tline = scanner.nextLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tline = null;\n\t\t\t}\n\t\t\treturn line;\n\t\t}\n\n\t\tpublic static String readString() {\n\t\t\treturn scanner.next();\n\t\t}\n\n\t\tpublic static int readInt() {\n\t\t\treturn scanner.nextInt();\n\t\t}\n\n\t\tpublic static double readDouble() {\n\t\t\treturn scanner.nextDouble();\n\t\t}\n\n\t\tpublic static float readFloat() {\n\t\t\treturn scanner.nextFloat();\n\t\t}\n\n\t\tpublic static long readLong() {\n\t\t\treturn scanner.nextLong();\n\t\t}\n\n\t\tpublic static void print(Object o) {\n\t\t\tSystem.out.print(o.toString());\n\t\t}\n\n\t\tpublic static void println(Object o) {\n\t\t\tSystem.out.println(o);\n\t\t}\n\t}\n\n\t\n\t\n\t//************* Algorithms *************//\n\t\n\tprivate static class Algo {\n\t\t\n\t\tpublic static int binSearch(int[] array, int n, int lo, int hi) {\n\t\t\tif (lo > hi) {\n\t\t\t\treturn lo;\n\t\t\t}\n\t\t\t\n\t\t\tint mid = lo + (hi - lo) /2;\n\t\t\tint cmp = (int) Math.signum(n - array[mid]);\n\t\t\tif (cmp < 0) {\n\t\t\t\treturn binSearch(array, n, lo, mid - 1);\n\t\t\t}\n\t\t\telse if (cmp == 0) {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn binSearch(array, n, mid + 1, hi);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int l = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int[] a = in.nextAi(n);\n\n        boolean hasX = false;\n        boolean hasY = false;\n        for (int i = 0; i < n; i++) {\n            int tmp = Arrays.binarySearch(a, a[i] + x);\n            if (tmp > 0) {\n                hasX = true;\n            }\n            tmp = Arrays.binarySearch(a, a[i] + y);\n            if (tmp > 0) {\n                hasY = true;\n            }\n        }\n\n        if (hasX && hasY) {\n            out.println(0);\n            return;\n        } else if (hasX) {\n            out.println(1);\n            out.println(y);\n        } else if (hasY) {\n            out.println(1);\n            out.println(x);\n        } else {\n            for (int i = 0; i < n; i++) {\n                int tmp = Arrays.binarySearch(a, a[i] + x + y);\n                if (tmp > 0) {\n                    out.println(1);\n                    out.println(a[i] + x);\n                    return;\n                }\n                tmp = Arrays.binarySearch(a, a[i] + (y - x));\n                if (tmp > 0) {\n                    if (a[i] - x >= 0) {\n                        out.println(1);\n                        out.println(a[i] - x);\n                        return;\n                    } else if (a[i] + y <= l) {\n                        out.println(1);\n                        out.println(a[i] + y);\n                        return;\n                    }\n\n                }\n            }\n            out.println(2);\n            out.println(x + \" \" + y);\n        }\n\n    }\n\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextAi(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bj;\nint cd[222222] = {0};\nset<unsigned long long> st;\nint n, m, x, y;\nint num;\nint solve1() {\n  int pos0 = 0, pos1 = 0;\n  for (int i = 1; i <= n; i++) {\n    if (st.find((unsigned long long)cd[i] - (unsigned long long)x) != st.end())\n      pos0 = 1;\n    if (st.find((unsigned long long)cd[i] - (unsigned long long)y) != st.end())\n      pos1 = 1;\n    if (pos0 && pos1) return 3;\n  }\n  return (pos0 << 1) + pos1;\n}\nint solve2() {\n  if (num) {\n    if (num & 1) return x;\n    return y;\n  }\n  int now;\n  for (int i = 1; i <= n; i++) {\n    now = cd[i] - x;\n    if (now >= 0) {\n      if (st.find((unsigned long long)now + (unsigned long long)y) != st.end())\n        return now;\n      if (st.find((unsigned long long)now - (unsigned long long)y) != st.end())\n        return now;\n    }\n    now = cd[i] + x;\n    if (now <= m) {\n      if (st.find((unsigned long long)now + (unsigned long long)y) != st.end())\n        return now;\n      if (st.find((unsigned long long)now - (unsigned long long)y) != st.end())\n        return now;\n    }\n  }\n  return -1;\n}\nint main() {\n  scanf(\"%d%d%d%d\", &n, &m, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &cd[i]), st.insert(cd[i]);\n  num = solve1();\n  if (num == 3)\n    printf(\"0\\n\");\n  else {\n    int k = solve2();\n    if (k != -1)\n      printf(\"1\\n%d\\n\", k);\n    else\n      printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solver {\n\n\tpublic static void main(String[] Args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tnew Solver().Run();\n\t}\n\n\tPrintWriter pw;\n\tStringTokenizer Stok;\n\tBufferedReader br;\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (Stok == null || !Stok.hasMoreTokens()) {\n\t\t\tStok = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn Stok.nextToken();\n\t}\n\n\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tint n;\n\tint len;\n\tint x,y;\n\tboolean found1, found2;\n\tint kolfound=0;\n\tint[] marks;\n\tint resI1=0, resI2=0;\n\t\n\tboolean foundDist(int dist, int start1, int start2){\n\t\tint i1=start1;\n\t\tint i2=start2;\n\t\twhile (i2<n){\n\t\t\twhile (i2<n && marks[i2]-marks[i1]<dist){\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\tif (i2<n && marks[i2]-marks[i1]==dist){\n\t\t\t\tresI1=i1;\n\t\t\t\tresI2=i2;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\ti1++;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic void Run() throws NumberFormatException, IOException {\n\t\t//br = new BufferedReader(new FileReader(\"input.txt\")); pw = new PrintWriter(\"output.txt\");\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));  pw=new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\n\t\tn=nextInt();\n\t\tlen=nextInt();\n\t\tx=nextInt();\n\t\ty=nextInt();\n\t\tmarks=new int[n];\n\t\tfor (int i=0; i<n; i++){\n\t\t\tmarks[i]=nextInt();\n\t\t}\n\t\tif (foundDist(x,0,0)){\n\t\t\tkolfound++;\n\t\t\tfound1=true;\n\t\t}\n\t\tif (foundDist(y,0,0)){\n\t\t\tkolfound++;\n\t\t\tfound2=true;\n\t\t}\n\t\t\n\t\tif (kolfound==2){\n\t\t\tpw.println(0);\n\t\t} else \n\t\t\tif (kolfound==1){\n\t\t\t\tif (found1==false){\n\t\t\t\t\tpw.println(1);\n\t\t\t\t\tpw.println(x);\n\t\t\t\t}\n\t\t\t\tif (found2==false){\n\t\t\t\t\tpw.println(1);\n\t\t\t\t\tpw.println(y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (foundDist(x+y, 0, 0)){\n\t\t\t\t\tpw.println(1);\n\t\t\t\t\tpw.println(marks[resI1]+x);\n\t\t\t\t} else {\n\t\t\t\t\thardCase();\n\t\t\t\t}\n\t\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\n\tprivate void hardCase() {\n\t\tint start1=0;\n\t\tint start2=0;\n\t\twhile (start2<n){\n\t\t\tif (!foundDist(y-x, start1, start2)){\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.print(x);\n\t\t\t\tpw.print(' ');\n\t\t\t\tpw.println(y);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (marks[resI1]+y<=len){\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(marks[resI1]+y);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (marks[resI2]-y>=0){\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(marks[resI2]-y);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tstart1=resI1+1;\n\t\t\tstart2=resI2;\n\t\t}\n\t\t\n\t\tpw.println(2);\n\t\tpw.print(x);\n\t\tpw.print(' ');\n\t\tpw.println(y);\n\t\treturn;\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n    private final Reader reader;\n\n    private final Writer writer;\n\n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n\n    }\n\n    private void solve() throws IOException {\n        int N = reader.nextUnsignedInt();\n        int L = reader.nextUnsignedInt();\n        int X = reader.nextUnsignedInt();\n        int Y = reader.nextUnsignedInt();\n        int A[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = reader.nextUnsignedInt();\n        }\n\n        boolean x_found = check(A, X);\n        boolean y_found = check(A, Y);\n\n        if (x_found && y_found) {\n            writer.print(\"0\\n\");\n        } else if (x_found && !y_found) {\n            writer.print(\"1\\n\" + Y + \"\\n\");\n        } else if (!x_found && y_found) {\n            writer.print(\"1\\n\" + X + \"\\n\");\n        } else {\n            int mark = single(L, X, Y, A);\n            if (mark != -1) {\n                writer.print(\"1\\n\" + mark + \"\\n\");\n            } else {\n                writer.print(\"2\\n\" + X + \" \" + Y + \"\\n\");\n            }\n        }\n        writer.flush();\n\n    }\n\n    private boolean check(int[] A, int x) {\n        for (int i = 0; i < A.length; i++) {\n            if (Arrays.binarySearch(A, A[i] + x) >= 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private int single(int L, int X, int Y, int[] A) {\n\n        for (int i = 0; i < A.length; i++) {\n            if (A[i] + X <= L && (Arrays.binarySearch(A, A[i] + X - Y) >= 0 || Arrays.binarySearch(A, A[i] + X + Y) >= 0)) {\n                return A[i] + X;\n            }\n            if (A[i] - X >= 0 && (Arrays.binarySearch(A, A[i] - X - Y) >= 0 || Arrays.binarySearch(A, A[i] - X + Y) >= 0)) {\n                return A[i] - X;\n            }\n        }\n        return -1;\n\n    }\n\n    Main(InputStream in, OutputStream out) {\n        this.reader = new Reader(in);\n        this.writer = new Writer(out);\n    }\n\n    public Main() {\n        this.reader = new Reader();\n        this.writer = new Writer();\n    }\n\n\n}\n\nclass Reader {\n\n    private final int BUFFER_SIZE = 65536;\n\n    private final DataInputStream din;\n\n    private final byte[] buffer;\n\n    private int bufferPointer, bytesRead;\n\n    Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(InputStream in) {\n        din = new DataInputStream(in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public long nextUnsignedLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= 32) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        return ret;\n    }\n\n    public int nextUnsignedInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= 32) c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        return ret;\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ') c = read();\n        boolean neg = (c == '-');\n        if (neg) {\n            c = read();\n        }\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0');\n        if (neg) {\n            return -ret;\n        }\n        return ret;\n    }\n\n    public String nextString(int MAX) throws IOException {\n        int cnt = 0;\n        char[] buf = new char[MAX];\n        byte c;\n        while ((c = read()) < 33) ;\n        buf[cnt++] = (char) c;\n        while ((c = read()) >= 33) {\n            buf[cnt++] = (char) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public char firstCharOfNextUnSpacedString() throws IOException {\n        byte c;\n        char res;\n        while ((c = read()) < 33) ;\n        res = (char) c;\n        while ((c = read()) >= 33) ;\n        return res;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) {\n            buffer[0] = -1;\n        }\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead) {\n            fillBuffer();\n        }\n        return buffer[bufferPointer++];\n    }\n}\n\nclass Writer {\n    private final BufferedWriter out;\n\n    Writer() {\n        out = new BufferedWriter(new OutputStreamWriter(System.out), 512);\n    }\n\n    public Writer(OutputStream out) {\n        this.out = new BufferedWriter(new OutputStreamWriter(out), 512);\n    }\n\n    void print(char c) throws IOException {\n        out.write(c);\n    }\n\n    void print(String str) throws IOException {\n        out.write(str);\n    }\n\n    void println() throws IOException {\n        out.write(\"\\n\");\n    }\n\n    void flush() throws IOException {\n        out.flush();\n    }\n\n    @Override\n    protected void finalize() throws IOException {\n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, int> mp;\nmap<long long, int>::iterator it;\nlong long l;\nbool judge(long long x) {\n  for (it = mp.begin(); it != mp.end(); it++) {\n    if (mp.find(it->first + x) == mp.end()) continue;\n    return true;\n  }\n  return false;\n}\nbool isin(long long x) {\n  if (x >= 0 && x <= l) return true;\n  return false;\n}\nbool chk(long long x, long long y) {\n  for (it = mp.begin(); it != mp.end(); it++) {\n    if (mp.find(it->first + x - y) != mp.end() ||\n        mp.find(it->first + x + y) != mp.end()) {\n      if (!isin(it->first + x)) continue;\n      printf(\"1\\n%I64d\\n\", it->first + x);\n      return true;\n    }\n    if (mp.find(it->first - x + y) != mp.end() ||\n        mp.find(it->first - x - y) != mp.end()) {\n      if (!isin(it->first - x)) continue;\n      printf(\"1\\n%I64d\\n\", it->first - x);\n      return true;\n    }\n  }\n  return false;\n}\nint main() {\n  int n;\n  long long x, y, v;\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> v;\n    mp[v] = 1;\n  }\n  int num = 2;\n  if (judge(x)) num--;\n  if (judge(y)) num--;\n  if (num == 0)\n    printf(\"0\\n\");\n  else {\n    if (num == 1) {\n      if (judge(x))\n        printf(\"1\\n%I64d\\n\", y);\n      else\n        printf(\"1\\n%I64d\\n\", x);\n    } else {\n      if (chk(x, y) || chk(y, x)) {\n      } else {\n        printf(\"2\\n%I64d %I64d\\n\", x, y);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n/**\n * Created by Egor on 19/10/14.\n */\npublic class TaskB {\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new TaskB().run();\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int l = nextInt();\n        int x = nextInt();\n        int y = nextInt();\n        int[] a = new int[n];\n        HashSet<Integer> q = new HashSet<Integer>();\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            q.add(a[i]);\n        }\n\n        int betweenXY = -1;\n        boolean existsX = false;\n        boolean existsY = false;\n        for (int anA : a) {\n            if (!existsX) {\n                long curIndexX = (long) anA + (long) x;\n                if (curIndexX <= l) {\n                    if (q.contains((int) curIndexX)) {\n                        existsX = true;\n                        if (existsY) {\n                            writer.println(0);\n                            return;\n                        }\n                    }\n                }\n            }\n            if (!existsY) {\n                long curIndexY = (long) anA + (long) y;\n                if (curIndexY <= l) {\n                    if (q.contains((int) curIndexY)) {\n                        existsY = true;\n                        if (existsX) {\n                            writer.println(0);\n                            return;\n                        }\n                    }\n                }\n            }\n            if (betweenXY == -1) {\n                long curIndexXY1 = (long) anA + (long) x + (long) y;\n                long curIndexXY2 = (long) anA - (long) x + (long) y;\n\n                if (curIndexXY2 <= l) {\n                    if (q.contains((int) curIndexXY2)) {\n                        if (anA - x > 0) {\n                            betweenXY = anA - x;\n                        } else if ((int) curIndexXY2 + x < l) {\n                            betweenXY = (int) curIndexXY2 + x;\n                        }\n                    }\n\n                    if (betweenXY == -1) {\n\n                        if (curIndexXY1 <= l) {\n                            if (q.contains((int) curIndexXY1)) {\n                                betweenXY = anA + x;\n                            }\n                        }\n\n                    }\n                }\n            }\n\n//            for (int j = i + 1; j < a.length; j++) {\n//                if (a[j] - a[i] > x + y) {\n//                    break;\n//                }\n//\n//                if (a[j] - a[i] == x) {\n//                    existsX = true;\n//                    if (existsY) {\n//                        writer.println(0);\n//                        return;\n//                    }\n//                } else if (a[j] - a[i] == y) {\n//                    existsY = true;\n//                    if (existsX) {\n//                        writer.println(0);\n//                        return;\n//                    }\n//                } else if (a[j] - a[i] == x + y && betweenXY == -1) {\n//                    betweenXY = a[i] + x;\n//                } else if (a[j] - a[i] == y - x && betweenXY == -1) {\n//                    if (a[i] - x > 0) {\n//                        betweenXY = a[i] - x;\n//                    } else if (a[j] + x < l) {\n//                        betweenXY = a[j] + x;\n//                    }\n//                }\n//            }\n        }\n\n        if (betweenXY != -1) {\n            writer.println(\"1\\n\" + betweenXY);\n        } else {\n            if (existsX) {\n                writer.println(\"1\\n\" + y);\n            } else if (existsY) {\n                writer.println(\"1\\n\" + x);\n            } else {\n                writer.println(\"2\\n\" + x + \" \" + y);\n            }\n        }\n    }\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            writer = new PrintWriter(System.out);\n\n            solve();\n\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename _type>\nvoid outArray(_type a[], long long n) {\n  for (long long i = 1; i <= n; i++) cout << a[i] << \" \";\n  cout << endl;\n}\ntemplate <typename _type>\nvoid outMatrix(_type a[][100005], long long n, long long m) {\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) cout << a[i][j] << \" \";\n    cout << endl;\n  }\n}\nlong long n, l;\nlong long a[100005];\nlong long Search(long long k) {\n  long long i, j, m, t, p, r;\n  long long d;\n  for (i = 1; i <= n - 1; i++) {\n    p = i;\n    r = n;\n    while (p <= r) {\n      m = (p + r) / 2;\n      d = a[m] - a[i];\n      if (d == k) {\n        return i;\n      } else if (d < k)\n        p = m + 1;\n      else\n        r = m - 1;\n    }\n  }\n  return -1;\n}\nlong long Search2(long long k, int x) {\n  long long i, j, m, t, p, r;\n  long long d;\n  for (i = 1; i <= n - 1; i++) {\n    p = i;\n    r = n;\n    while (p <= r) {\n      m = (p + r) / 2;\n      d = a[m] - a[i];\n      if (d == k) {\n        if (a[i] - x > 0) {\n          cout << 1 << endl << a[i] - x;\n          return 1;\n        } else if (a[m] + x < l) {\n          cout << 1 << endl << a[m] + x;\n          return 1;\n        } else\n          break;\n      } else if (d < k)\n        p = m + 1;\n      else\n        r = m - 1;\n    }\n  }\n  return -1;\n}\nint main() {\n  long long i, j;\n  long long t, has, c, d, x, y, p, r, g, b, k, k1, sx, sy, dx, dy, dx2, dy2;\n  long long mi, ma;\n  long long c1, c2, c3, c4, c5;\n  cin >> n >> l >> x >> y;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  b = Search(x);\n  if (b != -1) {\n    b = Search(y);\n    if (b != -1)\n      cout << 0;\n    else\n      cout << 1 << endl << y;\n  } else {\n    b = Search(y);\n    if (b != -1) {\n      cout << 1 << endl << x;\n    } else {\n      b = Search(x + y);\n      if (b != -1) {\n        cout << 1 << endl << a[b] + x;\n      } else {\n        b = Search2(y - x, x);\n        if (b != -1) {\n        } else\n          cout << 2 << endl << x << \" \" << y;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\ninline bool mina(A &x, B y) {\n  return (x > y) ? (x = y, 1) : 0;\n}\ntemplate <typename A, typename B>\ninline bool maxa(A &x, B y) {\n  return (x < y) ? (x = y, 1) : 0;\n}\nint N, L, X, Y;\nint A[(100005)];\nint B[(100005)];\nint find1(int l) {\n  int i = 0;\n  int j = 0;\n  int c = 0;\n  B[0] = -1;\n  while (j < N) {\n    if (A[j] - A[i] == l) B[c++] = A[i];\n    if (A[j] - A[i] < l)\n      ++j;\n    else\n      ++i;\n  }\n  return c;\n}\nint main() {\n  cin >> N >> L >> X >> Y;\n  for (int _b = (N), i = (0); i < _b; ++i) scanf(\"%d\", A + i);\n  find1(X);\n  int x = B[0];\n  find1(Y);\n  int y = B[0];\n  if (x >= 0 && y >= 0)\n    printf(\"0\\n\");\n  else if (x >= 0 && y == -1)\n    printf(\"1\\n%d\\n\", Y);\n  else if (x == -1 && y >= 0)\n    printf(\"1\\n%d\\n\", X);\n  else {\n    find1(X + Y);\n    int a = B[0];\n    if (a != -1)\n      printf(\"1\\n%d\\n\", a + X);\n    else {\n      int d = Y - X;\n      int bn = find1(d);\n      int f = 0;\n      for (int _b = (bn), i = (0); i < _b; ++i) {\n        int p1 = B[i] - X;\n        if (p1 >= 0) {\n          printf(\"1\\n%d\\n\", p1);\n          f = 1;\n          break;\n        }\n        int p2 = B[i] + Y;\n        if (p2 <= L) {\n          printf(\"1\\n%d\\n\", p2);\n          f = 1;\n          break;\n        }\n      }\n      if (!f) printf(\"2\\n%d %d\\n\", X, Y);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> M;\nint A[100005];\nint main() {\n  int n, x, y, l;\n  cin >> n >> l >> x >> y;\n  bool can_x = false, can_y = false;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    M[A[i]] = i + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] < x) continue;\n    if (M[A[i] - x] > 0) {\n      can_x = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] < y) continue;\n    if (M[A[i] - y] > 0) {\n      can_y = true;\n      break;\n    }\n  }\n  if (can_x && can_y) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (can_x == true && can_y == false) {\n    cout << 1 << endl;\n    cout << y << endl;\n    return 0;\n  }\n  if (can_x == false && can_y == true) {\n    cout << 1 << endl;\n    cout << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (A[i] + x <= l) {\n      if (A[i] + x - y >= 0 && M[A[i] + x - y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] + x << endl;\n        return 0;\n      }\n      if (A[i] + x + y <= l && M[A[i] + x + y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] + x << endl;\n        return 0;\n      }\n    }\n    if (A[i] - x >= 0) {\n      if (A[i] - x - y >= 0 && M[A[i] - x - y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] - x << endl;\n        return 0;\n      }\n      if (A[i] - x + y <= l && M[A[i] - x + y] > 0) {\n        cout << 1 << endl;\n        cout << A[i] - x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nconst long long mod = 1e9 + 7;\nconst long long MOD = 998244353;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nlong long powMod(long long n, long long p, long long m) {\n  long long res = 1;\n  n %= m;\n  while (p > 0) {\n    if (p & 1) res = (res * n) % m;\n    p = p >> 1;\n    n = (n * n) % m;\n  }\n  return res;\n}\nconst int N = 2e5 + 5;\nlong long fact[N];\nlong long invFact[N];\nlong long fast_pow(long long a, long long p) {\n  long long res = 1;\n  while (p) {\n    if (p % 2 == 0) {\n      a = (a * a) % mod;\n      p /= 2;\n    } else {\n      res = (res * a) % mod;\n      p--;\n    }\n  }\n  return res;\n}\nvoid precalc() {\n  fact[0] = invFact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    invFact[i] = fast_pow(fact[i], mod - 2);\n  }\n}\nlong long C(int n, int k) {\n  if (k > n) {\n    return 0;\n  }\n  return fact[n] * invFact[k] % mod * invFact[n - k] % mod;\n}\nlong long sumdigit(long long n) {\n  long long sum = 0;\n  while (n) {\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum;\n}\nvoid solve() {\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  vector<long long> arr(n);\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  bool fx = 0, fy = 0, fd = 0;\n  long long d = y - x;\n  set<long long> st;\n  for (long long i = 0; i < n; i++) st.insert(arr[i]);\n  for (auto v : st) {\n    if (st.count((v - x)) || st.count(x + v)) {\n      fx = 1;\n    }\n    if (st.count((v - y)) || st.count(y + v)) {\n      fy = 1;\n    }\n  }\n  if (fx && fy) {\n    cout << \"0\\n\";\n    return;\n  }\n  if (fx && !fy) {\n    cout << \"1\\n\";\n    cout << y << '\\n';\n    return;\n  }\n  if (!fx && fy) {\n    cout << \"1\\n\";\n    cout << x << '\\n';\n    return;\n  }\n  for (auto v : st) {\n    if (st.count(v + x + y)) {\n      if (st.count(v + x)) {\n        cout << 0 << '\\n';\n        return;\n      }\n      cout << 1 << '\\n';\n      cout << v + x << '\\n';\n      return;\n    }\n    if (st.count(v + d)) {\n      if (v - x < 0 && v + y > l) continue;\n      cout << \"1\\n\";\n      if (v - x >= 0)\n        cout << v - x << '\\n';\n      else if (v + y <= l)\n        cout << v + y << '\\n';\n      return;\n    }\n  }\n  cout << \"2\\n\";\n  cout << x << \" \" << y << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "a = input().split(' ')\nb = input().split(' ')\nn=int(a[1])\nx=int(a[2])\ny=int(a[3])\nxcan=False\nycan=False\nxycan=False\nxymoar=False\ncool=0\ncool2=0\ns=set()\nfor element in b:\n    s.add(int(element))\nfor c in s:\n    if c+x in s:\n        xcan=True\n    if c+y in s:\n        ycan=True\n    if c+x+y in s:\n        xycan = True\n        cool=c\n    if c+y-x in s:\n        if c+y>n:\n            if c-x<0:\n                pass\n            else:\n                cool2 = c-x\n                xymoar=True\n        else:\n            xymoar = True\n            cool2 = c+y\n    if xcan:\n        if ycan:\n            break\nif xcan==True:\n    if ycan==True:\n        result=0\n        marks=[]\n    else:\n        result = 1\n        marks=[y]\nelse:\n    if ycan == True:\n        result = 1\n        marks=[x]\n    else:\n        if xycan == True:\n            result=1\n            marks=[cool+x]\n        elif xymoar == True:\n            result=1\n            marks=[cool2]\n        else:\n            result=2\n            marks=[x,y]\nprint(result)\nfor i in range(len(marks)):\n    print(marks[i], end=' ')"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class _LongJumps_479D\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\n\t\tlong dif = Math.abs(x-y);\n\t\tTreeSet<Long> set = new TreeSet<>();\n\n\t\tboolean can_x = false, can_y = false;\n\t\tlong one = -1;\n\t\tlong doble = -1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tlong now = sc.nextInt();\n\t\t\tif(set.contains(now - x))\n\t\t\t\tcan_x = true;\n\t\t\tif(set.contains(now - y))\n\t\t\t\tcan_y = true;\n\t\t\tif(set.contains(now - (x+y)))\n\t\t\t\tdoble = (now) - (x+y);\n\t\t\tif(set.contains(now - dif) && now + Math.min(x, y) <=l)\n\t\t\t\tone = now + Math.min(x, y);\n\t\t\telse\n\t\t\t\tif(set.contains(now - dif) && now - dif - Math.min(x, y) >= 0)\n\t\t\t\t\tone = now - dif - Math.min(x, y);\n\n\t\t\tset.add(now);\n\t\t}\n\t\tif(can_x && can_y)\n\t\t\tSystem.out.println(0);\n\t\telse\n\t\t\tif(doble != -1)\n\t\t\t\tSystem.out.println(\"1\\n\"+ (doble + x));\n\t\t\telse\n\t\t\t\tif(one != -1)\n\t\t\t\t\tSystem.out.println(\"1\\n\"+one);\n\t\t\t\telse\n\t\t\t\t\tif(can_y)\n\t\t\t\t\t\tSystem.out.println(\"1\\n\"+x);\n\t\t\t\t\telse\n\t\t\t\t\t\tif(can_x)\n\t\t\t\t\t\t\tSystem.out.println(\"1\\n\"+y);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tSystem.out.println(\"2\\n\"+x+\" \"+y);\n\t}\n\n\tstatic class Scanner{\n\t\tStringTokenizer st;BufferedReader br;\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic String next() throws IOException \n\t\t{while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());return st.nextToken();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  multiset<int> s;\n  for (int i = 0; i < n; i++) {\n    long long int a;\n    cin >> a;\n    s.insert(a);\n  }\n  bool x_found = false, y_found = false;\n  for (long long int el : s) {\n    if (s.find(el + x) != s.end()) x_found = true;\n    if (s.find(el + y) != s.end()) y_found = true;\n  }\n  if (x_found && y_found)\n    cout << 0 << '\\n';\n  else if (x_found || y_found) {\n    if (!x_found)\n      cout << 1 << '\\n' << x << '\\n';\n    else\n      cout << 1 << '\\n' << y << '\\n';\n  } else {\n    bool one = false;\n    for (int el : s) {\n      if ((el + x <= l) &&\n          (s.find(el + x + y) != s.end() || s.find(el + x - y) != s.end())) {\n        cout << 1 << '\\n';\n        cout << el + x << '\\n';\n        one = true;\n        break;\n      }\n      if ((el - x >= 0) &&\n          (s.find(el - x - y) != s.end() || s.find(el - x + y) != s.end())) {\n        cout << 1 << '\\n';\n        cout << el - x << '\\n';\n        one = true;\n        break;\n      }\n    }\n    if (!one) cout << 2 << '\\n' << x << \" \" << y << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD_EXPO(long long b, long long p, long long m) {\n  if (p == 0) return 1;\n  long long ret = MOD_EXPO(b, p / 2, m) % m;\n  ret = (ret * ret) % m;\n  return ((p & 1) ? (ret * b) % m : ret % m);\n}\nlong long POWER(long long N, long long K) {\n  long long i, ans = 1;\n  for (i = 1; i <= K; i++) ans *= N;\n  return ans;\n}\nint SET(int N, int pos) { return (N | (1 << pos)); }\nint RESET(int N, int pos) { return (N & !(1 << pos)); }\nbool CHECK(int N, int pos) { return (N & (1 << pos)); }\nint dx4[] = {1, -1, 0, 0};\nint dy4[] = {0, 0, 1, -1};\nint dx6[] = {0, 0, 1, -1, 0, 0};\nint dy6[] = {1, -1, 0, 0, 0, 0};\nint dz6[] = {0, 0, 0, 0, 1, -1};\nint dx8[] = {1, -1, 0, 0, -1, 1, -1, 1};\nint dy8[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dkx8[] = {-1, 1, -1, 1, -2, -2, 2, 2};\nint dky8[] = {2, 2, -2, -2, 1, -1, 1, -1};\nint tc = 1;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\nconst long long int mx = 1e5;\nconst long long int mod = 1e9 + 7;\nlong long arr[mx + 5];\nint main() {\n  long long n, l, x, y, diff, i, a, b, c, d, e, sum, bal;\n  bool xflag, yflag, dflag, bflag, cflag;\n  while (cin >> n >> l >> x >> y) {\n    map<long long, bool> mp;\n    vector<long long> idx;\n    for (i = 1; i <= n; i++) {\n      scanf(\"%lld\", &arr[i]);\n      mp[arr[i]] = true;\n    }\n    xflag = yflag = dflag = bflag = cflag = false;\n    for (i = 1; i <= n; i++) {\n      a = x + arr[i];\n      b = y + arr[i];\n      c = (y - x) + arr[i];\n      d = x + y + arr[i];\n      e = y - x;\n      if (mp[a]) xflag = true;\n      if (mp[b]) yflag = true;\n      if (mp[c] && !dflag && (c - y >= 0 || c + x <= l)) diff = c, dflag = true;\n      if (mp[d] && !bflag && (d - y >= 0 || d + x <= l)) sum = d, bflag = true;\n      if (mp[e] && !cflag && (e - y >= 0 || e + x <= l)) bal = e, cflag = true;\n    }\n    if (!xflag && !yflag) {\n      if (mp[x + y])\n        idx.push_back(x);\n      else if (cflag && bal + x <= l)\n        idx.push_back(bal + x);\n      else if (bflag && sum - y >= 0)\n        idx.push_back(sum - y);\n      else if (bflag && sum + x <= l)\n        idx.push_back(sum + x);\n      else if (dflag && diff - y >= 0)\n        idx.push_back(diff - y);\n      else if (dflag && diff + x <= l)\n        idx.push_back(diff + x);\n      else\n        idx.push_back(x), idx.push_back(y);\n    } else if (!xflag) {\n      idx.push_back(x);\n    } else if (!yflag) {\n      idx.push_back(y);\n    }\n    cout << idx.size() << \"\\n\";\n    for (i = 0; i < idx.size(); i++) printf(\"%lld \", idx[i]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nset<int> s;\nint n, L;\nint lo, hi, mid;\nint fin(int tar) {\n  lo = 0;\n  hi = n - 1;\n  while (lo <= hi) {\n    mid = (lo + hi) / 2;\n    if (a[mid] > tar)\n      hi = mid - 1;\n    else\n      lo = mid + 1;\n  }\n  if (hi >= 0 && a[hi] == tar) return 1;\n  return 0;\n}\nint get(int val) {\n  int i;\n  for (i = 0; i < n; i++) {\n    if (fin(a[i] + val) || fin(a[i] - val)) return 1;\n  }\n  return 0;\n}\nint make(int val, int other_val) {\n  int i, val2;\n  for (i = 0; i < n; i++) {\n    if ((a[i] + val) <= L) {\n      val2 = a[i] + val;\n      if (fin(val2 - other_val) || fin(val2 + other_val)) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", val2);\n        return 1;\n      }\n    }\n    if ((a[i] - val) >= 0) {\n      val2 = a[i] - val;\n      if (fin(val2 - other_val) || fin(val2 + other_val)) {\n        printf(\"1\\n\");\n        printf(\"%d\\n\", val2);\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j, k, x, y;\n  scanf(\"%d %d %d %d\", &n, &L, &x, &y);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int gotx = get(x);\n  int goty = get(y);\n  if (gotx && goty) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (gotx || goty) {\n    printf(\"1\\n\");\n    if (gotx) printf(\"%d\\n\", y);\n    if (goty) printf(\"%d\\n\", x);\n    return 0;\n  }\n  int val = x;\n  int other_val = y;\n  int sts = make(val, other_val);\n  if (sts) return 0;\n  sts = make(other_val, val);\n  if (sts) return 0;\n  printf(\"2\\n\");\n  printf(\"%d %d\\n\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,l,x,y = map(int,raw_input().split())\nentrada = map(int,raw_input().split())\nboy=[]\ngirl=[]\nfor e in entrada:\n    if e-x>=0:\n        girl.append(e-x)\n    if e+x<=l:\n        girl.append(e+x)\n    if e-y>=0:\n        boy.append(e-y)\n    if e+y<=l:\n        boy.append(e+y)\ngirl.sort()\nboy.sort()\nb=g=False\nbg=False\ni=0\nfor k in girl:\n    while entrada[i] < k and i <n-1:\n        i+=1\n    if entrada[i]==k:\n        g=True\ni=0\nfor k in boy:\n    while entrada[i]<k and i<n-1:\n        i+=1\n    if entrada[i]==k:\n        b=True\nif g and b:\n    print 0\nelif g:\n    print 1\n    print y\nelif b:\n    print 1\n    print x\nelse:\n    i=0\n    n=len(girl)\n    for k in boy:\n        while girl[i]<k and i<n-1:\n            i+=1\n        if girl[i]==k:\n            bg=True\n            break\n    if bg:\n        print 1\n        print k\n    else:\n        print 2\n        print x,y"
        },
        {
            "language": 3,
            "solution": "if __name__ == \"__main__\":\t\n\tn, l, x, y = list(map(int, input().split()))\n\tv = list(map(int, input().split()))\n\ts = set(v)\n\n\tcx = 0\n\tfor i in range(n):\n\t\tif v[i]+x in s:\n\t\t\tcx = 1\n\t\t\tbreak\n\t\n\tcy = 0\n\tfor i in range(n):\n\t\tif v[i]+y in s:\n\t\t\tcy = 1\n\t\t\tbreak\n\t\n\tcount = 0\n\tans = []\n\n\tif cx==0:\n\t\tcount += 1\n\t\tans.append(x)\n\tif cy==0:\n\t\tcount += 1\n\t\tans.append(y)\n\n\tif count==2:\n\t\tfor i in range(n):\n\t\t\tif (v[i]+x+y in s):\n\t\t\t\tcount = 1\n\t\t\t\tans = [v[i]+x]\n\t\t\t\tbreak\n\n\tif count==2:\n\t\tfor i in range(n):\n\t\t\tif (v[i]+x-y in s):\n\t\t\t\tif v[i]+x<=l:\n\t\t\t\t\tcount = 1\n\t\t\t\t\tans = [v[i]+x]\n\t\t\t\t\tbreak\n\t\t\t\telif v[i]-y>=0:\n\t\t\t\t\tcount = 1\n\t\t\t\t\tans = [v[i]-y]\n\t\t\t\t\tbreak\n\n\tprint(count)\n\tif count!=0:\n\t\tprint(*ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class LongJumps implements Runnable {\n\t\t\n\tpublic void solve() throws IOException {\n\t\tint N = nextInt();\n                int length = nextInt();\n                int left = nextInt();\n                int right = nextInt();\n                \n                int[] a = new int[N];\n                for(int i = 0; i < N; i++) a[i] = nextInt();\n                \n                boolean hasLeft = false, hasRight = false;\n                int[] answer = new int[]{left, right};\n                \n                for(int i : a){\n                    if(i - left >= 0 && Arrays.binarySearch(a, i - left) >= 0) hasLeft = true;\n                    if(i - right >= 0 && Arrays.binarySearch(a, i - right) >= 0) hasRight = true;\n                    if(answer.length == 2){\n                        if( i-left >= 0 && ( (i - left - right >= 0 && Arrays.binarySearch(a, i-left-right) >= 0) || (i - left +right <= length && Arrays.binarySearch(a, i-left + right) >= 0))){\n                            answer = new int[]{i-left};\n                        }\n                        else if(i+left <= length && ( \n                                (i+left - right >= 0 && Arrays.binarySearch(a, i+left - right) >= 0) ||\n                                (i+left + right <= length && Arrays.binarySearch(a, i+left + right) >= 0)\n                                )){\n                            answer = new int[]{i+left};\n                        }\n                        \n                        //other condition not needed because\n                        // i+right - left == i - left + right\n                        // i+right + left == i + left + right\n                        //etc\n                    }\n                }\n                \n                \n                if(hasLeft && hasRight) answer = new int[0];\n                else if(hasLeft) answer = new int[]{right};\n                else if(hasRight) answer = new int[]{left};\n                \n                System.out.println(answer.length);\n                for(int i : answer) System.out.print(i + \" \");\n                System.out.println();\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//-----------------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tnew LongJumps().run();\n\t}\n\n        public void print1Int(int[] a){\n                for(int i = 0; i < a.length; i++)\n                        System.out.print(a[i] + \" \");\n                System.out.println();\n        }\n        \n        public void print2Int(int[][] a){\n                for(int i = 0; i < a.length; i++){\n                        for(int j = 0; j < a[0].length; j++){\n                                System.out.print(a[i][j] + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n        \n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttok = null;\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer tok;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nint n, l, x, y;\nunordered_set<int> locs;\nbool valid(int x) { return x >= 0 && x <= l; }\nbool dfx = false, dfy = false;\nbool ok(int p) {\n  bool xok = dfx, yok = dfy;\n  if (valid(p + x) && locs.count(p + x)) {\n    xok = true;\n  } else if (valid(p - x) && locs.count(p - x)) {\n    xok = true;\n  }\n  if (valid(p + y) && locs.count(p + y)) {\n    yok = true;\n  } else if (valid(p - y) && locs.count(p - y)) {\n    yok = true;\n  }\n  return xok && yok;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    int cx;\n    cin >> cx;\n    locs.insert(cx);\n    if (valid(cx - x) && locs.count(cx - x)) dfx = true;\n    if (valid(cx - y) && locs.count(cx - y)) dfy = true;\n  }\n  int ans = 2;\n  pi ret = make_pair(x, y);\n  for (int v : locs) {\n    if (ok(v)) {\n      ans = 0;\n      break;\n    }\n    if (valid(v + x) && ok(v + x)) {\n      ans = min(ans, 1);\n      ret.first = v + x;\n    }\n    if (valid(v - x) && ok(v - x)) {\n      ans = min(ans, 1);\n      ret.first = v - x;\n    }\n    if (valid(v + y) && ok(v + y)) {\n      ans = min(ans, 1);\n      ret.first = v + y;\n    }\n    if (valid(v - y) && ok(v - y)) {\n      ans = min(ans, 1);\n      ret.first = v - y;\n    }\n  }\n  cout << ans << '\\n';\n  if (ans == 2) {\n    cout << ret.first << \" \" << ret.second << '\\n';\n  } else if (ans == 1) {\n    cout << ret.first << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import fileinput\n\n###          ###\n# utility func #\n###          ###\n\ndbug = True\n\ndef stoi(s):\n\treturn([ int(x) for x in s.split() ])\n\ndef pd(s):\n\tglobal dbug\n\tif dbug:\n\t\tprint 'dbug: ', s\n\n###          ###\n# code follows #\n###          ###\n\n# args = [ 'line 1', 'line 2', ... ]\ndef proc_input(args):\n\t(_, l, x, y) = stoi(args[0])\n\ta = stoi(args[1])\n\treturn(a, l, x, y)\n\ndef solve(args, verbose=False):\n\t(a, l, x, y) = proc_input(args)\n\t# a now in ascending order\n\ta.sort()\n\ts = set(a)\n\tx_found = y_found = False\n\tcandidates = []\n\tfor term in s:\n\t\tif term + x in s or term - x in s:\n\t\t\tx_found = True\n\t\tif term + y in s or term - y in s:\n\t\t\ty_found = True\n\n\tif not x_found:\n\t\tcandidates.append(x)\n\tif not y_found:\n\t\tcandidates.append(y)\n\n\tif not x_found and not y_found:\n\t\tfor term in s:\n\t\t\tif term + x + y in s and term + x < l:\n\t\t\t\tcandidates = [ term + x ]\n\t\t\telif term + x - y in s and term + x < l:\n\t\t\t\tcandidates = [ term + x ]\n\t\t\telif term - x + y in s and term - x > 0:\n\t\t\t\tcandidates = [ term - x ]\n\t\t\telif term - x - y in s and term - x > 0:\n\t\t\t\tcandidates = [ term - x ]\n\tif verbose:\n\t\tprint len(candidates)\n\t\tprint ' '.join([ str(x) for x in candidates ])\n\treturn candidates\n\ndef test():\n\tassert(solve([ '3 250 185 230', '0 185 250' ]) == [ 230 ])\n\tassert(solve([ '4 250 185 230', '0 20 185 250' ]) == [])\n\tassert(solve([ '2 300 185 230', '0 300' ]) == [ 185, 230 ])\n\tassert(solve([ '4 300 4 5', '0 6 7 300' ]) == [ 11 ])\n\tassert(solve([ '4 300 4 5', '0 298 299 300' ]) == [ 295 ])\n\nif __name__ == '__main__':\n\tfrom sys import argv\n\tif argv.pop() == 'test':\n\t\ttest()\n\telse:\n\t\tdbug = False\n\t\tsolve(list(fileinput.input()), verbose=True)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  map<long long, int> num;\n  num.clear();\n  long long n, l, x, y, curr;\n  cin >> n >> l >> x >> y;\n  int boy = 0, girl = 0;\n  long long diff = y - x, sum = y + x, ans2 = -1, ans3 = -1;\n  for (int i = 0; i <= n - 1; i++) {\n    cin >> curr;\n    if (boy & girl) continue;\n    num[curr] = 1;\n    if (curr >= x && num[curr - x]) girl = 1;\n    if (curr >= y && num[curr - y]) boy = 1;\n    if (ans2 == -1 && ans3 == -1) {\n      if (curr >= diff && num[curr - diff]) {\n        if (curr + x <= l)\n          ans2 = curr + x;\n        else if (curr - y >= 0)\n          ans2 = curr - y;\n      }\n      if (curr >= sum && num[curr - sum]) ans3 = curr - sum;\n    }\n  }\n  int ans = 2;\n  if (boy) ans--;\n  if (girl) ans--;\n  if (ans == 0) {\n    cout << ans << endl;\n    return 0;\n  } else if (ans == 1) {\n    cout << \"1\\n\";\n    if (!boy) {\n      cout << y;\n      return 0;\n    } else if (!girl) {\n      cout << x;\n      return 0;\n    }\n  } else {\n    if (ans2 != -1) {\n      cout << \"1\\n\";\n      cout << ans2;\n      return 0;\n    }\n    if (ans3 != -1) {\n      if (ans3 + x <= l) {\n        cout << \"1\\n\";\n        cout << ans3 + x;\n        return 0;\n      }\n    }\n    cout << \"2\\n\";\n    cout << x << \" \" << y << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, a[100005];\nmap<int, bool> ma;\nvoid ck(int d, int t) {\n  if (d < 0 || d > l) {\n    return;\n  }\n  if (ma[d - t] || ma[d + t]) {\n    cout << 1 << endl << d;\n    exit(0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ma[a[i]] = true;\n  }\n  bool xok = false, yok = false;\n  for (int i = 0; i < n; i++) {\n    if (ma[a[i] + x] || ma[a[i] - x]) xok = true;\n    if (ma[a[i] + y] || ma[a[i] - y]) yok = true;\n  }\n  if (xok && yok) {\n    cout << 0;\n    return 0;\n  } else if (xok) {\n    cout << 1 << endl << y;\n    return 0;\n  } else if (yok) {\n    cout << 1 << endl << x;\n    return 0;\n  } else {\n    for (int i = 0; i < n; i++) {\n      ck(a[i] + x, y);\n      ck(a[i] - x, y);\n      ck(a[i] + y, x);\n      ck(a[i] - y, x);\n    }\n    cout << 2 << endl << x << ' ' << y;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9, maxn = (int)1e5 + 1;\nconst double eps = (double)1e-8;\nconst int mod = (int)1000000009;\nmap<int, bool> m;\nint a[100001], n, l, x, y, z, one;\nbool tx = 0, ty = 0, t1 = 0;\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = (1); i <= (n); i++) {\n    scanf(\"%d\", &(a[i]));\n    m[a[i]] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    z = a[i];\n    if (m[z - x] == 1 || m[z + x] == 1)\n      tx = 1;\n    else {\n      if (z - x >= 0 && z - x <= l &&\n          (m[z - x - y] == 1 || m[y + (z - x)] == 1)) {\n        one = z - x;\n        t1 = 1;\n      } else if (x + z >= 0 && x + z <= l &&\n                 (m[x + z - y] == 1 || m[y + (x + z)] == 1)) {\n        one = x + z;\n        t1 = 1;\n      }\n    }\n    if (m[z - y] == 1 || m[y + z] == 1)\n      ty = 1;\n    else {\n      if (z - y >= 0 && z - y <= l &&\n          (m[z - y - x] == 1 || m[x + (z - y)] == 1)) {\n        one = z - y;\n        t1 = 1;\n      }\n      if (y + z >= 0 && y + z <= l &&\n          (m[y + z - x] == 1 || m[x + (y + z)] == 1)) {\n        one = y + z;\n        t1 = 1;\n      }\n    }\n  }\n  if (tx == 1 && ty == 1) {\n    cout << 0;\n  } else if (t1 == 1) {\n    cout << 1 << endl;\n    cout << one;\n  } else if (tx == 1) {\n    cout << 1 << endl;\n    cout << y;\n  } else if (ty == 1) {\n    cout << 1 << endl;\n    cout << x;\n  } else {\n    cout << 2 << endl;\n    cout << x << \" \" << y;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nint main() {\n  int n, l, x, y;\n  int ans = 0;\n  cin >> n >> l >> x >> y;\n  std::vector<int> a;\n  int z;\n  for (int i = 0; i < n; i++) {\n    cin >> z;\n    a.push_back(z);\n  }\n  std::vector<int> gm, gf;\n  std::vector<int> cm, cf;\n  for (int i = 0; i < n; i++) {\n    cm.push_back(a[i]);\n    cm.push_back(a[i] + y);\n    cf.push_back(a[i]);\n    cf.push_back(a[i] + x);\n  }\n  sort((cm).begin(), (cm).end());\n  sort((cf).begin(), (cf).end());\n  bool m = false;\n  bool f = false;\n  for (int i = 1; i < 2 * n; i++)\n    if (cm[i] == cm[i - 1]) m = true;\n  for (int i = 1; i < 2 * n; i++)\n    if (cf[i] == cf[i - 1]) f = true;\n  if (m && f) {\n    cout << 0;\n    return 0;\n  }\n  if (m || f) {\n    cout << 1 << endl;\n    if (m)\n      cout << x;\n    else\n      cout << y;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] >= y) gm.push_back(a[i] - y);\n    if (a[i] + y <= l) gm.push_back(a[i] + y);\n    if (a[i] >= x) gf.push_back(a[i] - x);\n    if (a[i] + x <= l) gf.push_back(a[i] + x);\n  }\n  sort((gf).begin(), (gf).end());\n  sort((gm).begin(), (gm).end());\n  int fs = gf.size();\n  int ms = gm.size();\n  int curf = 0, curm = 0;\n  while ((curf < fs) && (curm < ms)) {\n    if (gf[curf] == gm[curm]) {\n      cout << 1 << endl << gf[curf];\n      return 0;\n    } else if (gf[curf] > gm[curm]) {\n      curm++;\n    } else\n      curf++;\n  }\n  cout << 2 << endl;\n  cout << x << \" \" << y;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, l, x, y;\n  cin >> n >> l >> x >> y;\n  long long int arr[100005];\n  for (int i = 0, _i = (n); i < _i; ++i) cin >> arr[i];\n  bool possi1 = false, possi2 = false;\n  for (int i = 0, _i = (n - 1); i < _i; ++i) {\n    if (arr[lower_bound(arr + i, arr + n, arr[i] + x) - arr] == arr[i] + x)\n      possi1 = true;\n    if (arr[lower_bound(arr + i, arr + n, arr[i] + y) - arr] == arr[i] + y)\n      possi2 = true;\n  }\n  if (possi1 && possi2)\n    cout << 0 << endl;\n  else {\n    if (!possi2 && !possi1) {\n      long long int temp = x + y;\n      int index;\n      bool po = false;\n      for (int i = 0, _i = (n - 1); i < _i; ++i) {\n        if (arr[lower_bound(arr + i, arr + n, arr[i] + temp) - arr] ==\n            temp + arr[i]) {\n          po = true;\n          index = i;\n        }\n      }\n      if (po) {\n        cout << 1 << endl;\n        cout << arr[index] + x;\n        return 0;\n      }\n      temp = y - x;\n      for (int i = 0, _i = (n - 1); i < _i; ++i) {\n        if (arr[lower_bound(arr + i, arr + n, arr[i] + temp) - arr] ==\n            temp + arr[i]) {\n          if (arr[i] >= x) {\n            cout << 1 << endl;\n            cout << arr[i] - x << endl;\n            return 0;\n          } else if (arr[i] + y <= l) {\n            cout << 1 << endl;\n            cout << arr[i] + y << endl;\n            return 0;\n          }\n        }\n      }\n      cout << 2 << endl;\n      cout << x << \" \" << y << endl;\n    } else {\n      cout << 1 << endl;\n      if (possi2)\n        cout << x << endl;\n      else\n        cout << y << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\n\npublic class Main4 \n{\n    public static boolean find(int[] arr,int x)\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            if(Arrays.binarySearch(arr,arr[i]-x)>=0 || Arrays.binarySearch(arr, arr[i]+x)>=0)\n                return true;\n        }\n        return false;\n    }\n    public static void main(String a[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        StringBuilder ans=new StringBuilder(\"\");\n        st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        int l=Integer.parseInt(st.nextToken());\n        int x=Integer.parseInt(st.nextToken());\n        int y=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        int[] arr=new int[n];\n        int count=0;\n        for(int i=0;i<n;i++)\n            arr[i]=Integer.parseInt(st.nextToken());\n        if(!find(arr,x))\n        {\n            ans.append(x+\" \");\n            count++;\n        }\n        if(!find(arr,y))\n        {\n            ans.append(y);\n            count++;\n        }\n        if(count==2)\n        {\n            \n            l:for(int i=0;i<n;i++)\n            {\n                int loc[]={arr[i]+x,arr[i]-x,arr[i]+x,arr[i]-x,arr[i]+y,arr[i]-y,arr[i]+y,arr[i]-y};\n                int add[]={y,y,-y,-y,x,x,-x,-x};\n                for(int j=0;j<8;j++)\n                {\n                    if(loc[j]>=0 && loc[j]<=l && Arrays.binarySearch(arr,loc[j]+add[j])>=0)\n                    {\n                        ans.setLength(0);\n                        count=1;\n                        ans.append(loc[j]);\n                        //System.out.println(arr[i]+\" \"+loc[j]+\" \"+add[j]);\n                        break l;\n                    }\n                }\n            }\n        }\n        System.out.println(count);\n        System.out.print(ans);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, l, x, y;\n  cin >> n >> l >> x >> y;\n  std::vector<long long> v(n, 0);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i];\n  }\n  long long a = 0, b = 0;\n  for (int i = 0; i < n; ++i) {\n    if (binary_search(v.begin(), v.end(), v[i] + x)) a++;\n    if (binary_search(v.begin(), v.end(), v[i] + y)) b++;\n  }\n  if (a && b) {\n    cout << 0;\n    return 0;\n  }\n  if (a) {\n    cout << 1 << '\\n' << y;\n    return 0;\n  }\n  if (b) {\n    cout << 1 << '\\n' << x;\n    return 0;\n  }\n  b = 0;\n  for (int i = 0; i < n && (v[i] + x <= l); ++i) {\n    if (binary_search(v.begin(), v.end(), v[i] + x - y) ||\n        binary_search(v.begin(), v.end(), v[i] + x + y)) {\n      cout << 1 << '\\n' << v[i] + x;\n      return 0;\n    }\n  }\n  for (int i = n - 1; i >= 0 && (v[i] - x >= 0); --i) {\n    if (binary_search(v.begin(), v.end(), v[i] - x - y) ||\n        binary_search(v.begin(), v.end(), v[i] - x + y)) {\n      cout << 1 << '\\n' << v[i] - x;\n      return 0;\n    }\n  }\n  cout << 2 << '\\n' << x << \" \" << y;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> marks;\nint l;\nint x, y;\nint a[200200];\nint n;\nint main() {\n  cin >> n >> l >> x >> y;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    marks.insert(a[i]);\n  }\n  bool xx = false;\n  bool yy = false;\n  for (int i = 0; i < n; ++i) {\n    int start = a[i];\n    int end = a[i] + x;\n    if (marks.find(end) != marks.end()) {\n      xx = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int start = a[i];\n    int end = a[i] + y;\n    if (marks.find(end) != marks.end()) {\n      yy = true;\n      break;\n    }\n  }\n  if (xx && yy) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (xx) {\n    cout << 1 << endl << y << endl;\n    return 0;\n  }\n  if (yy) {\n    cout << 1 << endl << x << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int start = a[i];\n    int end1 = a[i] + y - x;\n    int end2 = a[i] + x + y;\n    if (marks.find(end2) != marks.end()) {\n      cout << 1 << endl << start + x << endl;\n      return 0;\n    }\n    if (marks.find(end1) != marks.end()) {\n      if (start - x >= 0) {\n        cout << 1 << endl << start - x << endl;\n        return 0;\n      }\n      if (end1 + x <= l) {\n        cout << 1 << endl << end1 + x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#Adapted from code of hatsuyuki15 in this contest\nn, l, x, y = map(int, input().split())\na = set(map(int, input().split()))\nboy = False\ngirl = False\none = False\nwhere = -1\nfor i in a:\n    if i + x in a:\n        boy = True\n    if i + y in a:\n        girl = True\n    if i - x > 0 and i - x + y in a:\n        one = True\n        where = i - x\n    if i + x < l and i + x - y in a:\n        one = True\n        where = i + x\n    if i + x + y in a:\n        one = True\n        where = i + x\n    if i - x - y in a:\n        one = True\n        where = i - x\n\n\nif boy and girl:\n    print(0)\nif boy and not girl:\n    print(1)\n    print(y)\nif girl and not boy:\n    print(1)\n    print(x)\nif not boy and not girl:\n    if one:\n        print(1)\n        print(where)\n    if not one:\n        print(2)\n        print(x, y)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100050;\nint n, l, x, y, a[maxn];\nmap<int, int> q;\nint main() {\n  int i, j;\n  bool z1 = 0, z2 = 0;\n  scanf(\"%d%d%d%d\\n\", &n, &l, &x, &y);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    q[a[i]] = 1;\n    if (q.count(a[i] - x)) z1 = 1;\n    if (q.count(a[i] - y)) z2 = 1;\n  }\n  if (z1 && z2)\n    printf(\"0\\n\");\n  else if (z1)\n    printf(\"1\\n%d\\n\", y);\n  else if (z2)\n    printf(\"1\\n%d\\n\", x);\n  else {\n    for (i = 1; i <= n; i++)\n      if (q[a[i] + x - y]) {\n        if (a[i] + x <= l) {\n          printf(\"1\\n%d\\n\", a[i] + x);\n          return 0;\n        }\n        if (a[i] - y >= 0) {\n          printf(\"1\\n%d\\n\", a[i] - y);\n          return 0;\n        }\n      } else if (q[a[i] - x - y]) {\n        printf(\"1\\n%d\\n\", a[i] - x);\n        return 0;\n      }\n    printf(\"2\\n%d %d\\n\", x, y);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1000000000\")\nusing namespace std;\nconst int maxn = 100010;\nint v[maxn];\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &v[i]);\n  }\n  v[n] = (int)2e9 + 10;\n  bool f = false, s = false;\n  for (int i = 0; i < n; i++) {\n    int need = v[i] - x;\n    if ((*lower_bound(v, v + n, need)) == need) {\n      f = true;\n    }\n    need = v[i] - y;\n    if ((*lower_bound(v, v + n, need)) == need) {\n      s = true;\n    }\n  }\n  if (f && s) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (!f && s) {\n    cout << 1 << endl;\n    cout << x << endl;\n    return 0;\n  }\n  if (f && !s) {\n    cout << 1 << endl;\n    cout << y << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int need = v[i] + x;\n    if (need <= l) {\n      if ((*lower_bound(v, v + n, need - y)) == need - y ||\n          (*lower_bound(v, v + n, need + y)) == need + y) {\n        cout << 1 << endl;\n        cout << need << endl;\n        return 0;\n      }\n    }\n    need = v[i] - x;\n    if (need >= 0) {\n      if ((*lower_bound(v, v + n, need - y)) == need - y ||\n          (*lower_bound(v, v + n, need + y)) == need + y) {\n        cout << 1 << endl;\n        cout << need << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 2 << endl;\n  cout << x << ' ' << y << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "[n, l, x, y] = map(int, raw_input().split())\nmarks = map(int, raw_input().split())\nso = set(marks)\nsx = set()\nsy = set()\nbx, by = False, False\nfor it in so:\n    if bx and by:\n        break\n    v1 = it + x\n    v2 = it - x\n    v3 = it + y\n    v4 = it - y\n    if v1 <= l:\n        if so.__contains__(v1):\n            bx = True\n        else:\n            sx.add(v1)\n    if v2 >= 0:\n        if so.__contains__(v2):\n            bx = True\n        else:\n            sx.add(v2)\n    if v3 <= l:\n        if so.__contains__(v3):\n            by = True\n        else:\n            sy.add(v3)\n    if v4 >= 0:\n        if so.__contains__(v4):\n            by = True\n        else:\n            sy.add(v4)\nif bx and by:\n    print 0\nelif bx and by == False:\n    print 1\n    print y\nelif by and bx == False:\n    print 1\n    print x\nelse:\n    r = sx & sy\n    if len(r) == 0:\n        print 2\n        print '%d %d' % (x, y)\n    else:\n        print 1\n        for v in r:\n            print v\n            break\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, L, x, y;\n  while (scanf(\"%d\", &n) == 1) {\n    scanf(\"%d\", &L), scanf(\"%d\", &x), scanf(\"%d\", &y);\n    vector<int> v(n);\n    set<int> SET;\n    for (int i = 0; i < n; ++i) {\n      int val;\n      scanf(\"%d\", &val);\n      v[i] = val;\n      SET.insert(val);\n    }\n    bool foundX = 0, foundY = 0;\n    for (int i = 0; i < n; ++i)\n      if (SET.count(v[i] - x) || SET.count(v[i] + x)) {\n        foundX = 1;\n        break;\n      }\n    for (int i = 0; i < n; ++i)\n      if (SET.count(v[i] - y) || SET.count(v[i] + y)) {\n        foundY = 1;\n        break;\n      }\n    if (foundX && foundY) {\n      puts(\"0\");\n      continue;\n    }\n    if (foundX) {\n      puts(\"1\");\n      printf(\"%d\\n\", y);\n      continue;\n    }\n    if (foundY) {\n      puts(\"1\");\n      printf(\"%d\\n\", x);\n      continue;\n    }\n    bool found = 0;\n    for (int i = 0; i < n; ++i) {\n      int target = v[i] - x;\n      if (target >= 0 && target <= L &&\n          (SET.count(target - y) || SET.count(target + y))) {\n        found = 1;\n        puts(\"1\");\n        printf(\"%d\\n\", target);\n        break;\n      }\n      target = v[i] + x;\n      if (target >= 0 && target <= L &&\n          (SET.count(target - y) || SET.count(target + y))) {\n        found = 1;\n        puts(\"1\");\n        printf(\"%d\\n\", target);\n        break;\n      }\n    }\n    if (found) continue;\n    puts(\"2\");\n    printf(\"%d %d\\n\", x, y);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, l, x, y, b1, b2, o, ans, tot, a[200010];\nmap<int, int> b, bb;\nint main() {\n  scanf(\"%d%d%d%d\", &n, &l, &x, &y);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &o);\n    b[x + o] = 1;\n    bb[y + o] = 1;\n    bb[o - y] = 1;\n    b[o - x] = 1;\n    if (b[o]) b1 = 1;\n    a[++tot] = x + o;\n    a[++tot] = o - x;\n    if (bb[o]) b2 = 1;\n  }\n  if (b1 && b2) return puts(\"0\"), 0;\n  for (int i = 1; i <= tot; i++)\n    if (bb[a[i]] && a[i] <= l && a[i] >= 0) {\n      ans = a[i];\n      break;\n    }\n  if (ans) {\n    puts(\"1\");\n    printf(\"%d\", ans);\n    return 0;\n  }\n  printf(\"%d\\n\", (b1 ^ 1) + (b2 ^ 1));\n  if (!b1) printf(\"%d \", x);\n  if (!b2) printf(\"%d\", y);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMyScanner sc = new MyScanner();\n\t\tMyWriter mw = new MyWriter();\n\t\n\t\tint n , l , x , y ; \n\t\t\n\t\tn = sc.nextInt();\n\t\tl = sc.nextInt();\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\t\n\t\tint array[] = new int[n];\n\t\t\n\t\tfor( int i = 0 ; i < n; ++i )\n\t\t\tarray[i] = sc.nextInt();\n\t\t\n\t\tboolean hasX,hasY,hasXY;\n\t\tint candidateX,candidateY,candidateXY =  0;\n\t\t\n\t\thasX = hasY = hasXY = false ;\n\t\t\n\t\tint sum = x + y ;\n\t\tint dif = Math.abs(x-y);\n\t\tint max = Math.max(x, y);\n\t\tint min = Math.min(x, y);\n\t\t\n\t\tArrays.sort( array );\n\t\t\n\t\tfor( int i = 0 ; i < n ; ++i )\n\t\t{\n\t\t\t\n\t\t\t// search x\n\t\t\tint result ; \n\t\t\t\n\t\t\t\n\t\t\tif(  0 <  Arrays.binarySearch(array , array[i] + x ))\n\t\t\t\t{\n\t\t\t\thasX = true;\n\t\t\t\t}\n\t\t\t \n\t\t\tif( 0 < Arrays.binarySearch( array , array[i] + y ))\n\t\t\t\t{\n\t\t\t\thasY = true; \n\t\t\t\t}\n\t\t\t\n\t\t\tif( 0 < Arrays.binarySearch( array , array[i] + sum ))\n\t\t\t\t{\n\t\t\t\thasXY = true ;\n\t\t\t\tcandidateXY = array[i] + x ; \n\t\t\t\t}\n\t\t\t\n\t\t\tif( 0 < Arrays.binarySearch( array , array[i] + dif ))\n\t\t\t\t{\n\t\t\t\t\tif( 0 <= array[i] -  min   )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  hasXY = true ;\n\t\t\t\t\t\t  candidateXY = array[i] - min ;  \t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\telse if ( array[i] + max <=  array[n-1] ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\thasXY = true ; \n\t\t\t\t\t\tcandidateXY = array[i] + max ;  \n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(hasX && hasY )\n\t\t\tSystem.out.println( 0 );\n\t\t\n\t\telse if( hasX ) \n\t\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println( y );\n\t\t\t}\n\t\t\n\t\telse if( hasY)\n\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println( x );\n\t\t}\n\t\t\n\t\telse if( hasXY)\n\t\t{\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println( candidateXY );\n\t\t\t\n\t\t}\n\t\t\t\n\t\telse\n\t\t{System.out.println(\"2\");\n\t\tSystem.out.println( x +  \" \" + y );\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class MyScanner {\n\t      BufferedReader br;\n\t      StringTokenizer st;\n\t \n\t      public MyScanner() {\n\t         br = new BufferedReader(new InputStreamReader(System.in),8*1024);\n\t      }\n\t \n\t      String next() {\n\t          while (st == null || !st.hasMoreElements()) {\n\t              try {\n\t                  st = new StringTokenizer(br.readLine());\n\t              } catch (IOException e) {\n\t                  e.printStackTrace();\n\t              }\n\t          }\n\t          return st.nextToken();\n\t      }\n\t \n\t      int nextInt() {\n\t          return Integer.parseInt(next());\n\t      }\n\t \n\t      long nextLong() {\n\t          return Long.parseLong(next());\n\t      }\n\t \n\t      double nextDouble() {\n\t          return Double.parseDouble(next());\n\t      }\n\t \n\t      String nextLine(){\n\t          String str = \"\";\n\t\t  try {\n\t\t     str = br.readLine();\n\t\t  } catch (IOException e) {\n\t\t     e.printStackTrace();\n\t\t  }\n\t\t  return str;\n\t      }\n\n\t   }\n\n\tstatic class MyWriter {\n\t    BufferedWriter bw;\n\n\t    public  MyWriter() {\n\t       bw = new BufferedWriter(new OutputStreamWriter(System.out),8*1024);\n\t    }\n\n\t    void print(String s)\n\t    {\n\t    \ttry {\n\t\t\t\t\tbw.write( s , 0 , s.length() );\n\t\t\t\t\t\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t    }\n\t    \n\t    void println(String s)\n\t    {\n\t    \ttry {\n\t\t\t\tbw.write( s , 0 , s.length() );\n\t\t\t\tbw.newLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t    }\n\n\t void close()\n\t {\n\t\t try {\n\t\t\tbw.close();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t }\n\t}\n\t\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isFile = 0;\nconst long long INF = 1e15 + 1234;\nconst int N = 1e5 + 1234;\nconst long long MOD = 998244353;\nconst long long mod = 1e9 + 7;\ndouble EPS = 3e-18;\nconst double PI = acos(-1);\nvoid faster() {\n  if (isFile) {\n    freopen(\n        \"sort\"\n        \".in\",\n        \"r\", stdin);\n    freopen(\n        \"sort\"\n        \".out\",\n        \"w\", stdout);\n  }\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nlong long n, l, x, y;\nlong long a[N];\nbool fl = 0, f = 0;\nset<int> ans;\nmap<long long, bool> m;\nbool check(long long r) {\n  for (int i = 1; i <= n; i++) {\n    int c = 0, k = i;\n    while (c + 1 < k) {\n      int m = (c + k) / 2;\n      if (a[i] - a[m] < r)\n        k = m;\n      else\n        c = m;\n    }\n    if (a[i] - a[c] == r) {\n      return true;\n    }\n    c = i;\n    k = n + 1;\n    while (c + 1 < k) {\n      int m = (c + k) / 2;\n      if (a[m] - a[i] <= r)\n        c = m;\n      else\n        k = m;\n    }\n    if (a[c] - a[i] == r) {\n      return true;\n    }\n  }\n  return false;\n}\nvoid solve() {\n  cin >> n >> l >> x >> y;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (a[i] == x) fl = 1;\n    if (a[i] == y) f = 1;\n    m[a[i]] = 1;\n  }\n  if (!fl) fl = check(x);\n  if (!f) f = check(y);\n  pair<int, int> cc = {-1, -1};\n  if (!f && !fl) {\n    long long r = x + y;\n    for (int i = 1; i <= n; i++) {\n      int c = 0, k = i;\n      while (c + 1 < k) {\n        int m = (c + k) / 2;\n        if (a[i] - a[m] < r)\n          k = m;\n        else\n          c = m;\n      }\n      if (a[i] - a[c] == r) {\n        if (m.count(a[c] + x) || m.count(a[c] + y)) {\n          cc.first = 0;\n          break;\n        } else {\n          cc.first = i;\n          cc.second = c;\n        }\n      }\n      c = i;\n      k = n + 1;\n      while (c + 1 < k) {\n        int m = (c + k) / 2;\n        if (a[m] - a[i] <= r)\n          c = m;\n        else\n          k = m;\n      }\n      if (a[c] - a[i] == r) {\n        if (m.count(a[c] - x) || m.count(a[c] - y)) {\n          cc.first = 0;\n          break;\n        } else {\n          cc.first = i;\n          cc.second = c;\n        }\n      }\n    }\n  }\n  pair<int, int> dd = {-1, -1};\n  if (!f && !fl) {\n    long long r = y - x;\n    for (int i = 1; i <= n; i++) {\n      int c = 0, k = i;\n      while (c + 1 < k) {\n        int m = (c + k) / 2;\n        if (a[i] - a[m] < r)\n          k = m;\n        else\n          c = m;\n      }\n      if (a[i] - a[c] == r) {\n        if (m.count(a[c] + y)) {\n          dd.first = 0;\n          break;\n        } else if (a[c] + y <= l) {\n          dd.first = i;\n          dd.second = c;\n        }\n      }\n      c = i;\n      k = n + 1;\n      while (c + 1 < k) {\n        int m = (c + k) / 2;\n        if (a[m] - a[i] <= r)\n          c = m;\n        else\n          k = m;\n      }\n      if (a[c] - a[i] == r) {\n        if (m.count(a[c] - y)) {\n          dd.first = 0;\n          break;\n        } else if (a[c] - y >= 0) {\n          dd.first = i;\n          dd.second = c;\n        }\n      }\n    }\n  }\n  if (cc.first == 0 || dd.first == 0) {\n    cout << 0;\n    return;\n  } else if (cc.first > 0) {\n    cout << \"1\\n\";\n    if (cc.second > cc.first) {\n      cout << (a[cc.second] - y);\n    } else\n      cout << (a[cc.second] + y);\n    return;\n  } else if (dd.first > 0) {\n    cout << \"1\\n\";\n    if (dd.second > dd.first) {\n      cout << (a[dd.second] - y);\n    } else\n      cout << (a[dd.second] + y);\n    return;\n  }\n  if (!fl) ans.insert(x);\n  if (!f) ans.insert(y);\n  cout << (long long)ans.size();\n  cout << \"\\n\";\n  for (auto i : ans) cout << i << ' ';\n}\nint main() {\n  faster();\n  int t = 1;\n  while (t--) {\n    solve();\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:100000000\")\nint mas[100100];\nint sum[100100];\nset<int> st;\nint main() {\n  int n, l, x, y;\n  scanf(\"%d %d %d %d\", &n, &l, &x, &y);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &mas[i]);\n  for (int i = 0; i < n; i++) st.insert(mas[i]);\n  bool f1 = false;\n  bool f2 = false;\n  for (int i = 0; i < n; i++) {\n    int v = mas[i];\n    if (st.find(v + x) != st.end()) f1 = true;\n    if (st.find(v + y) != st.end()) f2 = true;\n  }\n  if (f1 && f2) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  if (f1 || f2) {\n    printf(\"1\\n\");\n    if (f1)\n      printf(\"%d\\n\", y);\n    else\n      printf(\"%d\\n\", x);\n    return 0;\n  }\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    int v = mas[i];\n    int lll = v - x;\n    int rr = v + x;\n    if (lll >= 0) {\n      if (st.find(lll + y) != st.end() || st.find(lll - y) != st.end()) {\n        printf(\"1\\n%d\\n\", lll);\n        return 0;\n      }\n    }\n    if (rr <= l) {\n      if (st.find(rr + y) != st.end() || st.find(rr - y) != st.end()) {\n        printf(\"1\\n%d\\n\", rr);\n        return 0;\n      }\n    }\n  }\n  printf(\"2\\n%d %d\", x, y);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid in() {}\nmap<int, int> m;\nint n, l, x, y, a[200100], cnt = 2;\nint main() {\n  in();\n  cin >> n >> l >> x >> y;\n  if (x > y) swap(x, y);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    m[a[i]]++;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (x > -1 && m[a[i] + x] > 0) {\n      x = -1;\n      cnt--;\n    }\n    if (y > -1 && m[a[i] + y] > 0) {\n      y = -1;\n      cnt--;\n    }\n    if (cnt == 0) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n  if (cnt == 2) {\n    for (int i = 0; i < n; ++i) {\n      if (m[a[i] + x + y] > 0) {\n        cout << 1 << endl << a[i] + x << endl;\n        return 0;\n      }\n      if (m[a[i] + x - y] > 0 && a[i] + x < l) {\n        cout << 1 << endl << a[i] + x << endl;\n        return 0;\n      }\n      if (m[a[i] - x + y] > 0 && a[i] - x > 0) {\n        cout << 1 << endl << a[i] - x << endl;\n        return 0;\n      }\n      if (m[a[i] - x - y] > 0) {\n        cout << 1 << endl << a[i] - x << endl;\n        return 0;\n      }\n    }\n  }\n  cout << cnt << endl;\n  if (x != -1) cout << x << \" \";\n  if (y != -1) cout << y;\n  cout << endl;\n  return 0;\n}\n"
        }
    ]
}