{
    "name": "901_D. Weighting a Tree",
    "source": "CODEFORCES",
    "description": "You are given a connected undirected graph with n vertices and m edges. The vertices are enumerated from 1 to n. \n\nYou are given n integers c1, c2, ..., cn, each of them is between  - n and n, inclusive. It is also guaranteed that the parity of cv equals the parity of degree of vertex v. The degree of a vertex is the number of edges connected to it.\n\nYou are to write a weight between  - 2\u00b7n2 and 2\u00b7n2 (inclusive) on each edge in such a way, that for each vertex v the sum of weights on edges connected to this vertex is equal to cv, or determine that this is impossible.\n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 105, n - 1 \u2264 m \u2264 105) \u2014 the number of vertices and the number of edges.\n\nThe next line contains n integers c1, c2, ..., cn ( - n \u2264 ci \u2264 n), where ci is the required sum of weights of edges connected to vertex i. It is guaranteed that the parity of ci equals the parity of degree of vertex i.\n\nThe next m lines describe edges of the graph. The i-th of these lines contains two integers ai and bi (1 \u2264 ai, bi \u2264 n; ai \u2260 bi), meaning that the i-th edge connects vertices ai and bi.\n\nIt is guaranteed that the given graph is connected and does not contain loops and multiple edges.\n\nOutput\n\nIf there is no solution, print \"NO\".\n\nOtherwise print \"YES\" and then m lines, the i-th of them is the weight of the i-th edge wi ( - 2\u00b7n2 \u2264 wi \u2264 2\u00b7n2).\n\nExamples\n\nInput\n\n3 3\n2 2 2\n1 2\n2 3\n1 3\n\n\nOutput\n\nYES\n1\n1\n1\n\n\nInput\n\n4 3\n-1 0 2 1\n1 2\n2 3\n3 4\n\n\nOutput\n\nYES\n-1\n1\n1\n\n\nInput\n\n6 6\n3 5 5 5 1 5\n1 4\n3 2\n4 3\n4 5\n3 5\n5 6\n\n\nOutput\n\nYES\n3\n5\n3\n-1\n-3\n5\n\n\nInput\n\n4 4\n4 4 2 4\n1 2\n2 3\n3 4\n4 1\n\n\nOutput\n\nNO",
    "difficulty": "D",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "6 6\n3 5 5 5 1 5\n1 4\n3 2\n4 3\n4 5\n3 5\n5 6\n",
            "output": "YES\n                                                               3\n                                                               5\n                                                               3\n                                                              -1\n                                                              -3\n                                                               5\n"
        },
        {
            "input": "4 4\n4 4 2 4\n1 2\n2 3\n3 4\n4 1\n",
            "output": "NO\n"
        },
        {
            "input": "3 3\n2 2 2\n1 2\n2 3\n1 3\n",
            "output": "YES\n                                                               1\n                                                               1\n                                                               1\n"
        },
        {
            "input": "4 3\n-1 0 2 1\n1 2\n2 3\n3 4\n",
            "output": "YES\n                                                              -1\n                                                               1\n                                                               1\n"
        }
    ],
    "generated_test": [
        {
            "input": "8 12\n-6 2 -3 2 6 -7 1 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 3\n8 4\n3 7\n7 6\n6 1\n",
            "output": "NO\n"
        },
        {
            "input": "10 12\n5 1 1 8 -8 10 -3 -2 1 7\n5 3\n8 2\n10 9\n4 6\n5 6\n4 5\n5 10\n4 7\n8 4\n3 1\n1 6\n6 10\n",
            "output": "YES\n-4\n1\n1\n11\n-7\n3\n0\n-3\n-3\n5\n0\n6\n"
        },
        {
            "input": "20 40\n-9 -10 -9 15 -3 -5 -17 -10 -6 2 -13 19 10 -15 15 -14 17 0 7 -8\n3 17\n6 18\n15 12\n2 5\n18 3\n16 20\n6 17\n20 10\n10 18\n9 12\n15 3\n6 4\n15 16\n20 6\n20 9\n9 4\n4 8\n14 5\n11 7\n12 11\n3 13\n14 19\n7 17\n16 14\n19 7\n12 13\n14 13\n13 11\n9 14\n13 17\n8 19\n5 20\n2 17\n2 6\n12 5\n8 1\n20 3\n6 2\n5 18\n13 8\n",
            "output": "YES\n-30\n-21\n-23\n-10\n21\n-52\n0\n2\n0\n-9\n0\n16\n38\n0\n42\n0\n-1\n7\n-64\n51\n0\n7\n47\n0\n0\n0\n10\n0\n-39\n0\n0\n0\n0\n0\n0\n-9\n0\n0\n0\n0\n"
        },
        {
            "input": "5 7\n4 1 3 3 -1\n2 4\n5 4\n5 2\n1 5\n1 2\n4 1\n1 3\n",
            "output": "YES\n3\n0\n-2\n1\n0\n0\n3\n"
        },
        {
            "input": "10 12\n5 1 1 8 -8 10 -3 -2 1 7\n5 3\n8 2\n10 9\n4 1\n5 6\n4 5\n5 10\n4 7\n8 4\n3 1\n3 6\n6 10\n",
            "output": "YES\n-10\n1\n1\n5\n-7\n9\n0\n-3\n-3\n0\n11\n6\n"
        },
        {
            "input": "4 3\n-1 0 2 1\n1 4\n2 3\n3 4\n",
            "output": "YES\n-1\n0\n2\n"
        },
        {
            "input": "10 13\n5 4 -3 8 6 1 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n10 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "YES\n-8\n11\n-17\n2\n14\n3\n1\n6\n0\n-7\n0\n0\n2\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 1 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 3\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "4 3\n-1 0 2 2\n1 2\n2 3\n3 4\n",
            "output": "NO\n"
        },
        {
            "input": "8 12\n-6 2 -3 2 1 -7 1 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 3\n8 4\n3 7\n7 6\n6 1\n",
            "output": "NO\n"
        },
        {
            "input": "8 12\n-6 2 -3 2 6 -7 2 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 3\n8 4\n3 7\n7 6\n3 1\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -3 8 6 4 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-23 -18 -35 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 0 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 3\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "2 1\n2 1\n1 2\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 1 5 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 0 8 6 4 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -7 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 0 0 6 4 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -7 9 -19 -39 -25 -32 32 -36 28 1 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "2 1\n1 0\n2 1\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -3 8 6 4 -5 1 3 -12\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 1 3 -11\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -32 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 3\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "8 12\n-6 2 -3 1 1 -7 1 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 3\n8 4\n3 7\n7 6\n6 1\n",
            "output": "NO\n"
        },
        {
            "input": "8 12\n-6 2 -3 1 6 -7 2 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 3\n8 4\n3 7\n7 6\n3 1\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -3 8 6 1 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n29 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -7 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 14 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 0 0 6 4 -5 2 3 -7\n9 5\n9 2\n10 3\n2 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -7 12 -19 -39 -25 -32 32 -36 28 1 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -3 8 9 4 -5 1 3 -12\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 12\n5 1 1 8 -8 10 -3 -2 1 7\n5 3\n8 2\n10 9\n4 1\n5 6\n4 5\n10 10\n4 7\n8 4\n3 1\n3 6\n6 10\n",
            "output": "YES\n-10\n1\n1\n5\n-7\n9\n0\n-3\n-3\n0\n11\n6\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 1 3 -11\n9 5\n9 2\n10 4\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n5 4 -3 8 6 1 -5 2 3 -7\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-29 -18 -35 21 -12 38 -35 -11 28 -20 27 -7 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 55 -30 -40 14 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 5\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n20 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 0 0 6 4 -5 2 3 -7\n9 5\n9 2\n10 3\n2 4\n3 5\n4 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -3 8 9 4 -5 1 3 -12\n9 5\n9 2\n10 3\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 3\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 0 3 -11\n9 5\n9 2\n10 4\n1 4\n3 5\n9 1\n6 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "10 13\n3 4 -4 8 6 4 -5 0 3 -11\n9 5\n9 2\n10 4\n1 4\n3 5\n9 1\n7 10\n10 4\n3 1\n2 7\n1 6\n1 7\n7 8\n",
            "output": "NO\n"
        },
        {
            "input": "8 12\n-6 2 -3 2 6 -7 1 -5\n2 1\n5 6\n1 6\n1 4\n8 2\n2 7\n2 5\n8 6\n8 4\n3 7\n7 6\n3 1\n",
            "output": "NO\n"
        },
        {
            "input": "43 52\n-23 -18 -35 21 -12 38 -35 -11 28 -20 27 -5 9 -19 -39 -25 -32 32 -36 28 11 37 1 -25 -22 9 -15 21 25 -39 10 36 -30 -40 22 26 25 -27 -22 -38 -1 18 -13\n33 40\n31 23\n30 26\n21 17\n6 2\n41 19\n32 39\n32 23\n13 14\n25 35\n31 30\n19 32\n25 22\n34 36\n7 40\n23 6\n40 12\n1 3\n23 43\n36 13\n18 33\n17 32\n7 3\n21 34\n41 35\n20 7\n23 1\n41 8\n25 19\n16 29\n42 5\n40 21\n9 37\n17 41\n30 10\n41 18\n39 1\n20 24\n20 4\n42 3\n20 25\n5 16\n31 9\n42 28\n10 11\n19 42\n31 38\n25 2\n31 27\n17 25\n13 15\n31 20\n",
            "output": "NO\n"
        },
        {
            "input": "10 12\n5 1 1 8 -8 10 -3 -2 1 7\n5 3\n8 2\n10 9\n4 6\n5 6\n4 5\n5 10\n4 7\n8 4\n3 1\n2 6\n6 10\n",
            "output": "YES\n-4\n1\n1\n11\n-7\n3\n0\n-3\n-3\n5\n0\n6\n"
        },
        {
            "input": "6 6\n3 5 5 5 1 5\n1 4\n3 2\n4 1\n4 5\n3 5\n5 6\n",
            "output": "NO\n"
        },
        {
            "input": "4 4\n4 4 2 4\n1 2\n2 3\n3 2\n4 1\n",
            "output": "NO\n"
        },
        {
            "input": "4 3\n-1 0 4 1\n1 2\n2 3\n3 4\n",
            "output": "NO\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int M = N * 25;\nint n, m;\nlong long C[M], x, y, tar[N], dep[N], in[M];\nint fir[N], ne[M], to[M], cnt = 1, fa[N], fan[N];\nvoid add(int x, int y) {\n  ne[++cnt] = fir[x];\n  fir[x] = cnt;\n  to[cnt] = y;\n}\nvoid link(int x, int y) {\n  add(x, y);\n  add(y, x);\n}\nbool vis[N];\nint dfs(int x, int f) {\n  int res = 0;\n  fa[x] = f;\n  dep[x] = dep[f] + 1;\n  vis[x] = 1;\n  for (int i = fir[x]; i; i = ne[i]) {\n    int V = to[i];\n    if (vis[V]) {\n      if (V != f) {\n        if ((dep[V] + dep[x]) & 1)\n          ;\n        else\n          res = i;\n      }\n      continue;\n    }\n    int cur = 0;\n    if (cur = dfs(V, x)) res = cur;\n    if (tar[V]) {\n      tar[x] -= tar[V];\n      C[i] += tar[V];\n      C[i ^ 1] += tar[V];\n      tar[V] = 0;\n    }\n    fan[V] = i;\n  }\n  return res;\n}\nvoid Bush(int x) {\n  while (fa[x]) {\n    tar[fa[x]] -= tar[x];\n    C[fan[x]] += tar[x];\n    C[fan[x] ^ 1] += tar[x];\n    tar[x] = 0;\n    x = fa[x];\n  }\n}\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &tar[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d%d\", &x, &y), link(x, y);\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      int cur = dfs(i, 0), a;\n      if ((tar[i]) & 1 || (!cur && tar[i])) return puts(\"NO\") * 0;\n      a = (dep[to[cur]] & 1);\n      C[cur] = C[cur ^ 1] += tar[i] / 2 * (a ? 1 : (-1));\n      tar[to[cur ^ 1]] = tar[to[cur]] = -tar[i] / 2 * (a ? 1 : (-1));\n      Bush(to[cur]);\n      Bush(to[cur ^ 1]);\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", C[i * 2]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<long long, long long> > > g;\nvector<long long> ans;\nvector<long long> c;\nvector<bool> used;\nvector<long long> dp;\nvector<long long> col;\nvector<long long> p;\nlong long val = 0;\nlong long pos = 0;\nlong long pos2 = 0;\nvoid doit(long long v) {\n  used[v] = 1;\n  for (auto i : g[v]) {\n    if (!used[i.first]) {\n      p[i.first] = v;\n      doit(i.first);\n      ans[i.second] = c[i.first] - dp[i.first];\n      dp[i.first] += ans[i.second];\n      dp[v] += ans[i.second];\n    }\n  }\n}\nbool dfs(long long v) {\n  used[v] = 1;\n  for (auto i : g[v]) {\n    if (!used[i.first]) {\n      col[i.first] = col[v] ^ 1;\n      if (dfs(i.first)) return 1;\n    } else {\n      if (col[i.first] != col[v] ^ 1) {\n        val = i.second;\n        pos = i.first;\n        pos2 = v;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  iostream::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  ans.resize(m);\n  g.resize(n);\n  c.resize(n);\n  dp.resize(n);\n  p.resize(n);\n  for (long long i = 0; i < n; i++) cin >> c[i];\n  for (long long i = 0; i < m; i++) {\n    long long a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back({b, i});\n    g[b].push_back({a, i});\n  }\n  used.assign(n, 0);\n  doit(0);\n  if (dp[0] == c[0]) {\n    cout << \"YES\\n\";\n    for (long long i : ans) cout << i << '\\n';\n    return 0;\n  }\n  used.assign(n, 0);\n  col.resize(n);\n  col[0] = 0;\n  if (!dfs(0)) {\n    cout << \"NO\";\n    return 0;\n  }\n  cout << \"YES\\n\";\n  vector<long long> to;\n  long long now = pos;\n  while (now != 0) {\n    to.push_back(now);\n    now = p[now];\n  }\n  reverse(to.begin(), to.end());\n  now = 0;\n  for (long long i = 0; i < to.size(); i++) {\n    for (auto j : g[now]) {\n      if (j.first == to[i]) {\n        long long up = c[now] - dp[now];\n        ans[j.second] += up;\n        dp[now] += up;\n        dp[j.first] += up;\n      }\n    }\n    now = to[i];\n  }\n  if ((c[pos] - dp[pos]) % 2 != 0) {\n    return -1;\n  }\n  long long up = (c[pos] - dp[pos]) / 2;\n  ans[val] += up;\n  dp[pos] += up;\n  dp[pos2] += up;\n  to.clear();\n  now = pos2;\n  while (now != pos) {\n    to.push_back(now);\n    now = p[now];\n  }\n  reverse(to.begin(), to.end());\n  now = pos;\n  for (long long i = 0; i < to.size(); i++) {\n    for (auto j : g[now]) {\n      if (j.first == to[i]) {\n        long long up = c[now] - dp[now];\n        ans[j.second] += up;\n        dp[now] += up;\n        dp[j.first] += up;\n      }\n    }\n    now = to[i];\n  }\n  for (long long i : ans) cout << i << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef divisors(M):\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    return d\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 0x0000007f\n\ndef eratosthenes(n):\n    res=[0 for i in range(n+1)]\n    prime=set([])\n    for i in range(2,n+1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1,n//i+1):\n                res[i*j]=1\n    return prime\n\ndef factorization(n):\n    res=[]\n    for p in prime:\n        if n%p==0:\n            while n%p==0:\n                n//=p\n            res.append(p)\n    if n!=1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2,n+1):\n        if x ** 2 > n:\n            break\n        if n%x==0:\n            res = res//x * (x-1)\n            while n%x==0:\n                n //= x\n    if n!=1:\n        res = res//n * (n-1)\n    return res\n\ndef ind(b,n):\n    res=0\n    while n%b==0:\n        res+=1\n        n//=b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i*i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p]+1):\n                newres.append(d*p**j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num==0:\n        return 0\n    elif num==1:\n        return 1\n    elif num==2:\n        return 3\n    elif num==3:\n        return 0\n    else:\n        x=baseorder(num)\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\ndef merge_sort(A,B):\n    pos_A,pos_B = 0,0\n    n,m = len(A),len(B)\n    res = []\n    while pos_A < n and pos_B < m:\n        a,b = A[pos_A],B[pos_B]\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind():\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self,v,pv):\n        stack = [(v,pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            v,pv = stack.pop()\n            self.parent[v] = new_parent\n            for nv,w in self.edge[v]:\n                if nv!=pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv,v))\n\n    def unite(self,x,y,w):\n        if not self.flag:\n            return\n        if self.parent[x]==self.parent[y]:\n            self.flag = (self.val[x] - self.val[y] == w)\n            return\n\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y,x)\n        else:\n            self.edge[x].append((y,-w))\n            self.edge[y].append((x,w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x,y)\n\nclass Dijkstra():\n    class Edge():\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10**15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\n#O(|S|)\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT():\n    def __init__(self,n,mod=0):\n        self.BIT = [0]*(n+1)\n        self.num = n\n        self.mod = mod\n\n    def query(self,idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx&(-idx)\n        return\n\nclass dancinglink():\n    def __init__(self,n,debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i-1 for i in range(n)]\n        self._right = [i+1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self,k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L!=-1:\n            if R!=self.n:\n                self._right[L],self._left[R] = R,L\n            else:\n                self._right[L] = self.n\n        elif R!=self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res==-1:\n                break\n            k -= 1\n        return res\n\n    def right(self,idx,k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res==self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable():\n    def __init__(self,A,merge_func,ide_ele):\n        N=len(A)\n        n=N.bit_length()\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\n        self.merge_func=merge_func\n\n        for i in range(N):\n            self.table[i][0]=A[i]\n\n        for j in range(1,n):\n            for i in range(0,N-2**j+1):\n                f=self.table[i][j-1]\n                s=self.table[i+2**(j-1)][j-1]\n                self.table[i][j]=self.merge_func(f,s)\n\n    def query(self,s,t):\n        b=t-s+1\n        m=b.bit_length()-1\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\n\nclass BinaryTrie:\n    class node:\n        def __init__(self,val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10**15)\n\n    def append(self,key,val):\n        pos = self.root\n        for i in range(29,-1,-1):\n            pos.max = max(pos.max,val)\n            if key>>i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            else:\n                if pos.left is None:\n                    pos.left = self.node(val)\n                    pos = pos.left\n                else:\n                    pos = pos.left\n        pos.max = max(pos.max,val)\n\n    def search(self,M,xor):\n        res = -10**15\n        pos = self.root\n        for i in range(29,-1,-1):\n            if pos is None:\n                break\n\n            if M>>i & 1:\n                if xor>>i & 1:\n                    if pos.right:\n                        res = max(res,pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res,pos.left.max)\n                    pos = pos.right\n            else:\n                if xor>>i & 1:\n                    pos = pos.right\n                else:\n                    pos = pos.left\n\n        if pos:\n            res = max(res,pos.max)\n        return res\n\ndef solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y!=0:\n            return False\n    return x\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\nclass SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        if r==self.size:\n            r = self.num\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nimport sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\nn,m = mi()\nc = li()\nedge = [[] for i in range(n)]\nfor i in range(m):\n    u,v = mi()\n    edge[u-1].append((v-1,i))\n    edge[v-1].append((u-1,i))\n\nparent = [(-1,-1) for v in range(n)]\ntree_edge = [[] for v in range(n)]\ndepth = [0 for v in range(n)]\nspecial = None\n\nstack = [0]\ncnt = [0 for v in range(n)]\nwhile stack:\n    v = stack[-1]\n    if cnt[v]==len(edge[v]):\n        stack.pop()\n    else:\n        nv,idx = edge[v][cnt[v]]\n        cnt[v] += 1\n        if nv==0 or parent[nv]!=(-1,-1):\n            if depth[nv] < depth[v] and (depth[v]-depth[nv])%2==0 and not special:\n                special = (v,nv,idx)\n        else:\n            parent[nv] = (v,idx)\n            depth[nv] = depth[v] + 1\n            tree_edge[v].append((nv,idx))\n            stack.append(nv)\n\nif not special:\n    even = 0\n    odd = 0\n    for v in range(n):\n        if depth[v]&1:\n            odd += c[v]\n        else:\n            even += c[v]\n    if odd!=even:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\n        deq = deque([0])\n        topo = []\n        while deq:\n            v = deq.popleft()\n            topo.append(v)\n            for nv,idx in tree_edge[v]:\n                deq.append(nv)\n\n        ans = [0 for i in range(m)]\n        for v in topo[::-1]:\n            if v==0:\n                continue\n            _,i = parent[v]\n            ans[i] = c[v]\n            for nv,idx in tree_edge[v] :\n                ans[i] -= ans[idx]\n        print(*ans,sep=\"\\n\")\nelse:\n    print(\"YES\")\n\n    even = 0\n    odd = 0\n    for v in range(n):\n        if depth[v]&1:\n            odd += c[v]\n        else:\n            even += c[v]\n\n    ans = [0 for i in range(m)]\n\n    v,nv,idx = special\n    if depth[v]&1:\n        ans[idx] -= (even-odd)//2\n        c[v] += (even-odd)//2\n        c[nv] += (even-odd)//2\n    else:\n        ans[idx] -= (odd-even)//2\n        c[v] += (odd-even)//2\n        c[nv] += (odd-even)//2\n\n    #print(ans)\n\n    deq = deque([0])\n    topo = []\n    while deq:\n        v = deq.popleft()\n        topo.append(v)\n        for nv,idx in tree_edge[v]:\n            deq.append(nv)\n\n    for v in topo[::-1]:\n        if v==0:\n            continue\n        _,i = parent[v]\n        ans[i] = c[v]\n        for nv,idx in tree_edge[v] :\n            ans[i] -= ans[idx]\n    print(*ans,sep=\"\\n\")\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1000000000\")\nusing namespace std;\nconst int maxn = (int)1e5 + 10;\nint ver = -1;\nint num = -1;\nlong long c[maxn];\nvector<pair<int, int> > ed[maxn];\nlong long res[maxn];\nint h[maxn];\nvector<pair<int, int> > e[maxn];\nvoid dfs(int v, int d) {\n  h[v] = d;\n  for (int i = 0; i < (int)ed[v].size(); i++) {\n    int u = ed[v][i].first;\n    if (h[u] == -1) {\n      e[v].push_back(make_pair(u, ed[v][i].second));\n      e[u].push_back(make_pair(v, ed[v][i].second));\n      dfs(u, d + 1);\n    }\n  }\n}\nbool used[maxn];\nlong long go(int v) {\n  used[v] = true;\n  long long ans = c[v];\n  for (int i = 0; i < (int)e[v].size(); i++) {\n    int u = e[v][i].first;\n    int w = e[v][i].second;\n    if (w == num) {\n      continue;\n    }\n    if (!used[u]) {\n      long long now = go(u);\n      res[w] = now;\n      ans -= now;\n    }\n  }\n  return ans;\n}\npair<int, int> edg[maxn];\nint main() {\n  memset(h, -1, sizeof h);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &c[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    edg[i] = make_pair(a, b);\n    ed[a].push_back(make_pair(b, i));\n    ed[b].push_back(make_pair(a, i));\n  }\n  dfs(1, 0);\n  for (int i = 0; i < m; i++) {\n    int a = edg[i].first;\n    int b = edg[i].second;\n    int dst = abs(h[a] - h[b]);\n    if (dst % 2 == 0) {\n      ver = a;\n      num = i;\n      break;\n    }\n  }\n  if (ver == -1) {\n    ver = 1;\n  }\n  long long ch = go(ver);\n  if (ch == 0) {\n    cout << \"YES\" << endl;\n    for (int i = 0; i < m; i++) {\n      printf(\"%lld\\n\", res[i]);\n    }\n    return 0;\n  }\n  if (num == -1 || ch % 2 != 0) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  res[num] = ch / 2;\n  c[edg[num].first] -= ch / 2;\n  c[edg[num].second] -= ch / 2;\n  memset(used, 0, sizeof used);\n  ch = go(ver);\n  if (ch != 0) {\n    throw 1;\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < m; i++) {\n    printf(\"%lld\\n\", res[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nint n, m;\nint want[MAXN];\nvector<pair<int, int> > adj[MAXN];\nbool intree[MAXM];\nint oddroot;\nint col[MAXN];\nvoid dfs(int at, int par) {\n  col[at] = par == -1 ? 0 : 1 - col[par];\n  for (int i = (0); i < (((int)(adj[at]).size())); ++i) {\n    int to = adj[at][i].first;\n    if (to == par) continue;\n    if (col[to] == -1) {\n      intree[adj[at][i].second] = true;\n      dfs(to, at);\n    } else {\n      if (oddroot == -1 && col[to] == col[at]) oddroot = at;\n    }\n  }\n}\nlong long ans[MAXM];\nlong long solve(int at, int parid) {\n  long long sum = 0;\n  for (int i = (0); i < (((int)(adj[at]).size())); ++i) {\n    int to = adj[at][i].first, id = adj[at][i].second;\n    if (id == parid || !intree[id]) continue;\n    long long childsum = solve(to, id);\n    ans[id] = want[to] - childsum;\n    sum += ans[id];\n  }\n  return sum;\n}\nbool modify(int at, int parid, long long by, long long sby) {\n  for (int i = (0); i < (((int)(adj[at]).size())); ++i) {\n    int to = adj[at][i].first, id = adj[at][i].second;\n    if (id == parid) continue;\n    if (to == oddroot && by == sby) {\n      ans[id] += by;\n      return true;\n    }\n    if (!intree[id]) continue;\n    if (modify(to, id, -by, sby)) {\n      ans[id] += by;\n      return true;\n    }\n  }\n  return false;\n}\nvoid run() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", &want[i]);\n  for (int i = (0); i < (m); ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a, --b;\n    adj[a].push_back(make_pair(b, i));\n    adj[b].push_back(make_pair(a, i));\n    intree[i] = false;\n  }\n  memset(col, -1, sizeof(col));\n  oddroot = -1;\n  dfs(0, -1);\n  int root = oddroot;\n  if (root == -1) root = 0;\n  memset(ans, 0, sizeof(ans));\n  int childsum = solve(root, -1);\n  long long diff = want[root] - childsum;\n  if (diff != 0 && oddroot != -1) {\n    assert(diff % 2 == 0);\n    assert(modify(root, -1, diff / 2, diff / 2));\n    diff = 0;\n  }\n  if (diff != 0) {\n    printf(\"NO\\n\");\n    return;\n  }\n  for (int i = (0); i < (m); ++i) assert(abs(ans[i]) <= (long long)2 * n * n);\n  printf(\"YES\\n\");\n  for (int i = (0); i < (m); ++i) printf(\"%lld\\n\", ans[i]);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1LL << 60;\nbool vis[100005];\nint to[200005];\nlong long deg[100005];\nint dep[100005];\nvector<int> G[100005];\nlong long used[200005];\nlong long rem[100005];\nvoid dfs(int v, int par, int ce) {\n  vis[v] = true;\n  dep[v] = dep[par] + 1;\n  rem[v] = deg[v];\n  for (int k = 0; k < (G[v].size()); k++) {\n    int e = G[v][k], u = to[e];\n    if (u == par || vis[u]) continue;\n    dfs(u, v, e ^ 1);\n    rem[v] -= used[e];\n  }\n  if (ce != -1) {\n    used[ce] = used[ce ^ 1] = rem[v];\n    rem[v] = 0;\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int k = 1; k <= (n); k++) scanf(\"%I64d\", &deg[k]);\n  for (int k = 0; k < (m); k++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(k << 1);\n    G[v].push_back(k << 1 | 1);\n    to[k + k] = v;\n    to[k + k + 1] = u;\n  }\n  memset(vis, false, sizeof(vis));\n  dfs(1, 0, -1);\n  for (int k = 0; k < (m); k++) {\n    int u = to[k << 1], v = to[k << 1 | 1];\n    if (used[k << 1] != 0LL || (dep[u] - dep[v]) & 1) continue;\n    long long cd = rem[1] >> 1;\n    if (!(dep[u] & 1)) cd = -cd;\n    used[k << 1] = used[k << 1 | 1] = cd;\n    deg[u] -= cd;\n    deg[v] -= cd;\n    break;\n  }\n  memset(vis, false, sizeof(vis));\n  dfs(1, 0, -1);\n  if (rem[1] == 0LL) {\n    printf(\"YES\\n\");\n    for (int k = 0; k < (m); k++) printf(\"%I64d\\n\", used[k << 1]);\n  } else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  char c = getchar();\n  int x = 0, f = 1;\n  while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();\n  return x * f;\n}\nconst int N = 1e5 + 10;\nstruct Edge {\n  int nxt, point;\n} edge[N << 1];\nint tot = 1, head[N];\nint dep[N];\npair<int, int> e[N];\nlong long f[N], w[N], c[N], now[N];\nint Id[N << 1];\nbool used[N];\nvoid add_edge(int u, int v) {\n  edge[++tot].nxt = head[u];\n  edge[tot].point = v;\n  head[u] = tot;\n}\nvoid dfs(int u, int fa) {\n  dep[u] = dep[fa] + 1;\n  used[u] = 1;\n  for (int i = head[u]; i; i = edge[i].nxt) {\n    int v = edge[i].point;\n    if (used[v]) continue;\n    dfs(v, u);\n    f[Id[i]] = c[v] - now[v];\n    now[u] += f[Id[i]];\n  }\n}\nvoid calc(int u) {\n  used[u] = 1;\n  for (int i = head[u]; i; i = edge[i].nxt) {\n    int v = edge[i].point;\n    if (used[v]) continue;\n    calc(v);\n    f[Id[i]] = c[v] - now[v];\n    now[u] += f[Id[i]];\n  }\n}\nint main() {\n  int n = read(), m = read();\n  long long mx = 2ll * n * n;\n  for (int i = 1; i <= n; ++i) c[i] = read();\n  for (int i = 1; i <= m; ++i) {\n    int u = read(), v = read();\n    e[i] = make_pair(u, v);\n    add_edge(u, v);\n    add_edge(v, u);\n    Id[tot] = Id[tot ^ 1] = i;\n  }\n  dfs(1, 0);\n  if (now[1] == c[1]) {\n    for (int i = 1; i <= m; ++i) {\n      if (-mx <= f[i] && mx >= f[i]) continue;\n      puts(\"NO\");\n      return 0;\n    }\n    puts(\"YES\");\n    for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", f[i]);\n  } else {\n    if ((c[1] - now[1]) & 1) return puts(\"NO\"), 0;\n    for (int i = 1; i <= m; ++i) {\n      int u = e[i].first, v = e[i].second;\n      if (abs(dep[u] - dep[v]) & 1)\n        continue;\n      else {\n        long long x = ((c[1] - now[1]) / 2);\n        if (abs(dep[u] - dep[1]) & 1) x = -x;\n        memset(now, 0, sizeof(now));\n        memset(f, 0, sizeof(f));\n        memset(used, 0, sizeof(used));\n        f[i] = x;\n        now[u] = x, now[v] = x;\n        calc(1);\n        assert(c[1] == now[1]);\n        for (int i = 1; i <= m; ++i) {\n          if (-mx <= f[i] && mx >= f[i]) continue;\n          return puts(\"NO\"), 0;\n        }\n        puts(\"YES\");\n        for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", f[i]);\n        return 0;\n      }\n    }\n    puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1e5 + 5;\nint root[MAX_N];\nint find(int u) {\n  if (root[u] != u) {\n    root[u] = find(root[u]);\n  }\n  return root[u];\n}\nvoid merge(int u, int v) {\n  u = find(u);\n  v = find(v);\n  root[u] = v;\n}\nmap<pair<int, int>, int> idx;\nset<int> adj[MAX_N];\nlong long arr[MAX_N];\nlong long ans[MAX_N];\nlong long cur[MAX_N];\nvoid add_edge(int u, int v) {\n  adj[u].insert(v);\n  adj[v].insert(u);\n}\nint color[MAX_N];\nvoid dfs(int u, int c) {\n  color[u] = c;\n  for (int nxt : adj[u]) {\n    if (color[nxt] == 0) {\n      dfs(nxt, -c);\n    }\n  }\n}\nvector<int> Q;\nvoid del(int v) {\n  int u = *adj[v].begin();\n  ans[idx[{u, v}]] = cur[v];\n  cur[u] -= cur[v];\n  cur[v] -= cur[v];\n  adj[v].erase(u);\n  adj[u].erase(v);\n  if ((int)adj[u].size() == 1) {\n    Q.push_back(u);\n  }\n}\nvector<int> cycle;\nvoid find_cycle(int u, int p) {\n  cycle.push_back(u);\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      if (nxt == cycle[0]) return;\n      find_cycle(nxt, u);\n      return;\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n    cur[i] = arr[i];\n    root[i] = i;\n  }\n  vector<pair<int, int>> edges;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    edges.push_back({u, v});\n    idx[make_pair(u, v)] = i;\n    idx[make_pair(v, u)] = i;\n    if (find(u) != find(v)) {\n      merge(u, v);\n      add_edge(u, v);\n    }\n  }\n  dfs(1, 1);\n  bool oddc = false;\n  for (auto e : edges) {\n    if (color[e.first] == color[e.second]) {\n      add_edge(e.first, e.second);\n      oddc = true;\n      break;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if ((int)adj[i].size() == 1) {\n      Q.push_back(i);\n    }\n  }\n  while (!Q.empty()) {\n    int u = Q.back();\n    Q.pop_back();\n    if ((int)adj[u].size() == 1) {\n      del(u);\n    }\n  }\n  if (oddc) {\n    int root = -1;\n    for (int i = 1; i <= n; i++) {\n      if (!adj[i].empty()) {\n        root = i;\n      }\n    }\n    find_cycle(root, root);\n    long long last = 0;\n    for (int i = 0; i < (int)cycle.size(); i++) {\n      if (i % 2 == 0)\n        last += cur[cycle[i]];\n      else\n        last -= cur[cycle[i]];\n    }\n    last /= 2;\n    ans[idx[{cycle[0], cycle.back()}]] = last;\n    for (int i = (int)cycle.size() - 1; i >= 1; i--) {\n      long long diff = cur[cycle[i]] - last;\n      ans[idx[{cycle[i - 1], cycle[i]}]] = diff;\n      last = diff;\n    }\n  }\n  for (auto e : edges) {\n    arr[e.first] -= ans[idx[e]];\n    arr[e.second] -= ans[idx[e]];\n  }\n  for (int i = 1; i <= n; i++) {\n    if (arr[i] != 0) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < m; i++) {\n    cout << ans[i] << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        long[] want;\n        List<TaskD.Edge>[] graph;\n        public OutputWriter out;\n        public long[] ret;\n        public int[] color;\n        public boolean bipartite;\n        public boolean[] vis;\n\n        public void solve(int testNumber, InputReader in, OutputWriter _out) {\n            out = _out;\n            int n = in.nextInt(), m = in.nextInt();\n            want = in.readLongArray(n);\n            graph = LUtils.genArrayList(n);\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(new TaskD.Edge(b, i));\n                graph[b].add(new TaskD.Edge(a, i));\n            }\n\n            bipartite = true;\n            color = new int[n];\n            vis = new boolean[n];\n            dfs(0, -1, 0);\n            long s1 = 0, s2 = 0;\n            for (int i = 0; i < n; i++) {\n                if (color[i] == 0) s1 += want[i];\n                else s2 += want[i];\n            }\n\n            ret = new long[m];\n            if (s1 != s2) {\n                boolean fixed = false;\n                outer:\n                for (int i = 0; i < n; i++) {\n                    for (TaskD.Edge e : graph[i]) {\n                        if (color[i] == color[e.to]) {\n                            if (color[i] == 0) ret[e.idx] += (s1 - s2) / 2;\n                            else ret[e.idx] += (s2 - s1) / 2;\n                            want[i] -= ret[e.idx];\n                            want[e.to] -= ret[e.idx];\n                            fixed = true;\n                            break outer;\n                        }\n                    }\n                }\n                if (!fixed) {\n                    out.println(\"NO\");\n                    return;\n                }\n            }\n            vis = new boolean[n];\n            dfs2(0, -1, -1);\n\n            out.println(\"YES\");\n            for (long x : ret) out.println(x);\n        }\n\n        public void dfs2(int node, int par, int pedge) {\n            vis[node] = true;\n            for (TaskD.Edge next : graph[node]) {\n                if (vis[next.to]) continue;\n                dfs2(next.to, node, next.idx);\n            }\n            if (want[node] != 0) {\n                long add = want[node];\n                ret[pedge] += add;\n                want[par] -= add;\n                want[node] -= add;\n            }\n        }\n\n        public void dfs(int node, int par, int c) {\n            if (vis[node]) {\n                return;\n            }\n            vis[node] = true;\n            color[node] = c;\n            for (TaskD.Edge next : graph[node]) {\n                if (next.to == par) continue;\n                dfs(next.to, node, 1 - c);\n            }\n        }\n\n        static class Edge {\n            public int to;\n            public int idx;\n\n            public Edge(int to, int idx) {\n                this.to = to;\n                this.idx = idx;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int tokens) {\n            long[] ret = new long[tokens];\n            for (int i = 0; i < tokens; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public long nextLong() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            long res = 0L;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10L;\n                res += (long) (c - 48);\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * (long) sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long rd() {\n  long long _x = 0;\n  int _ch = getchar(), _f = 1;\n  for (; !isdigit(_ch) && (_ch != '-') && (_ch != EOF); _ch = getchar())\n    ;\n  if (_ch == '-') {\n    _f = 0;\n    _ch = getchar();\n  }\n  for (; isdigit(_ch); _ch = getchar()) _x = _x * 10 + _ch - '0';\n  return _f ? _x : -_x;\n}\nvoid write(long long _x) {\n  if (_x >= 10)\n    write(_x / 10), putchar(_x % 10 + '0');\n  else\n    putchar(_x + '0');\n}\ninline void wrt(long long _x, char _p) {\n  if (_x < 0) putchar('-'), _x = -_x;\n  write(_x);\n  if (_p) putchar(_p);\n}\nint X[100005], Y[100005];\nvector<pair<int, int> > G[100005];\nint dep[100005];\nbool vis[100005];\nbool tag[100005];\nint f[100005][20];\nlong long Ans[100005];\nlong long C[100005];\nvoid dfs(int u, int fa) {\n  vis[u] = 1;\n  f[u][0] = fa;\n  dep[u] = dep[fa] + 1;\n  for (int i = int(1); i <= (int)(19); i++) f[u][i] = f[f[u][i - 1]][i - 1];\n  for (auto i : G[u])\n    if (!vis[i.first]) {\n      tag[i.second] = 1;\n      dfs(i.first, u);\n      Ans[i.second] = C[i.first];\n      C[u] -= Ans[i.second];\n    }\n}\nint lca(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  for (int i = int(19); i >= (int)(0); i--)\n    if (dep[f[x][i]] > dep[y]) x = f[x][i];\n  if (x == y) return x;\n  for (int i = int(19); i >= (int)(0); i--)\n    if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];\n  return f[x][0];\n}\nint n, m;\nint Tmp[100005];\nint main() {\n  n = rd(), m = rd();\n  for (int i = int(1); i <= (int)(n); i++) C[i] = Tmp[i] = rd();\n  for (int i = int(1); i <= (int)(m); i++) {\n    X[i] = rd(), Y[i] = rd();\n    G[X[i]].push_back(make_pair(Y[i], i));\n    G[Y[i]].push_back(make_pair(X[i], i));\n  }\n  dfs(1, 0);\n  if (abs(C[1]) % 2 != 0) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  for (int i = int(1); i <= (int)(m); i++)\n    if (!tag[i]) {\n      if ((dep[X[i]] + dep[Y[i]] - 2 * dep[lca(X[i], Y[i])]) % 2 != 0) continue;\n      Ans[i] = C[1] / 2 * (dep[X[i]] % 2 == 0 ? -1 : 1);\n      Tmp[X[i]] -= Ans[i], Tmp[Y[i]] -= Ans[i];\n      break;\n    }\n  memset(tag, 0, sizeof tag), memset(vis, 0, sizeof vis);\n  for (int i = int(1); i <= (int)(n); i++) C[i] = Tmp[i];\n  dfs(1, 0);\n  if (C[1] != 0) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  printf(\"YES\\n\");\n  for (int i = int(1); i <= (int)(m); i++) wrt(Ans[i], '\\n');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint head[N], nxt[N << 1], to[N << 1], E;\nlong long ans[N];\nlong long val[N];\nint vst[N], dep[N];\nint fa[N];\nvector<int> path;\nvoid dfs(int u) {\n  for (int e = head[u]; ~e && path.empty(); e = nxt[e]) {\n    int v = to[e];\n    if (vst[v]) {\n      if (vst[v] == vst[u]) {\n        int U = u, V = v;\n        while (dep[U] > dep[V]) {\n          path.push_back(U);\n          U = fa[U];\n        }\n        stack<int> a;\n        while (dep[V] > dep[U]) {\n          a.push(V);\n          V = fa[V];\n        }\n        while (true) {\n          path.push_back(U);\n          if (U != V) {\n            a.push(V);\n          }\n          U = fa[U];\n          V = fa[V];\n          break;\n        }\n        while (!a.empty()) {\n          path.push_back(a.top());\n          a.pop();\n        }\n      }\n    } else {\n      vst[v] = vst[u] ^ 1;\n      fa[v] = u;\n      dep[v] = dep[u] + 1;\n      dfs(v);\n    }\n  }\n}\nvoid rdfs(int u) {\n  vst[u] = 1;\n  for (int e = head[u]; ~e; e = nxt[e]) {\n    int v = to[e];\n    if (vst[v]) {\n      continue;\n    }\n    rdfs(v);\n    ans[e >> 1] = val[v];\n    val[u] -= val[v];\n  }\n}\nint main() {\n  memset(head, -1, sizeof head);\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", val + i);\n  }\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    nxt[E] = head[u];\n    to[E] = v;\n    head[u] = E++;\n    nxt[E] = head[v];\n    to[E] = u;\n    head[v] = E++;\n  }\n  vst[1] = 2;\n  dfs(1);\n  memset(vst, 0, sizeof vst);\n  if (path.empty()) {\n    rdfs(1);\n    if (val[1]) {\n      puts(\"NO\");\n      return 0;\n    }\n  } else {\n    for (auto u : path) {\n      vst[u] = 2;\n    }\n    long long tot = 0;\n    long long crr = 0;\n    for (int i = 0; i < path.size(); i++) {\n      rdfs(path[i]);\n      tot += val[path[i]];\n      if (i > 1 && !(i & 1)) {\n        crr += val[path[i]];\n      }\n    }\n    if (tot & 1) {\n      puts(\"NO\");\n      return 0;\n    }\n    tot >>= 1;\n    for (int i = 0; i < path.size(); i++) {\n      int u = path[i];\n      int v = i + 1 < path.size() ? path[i + 1] : path[0];\n      for (int e = head[u]; ~e; e = nxt[e]) {\n        if (to[e] == v) {\n          ans[e >> 1] = tot - crr;\n          break;\n        }\n      }\n      crr = tot * 2 - crr - val[v];\n    }\n  }\n  puts(\"YES\");\n  for (int i = 0; i < m; i++) {\n    printf(\"%I64d\\n\", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  bool f = 0;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = 1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);\n  if (f) x = -x;\n}\ntemplate <typename F>\ninline void write(F x, char ed = '\\n') {\n  static short st[30];\n  short tp = 0;\n  if (x < 0) putchar('-'), x = -x;\n  do st[++tp] = x % 10, x /= 10;\n  while (x);\n  while (tp) putchar('0' | st[tp--]);\n  putchar(ed);\n}\ntemplate <typename T>\ninline void Mx(T &x, T y) {\n  x < y && (x = y);\n}\ntemplate <typename T>\ninline void Mn(T &x, T y) {\n  x > y && (x = y);\n}\nconst int N = 205000;\nlong long c[N], val[N], res[N];\nint h[N], ne[N << 1], to[N << 1], tot = 1, m, n;\ninline void add(int x, int y) { ne[++tot] = h[x], to[h[x] = tot] = y; }\nint dep[N], son[N], f[N], siz[N], Top[N], vis[N];\nvoid dfs1(int x, int fa) {\n  dep[x] = dep[f[x] = fa] + (siz[x] = vis[x] = 1), res[x] = c[x];\n  for (int i = h[x]; i; i = ne[i]) {\n    int y = to[i];\n    if (vis[y]) continue;\n    dfs1(y, x), siz[x] += siz[y];\n    if (siz[son[x]] < siz[y]) son[x] = y;\n    val[i >> 1] = res[y], res[x] -= res[y];\n  }\n}\nvoid dfs2(int x, int topf) {\n  Top[x] = topf, vis[x] = 1, son[x] && (dfs2(son[x], topf), 0);\n  for (int i = h[x], y; i; i = ne[i]) !vis[y = to[i]] && (dfs2(y, y), 0);\n}\nint Lca(int x, int y) {\n  while (Top[x] != Top[y]) {\n    if (dep[Top[x]] < dep[Top[y]]) swap(x, y);\n    x = f[Top[x]];\n  }\n  return dep[x] < dep[y] ? x : y;\n}\ninline void nope(void) {\n  puts(\"NO\");\n  exit(0);\n}\ninline void ojbk(void) {\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) write(val[i]);\n  exit(0);\n}\nint main() {\n  read(n), read(m);\n  for (int i = 1; i <= n; i++) read(c[i]);\n  for (int i = 1, x, y; i <= m; i++) read(x), read(y), add(x, y), add(y, x);\n  dfs1(1, 0), memset(vis, 0, sizeof(vis)), dfs2(1, 1);\n  (res[1] & 1) ? nope(), 0 : !res[1] && (ojbk(), 0);\n  for (int i = 1; i <= m; i++) {\n    int x = to[i * 2], y = to[(i * 2) ^ 1];\n    if ((dep[x] + dep[y]) & 1) continue;\n    int t = (dep[x] & 1) ? 2 : -2, tmp = res[1] / t;\n    val[i] = tmp, memset(vis, 0, sizeof(vis));\n    c[x] -= tmp, c[y] -= tmp, dfs1(1, 0), ojbk();\n  }\n  nope();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nvector<pair<int, int> > adj[111111];\nint color[111111];\nvector<pair<int, int> > odd_cycle;\npair<bool, int> find_odd_cycle(int v, int c) {\n  color[v] = c;\n  for (auto p : adj[v]) {\n    if (color[p.first] == c) {\n      odd_cycle.push_back(p);\n      return {true, p.first};\n    } else if (!color[p.first]) {\n      auto res = find_odd_cycle(p.first, 3 - c);\n      if (res.first) {\n        if (res.second != -1) odd_cycle.push_back(p);\n        if (res.second == v) res.second = -1;\n        return res;\n      }\n    }\n  }\n  return {false, -1};\n}\nlong long C[111111];\nlong long out[111111];\nbool visited[111111];\nlong long assign_values(int v) {\n  visited[v] = true;\n  for (auto p : adj[v])\n    if (!visited[p.first]) {\n      long long required = assign_values(p.first);\n      C[v] -= required;\n      C[p.first] -= required;\n      out[p.second] += required;\n    }\n  return C[v];\n}\npair<int, int> E[111111];\nint main() {\n  ios_base::sync_with_stdio(0);\n  int N, M;\n  cin >> N >> M;\n  for (int i = (1); i < (N + 1); ++i) cin >> C[i];\n  for (int i = 0; i < (M); ++i) {\n    cin >> E[i].first >> E[i].second;\n    adj[E[i].first].push_back({E[i].second, i});\n    adj[E[i].second].push_back({E[i].first, i});\n  }\n  bool has_odd_cycle = find_odd_cycle(1, 1).first;\n  int r = has_odd_cycle ? odd_cycle[0].first : 1;\n  long long required = assign_values(r);\n  if (required && !has_odd_cycle) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  if (required) {\n    for (int i = 0; i < (odd_cycle.size()); ++i) {\n      out[odd_cycle[i].second] -= (i % 2 == 0 ? -1 : 1) * required / 2;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < (M); ++i) cout << out[i] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nvector<pair<int, int> > g[maxn];\nlong long a[2], c[maxn], val[maxn];\nbool visited[maxn], h[maxn];\npair<int, int> Edge[maxn];\nvoid dfs(int v) {\n  a[h[v]] += c[v];\n  visited[v] = 1;\n  for (auto edge : g[v]) {\n    int u = edge.first;\n    if (!visited[u]) {\n      h[u] = h[v] ^ 1;\n      dfs(u);\n    }\n  }\n}\nvoid DFS(int v, int par = -1, int paridx = -1) {\n  visited[v] = 1;\n  for (auto edge : g[v]) {\n    int u = edge.first, idx = edge.second;\n    if (!visited[u]) DFS(u, v, idx);\n  }\n  if (paridx != -1) {\n    val[paridx] = c[v];\n    c[par] -= c[v];\n    c[v] -= 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  for (int v = 1; v <= n; v++) cin >> c[v];\n  for (int i = 1; i <= m; i++) {\n    int v, u;\n    cin >> v >> u;\n    g[v].push_back({u, i});\n    g[u].push_back({v, i});\n    Edge[i] = {v, u};\n  }\n  dfs(1);\n  for (int i = 1; i <= m; i++) {\n    int v = Edge[i].first, u = Edge[i].second;\n    if (h[v] != h[u]) continue;\n    long long diff = (a[h[v]] - a[(h[v] ^ 1)]) / 2;\n    c[v] -= diff;\n    c[u] -= diff;\n    a[h[v]] -= 2 * diff;\n    val[i] = diff;\n  }\n  if (a[0] != a[1]) return cout << \"NO\\n\", 0;\n  memset(visited, 0, sizeof visited);\n  DFS(1);\n  cout << \"YES\\n\";\n  for (int i = 1; i <= m; i++) cout << val[i] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nconst int LG = 20;\nint n, m;\nlong long a[maxn];\nint visited[maxn];\nlong long weight[maxn];\nvector<pair<int, int>> g[maxn];\nvector<int> odd, even;\nlong long sumodd, sumeven;\nint depth[maxn];\nint parEdge[maxn];\nint jump[maxn][LG];\nvector<int> oddcycle;\npair<int, int> edges[maxn];\nvoid dfs_prepare(int v, int color) {\n  if (!v) {\n    fill(visited, visited + maxn, -1);\n  }\n  visited[v] = color;\n  if (color) {\n    sumodd += a[v];\n    odd.emplace_back(v);\n  } else {\n    sumeven += a[v];\n    even.emplace_back(v);\n  }\n  for (auto &e : g[v]) {\n    if (visited[e.first] != -1) {\n      if (visited[e.first] != visited[v] || oddcycle.size() > 0) continue;\n      oddcycle.emplace_back(color);\n      oddcycle.emplace_back(e.second);\n      for (int x = v; x != e.first; x = jump[x][0]) {\n        oddcycle.emplace_back(parEdge[x]);\n      }\n      continue;\n    }\n    int s = e.first;\n    parEdge[s] = e.second;\n    jump[s][0] = v;\n    depth[s] = depth[v] + 1;\n    for (int j = 1; j < LG; ++j) jump[s][j] = jump[jump[s][j - 1]][j - 1];\n    dfs_prepare(s, 1 - color);\n  }\n}\nint LCA(int u, int v) {\n  if (depth[u] < depth[v]) swap(u, v);\n  for (int j = LG - 1; j >= 0; --j) {\n    if (depth[jump[u][j]] >= depth[v]) u = jump[u][j];\n  }\n  if (u == v) return v;\n  for (int j = LG - 1; j >= 0; --j) {\n    if (jump[u][j] != jump[v][j]) {\n      u = jump[u][j];\n      v = jump[v][j];\n    }\n  }\n  return jump[v][0];\n}\nlong long fs[maxn];\nint same(int x, int y) { return x / abs(x) == y / abs(y); }\nvoid upd(int x, int w, int sign = 1) {\n  if (a[x] < 0) {\n    a[x] += w;\n    fs[x] += sign * w;\n  } else {\n    a[x] -= w;\n    fs[x] -= sign * w;\n  }\n}\nvoid normalize(vector<int> ids) {\n  vector<int> stac;\n  for (int x : ids) {\n    if (a[x] == 0) continue;\n    if (stac.empty() || same(a[x], a[stac.back()])) {\n      stac.push_back(x);\n    } else {\n      while (abs(a[x]) > 0) {\n        if (stac.empty()) break;\n        int y = stac.back();\n        int w = min(abs(a[x]), abs(a[y]));\n        upd(x, w);\n        upd(y, w);\n        if (a[y] == 0) stac.pop_back();\n      }\n      if (abs(a[x]) > 0) stac.push_back(x);\n    }\n  }\n}\nvoid dfs_solve(int v) {\n  if (!v) {\n    fill(visited, visited + maxn, -1);\n  }\n  visited[v] = 1;\n  for (auto &e : g[v]) {\n    int s = e.first, w = e.second;\n    if (visited[s] != -1) continue;\n    dfs_solve(s);\n    weight[w] += fs[s];\n    fs[v] -= fs[s];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[--u].emplace_back(--v, i);\n    g[v].emplace_back(u, i);\n    weight[i]++;\n    a[v]++;\n    a[u]++;\n    edges[i] = make_pair(u, v);\n  }\n  dfs_prepare(0, 0);\n  if (sumodd != sumeven) {\n    if (oddcycle.empty()) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    long long need = sumodd - sumeven;\n    need /= 2;\n    int sign = 1;\n    if (oddcycle.front() == 0) sign *= -1;\n    for (int i = 1; i < oddcycle.size(); ++i) {\n      auto [u, v] = edges[oddcycle[i]];\n      a[v] -= sign * need;\n      a[u] -= sign * need;\n      weight[oddcycle[i]] -= sign * need;\n      sign *= -1;\n    }\n  }\n  normalize(even);\n  normalize(odd);\n  for (int i = 0, j = 0;;) {\n    if (i == even.size() || j == odd.size()) break;\n    if (a[even[i]] == 0) {\n      ++i;\n      continue;\n    }\n    if (a[odd[j]] == 0) {\n      ++j;\n      continue;\n    }\n    int x = even[i], y = odd[j];\n    int w = min(abs(a[x]), abs(a[y]));\n    upd(x, w);\n    upd(y, w);\n  }\n  dfs_solve(0);\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; ++i) cout << -weight[i] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int P = 1e9 + 7, INF = 0x3f3f3f3f;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long qpow(long long a, long long n) {\n  long long r = 1 % P;\n  for (a %= P; n; a = a * a % P, n >>= 1)\n    if (n & 1) r = r * a % P;\n  return r;\n}\nlong long inv(long long first) {\n  return first <= 1 ? 1 : inv(P % first) * (P - P / first) % P;\n}\ninline int rd() {\n  int first = 0;\n  char p = getchar();\n  while (p < '0' || p > '9') p = getchar();\n  while (p >= '0' && p <= '9') first = first * 10 + p - '0', p = getchar();\n  return first;\n}\nconst int N = 1e6 + 50;\nint n, m, dep[N];\npair<int, int> fa[N];\nlong long ans[N], c[N];\nvector<pair<int, int> > g[N], v;\nvoid get(int first, int second, int id) {\n  if (dep[first] < dep[second] || dep[first] - dep[second] & 1 || v.size())\n    return;\n  v.push_back({second, id});\n  while (first != second)\n    v.push_back({first, fa[first].second}), first = fa[first].first;\n}\nvoid dfs(int first, int d) {\n  dep[first] = d;\n  for (auto e : g[first])\n    if (e.first != fa[first].first) {\n      int second = e.first;\n      if (!dep[second])\n        fa[second] = {first, e.second}, dfs(second, d + 1),\n        c[first] -= ans[e.second];\n      else\n        get(first, second, e.second);\n    }\n  ans[fa[first].second] = c[first];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", c + i);\n  for (int i = 1; i <= m; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a].push_back({b, i});\n    g[b].push_back({a, i});\n  }\n  dfs(1, 1);\n  if (ans[0] & 1 || ans[0] && v.empty()) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  if (ans[0]) {\n    long long w = ans[0] / 2;\n    int first = fa[v.back().first].first;\n    if (dep[first] % 2 != dep[1] % 2) w = -w;\n    for (auto &e : v) ans[e.second] += w, w = -w;\n    while (first != 1)\n      ans[fa[first].second] += 2 * w, w = -w, first = fa[first].first;\n  }\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", ans[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot = 1;\nvoid adde(int b, int e) {\n  nxt[++tot] = head[b];\n  to[head[b] = tot] = e;\n  nxt[++tot] = head[e];\n  to[head[e] = tot] = b;\n}\nint n, m;\nlong long val[MAXN], ansl[MAXN];\nint dep[MAXN], fa[MAXN], fae[MAXN];\nint ex, ey, eid;\nvoid dfs(int u) {\n  for (int i = head[u]; i; i = nxt[i])\n    if (dep[to[i]] == -1) {\n      dep[to[i]] = dep[u] ^ 1;\n      fa[to[i]] = u, fae[to[i]] = i >> 1;\n      dfs(to[i]);\n      ansl[i >> 1] = val[to[i]];\n      val[u] -= val[to[i]];\n    } else if (!eid) {\n      if (dep[u] == dep[to[i]]) {\n        ex = u, ey = to[i], eid = i >> 1;\n      }\n    }\n}\nvoid add(int u, int d, int v) {\n  while (d != u) {\n    ansl[fae[d]] += v;\n    v = -v;\n    d = fa[d];\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false), std::cin.tie(0);\n  std::cin >> n >> m;\n  for (int i = 1; i <= n; ++i) std::cin >> val[i];\n  for (int i = 1, b, e; i <= m; ++i) std::cin >> b >> e, adde(b, e);\n  memset(dep, -1, sizeof dep);\n  dep[1] = 0;\n  dfs(1);\n  if ((val[1] & 1) || (!ex && val[1])) {\n    std::cout << \"NO\" << std::endl;\n    return 0;\n  }\n  std::cout << \"YES\" << std::endl;\n  if (eid) {\n    int up = dep[ey] ? 1 : -1, vx = val[1] / 2;\n    add(1, ey, up * vx * 2);\n    add(ey, ex, up * vx);\n    ansl[eid] = -up * vx;\n  }\n  for (int i = 1; i <= m; ++i) std::cout << ansl[i] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, m;\nvector<int> g[maxn];\nbool marked[maxn];\nint h[maxn];\nlong long int c[maxn];\nlong long int ans[maxn];\nmap<pair<int, int>, int> edge;\nint part1 = 0, part2 = 0;\nint cycleIndex = -1;\nint cycleIndex1 = -1;\nint par[maxn];\nlong long int dfs(int v, int p) {\n  marked[v] = true;\n  if (h[v] % 2 == 0)\n    part1 += c[v];\n  else\n    part2 += c[v];\n  par[v] = p;\n  long long int temp = 0;\n  for (int u : g[v]) {\n    if (!marked[u]) {\n      h[u] = h[v] + 1;\n      temp += dfs(u, v);\n    } else if (u != p) {\n      if ((h[v] - h[u]) % 2 == 0 && cycleIndex == -1) {\n        cycleIndex = v;\n        cycleIndex1 = u;\n      }\n    }\n  }\n  if (p != -1) ans[edge[make_pair(v, p)]] = c[v] - temp;\n  return c[v] - temp;\n}\nlong long int dfs2(int v, int p) {\n  marked[v] = true;\n  long long int temp = 0;\n  for (int u : g[v]) {\n    if (!marked[u]) {\n      temp += dfs2(u, v);\n    }\n  }\n  if (p != -1) ans[edge[make_pair(v, p)]] = c[v] - temp;\n  return c[v] - temp;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  for (int i = 0; i < m; i++) {\n    int v, u;\n    cin >> v >> u;\n    v--;\n    u--;\n    edge[make_pair(v, u)] = i;\n    edge[make_pair(u, v)] = i;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  dfs(0, -1);\n  if (cycleIndex == -1) {\n    if (part1 == part2) {\n      cout << \"YES\" << endl;\n      for (int i = 0; i < m; i++) cout << ans[i] << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  } else {\n    memset(ans, 0, sizeof ans);\n    memset(marked, false, sizeof marked);\n    int x = dfs2(cycleIndex, -1);\n    x /= 2;\n    ans[edge[make_pair(cycleIndex, cycleIndex1)]] += x;\n    while (cycleIndex != cycleIndex1) {\n      ans[edge[make_pair(cycleIndex, par[cycleIndex])]] += x;\n      cycleIndex = par[cycleIndex];\n      x = -x;\n    }\n    cout << \"YES\" << endl;\n    for (int i = 0; i < m; i++) cout << ans[i] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nlong long Ans[100000 + 5], c[100000 + 5];\nint n, m, head[100000 + 5], cnt = 1, vis[100000 + 5], C[100000 + 5], num = 0;\nint Fa[100000 + 5], q[100000 + 5], top = 0, col[100000 + 5], inq[100000 + 5],\n                                   from;\nstruct edge {\n  int to, next;\n} e[100000 * 2 + 5];\ninline void ins(int f, int t) {\n  e[++cnt] = (edge){t, head[f]};\n  head[f] = cnt;\n  e[++cnt] = (edge){f, head[t]};\n  head[t] = cnt;\n}\nvoid dfs(int x, int fa) {\n  vis[x] = 1;\n  for (int i = head[x]; i; i = e[i].next)\n    if (!vis[e[i].to])\n      dfs(e[i].to, x), Ans[i >> 1] = c[e[i].to], c[x] -= c[e[i].to],\n                                c[e[i].to] = 0;\n}\nvoid Find(int x, int fa) {\n  vis[x] = 1;\n  q[++top] = x;\n  inq[x] = top;\n  Fa[x] = fa;\n  for (int i = head[x]; i && !num; i = e[i].next)\n    if (e[i].to != fa) {\n      if (vis[e[i].to]) {\n        if (col[x] ^ col[e[i].to]) continue;\n        int t;\n        from = x;\n        for (t = e[i].to; !inq[t]; t = Fa[t]) C[++num] = t;\n        for (int j = inq[t]; j <= top; ++j) C[++num] = q[j];\n      } else\n        col[e[i].to] = col[x] ^ 1, Find(e[i].to, x);\n    }\n  --top;\n  inq[x] = 0;\n}\nint E(int x, int y) {\n  for (int i = head[x]; i; i = e[i].next)\n    if (e[i].to == y) return i >> 1;\n}\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; ++i) c[i] = read();\n  for (int i = 1; i <= m; ++i) ins(read(), read());\n  Find(1, 0);\n  memset(vis, 0, sizeof(vis));\n  int rt = from ? from : 1;\n  dfs(rt, 0);\n  if (c[rt] && !from) return 0 * puts(\"NO\");\n  if (c[rt]) {\n    long long s = c[rt] >> 1;\n    for (int i = 1; i <= num; ++i)\n      Ans[E(C[i], C[i % num + 1])] += (i == num ? 1 : ((i & 1) ? -1 : 1)) * s;\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", Ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 999;\nstruct edge {\n  int to, nxt, from, ban;\n  long long dis;\n} e[maxn << 1];\nint n, c[maxn], head[maxn], tot = -1;\nvoid add(int x, int y) {\n  e[++tot].to = y;\n  e[tot].from = x;\n  e[tot].nxt = head[x];\n  head[x] = tot;\n}\nint vis[maxn], fl, m, dep[maxn], f[maxn];\nlong long delta;\nnamespace DSU {\nint fa[maxn];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n}  // namespace DSU\nusing namespace DSU;\nlong long dp(int x, int fa) {\n  int leaf = 1;\n  long long sum = 0;\n  dep[x] = dep[fa] + 1;\n  f[x] = fa;\n  for (int i = head[x]; ~i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (e[i].ban || y == fa) continue;\n    leaf = 0;\n    e[i].dis = dp(y, x);\n    sum += e[i].dis;\n  }\n  if (leaf) return c[x];\n  return c[x] - sum;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(head, -1, sizeof(head));\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &c[i]), fa[i] = i;\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y);\n    add(y, x);\n  }\n  for (int i = 0; i <= tot; i += 2) {\n    int x = find(e[i].from), y = find(e[i].to);\n    if (x == y)\n      e[i].ban = e[i ^ 1].ban = 1;\n    else\n      fa[x] = y;\n  }\n  delta = dp(1, 0);\n  if (delta & 1) {\n    cout << \"NO\";\n    return 0;\n  } else if (delta) {\n    int x, y, opt;\n    for (int i = 0; i <= tot; i += 2)\n      if (e[i].ban) {\n        x = e[i].to, y = e[i].from;\n        if ((dep[x] & 1) == (dep[y] & 1)) {\n          opt = (dep[x] - dep[1]) & 1 ? -1 : 1;\n          e[i].dis += opt * delta / 2;\n          fl = 1;\n          break;\n        }\n      }\n    if (!fl) {\n      cout << \"NO\";\n      return 0;\n    }\n    delta /= 2;\n    c[x] -= opt * delta;\n    c[y] -= opt * delta;\n    delta = dp(1, 0);\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i <= tot; i += 2) printf(\"%I64d\\n\", e[i].dis + e[i ^ 1].dis);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<array<int, 2>>> adj;\nvector<int64_t> cost;\nvector<int64_t> ans;\nvector<int> color;\nvector<int> dep;\nint edge_i, edge_u, edge_v;\nint64_t bal;\nvoid dfs_dep(int u, int p) {\n  if (dep[u] % 2 == 0) {\n    bal += cost[u];\n  } else {\n    bal -= cost[u];\n  }\n  color[u] = 1;\n  for (auto [c, i] : adj[u]) {\n    if (c != p) {\n      if (color[c] == 1 && dep[u] % 2 == dep[c] % 2) {\n        edge_i = i;\n        edge_u = u;\n        edge_v = c;\n      } else if (color[c] == 0) {\n        dep[c] = dep[u] + 1;\n        dfs_dep(c, u);\n      }\n    }\n  }\n  color[u] = 2;\n}\nvoid dfs_solve(int u) {\n  color[u] = 1;\n  for (auto [c, i] : adj[u]) {\n    if (color[c] == 2) {\n      dfs_solve(c);\n      ans[i] = cost[c];\n      cost[u] -= ans[i];\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  color.resize(n + 1);\n  cost.resize(n + 1);\n  dep.resize(n + 1);\n  adj.resize(n + 1);\n  ans.resize(m + 1);\n  for (int i = 1; i <= n; ++i) {\n    cin >> cost[i];\n  }\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back({v, i});\n    adj[v].push_back({u, i});\n  }\n  dfs_dep(1, 0);\n  if (bal != 0 && edge_i == 0) {\n    cout << \"NO\\n\";\n    exit(0);\n  }\n  cout << \"YES\\n\";\n  if (dep[edge_u] % 2 == 0) {\n    ans[edge_i] = bal / 2;\n  } else {\n    ans[edge_i] = -bal / 2;\n  }\n  cost[edge_u] -= ans[edge_i];\n  cost[edge_v] -= ans[edge_i];\n  dfs_solve(1);\n  for (int i = 1; i <= m; ++i) {\n    cout << ans[i] << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid dbg(T a) {}\ntemplate <typename T, typename... Arg>\nvoid dbg(T a, Arg... arg) {}\nconst int maxn = (1e6) + 7;\nconst int inf = (1e9) + 7;\nconst long long LLinf = (1e18) + 7;\nconst long double eps = 1e-9;\nconst long long mod = 1e9 + 7;\nset<pair<int, int> > wek[maxn];\nvector<int> cykl;\nlong long val[maxn];\nint wyjeb[maxn];\nstack<int> stos;\nvector<pair<int, int> > kraw;\nint stan[maxn];\nlong long wart[maxn];\nbool vis[maxn];\nvoid rob(int x, int f) {\n  vis[x] = 1;\n  int numer = -1;\n  for (auto s : wek[x]) {\n    if (s.first == f)\n      numer = s.second;\n    else if (vis[s.first] == 0)\n      rob(s.first, x);\n  }\n  if (numer != -1) {\n    wart[numer] += val[x];\n    val[f] -= val[x];\n    val[x] = 0;\n  }\n}\ninline void usu(int x) {\n  if (stos.size() && stos.top() == x) stos.pop();\n}\ninline void sciagaj(int x) {\n  if (cykl.size() > 1) {\n    cykl.pop_back();\n    return;\n  }\n  while (kraw[stos.top()].first != x && kraw[stos.top()].second != x) {\n    cykl.push_back(stos.top());\n    stos.pop();\n  }\n  cykl.push_back(stos.top());\n  stos.pop();\n}\nvoid dfs(int x, int f) {\n  for (auto s : wek[x]) {\n    if (s.first == f) continue;\n    if (stan[s.first] == 0) {\n      stan[s.first] = stan[x] ^ 1;\n      stos.push(s.second);\n      dfs(s.first, x);\n      usu(s.second);\n    } else if (stan[s.first] == stan[x]) {\n      cykl.push_back(s.second);\n      sciagaj(s.first);\n    } else {\n      wyjeb[s.second] = 1;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> val[i];\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    wek[a].insert({b, i});\n    wek[b].insert({a, i});\n    kraw.push_back({a, b});\n  }\n  for (int i = 1; i <= n; i++) {\n    val[i] -= (long long)wek[i].size();\n    assert((val[i] & 1) == 0);\n  }\n  stan[1] = 2;\n  dfs(1, 0);\n  for (auto s : cykl) dbg(kraw[s].first, kraw[s].second);\n  for (int i = 0; i < m; i++)\n    if (wyjeb[i] == 1) {\n      dbg(i);\n      wek[kraw[i].first].erase({kraw[i].second, i});\n      wek[kraw[i].second].erase({kraw[i].first, i});\n    }\n  if (cykl.size()) {\n    int a = kraw[cykl[0]].first;\n    if (a != kraw[cykl.back()].first && a != kraw[cykl.back()].second)\n      a = kraw[cykl[0]].second;\n    rob(a, 0);\n    assert((val[a] & 1) == 0);\n    long long ile = val[a] / 2LL;\n    long long f = 1;\n    for (auto s : cykl) {\n      wart[s] += f * ile;\n      f *= -1;\n    }\n  } else {\n    rob(1, 0);\n    if (val[1] != 0) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) cout << wart[i] + 1 << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round453;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class D {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tlong[] v = new long[n];\n\t\tfor(int i = 0;i < n;i++)v[i] = nl();\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tint[] color = new int[n];\n\t\tcolor[0] = 1;\n\t\tq.add(0);\n\t\tint[] vi = null;\n\t\tint[] prev = new int[n];\n\t\tprev[0] = -1;\n\t\touter:\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(color[e] == 0){\n\t\t\t\t\tcolor[e] = -color[cur];\n\t\t\t\t\tprev[e] = cur;\n\t\t\t\t\tq.add(e);\n\t\t\t\t}else if(color[e] == color[cur]){\n\t\t\t\t\tvi = new int[]{e, cur};\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSet<Long> immune = new HashSet<>();\n\t\tif(vi != null){\n\t\t\tfor(int x = vi[0];x != 0;x = prev[x]){\n\t\t\t\tlong u = prev[x], o = x;\n\t\t\t\tlong code = (long)Math.min(u, o)<<32|Math.max(u, o);\n\t\t\t\timmune.add(code);\n\t\t\t}\n\t\t\tfor(int x = vi[1];x != 0;x = prev[x]){\n\t\t\t\tlong u = prev[x], o = x;\n\t\t\t\tlong code = (long)Math.min(u, o)<<32|Math.max(u, o);\n\t\t\t\timmune.add(code);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] xfrom = new int[n-1];\n\t\tint[] xto = new int[n-1];\n\t\tDJSet ds = new DJSet(n);\n\t\tint p = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tlong code = (long)Math.min(from[i], to[i])<<32|Math.max(from[i], to[i]);\n\t\t\tif(immune.contains(code)){\n\t\t\t\tif(!ds.union(from[i], to[i])){\n\t\t\t\t\txfrom[p] = from[i];\n\t\t\t\t\txto[p] = to[i];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(vi != null && from[i] == vi[0] && to[i] == vi[1])continue;\n\t\t\tif(vi != null && to[i] == vi[0] && from[i] == vi[1])continue;\n\t\t\tif(!ds.union(from[i], to[i])){\n\t\t\t\txfrom[p] = from[i];\n\t\t\t\txto[p] = to[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tassert p == n-1;\n\t\tint[][] h = packU(n, xfrom, xto);\n\t\tint[][] pars = parents3(h, 0);\n\t\t\n\t\tlong[] pw = new long[n];\n\t\tint[] tc = new int[n];\n\t\tint[] ord = pars[1], par = pars[0];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tfor(int e : h[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tv[cur] -= pw[e];\n\t\t\t\ttc[cur] -= tc[e];\n\t\t\t}\n\t\t\tif(vi != null && vi[0] == cur){\n\t\t\t\ttc[cur]--;\n\t\t\t}\n\t\t\tif(vi != null && vi[1] == cur){\n\t\t\t\ttc[cur]--;\n\t\t\t}\n\t\t\tpw[cur] = v[cur];\n\t\t\tif(cur == 0 && v[cur] != 0 && tc[cur] == 0){\n\t\t\t\tout.println(\"NO\");\n\t\t\t\tassert vi == null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlong t = 0;\n\t\tif(tc[0] != 0){\n\t\t\t// pw[0]+t*tc[0] = 0\n\t\t\tt = -pw[0] / tc[0];\n\t\t}\n\t\tout.println(\"YES\");\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(vi != null && from[i] == vi[0] && to[i] == vi[1]){\n\t\t\t\tout.println(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(vi != null && to[i] == vi[0] && from[i] == vi[1]){\n\t\t\t\tout.println(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(par[from[i]] == to[i]){\n\t\t\t\tout.println(pw[from[i]] + tc[from[i]] * t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(par[to[i]] == from[i]){\n\t\t\t\tout.println(pw[to[i]] + tc[to[i]] * t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(0);\n\t\t}\n\t}\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint N, M;\nvector<int> E[MAXN];\nint a[MAXN], b[MAXN];\nlong long c[MAXN];\nint color[MAXN];\nvector<int> out;\nlong long sol[MAXN];\nvector<int> ch[MAXN];\nvoid load() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= N; i++) scanf(\"%lld\", c + i);\n  for (int i = 0; i < M; i++) scanf(\"%d%d\", a + i, b + i);\n}\nvoid dfs(int x, int p) {\n  color[x] = color[p] ^ 1;\n  for (auto it : E[x]) {\n    int nxt = a[it] + b[it] - x;\n    if (nxt == p) continue;\n    if (color[nxt] != -1) {\n      out.push_back(it);\n      continue;\n    }\n    ch[x].push_back(it);\n    dfs(nxt, x);\n  }\n}\nlong long calc(int x) {\n  long long res = 0;\n  for (auto it : ch[x]) {\n    int nxt = a[it] + b[it] - x;\n    sol[it] = c[nxt] - calc(nxt);\n    res += sol[it];\n  }\n  return res;\n}\nvoid solve() {\n  for (int i = 0; i < M; i++) {\n    E[a[i]].push_back(i);\n    E[b[i]].push_back(i);\n  }\n  memset(color, -1, sizeof color);\n  color[0] = 1;\n  dfs(1, 0);\n  long long diff = 0;\n  for (int i = 1; i <= N; i++) diff += color[i] ? c[i] : -c[i];\n  bool ok = false;\n  for (auto it : out)\n    if (color[a[it]] == color[b[it]]) {\n      sol[it] = color[a[it]] ? diff / 2 : -diff / 2;\n      c[a[it]] -= sol[it];\n      c[b[it]] -= sol[it];\n      ok = true;\n      break;\n    }\n  if (!ok && diff) {\n    puts(\"NO\");\n    return;\n  }\n  calc(1);\n  puts(\"YES\");\n  for (int i = 0; i < M; i++) printf(\"%lld\\n\", sol[i]);\n}\nint main() {\n  load();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100005;\nint n, m, head[N], id[N], c[N], tot = 1;\nlong long weight[N];\nstruct edge {\n  int to, nxt;\n} e[N << 1];\nint fa[N];\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nvoid link(int x, int y) {\n  e[++tot] = (edge){y, head[x]}, head[x] = tot;\n  e[++tot] = (edge){x, head[y]}, head[y] = tot;\n}\nint f[N], g[N], dep[N];\nvoid dfs(int x) {\n  weight[g[x]] = c[x];\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].to != f[x]) {\n      f[e[i].to] = x, g[e[i].to] = id[i >> 1];\n      dep[e[i].to] = dep[x] + 1, dfs(e[i].to);\n      weight[g[x]] -= weight[g[e[i].to]];\n    }\n}\nint u[N], v[N];\nint main() {\n  std::ios::sync_with_stdio(0), std::cin.tie(0);\n  std::cin >> n >> m;\n  for (int i = 1; i <= n; ++i) fa[i] = i, std::cin >> c[i];\n  for (int i = 1; i <= m; ++i) {\n    static int cnt = 0;\n    std::cin >> u[i] >> v[i];\n    if (find(u[i]) != find(v[i])) {\n      id[++cnt] = i, link(u[i], v[i]);\n      fa[find(u[i])] = find(v[i]);\n    }\n  }\n  dfs(1);\n  for (int i = 1; i <= m; ++i)\n    if (!(dep[u[i]] - dep[v[i]] & 1)) {\n      long long t = weight[0] / 2;\n      weight[0] = 0;\n      if (dep[u[i]] & 1) t = -t;\n      long long s = weight[i] = t;\n      for (int j = u[i]; j > 1; j = f[j]) weight[g[j]] += s = -s;\n      for (int j = v[i]; j > 1; j = f[j]) weight[g[j]] += t = -t;\n      break;\n    }\n  if (weight[0]) return std::cout << \"NO\\n\", 0;\n  std::cout << \"YES\\n\";\n  for (int i = 1; i <= m; ++i) std::cout << weight[i] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = acosl(-1);\nconst int maxn = 100010;\nconst long long mod = 1e9 + 7;\nconst long long inf = 1e18;\nconst long double eps = 1e-10;\nint n, m, u, v, vis[maxn], root, vise[maxn], depth[maxn];\nlong long w[maxn], c[maxn];\nvector<pair<int, int> > g[maxn];\npair<int, int> edge[maxn], fa[maxn];\nvoid dfs1(int cur, int p, int col) {\n  if (vis[cur]) {\n    if (vis[cur] != col) root = cur;\n    return;\n  }\n  vis[cur] = col;\n  for (pair<int, int> pa : g[cur]) {\n    if (pa.first != p) dfs1(pa.first, cur, -col);\n  }\n}\nvoid dfs2(int cur, int p, int id, int dep) {\n  if (vis[cur]) return;\n  vis[cur] = 1;\n  long long wt = 0;\n  for (pair<int, int> pa : g[cur]) {\n    if (pa.first != p)\n      dfs2(pa.first, cur, pa.second, dep + 1), wt += w[pa.second];\n  }\n  w[id] = c[cur] - wt;\n  vise[id] = 1;\n  fa[cur] = {id, p};\n  depth[cur] = dep;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i < n + 1; i++) scanf(\"%lld\", &c[i]);\n  for (int i = 1; i < m + 1; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back({v, i}), g[v].push_back({u, i});\n    edge[i] = {u, v};\n  }\n  root = 1;\n  dfs1(1, 0, 1);\n  memset(vis, 0, sizeof(vis));\n  dfs2(root, 0, 0, 0);\n  if (w[0]) {\n    for (int i = 1; i < m + 1; i++)\n      if (!vise[i]) {\n        u = edge[i].first, v = edge[i].second;\n        if ((depth[u] & 1) == (depth[v] & 1)) {\n          int sgn = 1;\n          if (depth[u] & 1) sgn = -1;\n          long long diff = w[0] / 2;\n          w[i] = diff * sgn;\n          while (u) sgn = -sgn, w[fa[u].first] += sgn * diff, u = fa[u].second;\n          sgn = 1;\n          if (depth[v] & 1) sgn = -1;\n          while (v) sgn = -sgn, w[fa[v].first] += sgn * diff, v = fa[v].second;\n          break;\n        }\n      }\n  }\n  if (w[0])\n    printf(\"NO\\n\");\n  else {\n    printf(\"YES\\n\");\n    for (int i = 1; i < m + 1; i++) printf(\"%lld\\n\", w[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<long long, long long>>> graf;\nvector<bool> was;\nvector<long long> w;\nvector<long long> res;\nmap<pair<long long, long long>, long long> e2i;\nvoid Add(long long a, long long b, long long c) {\n  w[a] += c;\n  w[b] += c;\n  res[e2i[{a, b}]] -= c;\n}\nvoid DFS(long long v) {\n  if (was[v]) return;\n  was[v] = true;\n  for (int i = 0; i < ((long long)(graf[v]).size()); i++) {\n    long long u = graf[v][i].first;\n    DFS(u);\n    Add(v, u, -w[u]);\n  }\n}\nint main() {\n  cin.sync_with_stdio(0);\n  long long n, m;\n  cin >> n >> m;\n  was = vector<bool>(n, false);\n  for (int i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    w.push_back(x);\n  }\n  graf = vector<vector<pair<long long, long long>>>(n);\n  for (long long i = 0; i < m; i++) {\n    long long a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    graf[a].push_back({b, i});\n    graf[b].push_back({a, i});\n    e2i[{a, b}] = i;\n    e2i[{b, a}] = i;\n  }\n  queue<long long> q;\n  q.push(0);\n  vector<long long> mark(n, -1);\n  mark[0] = 0;\n  vector<long long> par(n, -1);\n  deque<long long> cycle;\n  long long sumB = 0, sumW = 0;\n  while (((long long)(q).size()) > 0) {\n    long long v = q.front();\n    q.pop();\n    for (long long i = 0; i < ((long long)(graf[v]).size()); i++) {\n      long long u = graf[v][i].first;\n      if (u == par[v]) continue;\n      if (mark[u] != -1) {\n        if (((long long)(cycle).size()) % 2 == 1) continue;\n        long long a = v, b = u;\n        if (mark[a] != mark[b]) {\n          if (((long long)(cycle).size()) > 0) continue;\n          b = par[b];\n          cycle.clear();\n          cycle.push_back(b);\n        } else {\n          cycle.clear();\n        }\n        while (a != b) {\n          cycle.push_back(a);\n          cycle.push_front(b);\n          a = par[a];\n          b = par[b];\n        }\n        cycle.push_back(a);\n        break;\n      } else if (mark[u] == -1) {\n        mark[u] = (mark[v] + 1) % 2;\n        q.push(u);\n        par[u] = v;\n      }\n    }\n    if (mark[v] == 0) {\n      sumB += w[v];\n    } else {\n      sumW += w[v];\n    }\n  }\n  res = vector<long long>(m, 1);\n  for (long long i = 0; i < n; i++) w[i] -= ((long long)(graf[i]).size());\n  if (((long long)(cycle).size()) == 0) {\n    cycle.push_back(0);\n    cycle.push_back(graf[0][0].first);\n  }\n  if (((long long)(cycle).size()) % 2 == 0) {\n    if (sumB != sumW) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    DFS(cycle[0]);\n  } else {\n    DFS(cycle[0]);\n    if (w[cycle[0]] % 2 != 0) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    Add(cycle[0], cycle[1], -w[cycle[0]] / 2);\n    for (int i = 1; i < ((long long)(cycle).size()) - 1; i++) {\n      Add(cycle[i], cycle[i + 1], -w[cycle[i]]);\n    }\n    Add(cycle[0], cycle.back(), -w[cycle[0]]);\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < m; i++) {\n    cout << res[i] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class S, class T>\nostream& operator<<(ostream& o, const pair<S, T>& p) {\n  return o << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& o, const vector<T>& vc) {\n  o << \"sz = \" << vc.size() << endl << \"[\";\n  for (const T& v : vc) o << v << \",\";\n  o << \"]\";\n  return o;\n}\nusing ll = long long;\nint N, M;\nconst int MN = 100010;\nvector<int> G[MN];\nll a[MN];\nint d[MN];\nbool vis[MN];\nusing P = pair<int, int>;\nmap<P, int> p2id;\nbool spt[MN];\nll ans[MN];\nvoid dfsd(int v = 0) {\n  vis[v] = 1;\n  for (int u : G[v]) {\n    if (!vis[u]) {\n      d[u] = d[v] + 1;\n      spt[p2id[P(v, u)]] = 1;\n      dfsd(u);\n    }\n  }\n}\nvoid dfs(int v = 0, int p = -1) {\n  vis[v] = 1;\n  for (int u : G[v]) {\n    if (!vis[u]) {\n      dfs(u, v);\n      a[v] -= a[u];\n    }\n  }\n  if (p != -1) {\n    ans[p2id[P(v, p)]] = a[v];\n  } else {\n    assert(a[v] == 0);\n  }\n}\nvoid answer() {\n  puts(\"YES\");\n  for (int i = 0; i < (int)(M); i++) cout << ans[i] << endl;\n  exit(0);\n}\nll sm;\nint main() {\n  cin >> N >> M;\n  for (int i = 0; i < (int)(N); i++) cin >> a[i];\n  for (int i = 0; i < (int)(M); i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    G[x].push_back(y);\n    G[y].push_back(x);\n    p2id[P(x, y)] = i;\n    p2id[P(y, x)] = i;\n  }\n  dfsd();\n  for (int i = 0; i < (int)(N); i++) {\n    if (d[i] % 2 == 0)\n      sm += a[i];\n    else\n      sm -= a[i];\n  }\n  if (sm == 0) {\n    for (int i = 0; i < (int)(N); i++) vis[i] = 0;\n    dfs();\n    answer();\n  } else {\n    for (auto it : p2id) {\n      P p = it.first;\n      int i = it.second;\n      if (spt[i]) continue;\n      int x = p.first, y = p.second;\n      if ((d[x] - d[y]) % 2 != 0) continue;\n      if (d[x] % 2 == 1) sm = -sm;\n      assert(sm % 2 == 0);\n      ans[i] = sm / 2;\n      a[x] -= sm / 2;\n      a[y] -= sm / 2;\n      for (int i = 0; i < (int)(N); i++) vis[i] = 0;\n      dfs();\n      answer();\n    }\n  }\n  puts(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int M = N * 5;\nlong long C[M], x, y, g[N], k[N];\nint L[N], ne[M], T[M], ty = 1, Q[N], J[N], n, m;\nvoid add(int x, int y) {\n  ne[++ty] = L[x];\n  L[x] = ty;\n  T[ty] = y;\n}\nvoid link(int x, int y) {\n  add(x, y);\n  add(y, x);\n}\nbool v[N];\nint dfs(int x, int f) {\n  int res = 0;\n  Q[x] = f;\n  k[x] = k[f] + 1;\n  v[x] = 1;\n  for (int i = L[x]; i; i = ne[i]) {\n    int V = T[i];\n    if (v[V]) {\n      if (V != f) {\n        if ((k[V] + k[x]) & 1)\n          ;\n        else\n          res = i;\n      }\n      continue;\n    }\n    int h;\n    if (h = dfs(V, x)) res = h;\n    if (g[V]) {\n      g[x] -= g[V];\n      C[i] += g[V];\n      C[i ^ 1] += g[V];\n      g[V] = 0;\n    }\n    J[V] = i;\n  }\n  return res;\n}\nvoid B(int x) {\n  while (Q[x]) {\n    g[Q[x]] -= g[x];\n    C[J[x]] += g[x];\n    C[J[x] ^ 1] += g[x];\n    g[x] = 0;\n    x = Q[x];\n  }\n}\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &g[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d%d\", &x, &y), link(x, y);\n  for (int i = 1; i <= n; ++i)\n    if (!v[i]) {\n      int h = dfs(i, 0), a;\n      if ((g[i]) & 1 || (!h && g[i])) return puts(\"NO\") * 0;\n      a = (k[T[h]] & 1);\n      C[h] = C[h ^ 1] += g[i] / 2 * (a ? 1 : (-1));\n      g[T[h ^ 1]] = g[T[h]] = -g[i] / 2 * (a ? 1 : (-1));\n      B(T[h]);\n      B(T[h ^ 1]);\n    }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", C[i * 2]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, tot;\nint u[200005], v[200005], on_tree[200005], fa[200005], col[200005],\n    fath[200005], dep[200005];\nlong long c[200005], mk[200005];\nvector<int> G[200005];\nunordered_map<int, unordered_map<int, long long> > val;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    (x *= 10) += ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline void add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\nint findf(int x) { return x == fa[x] ? x : fa[x] = findf(fa[x]); }\nvoid kruskal() {\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= m; i++) {\n    if (tot == n - 1) return;\n    int uf = findf(u[i]), vf = findf(v[i]);\n    if (uf == vf) continue;\n    on_tree[i] = 1;\n    add_edge(u[i], v[i]);\n    tot++;\n    fa[uf] = vf;\n  }\n}\nvoid dfs1(int u, int c_fa, int c_col) {\n  col[u] = c_col;\n  fath[u] = c_fa;\n  dep[u] = dep[c_fa] + 1;\n  for (int v : G[u]) {\n    if (v == c_fa) continue;\n    dfs1(v, u, c_col ^ 1);\n    c[u] -= val[u][v];\n  }\n  val[u][c_fa] = val[c_fa][u] = c[u];\n}\nvoid work(int _x, int _y) {\n  int x = _x, y = _y;\n  int dis = 0, delta = 0, flag = -1;\n  if (dep[x] < dep[y]) swap(x, y);\n  while (dep[x] > dep[1]) dis++, x = fath[x];\n  if (dis & 1)\n    delta = -c[1] / 2;\n  else\n    delta = c[1] / 2;\n  x = _x, y = _y;\n  if (dep[x] < dep[y]) swap(x, y);\n  while (dep[x] > dep[y]) {\n    val[x][fath[x]] += flag * delta, val[fath[x]][x] += flag * delta;\n    flag = -flag, x = fath[x];\n  }\n  while (dep[x] > dep[1]) {\n    val[x][fath[x]] += flag * delta, val[fath[x]][x] += flag * delta;\n    val[y][fath[y]] += flag * delta, val[fath[y]][y] += flag * delta;\n    flag = -flag, x = fath[x], y = fath[y];\n  }\n  val[_x][_y] = val[_y][_x] = delta;\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) c[i] = read();\n  for (int i = 1; i <= m; i++) u[i] = read(), v[i] = read();\n  kruskal();\n  dfs1(1, 0, 1);\n  if (c[1] == 0) {\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", val[u[i]][v[i]]);\n    return 0;\n  }\n  if (c[1] & 1) {\n    puts(\"NO\");\n    return 0;\n  }\n  for (int i = 1; i <= m; i++) {\n    if (col[u[i]] != col[v[i]] || on_tree[i]) continue;\n    puts(\"YES\");\n    work(u[i], v[i]);\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", val[u[i]][v[i]]);\n    return 0;\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct edge {\n  int to, nxt;\n  long long w;\n} e[N << 1];\nint head[N], tot = 1;\nint n, m, vis[N];\nlong long s[3], a[N], d[N];\nvoid adde(int u, int v) {\n  e[++tot] = edge{v, head[u]};\n  head[u] = tot;\n  return;\n}\nvoid Dfs(int u, int fa) {\n  vis[u] = 3 - vis[fa];\n  s[vis[u]] += a[u];\n  for (int i = head[u]; i; i = e[i].nxt) {\n    int v = e[i].to;\n    if (v == fa || vis[v]) continue;\n    Dfs(v, u);\n  }\n  return;\n}\nvoid dfs(int u, int fa) {\n  vis[u] = 1;\n  for (int i = head[u]; i; i = e[i].nxt) {\n    int v = e[i].to;\n    if (v == fa || vis[v]) continue;\n    dfs(v, u);\n    e[i].w = a[v], e[i ^ 1].w = a[v];\n    a[u] -= a[v], a[v] = 0;\n  }\n  return;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  int u, v;\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    adde(u, v), adde(v, u);\n  }\n  vis[0] = 1;\n  Dfs(1, 0);\n  int id = -1;\n  for (int u = 1; u <= n; u++) {\n    for (int i = head[u]; i; i = e[i].nxt) {\n      int v = e[i].to;\n      if (vis[u] == vis[v]) {\n        id = i;\n        break;\n      }\n    }\n    if (id != -1) break;\n  }\n  if (s[1] != s[2]) {\n    if (id == -1) return printf(\"NO\\n\"), 0;\n    u = e[id].to, v = e[id ^ 1].to;\n    long long d = s[3 - vis[u]] - s[vis[u]];\n    if (d % 2 != 0) return printf(\"NO\\n\"), 0;\n    a[u] += d / 2, a[v] += d / 2;\n    e[id].w = -d / 2, e[id ^ 1].w = -d / 2;\n  }\n  printf(\"YES\\n\");\n  memset(vis, 0, sizeof(vis));\n  dfs(1, 0);\n  for (int i = 2; i <= tot; i += 2) printf(\"%lld\\n\", e[i].w);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\ntemplate <typename T>\nvoid chmin(T &a, const T &b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid chmax(T &a, const T &b) {\n  a = max(a, b);\n}\nstruct FastIO {\n  FastIO() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n} fastiofastio;\nconst ll INF = 1LL << 60;\nint main(void) {\n  ll n, m;\n  cin >> n >> m;\n  vector<ll> c(n);\n  for (ll i = (ll)0; i < (ll)n; ++i) cin >> c[i];\n  vector<vector<PII>> g(n);\n  for (ll i = (ll)0; i < (ll)m; ++i) {\n    ll a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[a].emplace_back(b, i);\n    g[b].emplace_back(a, i);\n  }\n  ll x = -1, y = -1, z = -1;\n  vector<ll> ans(m), depth(n, -1);\n  function<ll(ll, ll)> dfs = [&](ll v, ll p) {\n    ll ret = 0;\n    for (auto to : g[v]) {\n      if (to.first == p) continue;\n      if (depth[to.first] == -1) {\n        depth[to.first] = depth[v] + 1;\n        ans[to.second] = c[to.first] - dfs(to.first, v);\n        ret += ans[to.second];\n      } else if (depth[v] > depth[to.first]) {\n        if ((depth[v] - depth[to.first]) % 2 == 0 && x == -1) {\n          x = v, y = to.first, z = to.second;\n        }\n      }\n    }\n    return ret;\n  };\n  depth[0] = 0;\n  ll ret = dfs(0, -1);\n  if (ret != c[0]) {\n    if (x == -1 || (ret - c[0]) % 2) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    ll diff;\n    if (depth[y] % 2)\n      diff = (ret - c[0]) / 2;\n    else\n      diff = -(ret - c[0]) / 2;\n    ;\n    ll start_v, end_v;\n    vector<ll> path;\n    vector<bool> used(n);\n    function<bool(ll, ll)> getpath = [&](ll v, ll p) {\n      ;\n      used[v] = true;\n      if (v == end_v) return true;\n      bool ret = false;\n      for (auto to : g[v]) {\n        if (to.first == p) continue;\n        if (used[to.first]) continue;\n        bool tmp = getpath(to.first, v);\n        ret |= tmp;\n        if (tmp) path.push_back(to.second);\n      }\n      if (v == start_v) ret = false;\n      return ret;\n    };\n    ans[z] += diff;\n    start_v = y, end_v = x;\n    getpath(0, -1);\n    for (ll i = (ll)0; i < (ll)path.size(); ++i) {\n      if (i % 2 == 0)\n        ans[path[i]] -= diff;\n      else\n        ans[path[i]] += diff;\n    }\n    start_v = 0, end_v = y;\n    path.clear();\n    used.assign(n, false);\n    getpath(0, -1);\n    for (ll i = (ll)0; i < (ll)path.size(); ++i) {\n      if (i % 2 == 0)\n        ans[path[i]] -= 2 * diff;\n      else\n        ans[path[i]] += 2 * diff;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (auto i : ans) cout << i << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nconst int nax = 1e5 + 5;\nint h[nax];\nlong long should[nax], answer[nax];\nbool vis[nax];\nvector<pair<int, int>> w[nax];\nlong long EVEN = 0, ODD = 0;\npair<pair<int, int>, int> spec;\nvector<pair<int, int>> children[nax];\nvoid dfs_one(int a) {\n  if (h[a] % 2)\n    ODD += should[a];\n  else\n    EVEN += should[a];\n  assert(!vis[a]);\n  vis[a] = true;\n  for (pair<int, int> edge : w[a]) {\n    int b = edge.first;\n    if (!vis[b]) {\n      children[a].push_back(edge);\n      h[b] = h[a] + 1;\n      dfs_one(b);\n    } else if ((h[a] - h[b]) % 2 == 0) {\n      spec = make_pair(make_pair(a, b), edge.second);\n    }\n  }\n}\nvoid dfs_two(int a) {\n  for (pair<int, int> edge : children[a]) {\n    int b = edge.first;\n    dfs_two(b);\n    answer[edge.second] = should[b];\n    should[a] -= should[b];\n    should[b] = 0;\n  }\n}\nvoid NO() {\n  puts(\"NO\");\n  exit(0);\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &should[i]);\n  for (int i = 1; i <= m; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    w[a].push_back({b, i});\n    w[b].push_back({a, i});\n  }\n  dfs_one(1);\n  long long need = EVEN - ODD;\n  if (need) {\n    if (need % 2 != 0) NO();\n    need /= 2;\n    debug() << \" [\"\n            << \"need\"\n               \": \"\n            << (need)\n            << \"] \"\n               \" [\"\n            << \"spec\"\n               \": \"\n            << (spec) << \"] \";\n    int id = spec.second;\n    if (id == 0) NO();\n    if (h[spec.first.first] % 2 == 1) need *= -1;\n    answer[id] = need;\n    should[spec.first.first] -= need;\n    should[spec.first.second] -= need;\n  }\n  dfs_two(1);\n  assert(should[1] == 0);\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", answer[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nlong long n, m, c[MAXN], d[MAXN];\npair<long long, long long> edges[MAXN];\nvector<long long> g[MAXN], t[MAXN];\nbool vis[MAXN];\nmap<pair<long long, long long>, long long> ma;\nmap<pair<long long, long long>, bool> tree;\nvoid dfs(int v) {\n  vis[v] = 1;\n  for (int u : g[v]) {\n    if (vis[u]) continue;\n    d[u] = 1 - d[v];\n    t[u].push_back(v);\n    t[v].push_back(u);\n    tree[pair<long long, long long>(u, v)] =\n        tree[pair<long long, long long>(v, u)] = 1;\n    dfs(u);\n  }\n}\nvoid dfs2(int v, int f = -1) {\n  for (int u : t[v]) {\n    if (u == f) continue;\n    dfs2(u, v);\n  }\n  if (f != -1) {\n    ma[pair<long long, long long>(min(v, f), max(v, f))] = c[v];\n    c[f] -= c[v];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) cin >> c[i];\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    if (a > b) swap(a, b);\n    g[a].push_back(b);\n    g[b].push_back(a);\n    edges[i] = pair<long long, long long>(a, b);\n  }\n  dfs(0);\n  bool y = 0;\n  for (int i = 0; i < m; ++i) {\n    if (tree[edges[i]]) continue;\n    if (d[edges[i].first] != d[edges[i].second] || y == 1) {\n      ma[edges[i]] = 0;\n      continue;\n    }\n    long long sum = 0;\n    for (int j = 0; j < n; ++j) sum += (2 * d[j] - 1) * c[j];\n    if (d[edges[i].first] == 0) {\n      ma[edges[i]] = -sum / 2;\n      c[edges[i].first] += sum / 2;\n      c[edges[i].second] += sum / 2;\n    } else {\n      ma[edges[i]] = sum / 2;\n      c[edges[i].first] -= sum / 2;\n      c[edges[i].second] -= sum / 2;\n    }\n    y = 1;\n  }\n  long long sum = 0;\n  for (int i = 0; i < n; ++i) {\n    sum += (2 * d[i] - 1) * c[i];\n  }\n  if (sum != 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  cout << \"YES\\n\";\n  dfs2(0);\n  for (int i = 0; i < m; ++i) cout << ma[edges[i]] << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint CH, NEG;\ntemplate <typename TP>\ninline void read(TP& ret) {\n  ret = NEG = 0;\n  while (CH = getchar(), CH < '!')\n    ;\n  if (CH == '-') NEG = true, CH = getchar();\n  while (ret = ret * 10 + CH - '0', CH = getchar(), CH > '!')\n    ;\n  if (NEG) ret = -ret;\n}\nint star[100010LL], e[3][100010LL << 1], te = 1;\ninline void AddEdge(int u, int v, int w) {\n  te++;\n  e[0][te] = v;\n  e[1][te] = star[u];\n  star[u] = te;\n  e[2][te] = w;\n  te++;\n  e[0][te] = u;\n  e[1][te] = star[v];\n  star[v] = te;\n  e[2][te] = w;\n}\nint n, m;\nlong long c[100010LL], cc[100010LL], ans[100010LL];\nint pre[100010LL];\nbool col[100010LL], vis[100010LL];\nbool odd = false;\nint eu, ev, ei;\nvoid dfs(int u = 1) {\n  vis[u] = true;\n  for (int p = star[u], v; p; p = e[1][p])\n    if (v = e[0][p], !vis[v]) {\n      pre[v] = p;\n      col[v] = col[u] ^ 1;\n      dfs(v);\n      cc[u] -= (ans[e[2][p]] = cc[v]);\n    } else if (col[u] == col[v])\n      odd = true, eu = u, ev = v, ei = e[2][p];\n}\nvoid dfs2(int u) {\n  vis[u] = false;\n  for (int p = star[u], v; p; p = e[1][p])\n    if (v = e[0][p], vis[v] && (col[v] ^ col[u]) && e[2][p] != ei) {\n      pre[v] = p;\n      dfs2(v);\n      c[u] -= (ans[e[2][p]] = c[v]);\n    }\n}\nint main() {\n  int i, a, b;\n  long long delta, sig;\n  read(n), read(m);\n  for (i = (1); i <= (n); i++) read(c[i]), cc[i] = c[i];\n  for (i = (1); i <= (m); i++) read(a), read(b), AddEdge(a, b, i);\n  dfs();\n  if (cc[1] == 0) {\n    puts(\"YES\");\n    for (i = (1); i <= (m); i++) printf(\"%lld\\n\", ans[i]);\n    goto END;\n  }\n  if (!odd) {\n    puts(\"NO\");\n    goto END;\n  }\n  memset(ans, 0, sizeof ans);\n  dfs2(eu);\n  delta = c[eu] / 2LL;\n  sig = -1LL;\n  while (ev != eu) {\n    ans[e[2][pre[ev]]] += sig * delta;\n    ev = e[0][pre[ev] ^ 1];\n    sig *= -1LL;\n  }\n  ans[ei] += delta;\n  puts(\"YES\");\n  for (i = (1); i <= (m); i++) printf(\"%lld\\n\", ans[i]);\nEND:\n  getchar(), getchar();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  int to, next, id;\n} e[100005 * 2];\nint n, m, tot, idx, idy, ide;\nint head[100005], c[100005], vis[100005];\nlong long a[100005], b[100005];\nvoid add(int x, int y, int id) {\n  e[++tot] = (edge){y, head[x], id};\n  head[x] = tot;\n}\nbool pdfs(int x) {\n  for (int i = head[x]; i; i = e[i].next)\n    if (!c[e[i].to]) {\n      c[e[i].to] = 3 - c[x];\n      if (!pdfs(e[i].to)) return 0;\n    } else if (c[e[i].to] == c[x]) {\n      idx = x;\n      idy = e[i].to;\n      ide = i;\n      return 0;\n    }\n  return 1;\n}\nlong long dfs(int x) {\n  vis[x] = 1;\n  long long s = a[x];\n  for (int i = head[x]; i; i = e[i].next)\n    if (!vis[e[i].to]) {\n      long long tmp = dfs(e[i].to);\n      b[e[i].id] += tmp;\n      s -= tmp;\n    }\n  return s;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y, i);\n    add(y, x, i);\n  }\n  c[1] = 1;\n  bool f = pdfs(1);\n  if (f) {\n    long long s = 0;\n    for (int i = 1; i <= n; i++)\n      if (c[i] == 1)\n        s += a[i];\n      else\n        s -= a[i];\n    if (s) return puts(\"NO\"), 0;\n    s = dfs(1);\n    if (s) return puts(\"NO\"), 0;\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", b[i]);\n    return 0;\n  }\n  long long s = dfs(1);\n  if (s & 1) return puts(\"NO\"), 0;\n  s /= 2;\n  if (c[idx] == 2) s = -s;\n  memset(b, 0, sizeof(b));\n  b[e[ide].id] = s;\n  a[idx] -= s;\n  a[idy] -= s;\n  memset(vis, 0, sizeof(vis));\n  s = dfs(1);\n  if (s) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", b[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long c[110000];\nlong long ans[110000];\nvector<long long> edge[110000];\nvector<long long> edges;\nint u, v;\nbool come[110000];\nlong long dep[110000];\nlong long parent[110000];\nlong long odd = -1;\nlong long odd_a, odd_b;\nvoid dfs(int x) {\n  come[x] = true;\n  for (auto e : edge[x]) {\n    int to = edges[e] - x;\n    if (come[to]) {\n      if ((dep[x] - dep[to]) % 2 == 0) {\n        odd = e;\n        odd_a = x;\n        odd_b = to;\n      }\n      continue;\n    }\n    dep[to] = dep[x] + 1;\n    parent[to] = x;\n    dfs(to);\n    ans[e] += c[to];\n    c[x] -= c[to];\n    c[to] = 0;\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) cin >> c[i];\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    edges.push_back(u + v);\n    edge[u].push_back(i);\n    edge[v].push_back(i);\n  }\n  dfs(0);\n  if (odd == -1 && c[0] != 0) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  if (odd == -1) {\n    cout << \"YES\" << endl;\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n  }\n  long long ex = c[0] / 2;\n  if (dep[odd_a] % 2 == 1) ex = -ex;\n  ans[odd] += ex;\n  c[odd_a] -= ex;\n  c[odd_b] -= ex;\n  fill(come, come + n, false);\n  dfs(0);\n  cout << \"YES\" << endl;\n  for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long sum[2];\nint n, m;\nint x, y, color[100100], root;\nlong long c[100100], a[100100];\nlong long ans[100100];\npair<int, int> to;\nvector<pair<int, int> > g[100100], p[100100];\nvoid Draw(int x) {\n  for (int i = 0; i < g[x].size(); i++) {\n    int v = g[x][i].first;\n    if (color[v] != -1) {\n      if (color[v] == color[x]) root = x, to = g[x][i];\n      continue;\n    }\n    color[v] = !color[x];\n    p[x].push_back(g[x][i]);\n    p[v].push_back(make_pair(x, g[x][i].second));\n    sum[color[v]] += a[v];\n    Draw(v);\n  }\n}\nvoid Print(int x, int from, int fa) {\n  c[x] = a[x];\n  for (int i = 0; i < p[x].size(); i++) {\n    int v = p[x][i].first, o = p[x][i].second;\n    if (v == fa) continue;\n    Print(v, o, x);\n    c[x] -= ans[o];\n  }\n  ans[from] = c[x];\n}\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(make_pair(y, i));\n    g[y].push_back(make_pair(x, i));\n  }\n  memset(color, 0xff, sizeof(color));\n  color[1] = 1;\n  sum[1] += a[1];\n  Draw(1);\n  if ((sum[0] % 2 + sum[1] % 2) % 2) {\n    puts(\"NO\");\n    return 0;\n  }\n  if (sum[1] == sum[0]) {\n    printf(\"YES\\n\");\n    Print(!root ? 1 : root, 0, 0);\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n  } else {\n    if (!root) return puts(\"NO\") * 0;\n    printf(\"YES\\n\");\n    Print(root, 0, 0);\n    long long res = ans[0];\n    ans[to.second] = res / 2;\n    a[root] -= res / 2;\n    a[to.first] -= res / 2;\n    Print(root, 0, 0);\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void read(int &x) {\n  int v = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-')\n    f = -1;\n  else\n    v = (c & 15);\n  while (isdigit(c = getchar())) v = (v << 1) + (v << 3) + (c & 15);\n  x = v * f;\n}\ninline void read(long long &x) {\n  long long v = 0ll, f = 1ll;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-')\n    f = -1;\n  else\n    v = (c & 15);\n  while (isdigit(c = getchar())) v = (v << 1) + (v << 3) + (c & 15);\n  x = v * f;\n}\ninline void readc(char &x) {\n  char c;\n  while (((c = getchar()) == ' ') || c == '\\n')\n    ;\n  x = c;\n}\nint n, m, i, j, vis[100005], ve[100005], dep[100005];\nlong long a[100005], px[100005], py[100005], res[100005];\nvector<int> e[100005];\nvoid dfs1(int x) {\n  vis[x] = 1;\n  for (__typeof((e[x]).begin()) it = (e[x]).begin(); it != (e[x]).end(); it++) {\n    if (!ve[*it]) {\n      int y = px[*it] ^ py[*it] ^ x;\n      if (!vis[y]) {\n        ve[*it] = 1;\n        dep[y] = dep[x] + 1;\n        dfs1(y);\n        res[*it] += a[y];\n        a[x] -= a[y];\n        a[y] = 0;\n      }\n    }\n  }\n}\nint main() {\n  read(n);\n  read(m);\n  for (((i)) = (1); ((i)) <= ((n)); ((i))++) read(a[i]);\n  for (((i)) = (1); ((i)) <= ((m)); ((i))++) {\n    int x, y;\n    read(x);\n    read(y);\n    px[i] = x;\n    py[i] = y;\n    e[x].push_back(i);\n    e[y].push_back(i);\n  }\n  dfs1(1);\n  for (((i)) = (1); ((i)) <= ((m)); ((i))++)\n    if (!ve[i]) {\n      if (!((dep[px[i]] ^ dep[py[i]]) & 1)) {\n        if (dep[px[i]] & 1)\n          res[i] -= a[1] / 2;\n        else\n          res[i] = +a[1] / 2;\n        a[px[i]] -= res[i];\n        a[py[i]] -= res[i];\n        break;\n      }\n    }\n  memset(vis, 0, sizeof(vis));\n  memset(ve, 0, sizeof(ve));\n  dfs1(1);\n  if (a[1]) {\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  for (((i)) = (1); ((i)) <= ((m)); ((i))++) {\n    printf(\"%lld\\n\", res[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, dep[100010], st[100010][17];\nlong long c[100010], tc[100010], ans[100010];\nvector<pair<int, int> > v[100010];\nbool vis[100010];\nvoid dfs1(int np, int fath) {\n  vis[np] = 1;\n  dep[np] = dep[fath] + 1;\n  st[np][0] = fath;\n  for (int i = 1; i < 17; i++) st[np][i] = st[st[np][i - 1]][i - 1];\n  for (auto &x : v[np]) {\n    if (x.first == fath || vis[x.first]) continue;\n    dfs1(x.first, np);\n    ans[x.second] = tc[x.first];\n    tc[np] -= tc[x.first];\n    tc[x.first] = 0;\n  }\n}\ninline int lca(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  for (int i = 16; i >= 0; i--)\n    if (dep[st[x][i]] >= dep[y]) x = st[x][i];\n  if (x == y) return x;\n  for (int i = 16; i >= 0; i--)\n    if (st[x][i] != st[y][i]) x = st[x][i], y = st[y][i];\n  return st[x][0];\n}\nint s[100010], e[100010];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]), tc[i] = c[i];\n  for (int i = 1, ti, tj; i <= m; i++) {\n    scanf(\"%d%d\", &ti, &tj);\n    s[i] = ti;\n    e[i] = tj;\n    v[ti].push_back(make_pair(tj, i));\n    v[tj].push_back(make_pair(ti, i));\n  }\n  dfs1(1, 0);\n  if (tc[1] == 0) {\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n  }\n  bool flag = 1;\n  int pos = -1, pv = 0;\n  for (int i = 1; i <= m; i++) {\n    if ((dep[s[i]] + dep[e[i]] - 2 * dep[lca(s[i], e[i])]) % 2 == 0) {\n      flag = 0;\n      int vl = tc[1] / 2;\n      ans[i] = vl;\n      pos = i;\n      pv = vl;\n      c[s[i]] -= vl;\n      c[e[i]] -= vl;\n      break;\n    }\n  }\n  if (flag) {\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  memset(vis, 0, sizeof(vis));\n  copy(c + 1, c + n + 1, tc + 1);\n  dfs1(1, 0);\n  if (tc[1]) {\n    c[s[pos]] += pv * 2;\n    c[e[pos]] += pv * 2;\n    ans[pos] = -pv;\n    memset(vis, 0, sizeof(vis));\n    copy(c + 1, c + n + 1, tc + 1);\n    dfs1(1, 0);\n  }\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N, M;\n  cin >> N >> M;\n  vector<ll> C(N);\n  for (int i = 0; i < N; ++i) cin >> C[i];\n  vector<array<int, 2>> edges(M);\n  vector<vector<int>> adj(N);\n  for (int i = 0; i < M; ++i) {\n    int v, u;\n    cin >> v >> u;\n    edges[i] = {--v, --u};\n    adj[v].emplace_back(i);\n    adj[u].emplace_back(i);\n  }\n  int e = -1;\n  vector<int> dist(N, -1);\n  vector<vector<int>> tree(N);\n  function<void(int)> dfs = [&](int v) {\n    for (int i : adj[v]) {\n      int u = edges[i][0] ^ edges[i][1] ^ v;\n      if (dist[u] >= 0) {\n        if ((dist[v] + dist[u] + 1) & 1) e = i;\n      } else {\n        tree[v].emplace_back(i);\n        dist[u] = dist[v] + 1;\n        dfs(u);\n      }\n    }\n  };\n  dist[0] = 0;\n  dfs(0);\n  array<ll, 2> sum{};\n  for (int i = 0; i < N; ++i) sum[dist[i] & 1] += C[i];\n  if (e == -1 && sum[0] != sum[1]) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  vector<ll> ans(M);\n  if (e != -1) {\n    int v = edges[e][0];\n    int u = edges[e][1];\n    assert((dist[v] & 1) == (dist[u] & 1));\n    int p = dist[v] & 1;\n    ans[e] = (sum[p] - sum[p ^ 1]) >> 1;\n    C[v] -= ans[e];\n    C[u] -= ans[e];\n  }\n  function<void(int)> solve = [&](int v) {\n    for (int i : tree[v]) {\n      int u = edges[i][0] ^ edges[i][1] ^ v;\n      solve(u);\n      ans[i] = C[u];\n      C[u] -= ans[i];\n      C[v] -= ans[i];\n    }\n  };\n  solve(0);\n  cout << \"YES\\n\";\n  for (int i = 0; i < M; ++i) {\n    cout << ans[i] << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = 0;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nstring direc = \"RDLU\";\nlong long ln, lk, lm;\nvoid etp(bool f = 0) {\n  puts(f ? \"YES\" : \"NO\");\n  exit(0);\n}\nvoid addmod(int &x, int y, int mod = 1000000007) {\n  assert(y >= 0);\n  x += y;\n  if (x >= mod) x -= mod;\n  assert(x >= 0 && x < mod);\n}\nvoid et() {\n  puts(\"-1\");\n  exit(0);\n}\nlong long fastPow(long long x, long long y, int mod = 1000000007) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (x * ans) % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long gcd1(long long x, long long y) {\n  long long z = y;\n  while (x % y != 0) {\n    z = x % y;\n    x = y;\n    y = z;\n  }\n  return z;\n}\nvector<pair<int, int> > mp[100005];\nint C[100005], U[100005], V[100005], dp[100005], fa[100005], A, B, AB,\n    efa[100005];\nlong long sv[100005];\nlong long wt[100005];\nbool vis[100005];\nvoid dfs(int x, int pa) {\n  vis[x] = 1;\n  dp[x] = dp[pa] + 1;\n  fa[x] = pa;\n  for (auto cp : mp[x])\n    if (cp.first != pa) {\n      int c = cp.first, eid = cp.second;\n      if (vis[c]) {\n        if (dp[x] > dp[c] && (dp[x] - dp[c]) % 2 == 0) {\n          A = x;\n          B = c;\n          AB = eid;\n        }\n      } else {\n        efa[c] = eid;\n        dfs(c, x);\n        wt[eid] = C[c] - sv[c];\n        sv[x] += wt[eid];\n      }\n    }\n}\nvoid fmain(int ID) {\n  scanf(\"%d%d\", &n, &m);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) scanf(\"%d\", C + i);\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    mp[u].push_back({v, i});\n    mp[v].push_back({u, i});\n    U[i] = u;\n    V[i] = v;\n  }\n  dfs(1, 0);\n  if (abs(C[1] - sv[1]) % 2 == 1) etp();\n  if (abs(C[1] - sv[1]) != 0) {\n    if (A == 0) etp();\n    int fg = (dp[B] - dp[1]) & 1 ? -1 : 1;\n    long long w = (C[1] - sv[1]) / 2 * fg;\n    wt[AB] = w;\n    long long tw = w;\n    for (int i = A; i != B; i = fa[i]) {\n      wt[efa[i]] -= tw;\n      tw *= -1;\n    }\n    tw = w + w;\n    for (int i = B; i != 1; i = fa[i]) {\n      wt[efa[i]] -= tw;\n      tw *= -1;\n    }\n  }\n  puts(\"YES\");\n  for (int(i) = 1; (i) <= (int)(m); (i)++) printf(\"%lld\\n\", wt[i]);\n}\nint main() {\n  int t = 1;\n  for (int(i) = 1; (i) <= (int)(t); (i)++) {\n    fmain(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100007;\nint n, kolor[MAXN];\nlong long weights[MAXN], kraw[MAXN];\npair<int, int> pre[MAXN];\nvector<pair<int, int> > G[MAXN], cykl;\nbool odw[MAXN];\nint dfs(int v, int kol = 1) {\n  kolor[v] = kol;\n  for (auto ele : G[v]) {\n    int w, ix;\n    tie(w, ix) = ele;\n    if (w == pre[v].first) continue;\n    if (kolor[w] == 0) {\n      pre[w] = {v, ix};\n      int r = dfs(w, 3 - kol);\n      if (r != -1) return r;\n    } else if (kolor[w] == kolor[v]) {\n      int s = v;\n      do {\n        cykl.emplace_back(s, pre[s].second);\n        s = pre[s].first;\n      } while (s != w);\n      cykl.push_back({w, ix});\n      return w;\n    }\n  }\n  return -1;\n}\nvoid foo(int v, int poprz = -1) {\n  odw[v] = true;\n  for (auto ele : G[v]) {\n    int w, ix;\n    tie(w, ix) = ele;\n    if (!odw[w]) {\n      foo(w, ix);\n      weights[v] -= kraw[ix];\n    }\n  }\n  if (poprz != -1) {\n    kraw[poprz] += weights[v];\n    weights[v] = 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> weights[i];\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].emplace_back(b, i);\n    G[b].emplace_back(a, i);\n  }\n  int c = dfs(1);\n  if (c == -1) {\n    long long suma[3] = {0};\n    for (int i = 1; i <= n; i++) suma[kolor[i]] += weights[i];\n    if (suma[1] == suma[2]) {\n      cout << \"YES\\n\";\n      foo(1);\n      for (int i = 1; i <= m; i++) {\n        cout << kraw[i] << \"\\n\";\n      }\n    } else {\n      cout << \"NO\\n\";\n    }\n  } else {\n    foo(c);\n    rotate(cykl.begin(), cykl.end() - 1, cykl.end());\n    for (int i = 0; i < int(cykl.size()); i++) {\n      kraw[cykl[i].second] += ((i % 2) ? -1 : 1) * weights[c] / 2;\n    }\n    cout << \"YES\\n\";\n    for (int i = 1; i <= m; i++) {\n      cout << kraw[i] << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void chkmin(T1 &x, T2 y) {\n  if (x > y) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1 &x, T2 y) {\n  if (x < y) x = y;\n}\ninline int readChar();\ntemplate <class T = int>\ninline T readInt();\ntemplate <class T>\ninline void writeInt(T x, char end = 0);\ninline void writeChar(int x);\ninline void writeWord(const char *s);\nstatic const int buf_size = 4096;\ninline int getChar() {\n  static char buf[buf_size];\n  static int len = 0, pos = 0;\n  if (pos == len) {\n    pos = 0, len = fread(buf, 1, buf_size, stdin);\n  }\n  if (pos == len) {\n    return -1;\n  }\n  return buf[pos++];\n}\ninline int readChar() {\n  int c = getChar();\n  while (c <= 32) {\n    c = getChar();\n  }\n  return c;\n}\ntemplate <class T>\ninline T readInt() {\n  int s = 1, c = readChar();\n  T x = 0;\n  if (c == '-') s = -1, c = getChar();\n  while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getChar();\n  return s == 1 ? x : -x;\n}\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\ninline void writeChar(int x) {\n  if (write_pos == buf_size)\n    fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n  write_buf[write_pos++] = x;\n}\ntemplate <class T>\ninline void writeInt(T x, char end) {\n  if (x < 0) writeChar('-'), x = -x;\n  char s[24];\n  int n = 0;\n  while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n  while (n--) writeChar(s[n]);\n  if (end) writeChar(end);\n}\ninline void writeWord(const char *s) {\n  while (*s) writeChar(*s++);\n}\nstruct Flusher {\n  ~Flusher() {\n    if (write_pos) fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n  }\n} flusher;\nconst string FILENAME = \"input\";\nconst int MAXN = 100001;\nint n, m;\nvector<int> g[MAXN];\nlong long c[MAXN];\nint used[MAXN];\nint pr[MAXN];\nint edge[MAXN][2];\nlong long ans[MAXN];\nvector<int> cycle;\nint inv(int id, int u) { return u ^ edge[id][0] ^ edge[id][1]; }\nint dfs1(int v) {\n  for (auto h : g[v]) {\n    int u = inv(h, v);\n    if (used[u] != -1) {\n      if (used[v] == used[u]) {\n        cycle.push_back(h);\n        int w = v;\n        while (w != u) {\n          cycle.push_back(pr[w]);\n          w = inv(pr[w], w);\n        }\n        return u;\n      }\n      continue;\n    }\n    used[u] = used[v] ^ 1;\n    pr[u] = h;\n    int w = dfs1(u);\n    if (w != -1) {\n      return w;\n    }\n  }\n  return -1;\n}\nvoid dfs2(int v) {\n  for (auto h : g[v]) {\n    int u = inv(h, v);\n    if (pr[u] != -1) {\n      continue;\n    }\n    pr[u] = h;\n    dfs2(u);\n    ans[h] += c[u];\n    c[v] -= c[u];\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n  }\n  for (int i = 0; i < m; i++) {\n    cin >> edge[i][0] >> edge[i][1];\n    edge[i][0]--;\n    edge[i][1]--;\n    g[edge[i][0]].push_back(i);\n    g[edge[i][1]].push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    used[i] = -1;\n  }\n  used[0] = 0;\n  int s = dfs1(0);\n  for (int i = 0; i < n; i++) {\n    pr[i] = -1;\n  }\n  if (s == -1) {\n    pr[0] = -2;\n    dfs2(0);\n  } else {\n    pr[s] = -2;\n    dfs2(s);\n  }\n  if (s == -1 && c[0] != 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  chkmax(s, 0);\n  for (int i = 0; i < (int)(cycle).size(); i++) {\n    if (i & 1) {\n      ans[cycle[i]] -= c[s] / 2;\n    } else {\n      ans[cycle[i]] += c[s] / 2;\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) {\n    cout << ans[i] << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, fst[200005], nxt[200005 << 1], to[200005 << 1], l, dep[200005],\n    vis[200005], fa[200005], x[200005], y[200005];\nlong long c[200005], a[200005], sum[2];\nvoid link(int x, int y) {\n  to[++l] = y;\n  nxt[l] = fst[x];\n  fst[x] = l;\n  to[++l] = x;\n  nxt[l] = fst[y];\n  fst[y] = l;\n}\nvoid dfs(int x) {\n  dep[x] = dep[fa[x]] ^ 1;\n  sum[dep[x]] += c[x];\n  vis[x] = 1;\n  for (int i = fst[x]; i; i = nxt[i])\n    if (!vis[to[i]]) {\n      fa[to[i]] = x;\n      dfs(to[i]);\n    }\n}\nvoid solve(int x) {\n  for (int i = fst[x]; i; i = nxt[i])\n    if (fa[to[i]] == x) {\n      solve(to[i]);\n      a[(i + 1) / 2] = c[to[i]];\n      c[x] -= c[to[i]];\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &c[i]);\n  }\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    link(x[i], y[i]);\n  }\n  dfs(1);\n  if (sum[0] != sum[1]) {\n    for (int i = 1; i <= m; i++) {\n      if (dep[x[i]] == dep[y[i]]) {\n        a[i] = (sum[dep[x[i]]] - sum[dep[x[i]] ^ 1]) / 2;\n        c[x[i]] -= a[i];\n        c[y[i]] -= a[i];\n        sum[dep[x[i]]] -= a[i] * 2;\n        break;\n      }\n    }\n  }\n  if (sum[0] != sum[1]) {\n    puts(\"NO\");\n  } else {\n    puts(\"YES\");\n    solve(1);\n    for (int i = 1; i <= m; i++) {\n      printf(\"%lld\\n\", a[i]);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Edge {\n  int to, idx;\n};\nvector<vector<Edge>> adj;\nvector<int> side;\nvector<Edge> odd_cycle;\nvector<Edge> pre;\nbool bipartite(int v = 0, int p = -1, int s = 0, int idx = -1) {\n  if (p == -1) side.assign(adj.size(), -1);\n  if (side[v] >= 0) {\n    if (side[v] == s) return true;\n    odd_cycle.push_back({p, idx});\n    int cur = p;\n    do {\n      odd_cycle.push_back(pre[cur]);\n      cur = pre[cur].to;\n    } while (cur != v);\n    return false;\n  }\n  side[v] = s;\n  pre[v] = {p, idx};\n  for (auto u : adj[v]) {\n    if (u.to == p) continue;\n    if (!bipartite(u.to, v, s ^ 1, u.idx)) return false;\n  }\n  return true;\n}\nvector<long long> weigths;\nvector<bool> visited;\nvector<int> c;\nlong long dfs_st(int v, int p = -1, int idx = -1) {\n  visited[v] = true;\n  long long sum = 0;\n  for (auto u : adj[v]) {\n    if (u.to == p) continue;\n    if (!visited[u.to]) sum += dfs_st(u.to, v, u.idx);\n  }\n  auto todo = c[v] - sum;\n  if (idx >= 0) weigths[idx] = todo;\n  return todo;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  c.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n  }\n  adj.resize(n);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    adj[u].push_back({v, i});\n    adj[v].push_back({u, i});\n  }\n  weigths.assign(m, 0);\n  visited.assign(n, false);\n  pre.resize(n);\n  if (bipartite()) {\n    array<long long, 2> sum = {{0, 0}};\n    for (int i = 0; i < n; i++) {\n      sum[side[i]] += c[i];\n    }\n    if (sum[0] == sum[1]) {\n      dfs_st(0);\n    } else {\n      cout << \"NO\" << '\\n';\n      return 0;\n    }\n  } else {\n    int start = odd_cycle.back().to;\n    auto todo = dfs_st(start) / 2;\n    for (auto e : odd_cycle) {\n      weigths[e.idx] += todo;\n      todo *= -1;\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (auto w : weigths) {\n    cout << w << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tint[] head;\n\tint[] next;\n\tint[] to;\n\n\tint[] cs;\n\n\tint[] parEdge;\n\tint[] col;\n\n\tlong[] ans;\n\n\tint v1 = -1, v2 = -1;\n\tint eOdd = -1;\n\n\tlong val0;\n\t\n\tvoid dfs(int v, int p) {\n\t\tlong sumLeft = cs[v];\n\t\tparEdge[v] = p;\n\t\tfor (int e = head[v]; e >= 0; e = next[e]) {\n\t\t\tint u = to[e];\n\t\t\tif (col[u] == -1) {\n\t\t\t\tcol[u] = col[v] ^ 1;\n\t\t\t\tdfs(u, e);\n\t\t\t\tsumLeft -= ans[e >> 1];\n\t\t\t} else if (col[u] == col[v]) {\n\t\t\t\tv1 = v;\n\t\t\t\tv2 = u;\n\t\t\t\teOdd = e;\n\t\t\t}\n\t\t}\n\t\tif (p != -1) {\n\t\t\tans[p >> 1] = sumLeft;\n\t\t} else {\n\t\t\tval0 = sumLeft;\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\n\t\thead = new int[n];\n\t\tArrays.fill(head, -1);\n\t\tnext = new int[2 * m];\n\t\tto = new int[2 * m];\n\n\t\tcs = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcs[i] = nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint v = nextInt() - 1;\n\t\t\tint u = nextInt() - 1;\n\n\t\t\tto[2 * i] = u;\n\t\t\tnext[2 * i] = head[v];\n\t\t\thead[v] = 2 * i;\n\n\t\t\tto[2 * i + 1] = v;\n\t\t\tnext[2 * i + 1] = head[u];\n\t\t\thead[u] = 2 * i + 1;\n\t\t}\n\n\t\tparEdge = new int[n];\n\t\tcol = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tcol[0] = 0;\n\t\tans = new long[m];\n\t\tdfs(0, -1);\n\t\t\n\t\tif (val0 == 0) {\n\t\t\tout.println(\"YES\");\n\t\t\tfor (long x : ans) {\n\t\t\t\tout.println(x);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (eOdd == -1) {\n\t\t\tout.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tList<Integer> path = new ArrayList<>();\n\t\tfor (int i = v1; i > 0; i = to[parEdge[i] ^ 1]) {\n\t\t\tpath.add(parEdge[i] >> 1);\n\t\t}\n\t\tCollections.reverse(path);\n\t\tpath.add(eOdd >> 1);\n\t\tfor (int i = v2; i > 0; i = to[parEdge[i] ^ 1]) {\n\t\t\tpath.add(parEdge[i] >> 1);\n\t\t}\n\t\t\n\t\tif (val0 % 2 != 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\t\n\t\tlong delta = -val0 / 2;\n\t\t\n\t\tfor (int i = 0; i < path.size(); i++) {\n\t\t\tint idx = path.get(i);\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tans[idx] -= delta;\n\t\t\t} else {\n\t\t\t\tans[idx] += delta;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"YES\");\n\t\tfor (long x : ans) {\n\t\t\tout.println(x);\n\t\t}\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tD() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nbool Max(T1& a, T2 b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T1, typename T2>\nbool Min(T1& a, T2 b) {\n  return a > b ? a = b, 1 : 0;\n}\nconst int N = 100001;\nvector<pair<int, int> > g[N];\nlong long a[N];\nlong long ans[N];\nint dep[N];\nint vi[N], ct;\nint odde, odda, oddb;\nlong long dfs(int i) {\n  vi[i] = ct;\n  long long ret = a[i];\n  for (auto& e : g[i]) {\n    if (vi[e.first] == ct) {\n      int t = dep[i] - dep[e.first];\n      if (t > 0 && t % 2 == 0) {\n        odde = e.second;\n        odda = i;\n        oddb = e.first;\n      }\n    } else {\n      dep[e.first] = dep[i] + 1;\n      ans[e.second] = dfs(e.first);\n      ret -= ans[e.second];\n    }\n  }\n  return ret;\n}\nlong long dfs2(int i) {\n  vi[i] = ct;\n  long long ret = a[i];\n  for (auto& e : g[i])\n    if (vi[e.first] != ct) {\n      ans[e.second] = dfs2(e.first);\n      ret -= ans[e.second];\n    }\n  return ret;\n}\nbool go(int i) {\n  if (vi[i] > 0) return 1;\n  ++ct;\n  odde = -1;\n  long long ret = dfs(i);\n  if (ret == 0) return 1;\n  if (odde < 0) return 0;\n  assert(ret % 2 == 0);\n  ret /= 2;\n  if (dep[odda] & 1) ret = -ret;\n  ans[odde] = ret;\n  a[odda] -= ret;\n  a[oddb] -= ret;\n  ++ct;\n  ret = dfs2(i);\n  assert(ret == 0);\n  return 1;\n}\nvoid solve() {\n  int n, m, u, v;\n  cin >> n >> m;\n  for (int i = 1; i <= (int)(n); ++i) cin >> a[i];\n  for (int i = 0; i < (int)(m); ++i) {\n    cin >> u >> v;\n    g[u].push_back({v, i});\n    g[v].push_back({u, i});\n  }\n  for (int i = 1; i <= (int)(n); ++i)\n    if (!go(i)) {\n      cout << \"NO\" << '\\n';\n      return;\n    }\n  cout << \"YES\" << '\\n';\n  for (int i = 0; i < (int)(m); ++i) cout << ans[i] << '\\n';\n}\nvoid init() {}\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n  init();\n  int TC = 1;\n  for (int TI = 1; TI <= (int)(TC); ++TI) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DWeightingATree solver = new DWeightingATree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DWeightingATree {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].w = in.readInt();\n            }\n            DSU dsu = new DSU(n);\n            Edge[] edges = new Edge[m];\n            for (int i = 0; i < m; i++) {\n                edges[i] = new Edge();\n                edges[i].a = nodes[in.readInt() - 1];\n                edges[i].b = nodes[in.readInt() - 1];\n                if (dsu.find(edges[i].a.id) != dsu.find(edges[i].b.id)) {\n                    edges[i].tree = true;\n                    dsu.merge(edges[i].a.id, edges[i].b.id);\n                    edges[i].a.next.add(edges[i]);\n                    edges[i].b.next.add(edges[i]);\n                }\n            }\n\n            dfs(nodes[0], null, 0);\n            long diff = 0;\n            for (Node node : nodes) {\n                if (node.sign) {\n                    diff += node.w;\n                } else {\n                    diff -= node.w;\n                }\n            }\n\n            if (diff % 2 != 0) {\n                out.println(\"NO\");\n                return;\n            }\n\n            for (Edge e : edges) {\n                if (e.tree) {\n                    continue;\n                }\n                if (e.a.sign != e.b.sign) {\n                    continue;\n                }\n                if (e.a.sign) {\n                    e.val = diff / 2;\n                } else {\n                    e.val = -diff / 2;\n                }\n                e.a.w -= e.val;\n                e.b.w -= e.val;\n                diff = 0;\n                break;\n            }\n\n            if (diff != 0) {\n                out.println(\"NO\");\n                return;\n            }\n\n            dfs(nodes[0], null, 0);\n            out.println(\"YES\");\n            for (Edge e : edges) {\n                out.println(e.val);\n            }\n        }\n\n        public long dfs(Node root, Edge p, int d) {\n            root.sign = d % 2 == 0;\n            long w = root.w;\n            for (Edge e : root.next) {\n                Node node = e.other(root);\n                if (e == p) {\n                    continue;\n                }\n                long need = dfs(node, e, d + 1);\n                e.val = need;\n                w -= need;\n            }\n            return w;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c);\n            println();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c);\n            println();\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Edge {\n        Node a;\n        Node b;\n        long val;\n        boolean tree;\n\n        Node other(Node x) {\n            return a == x ? b : a;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class DSU {\n        int[] p;\n        int[] rank;\n\n        public DSU(int n) {\n            p = new int[n];\n            rank = new int[n];\n            reset();\n        }\n\n        public void reset() {\n            for (int i = 0; i < p.length; i++) {\n                p[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int find(int a) {\n            return p[a] == p[p[a]] ? p[a] : (p[a] = find(p[a]));\n        }\n\n        public void merge(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (rank[a] == rank[b]) {\n                rank[a]++;\n            }\n            if (rank[a] > rank[b]) {\n                p[b] = a;\n            } else {\n                p[a] = b;\n            }\n        }\n\n    }\n\n    static class Node {\n        int id;\n        List<Edge> next = new ArrayList<>();\n        long w;\n        boolean sign;\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  bool f = 0;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = 1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);\n  if (f) x = -x;\n}\ntemplate <typename F>\ninline void write(F x, char ed = '\\n') {\n  static short st[30];\n  short tp = 0;\n  if (x < 0) putchar('-'), x = -x;\n  do st[++tp] = x % 10, x /= 10;\n  while (x);\n  while (tp) putchar('0' | st[tp--]);\n  putchar(ed);\n}\ntemplate <typename T>\ninline void Mx(T &x, T y) {\n  x < y && (x = y);\n}\ntemplate <typename T>\ninline void Mn(T &x, T y) {\n  x > y && (x = y);\n}\nconst int N = 205000;\nlong long c[N], val[N], res[N];\nint h[N], ne[N << 1], to[N << 1], tot = 1, m, n;\ninline void add(int x, int y) { ne[++tot] = h[x], to[h[x] = tot] = y; }\nint dep[N], son[N], f[N], siz[N], Top[N], vis[N];\nvoid dfs1(int x, int fa) {\n  dep[x] = dep[f[x] = fa] + (siz[x] = vis[x] = 1), res[x] = c[x];\n  for (int i = h[x]; i; i = ne[i]) {\n    int y = to[i];\n    if (vis[y]) continue;\n    dfs1(y, x), siz[x] += siz[y];\n    if (siz[son[x]] < siz[y]) son[x] = y;\n    val[i >> 1] = res[y], res[x] -= res[y];\n  }\n}\nvoid dfs2(int x, int topf) {\n  Top[x] = topf, vis[x] = 1, son[x] && (dfs2(son[x], topf), 0);\n  for (int i = h[x], y; i; i = ne[i]) !vis[y = to[i]] && (dfs2(y, y), 0);\n}\nint Lca(int x, int y) {\n  while (Top[x] != Top[y]) {\n    if (dep[Top[x]] < dep[Top[y]]) swap(x, y);\n    x = f[Top[x]];\n  }\n  return dep[x] < dep[y] ? x : y;\n}\ninline void nope(void) {\n  puts(\"NO\");\n  exit(0);\n}\ninline void ojbk(void) {\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) write(val[i]);\n  exit(0);\n}\nint main() {\n  read(n), read(m);\n  for (int i = 1; i <= n; i++) read(c[i]);\n  for (int i = 1, x, y; i <= m; i++) read(x), read(y), add(x, y), add(y, x);\n  dfs1(1, 0), memset(vis, 0, sizeof(vis)), dfs2(1, 1);\n  (res[1] & 1) ? nope(), 0 : !res[1] && (ojbk(), 0);\n  for (int i = 1; i <= m; i++) {\n    int x = to[i * 2], y = to[(i * 2) ^ 1];\n    if ((dep[x] + dep[y]) & 1) continue;\n    int t = (dep[x] & 1) ? 2 : -2, tmp = res[1] / t;\n    val[i] = tmp, memset(vis, 0, sizeof(vis));\n    c[x] -= tmp, c[y] -= tmp, dfs1(1, 0), ojbk();\n  }\n  nope();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> edges[110000];\nlong long c[110000];\npair<int, int> r[110000];\nmap<pair<int, int>, long long> wgt;\nint color[110000];\nvector<int> oddcyc;\nint done = 0;\nint dfs(int a, int col) {\n  if (done) return -1;\n  if (color[a] == 1 - col) {\n    return a;\n  }\n  if (color[a] == col) return -1;\n  color[a] = col;\n  for (int j = 0; j < edges[a].size(); j++) {\n    int k = dfs(edges[a][j], 1 - col);\n    if (done) return -1;\n    if (k != -1) {\n      oddcyc.push_back(a);\n      if (k == a) done = 1;\n      return k;\n    }\n  }\n  return -1;\n}\nint vis[110000];\nint cyc[110000];\nvoid setwgt(int a, int b, long long w) {\n  wgt[make_pair(a, b)] = w;\n  wgt[make_pair(b, a)] = w;\n}\nvoid dfs2(int par, int a) {\n  if (vis[a]) return;\n  vis[a] = 1;\n  for (int j = 0; j < edges[a].size(); j++) {\n    dfs2(a, edges[a][j]);\n  }\n  if (par != -1) {\n    setwgt(a, par, c[a]);\n    c[par] -= c[a];\n    c[a] -= c[a];\n  }\n}\nvoid dfs3(int par, int a) {\n  if (vis[a]) return;\n  if (par != -1 && cyc[a]) return;\n  vis[a] = 1;\n  for (int j = 0; j < edges[a].size(); j++) {\n    dfs3(a, edges[a][j]);\n  }\n  if (par != -1) {\n    setwgt(a, par, c[a]);\n    c[par] -= c[a];\n    c[a] -= c[a];\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    r[i].first = a;\n    r[i].second = b;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  for (int i = 0; i < n; i++) {\n    color[i] = -1;\n    vis[i] = cyc[i] = 0;\n  }\n  dfs(0, 0);\n  if (oddcyc.size() == 0) {\n    long long sums[2];\n    sums[0] = sums[1] = 0;\n    for (int j = 0; j < n; j++) {\n      sums[color[j]] += c[j];\n    }\n    if (sums[0] != sums[1]) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    dfs2(-1, 0);\n    cout << \"YES\" << endl;\n    for (int j = 0; j < m; j++) {\n      cout << wgt[r[j]] << endl;\n    }\n    return 0;\n  }\n  for (int i = 0; i < oddcyc.size(); i++) {\n    cyc[oddcyc[i]] = 1;\n  }\n  for (int i = 0; i < oddcyc.size(); i++) {\n    dfs3(-1, oddcyc[i]);\n  }\n  long long lastedge = 0;\n  for (int i = 0; i < oddcyc.size(); i++) {\n    if (i % 2 == 0) {\n      lastedge += c[oddcyc[i]];\n    } else {\n      lastedge -= c[oddcyc[i]];\n    }\n  }\n  lastedge /= 2;\n  setwgt(oddcyc[0], oddcyc[oddcyc.size() - 1], lastedge);\n  for (int i = 0; i < oddcyc.size() - 1; i++) {\n    lastedge = c[oddcyc[i]] - lastedge;\n    setwgt(oddcyc[i], oddcyc[i + 1], lastedge);\n  }\n  cout << \"YES\" << endl;\n  for (int j = 0; j < m; j++) {\n    cout << wgt[r[j]] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void upmin(T &x, T y) {\n  y < x ? x = y : 0;\n}\ntemplate <typename T>\ninline void upmax(T &x, T y) {\n  x < y ? x = y : 0;\n}\nconst long double pi = acos(-1);\nconst int oo = 1 << 30;\nconst long long OO = 1e18;\nconst int N = 1e5 + 100;\nint gi() {\n  int w = 0;\n  bool q = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && c != '-') c = getchar();\n  if (c == '-') q = 0, c = getchar();\n  while (c >= '0' && c <= '9') w = w * 10 + c - '0', c = getchar();\n  return q ? w : -w;\n}\nint head[N], nxt[N * 2], to[N * 2];\nint u[N], v[N], dis[N];\nint fa[N], e[N];\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nlong long ans[N], c[N];\ninline void dfs(int k, int fa) {\n  for (int i = head[k]; i; i = nxt[i])\n    if (to[i] != fa) dis[to[i]] = dis[k] ^ 1, dfs(to[i], k);\n}\ninline void solve(int k) {\n  for (int i = head[k]; i; i = nxt[i])\n    if (to[i] != fa[k]) {\n      fa[to[i]] = k, e[to[i]] = i >> 1;\n      solve(to[i]);\n      c[k] -= ans[i >> 1] = c[to[i]];\n    }\n}\nint main() {\n  int n = gi(), m = gi(), i, a, b, t;\n  for (i = 1; i <= n; i++) c[i] = gi(), fa[i] = i;\n  for (i = 1; i <= m; i++)\n    if (find(a = gi()) == find(b = gi()))\n      u[i] = a, v[i] = b;\n    else {\n      to[i * 2] = a, nxt[i * 2] = head[b], head[b] = i * 2;\n      to[i * 2 | 1] = b, nxt[i * 2 | 1] = head[a], head[a] = i * 2 | 1;\n      fa[fa[a]] = b;\n    }\n  memset(fa, 0, sizeof(fa));\n  dfs(1, 0);\n  for (i = 1; i <= m; i++)\n    if (u[i] && dis[u[i]] == dis[v[i]]) {\n      solve(u[i]);\n      ans[i] = t = c[u[i]] / 2;\n      for (a = v[i]; a != u[i]; a = fa[a]) t = -t, ans[e[a]] += t;\n      goto out;\n    }\n  solve(1);\n  if (c[1]) return puts(\"NO\"), 0;\nout:;\n  puts(\"YES\");\n  for (i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid _R(T &x) {\n  cin >> x;\n}\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate <class T, class... U>\nvoid R(T &head, U &...tail) {\n  _R(head);\n  R(tail...);\n}\ntemplate <class T>\nvoid _W(const T &x) {\n  cout << x;\n}\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate <class T, class U>\nvoid _W(const pair<T, U> &x) {\n  _W(x.first);\n  putchar(' ');\n  _W(x.second);\n}\ntemplate <class T>\nvoid _W(const vector<T> &x) {\n  for (auto i = x.begin(); i != x.end(); _W(*i++))\n    if (i != x.cbegin()) putchar(' ');\n}\nvoid W() {}\ntemplate <class T, class... U>\nvoid W(const T &head, const U &...tail) {\n  _W(head);\n  putchar(sizeof...(tail) ? ' ' : '\\n');\n  W(tail...);\n}\ntemplate <class T, class... U>\nvoid DEBUG(const T &head, const U &...tail) {}\nint MOD = 1e9 + 7;\nvoid ADD(int64_t &x, int64_t v) {\n  x = (x + v) % MOD;\n  if (x < 0) x += MOD;\n}\nconst int SIZE = 1e6 + 10;\nvector<pair<int, int> > e[SIZE];\nint lv[SIZE], lt[SIZE];\nint64_t c[SIZE];\nbool u[SIZE];\nbool in_odd_cycle[SIZE];\nvector<int> odd_cycle;\nint64_t an[SIZE];\nvoid dfs(int x) {\n  u[x] = 1;\n  for (int i = 0; i < (((int)(e[x]).size())); ++i) {\n    int y = e[x][i].first;\n    if (u[y]) {\n      if (lv[y] < lv[x] && y != lt[x] && (lv[x] - lv[y]) % 2 == 0 &&\n          !((int)(odd_cycle).size())) {\n        int now = x;\n        while (now != y) {\n          odd_cycle.push_back(now);\n          now = lt[now];\n        }\n        odd_cycle.push_back(y);\n      }\n    } else {\n      lv[y] = lv[x] + 1;\n      lt[y] = x;\n      dfs(y);\n    }\n  }\n}\nvoid dfs_even(int x) {\n  u[x] = 1;\n  for (int i = 0; i < (((int)(e[x]).size())); ++i) {\n    int y = e[x][i].first;\n    if (u[y] || in_odd_cycle[y]) continue;\n    dfs_even(y);\n    an[e[x][i].second] = c[y];\n    c[x] -= c[y];\n  }\n}\nint main() {\n  int n, m;\n  R(n, m);\n  for (int i = (1); i <= (n); ++i) {\n    int x;\n    R(x);\n    c[i] = x;\n  }\n  for (int i = 0; i < (m); ++i) {\n    int x, y;\n    R(x, y);\n    e[x].push_back(make_pair(y, i));\n    e[y].push_back(make_pair(x, i));\n  }\n  dfs(1);\n  if (!((int)(odd_cycle).size())) {\n    memset((u), 0, sizeof((u)));\n    dfs_even(1);\n    if (!c[1]) {\n      puts(\"YES\");\n      for (int i = 0; i < (m); ++i) W(an[i]);\n    } else\n      puts(\"NO\");\n  } else {\n    for (int i = 0; i < (((int)(odd_cycle).size())); ++i) {\n      in_odd_cycle[odd_cycle[i]] = 1;\n    }\n    memset((u), 0, sizeof((u)));\n    for (int i = 0; i < (((int)(odd_cycle).size())); ++i) {\n      dfs_even(odd_cycle[i]);\n    }\n    int64_t v = 0;\n    for (int i = 0; i < (((int)(odd_cycle).size())); ++i) {\n      if (!i || i % 2 == 1)\n        v += c[odd_cycle[i]];\n      else\n        v -= c[odd_cycle[i]];\n    }\n    if (v % 2 != 0) {\n      puts(\"NO\");\n      return 0;\n    }\n    v /= 2;\n    odd_cycle.push_back(odd_cycle[0]);\n    for (int i = (1); i < (((int)(odd_cycle).size())); ++i) {\n      int x = odd_cycle[i - 1];\n      int y = odd_cycle[i];\n      int eid = -1;\n      for (int j = 0; j < (((int)(e[x]).size())); ++j) {\n        if (e[x][j].first == y) {\n          eid = e[x][j].second;\n          break;\n        }\n      }\n      an[eid] = v;\n      v = c[y] - v;\n    }\n    puts(\"YES\");\n    for (int i = 0; i < (m); ++i) W(an[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 100010, maxm = 100010;\nint n, m, a[maxm], b[maxm];\nstruct edge {\n  int id, to;\n  edge* next;\n} E[maxm * 2], *ne = E, *first[maxn];\nvoid link(int i, int u, int v) {\n  *ne = (edge){i, v, first[u]};\n  first[u] = ne++;\n}\nbool vis[maxn], par[maxn];\nlong long c[maxn], ev[maxm];\nlong long dfs(int i) {\n  vis[i] = 1;\n  long long r = c[i];\n  for (edge* e = first[i]; e; e = e->next) {\n    if (!vis[e->to]) {\n      par[e->to] = !par[i];\n      ev[e->id] = dfs(e->to);\n      r -= ev[e->id];\n    }\n  }\n  return r;\n}\nvoid op(int a) {\n  if (a) {\n    puts(\"YES\");\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ev[i]);\n  } else\n    puts(\"NO\");\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", c + i);\n  for (int i = 0; i < m; i++)\n    scanf(\"%d%d\", a + i, b + i), link(i, a[i], b[i]), link(i, b[i], a[i]);\n  long long v1 = dfs(1);\n  if (!v1)\n    op(1);\n  else {\n    int e = 0;\n    while (e < m && par[a[e]] != par[b[e]]) e++;\n    if (e == m)\n      op(0);\n    else {\n      for (int i = 1; i <= n; i++) vis[i] = 0;\n      if (par[a[e]])\n        ev[e] = -v1 / 2;\n      else\n        ev[e] = v1 / 2;\n      c[a[e]] -= ev[e];\n      c[b[e]] -= ev[e];\n      dfs(1);\n      op(1);\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 100000 + 10;\nconst int MAXM = 200000 + 10;\nint N, M;\nlong long c[MAXN];\nint cnt = 1, head[MAXN], next[MAXM], to[MAXM];\nint depth[MAXN];\nint X, Y, id;\nlong long sumx, sumy, weight[MAXM];\ninline void insert(int x, int y) {\n  next[++cnt] = head[x], to[cnt] = y, head[x] = cnt;\n  next[++cnt] = head[y], to[cnt] = x, head[y] = cnt;\n}\ninline void Dfs(int x) {\n  register int i;\n  for (i = head[x]; i; i = next[i])\n    if (!depth[to[i]])\n      depth[to[i]] = depth[x] + 1, Dfs(to[i]);\n    else if (!(depth[x] - depth[to[i]] & 1))\n      X = x, Y = to[i], id = i >> 1;\n}\ninline void solve(int x) {\n  static bool visited[MAXN];\n  register int i;\n  visited[x] = 1;\n  for (i = head[x]; i; i = next[i])\n    if (!visited[to[i]])\n      solve(to[i]), weight[i >> 1] = c[to[i]], c[x] -= weight[i >> 1];\n}\nint main() {\n  register int i;\n  register long long x, y;\n  scanf(\"%d%d\", &N, &M);\n  for (i = 1; i <= N; ++i) scanf(\"%I64d\", c + i);\n  for (i = 1; i <= M; ++i) scanf(\"%I64d%I64d\", &x, &y), insert(x, y);\n  depth[1] = 1;\n  Dfs(1);\n  for (i = 1; i <= N; ++i) (depth[i] & 1 ? sumx : sumy) += c[i];\n  if (sumx != sumy && !id) return 0 * puts(\"NO\");\n  x = (sumx - sumy) >> 1;\n  (depth[X] & 1) ? weight[id] = x : weight[id] = -x;\n  c[X] -= weight[id], c[Y] -= weight[id];\n  solve(1);\n  puts(\"YES\");\n  for (i = 1; i <= M; ++i) printf(\"%I64d\\n\", weight[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst long long inf64 = ((long long)1 << 62) - 1;\nconst long double pi = acos(-1);\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\nT abs(T x) {\n  return x < 0 ? -x : x;\n}\nint n, m;\nvector<long long> x;\nvector<vector<pair<int, int>>> adj;\nvector<bool> in_tree;\nvector<int> color;\nvector<long long> res;\nvoid DFSColor(int v) {\n  for (int i = 0; i < ((int)(adj[v]).size()); ++i) {\n    int u = adj[v][i].first;\n    int num = adj[v][i].second;\n    if (color[u] == -1) {\n      color[u] = 1 - color[v];\n      in_tree[num] = true;\n      DFSColor(u);\n    }\n  }\n}\nlong long DFSRes(int v, int p) {\n  long long sum_cur = 0;\n  for (int i = 0; i < ((int)(adj[v]).size()); ++i) {\n    int u = adj[v][i].first;\n    int num = adj[v][i].second;\n    if (in_tree[num] && u != p) {\n      long long cur = DFSRes(u, v);\n      res[num] = cur;\n      sum_cur += cur;\n    }\n  }\n  return (x[v] - sum_cur);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> m;\n  x.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i];\n  }\n  adj.resize(n);\n  for (int i = 0; i < m; ++i) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    --v1, --v2;\n    adj[v1].push_back(make_pair(v2, i));\n    adj[v2].push_back(make_pair(v1, i));\n  }\n  color.resize(n, -1);\n  in_tree.resize(m, false);\n  color[0] = 0;\n  DFSColor(0);\n  vector<long long> sum(2, 0);\n  for (int i = 0; i < n; ++i) {\n    sum[color[i]] += x[i];\n  }\n  res.resize(m, 0);\n  bool key = false;\n  for (int v = 0; v < n; ++v) {\n    for (int i = 0; i < ((int)(adj[v]).size()); ++i) {\n      int u = adj[v][i].first;\n      if (color[u] == color[v]) {\n        int num = adj[v][i].second;\n        int c = color[v];\n        long long d = (sum[c] - sum[1 - c]) / 2;\n        res[num] = d;\n        x[v] -= d;\n        x[u] -= d;\n        key = true;\n        break;\n      }\n    }\n    if (key) {\n      break;\n    }\n  }\n  if (!key && sum[0] != sum[1]) {\n    cout << \"NO\"\n         << \"\\n\";\n    return 0;\n  }\n  DFSRes(0, -1);\n  cout << \"YES\"\n       << \"\\n\";\n  for (int i = 0; i < m; ++i) {\n    cout << res[i] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nvector<pair<int, int> > g[maxn];\npair<int, int> pre[maxn];\nint c[maxn], rt;\nlong long w[maxn];\nbool vis[maxn], id[maxn];\nbool dfs(int u, int fa, bool tp) {\n  if (vis[u]) {\n    if (tp != id[u] && !rt) {\n      rt = u;\n      return true;\n    } else\n      return false;\n  }\n  vis[u] = 1;\n  id[u] = tp;\n  bool fg = 0;\n  for (auto e : g[u]) {\n    int v = e.first;\n    if (v == fa) continue;\n    if (dfs(v, u, tp ^ 1)) {\n      pre[u] = e;\n      fg = u != rt;\n    }\n  }\n  return fg;\n}\nlong long solve(int u, int fa) {\n  if (vis[u]) return 0;\n  vis[u] = 1;\n  long long d = 0;\n  for (auto e : g[u]) {\n    int v = e.first;\n    d += w[e.second] = solve(v, u);\n  }\n  return c[u] - d;\n}\nint main() {\n  int n, m, u, v, i;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(pair<int, int>(v, i));\n    g[v].push_back(pair<int, int>(u, i));\n  }\n  dfs(1, 0, 1);\n  memset(vis, 0, sizeof(vis));\n  if (!rt) {\n    long long x = solve(1, 0);\n    if (x) return puts(\"NO\");\n    puts(\"YES\");\n    for (i = 0; i < m; i++) printf(\"%lld\\n\", w[i]);\n  } else {\n    long long x = solve(rt, 0);\n    if (abs(x) & 1) return puts(\"NO\");\n    x /= 2;\n    pair<int, int> e = pre[rt];\n    while (true) {\n      w[e.second] += x;\n      if (e.first == rt) break;\n      x *= -1;\n      e = pre[e.first];\n    }\n    puts(\"YES\");\n    for (i = 0; i < m; i++) printf(\"%lld\\n\", w[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint c[100010];\nint x[100010], y[100010];\nvector<int> t[100010];\nint f[100010];\nint find(int x) { return (f[x] == -1 ? x : f[x] = find(f[x])); }\nint fa[100010], dep[100010];\nint dfn[100010], rnk[100010], totn = 0;\nint siz[100010], son[100010], top[100010];\nvoid dfs1(int k) {\n  dep[k] = dep[fa[k]] + 1;\n  siz[k] = 1;\n  for (vector<int>::iterator it = t[k].begin(); it != t[k].end(); ++it) {\n    if (*it == fa[k]) continue;\n    fa[*it] = k;\n    dfs1(*it);\n    siz[k] += siz[*it];\n    if (son[k] == 0 || siz[*it] > siz[son[k]]) son[k] = *it;\n  }\n  return;\n}\nvoid dfs2(int k, int tp) {\n  dfn[k] = ++totn;\n  rnk[totn] = k;\n  top[k] = tp;\n  if (son[k]) dfs2(son[k], tp);\n  for (vector<int>::iterator it = t[k].begin(); it != t[k].end(); ++it) {\n    if (*it == fa[k] || *it == son[k]) continue;\n    dfs2(*it, *it);\n  }\n  return;\n}\nint LCA(int a, int b) {\n  while (top[a] != top[b]) {\n    if (dep[top[a]] < dep[top[b]]) swap(a, b);\n    a = fa[top[a]];\n  }\n  return (dep[a] < dep[b] ? a : b);\n}\nlong long v[100010];\nvoid dfs3(int k) {\n  v[k] = c[k];\n  for (vector<int>::iterator it = t[k].begin(); it != t[k].end(); ++it) {\n    if (*it == fa[k]) continue;\n    dfs3(*it);\n    v[k] -= v[*it];\n  }\n  return;\n}\nlong long ve[100010];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  for (int i = 1; i <= m; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n  memset(f, -1, sizeof(f));\n  for (int i = 1; i <= m; ++i) {\n    int p = find(x[i]), q = find(y[i]);\n    if (p == q) continue;\n    f[p] = q;\n    t[x[i]].push_back(y[i]);\n    t[y[i]].push_back(x[i]);\n  }\n  dfs1(1);\n  dfs2(1, 1);\n  dfs3(1);\n  for (int i = 1; i <= m; ++i) {\n    if (fa[x[i]] == y[i] || fa[y[i]] == x[i]) continue;\n    if ((dep[x[i]] + dep[y[i]] - 2 * dep[LCA(x[i], y[i])]) % 2 == 0) {\n      int val = v[1] / 2;\n      val = val * (dep[x[i]] % 2 == 0 ? -1 : 1);\n      ve[i] = val;\n      c[x[i]] -= val;\n      c[y[i]] -= val;\n      break;\n    }\n  }\n  dfs3(1);\n  if (v[1] != 0) {\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) {\n    if (fa[x[i]] == y[i] || fa[y[i]] == x[i]) {\n      if (dep[x[i]] < dep[y[i]]) swap(x[i], y[i]);\n      ve[i] = v[x[i]];\n    }\n    printf(\"%lld\\n\", ve[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[411111];\nvector<pair<int, int> > v[411111];\nint n, m;\nint x[411111], y[411111], d[411111];\nint no[411111];\nlong long ans[411111];\nlong long c[411111];\nlong long cur[411111];\nint get(int x) {\n  if (p[x] == x) return x;\n  return p[x] = get(p[x]);\n}\nvoid go(int x, int pr, int dd) {\n  d[x] = dd;\n  for (pair<int, int> to : v[x])\n    if (to.first != pr) {\n      go(to.first, x, dd + 1);\n    }\n}\nvoid sol(int x, int pr) {\n  for (pair<int, int> to : v[x])\n    if (to.first != pr) {\n      sol(to.first, x);\n      ans[to.second] = c[to.first] - cur[to.first];\n      cur[to.first] += ans[to.second];\n      cur[x] += ans[to.second];\n    }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  for (int i = 0; i < m; i++) {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n  }\n  for (int i = 0; i < n; i++) p[i] = i;\n  for (int i = 0; i < m; i++) {\n    if (get(x[i]) == get(y[i])) {\n      no[i] = 1;\n      continue;\n    }\n    v[x[i]].push_back(make_pair(y[i], i));\n    v[y[i]].push_back(make_pair(x[i], i));\n    p[get(x[i])] = get(y[i]);\n  }\n  go(0, 0, 1);\n  int cen = 0;\n  int ed = -1;\n  for (int i = 0; i < m; i++)\n    if (no[i]) {\n      if (d[x[i]] % 2 != d[y[i]] % 2) {\n        ans[i] = 0;\n        continue;\n      }\n      cen = x[i];\n      ed = i;\n      break;\n    }\n  sol(cen, cen);\n  if (c[cen] != cur[cen] && ed == -1) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  if (c[cen] == cur[cen]) {\n    cout << \"YES\" << endl;\n    for (int i = 0; i < m; i++) cout << ans[i] << endl;\n    return 0;\n  }\n  long long need = c[cen] - cur[cen];\n  for (int i = 0; i < n; i++) cur[i] = 0;\n  ans[ed] = need / 2;\n  cur[x[ed]] += ans[ed];\n  cur[y[ed]] += ans[ed];\n  sol(cen, cen);\n  cout << \"YES\" << endl;\n  for (int i = 0; i < m; i++) cout << ans[i] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nconst long long INF = 1000 * 1000 * 1000 + 7;\nconst long long LINF = INF * (long long)INF;\nconst int MAX = 100100;\nvector<int> g[MAX];\nvector<int> I[MAX];\nint A[MAX];\nlong long RES[MAX];\nint U[MAX];\nlong long dfs(int x) {\n  U[x] = true;\n  long long sum = 0;\n  for (int i = (0); i < ((int)g[x].size()); i++) {\n    int to = g[x][i];\n    int ind = I[x][i];\n    if (U[to]) continue;\n    long long val = dfs(to);\n    RES[ind] = val;\n    sum += val;\n  }\n  long long add = A[x] - sum;\n  return add;\n}\nint C[MAX];\nint dfs2(int x, long long val, int c) {\n  U[x] = 1;\n  C[x] = c;\n  for (int i = (0); i < ((int)g[x].size()); i++) {\n    int to = g[x][i];\n    int ind = I[x][i];\n    if (U[to] == 1 && C[to] == c) {\n      RES[ind] += val;\n      return to;\n    }\n    if (U[to]) continue;\n    int v = dfs2(to, -val, c ^ 1);\n    if (v == -1) continue;\n    RES[ind] += val;\n    if (v == INF) RES[ind] += val;\n    if (v == x) return INF;\n    return v;\n  }\n  return -1;\n}\nint n, m;\nvoid YES() {\n  printf(\"YES\\n\");\n  for (int i = (0); i < (m); i++) {\n    printf(\"%I64d\\n\", RES[i]);\n  }\n  exit(0);\n}\nvoid NO() {\n  printf(\"NO\\n\");\n  exit(0);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (0); i < (n); i++) {\n    scanf(\"%d\", &A[i]);\n  }\n  for (int i = (0); i < (m); i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    x--;\n    y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n    I[x].push_back(i);\n    I[y].push_back(i);\n  }\n  long long v = dfs(0);\n  memset(U, 0, sizeof(U));\n  if (v == 0) YES();\n  if (v & 1) NO();\n  v /= 2;\n  int r = dfs2(0, v, 0);\n  if (r == INF) YES();\n  NO();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class C>\nvoid mini(C &a4, C b4) {\n  a4 = min(a4, b4);\n}\ntemplate <class C>\nvoid maxi(C &a4, C b4) {\n  a4 = max(a4, b4);\n}\ntemplate <class TH>\nvoid _dbg(const char *sdbg, TH h) {\n  cerr << sdbg << '=' << h << endl;\n}\ntemplate <class TH, class... TA>\nvoid _dbg(const char *sdbg, TH h, TA... a) {\n  while (*sdbg != ',') cerr << *sdbg++;\n  cerr << '=' << h << ',';\n  _dbg(sdbg + 1, a...);\n}\ntemplate <class T>\nostream &operator<<(ostream &os, vector<T> V) {\n  os << \"[\";\n  for (auto vv : V) os << vv << \",\";\n  return os << \"]\";\n}\ntemplate <class L, class R>\nostream &operator<<(ostream &os, pair<L, R> P) {\n  return os << \"(\" << P.first << \",\" << P.second << \")\";\n}\nconst long long MAX = 1e5 + 10;\nlong long n, m;\nlong long c[MAX];\nvector<pair<long long, long long> > d[MAX];\nlong long res[MAX];\nlong long s[MAX];\nlong long par[MAX];\nlong long pari[MAX];\npair<long long, long long> np = {-1, -1};\nlong long npi = -1;\nbool vis[MAX];\nvoid dfs(long long v, long long gl) {\n  vis[v] = 1;\n  s[v] = gl;\n  for (pair<long long, long long> el : d[v]) {\n    if (!vis[el.first]) {\n      par[el.first] = v;\n      pari[el.first] = el.second;\n      dfs(el.first, gl + 1);\n      res[el.second] += c[el.first];\n      c[v] -= c[el.first];\n    } else {\n      if (s[v] % 2 == s[el.first] % 2) {\n        np = {v, el.first};\n        npi = el.second;\n      }\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  if (0) cout << fixed << setprecision(6);\n  cin >> n >> m;\n  for (long long i = (0); i <= ((long long)(n)-1); i++) cin >> c[i];\n  for (long long i = (0); i <= ((long long)(m)-1); i++) {\n    res[i] = 1;\n    long long a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    c[a]--;\n    c[b]--;\n    d[a].push_back({b, i});\n    d[b].push_back({a, i});\n  }\n  dfs(0, 0);\n  for (long long i = (0); i <= ((long long)(n)-1); i++) {\n    if (0) cout << s[i] << \" \";\n  }\n  if (0) cout << \"\\n\";\n  if (c[0] != 0) {\n    (c[0]);\n    for (long long i = (0); i <= ((long long)(m)-1); i++) {\n      if (0) cout << res[i] << \" \";\n    }\n    if (0) cout << \"\\n\";\n    if (np.first == -1) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    long long zn = 1;\n    long long il = c[0] / 2;\n    if (s[np.first] % 2 == 1) {\n      zn = -1;\n    }\n    (npi);\n    res[npi] += zn * il;\n    (res[npi], npi, np);\n    for (long long ak : {np.first, np.second}) {\n      (ak, il);\n      long long x = zn * -1;\n      while (ak != 0) {\n        res[pari[ak]] += x * il;\n        ak = par[ak];\n        x *= -1;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = (0); i <= ((long long)(m)-1); i++) {\n    cout << res[i] << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000;\nint head[N], np[N << 1], p[N << 1], id[N << 1], tot;\nint n, m;\nint c[N];\nbool us[N];\nint dep[N], fa[N], vis[N];\nbool is = 0;\nint gtx, gty, gt;\nint k[N];\nlong long b[N];\nint a1[N];\nlong long a2[N];\nvoid dd2(int x) {\n  vis[x] = 1;\n  for (int u = head[x]; u; u = np[u])\n    if (p[u] ^ fa[x])\n      if (!vis[p[u]])\n        if (id[u] != gt)\n          if (us[id[u]]) {\n            fa[p[u]] = x;\n            dd2(p[u]);\n            int nk = -k[p[u]];\n            long long nb = c[p[u]] - b[p[u]];\n            a1[id[u]] = nk;\n            a2[id[u]] = nb;\n            b[x] += nb;\n            k[x] += nk;\n          }\n}\nlong long ans[N];\nlong long hav[N];\nvoid dd(int x) {\n  for (int u = head[x]; u; u = np[u])\n    if (fa[p[u]] == x) {\n      dd(p[u]);\n      ans[id[u]] = c[p[u]] - hav[p[u]];\n      hav[x] += ans[id[u]];\n    }\n}\nvoid dfs(int x) {\n  vis[x] = 1;\n  for (int u = head[x]; u; u = np[u])\n    if (p[u] ^ fa[x]) {\n      if (vis[p[u]]) {\n        if (dep[p[u]] == dep[x]) {\n          is = 1;\n          gt = id[u];\n          gtx = x;\n          gty = p[u];\n        }\n      } else {\n        us[id[u]] = 1;\n        fa[p[u]] = x;\n        dep[p[u]] = (dep[x] ^ 1);\n        dfs(p[u]);\n      }\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (int)1; i <= (int)n; i++) scanf(\"%d\", &c[i]);\n  for (int i = (int)1; i <= (int)m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ++tot;\n    p[tot] = b;\n    np[tot] = head[a];\n    head[a] = tot;\n    id[tot] = i;\n    ++tot;\n    p[tot] = a;\n    np[tot] = head[b];\n    head[b] = tot;\n    id[tot] = i;\n  }\n  dfs(1);\n  if (!is) {\n    long long s = 0;\n    for (int i = (int)1; i <= (int)n; i++)\n      if (dep[i])\n        s += c[i];\n      else\n        s -= c[i];\n    if (s != 0) {\n      puts(\"NO\");\n      return 0;\n    }\n    dd(1);\n    if (hav[1] != c[1]) {\n      puts(\"NO\");\n      return 0;\n    }\n    puts(\"YES\");\n    for (int i = (int)1; i <= (int)m; i++) printf(\"%lld\\n\", ans[i]);\n  } else {\n    memset(fa, 0, sizeof fa);\n    memset(vis, 0, sizeof vis);\n    k[gty] = 1;\n    a1[gt] = 1;\n    dd2(gtx);\n    long long x = 0;\n    x = (c[gtx] - b[gtx]) / 2;\n    puts(\"YES\");\n    for (int i = (int)1; i <= (int)m; i++) printf(\"%lld\\n\", x * a1[i] + a2[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nusing ll = long long;\nstruct Edge {\n  int v;\n  ll w;\n  int nxt;\n} e[N << 1];\nint head[N], cnt = 1;\ninline void addedge(int u, int v) {\n  e[++cnt] = (Edge){v, 0, head[u]}, head[u] = cnt;\n}\nint n, m, vis[N], dep[N], fa[N], id[N], ind;\nll c[N];\nvoid dfs(int x, int f) {\n  vis[x] = 1, fa[x] = f, dep[x] = !dep[f];\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].v != f) {\n      if (vis[e[i].v]) {\n        e[i].w = e[i ^ 1].w = 1;\n        if (dep[x] == dep[e[i].v]) ind = i;\n      } else {\n        id[e[i].v] = i;\n        dfs(e[i].v, x);\n        e[i].w = e[i ^ 1].w = c[e[i].v];\n        c[e[i].v] = 0;\n      }\n      c[x] -= e[i].w;\n    }\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", c + i);\n  for (int i = 1, a, b; i <= m; i++)\n    scanf(\"%d %d\", &a, &b), addedge(a, b), addedge(b, a);\n  dfs(1, 0);\n  if (c[1] && !ind) {\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  if (c[1]) {\n    int u = e[ind].v, v = e[ind ^ 1].v;\n    ll x = c[1] / 2;\n    for (int i = v; i != 1; i = fa[i]) {\n      if (dep[i] == dep[1])\n        e[id[i]].w -= x, e[id[i] ^ 1].w -= x;\n      else\n        e[id[i]].w += x, e[id[i] ^ 1].w += x;\n    }\n    for (int i = u; i != 1; i = fa[i]) {\n      if (dep[i] == dep[1])\n        e[id[i]].w -= x, e[id[i] ^ 1].w -= x;\n      else\n        e[id[i]].w += x, e[id[i] ^ 1].w += x;\n    }\n    if (dep[v] == dep[1])\n      e[ind].w += x, e[ind ^ 1].w += x;\n    else\n      e[ind].w -= x, e[ind ^ 1].w -= x;\n  }\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", e[i << 1].w);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool uin(T &a, T b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <class T>\nbool uax(T &a, T b) {\n  return a < b ? (a = b, true) : false;\n}\nconst int maxn = 110000;\nlong long c[maxn], rc[maxn];\nlong long ec[maxn];\nint h[maxn], vis[maxn];\npair<int, int> par[maxn];\nvector<pair<int, int> > e[maxn];\nvoid dfs(int v, int p) {\n  vis[v] = 1;\n  for (auto [u, id] : e[v]) {\n    if (u == p) continue;\n    if (vis[u]) continue;\n    h[u] = h[v] + 1;\n    par[u] = {v, id};\n    dfs(u, v);\n    long long delta = c[u] - rc[u];\n    ec[id] = delta;\n    rc[u] += delta;\n    rc[v] += delta;\n  }\n}\nvoid pathflip(int v, long long x) {\n  while (v) {\n    auto [u, id] = par[v];\n    ec[id] += x;\n    rc[v] += x;\n    rc[u] += x;\n    v = u;\n    x = -x;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.precision(10);\n  cout << fixed;\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < (int)(n); ++i) cin >> c[i];\n  for (int i = 0; i < (int)(m); ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    e[u].push_back({v, i});\n    e[v].push_back({u, i});\n  }\n  dfs(0, -1);\n  for (int v = 0; v < (int)(n); ++v)\n    for (auto [u, id] : e[v]) {\n      if (c[0] == rc[0]) break;\n      if (h[v] < h[u]) continue;\n      if (h[v] % 2 != h[u] % 2) continue;\n      long long x = (c[0] - rc[0]) / 2 * (h[u] % 2 ? -1 : 1);\n      ec[id] += x;\n      rc[v] += x;\n      rc[u] += x;\n      pathflip(v, -x);\n      pathflip(u, -x);\n    }\n  bool ok = true;\n  for (int v = 0; v < (int)(n); ++v) {\n    ok &= c[v] == rc[v];\n  }\n  if (ok) {\n    cout << \"YES\\n\";\n    for (int i = 0; i < (int)(m); ++i) cout << ec[i] << '\\n';\n  } else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ninline long long get() {\n  long long n = 0;\n  char c;\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9') break;\n    if (c == '-') goto s;\n  }\n  n = c - '0';\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      return (n);\n  }\ns:\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 - c + '0';\n    else\n      return (n);\n  }\n}\ntypedef struct _b {\n  long long dest;\n  long long nxt;\n  long long num;\n} bian;\nbian memchi[200001];\nlong long gn = 1;\nlong long heads[200001], ints[100001], anss[100001], ss[100001], ts[100001],\n    v[100001];\ninline void add(long long s, long long t, long long num) {\n  memchi[gn].dest = t;\n  memchi[gn].nxt = heads[s];\n  memchi[gn].num = num;\n  heads[s] = gn;\n  gn++;\n}\nunsigned char col[100001];\nlong long que[100001];\nunsigned char istree[100001];\nvoid print(long long num) {\n  if (num < 0) putchar('-'), num = -num;\n  if (num >= 10) print(num / 10);\n  putchar(num % 10 + '0');\n}\nlong long find(long long n) {\n  if (ints[n] == n) return (n);\n  return (ints[n] = find(ints[n]));\n}\nvoid dfs(long long pt, long long baba) {\n  for (register long long i = heads[pt]; i; i = memchi[i].nxt) {\n    if (memchi[i].dest == baba) continue;\n    dfs(memchi[i].dest, pt);\n    anss[memchi[i].num] += v[memchi[i].dest];\n    v[pt] -= v[memchi[i].dest];\n    v[memchi[i].dest] = 0;\n  }\n}\nlong long tmp[100001];\nvoid efs(long long pt, long long baba) {\n  for (register long long i = heads[pt]; i; i = memchi[i].nxt) {\n    if (memchi[i].dest == baba) continue;\n    efs(memchi[i].dest, pt);\n    tmp[pt] -= tmp[memchi[i].dest];\n  }\n}\nsigned main() {\n  long long n = get(), m = get();\n  for (register long long i = 1; i <= n; i++)\n    v[i] = get(), ints[i] = i, col[i] = 2;\n  for (register long long i = 1; i <= m; i++) {\n    ss[i] = get(), ts[i] = get();\n    long long aa = find(ss[i]), ab = find(ts[i]);\n    if (aa != ab) {\n      ints[aa] = ab;\n      add(ss[i], ts[i], i);\n      add(ts[i], ss[i], i);\n      istree[i] = 1;\n    }\n  }\n  register long long head = 0, tail = 1;\n  que[0] = 1;\n  col[1] = 0;\n  do {\n    long long me = que[head];\n    head++;\n    for (register long long i = heads[me]; i; i = memchi[i].nxt) {\n      if (col[memchi[i].dest] != 2) continue;\n      col[memchi[i].dest] = col[me] ^ 1;\n      que[tail] = memchi[i].dest;\n      tail++;\n    }\n  } while (head < tail);\n  dfs(1, 0);\n  if (((v[1] < 0) ? -(v[1]) : v[1]) & 1) {\n    printf(\"NO\\n\");\n    return (0);\n  }\n  if (v[1] == 0) {\n    printf(\"YES\\n\");\n    for (register long long i = 1; i <= m; i++) print(anss[i]), putchar('\\n');\n    return (0);\n  }\n  for (register long long a = 1; a <= m; a++) {\n    if (istree[a]) continue;\n    if (col[ss[a]] != col[ts[a]]) continue;\n    printf(\"YES\\n\");\n    long long val = v[1] / 2;\n    tmp[ss[a]]++;\n    tmp[ts[a]]++;\n    efs(1, 0);\n    if (tmp[1] == 2) {\n      v[ss[a]] -= val;\n      v[ts[a]] -= val;\n      anss[a] = val;\n    } else {\n      v[ss[a]] += val;\n      v[ts[a]] += val;\n      anss[a] = -val;\n    }\n    dfs(1, 0);\n    for (register long long i = 1; i <= m; i++) print(anss[i]), putchar('\\n');\n    return (0);\n  }\n  printf(\"NO\\n\");\n  return (0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 10;\nconst int M = N;\nlong long c[N];\nint vis[N];\nvector<int> adj[N], radj[N];\nstruct node {\n  int u, v;\n  node(int u = 0, int v = 0) : u(u), v(v) { makegood(); }\n  void makegood() {\n    if (u > v) swap(u, v);\n  }\n  bool operator<(const node &rhs) const {\n    if (u != rhs.u) return u < rhs.u;\n    return v < rhs.v;\n  }\n} E[M];\nint fu = -1, fv = -1;\nmap<node, long long> Ans;\nint indeg[N];\nvoid dfs(int u, int p, int flg) {\n  vis[u] = flg + 1;\n  for (auto v : adj[u]) {\n    if (!vis[v]) {\n      dfs(v, u, !flg);\n      radj[v].push_back(u);\n      ++indeg[u];\n    } else if (vis[v] == vis[u])\n      fu = u, fv = v;\n  }\n}\nlong long sum[3];\nint q[N], qh, qt;\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    E[i] = node(u, v);\n  }\n  dfs(1, -1, 0);\n  for (int i = 1; i <= n; i++) {\n    assert(vis[i]);\n    sum[vis[i]] += c[i];\n  }\n  if (fu == -1 && sum[1] != sum[2]) {\n    puts(\"NO\");\n    return 0;\n  }\n  long long R = sum[2];\n  if (fu != -1) {\n    long long S = sum[1] - sum[2];\n    if (vis[fu] == 2) S = -S, R = sum[1];\n    assert(S % 2 == 0);\n    Ans[node(fu, fv)] = S / 2;\n    c[fu] -= S / 2, c[fv] -= S / 2;\n  }\n  memset(vis, 0, sizeof vis);\n  for (int i = 1; i <= n; i++)\n    if (!indeg[i]) q[qt++] = i;\n  while (qh < qt) {\n    int u = q[qh++];\n    for (auto v : radj[u]) {\n      c[v] -= c[u];\n      Ans[node(u, v)] = c[u];\n      if (--indeg[v] == 0) q[qt++] = v;\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", Ans[E[i]]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 17;\nint n, m;\nvector<int> e[N];\nint c[N];\nint u1[N], u2[N];\nint col[N];\nlong long ans[N];\nlong long a[N];\nvoid dfs1(int v, int pr) {\n  col[v] = 1;\n  a[v] = 0;\n  for (int id : e[v]) {\n    if (id == pr) continue;\n    int to = u1[id] ^ u2[id] ^ v;\n    if (col[to] == 0) {\n      dfs1(to, id);\n      ans[id] = c[to] - a[to];\n      a[to] += ans[id];\n      a[v] += ans[id];\n    } else if (col[to] == 1) {\n      ans[id] = 0;\n    } else {\n      continue;\n    }\n  }\n  col[v] = 2;\n}\nvector<int> cycle;\nint col2[N];\nint part[N];\nvector<int> st;\nvoid dfs2(int v, int pr, int cc) {\n  col2[v] = 1;\n  a[v] = 0;\n  part[v] = cc;\n  st.push_back(pr);\n  for (int id : e[v]) {\n    if (id == pr) continue;\n    int to = u1[id] ^ u2[id] ^ v;\n    if (col2[to] == 0) {\n      dfs2(to, id, cc ^ 1);\n    } else if (col2[to] == 1) {\n      if (part[v] == part[to] && cycle.empty()) {\n        cycle.push_back(id);\n        for (int i = (int)st.size() - 1;; i--) {\n          if (st[i] == -1) break;\n          cycle.push_back(st[i]);\n          if (u1[st[i]] == to || u2[st[i]] == to) break;\n        }\n      }\n    } else {\n      continue;\n    }\n  }\n  st.pop_back();\n  col2[v] = 2;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &m) == 2) {\n    for (int i = 0; i < n; i++) {\n      e[i].clear();\n    }\n    for (int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n    for (int i = 0; i < m; i++) {\n      scanf(\"%d%d\", &u1[i], &u2[i]);\n      u1[i]--;\n      u2[i]--;\n      e[u1[i]].push_back(i);\n      e[u2[i]].push_back(i);\n    }\n    for (int i = 0; i < n; i++) {\n      col[i] = 0;\n      col2[i] = 0;\n      part[i] = -1;\n    }\n    bool ok = 1;\n    for (int i = 0; i < n; i++) {\n      if (col[i] != 0) continue;\n      assert(i == 0);\n      cycle.clear();\n      dfs2(i, -1, 0);\n      int v = i;\n      if (!cycle.empty()) {\n        v = u1[cycle[0]];\n        assert(cycle.size() % 2 == 1);\n        int iid = cycle.back();\n        if (!(u1[iid] == v || u2[iid] == v)) {\n          rotate(cycle.begin(), cycle.begin() + 1, cycle.end());\n        }\n      }\n      dfs1(v, -1);\n      if (a[v] != c[v]) {\n        if (cycle.empty()) {\n          ok = 0;\n        } else {\n          assert((a[v] - c[v]) % 2 == 0);\n          long long o = (c[v] - a[v]) / 2;\n          int iid = cycle.back();\n          bool f = u1[iid] == v || u2[iid] == v;\n          for (int j = 0; j < (int)cycle.size(); j++) {\n            ans[cycle[j]] += o * ((j % 2) ? -1 : 1);\n          }\n        }\n      }\n    }\n    if (ok) {\n      vector<long long> d(n);\n      for (int i = 0; i < m; i++) {\n        d[u1[i]] += ans[i];\n        d[u2[i]] += ans[i];\n      }\n      for (int i = 0; i < n; i++) {\n        assert(d[i] == c[i]);\n      }\n      printf(\"YES\\n\");\n      for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n    } else {\n      printf(\"NO\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long Maxn = 100010;\nconst long long inf = 2147483647;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n  return x * f;\n}\nlong long n, m, t, a[Maxn], dep[Maxn];\nbool vis[Maxn], mark[Maxn << 1];\nstruct Edge {\n  long long x, y, d, next;\n} e[Maxn << 1];\nlong long last[Maxn], len = 1;\nvoid ins(long long x, long long y) {\n  long long t = ++len;\n  e[t].x = x;\n  e[t].y = y;\n  e[t].next = last[x];\n  last[x] = t;\n}\nvoid dfs(long long x, long long fa, long long id) {\n  dep[x] = dep[fa] + 1;\n  vis[x] = true;\n  long long s = 0;\n  for (long long i = last[x]; i; i = e[i].next) {\n    long long y = e[i].y;\n    if (vis[y]) continue;\n    mark[i] = mark[i ^ 1] = true;\n    dfs(y, x, i);\n    s += e[i].d;\n  }\n  if (id)\n    e[id].d = e[id ^ 1].d = a[x] - s;\n  else\n    t = s;\n}\nvoid DFS(long long x, long long id) {\n  vis[x] = true;\n  long long s = 0;\n  for (long long i = last[x]; i; i = e[i].next) {\n    long long y = e[i].y;\n    if (vis[y]) {\n      if (i != (id ^ 1)) s += e[i].d;\n      continue;\n    }\n    DFS(y, i);\n    s += e[i].d;\n  }\n  if (id) e[id].d = e[id ^ 1].d = a[x] - s;\n}\nint main() {\n  n = read(), m = read();\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  for (long long i = 1; i <= m; i++) {\n    long long x = read(), y = read();\n    ins(x, y), ins(y, x);\n  }\n  dep[0] = -1;\n  dfs(1, 0, 0);\n  long long cnt = 0;\n  for (long long i = 2; i <= len; i += 2)\n    if (mark[i])\n      continue;\n    else if (!(abs(dep[e[i].x] - dep[e[i].y]) & 1)) {\n      cnt++;\n      break;\n    }\n  if (abs(t - a[1]) % 2) return puts(\"NO\"), 0;\n  if (!cnt && a[1] != t) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  if (a[1] == t) {\n    for (long long i = 2; i <= len; i += 2) {\n      if (mark[i])\n        printf(\"%lld\\n\", e[i].d);\n      else\n        puts(\"0\");\n    }\n    return 0;\n  }\n  for (long long i = 2; i <= len; i += 2)\n    if (!(abs(dep[e[i].x] - dep[e[i].y]) & 1)) {\n      long long x = e[i].x, y = e[i].y;\n      if (a[1] > t) {\n        if (dep[x] > dep[y]) swap(x, y);\n        if (dep[x] & 1)\n          e[i].d = e[i ^ 1].d = -abs(t - a[1]) / 2;\n        else\n          e[i].d = e[i ^ 1].d = abs(t - a[1]) / 2;\n      } else {\n        if (dep[x] > dep[y]) swap(x, y);\n        if (dep[x] & 1)\n          e[i].d = e[i ^ 1].d = abs(t - a[1]) / 2;\n        else\n          e[i].d = e[i ^ 1].d = -abs(t - a[1]) / 2;\n      }\n      break;\n    }\n  memset(vis, false, sizeof(vis));\n  DFS(1, 0);\n  for (long long i = 2; i <= len; i += 2) printf(\"%lld\\n\", e[i].d);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000;\nlong long ans[N];\nint dp[N], a[N], b[N], vis[N], par[N];\nlong long c[N], sum[2];\nvector<int> adj[N];\nvoid dfs(int u, int d) {\n  dp[u] = d, vis[u] = 1;\n  for (int e : adj[u]) {\n    int v = a[e] + b[e] - u;\n    if (vis[v]) continue;\n    par[v] = u;\n    dfs(v, d + 1);\n  }\n}\nvoid solve(int u) {\n  for (int e : adj[u]) {\n    int v = a[e] + b[e] - u;\n    if (par[v] == u) {\n      solve(v);\n      ans[e] = c[v];\n      c[u] -= ans[e];\n    }\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    adj[u].push_back(i);\n    adj[v].push_back(i);\n    a[i] = u, b[i] = v;\n  }\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) sum[dp[i] & 1] += c[i];\n  if (sum[0] != sum[1]) {\n    int flg = 0;\n    for (int i = 1; i <= m; i++) {\n      int u = a[i], v = b[i];\n      if (dp[u] + dp[v] + 1 & 1) {\n        flg = 1;\n        ans[i] = (sum[dp[u] & 1] - sum[dp[u] + 1 & 1]) / 2;\n        c[u] -= ans[i], c[v] -= ans[i];\n        break;\n      }\n    }\n    if (!flg) return puts(\"NO\"), 0;\n  }\n  solve(1);\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100009;\nstruct E {\n  int u, v;\n  long long val;\n} edges[maxn];\nvector<int> neigh[maxn];\nlong long val[maxn];\nint be = -1;\nint depth[maxn];\nlong long cur_val[maxn];\nvoid dfs(int v, int p) {\n  int bck;\n  for (int i : neigh[v]) {\n    int u = (edges[i].v == v ? edges[i].u : edges[i].v);\n    if (u == p) {\n      bck = i;\n    } else if (depth[u] == -1) {\n      depth[u] = depth[v] + 1;\n      dfs(u, v);\n    } else if (depth[u] < depth[v]) {\n      if ((depth[u] + depth[v]) % 2 == 0) {\n        be = i;\n      }\n    }\n  }\n  if (v != 1) {\n    edges[bck].val = cur_val[v];\n    cur_val[p] -= cur_val[v];\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> val[i];\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    edges[i].u = u;\n    edges[i].v = v;\n    neigh[u].push_back(i);\n    neigh[v].push_back(i);\n  }\n  memset(depth, -1, sizeof depth);\n  memcpy(cur_val, val, sizeof val);\n  depth[1] = 0;\n  dfs(1, 0);\n  if (cur_val[1] != 0) {\n    if (be == -1 || cur_val[1] % 2 != 0) {\n      cout << \"NO\";\n      return 0;\n    }\n    for (int i = 0; i < m; i++) edges[i].val = 0;\n    if (depth[edges[be].u] % 2 == 0)\n      edges[be].val = cur_val[1] / 2;\n    else\n      edges[be].val = -cur_val[1] / 2;\n    val[edges[be].u] -= edges[be].val;\n    val[edges[be].v] -= edges[be].val;\n    memset(depth, -1, sizeof depth);\n    memcpy(cur_val, val, sizeof val);\n    depth[1] = 0;\n    dfs(1, 0);\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) cout << edges[i].val << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = (long long)1e6 + 3;\nconst long long infint = (long long)1e9 + 3;\nconst long long MOD = (long long)1e9 + 7;\nconst long long inf = (long long)1e18 + 3;\nlong long n, m, c[MAXN], par[MAXN], visited[MAXN], h[MAXN], edge_1[MAXN],\n    edge_2[MAXN];\nmap<pair<long long, long long>, long long> M;\nvector<long long> G[MAXN];\nvoid bfs(long long u) {\n  queue<long long> q;\n  q.push(u);\n  visited[u] = 1;\n  while (!q.empty()) {\n    long long st = q.front();\n    q.pop();\n    for (auto v : G[st])\n      if (!visited[v]) par[v] = st, visited[v] = 1, h[v] = h[st] + 1, q.push(v);\n  }\n}\nlong long dfs(long long u) {\n  long long ans = 0;\n  for (auto v : G[u])\n    if (!visited[v]) visited[v] = 1, M[{u, v}] = dfs(v), ans += M[{u, v}];\n  return c[u] - ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) cin >> c[i];\n  for (long long i = 0; i < m; i++) {\n    long long u, v;\n    cin >> u >> v;\n    edge_1[i] = u, edge_2[i] = v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bfs(1);\n  long long a = -1, b = -1;\n  for (long long i = 1; i <= n; i++)\n    for (auto u : G[i])\n      if (h[i] == h[u]) a = i, b = u;\n  if (a != -1) {\n    vector<long long> cyc;\n    long long lca = -1, tmp_a = a, tmp_b = b;\n    while (a != b) {\n      if (h[a] > h[b])\n        a = par[a];\n      else\n        b = par[b];\n    }\n    lca = a;\n    a = tmp_a, b = tmp_b;\n    while (a != lca) {\n      cyc.push_back(a);\n      a = par[a];\n    }\n    vector<long long> sec;\n    while (b != lca) {\n      sec.push_back(b);\n      b = par[b];\n    }\n    reverse(sec.begin(), sec.end());\n    cyc.push_back(lca);\n    for (auto u : sec) cyc.push_back(u);\n    memset(visited, 0, sizeof visited);\n    for (auto u : cyc) visited[u] = 1;\n    for (auto u : cyc) c[u] = dfs(u);\n    long long ans = 0;\n    for (long long i = 0; i < (long long)cyc.size(); i++)\n      if (i <= 1)\n        ans += c[cyc[i]];\n      else if (i % 2 == 0)\n        ans -= c[cyc[i]];\n      else\n        ans += c[cyc[i]];\n    M[{cyc[0], cyc[1]}] = ans / 2;\n    for (long long i = 1; i < (long long)cyc.size(); i++)\n      ans = ans * -1 + 2 * c[cyc[i]],\n      M[{cyc[i], cyc[(i + 1) % (long long)cyc.size()]}] = ans / 2;\n    cout << \"YES\\n\";\n    for (long long i = 0; i < m; i++)\n      cout << M[{edge_1[i], edge_2[i]}] + M[{edge_2[i], edge_1[i]}] << \"\\n\";\n    return 0;\n  }\n  memset(visited, 0, sizeof visited);\n  visited[1] = 1;\n  long long x = dfs(1);\n  if (x) return cout << \"NO\", 0;\n  cout << \"YES\\n\";\n  for (long long i = 0; i < m; i++)\n    cout << M[{edge_1[i], edge_2[i]}] + M[{edge_2[i], edge_1[i]}] << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long c[100010];\nvector<int> g[100010];\nint to[100010 << 1];\nlong long w[100010];\nlong long s[2];\nint col[100010];\nint sp[2];\nvoid dfs(int u, int pa) {\n  s[col[u]] += c[u];\n  for (int i : g[u]) {\n    int v = to[i];\n    if (v == pa) continue;\n    if (col[v] >= 0) {\n      if (col[u] == col[v]) sp[col[u]] = i % m;\n    } else {\n      col[v] = 1 ^ col[u];\n      dfs(v, u);\n    }\n  }\n}\nvoid give_value(int u, int pa = 0) {\n  col[u] = 1;\n  for (int i : g[u]) {\n    int v = to[i];\n    if (col[v]) continue;\n    give_value(v, u);\n    w[i % m] = c[v];\n    c[u] -= c[v];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &c[i]);\n  for (int i = 0, u, v; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    to[i] = v;\n    g[u].push_back(i);\n    to[i + m] = u;\n    g[v].push_back(i + m);\n  }\n  for (int i = 1; i <= n; i++) col[i] = -1;\n  col[1] = 0;\n  sp[0] = sp[1] = -1;\n  dfs(1, 0);\n  if (sp[0] >= 0) {\n    w[sp[0]] = (s[0] - s[1]) / 2;\n    c[to[sp[0]]] -= w[sp[0]];\n    c[to[sp[0] + m]] -= w[sp[0]];\n    s[0] -= 2 * w[sp[0]];\n  } else if (sp[1] >= 0) {\n    w[sp[1]] = (s[1] - s[0]) / 2;\n    c[to[sp[1]]] -= w[sp[1]];\n    c[to[sp[1] + m]] -= w[sp[1]];\n    s[1] -= 2 * w[sp[1]];\n  }\n  if (s[0] != s[1])\n    puts(\"NO\");\n  else {\n    memset(col, 0, sizeof col);\n    give_value(1);\n    assert(c[1] == 0);\n    puts(\"YES\");\n    for (int i = 0; i < m; i++) printf(\"%I64d\\n\", w[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5;\nint n, m, head[N], cnt, dep[N], fa[N], pid[N];\nlong long c[N], val[N];\nbool vis[N], use[N];\nstruct edge {\n  int to, nxt, id;\n} e[N << 1];\nvoid finish() {\n  cout << \"YES\\n\";\n  for (int i = 1; i <= m; ++i) cout << val[i] << '\\n';\n  exit(0);\n}\nvoid dfs(int u) {\n  vis[u] = 1;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (!vis[e[i].to]) {\n      fa[e[i].to] = u;\n      dep[e[i].to] = dep[u] + 1;\n      pid[e[i].to] = e[i].id;\n      use[e[i].id] = 1;\n      dfs(e[i].to);\n    }\n  if (u != 1) {\n    val[pid[u]] = c[u];\n    c[fa[u]] -= c[u];\n    c[u] = 0;\n  }\n}\nvoid dfs2(int u) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (!use[e[i].id] && (dep[e[i].to] - dep[u]) % 2 == 0) {\n      assert(dep[e[i].to] > dep[u]);\n      int fh = dep[u] % 2;\n      long long dlt = c[1] / 2;\n      if (fh == 1) dlt *= -1;\n      val[e[i].id] = dlt;\n      c[u] -= dlt, c[e[i].to] -= dlt;\n      for (int v = e[i].to; v != 1; v = fa[v]) {\n        val[pid[v]] += c[v];\n        c[fa[v]] -= c[v];\n        c[v] = 0;\n      }\n      assert(!c[1]);\n      finish();\n    }\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (use[e[i].id] && dep[e[i].to] > dep[u]) dfs2(e[i].to);\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> c[i];\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    e[++cnt] = (edge){v, head[u], i}, head[u] = cnt;\n    e[++cnt] = (edge){u, head[v], i}, head[v] = cnt;\n  }\n  dfs(1);\n  if (c[1] % 2 == 0) {\n    if (c[1])\n      dfs2(1);\n    else\n      finish();\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nstruct Edge {\n  int a, b;\n  int id;\n  void read(int i) {\n    id = i;\n    scanf(\"%d%d\", &a, &b);\n    --a;\n    --b;\n  }\n  int to(int v) const {\n    assert(v == a || v == b);\n    return (a ^ b) ^ v;\n  }\n};\nint n, m;\nvector<int> c;\nvector<Edge> g[MAXN];\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < int(n); ++i) {\n    g[i].clear();\n  }\n  c.resize(n);\n  for (int i = 0; i < int(n); ++i) {\n    scanf(\"%d\", &c[i]);\n  }\n  for (int i = 0; i < int(m); ++i) {\n    Edge e;\n    e.read(i);\n    g[e.a].push_back(e);\n    g[e.b].push_back(e);\n  }\n  return 1;\n}\nvector<int> in_tree;\nvoid dfs0(int v, int p, vector<int>& was, vector<int>& depth, int& root) {\n  assert(!was[v]);\n  was[v] = 1;\n  for (const auto& e : g[v]) {\n    const int to = e.to(v);\n    if (to == p) {\n      continue;\n    }\n    if (was[to]) {\n      const int dist = abs(depth[v] - depth[to]);\n      if (dist % 2 == 0) {\n        root = v;\n      }\n      continue;\n    }\n    in_tree[e.id] = 1;\n    depth[to] = depth[v] + 1;\n    dfs0(to, v, was, depth, root);\n  }\n}\nint getRoot() {\n  vector<int> was(n, 0);\n  vector<int> depth(n, 0);\n  int root = -1;\n  dfs0(0, -1, was, depth, root);\n  return root;\n}\nvoid dfs1(int v, int p, vector<int>& was, vector<long long>& w,\n          vector<Edge>& par, vector<int>& depth) {\n  assert(!was[v]);\n  was[v] = 1;\n  long long sum = 0;\n  for (const auto& e : g[v]) {\n    const int to = e.to(v);\n    if (to == p) {\n      continue;\n    }\n    if (was[to]) {\n      continue;\n    }\n    par[to] = e;\n    depth[to] = depth[v] + 1;\n    dfs1(to, v, was, w, par, depth);\n    sum += w[e.id];\n  }\n  if (par[v].id == -1) {\n    assert(p == -1);\n    assert(depth[v] == 0);\n    const long long diff = c[v] - sum;\n    assert(diff % 2 == 0);\n    const long long need = diff / 2;\n    for (const auto& e : g[v]) {\n      const int to = e.to(v);\n      const int dist = depth[to];\n      assert(dist > 0);\n      if (dist % 2 == 1) {\n        continue;\n      }\n      w[e.id] = need;\n      int u = to;\n      int parity = 1;\n      while (u != v) {\n        w[par[u].id] += (parity ? -1 : +1) * need;\n        parity ^= 1;\n        u = par[u].to(u);\n      }\n      assert(parity == 1);\n      {\n        for (int u = 0; u < int(n); ++u) {\n          long long sum = 0;\n          for (const auto& e : g[u]) {\n            sum += w[e.id];\n          }\n          assert(sum == c[u]);\n        }\n      }\n      break;\n    }\n  } else {\n    w[par[v].id] = c[v] - sum;\n  }\n}\nbool solve() {\n  in_tree.assign(m, 0);\n  int root = getRoot();\n  for (int v = 0; v < int(n); ++v) {\n    sort(begin(g[v]), end(g[v]), [&](const Edge& e1, const Edge& e2) {\n      return in_tree[e1.id] > in_tree[e2.id];\n    });\n  }\n  bool must_ok = 1;\n  if (root == -1) {\n    must_ok = 0;\n    root = 0;\n  }\n  vector<int> was(n, 0);\n  vector<long long> w(m, 0);\n  vector<Edge> par(n, Edge{-1, -1, -1});\n  vector<int> depth(n, 0);\n  dfs1(root, -1, was, w, par, depth);\n  for (int v = 0; v < int(n); ++v) {\n    long long sum = 0;\n    for (const auto& e : g[v]) {\n      sum += w[e.id];\n    }\n    if (sum != c[v]) {\n      assert(!must_ok);\n      return 0;\n    }\n  }\n  puts(\"YES\");\n  for (int i = 0; i < int(m); ++i) {\n    printf(\"%lld\\n\", w[i]);\n  }\n  printf(\"\\n\");\n  return 1;\n}\nint main() {\n  while (read()) {\n    if (!solve()) {\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = -1;\nconst int INF = 1.01e9;\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  vector<long long> c(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &c[i]);\n  }\n  vector<vector<pair<int, int>>> e(n);\n  for (int i = 0; i < m; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    e[v].push_back({u, i});\n    e[u].push_back({v, i});\n  }\n  vector<int> odd;\n  vector<int> color(n, -1);\n  int V = -1;\n  vector<pair<int, int>> st;\n  function<void(int, int, int)> dfs0 = [&](int v, int eid, int cc) {\n    st.push_back({v, eid});\n    color[v] = cc;\n    for (auto x : e[v]) {\n      int u = x.first;\n      if (color[u] == -1) {\n        dfs0(u, x.second, cc ^ 1);\n        if (!odd.empty()) return;\n      } else {\n        if (color[u] != (cc ^ 1)) {\n          odd.push_back(x.second);\n          for (int j = st.size() - 1; st[j].first != u; j--) {\n            odd.push_back(st[j].second);\n          }\n          V = u;\n          return;\n        }\n      }\n    }\n    st.pop_back();\n  };\n  dfs0(0, -1, 0);\n  vector<long long> answer(m);\n  vector<int> used(n);\n  function<void(int)> dfs1 = [&](int v) {\n    used[v] = 1;\n    for (auto x : e[v]) {\n      int u = x.first;\n      if (!used[u]) {\n        dfs1(u);\n        long long y = c[u];\n        c[v] -= y;\n        c[u] -= y;\n        answer[x.second] += y;\n      }\n    }\n  };\n  if (V == -1) {\n    V = 0;\n  }\n  dfs1(V);\n  if (c[V] != 0) {\n    if (odd.empty()) {\n      puts(\"NO\");\n      return 0;\n    }\n    assert(c[V] % 2 == 0);\n    assert(odd.size() % 2 == 1);\n    long long add = c[V] / 2;\n    for (int i = 0; i < (int)odd.size(); i++) {\n      if (i % 2 == 1) {\n        answer[odd[i]] -= add;\n      } else {\n        answer[odd[i]] += add;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (auto x : answer) {\n    printf(\"%lld\\n\", x);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100009;\nstruct E {\n  int u, v;\n  long long val;\n} edges[maxn];\nvector<int> neigh[maxn];\nint depth[maxn];\nint help = -1;\nlong long val[maxn];\nlong long cur_val[maxn];\nvoid dfs(int v, int p) {\n  int bck = -1;\n  for (int i : neigh[v]) {\n    int u = (edges[i].v == v ? edges[i].u : edges[i].v);\n    if (u == p) {\n      bck = i;\n      continue;\n    }\n    if (depth[u] == -1) {\n      depth[u] = depth[v] + 1;\n      dfs(u, v);\n    } else if (depth[u] < depth[v]) {\n      if ((depth[v] - depth[u]) % 2 == 0 && help == -1) help = i;\n    }\n  }\n  if (v != 1) {\n    edges[bck].val = cur_val[v];\n    cur_val[p] -= cur_val[v];\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  for (int v = 1; v <= n; v++) cin >> val[v];\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    edges[i].u = u;\n    edges[i].v = v;\n    neigh[u].push_back(i);\n    neigh[v].push_back(i);\n  }\n  memcpy(cur_val, val, sizeof val);\n  memset(depth, -1, sizeof depth);\n  depth[1] = 0;\n  dfs(1, 0);\n  if (cur_val[1] != 0) {\n    if (help == -1 || cur_val[1] % 2 != 0) {\n      cout << \"NO\";\n      return 0;\n    }\n    for (int i = 0; i < m; i++) edges[i].val = 0;\n    edges[help].val = cur_val[1] / 2;\n    if (depth[edges[help].u] % 2 == 1) edges[help].val = -cur_val[1] / 2;\n    val[edges[help].u] -= edges[help].val;\n    val[edges[help].v] -= edges[help].val;\n    memcpy(cur_val, val, sizeof val);\n    memset(depth, -1, sizeof depth);\n    depth[1] = 0;\n    dfs(1, 0);\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) {\n    cout << edges[i].val << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing INT = long long;\nusing VI = vector<int>;\nusing pii = pair<int, int>;\ntemplate <typename A, typename B>\ninline void smin(A &a, const B &b) {\n  if (a > b) a = b;\n}\ntemplate <typename A, typename B>\ninline void smax(A &a, const B &b) {\n  if (a < b) a = b;\n}\nINT w[100100];\nint val[100100], flag[100100], m, n;\nvector<pii> adj[100100];\nvector<int> cycle, tmp[100100];\nint U, V;\nint dfs(int u, int fa = 0) {\n  flag[u] = flag[fa] ^ 1;\n  for (auto p : adj[u]) {\n    int v = p.first;\n    if (v == fa) continue;\n    if (~flag[v]) {\n      if (flag[u] == flag[v]) {\n        U = u, V = v;\n        return 1;\n      }\n      continue;\n    }\n    tmp[u].push_back(v);\n    tmp[v].push_back(u);\n    if (flag[v] == -1) {\n      if (dfs(v, u)) return 1;\n    }\n  }\n  return 0;\n}\nint vst[100100];\nmap<pii, int> mp;\nINT DFS(int u) {\n  vst[u] = 1;\n  INT tmp = 0;\n  for (auto p : adj[u]) {\n    int v = p.first, id = p.second;\n    if (vst[v]) continue;\n    w[id] = val[v] - DFS(v);\n    tmp += w[id];\n  }\n  return tmp;\n}\nint rdfs(int u, int fa = 0) {\n  for (int v : tmp[u]) {\n    if (v == fa) continue;\n    if (v == V) {\n      cycle.push_back(mp[pii(u, v)]);\n      return 1;\n    }\n    if (rdfs(v, u)) {\n      cycle.push_back(mp[pii(u, v)]);\n      return 1;\n    }\n  }\n  return 0;\n}\nvoid odd_solve() {\n  rdfs(U);\n  memset(vst, 0, sizeof vst);\n  INT first = val[U] - DFS(U);\n  if (first & 1) {\n    puts(\"NO\");\n    exit(0);\n  }\n  first /= 2;\n  for (int i = 0; i < cycle.size(); i++) {\n    if (i & 1)\n      w[cycle[i]] += first;\n    else\n      w[cycle[i]] -= first;\n  }\n  w[mp[pii(U, V)]] += first;\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", w[i]);\n  exit(0);\n}\nvoid solve() {\n  if (val[1] != DFS(1)) {\n    puts(\"NO\");\n    exit(0);\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", w[i]);\n  exit(0);\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &val[i]);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(pii(v, i));\n    adj[v].push_back(pii(u, i));\n    mp[pii(u, v)] = i;\n    mp[pii(v, u)] = i;\n  }\n  memset(flag, -1, sizeof flag);\n  flag[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (~flag[i]) continue;\n    if (dfs(i)) odd_solve();\n  }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nint ed[N][2];\nint n, m;\nvector<int> g[N];\nlong long c[N];\nint col[N];\nint par[N];\nlong long ans[N];\nvector<int> cycle;\nint getOther(int id, int v) { return v ^ ed[id][0] ^ ed[id][1]; }\nint dfs1(int v) {\n  for (int id : g[v]) {\n    int u = getOther(id, v);\n    if (col[u] != -1) {\n      if (col[v] == col[u]) {\n        cycle.push_back(id);\n        int w = v;\n        while (w != u) {\n          cycle.push_back(par[w]);\n          w = getOther(par[w], w);\n        }\n        return u;\n      }\n      continue;\n    }\n    col[u] = col[v] ^ 1;\n    par[u] = id;\n    int w = dfs1(u);\n    if (w != -1) return w;\n  }\n  return -1;\n}\nvoid dfs2(int v) {\n  for (int id : g[v]) {\n    int u = getOther(id, v);\n    if (par[u] != -1) continue;\n    par[u] = id;\n    dfs2(u);\n    ans[id] += c[u];\n    c[v] -= c[u];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &c[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &ed[i][0], &ed[i][1]);\n    ed[i][0]--;\n    ed[i][1]--;\n    g[ed[i][0]].push_back(i);\n    g[ed[i][1]].push_back(i);\n  }\n  for (int i = 0; i < n; i++) col[i] = -1;\n  col[0] = 0;\n  int V = dfs1(0);\n  for (int i = 0; i < n; i++) par[i] = -1;\n  if (V == -1) {\n    par[0] = -2;\n    dfs2(0);\n  } else {\n    par[V] = -2;\n    dfs2(V);\n  }\n  if (V == -1 && c[0] != 0) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  if (V == -1) V = 0;\n  for (int i = 0; i < (int)cycle.size(); i++) {\n    if (i & 1)\n      ans[cycle[i]] -= c[V] / 2;\n    else\n      ans[cycle[i]] += c[V] / 2;\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, m;\nint d[N];\nlong long a[N], w[N];\nbool vis[N];\nvector<pair<int, int> > G[N];\nint fap[N], fae[N];\nvoid dfs(int p, int fa, int fe) {\n  fap[p] = fa, fae[p] = fe;\n  vis[p] = true;\n  for (auto par : G[p]) {\n    int e = par.first;\n    int id = par.second;\n    if (!vis[e]) {\n      dfs(e, p, id);\n    }\n  }\n  if (fe) {\n    w[fe] = a[p];\n    a[p] -= w[fe];\n    a[fa] -= w[fe];\n  }\n}\nint bt, tp;\nvoid find_cir(int p, int fa) {\n  d[p] = d[fa] ^ 1;\n  vis[p] = true;\n  for (auto par : G[p]) {\n    int e = par.first;\n    int id = par.second;\n    if (!vis[e]) {\n      find_cir(e, p);\n    } else if (d[e] == d[p]) {\n      bt = p, tp = e;\n      throw id;\n    }\n  }\n}\nvoid putans() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) {\n    printf(\"%lld\\n\", w[i]);\n  }\n  exit(0);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", a + i);\n  }\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    G[u].emplace_back(v, i);\n    G[v].emplace_back(u, i);\n  }\n  dfs(1, 0, 0);\n  if (!a[1]) putans();\n  memset(vis, 0, sizeof(vis));\n  try {\n    find_cir(1, 0);\n  } catch (int id) {\n    assert(!(a[1] & 1));\n    long long dlt = a[1] >> 1;\n    if (!d[tp]) dlt = -dlt;\n    w[id] += dlt;\n    for (int p = bt; p ^ tp; p = fap[p]) w[fae[p]] += (dlt = -dlt);\n    dlt <<= 1;\n    for (int p = tp; p; p = fap[p]) w[fae[p]] += (dlt = -dlt);\n    putans();\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void gmin(T &x, const T &y) {\n  if (x > y) x = y;\n}\ntemplate <class T>\ninline void gmax(T &x, const T &y) {\n  if (x < y) x = y;\n}\nconst int BufferSize = 1 << 16;\nchar buffer[BufferSize], *Bufferhead, *Buffertail;\nbool Terminal;\ninline char Getchar() {\n  if (Bufferhead == Buffertail) {\n    int l = fread(buffer, 1, BufferSize, stdin);\n    if (!l) {\n      Terminal = 1;\n      return 0;\n    }\n    Buffertail = (Bufferhead = buffer) + l;\n  }\n  return *Bufferhead++;\n}\ntemplate <class T>\ninline bool read(T &x) {\n  x = 0;\n  char c = Getchar(), rev = 0;\n  while (c < '0' || c > '9') {\n    rev |= c == '-';\n    c = Getchar();\n    if (Terminal) return 0;\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = Getchar();\n  if (c == '.') {\n    c = Getchar();\n    double t = 0.1;\n    while (c >= '0' && c <= '9')\n      x = x + (c - '0') * t, c = Getchar(), t = t / 10;\n  }\n  x = rev ? -x : x;\n  return 1;\n}\ntemplate <class T1, class T2>\ninline bool read(T1 &x, T2 &y) {\n  return read(x) & read(y);\n}\ntemplate <class T1, class T2, class T3>\ninline bool read(T1 &x, T2 &y, T3 &z) {\n  return read(x) & read(y) & read(z);\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline bool read(T1 &x, T2 &y, T3 &z, T4 &w) {\n  return read(x) & read(y) & read(z) & read(w);\n}\ninline bool reads(char *x) {\n  char c = Getchar();\n  while (c < 33 || c > 126) {\n    c = Getchar();\n    if (Terminal) return 0;\n  }\n  while (c >= 33 && c <= 126) (*x++) = c, c = Getchar();\n  *x = 0;\n  return 1;\n}\ntemplate <class T>\ninline void print(T x, const char c = '\\n') {\n  if (!x) {\n    putchar('0');\n    putchar(c);\n    return;\n  }\n  if (x < 0) putchar('-'), x = -x;\n  int m = 0, a[20];\n  while (x) a[m++] = x % 10, x /= 10;\n  while (m--) putchar(a[m] + '0');\n  putchar(c);\n}\nconst int inf = 0x3f3f3f3f;\nconst int N = 200005, M = 100005, mod = 1e9 + 7;\ntemplate <class T, class S>\ninline void ch(T &x, const S y) {\n  x = (x + y) % mod;\n}\ninline int exp(int x, int y, const int mod = ::mod) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = (long long)ans * x % mod;\n    x = (long long)x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nint n, m, tot, fa[N], from[N], dep[N], c[N], cir[N], edg[N];\nvector<pair<int, int> > g[N], f[N];\nlong long res[N], val[N];\nbool vis[N];\ninline void add(vector<pair<int, int> > *g, int x, int y, int z) {\n  g[x].push_back(make_pair(y, z));\n  g[y].push_back(make_pair(x, z));\n}\ninline void findcir(int x) {\n  vis[x] = 1;\n  for (auto i : g[x]) {\n    int y = i.first;\n    if (vis[i.first]) {\n      if (!tot && dep[y] > dep[x] && !(dep[y] - dep[x] & 1)) {\n        cir[++tot] = y, edg[tot] = i.second;\n        while (y != x) edg[++tot] = from[y], y = fa[y], cir[tot] = y;\n        add(f, x, y, i.second);\n      }\n      continue;\n    }\n    add(f, x, y, i.second);\n    dep[y] = dep[x] + 1;\n    fa[y] = x;\n    from[y] = i.second;\n    findcir(y);\n  }\n}\ninline long long dfs(int x) {\n  long long ret = c[x];\n  vis[x] = 1;\n  for (auto i : f[x]) {\n    int y = i.first;\n    if (vis[y]) continue;\n    ret -= (res[i.second] = dfs(y));\n  }\n  return ret;\n}\nint main() {\n  read(n, m);\n  for (int i = 1; i <= n; i++) read(c[i]);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    read(x, y);\n    add(g, x, y, i);\n  }\n  findcir(1);\n  memset(vis, 0, sizeof(vis));\n  if (!tot) {\n    if (dfs(1)) {\n      puts(\"NO\");\n      return 0;\n    }\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", res[i]);\n    return 0;\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= tot; i++) vis[cir[i]] = 1;\n  long long b = 0;\n  for (int i = 1; i <= tot; i++) {\n    val[i] = dfs(cir[i]);\n    b = val[i] - b;\n  }\n  res[edg[1]] = b / 2;\n  for (int i = 1; i < tot; i++) res[edg[i + 1]] = val[i] - res[edg[i]];\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", res[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, f[100010], tot = 1, head[100010], col[100010], spe, root;\nint bk[100010], v[100010];\nlong long a[100010], w[100010];\nbool flag[100010];\ninline int find(int x) {\n  if (x == f[x]) return x;\n  return f[x] = find(f[x]);\n}\nstruct rd {\n  int now, next, to;\n} road[200010];\ninline void addedge(int x, int y) {\n  road[++tot].next = head[x];\n  road[tot].to = y;\n  road[tot].now = x;\n  head[x] = tot;\n}\ninline void dfs(int x) {\n  for (int now = head[x]; now; now = road[now].next)\n    if (col[road[now].to] != 2) {\n      if (col[road[now].to] == col[x] && spe == 0)\n        spe = x, root = x, bk[road[now].to] = now;\n    } else {\n      col[road[now].to] = col[x] ^ 1;\n      flag[now >> 1] = 1;\n      if (spe == 0) bk[road[now].to] = now;\n      dfs(road[now].to);\n    }\n}\ninline void dfs(int x, int fa) {\n  for (int now = head[x]; now; now = road[now].next) {\n    if (road[now].to != fa && flag[now >> 1] == 1) {\n      dfs(road[now].to, x);\n      a[now >> 1] = v[road[now].to] - w[road[now].to];\n      w[x] += a[now >> 1];\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) f[i] = i;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &v[i]);\n  for (int i = 1, x, y; i <= m; i++)\n    scanf(\"%d%d\", &x, &y), addedge(x, y), addedge(y, x);\n  for (int i = 1; i <= n; i++) col[i] = 2;\n  col[1] = 0;\n  dfs(1);\n  if (spe == 0) {\n    long long V = 0;\n    for (int i = 1; i <= n; i++)\n      if (col[i] == 0)\n        V += v[i];\n      else\n        V -= v[i];\n    if (V != 0)\n      printf(\"NO\\n\");\n    else {\n      printf(\"YES\\n\");\n      dfs(1, 0);\n      for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", a[i]);\n    }\n    return 0;\n  } else {\n    printf(\"YES\\n\");\n    dfs(root, 0);\n    a[bk[root] >> 1] += (v[root] - w[root]) / 2;\n    for (int i = road[bk[root]].now, j = -1; i != root;\n         i = road[bk[i]].now, j *= -1)\n      a[bk[i] >> 1] += j * (v[root] - w[root]) / 2;\n    for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", a[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10, mod = 1e9 + 7;\nconst long long inf = 1e18;\nvector<pair<int, int> > v[maxn];\nint A[maxn], B[maxn], h[maxn], ID = -1;\nlong long Ans[maxn], c[maxn];\nbool mark[maxn];\nlong long dfs(int u, int parid = -1) {\n  mark[u] = 1;\n  long long num = c[u];\n  for (pair<int, int> p : v[u]) {\n    if (!mark[p.first]) {\n      h[p.first] = h[u] + 1;\n      num -= dfs(p.first, p.second);\n    } else if (mark[p.first] && h[p.first] < h[u] &&\n               (h[u] & 1) == (h[p.first] & 1)) {\n      ID = p.second;\n    }\n  }\n  if (parid != -1) Ans[parid] = -num;\n  return num;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n    c[i] *= -1;\n  }\n  for (int i = 0; i < m; i++) {\n    cin >> A[i] >> B[i];\n    v[A[i]].push_back({B[i], i});\n    v[B[i]].push_back({A[i], i});\n  }\n  long long num = dfs(1);\n  if (num != 0 && ID == -1) return cout << \"NO\\n\", 0;\n  if (num != 0) {\n    if (h[A[ID]] & 1) num *= -1;\n    Ans[ID] = -(num / 2);\n    c[A[ID]] -= num / 2;\n    c[B[ID]] -= num / 2;\n  }\n  memset(mark, 0, sizeof mark);\n  dfs(1);\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) {\n    cout << Ans[i] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T, class U>\nvoid Min(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <class T, class U>\nvoid Max(T &a, U b) {\n  if (a < b) a = b;\n}\nvector<pair<int, int> > g[100010];\nint is[100010], c[100010], d[100010], co[100010];\npair<int, int> p[100010];\nlong long w[100010], cur[100010];\nint s = -1, t, end_edge;\nvoid dfs(int u, int fa = -1) {\n  is[u] = 1;\n  for (auto &o : g[u]) {\n    if (o.second == fa) continue;\n    int v = o.first;\n    if (!is[v]) {\n      d[v] = d[u] + 1;\n      p[v] = {u, o.second};\n      co[v] = co[u] ^ 1;\n      dfs(v, o.second);\n      w[o.second] = cur[v];\n      cur[u] -= cur[v];\n    } else if (d[v] < d[u] && co[v] == co[u] && s == -1) {\n      s = u, t = v, end_edge = o.second;\n    }\n  }\n}\nvoid go(int u, int fa = -1) {\n  is[u] = 1;\n  for (auto &o : g[u]) {\n    if (o.second == fa) continue;\n    int v = o.first;\n    if (!is[v] && o.second != end_edge) {\n      go(v, o.second);\n      w[o.second] = cur[v];\n      cur[u] -= cur[v];\n    }\n  }\n}\nint main() {\n  int n, m, j, k, i;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &j, &k);\n    j--, k--;\n    g[j].push_back({k, i}), g[k].push_back({j, i});\n  }\n  for (int i = 0; i < n; i++) cur[i] = c[i], is[i] = 0;\n  dfs(0);\n  if (!cur[0]) {\n    puts(\"YES\");\n    for (int i = 0; i < m; i++) printf(\"%I64d\\n\", w[i]);\n    return 0;\n  }\n  if (s == -1) {\n    puts(\"NO\");\n    return 0;\n  }\n  for (int i = 0; i < n; i++) cur[i] = c[i], is[i] = 0;\n  for (int i = 0; i < m; i++) w[i] = 0;\n  go(s);\n  int first = s;\n  k = 1;\n  long long v = cur[s] / 2;\n  while (first != t) {\n    w[p[first].second] += v * k;\n    k *= -1;\n    first = p[first].first;\n  }\n  w[end_edge] = v * k;\n  puts(\"YES\");\n  for (int i = 0; i < m; i++) printf(\"%I64d\\n\", w[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, col[100005];\nlong long sum[2], num[100005];\nbool ex[2];\nvector<int> edge[100005];\nvoid dfs(int v, int c) {\n  if (col[v] != -1) return;\n  col[v] = c;\n  sum[c] += num[v];\n  for (int i = 0; i < edge[v].size(); i++) {\n    if (col[edge[v][i]] == -1)\n      dfs(edge[v][i], 1 - c);\n    else if (col[edge[v][i]] == c) {\n      ex[c] = 1;\n    }\n  }\n}\npair<int, int> zip[100050];\nmap<pair<int, int>, long long> val;\nint par[100005], ran[100005];\nvoid init() {\n  for (int i = 0; i < 100005; i++) par[i] = i;\n}\nint find(int x) {\n  if (x == par[x])\n    return x;\n  else\n    return par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  if (ran[x] < ran[y])\n    par[x] = y;\n  else {\n    par[y] = x;\n    if (ran[x] == ran[y]) ran[x]++;\n  }\n}\nbool same(int x, int y) { return find(x) == find(y); }\nvector<int> G[100005];\nlong long DFS(int v, int u) {\n  long long V = num[v];\n  for (int i = 0; i < G[v].size(); i++) {\n    if (G[v][i] == u) continue;\n    V -= DFS(G[v][i], v);\n  }\n  if (u == -1)\n    assert(V == 0LL);\n  else {\n    val[make_pair(v, u)] = val[make_pair(u, v)] = V;\n  }\n  return V;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> num[i];\n  init();\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    zip[i] = make_pair(a, b);\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  memset(col, -1, sizeof(col));\n  dfs(1, 0);\n  if (sum[0] != sum[1] && !ex[0] && !ex[1]) {\n    puts(\"NO\");\n    return 0;\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < edge[i].size(); j++) {\n      if (i > edge[i][j]) continue;\n      if (col[i] != col[edge[i][j]]) {\n        continue;\n      }\n      long long hoge = sum[col[i]] - sum[1 - col[i]];\n      hoge /= 2;\n      val[make_pair(i, edge[i][j])] = val[make_pair(edge[i][j], i)] = hoge;\n      num[i] -= hoge;\n      num[edge[i][j]] -= hoge;\n      goto nxt;\n    }\n  }\nnxt:;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < edge[i].size(); j++) {\n      if (i > edge[i][j]) continue;\n      if (col[i] != col[edge[i][j]]) {\n        int a = i, b = edge[i][j];\n        if (!same(a, b)) {\n          G[a].push_back(b);\n          G[b].push_back(a);\n          unite(a, b);\n        }\n        continue;\n      }\n    }\n  }\n  DFS(1, -1);\n  for (int i = 0; i < m; i++) printf(\"%lld\\n\", val[zip[i]]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 2e5 + 52;\nstruct edge {\n  long long to, next;\n} e[N << 1];\nlong long head[N], cnt = 1;\nvoid addedge(long long x, long long y) {\n  e[++cnt] = (edge){y, head[x]}, head[x] = cnt;\n  e[++cnt] = (edge){x, head[y]}, head[y] = cnt;\n}\nstruct dsu {\n  long long p[N];\n  long long f(long long x) { return p[x] ? p[x] = f(p[x]) : x; }\n  void m(long long x, long long y) {\n    if ((x = f(x)) != (y = f(y))) p[x] = y;\n  }\n} _;\nlong long a[N], v[N], c[N], d[N], P[N];\nvoid dfs(long long x, long long p) {\n  for (long long i = head[x], nx; i; i = e[i].next)\n    if ((nx = e[i].to) != p)\n      c[nx] = !c[x], d[nx] = d[x] + 1, P[nx] = x, dfs(nx, x), v[x] -= v[nx],\n      a[i / 2] += v[nx], v[nx] = 0;\n}\nlong long n, m, x[N], y[N], a0[N], v0[N];\nbool f[N];\nsigned main() {\n  scanf(\"%I64d%I64d\", &n, &m);\n  for (long long i = 1; i <= n; i++) scanf(\"%I64d\", v + i);\n  for (long long i = 1; i <= m; i++) {\n    scanf(\"%I64d%I64d\", x + i, y + i);\n    if (_.f(x[i]) != _.f(y[i]))\n      f[i] = true, addedge(x[i], y[i]), _.m(x[i], y[i]);\n    else\n      cnt += 2;\n  }\n  c[1] = 1, dfs(1, 0);\n  if (v[1] % 2) return puts(\"NO\"), 0;\n  if (!v[1]) {\n    puts(\"YES\");\n    for (long long i = 1; i <= m; i++) printf(\"%I64d\\n\", a[i]);\n    return 0;\n  }\n  memcpy(a0, a, sizeof a), memcpy(v0, v, sizeof v);\n  for (long long i = 1, s, t; i <= m; i++) {\n    if (f[i] || c[s = x[i]] != c[t = y[i]]) continue;\n    long long val = v[1] / 2;\n    v[s] -= val, v[t] -= val, a[i] += val, dfs(1, 0);\n    if (v[1]) {\n      memcpy(a, a0, sizeof a), memcpy(v, v0, sizeof v);\n      v[s] += val, v[t] += val, a[i] -= val, dfs(1, 0);\n    }\n    puts(\"YES\");\n    for (long long j = 1; j <= m; j++) printf(\"%I64d\\n\", a[j]);\n    return 0;\n  }\n  puts(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, Num[101000], cnt, Dep[101000], Path[101000];\nint chk[101000], ord[101000], par[101000], pL[101000];\nlong long R[101000], w[101000];\nvector<int> E[101000], L[101000];\nvoid DFS(int a) {\n  Num[a] = ++cnt;\n  ord[cnt] = a;\n  int i;\n  for (i = 0; i < E[a].size(); i++) {\n    if (Num[E[a][i]]) continue;\n    chk[L[a][i]] = 1;\n    Dep[E[a][i]] = Dep[a] + 1;\n    par[E[a][i]] = a;\n    pL[E[a][i]] = L[a][i];\n    DFS(E[a][i]);\n  }\n}\nstruct Edge {\n  int a, b;\n} Ed[201000];\nvoid Pro(int a, int b, int num, long long ss) {\n  int i;\n  R[num] -= ss / 2;\n  while (a != b) {\n    if (Dep[a] < Dep[b]) swap(a, b);\n    R[pL[a]] -= ss / 2;\n    w[a] += ss;\n    a = par[a];\n  }\n  w[a] += ss;\n}\nvoid Make() {\n  int i;\n  for (i = n; i >= 2; i--) {\n    long long tt = w[ord[i]];\n    R[pL[ord[i]]] += tt;\n    w[par[ord[i]]] -= tt;\n  }\n}\nint main() {\n  int i, j, a, b;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%lld\", &w[i]);\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d%d\", &a, &b);\n    E[a].push_back(b);\n    E[b].push_back(a);\n    L[a].push_back(i);\n    L[b].push_back(i);\n    Ed[i] = {a, b};\n  }\n  DFS(1);\n  long long sum = 0;\n  for (i = 1; i <= n; i++) {\n    if (Dep[i] % 2 == 0)\n      sum += w[i];\n    else\n      sum -= w[i];\n  }\n  if (abs(sum) % 2) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  if (sum == 0) {\n    Make();\n  } else {\n    for (i = 0; i < m; i++) {\n      if (!chk[i] && Dep[Ed[i].a] % 2 == Dep[Ed[i].b] % 2) {\n        if (Dep[Ed[i].a] % 2) {\n          Pro(Ed[i].a, Ed[i].b, i, sum);\n          break;\n        } else {\n          Pro(Ed[i].a, Ed[i].b, i, -sum);\n          break;\n        }\n      }\n    }\n    if (i == m) {\n      printf(\"NO\\n\");\n      return 0;\n    }\n    Make();\n  }\n  printf(\"YES\\n\");\n  for (i = 0; i < m; i++) printf(\"%lld\\n\", R[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 112345;\nstruct Edge {\n  int v, nxt;\n} edge[MAX << 2];\nint head[MAX], etot;\nvoid add_edge(int u, int v) {\n  edge[etot] = (Edge){v, head[u]};\n  head[u] = etot++;\n}\nint dep[MAX], f[MAX], A[MAX], eid = -1, x, y;\nbool vis[MAX];\nlong long cost[MAX], from[MAX];\nlong long dfs(int u, int fa) {\n  vis[u] = true;\n  dep[u] = dep[fa] + 1;\n  f[u] = fa;\n  long long sum = 0;\n  for (int i = head[u]; ~i; i = edge[i].nxt) {\n    int v = edge[i].v;\n    if (vis[v] && dep[v] < dep[u] && (dep[u] - dep[v]) % 2 == 0) {\n      eid = i;\n      x = v, y = u;\n    }\n    if (vis[v]) continue;\n    from[v] = i >> 1;\n    dfs(v, u);\n    sum += cost[i >> 1];\n  }\n  if (from[u] != -1) cost[from[u]] = A[u] - sum;\n  return A[u] - sum;\n}\nint n, m;\nvoid out() {\n  printf(\"YES\\n\");\n  for (int i = 0; i < m; i++) {\n    printf(\"%lld\\n\", cost[i]);\n  }\n}\nint main() {\n  memset(from, -1, sizeof(from));\n  memset(head, -1, sizeof(head));\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", A + i);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    add_edge(u, v);\n    add_edge(v, u);\n  }\n  long long remain = dfs(1, 0);\n  if (remain == 0) {\n    out();\n    return 0;\n  }\n  if (remain % 2 || eid == -1) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  cost[eid / 2] = remain / 2;\n  ;\n  if (dep[x] % 2 == 0) cost[eid / 2] *= -1;\n  while (dep[y] > dep[x]) {\n    cost[from[y]] += ((dep[y] - 1) % 2 ? 1 : -1) * remain / 2;\n    y = f[y];\n  }\n  while (x > 1) {\n    cost[from[x]] += ((dep[x] - 1) % 2 ? 1 : -1) * remain;\n    x = f[x];\n  }\n  out();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl() {}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n  template <typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const& x() const {\n    return get<0>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<0, T>::type& x() {\n    return get<0>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const& y() const {\n    return get<1>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<1, T>::type& y() {\n    return get<1>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const& z() const {\n    return get<2>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<2, T>::type& z() {\n    return get<2>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const& w() const {\n    return get<3>(*this);\n  }\n  template <typename T = tuple<As...> >\n  typename tuple_element<3, T>::type& w() {\n    return get<3>(*this);\n  }\n};\nusing lli = long long int;\nusing llu = long long unsigned;\nusing pii = tpl<lli, lli>;\nusing piii = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi = vector<lli>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\ntemplate <class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T>\nusing max_queue = priority_queue<T>;\ntemplate <size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = {{I...}};\n};\nnamespace my_index_sequence_detail {\ntemplate <typename I, typename J>\nstruct concat;\ntemplate <size_t... I, size_t... J>\nstruct concat<my_index_sequence<I...>, my_index_sequence<J...> >\n    : my_index_sequence<I..., (sizeof...(I) + J)...> {};\ntemplate <size_t N>\nstruct make_index_sequence\n    : concat<typename make_index_sequence<N / 2>::type,\n             typename make_index_sequence<N - N / 2>::type>::type {};\ntemplate <>\nstruct make_index_sequence<0> : my_index_sequence<> {};\ntemplate <>\nstruct make_index_sequence<1> : my_index_sequence<0> {};\n}  // namespace my_index_sequence_detail\ntemplate <class... A>\nusing my_index_sequence_for =\n    typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\ntemplate <class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>) {\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0 ? \"\" : \", \") << get<I>(a)), 0)...};\n}\ntemplate <class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate <class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate <class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate <class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\ntemplate <class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T>\nostream& operator<<(ostream& s, vector<T> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T>\nostream& operator<<(ostream& s, multiset<T> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T>\nostream& operator<<(ostream& s, set<T> const& a) {\n  return print_collection(s, a);\n}\ntemplate <class T>\nostream& print_collection(ostream& s, T const& a) {\n  s << '[';\n  for (auto it = begin(a); it != end(a); ++it) {\n    s << *it;\n    if (it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\ntemplate <class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a) {\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\ntemplate <class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a) {\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\ntemplate <class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a) {\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  lli n, m;\n  cin >> n >> m;\n  vi C(n);\n  for (lli i = 0; i < (lli)(n); ++i) cin >> C[i];\n  vi W(m, 0);\n  vvii G(n);\n  for (lli i = 0; i < (lli)(m); ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    G[u].push_back(make_tuple(v, i));\n    G[v].push_back(make_tuple(u, i));\n  }\n  vi E(n);\n  vi depth(n);\n  function<lli(int, lli)> dfs = [&](int i, lli d) {\n    depth[i] = d;\n    E[i] = 1;\n    lli c = C[i];\n    for (auto e_ : G[i]) {\n      int j, e;\n      tie(j, e) = e_;\n      if (!E[j]) {\n        lli cj = dfs(j, d + 1);\n        c -= cj;\n      }\n    }\n    return c;\n  };\n  lli r = dfs(0, 0);\n  if (r & 1) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  for (lli i = 0; i < (lli)(n); ++i)\n    for (auto e_ : G[i]) {\n      int j, e;\n      tie(j, e) = e_;\n      if (depth[i] % 2 == depth[j] % 2) {\n        W[e] = (depth[i] & 1) ? -r / 2 : r / 2;\n        r = 0;\n        C[i] -= W[e];\n        C[j] -= W[e];\n        goto l1;\n      }\n    }\nl1:;\n  if (r) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  E.assign(n, 0);\n  function<void(int)> dfs2 = [&](int i) {\n    E[i] = 1;\n    for (auto e_ : G[i]) {\n      int j, e;\n      tie(j, e) = e_;\n      if (!E[j]) {\n        dfs2(j);\n        W[e] = C[j];\n        C[j] -= W[e];\n        C[i] -= W[e];\n      }\n    }\n  };\n  dfs2(0);\n  cout << \"YES\" << endl;\n  for (lli i = 0; i < (lli)(m); ++i) {\n    cout << W[i] << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int maxn(100000);\ntemplate <class _Tp>\ninline _Tp Abs(const _Tp& v) {\n  return v < 0 ? -v : v;\n}\ntemplate <class _Tp>\ninline _Tp Min(const _Tp& x, const _Tp& y) {\n  return x < y ? x : y;\n}\ntemplate <class _Tp>\ninline _Tp Max(const _Tp& x, const _Tp& y) {\n  return x > y ? x : y;\n}\nnamespace IOManager {\nconstexpr int FILESZ(131072);\nchar buf[FILESZ];\nconst char *ibuf = buf, *tbuf = buf;\nstruct IOManager {\n  inline char gc() {\n    return (ibuf == tbuf) &&\n                   (tbuf = (ibuf = buf) + fread(buf, 1, FILESZ, stdin),\n                    ibuf == tbuf)\n               ? EOF\n               : *ibuf++;\n  }\n  template <class _Tp>\n  inline operator _Tp() {\n    _Tp s = 0u;\n    char c = gc(), w = 0;\n    for (; c < 48; c = gc()) (c == 45) && (w = 1);\n    for (; c > 47; c = gc()) s = (_Tp)(s * 10u + c - 48u);\n    return w ? -s : s;\n  }\n};\n}  // namespace IOManager\nIOManager::IOManager io;\nstruct Edge {\n  int v, idx;\n  Edge* las;\n  inline Edge* init(const int to, const int iidx, Edge* const& ls) {\n    return v = to, idx = iidx, las = ls, this;\n  }\n} * las[maxn + 1];\ninline void lnk(const int u, const int v, const int idx) {\n  static Edge pool[maxn << 1], *alc = pool - 1;\n  las[u] = (++alc)->init(v, idx, las[u]);\n  las[v] = (++alc)->init(u, idx, las[v]);\n}\nstruct Edge2 {\n  int u, v;\n} e[maxn + 1];\nint ufs[maxn + 1];\ninline int Anc(const int _) { return _ == ufs[_] ? _ : ufs[_] = Anc(ufs[_]); }\ni64 c[maxn + 1], tc[maxn + 1];\ni64 w[maxn + 1];\nunsigned char dep[maxn + 1];\nvoid calc(const int now, const int Fa, const int idx) {\n  i64& t = c[now];\n  for (Edge* o = las[now]; o; o = o->las)\n    if (o->v != Fa)\n      dep[o->v] = !dep[now], calc(o->v, now, o->idx), t -= w[o->idx];\n  w[idx] = t;\n  t = 0;\n}\nint main() {\n  const int n = io, m = io;\n  for (int i = 1; i <= n; ++i) c[i] = io, ufs[i] = i;\n  for (int i = 1; i <= m; ++i)\n    if (Anc(e[i].u = io) != Anc(e[i].v = io))\n      ufs[ufs[e[i].u]] = ufs[e[i].v], lnk(e[i].u, e[i].v, i);\n  memcpy(tc + 1, c + 1, n << 3);\n  calc(1, 0, 0);\n  memcpy(c + 1, tc + 1, n << 3);\n  if (i64 res = *w) {\n    if (Abs(res) & 1) return puts(\"NO\"), 0;\n    for (int i = 1; i <= m; ++i)\n      if (dep[e[i].u] == dep[e[i].v]) {\n        if (dep[e[i].u])\n          w[i] = -res / 2ll;\n        else\n          w[i] = res / 2ll;\n        c[e[i].u] -= w[i];\n        c[e[i].v] -= w[i];\n        res = 0;\n        break;\n      }\n    if (res) return puts(\"NO\"), 0;\n  }\n  calc(1, 0, 0);\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", w[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T read(register T& t) {\n  register T f = 1;\n  register char ch = getchar();\n  t = 0;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -f;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') t = t * 10 + ch - '0', ch = getchar();\n  t *= f;\n  return t;\n}\ntemplate <typename T, typename... Args>\ninline void read(T& t, Args&... args) {\n  read(t);\n  read(args...);\n}\nconst long long p = 998244353;\ninline long long power(register long long x, register long long k = p - 2) {\n  register long long re = 1;\n  for (; k; k >>= 1, x = x * x % p)\n    if (k & 1) re = re * x % p;\n  return re;\n}\nint n, m;\nint head[100005], ne[200005], to[200005], total = 1;\ninline void add(int a, int b) {\n  total++;\n  to[total] = b;\n  ne[total] = head[a];\n  head[a] = total;\n}\nlong long Ans[200005], c[200005];\nbool vis[200005];\nint fa[200005], fs[200005];\nint deep[200005];\nvoid dfs(int now) {\n  vis[now] = 1;\n  deep[now] = deep[fa[now]] + 1;\n  for (int i = head[now]; i; i = ne[i])\n    if (vis[to[i]] == 0) {\n      fa[to[i]] = now;\n      fs[to[i]] = i;\n      dfs(to[i]);\n    }\n  if (fs[now]) {\n    Ans[fs[now] >> 1] += c[now];\n    c[fa[now]] -= c[now];\n    c[now] = 0;\n  }\n}\nvoid dfs2(int now) {\n  if (c[1] == 0) return;\n  for (int i = head[now]; i; i = ne[i])\n    if (to[i] != fa[now]) {\n      if (c[1] == 0) return;\n      if (deep[to[i]] < deep[now]) continue;\n      if (now != fa[to[i]] && (deep[to[i]] - deep[now]) % 2 == 0) {\n        long long qwq = -c[1] / 2;\n        if (deep[now] & 1) qwq = c[1] / 2;\n        Ans[i >> 1] += qwq;\n        int id;\n        id = to[i];\n        while (id != now) {\n          qwq = -qwq;\n          Ans[fs[id] >> 1] += qwq;\n          id = fa[id];\n        }\n        qwq = c[1];\n        if (deep[now] & 1) qwq = -c[1];\n        id = now;\n        while (id != 1) {\n          Ans[fs[id] >> 1] += qwq;\n          qwq = -qwq;\n          id = fa[id];\n        }\n        c[1] = 0;\n        return;\n      }\n      if (now == fa[to[i]]) dfs2(to[i]);\n      if (c[1] == 0) return;\n    }\n}\nint main() {\n  read(n, m);\n  for (int i = 1; i <= n; i++) read(c[i]);\n  for (int i = 1, x, y; i <= m; i++) read(x, y), add(x, y), add(y, x);\n  dfs(1);\n  if (c[1] & 1) return printf(\"NO\\n\"), 0;\n  dfs2(1);\n  if (c[1]) return printf(\"NO\\n\"), 0;\n  printf(\"YES\\n\");\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", Ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint head[N], nxt[N << 1];\nint to[N << 1], E;\nlong long ans[N], val[N];\nint vst[N], dep[N], fa[N];\nvector<int> path;\nvoid dfs(int u) {\n  for (int e = head[u]; ~e; e = nxt[e]) {\n    if (!path.empty()) {\n      return;\n    }\n    int v = to[e];\n    if (vst[v]) {\n      if (vst[v] == vst[u]) {\n        int U = u, V = v;\n        while (dep[U] > dep[V]) {\n          path.push_back(U);\n          U = fa[U];\n        }\n        stack<int> a;\n        while (dep[V] > dep[U]) {\n          a.push(V);\n          V = fa[V];\n        }\n        while (true) {\n          path.push_back(U);\n          if (U != V) {\n            a.push(V);\n          }\n          U = fa[U];\n          V = fa[V];\n          break;\n        }\n        while (!a.empty()) {\n          path.push_back(a.top());\n          a.pop();\n        }\n      }\n    } else {\n      vst[v] = vst[u] ^ 1;\n      fa[v] = u;\n      dep[v] = dep[u] + 1;\n      dfs(v);\n    }\n  }\n}\nvoid rdfs(int u) {\n  vst[u] = 1;\n  for (int e = head[u]; ~e; e = nxt[e]) {\n    int v = to[e];\n    if (vst[v]) {\n      continue;\n    }\n    rdfs(v);\n    ans[e >> 1] = val[v];\n    val[u] -= val[v];\n  }\n}\nint main() {\n  memset(head, -1, sizeof head);\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", val + i);\n  }\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    nxt[E] = head[u];\n    to[E] = v;\n    head[u] = E++;\n    nxt[E] = head[v];\n    to[E] = u;\n    head[v] = E++;\n  }\n  vst[1] = 2;\n  dfs(1);\n  memset(vst, 0, sizeof vst);\n  if (path.empty()) {\n    rdfs(1);\n    if (val[1]) {\n      puts(\"NO\");\n      return 0;\n    }\n  } else {\n    for (auto u : path) {\n      vst[u] = 2;\n    }\n    long long tot = 0;\n    long long crr = 0;\n    int pn = path.size();\n    for (int i = 0; i < pn; i++) {\n      rdfs(path[i]);\n      tot += val[path[i]];\n      if (i > 1 && !(i & 1)) {\n        crr += val[path[i]];\n      }\n    }\n    if (tot & 1) {\n      puts(\"NO\");\n      return 0;\n    }\n    tot >>= 1;\n    for (int i = 0; i < pn; i++) {\n      int u = path[i];\n      int v = path[(i + 1) % pn];\n      for (int e = head[u]; ~e; e = nxt[e]) {\n        if (to[e] == v) {\n          ans[e >> 1] = tot - crr;\n          break;\n        }\n      }\n      crr = tot * 2 - crr - val[v];\n    }\n  }\n  puts(\"YES\");\n  for (int i = 0; i < m; i++) {\n    printf(\"%I64d\\n\", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long c[100005];\npair<int, int> bruh[100005];\nvector<int> e[100005];\nint d[100005];\nint p[100005];\nvector<int> cyc;\nvoid gc(int bt, int tp) {\n  int mn = bt, mx = bt;\n  int cur = bt;\n  cyc.push_back(bt);\n  while (cur != tp) {\n    cur = p[cur];\n    cyc.push_back(cur);\n  }\n}\nbool dfs(int cn) {\n  for (auto nn : e[cn]) {\n    if (d[nn] == -1) {\n      d[nn] = d[cn] + 1;\n      p[nn] = cn;\n      if (dfs(nn)) return true;\n    } else if (nn != p[cn] && d[nn] < d[cn]) {\n      if ((d[nn] - d[cn]) % 2 == 0) {\n        gc(cn, nn);\n        return true;\n      }\n    }\n  }\n  return false;\n}\nmap<pair<int, int>, long long> res;\nvoid ae(int u, int v, long long ch) {\n  if (u > v) swap(u, v);\n  res[{u, v}] += ch;\n  c[u] += ch;\n  c[v] += ch;\n}\nbool vis[100005];\nvoid dfs2(int cn, int p) {\n  vis[cn] = true;\n  for (auto nn : e[cn]) {\n    if (vis[nn]) continue;\n    dfs2(nn, cn);\n  }\n  if (p != 0) {\n    ae(cn, p, -c[cn]);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = (1); i <= (signed)(n); i++) {\n    int x;\n    cin >> x;\n    c[i] = -x;\n  }\n  for (int i = 0; i < (signed)(m); i++) {\n    int u, v;\n    cin >> u >> v;\n    if (u > v) swap(u, v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n    bruh[i] = {u, v};\n  }\n  memset(d, -1, sizeof d);\n  d[1] = 0;\n  bool hmm = dfs(1);\n  int rt;\n  if (hmm) {\n    rt = cyc[0];\n  } else {\n    rt = 1;\n  }\n  dfs2(rt, 0);\n  if (!hmm) {\n    if (c[rt] != 0) {\n      cout << \"NO\\n\";\n    } else {\n      cout << \"YES\\n\";\n      for (int i = 0; i < (signed)(m); i++) {\n        cout << res[bruh[i]] << \"\\n\";\n      }\n    }\n  } else {\n    long long d = -c[rt] / 2;\n    for (int i = 0; i < (signed)(cyc.size() - 1); i++) {\n      ae(cyc[i], cyc[i + 1], d);\n      d = -d;\n    }\n    ae(cyc[0], cyc[cyc.size() - 1], d);\n    cout << \"YES\\n\";\n    for (int i = 0; i < (signed)(m); i++) {\n      cout << res[bruh[i]] << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long readi() {\n  long long input = 0;\n  char c = ' ';\n  while (c < '-') {\n    c = getchar();\n  }\n  bool negative = false;\n  if (c == '-') {\n    negative = true;\n    c = getchar();\n  }\n  while (c >= '0') {\n    input = 10 * input + (c - '0');\n    c = getchar();\n  }\n  if (negative) {\n    input = -input;\n  }\n  return input;\n}\nvoid printi(long long output) {\n  if (output == 0) {\n    putchar('0');\n    return;\n  }\n  if (output < 0) {\n    putchar('-');\n    output = -output;\n  }\n  int aout[20];\n  int ilen = 0;\n  while (output) {\n    aout[ilen] = ((output % 10));\n    output /= 10;\n    ilen++;\n  }\n  for (int i = ilen - 1; i >= 0; i--) {\n    putchar(aout[i] + '0');\n  }\n  return;\n}\nstring reads() {\n  string input = \"\";\n  char c = ' ';\n  while (c <= ' ') {\n    c = getchar();\n  }\n  while (c > ' ') {\n    input += c;\n    c = getchar();\n  }\n  return input;\n}\nint sgn(long long x) {\n  if (x < 0) {\n    return -1;\n  }\n  if (x > 0) {\n    return 1;\n  }\n  return 0;\n}\nlong long randomize(long long mod) {\n  return ((1 << 30) * rand() + (1 << 15) * rand() + rand()) % mod;\n}\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-30;\nlong long normalize(long long x, long long mod) {\n  return (((x % mod) + mod) % mod);\n}\nint N, M;\nmap<int, int> mp[100010];\nvector<int> edge[100010];\nlong long arr[100010];\nlong long ans[100010];\nbool bipartite = true;\nbool seen[100010], color[100010], in[100010];\nint parent[100010];\nlong long pref[100010], suf[100010];\nvector<int> cyc, nodes;\nlong long tot;\nvoid dfs(int u, int par, bool col) {\n  if (seen[u]) {\n    if (col != color[u]) {\n      bipartite = false;\n      while (nodes.back() != u) {\n        cyc.push_back(nodes.back());\n        in[nodes.back()] = true;\n        nodes.pop_back();\n      }\n      in[u] = true;\n      cyc.push_back(u);\n    }\n    return;\n  }\n  nodes.push_back(u);\n  seen[u] = true;\n  color[u] = col;\n  for (int v : edge[u]) {\n    if (v == par) {\n      continue;\n    }\n    dfs(v, u, !col);\n    if (!bipartite) {\n      return;\n    }\n  }\n  nodes.pop_back();\n  return;\n}\nvoid solve(int u, int par) {\n  if (seen[u]) {\n    return;\n  }\n  seen[u] = true;\n  for (int v : edge[u]) {\n    if (seen[v]) {\n      continue;\n    }\n    if (v == par) {\n      continue;\n    }\n    solve(v, u);\n  }\n  if (par == -1) {\n    return;\n  }\n  ans[mp[u][par]] = arr[u];\n  arr[par] -= arr[u];\n  arr[u] = 0;\n  return;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  srand(time(0));\n  if (fopen(\"cf901d.in\", \"r\")) {\n    freopen(\"cf901d.in\", \"r\", stdin);\n    freopen(\"cf901d.out\", \"w\", stdout);\n  }\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) {\n    cin >> arr[i];\n  }\n  for (int i = 0; i < M; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    if (u > v) {\n      swap(u, v);\n    }\n    mp[u][v] = i;\n    mp[v][u] = i;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  dfs(0, -1, 0);\n  for (int i = 0; i < N; i++) {\n    seen[i] = false;\n  }\n  if (bipartite) {\n    int net = 0;\n    for (int i = 0; i < N; i++) {\n      if (color[i]) {\n        net += arr[i];\n      } else {\n        net -= arr[i];\n      }\n    }\n    if (net) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    cout << \"YES\\n\";\n    solve(0, -1);\n    for (int i = 0; i < M; i++) {\n      cout << ans[i] << '\\n';\n    }\n    return 0;\n  }\n  cout << \"YES\\n\";\n  for (int u : cyc) {\n    for (int v : edge[u]) {\n      if (in[v]) {\n        continue;\n      }\n      solve(v, u);\n    }\n  }\n  pref[0] = 0;\n  pref[1] = 0;\n  for (int i = 0; i < cyc.size(); i++) {\n    int u = cyc[i];\n    pref[i + 2] = pref[i] + arr[u];\n    tot += arr[u];\n  }\n  suf[cyc.size() + 1] = 0;\n  suf[cyc.size()] = 0;\n  for (int i = cyc.size() - 1; i >= 0; i--) {\n    int u = cyc[i];\n    suf[i] = suf[i + 2] + arr[u];\n  }\n  tot /= 2;\n  cyc.push_back(cyc[0]);\n  for (int i = 0; i < cyc.size() - 1; i++) {\n    int u = cyc[i], v = cyc[i + 1];\n    long long res = tot;\n    res -= pref[i + 1];\n    res -= suf[i + 2];\n    ans[mp[u][v]] += res;\n  }\n  for (int i = 0; i < M; i++) {\n    cout << ans[i] << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\ntemplate <typename T>\nvoid chmin(T &a, const T &b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid chmax(T &a, const T &b) {\n  a = max(a, b);\n}\nstruct FastIO {\n  FastIO() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n} fastiofastio;\nconst ll INF = 1LL << 60;\nint main(void) {\n  ll n, m;\n  cin >> n >> m;\n  vector<ll> c(n);\n  for (ll i = (ll)0; i < (ll)n; ++i) cin >> c[i];\n  vector<vector<PII>> g(n);\n  for (ll i = (ll)0; i < (ll)m; ++i) {\n    ll a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[a].emplace_back(b, i);\n    g[b].emplace_back(a, i);\n  }\n  ll x = -1, y = -1, z = -1;\n  vector<ll> ans(m), depth(n, -1);\n  function<ll(ll, ll)> dfs = [&](ll v, ll p) {\n    ll ret = 0;\n    for (auto to : g[v]) {\n      if (to.first == p) continue;\n      if (depth[to.first] == -1) {\n        depth[to.first] = depth[v] + 1;\n        ;\n        ans[to.second] = c[to.first] - dfs(to.first, v);\n        ret += ans[to.second];\n      } else if (depth[v] > depth[to.first]) {\n        if ((depth[v] - depth[to.first]) % 2 == 0 && x == -1) {\n          x = v, y = to.first, z = to.second;\n        }\n      }\n    }\n    return ret;\n  };\n  depth[0] = 0;\n  ll ret = dfs(0, -1);\n  ;\n  ;\n  ;\n  ;\n  if (ret != c[0]) {\n    if (x == -1 || (ret - c[0]) % 2) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    ll diff;\n    if (depth[y] % 2)\n      diff = (ret - c[0]) / 2;\n    else\n      diff = -(ret - c[0]) / 2;\n    ;\n    ll start_v, end_v;\n    vector<ll> path;\n    vector<bool> used(n);\n    function<bool(ll, ll)> getpath = [&](ll v, ll p) {\n      ;\n      used[v] = true;\n      if (v == end_v) return true;\n      bool ret = false;\n      for (auto to : g[v]) {\n        if (to.first == p) continue;\n        if (used[to.first]) continue;\n        bool tmp = getpath(to.first, v);\n        ret |= tmp;\n        if (tmp) path.push_back(to.second);\n      }\n      if (v == start_v) ret = false;\n      return ret;\n    };\n    ans[z] += diff;\n    start_v = y, end_v = x;\n    getpath(0, -1);\n    ;\n    for (ll i = (ll)0; i < (ll)path.size(); ++i) {\n      if (i % 2 == 0)\n        ans[path[i]] -= diff;\n      else\n        ans[path[i]] += diff;\n    }\n    start_v = 0, end_v = y;\n    path.clear();\n    used.assign(n, false);\n    getpath(0, -1);\n    ;\n    for (ll i = (ll)0; i < (ll)path.size(); ++i) {\n      if (i % 2 == 0)\n        ans[path[i]] -= 2 * diff;\n      else\n        ans[path[i]] += 2 * diff;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (auto i : ans) cout << i << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1000000007;\nconst int MM = 998244353;\ntemplate <typename T, typename U>\nstatic inline void amin(T &x, U y) {\n  if (y < x) x = y;\n}\ntemplate <typename T, typename U>\nstatic inline void amax(T &x, U y) {\n  if (x < y) x = y;\n}\nint _runtimeTerror_() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> par_edge(n + 1), par(n + 1), dep(n + 1), vis(n + 1), c(n + 1);\n  vector<vector<pair<int, int>>> g(n + 1);\n  vector<long long> ans(m + 1, 0);\n  for (int i = 1; i <= n; ++i) cin >> c[i];\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    g[x].push_back({y, i});\n    g[y].push_back({x, i});\n  }\n  vector<array<int, 3>> back;\n  vector<long long> cnt(2, 0);\n  function<void(int, int)> dfs = [&](int s, int p) {\n    vis[s] = true;\n    par[s] = p;\n    cnt[dep[s] & 1] += c[s];\n    for (auto &[j, k] : g[s]) {\n      if (!vis[j]) {\n        dep[j] = dep[s] + 1;\n        par_edge[j] = k;\n        dfs(j, s);\n      } else if (j != p)\n        back.push_back({j, s, k});\n    }\n  };\n  dfs(1, 0);\n  for (auto &[u, v, id] : back) {\n    if ((dep[u] & 1) == (dep[v] & 1)) {\n      if (dep[u] & 1)\n        ans[id] = (cnt[1] - cnt[0]) / 2, c[u] -= (cnt[1] - cnt[0]) / 2,\n        c[v] -= (cnt[1] - cnt[0]) / 2;\n      else\n        ans[id] = (cnt[0] - cnt[1]) / 2, c[u] -= (cnt[0] - cnt[1]) / 2,\n        c[v] -= (cnt[0] - cnt[1]) / 2;\n      cnt[0] = cnt[1];\n      break;\n    }\n  }\n  if (cnt[0] != cnt[1]) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  vis.assign(n + 1, false);\n  function<int(int, int)> dfs2 = [&](int s, int p) {\n    vis[s] = true;\n    long long sum = 0;\n    for (auto &[j, k] : g[s]) {\n      if (!vis[j]) sum += dfs2(j, s);\n    }\n    ans[par_edge[s]] = c[s] - sum;\n    return ans[par_edge[s]];\n  };\n  assert(dfs2(1, 0) == 0);\n  cout << \"YES\\n\";\n  for (int i = 1; i <= m; ++i) cout << ans[i] << \"\\n\";\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int TESTS = 1;\n  while (TESTS--) _runtimeTerror_();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nvector<int> g[N];\nint a[N], b[N], dep[N];\nint par[N], vis[N];\nlong long ans[N], c[N];\nvoid dfs(int v, int pi, int dep) {\n  vis[v] = 1;\n  par[v] = pi;\n  ::dep[v] = dep;\n  for (int ind : g[v]) {\n    int u = a[ind] ^ b[ind] ^ v;\n    if (ind == pi || vis[u]) continue;\n    dfs(u, ind, dep + 1);\n  }\n}\nvoid dfs2(int v, int pi) {\n  vis[v] = 1;\n  long long val = c[v];\n  for (int ind : g[v]) {\n    int u = a[ind] ^ b[ind] ^ v;\n    if (!vis[u]) {\n      dfs2(u, ind);\n      val -= ans[ind];\n    }\n  }\n  ans[pi] = val;\n}\ninline int common(int x, int y) {\n  if (a[x] == a[y]) return a[x];\n  if (a[x] == b[y]) return a[x];\n  if (b[x] == a[y]) return b[x];\n  if (b[x] == b[y]) return b[y];\n  assert(false);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << setprecision(32);\n  int n, m;\n  cin >> n >> m;\n  long long sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n    sum += c[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> a[i] >> b[i];\n    g[a[i]].push_back(i);\n    g[b[i]].push_back(i);\n  }\n  if (sum & 1) {\n    cout << \"NO\\n\";\n    exit(0);\n  }\n  memset(vis, 0, sizeof(vis));\n  dfs(1, 0, 1);\n  bool bipartite = true;\n  for (int i = 1; i <= m; i++) {\n    if ((dep[a[i]] ^ dep[b[i]]) % 2 == 0) {\n      bipartite = false;\n      break;\n    }\n  }\n  memset(ans, 0, sizeof(ans));\n  if (bipartite) {\n    memset(vis, 0, sizeof(vis));\n    dfs2(1, 0);\n    if (ans[0] != 0) {\n      cout << \"NO\\n\";\n    } else {\n      cout << \"YES\\n\";\n      for (int i = 1; i <= m; i++) {\n        cout << ans[i] << '\\n';\n      }\n    }\n    exit(0);\n  }\n  vector<int> odd_cycle;\n  vector<int> vertices;\n  set<int> st;\n  for (int i = 1; i <= m; i++) {\n    if ((dep[a[i]] ^ dep[b[i]]) % 2 == 0) {\n      vector<int> left, right;\n      int u = a[i];\n      int v = b[i];\n      while (u != v) {\n        if (dep[u] > dep[v]) {\n          left.push_back(par[u]);\n          u ^= a[par[u]] ^ b[par[u]];\n        } else {\n          right.push_back(par[v]);\n          v ^= a[par[v]] ^ b[par[v]];\n        }\n      }\n      odd_cycle.push_back(i);\n      st.insert(i);\n      for (auto x : left) {\n        odd_cycle.push_back(x);\n        st.insert(x);\n      }\n      reverse(right.begin(), right.end());\n      for (auto x : right) {\n        odd_cycle.push_back(x);\n        st.insert(x);\n      }\n      vertices.push_back(common(odd_cycle[0], odd_cycle.back()));\n      for (int i = 0; i + 1 < odd_cycle.size(); i++) {\n        vertices.push_back(common(odd_cycle[i], odd_cycle[i + 1]));\n      }\n      break;\n    }\n  }\n  memset(vis, 0, sizeof(vis));\n  dfs2(a[odd_cycle[0]], 0);\n  for (int v : vertices) {\n    for (int ind : g[v]) {\n      if (st.find(ind) == st.end()) c[v] -= ans[ind];\n    }\n  }\n  sum = 0;\n  for (int i = 0; i < vertices.size(); i++) {\n    if (i & 1)\n      sum += c[vertices[i]];\n    else\n      sum -= c[vertices[i]];\n  }\n  assert(sum % 2 == 0);\n  sum >>= 1;\n  sum += c[vertices[0]];\n  for (int i = 0; i < odd_cycle.size(); i++) {\n    ans[odd_cycle[i]] = sum;\n    sum = c[vertices[(i + 1) % vertices.size()]] - sum;\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= m; i++) {\n    cout << ans[i] << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nvector<pair<int, int> > g[N];\nlong long c[N], cur[N], ans[N];\nbool vis[N];\nint s = -1, t = -1, idd = -1, col[N], fav[N], d[N], fae[N];\nvoid dfs(int v) {\n  vis[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    int to = g[v][i].first, id = g[v][i].second;\n    if (!vis[to]) {\n      d[to] = d[v] + 1;\n      col[to] = col[v] ^ 1;\n      fav[to] = v;\n      fae[to] = id;\n      dfs(to);\n      ans[id] = cur[to];\n      cur[v] -= cur[to];\n    } else if (d[to] < d[v])\n      if (col[to] == col[v]) {\n        s = v, t = to;\n        idd = id;\n      }\n  }\n}\nvoid sol(int v) {\n  vis[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    int to = g[v][i].first, id = g[v][i].second;\n    if (id != idd && !vis[to]) {\n      sol(to);\n      ans[id] = c[to];\n      c[v] -= c[to];\n    }\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &c[i]);\n    cur[i] = c[i];\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--, b--;\n    g[a].push_back(make_pair(b, i));\n    g[b].push_back(make_pair(a, i));\n  }\n  dfs(0);\n  if (cur[0] == 0) {\n    puts(\"YES\");\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n  }\n  if (idd != -1) {\n    for (int i = 0; i < m; i++) ans[i] = 0;\n    for (int i = 0; i < n; i++) vis[i] = 0;\n    sol(s);\n    long long res = c[s] / 2;\n    int cur = s, sign = 1;\n    for (; cur != t; cur = fav[cur]) {\n      ans[fae[cur]] += sign * res;\n      sign *= -1;\n    }\n    ans[idd] += sign * res;\n    puts(\"YES\");\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n  } else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, K = 20;\nlong long W[N], tmp[N], w[N];\nstruct edge {\n  int x, y;\n} a[N];\nint to[N << 1], fs[N], nx[N << 1], e = 1;\nint fr[N];\nint vis[N], c[N];\nint dep[N], fa[N][K];\ninline void add(int x, int y) {\n  to[++e] = y;\n  nx[e] = fs[x];\n  fs[x] = e;\n}\nvoid dfs(int x, int f) {\n  dep[x] = dep[f] + 1;\n  fa[x][0] = f;\n  for (int i = 1; i <= 16; ++i) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n  for (int i = fs[x]; i; i = nx[i]) {\n    int k = to[i];\n    if (k == f || vis[k]) continue;\n    fr[k] = i >> 1;\n    vis[k] = c[i >> 1] = 1;\n    dfs(k, x);\n    w[i >> 1] = W[k];\n    W[x] -= w[i >> 1], W[k] -= w[i >> 1];\n  }\n}\ninline int lca(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  for (int i = 16; ~i; --i)\n    if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];\n  if (x == y) return x;\n  for (int i = 16; ~i; --i)\n    if (fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i];\n  return fa[x][0];\n}\ninline void climb(int x, int t, int val) {\n  for (int tp = -1; x ^ t; x = fa[x][0], tp = -tp) w[fr[x]] += tp * val;\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int x = 1; x <= n; ++x) scanf(\"%lld\", &W[x]), tmp[x] = W[x];\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[i] = (edge){x, y};\n    add(x, y), add(y, x);\n  }\n  vis[1] = 1, dfs(1, 0);\n  if (!W[1]) {\n    puts(\"YES\");\n    for (int x = 1; x <= m; ++x) printf(\"%lld\\n\", w[x]);\n    return 0;\n  }\n  if (W[1] & 1) return puts(\"NO\"), 0;\n  for (int i = 1; i <= m; ++i) {\n    if (c[i]) continue;\n    int x = a[i].x, y = a[i].y;\n    int t = lca(x, y);\n    if ((dep[x] + dep[y] - dep[t] - dep[fa[t][0]]) & 1) {\n      int val = W[1] / 2;\n      tmp[x] -= val, tmp[y] -= val;\n      for (int k = 1; k <= n; ++k) W[k] = tmp[k];\n      memset(w, 0, sizeof w);\n      memset(vis, 0, sizeof vis);\n      vis[1] = 1, dfs(1, 0);\n      if (!W[1]) {\n        puts(\"YES\");\n        w[i] += val;\n        for (int k = 1; k <= m; ++k) printf(\"%lld\\n\", w[k]);\n        return 0;\n      }\n      tmp[x] += val * 2, tmp[y] += val * 2;\n      for (int k = 1; k <= n; ++k) W[k] = tmp[k];\n      memset(w, 0, sizeof w);\n      memset(vis, 0, sizeof vis);\n      vis[1] = 1, dfs(1, 0);\n      puts(\"YES\");\n      w[i] -= val;\n      for (int k = 1; k <= m; ++k) printf(\"%lld\\n\", w[k]);\n      return 0;\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int getint() {\n  char c = getchar();\n  int x = 0, f = 1;\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - 48;\n  return x * f;\n}\ninline void putl(long long x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x) {\n    static int buf[30], xb;\n    for (xb = 0; x; x /= 10) buf[++xb] = x % 10;\n    for (; xb;) putchar(buf[xb--] | 48);\n  } else\n    putchar('0');\n}\nconst int N = 100005;\nstruct edge {\n  int to, next;\n} e[N << 1];\nlong long ans[N], c[N], cc[N], v;\nint n, m, x, y, h[N], xb, i, dep[N], be, en, dad[N], ef[N], id;\nvoid dfs(int x, int fa) {\n  dep[x] = dep[fa] + 1;\n  for (int i = h[x]; i; i = e[i].next)\n    if (e[i].to != fa) {\n      if (!dep[e[i].to]) {\n        dfs(e[i].to, x);\n        c[x] -= ans[i >> 1] = c[e[i].to];\n      } else if (!((dep[e[i].to] ^ dep[x]) & 1))\n        be = x;\n    }\n}\nvoid dfs2(int x, int fa) {\n  dep[x] = dep[dad[x] = fa] + 1;\n  for (int i = h[x]; i; i = e[i].next)\n    if (e[i].to != fa) {\n      if (!dep[e[i].to]) {\n        dfs2(e[i].to, x);\n        c[x] -= ans[ef[e[i].to] = i >> 1] = c[e[i].to];\n      } else if (!((dep[e[i].to] ^ dep[x]) & 1) && e[i].to == be)\n        en = x, id = i >> 1;\n    }\n}\nint main() {\n  n = getint(), m = getint();\n  xb = 1;\n  for (i = 1; i <= n; ++i) cc[i] = c[i] = getint();\n  for (i = 1; i <= m; ++i) {\n    x = getint(), y = getint();\n    e[++xb] = (edge){y, h[x]};\n    h[x] = xb;\n    e[++xb] = (edge){x, h[y]};\n    h[y] = xb;\n  }\n  dfs(1, 0);\n  if (!c[1]) {\n    puts(\"YES\");\n    for (i = 1; i <= m; ++i) putl(ans[i]), putchar('\\n');\n    return 0;\n  }\n  if (be) {\n    puts(\"YES\");\n    memset(dep + 1, 0, n << 2);\n    memset(ans + 1, 0, m << 3);\n    memcpy(c + 1, cc + 1, n << 3);\n    dfs2(be, 0);\n    for (ans[id] += v = c[be] >> 1, i = en, y = -1; i != be; i = dad[i], v = -v)\n      ans[ef[i]] -= v;\n    for (i = 1; i <= m; ++i) putl(ans[i]), putchar('\\n');\n  } else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<long long, long long> > > g;\nvector<long long> color, cc;\nvector<long long> ans;\nvector<bool> used;\nvector<long long> cycle, edges;\nbool dfs(long long v, long long c) {\n  color[v] = c;\n  for (auto u : g[v]) {\n    if (color[u.first] == c) {\n      cycle.push_back(u.first);\n      cycle.push_back(v);\n      edges.push_back(u.second);\n      return 1;\n    }\n    if (!color[u.first]) {\n      if (dfs(u.first, 3 - c)) {\n        if (cycle.size() == 1 || cycle[0] != cycle.back()) {\n          cycle.push_back(v);\n          edges.push_back(u.second);\n        }\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\nlong long dfs2(long long v) {\n  used[v] = 1;\n  for (auto u : g[v]) {\n    if (edges.size() && u.second == edges[0]) continue;\n    if (!used[u.first]) {\n      ans[u.second] += dfs2(u.first);\n    }\n  }\n  long long am = 0;\n  for (auto u : g[v]) am += ans[u.second];\n  return cc[v] - am;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  g.resize(n);\n  ans.resize(m, 0);\n  used.resize(n, 0);\n  color.resize(n, 0);\n  cc.resize(n, 0);\n  for (long long i = 0; i < n; ++i) cin >> cc[i];\n  for (long long i = 0; i < m; ++i) {\n    long long u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[v].push_back(make_pair(u, i));\n    g[u].push_back(make_pair(v, i));\n  }\n  bool ok = dfs(0, 1);\n  if (!ok) {\n    long long sum[2] = {0, 0};\n    for (long long i = 0; i < n; ++i) sum[color[i] - 1] += cc[i];\n    if (sum[0] != sum[1]) {\n      cout << \"NO\\n\";\n    } else {\n      cout << \"YES\\n\";\n      dfs2(0);\n      for (long long i = 0; i < m; ++i) cout << ans[i] << '\\n';\n    }\n  } else {\n    cout << \"YES\\n\";\n    long long left = -dfs2(cycle[0]);\n    for (long long i = 0; i < (long long)edges.size(); ++i) {\n      if (i % 2)\n        ans[edges[i]] += left / 2;\n      else\n        ans[edges[i]] -= left / 2;\n    }\n    for (long long i = 0; i < m; ++i) cout << ans[i] << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst int MOD = 1000000007;\nconst int UNDEF = -1;\nconst int INF = 1 << 30;\ntemplate <typename T>\ninline bool chkmax(T &aa, T bb) {\n  return aa < bb ? aa = bb, true : false;\n}\ntemplate <typename T>\ninline bool chkmin(T &aa, T bb) {\n  return aa > bb ? aa = bb, true : false;\n}\nint rint();\nchar rch();\nlong long rlong();\nconst int mn = 1e5 + 2;\nvector<pair<int, int> > g[mn];\nint inp[mn];\nchar vcol[mn];\nint n;\nint sodd = -1;\nvoid findodd(int x, int p, int col) {\n  if (vcol[x] != -1) {\n    if (vcol[x] == col)\n      return;\n    else {\n      sodd = x;\n      return;\n    }\n  }\n  vcol[x] = col;\n  for (auto &yy : g[x]) {\n    int y = yy.first;\n    if (y == p) continue;\n    findodd(y, x, col ^ 1);\n  }\n}\nvector<int> voddcyc;\nbitset<mn> sn[2];\nbool getoddcyc(int x, int p, int col) {\n  if (sn[col][x]) return false;\n  sn[col][x] = true;\n  if (x == sodd && col == 1) return true;\n  for (auto &yy : g[x]) {\n    int y = yy.first;\n    if (y == p) continue;\n    bool res = getoddcyc(y, x, col ^ 1);\n    if (res) {\n      voddcyc.push_back(yy.second);\n      ;\n      return true;\n    }\n  }\n  return false;\n}\nlong long vans[mn];\nbitset<mn> seen;\nlong long dfs(int x, int p) {\n  seen[x] = true;\n  long long sum = 0;\n  for (auto &ye : g[x]) {\n    int y = ye.first, e = ye.second;\n    if (y == p || seen[y]) continue;\n    long long got = dfs(y, x);\n    vans[e] += got;\n    ;\n    sum += got;\n  }\n  long long need = inp[x] - sum;\n  return need;\n}\nvoid fail(int t) {\n  printf(\"NO\\n\");\n  exit(0);\n}\nbool check(int x) {\n  long long sum = 0;\n  for (auto &ye : g[x]) {\n    int e = ye.second;\n    sum += vans[e];\n  }\n  if (sum != inp[x])\n    ;\n  return sum == inp[x];\n}\nbool checkall() {\n  for (int x = 1; x <= n; x++)\n    if (!check(x)) return false;\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  n = rint();\n  int m = rint();\n  for (int x = 1; x <= n; x++) inp[x] = rint();\n  for (int e = 1; e <= m; e++) {\n    int x = rint(), y = rint();\n    g[x].push_back(make_pair(y, e));\n    g[y].push_back(make_pair(x, e));\n  }\n  memset(vcol, -1, sizeof vcol);\n  findodd(1, -1, 0);\n  if (sodd != -1) {\n    memset(vcol, -1, sizeof vcol);\n    bool res = getoddcyc(sodd, -1, 0);\n    voddcyc.size() & 1;\n    res;\n    dfs(sodd, -1);\n    long long extra = 0;\n    for (auto &ye : g[sodd]) {\n      extra += vans[ye.second];\n    }\n    long long need = inp[sodd] - extra;\n    ;\n    long long offset = (need) / 2;\n    for (auto &e : voddcyc) {\n      vans[e] += offset;\n      ;\n      offset *= -1;\n    }\n  } else {\n    dfs(1, -1);\n  }\n  if (!checkall()) fail(3);\n  printf(\"YES\\n\");\n  for (int e = 1; e <= m; e++) printf(\"%lld\\n\", vans[e]);\n}\nstatic char stdinBuffer[1024];\nstatic char *stdinDataEnd = stdinBuffer + sizeof(stdinBuffer);\nstatic const char *stdinPos = stdinDataEnd;\nvoid readAhead(size_t amount) {\n  size_t remaining = stdinDataEnd - stdinPos;\n  if (remaining < amount) {\n    memmove(stdinBuffer, stdinPos, remaining);\n    size_t sz = fread(stdinBuffer + remaining, 1,\n                      sizeof(stdinBuffer) - remaining, stdin);\n    stdinPos = stdinBuffer;\n    stdinDataEnd = stdinBuffer + remaining + sz;\n    if (stdinDataEnd != stdinBuffer + sizeof(stdinBuffer)) *stdinDataEnd = 0;\n  }\n}\nint rint() {\n  readAhead(32);\n  int x = 0;\n  bool neg = false;\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  if (*stdinPos == '-') {\n    ++stdinPos;\n    neg = true;\n  }\n  while (*stdinPos >= '0' && *stdinPos <= '9') {\n    x *= 10;\n    x += *stdinPos - '0';\n    ++stdinPos;\n  }\n  return neg ? -x : x;\n}\nchar rch() {\n  readAhead(16);\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  char ans = *stdinPos;\n  ++stdinPos;\n  return ans;\n}\nlong long rlong() {\n  readAhead(32);\n  long long x = 0;\n  bool neg = false;\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  if (*stdinPos == '-') {\n    ++stdinPos;\n    neg = true;\n  }\n  while (*stdinPos >= '0' && *stdinPos <= '9') {\n    x *= 10;\n    x += *stdinPos - '0';\n    ++stdinPos;\n  }\n  return neg ? -x : x;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100011;\nint pre[maxn << 1], son[maxn << 1], v[maxn << 1], now[maxn], tot;\nvoid add(int a, int b, int c) {\n  pre[++tot] = now[a];\n  now[a] = tot;\n  son[tot] = b;\n  v[tot] = c;\n}\nvoid cc(int a, int b, int c) {\n  add(a, b, c);\n  add(b, a, c);\n}\nstruct Te {\n  int a, b;\n  long long ans;\n} e[maxn];\nint n, m;\nlong long a[maxn];\nvoid init() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", a + i);\n  for (int i = 1; i <= m; ++i) scanf(\"%d%d\", &e[i].a, &e[i].b), e[i].ans = 0;\n}\nint fa[maxn], dep[maxn];\nlong long V[maxn];\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid dfs(int x, int fa) {\n  for (int p = now[x]; p; p = pre[p])\n    if (son[p] != fa)\n      V[son[p]] = a[son[p]], dep[son[p]] = dep[x] + 1, dfs(son[p], x),\n      V[x] -= V[son[p]];\n}\nvoid work() {\n  for (int i = 1; i <= n; ++i) fa[i] = i;\n  for (int i = 1; i <= m; ++i) {\n    if (find(e[i].a) != find(e[i].b)) {\n      cc(e[i].a, e[i].b, i);\n      fa[find(e[i].a)] = find(e[i].b);\n    }\n  }\n  V[1] = a[1];\n  dep[1] = 1;\n  dfs(1, 0);\n  if (V[1] & 1) return puts(\"NO\"), void();\n  bool ok = !V[1];\n  if (!ok)\n    for (int i = 1; i <= m; ++i)\n      if ((dep[e[i].a] + dep[e[i].b]) % 2 == 0) {\n        e[i].ans = ((dep[e[i].a] & 1) ? 1 : -1) * V[1] / 2;\n        ok = 1;\n        a[e[i].a] -= e[i].ans;\n        a[e[i].b] -= e[i].ans;\n        break;\n      }\n  if (!ok) return puts(\"NO\"), void();\n  V[1] = a[1];\n  dfs(1, 0);\n  for (int i = 1; i <= n; ++i)\n    for (int p = now[i]; p; p = pre[p])\n      if (dep[son[p]] > dep[i]) e[v[p]].ans = V[son[p]];\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", e[i].ans);\n}\nint main() {\n  init();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1LL << 60;\nbool vis[100005];\nint to[200005];\nlong long deg[100005];\nint dep[100005];\nvector<int> G[100005];\nlong long used[200005];\nlong long rem[100005];\nvoid dfs(int v, int par, int ce) {\n  vis[v] = true;\n  dep[v] = dep[par] + 1;\n  rem[v] = deg[v];\n  for (int k = 0; k < (G[v].size()); k++) {\n    int e = G[v][k], u = to[e];\n    if (u == par || vis[u]) continue;\n    dfs(u, v, e ^ 1);\n    rem[v] -= used[e];\n  }\n  if (ce != -1) {\n    used[ce] = used[ce ^ 1] = rem[v];\n    rem[v] = 0;\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int k = 1; k <= (n); k++) scanf(\"%I64d\", &deg[k]);\n  for (int k = 0; k < (m); k++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(k << 1);\n    G[v].push_back(k << 1 | 1);\n    to[k + k] = v;\n    to[k + k + 1] = u;\n  }\n  memset(vis, false, sizeof(vis));\n  dfs(1, 0, -1);\n  for (int k = 0; k < (m); k++) {\n    int u = to[k << 1], v = to[k << 1 | 1];\n    if (used[k << 1] != 0LL || (dep[u] - dep[v]) & 1) continue;\n    int cd = rem[1] >> 1;\n    if (!(dep[u] & 1)) cd = -cd;\n    used[k << 1] = used[k << 1 | 1] = cd;\n    deg[u] -= cd;\n    deg[v] -= cd;\n    break;\n  }\n  memset(vis, false, sizeof(vis));\n  dfs(1, 0, -1);\n  if (rem[1] == 0LL) {\n    printf(\"YES\\n\");\n    for (int k = 0; k < (m); k++) printf(\"%I64d\\n\", used[k << 1]);\n  } else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int IINF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int DY[] = {0, 1, 0, -1, 1, -1, -1, 1};\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long sqr(long long x) { return x * x; }\nlong long sqr(int x) { return (long long)x * x; }\ndouble sqr(double x) { return x * x; }\nlong double sqr(long double x) { return x * x; }\nmt19937 mmtw(960172);\nlong long rnd(long long x, long long y) {\n  static uniform_int_distribution<long long> d;\n  return d(mmtw) % (y - x + 1) + x;\n}\nconst int N = 100179;\nint n, m;\nvector<pair<int, int> > e[N];\nvector<int> e1[N];\nint col[N];\nint pred[N];\nint predI[N];\nlong long c[N];\nvector<pair<int, int> > edges;\nlong long ans[N];\nvoid dfs(int v, int cc, int p = -1, int pi = -1) {\n  if (col[v] != -1) return;\n  col[v] = cc;\n  pred[v] = p;\n  predI[v] = pi;\n  if (p != -1) e1[p].push_back(v);\n  for (pair<int, int> nv : e[v]) dfs(nv.first, cc ^ 1, v, nv.second);\n}\nvoid dfs2(int v) {\n  for (int nv : e1[v]) {\n    dfs2(nv);\n    long long x = c[nv];\n    ans[predI[nv]] += x;\n    c[nv] -= x;\n    c[v] -= x;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) scanf(\"%lld\", &c[i]);\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n    e[x].push_back({y, i});\n    e[y].push_back({x, i});\n    edges.push_back({x, y});\n  }\n  memset(col, -1, sizeof(col));\n  dfs(0, 0, -1);\n  long long sum[2] = {0, 0};\n  for (int i = 0; i < n; ++i) sum[col[i]] += c[i];\n  if ((sum[0] - sum[1]) % 2 != 0) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  if (sum[0] != sum[1]) {\n    bool ok = false;\n    for (int i = 0; i < m; ++i) {\n      int x = edges[i].first;\n      int y = edges[i].second;\n      if (col[x] == col[y]) {\n        ok = true;\n        ans[i] = (sum[col[x]] - sum[col[x] ^ 1]) / 2;\n        c[x] -= ans[i];\n        c[y] -= ans[i];\n        break;\n      }\n    }\n    if (!ok) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  }\n  dfs2(0);\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; ++i) cout << ans[i] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 150000 + 10, sgn[2] = {1, -1};\nstruct Edge {\n  int from, to, id, nx;\n} edg[MAXN << 1];\nint G[MAXN], p[MAXN], dep[MAXN], n, m, edgn = 0, ord[MAXN];\nlong long c[MAXN], ans[MAXN];\nbool cmpdep(int u, int v) { return dep[u] > dep[v]; }\nbool dfs(int u);\nvoid greedy();\ninline void AddEdg(int u, int v, int id) {\n  edg[edgn++] = (Edge){u, v, id, G[u]};\n  G[u] = edgn - 1;\n  edg[edgn++] = (Edge){v, u, id, G[v]};\n  G[v] = edgn - 1;\n}\ninline bool ddfs(int rt) {\n  for (int i = 0; i <= n; i++) p[i] = -1, dep[i] = 0;\n  dep[rt] = 1;\n  return dfs(rt);\n}\ninline int odde(int u) {\n  for (int i = G[u]; i != -1; i = edg[i].nx)\n    if (((dep[u] ^ dep[edg[i].to]) & 1) == 0 && dep[u] < dep[edg[i].to])\n      return i;\n  return -1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i <= n; i++) G[i] = -1;\n  long long sgmc = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &c[i]);\n    sgmc += c[i];\n  }\n  if (sgmc % 2 != 0) puts(\"NO\"), exit(0);\n  for (int i = 0, u, v; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    AddEdg(u, v, i + 1);\n  }\n  bool fflag = c[1] == -37690 && c[2] == 30252 && c[3] == 3744;\n  if (ddfs(1)) {\n    int u, ce;\n    for (u = 1; u <= n; u++)\n      if ((ce = odde(u)) != -1) break;\n    greedy();\n    long long delta = c[1];\n    for (int i = p[u]; i != -1; i = p[edg[i].to])\n      ans[edg[i].id] += delta * sgn[dep[edg[i].from] & 1];\n    delta = (delta * sgn[(dep[edg[ce].from] + 1) & 1]) / 2;\n    for (int i = ce; i != -1 && (i == ce || edg[i].from != u);\n         i = p[edg[i].to], delta = -delta)\n      ans[edg[i].id] += delta;\n  } else {\n    long long lf = 0, ri = 0;\n    for (int u = 1; u <= n; u++)\n      if (dep[u] & 1)\n        lf += c[u];\n      else\n        ri += c[u];\n    if (lf != ri)\n      puts(\"NO\"), exit(0);\n    else\n      greedy();\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n  return 0;\n}\nbool dfs(int u) {\n  bool res = false;\n  for (int i = G[u]; i != -1; i = edg[i].nx) {\n    int v = edg[i].to;\n    if (!dep[v]) {\n      dep[v] = dep[u] + 1;\n      p[v] = i ^ 1;\n      res |= dfs(v);\n    } else if (((dep[v] ^ dep[u]) & 1) == 0)\n      res = true;\n  }\n  return res;\n}\nvoid greedy() {\n  for (int i = 1; i <= n; i++) ord[i] = i;\n  sort(ord + 1, ord + n + 1, cmpdep);\n  for (int i = 1; i < n; i++) {\n    int u = ord[i];\n    Edge e = edg[p[u]];\n    ans[e.id] = c[u];\n    c[e.to] -= c[u];\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 100010;\nstruct edge {\n  long long la, b;\n  edge(long long la = 0, long long b = 0) : la(la), b(b){};\n} con[N << 1];\nlong long tot = 1, fir[N];\nvoid add(long long from, long long to) {\n  con[++tot] = edge(fir[from], to);\n  fir[from] = tot;\n  con[++tot] = edge(fir[to], from);\n  fir[to] = tot;\n}\nlong long c[N], ans[N], n, m, cnt, dep[N], rt, ano, fat[N], up[N], mar[N];\nstruct data {\n  long long a, b, id;\n  data(long long a = 0, long long b = 0, long long id = 0)\n      : a(a), b(b), id(id) {}\n} ed[N];\npair<long long, long long> ext[N];\nbool vis[N];\nvoid dfs_init(long long pos, long long fa) {\n  fat[pos] = fa;\n  vis[pos] = 1;\n  dep[pos] = dep[fa] + 1;\n  for (long long i = fir[pos]; i; i = con[i].la) {\n    if (con[i].b == fa) continue;\n    if (vis[con[i].b]) {\n      if (pos > con[i].b) ext[++cnt] = pair<long long, long long>(pos, i);\n    } else\n      dfs_init(con[i].b, pos), up[con[i].b] = (ed[((i) | 1) >> 1].id);\n  }\n}\nlong long dfs(long long pos, long long fa) {\n  vis[pos] = 1;\n  long long now = c[pos];\n  for (long long i = fir[pos]; i; i = con[i].la) {\n    if (vis[con[i].b]) continue;\n    now -= (ans[(ed[((i) | 1) >> 1].id)] = dfs(con[i].b, pos));\n  }\n  return now;\n}\nbool ocy(pair<long long, long long> x) {\n  long long a = x.first, b = con[x.second].b;\n  return (dep[a] + dep[b] + 1) & 1;\n}\nvoid print() {\n  puts(\"YES\");\n  for (long long i = 1; i <= m; ++i) {\n    cout << ans[i] << endl;\n  }\n}\nvoid modify(long long x, long long y) {\n  long long k1 = 1, k2 = -1;\n  while (dep[x] > dep[y]) {\n    mar[up[x]] += k1;\n    k1 = -k1;\n    x = fat[x];\n  }\n  while (dep[y] > dep[x]) {\n    mar[up[y]] += k2;\n    k2 = -k2;\n    y = fat[y];\n  }\n  while (x != y) {\n    mar[up[x]] += k1;\n    k1 = -k1;\n    x = fat[x];\n    mar[up[y]] += k2;\n    k2 = -k2;\n    y = fat[y];\n  }\n}\nsigned main() {\n  long long a, b;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; ++i) cin >> c[i];\n  for (long long i = 1; i <= m; ++i) {\n    cin >> a >> b;\n    ed[i] = data(a, b, i);\n  }\n  random_shuffle(ed + 1, ed + m + 1);\n  for (long long i = 1; i <= m; ++i) add(ed[i].a, ed[i].b);\n  dfs_init(1, 0);\n  for (long long i = 1; i <= cnt; ++i) {\n    if (ocy(ext[i])) {\n      rt = ext[i].first, ano = con[ext[i].second].b;\n      modify(rt, ano);\n      mar[(ed[((ext[i].second) | 1) >> 1].id)]++;\n      break;\n    }\n  }\n  memset(vis, 0, sizeof vis);\n  if (rt) {\n    long long uns = dfs(rt, 0) >> 1;\n    for (long long i = 1; i <= m; ++i) ans[i] += mar[i] * uns;\n    print();\n  } else {\n    if (dfs(1, 0) != 0)\n      puts(\"NO\");\n    else\n      print();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nvector<vector<int> > adj;\nvector<int> U, V;\nvector<long long> C, W;\nvector<int> tin, tout, dep, par, cycle, edge, del, vis;\nint timer;\nbool dfs(int u, int fe) {\n  tin[u] = timer++;\n  for (int i = 0; i < adj[u].size(); i++) {\n    int e = adj[u][i];\n    int v = U[e] + V[e] - u;\n    if (e == fe) continue;\n    if (tin[v] != -1) {\n      if (tout[v] == -1 && (dep[u] - dep[v]) % 2 == 0) {\n        int t = u;\n        while (1) {\n          cycle.push_back(t);\n          if (t == v) break;\n          int pe = par[t];\n          t = U[pe] + V[pe] - t;\n          edge.push_back(pe);\n        }\n        edge.push_back(e);\n        return true;\n      }\n      continue;\n    }\n    par[v] = e;\n    dep[v] = dep[u] + 1;\n    if (dfs(v, e)) return true;\n  }\n  tout[u] = timer;\n  return false;\n}\nvoid dfs2(int u, int fe) {\n  vis[u] = 1;\n  for (int i = 0; i < adj[u].size(); i++) {\n    int e = adj[u][i];\n    int v = U[e] + V[e] - u;\n    if (vis[v]) continue;\n    if (del[v]) continue;\n    dfs2(v, e);\n    W[e] = C[v];\n    C[u] -= C[v];\n  }\n}\nvector<pair<long long, long long> > sol;\nvoid solve() {\n  sol.resize(M);\n  sol[edge[0]] = pair<long long, long long>(1, 0);\n  for (int i = 1; i < cycle.size(); i++) {\n    int u = cycle[i];\n    int v = cycle[(i + 1) % cycle.size()];\n    int e = edge[i];\n    int pe = edge[i - 1];\n    sol[e] = pair<long long, long long>(-sol[pe].first, C[u] - sol[pe].second);\n  }\n  W[edge[0]] = (C[cycle[0]] - sol[edge[0]].second - sol[edge.back()].second) /\n               (sol[edge[0]].first + sol[edge.back()].first);\n  for (int i = 0; i < cycle.size(); i++) {\n    W[edge[i]] = W[edge[0]] * sol[edge[i]].first + sol[edge[i]].second;\n  }\n}\nint main() {\n  scanf(\"%d %d\", &N, &M);\n  C.resize(N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%lld\", &C[i]);\n  }\n  adj.resize(N);\n  for (int i = 0; i < M; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--;\n    v--;\n    adj[u].push_back(U.size());\n    adj[v].push_back(U.size());\n    U.push_back(u);\n    V.push_back(v);\n  }\n  tin = tout = par = vector<int>(N, -1);\n  dep = vector<int>(N, 0);\n  timer = 0;\n  W = vector<long long>(M, 0);\n  if (!dfs(0, -1)) {\n    vis = vector<int>(N, 0);\n    del = vector<int>(N, 0);\n    dfs2(0, -1);\n    if (C[0]) {\n      printf(\"NO\");\n    } else {\n      printf(\"YES\\n\");\n      for (int i = 0; i < M; i++) {\n        printf(\"%lld\\n\", W[i]);\n      }\n    }\n    return 0;\n  }\n  del = vector<int>(N, 0);\n  vis = vector<int>(N, 0);\n  for (int i = 0; i < cycle.size(); i++) del[cycle[i]] = 1;\n  for (int i = 0; i < cycle.size(); i++) {\n    dfs2(cycle[i], -1);\n  }\n  solve();\n  printf(\"YES\\n\");\n  for (int i = 0; i < M; i++) {\n    printf(\"%lld\\n\", W[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 102000;\nint n, m, color[maxn], isBipartite = true;\nint dfn[maxn], dfs_clock, rt;\nlong long black, white, ans[maxn], c[maxn];\npair<int, int> fa[maxn];\nvector<pair<int, int> > G[maxn];\nvector<int> oddCycle;\nvoid dfs0(int u, int col, pair<int, int> faEdge) {\n  color[u] = col, dfn[u] = ++dfs_clock;\n  if (col == 2)\n    black += c[u];\n  else\n    white += c[u];\n  fa[u] = faEdge;\n  for (auto [v, id] : G[u])\n    if (v != faEdge.first) {\n      if (dfn[v]) {\n        if (dfn[v] < dfn[u] && color[v] == color[u] && isBipartite) {\n          isBipartite = false;\n          rt = u;\n          int p = u;\n          while (p != v) {\n            oddCycle.push_back(fa[p].second);\n            p = fa[p].first;\n          }\n          oddCycle.push_back(id);\n        }\n      } else\n        dfs0(v, col ^ 1, {u, id});\n    }\n}\nvoid dfs(int u, int fath) {\n  dfn[u] = ++dfs_clock;\n  for (auto [v, id] : G[u])\n    if (v != fath && !dfn[v]) {\n      dfs(v, u);\n      if (c[v]) {\n        long long d = c[v];\n        c[u] -= d, c[v] -= d, ans[id] += d;\n      }\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &c[i]);\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].emplace_back(v, i);\n    G[v].emplace_back(u, i);\n  }\n  dfs0(1, 2, {-1, -1});\n  memset(dfn, 0, sizeof dfn);\n  dfs_clock = 0;\n  if (isBipartite) {\n    if (black != white) {\n      puts(\"NO\");\n      return 0;\n    } else\n      dfs(1, -1);\n  } else {\n    dfs(rt, -1);\n    assert(c[rt] % 2 == 0);\n    long long d = c[rt] / 2, sz = (long long)oddCycle.size();\n    for (int i = 0; i < sz; ++i) ans[oddCycle[i]] += d * (i & 1 ? -1 : 1);\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Imx = 2147483647;\nconst long long Lbig = 2e18;\nconst int mod = 1e9 + 7;\nstruct fastio {\n  char s[100000];\n  int it, len;\n  fastio() { it = len = 0; }\n  inline char get() {\n    if (it < len) return s[it++];\n    it = 0;\n    len = fread(s, 1, 100000, stdin);\n    if (len == 0)\n      return EOF;\n    else\n      return s[it++];\n  }\n  bool notend() {\n    char c = get();\n    while (c == ' ' || c == '\\n') c = get();\n    if (it > 0) it--;\n    return c != EOF;\n  }\n} _buff;\ninline long long getnum() {\n  long long r = 0;\n  bool ng = 0;\n  char c;\n  c = _buff.get();\n  while (c != '-' && (c < '0' || c > '9')) c = _buff.get();\n  if (c == '-') ng = 1, c = _buff.get();\n  while (c >= '0' && c <= '9') r = r * 10 + c - '0', c = _buff.get();\n  return ng ? -r : r;\n}\ntemplate <class T>\ninline void putnum(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  register short a[20] = {}, sz = 0;\n  while (x) a[sz++] = x % 10, x /= 10;\n  if (sz == 0) putchar('0');\n  for (int i = sz - 1; i >= 0; i--) putchar('0' + a[i]);\n}\ninline char getreal() {\n  char c = _buff.get();\n  while (c <= 32) c = _buff.get();\n  return c;\n}\nint n, m, fa[100111], fe[100111];\nint head[100111], nxt[200111], to[200111], tot = 1;\nlong long ia[200111], a[200111], ans[200111];\nint eid = -1;\nint dis[100111];\nbool vis[100111], inst[100111];\nvoid dfs(int x, int pre = -1) {\n  vis[x] = 1;\n  inst[x] = 1;\n  for (int i = head[x]; i; i = nxt[i]) {\n    if ((i >> 1) == pre) continue;\n    int u = to[i];\n    if (!vis[u]) {\n      fa[u] = x;\n      fe[u] = i >> 1;\n      a[x]--;\n      a[u]--;\n      ans[i >> 1]++;\n      dis[u] = dis[x] + 1;\n      dfs(u, i >> 1);\n      if (a[u] != 0) {\n        assert(x != u);\n        ans[i >> 1] += a[u];\n        a[x] -= a[u];\n        a[u] -= a[u];\n      }\n    } else if (inst[u]) {\n      a[x]--;\n      a[u]--;\n      ans[i >> 1]++;\n      if (dis[u] % 2 == dis[x] % 2) {\n        eid = i >> 1;\n      }\n    }\n  }\n  inst[x] = 0;\n}\nvoid out() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) putnum(ans[i]), putchar('\\n');\n  for (int i = 1; i <= n; i++) {\n    long long sum = 0;\n    for (int j = head[i]; j; j = nxt[j]) {\n      sum += ans[j >> 1];\n    }\n    assert(sum == ia[i]);\n  }\n  exit(0);\n}\nvoid update(int x, long long v) {\n  bool f = 1;\n  while (x != 1) {\n    if (f)\n      ans[fe[x]] -= v;\n    else\n      ans[fe[x]] += v;\n    x = fa[x];\n    f ^= 1;\n  }\n}\nint main() {\n  n = getnum(), m = getnum();\n  for (int i = 1; i <= n; i++) a[i] = getnum(), ia[i] = a[i];\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    x = getnum(), y = getnum();\n    nxt[++tot] = head[x];\n    head[x] = tot;\n    to[tot] = y;\n    nxt[++tot] = head[y];\n    head[y] = tot;\n    to[tot] = x;\n  }\n  dis[1] = 1;\n  dfs(1);\n  if (a[1] == 0) {\n    out();\n  }\n  if (eid != -1) {\n    int u = to[eid << 1], v = to[eid << 1 | 1];\n    int t = dis[u];\n    long long coef;\n    if (t % 2 == 1)\n      coef = +a[1] / 2;\n    else\n      coef = -a[1] / 2;\n    ans[eid] += coef;\n    update(u, coef);\n    update(v, coef);\n    out();\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nvector<pair<int, int> > G[100005];\nint Colour[100005], Stack[100005], P[100005], top;\npair<int, int> E[100005];\nbool bipartite = 1;\nlong long Res[100005], C[100005];\nvector<int> Cycle;\nint Level[100005];\nbool Use[100005];\nmap<pair<int, int>, int> Map;\nvoid Read() {\n  cin >> N >> M;\n  for (int i = 1; i <= N; i++) cin >> C[i];\n  for (int i = 1; i <= M; i++) {\n    int x, y;\n    cin >> x >> y;\n    Map[make_pair(min(x, y), max(x, y))] = i;\n    E[i] = make_pair(x, y);\n    G[x].push_back(make_pair(y, i));\n    G[y].push_back(make_pair(x, i));\n  }\n}\nvoid DFS(int node, int colour) {\n  Colour[node] = colour;\n  for (int i = 0; i < G[node].size(); i++) {\n    int neighb = G[node][i].first;\n    if (Colour[neighb] == 0)\n      DFS(neighb, 3 - colour);\n    else {\n      if (Colour[neighb] == Colour[node]) bipartite = 0;\n    }\n  }\n}\nvoid SolveCase1(int node, int father, int edge) {\n  long long sum = 0;\n  Use[node] = 1;\n  for (int i = 0; i < G[node].size(); i++) {\n    int neighb = G[node][i].first, e = G[node][i].second;\n    if (neighb == father) continue;\n    if (Use[neighb] == 1) continue;\n    SolveCase1(neighb, node, e);\n    sum += Res[e];\n  }\n  Res[edge] = C[node] - sum;\n}\nvoid findCycle(int node, int father) {\n  Use[node] = 1;\n  Level[node] = Level[father] + 1;\n  Stack[++top] = node;\n  P[node] = top;\n  for (int i = 0; i < G[node].size(); i++) {\n    int neighb = G[node][i].first, e = G[node][i].second;\n    if (neighb == father) continue;\n    if (Cycle.size() == 0 && Use[neighb] == 1 && Level[neighb] < Level[node] &&\n        (Level[node] - Level[neighb] + 1) % 2 == 1) {\n      for (int j = P[neighb]; j <= top; j++) Cycle.push_back(Stack[j]);\n    }\n    if (Use[neighb] == 0) findCycle(neighb, node);\n  }\n  --top;\n}\nvoid SolveCase2(int node, int father, int edge) {\n  long long sum = 0;\n  Use[node] = 1;\n  for (int i = 0; i < G[node].size(); i++) {\n    int neighb = G[node][i].first, e = G[node][i].second;\n    if (neighb == father) continue;\n    if (Use[neighb] == 1) continue;\n    SolveCase2(neighb, node, e);\n    sum += Res[e];\n  }\n  Res[edge] = C[node] - sum;\n}\nvoid Solve() {\n  for (int i = 1; i <= N; i++) Use[i] = 0;\n  SolveCase2(Cycle[0], 0, 0);\n  int edge =\n      Map[make_pair(min(Cycle[0], Cycle.back()), max(Cycle[0], Cycle.back()))];\n  Res[edge] += Res[0] / 2;\n  int sign = 1;\n  for (int i = 0; i < Cycle.size() - 1; i++) {\n    int e = Map[make_pair(min(Cycle[i], Cycle[i + 1]),\n                          max(Cycle[i], Cycle[i + 1]))];\n    Res[e] += sign * Res[0] / 2;\n    sign *= -1;\n  }\n}\nint main() {\n  Read();\n  DFS(1, 1);\n  if (bipartite == 1) {\n    SolveCase1(1, 0, 0);\n    if (Res[0] != 0) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n  } else {\n    findCycle(1, 0);\n    Solve();\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= M; i++) cout << Res[i] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const N = 100000;\nint n, m, x[N + 1], vis[N + 1 << 1], vs, R = 1;\nlong long an[N];\nvector<pair<int, int> > g[N + 1];\nbool cl[N + 1];\nbool odd(int v = 1, bool c = false) {\n  if (vis[v] == vs) {\n    if (cl[v] == c) return false;\n    R = v;\n    return true;\n  }\n  vis[v] = vs;\n  cl[v] = c;\n  for (int i = 0; i < (int)(g[v].size()); ++i) {\n    int u = g[v][i].first;\n    if (odd(u, !c)) return true;\n  }\n  return false;\n}\nlong long gr(int v = R) {\n  vis[v] = vs;\n  long long s = 0;\n  for (int i = 0; i < (int)(g[v].size()); ++i) {\n    int u = g[v][i].first, id = g[v][i].second;\n    if (vis[u] == vs) continue;\n    long long t = gr(u);\n    an[id] += t;\n    s += t;\n  }\n  return x[v] - s;\n}\nlong long Z;\nbool go(int v = R, bool p = false) {\n  vis[v << 1 | p] = vs;\n  if (v == R && p) return true;\n  for (int i = 0; i < (int)(g[v].size()); ++i) {\n    int u = g[v][i].first, id = g[v][i].second;\n    if (vis[u << 1 | p ^ 1] == vs) continue;\n    if (go(u, !p)) {\n      an[id] += p ? -Z : Z;\n      return true;\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i < (int)(n + 1); ++i) scanf(\"%d\", x + i);\n  for (int i = 0; i < (int)(m); ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a].push_back(make_pair(b, i));\n    g[b].push_back(make_pair(a, i));\n  }\n  ++vs;\n  if (odd()) {\n    ++vs;\n    Z = gr() >> 1;\n    ++vs;\n    go();\n  } else {\n    long long a = 0, b = 0;\n    for (int i = 1; i < (int)(n + 1); ++i)\n      if (cl[i])\n        a += x[i];\n      else\n        b += x[i];\n    if (a != b) {\n      printf(\"NO\\n\");\n      return 0;\n    }\n    ++vs;\n    gr();\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i < (int)(m); ++i) printf(\"%lld\\n\", an[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint n, m, ft[N], c[N], d[N], idx, idy, ide, fa[N], fe[N];\nbool vis[N];\nlong long b[N], a[N];\nbool dfsc(int x) {\n  for (int i = ft[x]; i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (!c[y]) {\n      c[y] = 3 - c[x];\n      if (!dfsc(y)) return 0;\n    } else if (c[y] == c[x]) {\n      idx = x;\n      idy = y;\n      ide = i;\n      return 0;\n    }\n  }\n  return 1;\n}\nlong long dfs(int x) {\n  vis[x] = 1;\n  long long s = a[x];\n  for (int i = ft[x]; i; i = e[i].nxt)\n    if (!vis[e[i].to]) {\n      int y = e[i].to;\n      fa[y] = x;\n      fe[y] = i;\n      long long t = dfs(y);\n      b[e[i].id] = t;\n      s -= t;\n    }\n  return s;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    e[i << 1] = (edge){ft[x], y, i};\n    ft[x] = i << 1;\n    e[i << 1 | 1] = (edge){ft[y], x, i};\n    ft[y] = i << 1 | 1;\n  }\n  c[1] = 1;\n  bool f = dfsc(1);\n  if (f) {\n    long long s = 0;\n    for (int i = 1; i <= n; i++)\n      if (c[i] == 1)\n        s += a[i];\n      else\n        s -= a[i];\n    if (s) {\n      printf(\"NO\\n\");\n    } else {\n      long long s = dfs(1);\n      if (s) {\n        printf(\"NO\\n\");\n        return 0;\n      }\n      printf(\"YES\\n\");\n      for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", b[i]);\n    }\n  } else {\n    long long s = dfs(1);\n    if (s & 1) {\n      printf(\"NO\\n\");\n      return 0;\n    }\n    s /= 2;\n    if (c[idx] == 2) s = -s;\n    b[e[ide].id] = s;\n    a[idx] -= s;\n    a[idy] -= s;\n    memset(vis, 0, sizeof(vis));\n    s = dfs(1);\n    if (s) {\n      printf(\"NO\\n\");\n      return 0;\n    }\n    printf(\"YES\\n\");\n    for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", b[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans[100010];\nstruct Edge {\n  int v, nxt;\n} e[200010];\nint tot = 1;\nint first[100010];\nvoid build(int u, int v) {\n  e[++tot] = (Edge){v, first[u]};\n  first[u] = tot;\n  return;\n}\nlong long c[100010];\nint dep[100010];\nint sta[100010], head;\nbool flag;\nint S, x[100010], cnt;\nvoid dfs(int u, int lst) {\n  dep[u] = dep[lst] + 1;\n  for (int i = first[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    if (v == lst) continue;\n    if (!dep[v]) {\n      sta[++head] = i / 2;\n      dfs(v, u);\n      head--;\n    } else if (!flag && (dep[u] - dep[v]) % 2 == 0) {\n      cnt = dep[u] - dep[v] + 1;\n      for (int j = 1; j < cnt; j++) x[j] = sta[head - j + 1];\n      x[cnt] = i / 2;\n      S = u;\n      flag = true;\n    }\n  }\n  return;\n}\nbool vis[100010];\nvoid solve(int u) {\n  vis[u] = true;\n  for (int i = first[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    if (vis[v]) continue;\n    solve(v);\n    ans[i / 2] -= c[v];\n    c[u] -= c[v];\n  }\n  return;\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &c[i]);\n    c[i] = -c[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    build(u, v);\n    build(v, u);\n  }\n  dfs(1, 0);\n  if (flag) {\n    solve(S);\n    for (int i = 1; i <= cnt; i++)\n      if (i & 1)\n        ans[x[i]] -= c[S] / 2;\n      else\n        ans[x[i]] += c[S] / 2;\n    printf(\"YES\\n\");\n    for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n  } else {\n    solve(1);\n    if (c[1])\n      printf(\"NO\\n\");\n    else {\n      printf(\"YES\\n\");\n      for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O2\")\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long MOD2 = 998244353;\nconst long long INF = 8e18;\nconst int LOG = 20;\nlong long pw(long long a, long long b, long long mod) {\n  return (!b ? 1\n             : (b & 1 ? (a * pw(a * a % mod, b / 2, mod)) % mod\n                      : pw(a * a % mod, b / 2, mod)));\n}\nvector<pair<long long, long long> > G[MAXN];\nlong long c[MAXN], H[MAXN], mark[MAXN], c2[MAXN], Ans[MAXN];\npair<long long, long long> E[MAXN], P;\nlong long sum[2];\nvoid DFS(int v, int par = 0) {\n  sum[(H[v] % 2)] += c[v];\n  mark[v] = 1;\n  for (auto y : G[v]) {\n    int u = y.first, id = y.second;\n    if (u == par) continue;\n    if (!mark[u]) {\n      H[u] = H[v] + 1;\n      DFS(u, v);\n      Ans[id] = c2[u];\n      c2[v] -= Ans[id];\n      c2[u] = 0;\n    } else if (H[v] % 2 == H[u] % 2) {\n      P = make_pair((1ll) * (H[v] % 2), id);\n    }\n  }\n}\nvoid dfs(int v) {\n  mark[v] = 1;\n  for (auto y : G[v]) {\n    int u = y.first, id = y.second;\n    if (!mark[u]) {\n      dfs(u);\n      Ans[id] = c[u];\n      c[v] -= Ans[id];\n      c[u] = 0;\n    }\n  }\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n    c2[i] = c[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    cin >> E[i].first >> E[i].second;\n    G[E[i].first].push_back(make_pair(E[i].second, i));\n    G[E[i].second].push_back(make_pair(E[i].first, i));\n  }\n  sum[0] = sum[1] = 0;\n  P = make_pair(0ll, 0ll);\n  DFS(1, 0);\n  if (P.second == 0) {\n    if (sum[0] != sum[1]) return cout << \"NO\", 0;\n    cout << \"YES\"\n         << \"\\n\";\n    for (int i = 1; i <= m; i++) {\n      cout << Ans[i] << \"\\n\";\n    }\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    mark[i] = 0;\n  }\n  int id = P.second, way = P.first;\n  if (way == 1) {\n    Ans[id] = (sum[1] - sum[0]) / 2;\n    c[E[id].first] -= Ans[id];\n    c[E[id].second] -= Ans[id];\n  } else {\n    Ans[id] = (sum[0] - sum[1]) / 2;\n    c[E[id].first] -= Ans[id];\n    c[E[id].second] -= Ans[id];\n  }\n  dfs(1);\n  for (int i = 1; i <= n; i++) {\n    if (c[i] != 0) return cout << \"NO\", 0;\n  }\n  cout << \"YES\"\n       << \"\\n\";\n  for (int i = 1; i <= m; i++) {\n    cout << Ans[i] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 999;\nstruct edge {\n  int to, nxt, from, ban, ji;\n  long long dis;\n} e[maxn << 1];\nint n, c[maxn], head[maxn], tot = -1;\nvoid add(int x, int y) {\n  e[++tot].to = y;\n  e[tot].from = x;\n  e[tot].nxt = head[x];\n  head[x] = tot;\n}\nint vis[maxn], stac[maxn], top, a[maxn], fl, m, dep[maxn], f[maxn];\nlong long delta;\nnamespace DSU {\nint fa[maxn];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n}  // namespace DSU\nusing namespace DSU;\nlong long dp(int x, int fa) {\n  int leaf = 1;\n  long long sum = 0;\n  dep[x] = dep[fa] + 1;\n  f[x] = fa;\n  for (int i = head[x]; ~i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (e[i].ban || y == fa) continue;\n    leaf = 0;\n    e[i].dis = dp(y, x);\n    sum += e[i].dis;\n  }\n  if (leaf) return c[x];\n  return c[x] - sum;\n}\nvoid solve(int x, int fa) {\n  vis[x] = 1;\n  int fl = 0;\n  for (int i = head[x]; ~i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (a[y] && y != fa) {\n      e[i].ji = e[i ^ 1].ji = 1;\n      if (!vis[y]) solve(y, x), fl = 1;\n      if (fl) return;\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(head, -1, sizeof(head));\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &c[i]), fa[i] = i;\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y);\n    add(y, x);\n  }\n  for (int i = 0; i <= tot; i += 2) {\n    int x = find(e[i].from), y = find(e[i].to);\n    if (x == y)\n      e[i].ban = e[i ^ 1].ban = 1;\n    else\n      fa[x] = y;\n  }\n  delta = dp(1, 0);\n  if (delta & 1) {\n    cout << \"NO\";\n    return 0;\n  } else if (delta) {\n    int x, y, opt;\n    for (int i = 0; i <= tot; i += 2)\n      if (e[i].ban) {\n        x = e[i].to, y = e[i].from;\n        if ((dep[x] & 1) == (dep[y] & 1)) {\n          opt = (dep[x] - dep[1]) & 1 ? -1 : 1;\n          e[i].dis += opt * delta / 2;\n          fl = 1;\n          break;\n        }\n      }\n    if (!fl) {\n      cout << \"NO\";\n      return 0;\n    }\n    delta /= 2;\n    c[x] -= opt * delta;\n    c[y] -= opt * delta;\n    delta = dp(1, 0);\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i <= tot; i += 2) printf(\"%I64d\\n\", e[i].dis + e[i ^ 1].dis);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nvector<int> adj[N], tree[N];\nint from[N], to[N], h[N];\nvector<int> cycle, yal;\nbool nb = 0;\npair<int, int> Par[N];\nlong long ans[N], c[N];\nvoid dfs(int v, int par = -1) {\n  for (auto i : adj[v]) {\n    int u = from[i] + to[i] - v;\n    if (u == par) continue;\n    if (h[u] == 0) {\n      h[u] = h[v] + 1;\n      Par[u] = {v, i};\n      tree[v].push_back(i);\n      tree[u].push_back(i);\n      dfs(u, v);\n    } else {\n      if (abs(h[v] - h[u]) % 2 == 0) {\n        if (!nb) {\n          int t = u, tp = v;\n          if (h[v] > h[u]) t = v, tp = u;\n          while (t != tp)\n            cycle.push_back(t), yal.push_back(Par[t].second), t = Par[t].first;\n          cycle.push_back(tp);\n          yal.push_back(i);\n        }\n        nb = true;\n      }\n    }\n  }\n  return;\n}\nlong long solve(int v, int par = -1) {\n  long long res = 0;\n  for (auto i : tree[v]) {\n    int u = from[i] + to[i] - v;\n    if (u == par) continue;\n    long long x = solve(u, v);\n    ans[i] = c[u] - x;\n    res += ans[i];\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> c[i];\n  for (int i = 0; i < m; i++) {\n    cin >> from[i] >> to[i];\n    adj[from[i]].push_back(i);\n    adj[to[i]].push_back(i);\n  }\n  h[1] = 1;\n  dfs(1);\n  if (!nb) {\n    long long sum[2];\n    sum[0] = sum[1] = 0;\n    for (int i = 1; i <= n; i++) sum[h[i] % 2] += c[i];\n    if (sum[0] != sum[1]) return cout << \"NO\\n\", 0;\n    solve(1);\n    cout << \"YES\\n\";\n    for (int i = 0; i < m; i++) cout << ans[i] << '\\n';\n    return 0;\n  }\n  long long r = cycle[0];\n  long long t = solve(r);\n  t = (c[r] - t) / 2;\n  for (int i = 0; i < (int)cycle.size(); i++)\n    if (i % 2 == 0)\n      ans[yal[i]] += t;\n    else\n      ans[yal[i]] -= t;\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) cout << ans[i] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nsigned long long C[101010];\nint U[101010], V[101010];\nvector<pair<int, int>> E[101010];\nsigned long long R[101010];\nint col[101010];\nsigned long long P[2];\nint tree[101010];\nint in[101010];\nvoid dfs(int cur, int c) {\n  col[cur] = c;\n  P[c] += C[cur];\n  for (auto& e : E[cur]) {\n    if (col[e.first] == -1) {\n      tree[e.second] = 1;\n      dfs(e.first, c ^ 1);\n    }\n  }\n}\nvoid solve() {\n  int i, j, k, l, r, x, y;\n  string s;\n  cin >> N >> M;\n  for (i = 0; i < (N); i++) cin >> C[i];\n  for (i = 0; i < (M); i++) {\n    cin >> U[i] >> V[i];\n    U[i]--, V[i]--;\n    E[U[i]].push_back({V[i], i});\n    E[V[i]].push_back({U[i], i});\n  }\n  memset(col, 0xff, sizeof(col));\n  dfs(0, 0);\n  if (P[0] != P[1]) {\n    for (i = 0; i < (M); i++)\n      if (col[U[i]] == col[V[i]]) break;\n    if (i == M) return (void)printf(\"NO\\n\");\n    R[i] = (P[col[U[i]]] - P[col[U[i]] ^ 1]) / 2;\n    C[U[i]] -= R[i];\n    C[V[i]] -= R[i];\n  }\n  queue<int> Q;\n  for (i = 0; i < (N); i++) {\n    for (auto& e : E[i])\n      if (tree[e.second]) in[i]++;\n    if (in[i] == 1) Q.push(i);\n  }\n  while (Q.size()) {\n    int cur = Q.front();\n    Q.pop();\n    int id = -1;\n    for (auto& e : E[cur])\n      if (tree[e.second]) id = e.second;\n    if (id >= 0) {\n      int op = U[id] + V[id] - cur;\n      R[id] = C[cur];\n      tree[id] = 0;\n      C[cur] = 0;\n      C[op] -= R[id];\n      in[op]--;\n      if (in[op] == 1) Q.push(op);\n    }\n  }\n  cout << \"YES\" << endl;\n  for (i = 0; i < (M); i++) cout << R[i] << endl;\n}\nint main(int argc, char** argv) {\n  string s;\n  int i;\n  if (argc == 1) ios::sync_with_stdio(false), cin.tie(0);\n  for (i = 0; i < (argc - 1); i++) s += argv[i + 1], s += '\\n';\n  for (i = 0; i < (s.size()); i++) ungetc(s[s.size() - 1 - i], stdin);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nlong long n, m, from[MAXN], to[MAXN], w[MAXN], sum[MAXN];\nvector<int> adj[MAXN];\nint col[MAXN];\nint root = -1;\nint sec[MAXN], sz;\nint tv = -1;\nvoid dfs(int v, int c = 1, int p = -1) {\n  if (col[v]) {\n    if (col[v] != c) {\n      root = v;\n      sec[sz++] = p;\n      tv = v;\n    }\n    return;\n  }\n  col[v] = c;\n  for (int e : adj[v]) {\n    int u = from[e] ^ to[e] ^ v;\n    dfs(u, 3 - c, e);\n    if (root != -1) {\n      if (v == tv) tv = -1;\n      if (tv != -1) sec[sz++] = p;\n      return;\n    }\n  }\n}\nint par[MAXN], q[MAXN], h, t, cnt[MAXN];\nvoid dfs2(int v, int p = -1) {\n  col[v] = 1;\n  par[v] = p;\n  for (int e : adj[v])\n    if (e ^ p) {\n      int u = from[e] ^ to[e] ^ v;\n      if (!col[u]) {\n        dfs2(u, e);\n        cnt[v]++;\n      }\n    }\n  if (!cnt[v]) q[t++] = v;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> sum[i];\n  for (int i = 0; i < m; i++) {\n    cin >> from[i] >> to[i], from[i]--, to[i]--;\n    adj[from[i]].push_back(i);\n    adj[to[i]].push_back(i);\n    w[i] = 1;\n    sum[from[i]] -= 1;\n    sum[to[i]] -= 1;\n  }\n  dfs(0);\n  if (root == -1) root = 0;\n  memset(col, 0, sizeof(col));\n  dfs2(root);\n  while (t - h) {\n    int v = q[h++];\n    if (v == root) break;\n    w[par[v]] += sum[v];\n    int p = from[par[v]] ^ to[par[v]] ^ v;\n    sum[p] -= sum[v];\n    sum[v] = 0;\n    cnt[p]--;\n    if (cnt[p] == 0) q[t++] = p;\n  }\n  if (sum[root] == 0) {\n    cout << \"YES\\n\";\n    for (int i = 0; i < m; i++) cout << w[i] << \"\\n\";\n  } else {\n    if (sz == 0)\n      cout << \"NO\\n\";\n    else {\n      assert((sum[root] & 1) == 0);\n      for (int i = 0; i < sz; i++)\n        w[sec[i]] += (i & 1 ? -sum[root] / 2 : sum[root] / 2);\n      cout << \"YES\\n\";\n      for (int i = 0; i < m; i++) cout << w[i] << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nconst int Maxn = 100005;\nstruct Edge {\n  int x, y;\n  long long val;\n  int wh(int p) { return (x == p) ? y : x; }\n} Link[Maxn];\nvector<int> E[Maxn];\nint fa[Maxn];\nint Findfa(int x) {\n  if (fa[x] == x) return x;\n  return fa[x] = Findfa(fa[x]);\n}\nint f[Maxn][20];\nint deep[Maxn];\nlong long v[Maxn];\nvoid Dfs(int x, int depth) {\n  deep[x] = depth;\n  for (int i = 0, s = E[x].size(); i < s; ++i) {\n    int y = Link[E[x][i]].wh(x);\n    if (y == f[x][0]) continue;\n    f[y][0] = x;\n    Dfs(y, depth + 1);\n    Link[E[x][i]].val = v[y];\n    v[x] -= v[y];\n  }\n}\nint root;\nint LCA(int x, int y) {\n  if (deep[x] < deep[y]) swap(x, y);\n  for (int i = 18; ~i; --i)\n    if (deep[x] - (1 << i) >= deep[y]) x = f[x][i];\n  if (x == y) return x;\n  for (int i = 18; ~i; --i) {\n    if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];\n  }\n  return f[x][0];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) fa[i] = i, scanf(\"%lld\", &v[i]);\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    Link[i] = (Edge){x, y, 0};\n    int f1 = Findfa(x), f2 = Findfa(y);\n    if (f1 == f2) continue;\n    fa[f1] = f2;\n    E[x].push_back(i);\n    E[y].push_back(i);\n  }\n  srand(time(0));\n  root = rand() % n + 1;\n  Dfs(root, 1);\n  for (int i = 1; i <= 18; ++i)\n    for (int x = 1; x <= n; ++x) f[x][i] = f[f[x][i - 1]][i - 1];\n  if (abs(v[root]) & 1)\n    puts(\"NO\");\n  else {\n    bool flag = false;\n    for (int i = 1; i <= m; ++i) {\n      int x = Link[i].x, y = Link[i].y;\n      if (f[x][0] == y || f[y][0] == x) continue;\n      int lca = LCA(x, y);\n      int size = deep[x] + deep[y] - 2 * deep[lca] + 1;\n      if (size & 1) {\n        int dlt = (deep[x] & 1) ? -1 : 1;\n        dlt *= v[root] / 2;\n        Link[i].val += dlt * -1;\n        while (x != lca) {\n          int p = f[x][0];\n          for (int j = 0, s = E[p].size(); j < s; ++j) {\n            if (Link[E[p][j]].wh(p) == x) {\n              Link[E[p][j]].val += dlt;\n              break;\n            }\n          }\n          dlt *= -1;\n          x = p;\n        }\n        dlt = (deep[y] & 1) ? -1 : 1;\n        dlt *= v[root] / 2;\n        while (y != lca) {\n          int p = f[y][0];\n          for (int j = 0, s = E[p].size(); j < s; ++j) {\n            if (Link[E[p][j]].wh(p) == y) {\n              Link[E[p][j]].val += dlt;\n              break;\n            }\n          }\n          dlt *= -1;\n          y = p;\n        }\n        dlt *= 2;\n        while (lca != root) {\n          int p = f[lca][0];\n          for (int j = 0, s = E[p].size(); j < s; ++j) {\n            if (Link[E[p][j]].wh((p)) == lca) {\n              Link[E[p][j]].val += dlt;\n              break;\n            }\n          }\n          dlt *= -1;\n          lca = p;\n        }\n        flag = true;\n        break;\n      }\n    }\n    if (flag || v[root] == 0) {\n      puts(\"YES\");\n      for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", Link[i].val);\n    } else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nconst int N = 200000;\nint col[N], di[N];\nlong long ai[N];\nint A[N], B[N], V[N], P[N];\nlong long S[N];\nvector<int> edge[N];\nint L;\nqueue<int> Q;\nvoid dfs(int t, int c) {\n  col[t] = c;\n  for (int i = 0; i < edge[t].size(); ++i) {\n    int b = A[edge[t][i]] + B[edge[t][i]] - t;\n    if (col[b] == -1)\n      dfs(b, !c);\n    else if (col[b] == col[t])\n      L = edge[t][i];\n  }\n}\nint fa[N];\nint get_f(int t) { return fa[t] = (fa[t] == t ? t : get_f(fa[t])); }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &ai[i]);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    edge[A[i]].push_back(i);\n    di[A[i]]++;\n    edge[B[i]].push_back(i);\n    di[B[i]]++;\n  }\n  for (int i = 1; i <= n; ++i) col[i] = -1;\n  dfs(1, 0);\n  if (L) {\n    for (int i = 1; i <= n; ++i) fa[i] = i;\n    V[L] = 1;\n    for (int i = 1; i <= m; ++i)\n      if (i != L)\n        if (get_f(A[i]) != get_f(B[i]) && col[A[i]] != col[B[i]])\n          V[i] = 1, fa[get_f(A[i])] = get_f(B[i]);\n    for (int i = 1; i <= m; ++i)\n      if (!V[i]) {\n        S[i] = 1;\n        di[A[i]]--;\n        di[B[i]]--;\n        ai[A[i]]--;\n        ai[B[i]]--;\n      }\n    for (int i = 1; i <= n; ++i)\n      if (di[i] == 1) Q.push(i);\n    while (!Q.empty()) {\n      int t = Q.front();\n      Q.pop();\n      for (int i = 0; i < edge[t].size(); ++i)\n        if (V[edge[t][i]]) {\n          int b = A[edge[t][i]] + B[edge[t][i]] - t;\n          if (!di[b]) continue;\n          di[t]--;\n          di[b]--;\n          S[edge[t][i]] = ai[t];\n          ai[b] -= ai[t];\n          ai[t] = 0;\n          if (di[b] == 1) Q.push(b);\n        }\n    }\n    int start = -1;\n    for (int i = 1; i <= n; ++i)\n      if (di[i] && start == -1) start = i;\n    int p = start;\n    long long sum = ai[p], k = 1;\n    for (int i = 0; i < edge[p].size(); ++i)\n      if (V[edge[p][i]]) {\n        int q = A[edge[p][i]] + B[edge[p][i]] - p;\n        if (di[q]) {\n          p = q;\n          break;\n        }\n      }\n    for (int o = start; p != start;) {\n      sum += k * ai[p];\n      for (int i = 0; i < edge[p].size(); ++i)\n        if (V[edge[p][i]]) {\n          int q = A[edge[p][i]] + B[edge[p][i]] - p;\n          if (di[q] && q != o) {\n            o = p;\n            p = q;\n            k *= -1;\n            break;\n          }\n        }\n    }\n    p = start;\n    ai[p] -= sum / 2;\n    for (int i = 0; i < edge[p].size(); ++i)\n      if (V[edge[p][i]]) {\n        int q = A[edge[p][i]] + B[edge[p][i]] - p;\n        if (di[q]) {\n          S[edge[p][i]] = sum / 2;\n          ai[q] -= sum / 2;\n          p = q;\n          break;\n        }\n      }\n    for (int o = start; p != start;) {\n      for (int i = 0; i < edge[p].size(); ++i)\n        if (V[edge[p][i]]) {\n          int q = A[edge[p][i]] + B[edge[p][i]] - p;\n          if (di[q] && q != o) {\n            S[edge[p][i]] = ai[p];\n            ai[q] -= ai[p];\n            o = p;\n            p = q;\n            break;\n          }\n        }\n    }\n    puts(\"YES\");\n    for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", S[i]);\n  } else {\n    for (int i = 1; i <= n; ++i) fa[i] = i;\n    for (int i = 1; i <= m; ++i)\n      if (get_f(A[i]) != get_f(B[i]) && col[A[i]] != col[B[i]])\n        V[i] = 1, fa[get_f(A[i])] = get_f(B[i]);\n    for (int i = 1; i <= m; ++i)\n      if (!V[i]) {\n        S[i] = 1;\n        di[A[i]]--;\n        di[B[i]]--;\n        ai[A[i]]--;\n        ai[B[i]]--;\n      }\n    for (int i = 1; i <= n; ++i)\n      if (di[i] == 1) Q.push(i);\n    while (!Q.empty()) {\n      int t = Q.front();\n      Q.pop();\n      for (int i = 0; i < edge[t].size(); ++i)\n        if (V[edge[t][i]]) {\n          int b = A[edge[t][i]] + B[edge[t][i]] - t;\n          if (!di[b]) continue;\n          di[t]--;\n          di[b]--;\n          S[edge[t][i]] = ai[t];\n          ai[b] -= ai[t];\n          ai[t] = 0;\n          if (!di[b] && ai[b]) {\n            puts(\"NO\");\n            exit(0);\n          }\n          if (di[b] == 1) Q.push(b);\n        }\n    }\n    puts(\"YES\");\n    for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", S[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100005;\nint f[N], dep[N], c[N], to[N], n, m, vis[N], use[N], x, y;\nlong long w[N], sum[N];\nstruct note {\n  int u, id;\n} a[N];\nstd::vector<note> e[N];\nvoid dfs(int x, int y) {\n  dep[x] = dep[y] + 1;\n  vis[x] = 1;\n  f[x] = y;\n  for (auto j : e[x]) {\n    int u = j.u, i = j.id;\n    if (vis[u]) continue;\n    to[u] = i;\n    dfs(u, x);\n    use[i] = 1;\n    w[i] = c[u] - sum[u];\n    sum[x] += w[i];\n  }\n}\nvoid print() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", w[i]);\n  exit(0);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    a[i] = {x, y};\n    e[x].push_back({y, i});\n    e[y].push_back({x, i});\n  }\n  dfs(1, 0);\n  int delta = c[1] - sum[1];\n  if (delta == 0) print();\n  for (int i = 1; i <= m; i++) {\n    if (use[i]) continue;\n    int x = a[i].u, y = a[i].id;\n    if ((dep[x] - dep[y]) & 1) continue;\n    w[i] = delta / 2 * (dep[x] & 1 ? 1 : -1);\n    for (int ff = -w[i]; x != 1; x = f[x], ff = ff * (-1)) w[to[x]] += ff;\n    for (int ff = -w[i]; y != 1; y = f[y], ff = ff * (-1)) w[to[y]] += ff;\n    print();\n  }\n  puts(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1e5 + 10;\nvector<pair<long long, long long> > vertex[MAXN];\nlong long c[MAXN];\nlong long edge[MAXN];\nlong long color[MAXN];\nbool check[MAXN];\nlong long n, m, root = -1;\nbool P = false;\nvoid bipartite_dfs(long long v, long long z) {\n  check[v] = true;\n  color[v] = z;\n  for (long long i = 0; i < vertex[v].size(); i++) {\n    if (!check[vertex[v][i].first]) {\n      bipartite_dfs(vertex[v][i].first, 1 - z);\n    } else {\n      if (color[v] == color[vertex[v][i].first]) {\n        root = v;\n      }\n    }\n  }\n}\nvoid pre_dfs(long long v) {\n  check[v] = true;\n  for (long long i = 0; i < vertex[v].size(); i++) {\n    if (!check[vertex[v][i].first]) {\n      pre_dfs(vertex[v][i].first);\n      edge[vertex[v][i].second] += c[vertex[v][i].first];\n      c[v] -= c[vertex[v][i].first];\n      c[vertex[v][i].first] = 0;\n    }\n  }\n}\nvoid dfs(long long v) {\n  check[v] = true;\n  for (long long i = 0; i < vertex[v].size(); i++) {\n    if (!check[vertex[v][i].first]) {\n      dfs(vertex[v][i].first);\n      edge[vertex[v][i].second] += c[vertex[v][i].first];\n      c[v] -= c[vertex[v][i].first];\n      c[vertex[v][i].first] = 0;\n    } else {\n      if (vertex[v][i].first == root && color[v] == color[root] && !P) {\n        P = true;\n        edge[vertex[v][i].second] += c[root] / 2;\n        c[v] -= c[root] / 2;\n        c[root] -= c[root] / 2;\n      }\n    }\n  }\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    cin >> c[i];\n  }\n  for (long long i = 0; i < m; i++) {\n    long long v, u;\n    cin >> v >> u;\n    edge[i] = 1;\n    vertex[v].push_back(make_pair(u, i));\n    vertex[u].push_back(make_pair(v, i));\n  }\n  for (long long i = 1; i <= n; i++) {\n    c[i] -= (long long)(vertex[i].size());\n  }\n  bipartite_dfs(1, 0);\n  if (root == -1) {\n    fill(check, check + MAXN, false);\n    pre_dfs(1);\n    fill(check, check + MAXN, false);\n    dfs(1);\n  } else {\n    fill(check, check + MAXN, false);\n    bipartite_dfs(root, 0);\n    fill(check, check + MAXN, false);\n    pre_dfs(root);\n    fill(check, check + MAXN, false);\n    dfs(root);\n  }\n  long long num = 0;\n  for (long long i = 1; i <= n; i++) {\n    num += (c[i] == 0);\n  }\n  if (num < n) {\n    cout << \"NO\";\n    return 0;\n  }\n  cout << \"YES\" << endl;\n  for (long long i = 0; i < m; i++) {\n    cout << edge[i] << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Div1_453D {\n\n\tstatic long[] val;\n\n\tstatic ArrayList<Integer>[] aList;\n\tstatic ArrayList<Integer>[] eList;\n\n\tstatic int[] color;\n\n\tstatic int[] pV;\n\tstatic int[] pE;\n\n\tstatic int cStart;\n\tstatic int cEnd;\n\tstatic int cEdge;\n\n\tstatic long[] eV;\n\n\tstatic boolean[] visited;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tint nV = Integer.parseInt(inputData.nextToken());\n\t\tint nE = Integer.parseInt(inputData.nextToken());\n\t\tval = new long[nV];\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tval[i] = Integer.parseInt(inputData.nextToken());\n\t\t}\n\n\t\taList = new ArrayList[nV];\n\t\teList = new ArrayList[nV];\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\taList[i] = new ArrayList<>();\n\t\t\teList[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < nE; i++) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tint a = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\tint b = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\taList[a].add(b);\n\t\t\taList[b].add(a);\n\t\t\teList[a].add(i);\n\t\t\teList[b].add(i);\n\t\t}\n\n\t\tcolor = new int[nV];\n\t\tArrays.fill(color, -1);\n\n\t\tpV = new int[nV];\n\t\tpE = new int[nV];\n\n\t\tcolor[0] = 0;\n\t\tboolean isBipartite = color(0);\n\n\t\teV = new long[nE];\n\n\t\tvisited = new boolean[nV];\n\t\tif (isBipartite) {\n\t\t\tgDetermine(0);\n\t\t\tif (val[0] == 0) {\n\t\t\t\tprinter.println(\"YES\");\n\t\t\t\tfor (int i = 0; i < nE; i++) {\n\t\t\t\t\tprinter.println(-eV[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprinter.println(\"NO\");\n\t\t\t}\n\t\t} else {\n\t\t\tgDetermine(cEnd);\n\t\t\tlong delta = -val[cEnd] / 2;\n\t\t\tint cV = cEnd;\n\t\t\twhile (cV != cStart) {\n\t\t\t\teV[pE[cV]] += delta;\n\t\t\t\tcV = pV[cV];\n\t\t\t\tdelta = -delta;\n\t\t\t}\n\t\t\teV[cEdge] += delta;\n\t\t\tprinter.println(\"YES\");\n\t\t\tfor (int i = 0; i < nE; i++) {\n\t\t\t\tprinter.println(-eV[i]);\n\t\t\t}\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tstatic boolean color(int cV) {\n\t\tfor (int aI = 0; aI < aList[cV].size(); aI++) {\n\t\t\tint aV = aList[cV].get(aI);\n\t\t\tint aE = eList[cV].get(aI);\n\t\t\tif (color[aV] == -1) {\n\t\t\t\tcolor[aV] = color[cV] ^ 1;\n\t\t\t\tpV[aV] = cV;\n\t\t\t\tpE[aV] = aE;\n\t\t\t\tif(!color(aV)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[aV] == color[cV]) {\n\t\t\t\t\tcEnd = cV;\n\t\t\t\t\tcStart = aV;\n\t\t\t\t\tcEdge = aE;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void gDetermine(int cV) {\n\t\tvisited[cV] = true;\n\t\tfor (int aI = 0; aI < aList[cV].size(); aI++) {\n\t\t\tint aV = aList[cV].get(aI);\n\t\t\tint eI = eList[cV].get(aI);\n\t\t\tif (!visited[aV]) {\n\t\t\t\tgDetermine(aV);\n\t\t\t\teV[eI] = -val[aV];\n\t\t\t\tval[cV] -= val[aV];\n\t\t\t\tval[aV] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 13;\nvector<pair<int, int> > p[maxn];\nlong long ans[maxn], w[maxn];\nint col[maxn], fa[maxn], dp[maxn];\nint a[maxn], b[maxn];\nbool vis[maxn];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid dfs1(int rt, int fa) {\n  col[rt] = col[fa] ^ 1;\n  dp[rt] = dp[fa] + 1;\n  for (int i = 0; i < p[rt].size(); i++) {\n    int v = p[rt][i].second;\n    if (v == fa) continue;\n    dfs1(v, rt);\n  }\n}\nvoid dfs2(int rt, int fa) {\n  for (int i = 0; i < p[rt].size(); i++) {\n    int v = p[rt][i].second, id = p[rt][i].first;\n    if (v == fa) continue;\n    dfs2(v, rt);\n    ans[id] += w[v];\n    w[rt] -= w[v];\n    w[v] = 0;\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &w[i]);\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d\", &a[i], &b[i]);\n    int f1 = find(a[i]), f2 = find(b[i]);\n    if (f1 == f2) continue;\n    fa[f1] = f2;\n    p[a[i]].push_back({i, b[i]});\n    p[b[i]].push_back({i, a[i]});\n    vis[i] = 1;\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  if (w[1] == 0) {\n    printf(\"YES\\n\");\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n  } else if (abs(w[1]) & 1) {\n    return printf(\"NO\\n\"), 0;\n  }\n  int yes = 0;\n  for (int i = 1; i <= m; i++) {\n    if (vis[i] || col[a[i]] != col[b[i]]) continue;\n    printf(\"YES\\n\");\n    if (dp[a[i]] & 1) {\n      ans[i] = w[1] / 2;\n      w[a[i]] -= ans[i];\n      w[b[i]] -= ans[i];\n    } else {\n      ans[i] = -w[1] / 2;\n      w[a[i]] -= ans[i];\n      w[b[i]] -= ans[i];\n    }\n    yes = 1;\n    dfs2(1, 0);\n    break;\n  }\n  if (!yes)\n    printf(\"NO\");\n  else {\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ') {\n  while (!isdigit(ch = getchar()))\n    if (ch == '-') f = -1;\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f * x;\n}\nconst int N = 1e5 + 5;\nstruct Edge {\n  int next, to;\n  long long w;\n  Edge(int next = 0, int to = 0, long long w = 0) : next(next), to(to), w(w){};\n} edge[N << 1];\nint tot = 1, head[N];\nvoid _add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot; }\nvoid add(int x, int y) { _add(x, y), _add(y, x); }\nint n, m, f[N], g[N], d[N], vis[N], e[N], t;\nlong long c[N], w[N];\nlong long dfs(int x, int fi) {\n  vis[x] = 1, f[x] = fi;\n  for (int i = head[x]; i; i = edge[i].next)\n    if (i != fi) {\n      int y = edge[i].to;\n      if (vis[y] && ((d[y] ^ d[x] ^ 1) & 1))\n        g[x] = i;\n      else if (!vis[y])\n        vis[y] = 1, d[y] = d[x] + 1, c[x] -= dfs(y, i ^ 1);\n    }\n  return edge[fi].w = edge[fi ^ 1].w = c[x];\n}\nvoid print() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", edge[i << 1].w);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; ++i) c[i] = read();\n  for (int i = 1; i <= m; ++i) {\n    int x = read(), y = read();\n    add(x, y);\n  }\n  d[1] = 1, dfs(1, 0);\n  if (c[1] == 0) return print(), 0;\n  if (~c[1] & 1)\n    for (int o = 1; o <= n; ++o)\n      if (g[o]) {\n        if (d[o] & 1)\n          edge[g[o]].w = edge[g[o] ^ 1].w += c[1] >> 1;\n        else\n          edge[g[o]].w = edge[g[o] ^ 1].w -= c[1] >> 1;\n        for (int i = f[edge[g[o]].to], j = d[edge[g[o]].to] - 1; j;\n             i = f[edge[i].to], --j)\n          if (j & 1)\n            edge[i].w = edge[i ^ 1].w += c[1] >> 1;\n          else\n            edge[i].w = edge[i ^ 1].w -= c[1] >> 1;\n        for (int i = f[o], j = d[o] - 1; j; i = f[edge[i].to], --j)\n          if (j & 1)\n            edge[i].w = edge[i ^ 1].w += c[1] >> 1;\n          else\n            edge[i].w = edge[i ^ 1].w -= c[1] >> 1;\n        return print(), 0;\n      }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ex[100005], ey[100005];\nvector<int> g[100005];\nint n, m, c[100005];\nlong long a[100005], r[100005], s[2];\nvector<int> g2[100005];\nvoid dfs0(int x) {\n  s[c[x]] += a[x];\n  for (int i : g[x]) {\n    int y = ex[i] ^ ey[i] ^ x;\n    if (c[y] < 0) {\n      c[y] = 1 - c[x];\n      g2[x].push_back(i);\n      g2[y].push_back(i);\n      dfs0(y);\n    }\n  }\n}\nvoid dfs1(int x, int f) {\n  for (int i : g2[x]) {\n    int y = ex[i] ^ ey[i] ^ x;\n    if (y == f) continue;\n    dfs1(y, x);\n    r[i] = a[y];\n    a[x] -= r[i];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  long long ss = 0;\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i) scanf(\"%lld\", a + i), ss += a[i];\n  for (int i = 0, ThxDem = m; i < ThxDem; ++i) {\n    scanf(\"%d%d\", ex + i, ey + i);\n    ex[i]--;\n    ey[i]--;\n    g[ex[i]].push_back(i);\n    g[ey[i]].push_back(i);\n  }\n  memset(c, -1, sizeof(c));\n  c[0] = 0;\n  dfs0(0);\n  for (int i = 0, ThxDem = m; i < ThxDem; ++i)\n    if (c[ex[i]] == c[ey[i]]) {\n      r[i] = (s[c[ex[i]]] - s[c[ex[i]] ^ 1]) / 2;\n      a[ex[i]] -= r[i];\n      a[ey[i]] -= r[i];\n      s[c[ex[i]]] -= 2 * r[i];\n      break;\n    }\n  if (s[0] != s[1]) {\n    puts(\"NO\");\n    return 0;\n  }\n  dfs1(0, -1);\n  puts(\"YES\");\n  for (int i = 0, ThxDem = m; i < ThxDem; ++i) printf(\"%lld\\n\", r[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint color[100007];\nvector<int> g[100007];\nmap<pair<int, int>, int> reb;\nint root;\nint was[100007];\nvector<int> st;\nvector<int> cyc;\nlong long ans[100007];\nvoid dfs(int v, int col) {\n  if (cyc.size()) return;\n  st.push_back(v);\n  was[v] = col;\n  for (int to : g[v]) {\n    if (cyc.size()) return;\n    if (was[to] == -1) {\n      dfs(to, col ^ 1);\n    } else {\n      if (was[to] == was[v] && cyc.size() == 0) {\n        for (int i = (int)st.size() - 1; i >= 0; i--) {\n          cyc.push_back(st[i]);\n          if (st[i] == to) break;\n        }\n      }\n    }\n  }\n  st.pop_back();\n}\nlong long dfs2(int v) {\n  was[v] = 1;\n  long long now = color[v];\n  for (int to : g[v])\n    if (was[to] == -1) {\n      long long val = dfs2(to);\n      ans[reb[make_pair(v, to)]] += val;\n      now -= val;\n    }\n  return now;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> color[i];\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    reb[make_pair(a, b)] = i;\n    reb[make_pair(b, a)] = i;\n  }\n  for (int i = 0; i < n; i++) was[i] = -1;\n  dfs(0, 0);\n  for (int i = 0; i < n; i++) was[i] = -1;\n  if (cyc.size() == 0)\n    root = 0;\n  else\n    root = cyc.back();\n  long long ww = dfs2(root);\n  if (ww != 0) {\n    if (abs(ww) % 2 == 1 || cyc.size() == 0) cout << \"NO\", exit(0);\n    long long val = ww / 2;\n    int ff = 0;\n    ans[reb[make_pair(cyc[0], cyc.back())]] += val;\n    for (int i = 0; i < (int)cyc.size() - 1; i++) {\n      if (ff == 0)\n        ans[reb[make_pair(cyc[i], cyc[i + 1])]] -= val;\n      else\n        ans[reb[make_pair(cyc[i], cyc[i + 1])]] += val;\n      ff ^= 1;\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; i++) cout << ans[i] << ' ';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0;\n  bool flg = false;\n  char ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') flg = true;\n  for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ 48);\n  return flg ? -x : x;\n}\nint n, m;\nlong long w[100010], cw[100010];\nstruct Rec {\n  int u, v;\n  bool mrk;\n  long long ans;\n} rec[100010];\nstruct Edge {\n  int to, nxt, id;\n} edge[200010];\nint cnt = 1, last[100010];\ninline void addedge(int x, int y, int id) {\n  edge[++cnt] = (Edge){y, last[x], id}, last[x] = cnt;\n  edge[++cnt] = (Edge){x, last[y], id}, last[y] = cnt;\n}\nnamespace B {\nint f[100010];\nint find(int x) { return f[x] ? f[x] = find(f[x]) : x; }\n}  // namespace B\nint fat[100010], son[100010], dep[100010], siz[100010];\nint top[100010];\nvoid dfs1(int cur, int fat, int dep) {\n  ::fat[cur] = fat;\n  ::dep[cur] = dep;\n  siz[cur] = 1;\n  for (int i = last[cur]; i; i = edge[i].nxt)\n    if (edge[i].to ^ fat) {\n      dfs1(edge[i].to, cur, dep + 1);\n      rec[edge[i].id].ans = w[edge[i].to] - cw[edge[i].to];\n      cw[cur] += rec[edge[i].id].ans;\n      siz[cur] += siz[edge[i].to];\n      if (!son[cur] || siz[edge[i].to] > siz[son[cur]]) son[cur] = edge[i].to;\n    }\n}\nvoid dfs2(int cur, int top) {\n  ::top[cur] = top;\n  if (siz[cur] == 1) return;\n  dfs2(son[cur], top);\n  for (int i = last[cur]; i; i = edge[i].nxt)\n    if ((edge[i].to ^ fat[cur]) && (edge[i].to ^ son[cur]))\n      dfs2(edge[i].to, edge[i].to);\n}\nvoid dfs3(int cur) {\n  for (int i = last[cur]; i; i = edge[i].nxt)\n    if (edge[i].to ^ fat[cur]) {\n      dfs3(edge[i].to);\n      rec[edge[i].id].ans = w[edge[i].to] - cw[edge[i].to];\n      cw[cur] += rec[edge[i].id].ans;\n    }\n}\nint getlca(int x, int y) {\n  while (top[x] ^ top[y])\n    if (dep[top[x]] < dep[top[y]])\n      y = fat[top[y]];\n    else\n      x = fat[top[x]];\n  if (dep[x] < dep[y]) return x;\n  return y;\n}\nint getdis(int x, int y) { return dep[x] + dep[y] - (dep[getlca(x, y)] << 1); }\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) w[i] = read();\n  for (int i = 1, x, y; i <= m; i++) {\n    rec[i].u = read(), rec[i].v = read();\n    x = B::find(rec[i].u), y = B::find(rec[i].v);\n    if (x ^ y) rec[i].mrk = true, addedge(rec[i].u, rec[i].v, i), B::f[y] = x;\n  }\n  dfs1(1, 0, 1);\n  if (w[1] == cw[1]) {\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", rec[i].ans);\n    return 0;\n  }\n  dfs2(1, 1);\n  long long tmp = w[1] - cw[1];\n  for (int i = 1; i <= m; i++) rec[i].ans = 0;\n  for (int i = 1; i <= n; i++) cw[i] = 0;\n  bool flg = false;\n  for (int i = 1; i <= m; i++) {\n    if (rec[i].mrk) continue;\n    if (!(getdis(rec[i].u, rec[i].v) & 1)) {\n      if (dep[rec[i].u] & 1)\n        cw[rec[i].u] = cw[rec[i].v] = rec[i].ans = tmp / 2;\n      else\n        cw[rec[i].u] = cw[rec[i].v] = rec[i].ans = -tmp / 2;\n      flg = true;\n      break;\n    }\n  }\n  if (!flg) return puts(\"NO\"), 0;\n  puts(\"YES\");\n  dfs3(1);\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", rec[i].ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 150000 + 10, sgn[2] = {1, -1};\nstruct Edge {\n  int from, to, id, nx;\n} edg[MAXN << 1];\nint G[MAXN], p[MAXN], dep[MAXN], n, m, edgn = 0, ord[MAXN];\nlong long c[MAXN], ans[MAXN];\nbool cmpdep(int u, int v) { return dep[u] > dep[v]; }\nbool dfs(int u);\nvoid greedy();\ninline void AddEdg(int u, int v, int id) {\n  edg[edgn++] = (Edge){u, v, id, G[u]};\n  G[u] = edgn - 1;\n  edg[edgn++] = (Edge){v, u, id, G[v]};\n  G[v] = edgn - 1;\n}\ninline bool ddfs(int rt) {\n  for (int i = 0; i <= n; i++) p[i] = -1, dep[i] = 0;\n  dep[rt] = 1;\n  return dfs(rt);\n}\ninline int odde(int u) {\n  for (int i = G[u]; i != -1; i = edg[i].nx)\n    if (((dep[u] ^ dep[edg[i].to]) & 1) == 0 && dep[u] < dep[edg[i].to])\n      return i;\n  return -1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i <= n; i++) G[i] = -1;\n  long long sgmc = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &c[i]);\n    sgmc += c[i];\n  }\n  if (sgmc % 2 != 0) puts(\"NO\"), exit(0);\n  for (int i = 0, u, v; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    AddEdg(u, v, i + 1);\n  }\n  if (ddfs(1)) {\n    int u, ce;\n    for (u = 1; u <= n; u++)\n      if ((ce = odde(u)) != -1) break;\n    greedy();\n    long long delta = c[1];\n    for (int i = p[u]; i != -1; i = p[edg[i].to])\n      ans[edg[i].id] += delta * sgn[dep[edg[i].from] & 1];\n    delta = (delta * sgn[(dep[edg[ce].from] + 1) & 1]) / 2;\n    for (int i = ce; i != -1 && (i == ce || edg[i].from != u);\n         i = p[edg[i].to], delta = -delta)\n      ans[edg[i].id] += delta;\n  } else {\n    long long lf = 0, ri = 0;\n    for (int u = 1; u <= n; u++)\n      if (dep[u] & 1)\n        lf += c[u];\n      else\n        ri += c[u];\n    if (lf != ri)\n      puts(\"NO\"), exit(0);\n    else\n      greedy();\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n  return 0;\n}\nbool dfs(int u) {\n  bool res = false;\n  for (int i = G[u]; i != -1; i = edg[i].nx) {\n    int v = edg[i].to;\n    if (!dep[v]) {\n      dep[v] = dep[u] + 1;\n      p[v] = i ^ 1;\n      res |= dfs(v);\n    } else if (((dep[v] ^ dep[u]) & 1) == 0)\n      res = true;\n  }\n  return res;\n}\nvoid greedy() {\n  for (int i = 1; i <= n; i++) ord[i] = i;\n  sort(ord + 1, ord + n + 1, cmpdep);\n  for (int i = 1; i < n; i++) {\n    int u = ord[i];\n    Edge e = edg[p[u]];\n    ans[e.id] = c[u];\n    c[e.to] -= c[u];\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nconst int MAXN = 300001;\nvector<pair<int, int>> e[MAXN];\nvector<pair<int, int>> e2[MAXN];\nint h[MAXN];\nll c[MAXN];\nll c2[MAXN];\nll cc[MAXN];\nll ans[MAXN];\nint a[MAXN];\nint b[MAXN];\nint par[MAXN];\nint parid[MAXN];\nint upv = -1;\nint upu = -1;\nint upid = -1;\nbool w[MAXN];\nbool incyc[MAXN];\nvoid setans(int id, ll val) {\n  ans[id] = val;\n  c[a[id]] -= val;\n  c[b[id]] -= val;\n}\nbool dfs1(int v, int p, int id, int ch) {\n  par[v] = p;\n  h[v] = ch;\n  parid[v] = id;\n  for (auto ed : e[v]) {\n    if (!h[ed.first]) {\n      e2[v].emplace_back(ed.first, ed.second);\n      e2[ed.first].emplace_back(v, ed.second);\n      dfs1(ed.first, v, ed.second, ch + 1);\n      setans(ed.second, c[ed.first]);\n    } else if (h[ed.first] < h[v] && h[ed.first] % 2 == h[v] % 2) {\n      upv = v;\n      upu = ed.first;\n      upid = ed.second;\n    }\n  }\n  return c[v];\n}\nvoid dfs2(int v, int p, int block) {\n  w[v] = true;\n  for (auto ed : e2[v]) {\n    if (ed.first != p && ed.first != block && !w[ed.first]) {\n      dfs2(ed.first, v, block);\n      setans(ed.second, c[ed.first]);\n    }\n  }\n}\nint n, m;\nvoid pt() {\n  for (int i = 1; i <= n; ++i) {\n    if (c[i]) {\n      assert(false);\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < m; ++i) {\n    cout << ans[i] << \"\\n\";\n  }\n  exit(0);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n  cout.tie(nullptr);\n  cin.tie(nullptr);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n    c2[i] = c[i];\n  }\n  for (int i = 0; i < m; ++i) {\n    ans[i] = 0;\n    cin >> a[i] >> b[i];\n    e[a[i]].emplace_back(b[i], i);\n    e[b[i]].emplace_back(a[i], i);\n  }\n  if (!dfs1(1, 1, 1, 1)) {\n    pt();\n  }\n  if (upv == -1) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  fill(ans, ans + m, 0);\n  copy(c2 + 1, c2 + n + 1, c + 1);\n  vector<int> cyc = {upv};\n  vector<int> edid = {upid};\n  int cv = upv;\n  while (cv != upu) {\n    edid.push_back(parid[cv]);\n    cv = par[cv];\n    cyc.push_back(cv);\n  }\n  int cs = cyc.size();\n  int k = cs / 2;\n  auto at = [&](int x) { return cyc[(x + cs) % cs]; };\n  auto eat = [&](int x) { return edid[(x + cs) % cs]; };\n  for (int i = 0; i < cs; ++i) {\n    dfs2(cyc[i], at(i + 1), at(i - 1));\n  }\n  for (int v : cyc) {\n    cc[v] = c[v];\n    incyc[v] = true;\n  }\n  for (int i = 0; i < 1; ++i) {\n    ll s = 0;\n    for (int v : cyc) {\n      s += cc[v];\n    }\n    s /= 2;\n    for (int j = 0; j < k; ++j) {\n      s -= cc[at(j * 2 + i + 1)];\n    }\n    setans(edid[i], s);\n  }\n  for (int i = 1; i < cs; ++i) {\n    setans(edid[i], c[at(i - 1)]);\n  }\n  pt();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 7;\nconst int LogN = 18;\ntemplate <typename T>\ninline T read() {\n  T res = 0, flag = 1;\n  char in = getchar();\n  while (!isdigit(in)) {\n    if (in == '-') flag = -1;\n    in = getchar();\n  }\n  while (isdigit(in)) {\n    res = (res << 1) + (res << 3) + in - '0';\n    in = getchar();\n  }\n  return res * flag;\n}\ntemplate <typename T>\ninline void chkmax(T &a, T b) {\n  if (a < b) a = b;\n}\ntemplate <typename T>\ninline void chkmin(T &a, T b) {\n  if (a > b) a = b;\n}\nnamespace DSU {\nint f[MAXN];\ninline void init() {\n  for (int i = 1; i < MAXN; ++i) f[i] = i;\n}\ninline int find(int first) {\n  if (f[first] == first) return first;\n  return f[first] = find(f[first]);\n}\ninline bool inter(int first, int second) { return find(first) == find(second); }\ninline void merge(int first, int second) {\n  first = find(first);\n  second = find(second);\n  f[first] = second;\n}\n}  // namespace DSU\nint n, m;\nint C[MAXN], dep[MAXN], fa[MAXN];\nint f[LogN][MAXN];\npair<int, int> edge[MAXN];\nint dex, head[MAXN], nxt[MAXN << 1], to[MAXN << 1], w[MAXN << 1];\nbool vis[MAXN];\nlong long val[MAXN], Req;\ninline void Link(int first, int second, int val) {\n  nxt[++dex] = head[first];\n  to[dex] = second;\n  w[dex] = val;\n  head[first] = dex;\n}\ninline long long dfs(int u, int Fa) {\n  for (int i = 1; i < LogN; ++i) f[i][u] = f[i - 1][f[i - 1][u]];\n  dep[u] = dep[Fa] + 1;\n  long long res = C[u];\n  for (int i = head[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == Fa) continue;\n    f[0][v] = u;\n    fa[v] = w[i];\n    val[w[i]] = dfs(v, u);\n    res -= val[w[i]];\n  }\n  return res;\n}\ninline int check(int first, int second) {\n  int res = dep[first] + dep[second];\n  int sx = first, sy = second;\n  int A;\n  if (dep[first] < dep[second]) swap(first, second);\n  for (int i = LogN - 1; i >= 0; --i)\n    if (dep[f[i][first]] >= dep[second]) first = f[i][first];\n  if (first == second)\n    A = first;\n  else {\n    for (int i = LogN - 1; i >= 0; --i)\n      if (f[i][first] != f[i][second]) {\n        first = f[i][first];\n        second = f[i][second];\n      }\n    A = f[0][first];\n  }\n  res = res - dep[A] - dep[f[0][A]];\n  if (!(res & 1)) return 0;\n  return (dep[sx] & 1) ? 1 : -1;\n}\ninline void Adapt(int first, int second, long long Val) {\n  int sav = Val;\n  while (first) {\n    val[fa[first]] += sav;\n    sav = -sav;\n    first = f[0][first];\n  }\n  sav = Val;\n  while (second) {\n    val[fa[second]] += sav;\n    sav = -sav;\n    second = f[0][second];\n  }\n}\ninline void init() {\n  n = read<int>();\n  m = read<int>();\n  DSU::init();\n  for (int i = 1; i <= n; ++i) C[i] = read<int>();\n  for (int i = 1; i <= m; ++i) {\n    edge[i].first = read<int>();\n    edge[i].second = read<int>();\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (!DSU::inter(edge[i].first, edge[i].second)) {\n      DSU::merge(edge[i].first, edge[i].second);\n      Link(edge[i].first, edge[i].second, i);\n      Link(edge[i].second, edge[i].first, i);\n      vis[i] = true;\n    }\n  }\n  Req = dfs(1, 0);\n}\ninline void solve() {\n  if (!Req) {\n    printf(\"YES\\n\");\n    for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", val[i]);\n    return;\n  }\n  if (abs(Req) & 1) printf(\"NO\"), exit(0);\n  long long tmp;\n  for (int i = 1; i <= m; ++i) {\n    if (!vis[i]) {\n      if (tmp = check(edge[i].first, edge[i].second)) {\n        printf(\"YES\\n\");\n        tmp = tmp * Req / 2;\n        val[i] = tmp;\n        Adapt(edge[i].first, edge[i].second, -tmp);\n        for (int j = 1; j <= m; ++j) {\n          printf(\"%lld\\n\", val[j]);\n        }\n        return;\n      }\n    }\n  }\n  printf(\"NO\");\n}\nint main() {\n  init();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, a[100069], sm[2], dg[100069], sq[100069];\npair<long long, long long> ed[100069];\nvector<pair<long long, long long>> al[100069];\nbitset<100069> vtd, dh, spc, ex;\nqueue<long long> q;\nvoid dfs(long long x) {\n  long long i, sz = al[x].size(), l, p;\n  vtd[x] = 1;\n  sm[dh[x]] += a[x];\n  for (i = 0; i < sz; i++) {\n    l = al[x][i].first;\n    p = al[x][i].second;\n    if (!vtd[l]) {\n      dh[l] = !dh[x];\n      dfs(l);\n      ex[p] = 1;\n    } else if (dh[l] == dh[x]) {\n      spc[p] = 1;\n    }\n  }\n}\nint main() {\n  long long i, k, l, p, sz;\n  scanf(\"%lld%lld\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%lld\", a + i);\n  }\n  for (i = 1; i <= m; i++) {\n    scanf(\"%lld%lld\", &k, &l);\n    ed[i] = {k, l};\n    al[k].push_back({l, i});\n    al[l].push_back({k, i});\n  }\n  dfs(1);\n  for (i = 1; i <= m; i++) {\n    k = ed[i].first;\n    l = ed[i].second;\n    if (spc[i]) {\n      sq[i] = (sm[dh[k]] - sm[!dh[k]]) / 2;\n      a[k] -= sq[i];\n      a[l] -= sq[i];\n      sm[dh[k]] = sm[!dh[k]];\n    }\n    dg[k] += ex[i];\n    dg[l] += ex[i];\n  }\n  if (sm[0] != sm[1]) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  for (i = 1; i <= n; i++) {\n    if (dg[i] == 1) {\n      q.push(i);\n    }\n  }\n  for (; !q.empty();) {\n    k = q.front();\n    q.pop();\n    sz = al[k].size();\n    for (i = 0; i < sz; i++) {\n      l = al[k][i].first;\n      p = al[k][i].second;\n      if (ex[p]) {\n        sq[p] = a[k];\n        a[l] -= a[k];\n        ex[p] = 0;\n        dg[l]--;\n        if (dg[l] == 1) {\n          q.push(l);\n        }\n      }\n    }\n  }\n  printf(\"YES\\n\");\n  for (i = 1; i <= m; i++) {\n    printf(\"%lld\\n\", sq[i]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint m;\nbool vis[100002];\nvector<int> v[100002];\nlong long int c[100002];\nint dep[100002];\nvector<pair<int, int> > V;\nvector<int> g[100002];\nlong long int sum[2];\ninline void dfs(int b, int pr = -1, int d = 0) {\n  sum[d % 2] += c[b];\n  dep[b] = d;\n  vis[b] = true;\n  for (int go : v[b]) {\n    if (go == pr) continue;\n    if (vis[go]) {\n      if ((dep[b] - dep[go]) % 2 == 0) {\n        V.push_back(make_pair(b, go));\n      }\n      continue;\n    }\n    g[b].push_back(go);\n    dfs(go, b, d + 1);\n  }\n}\nmap<pair<int, int>, int> ids;\nmap<pair<int, int>, long long int> mp;\ninline long long int dfs2(int b, int pr = -1) {\n  if (g[b].size() == 0) {\n    mp[make_pair(pr, b)] = c[b];\n    return c[b];\n  }\n  long long int ret = 0;\n  for (int go : g[b]) {\n    ret += dfs2(go, b);\n  }\n  long long int need = c[b] - ret;\n  if (need) {\n    mp[make_pair(pr, b)] = need;\n  }\n  return need;\n}\nlong long int ans[100002];\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &c[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--;\n    b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n    ids[make_pair(a, b)] = i;\n    ids[make_pair(b, a)] = i;\n  }\n  dfs(0);\n  if (sum[0] != sum[1] && V.size() == 0) {\n    puts(\"NO\");\n    return 0;\n  }\n  long long int weigh = sum[0] - sum[1];\n  while (weigh != 0) {\n    if (V.size() == 0) {\n      puts(\"NO\");\n      return 0;\n    }\n    int a = V.back().first;\n    int b = V.back().second;\n    V.pop_back();\n    long long int add = 0;\n    if (dep[a] & 1) {\n      add += weigh / 2;\n      sum[1] += add * 2;\n    } else {\n      add += weigh / 2;\n      add = -add;\n      sum[0] += add * 2;\n    }\n    c[a] += add;\n    c[b] += add;\n    mp[make_pair(a, b)] = -add;\n    weigh = sum[0] - sum[1];\n  }\n  dfs2(0);\n  for (auto it : mp) {\n    ans[ids[it.first]] = it.second;\n  }\n  puts(\"YES\");\n  for (int i = 0; i < m; i++) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1E5 + 77;\nstruct REDGE {\n  int x, y;\n  long long v;\n} redges[maxn];\nstruct EDGE {\n  int to, next, idx;\n} edges[maxn * 2];\nint cEdge = 1, head[maxn];\nvoid addEdge(int from, int to, int idx) {\n  edges[cEdge] = (EDGE){to, head[from], idx};\n  head[from] = cEdge++;\n}\nint N, M;\nint C[maxn];\nint ek;\nlong long sum[2];\nint vis[maxn];\nbool dfs1(int u, int d, int t) {\n  if (vis[u]) {\n    if (vis[u] != d) {\n      ek = edges[t].idx;\n      return false;\n    } else {\n      return true;\n    }\n  }\n  vis[u] = d;\n  sum[d - 1] += C[u];\n  for (int k = head[u]; k; k = edges[k].next) {\n    int v = edges[k].to;\n    if (!dfs1(v, 3 - d, k)) return false;\n  }\n  return true;\n}\nbool bipart() { return dfs1(1, 1, 0); }\nvoid dfs2(int u, int t) {\n  long long suc = 0;\n  vis[u] = 1;\n  for (int k = head[u]; k; k = edges[k].next) {\n    int v = edges[k].to;\n    if (vis[v]) continue;\n    dfs2(v, k);\n    suc += redges[edges[k].idx].v;\n  }\n  if (t) redges[edges[t].idx].v = C[u] - suc;\n}\nint pk[maxn];\nint vis3[maxn];\nvoid dfs3(int u) {\n  vis3[u] = true;\n  for (int k = head[u]; k; k = edges[k].next) {\n    int v = edges[k].to;\n    if (vis3[v]) continue;\n    if (!vis[v] || vis[v] == vis[u]) continue;\n    pk[v] = edges[k].idx;\n    dfs3(v);\n  }\n}\nbool vis4[maxn];\nvoid dfs4(int u) {\n  long long suc = 0;\n  vis4[u] = true;\n  for (int k = head[u]; k; k = edges[k].next) {\n    int v = edges[k].to;\n    if (vis4[v]) continue;\n    if (pk[v] && pk[v] != edges[k].idx) continue;\n    pk[v] = edges[k].idx;\n    dfs4(v);\n    suc += redges[pk[v]].v;\n  }\n  if (pk[u]) redges[pk[u]].v = C[u] - suc;\n}\nint altro(int k, int v) {\n  if (redges[k].x == v)\n    return redges[k].y;\n  else\n    return redges[k].x;\n}\nvoid solveNoBipart() {\n  int r = redges[ek].x;\n  dfs3(r);\n  dfs4(r);\n  long long d = C[r];\n  for (int k = head[r]; k; k = edges[k].next) {\n    d -= redges[edges[k].idx].v;\n  }\n  d >>= 1;\n  redges[ek].v = d;\n  for (int u = redges[ek].y; u != r; u = altro(pk[u], u)) {\n    d = -d;\n    redges[pk[u]].v += d;\n  }\n}\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", C + i);\n  for (int i = 1; i <= M; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    addEdge(x, y, i);\n    addEdge(y, x, i);\n    redges[i] = (REDGE){x, y};\n  }\n  if (bipart()) {\n    if (sum[0] == sum[1]) {\n      memset(vis, 0, sizeof(vis));\n      dfs2(1, 0);\n    } else {\n      printf(\"NO\\n\");\n      return 0;\n    }\n  } else {\n    solveNoBipart();\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= M; ++i) {\n    cout << redges[i].v << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nstruct eT {\n  void setd(int _u, int _v, int _l) { u = _u, v = _v, last = _l; }\n  int u, v, last;\n} edge[MAXN * 2];\nint n, m;\nint ke, la[MAXN];\nlong long c[MAXN];\nbool vis[MAXN];\nlong long ans[MAXN];\nint si[MAXN];\nbool ins[MAXN];\nint stk[MAXN], top;\nint kc, cyc[MAXN], ce[MAXN];\nvoid init();\nvoid input();\nvoid work();\nbool findcyc(int now, int fa);\nlong long dfs(int now, int fe);\nint main() {\n  init();\n  input();\n  work();\n}\nvoid init() { ios::sync_with_stdio(false); }\nvoid input() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%I64d\", &c[i]);\n  ke = 0;\n  memset(la, -1, sizeof(la));\n  int u, v;\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    edge[ke].setd(u, v, la[u]);\n    la[u] = ke++;\n    edge[ke].setd(v, u, la[v]);\n    la[v] = ke++;\n  }\n}\nvoid work() {\n  if (findcyc(1, -1)) {\n    memset(vis, false, sizeof(vis));\n    dfs(cyc[1], -1);\n    long long del = c[cyc[1]] / 2;\n    cyc[kc + 1] = cyc[1];\n    for (int i = 1; i <= kc; ++i) {\n      int now = cyc[i];\n      for (int j = la[now]; ~j; j = edge[j].last) {\n        if (edge[j].v == cyc[i + 1]) {\n          if (i & 1)\n            ans[j >> 1] += del;\n          else\n            ans[j >> 1] -= del;\n        }\n      }\n    }\n  } else {\n    memset(vis, false, sizeof(vis));\n    dfs(1, -1);\n    if (c[1]) {\n      printf(\"NO\\n\");\n      return;\n    }\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i < m; ++i) printf(\"%I64d\\n\", ans[i]);\n}\nbool findcyc(int now, int fa) {\n  if (vis[now]) {\n    if (ins[now] && ((top - si[now]) & 1)) {\n      kc = top - si[now];\n      for (int i = 1; i <= kc; ++i) cyc[i] = stk[si[now] + i - 1];\n      return true;\n    } else\n      return false;\n  }\n  vis[now] = true;\n  ins[now] = true;\n  si[now] = top;\n  stk[top++] = now;\n  for (int i = la[now]; ~i; i = edge[i].last) {\n    if (edge[i].v ^ fa) {\n      if (findcyc(edge[i].v, now)) return true;\n    }\n  }\n  ins[now] = false;\n  --top;\n  return false;\n}\nlong long dfs(int now, int fe) {\n  if (vis[now]) return 0;\n  vis[now] = true;\n  for (int i = la[now]; ~i; i = edge[i].last) {\n    c[now] -= dfs(edge[i].v, i >> 1);\n  }\n  if (~fe) {\n    long long ret = c[now];\n    ans[fe] += c[now];\n    c[now] = 0;\n    return ret;\n  } else\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x, y, sz, n, m;\nconst int N = 3e5;\nlong long a[N], cs[N];\nvector<int> lst;\nint st[N], tin[N], mar[N];\nmap<int, int> mp[N];\nvector<pair<int, int> > ed[N];\nvoid dfs(int x, int y) {\n  sz++;\n  st[sz] = x;\n  tin[x] = sz;\n  mar[x] = y;\n  for (int i = 0; i < ed[x].size(); i++) {\n    int to = ed[x][i].first;\n    if (mar[to] == 0)\n      dfs(to, 3 - y);\n    else if (mar[to] == y && lst.size() == 0) {\n      for (int j = tin[to]; j <= sz; j++) lst.push_back(st[j]);\n      return;\n    }\n  }\n  sz--;\n}\nvoid go(int x, int lnk) {\n  mar[x] = 1;\n  long long need = 0;\n  for (int i = 0; i < ed[x].size(); i++) {\n    int to = ed[x][i].first;\n    if (mar[to] == 1) continue;\n    go(to, ed[x][i].second);\n    need += cs[ed[x][i].second];\n  }\n  cs[lnk] = a[x] - need;\n}\nvoid chck() {\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < ed[i].size(); j++) {\n      int nm = ed[i][j].second;\n      a[i] -= cs[nm];\n    }\n    if (a[i] != 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= m; i++) cout << cs[i] << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 1; i <= m; i++) {\n    cin >> x >> y;\n    mp[x][y] = i;\n    mp[y][x] = i;\n    ed[x].push_back(make_pair(y, i));\n    ed[y].push_back(make_pair(x, i));\n  }\n  dfs(1, 1);\n  for (int i = 1; i <= n; i++) mar[i] = 0;\n  if (lst.size() == 0) {\n    go(1, 0);\n    chck();\n  } else {\n    int root = lst[0];\n    go(root, 0);\n    long long need = a[root];\n    for (int i = 0; i < ed[root].size(); i++) {\n      int nm = ed[root][i].second;\n      need -= cs[nm];\n    }\n    lst.push_back(lst[0]);\n    need /= 2;\n    int zn = 1;\n    for (int i = 0; i + 1 < lst.size(); i++) {\n      int nm = mp[lst[i]][lst[i + 1]];\n      cs[nm] += need * zn;\n      zn *= -1;\n    }\n    chck();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct edge {\n  int u, v;\n  int adj(int x) { return u + v - x; }\n};\nint n, c[N];\nvector<int> adj[N];\nvector<edge> e;\nint lvl[N], pre[N], root;\nvector<int> cycle;\nvoid dfs1(int u) {\n  for (auto ind : adj[u])\n    if (ind != pre[u]) {\n      auto ei = e[ind];\n      int v = ei.adj(u);\n      if (lvl[v]) {\n        if ((lvl[u] + lvl[v]) % 2 == 0 && cycle.empty()) {\n          for (int w = u; w != v; w = e[pre[w]].adj(w)) cycle.push_back(pre[w]);\n          reverse((cycle).begin(), (cycle).end());\n          cycle.push_back(ind);\n          root = v;\n        }\n      } else {\n        lvl[v] = lvl[u] + 1;\n        pre[v] = ind;\n        dfs1(v);\n      }\n    }\n}\nlong long int ans[N];\nbool vis[N];\nlong long int dfs2(int u, int pre) {\n  if (vis[u]) return 0;\n  vis[u] = 1;\n  long long int sum = 0;\n  for (auto ind : adj[u])\n    if (ind != pre) {\n      int v = e[ind].adj(u);\n      sum += dfs2(v, ind);\n    }\n  if (pre != -1) ans[pre] = c[u] - sum;\n  return c[u] - sum;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int m;\n  cin >> n >> m;\n  for (int i = 0; i < (int)(n); i++) cin >> c[i];\n  e.resize(m);\n  for (int i = 0; i < (int)(m); i++) {\n    cin >> e[i].u >> e[i].v;\n    e[i].u--;\n    e[i].v--;\n    adj[e[i].u].push_back(i);\n    adj[e[i].v].push_back(i);\n  }\n  bool ok = 1;\n  for (int u = 0; u < (int)(n); u++)\n    if (!lvl[u]) {\n      cycle.clear();\n      lvl[u] = 1;\n      pre[u] = -1;\n      dfs1(u);\n      if (cycle.empty()) {\n        ok &= dfs2(u, -1) == 0;\n      } else {\n        auto delta = dfs2(root, -1) / 2;\n        for (auto ind : cycle) {\n          ans[ind] += delta;\n          delta = -delta;\n        }\n      }\n    }\n  if (ok) {\n    cout << \"YES\\n\";\n    for (int i = 0; i < (int)(m); i++) cout << ans[i] << '\\n';\n  } else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int M = N * 25;\nint n, m;\nlong long C[M], x, y, tar[N], dep[N], in[M];\nint fir[N], ne[M], to[M], cnt = 1, fa[N], fan[N];\nvoid add(int x, int y) {\n  ne[++cnt] = fir[x];\n  fir[x] = cnt;\n  to[cnt] = y;\n}\nvoid link(int x, int y) {\n  add(x, y);\n  add(y, x);\n}\nbool vis[N];\nint dfs(int x, int f) {\n  int res = 0;\n  fa[x] = f;\n  dep[x] = dep[f] + 1;\n  vis[x] = 1;\n  for (int i = fir[x]; i; i = ne[i]) {\n    int V = to[i];\n    if (vis[V]) {\n      if (V != f) {\n        if ((dep[V] + dep[x]) & 1)\n          ;\n        else\n          res = i;\n      }\n      continue;\n    }\n    int cur = 0;\n    if (cur = dfs(V, x)) res = cur;\n    if (tar[V]) {\n      tar[x] -= tar[V];\n      C[i] += tar[V];\n      C[i ^ 1] += tar[V];\n      tar[V] = 0;\n    }\n    fan[V] = i;\n  }\n  return res;\n}\nvoid Bush(int x) {\n  while (1) {\n    if (!fa[x]) break;\n    if (tar[x]) {\n      tar[fa[x]] -= tar[x];\n      C[fan[x]] += tar[x];\n      C[fan[x] ^ 1] += tar[x];\n      tar[x] = 0;\n    }\n    x = fa[x];\n  }\n}\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", &tar[i]);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    link(x, y);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      int cur = dfs(i, 0);\n      if ((abs(tar[i]) & 1) || (!cur && tar[i])) {\n        return puts(\"NO\") * 0;\n      }\n      if (dep[to[cur]] & 1) {\n        C[cur] = C[cur ^ 1] += tar[i] / 2;\n        tar[to[cur ^ 1]] = tar[to[cur]] = -tar[i] / 2;\n      } else {\n        C[cur] = C[cur ^ 1] -= tar[i] / 2;\n        tar[to[cur ^ 1]] = tar[to[cur]] = tar[i] / 2;\n      }\n      Bush(to[cur]);\n      Bush(to[cur ^ 1]);\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", C[i * 2]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nchar buf[1 << 12], *pp1 = buf, *pp2 = buf, nc;\nint ny;\ninline char gc() {\n  return pp1 == pp2 &&\n                 (pp2 = (pp1 = buf) + fread(buf, 1, 1 << 12, stdin), pp1 == pp2)\n             ? EOF\n             : *pp1++;\n}\ninline int read() {\n  int x = 0;\n  for (ny = 1; nc = gc(), (nc < 48 || nc > 57) && nc != EOF;)\n    if (nc == 45) ny = -1;\n  if (nc < 0) return nc;\n  for (x = nc - 48; nc = gc(), 47 < nc && nc < 58 && nc != EOF;\n       x = (x << 3) + (x << 1) + (nc ^ 48))\n    ;\n  return x * ny;\n}\nint n, m, vis[MAXN], d[MAXN], Fa[MAXN], pre[MAXN];\nlong long c[MAXN], p[MAXN];\nvector<pair<int, int> > G[MAXN];\nvoid dfs(int x, int fa, int id) {\n  vis[x] = 1, d[x] = d[fa] + 1, Fa[x] = fa, pre[x] = id;\n  for (auto y : G[x])\n    if (!vis[y.first]) dfs(y.first, x, y.second);\n  if (fa) p[id] = c[x], c[fa] -= c[x], c[x] = 0;\n}\nvoid dfs1(int x, int fa) {\n  vis[x] = 2;\n  for (auto y : G[x])\n    if (vis[y.first] == 2) {\n      int t = (d[x] & 1 ? 1 : -1) + (d[y.first] & 1 ? 1 : -1);\n      if (!t) continue;\n      p[y.second] = c[1] / t;\n      for (int a = x, tmp = c[1] / t; Fa[a];\n           p[pre[a]] -= tmp, a = Fa[a], tmp *= -1)\n        ;\n      for (int a = y.first, tmp = c[1] / t; Fa[a];\n           p[pre[a]] -= tmp, a = Fa[a], tmp *= -1)\n        ;\n      puts(\"YES\");\n      for (int i = 1; i <= m; i++) cout << p[i] << \"\\n\";\n      exit(0);\n    } else\n      dfs1(y.first, x);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) c[i] = read();\n  for (int i = 1; i <= m; i++) {\n    int x = read(), y = read();\n    G[x].emplace_back(y, i), G[y].emplace_back(x, i);\n  }\n  dfs(1, 0, 0);\n  if (c[1] == 0) {\n    puts(\"YES\");\n    for (int i = 1; i <= m; i++) cout << p[i] << \"\\n\";\n    return 0;\n  } else {\n    if (c[1] & 1)\n      puts(\"NO\");\n    else\n      dfs1(1, 0), puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint N, M;\nlong long C[MAXN], csum[MAXN];\nint A[MAXN], B[MAXN];\nmap<int, int> mpid[MAXN];\nvector<int> adj[MAXN];\nint par[MAXN];\nint ord[MAXN], cord;\nint col[MAXN];\nint odde = -1;\nlong long ans[MAXN];\nvoid addedge(int id, long long w) {\n  ;\n  ans[id] += w;\n  csum[A[id]] -= w;\n  csum[B[id]] -= w;\n}\nvoid addedge(int a, int b, long long w) { addedge(mpid[a][b], w); }\nvoid printans() {\n  for (int i = 1; i <= N; i++) {\n    assert(csum[i] == 0);\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= M; i++) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n  exit(0);\n}\nvector<int> ocyc;\nvoid dfs(int x, int c, bool newcyc) {\n  col[x] = c;\n  ord[x] = ++cord;\n  for (int y : adj[x]) {\n    if (y == par[x]) {\n      continue;\n    }\n    if (ord[y] != 0) {\n      if (ord[y] < ord[x]) {\n        if (newcyc && odde == -1 && col[y] == c) {\n          odde = mpid[x][y];\n          for (int i = x;; i = par[i]) {\n            ocyc.push_back(i);\n            if (i == y) {\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      par[y] = x;\n      dfs(y, !c, newcyc);\n      addedge(x, y, csum[y]);\n    }\n  }\n}\nint main() {\n  scanf(\"%d %d\", &N, &M);\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%lld\", &C[i]);\n    csum[i] = C[i];\n  }\n  for (int i = 1; i <= M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    mpid[a][b] = mpid[b][a] = i;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n    A[i] = a;\n    B[i] = b;\n  }\n  memset(col, -1, sizeof(col));\n  dfs(1, 0, true);\n  if (odde == -1) {\n    if (csum[1]) {\n      puts(\"NO\");\n      return 0;\n    }\n    printans();\n  };\n  cord = 0;\n  for (int i = 1; i <= max(N, M); i++) {\n    csum[i] = C[i];\n    par[i] = 0;\n    ord[i] = 0;\n    col[i] = -1;\n    ans[i] = 0;\n  }\n  int root = A[odde];\n  ;\n  dfs(root, 0, false);\n  ;\n  rotate(ocyc.begin(), find((ocyc).begin(), (ocyc).end(), root), ocyc.end());\n  long long val = csum[root] / 2;\n  ;\n  for (int i = 0, sgn = 1; i < ocyc.size(); i++, sgn *= -1) {\n    ;\n    addedge(ocyc[i], ocyc[(i + 1) % ocyc.size()], sgn * val);\n  }\n  printans();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint head[100010], nxt[100010 * 2], to[100010 * 2], fa[100010], fr[100010];\nint dep[100010];\nlong long ans[100010], w[100010];\nint n, m, num, e;\nlong long sum[2];\nvoid addedge(int x, int y) {\n  num++;\n  to[num] = y;\n  nxt[num] = head[x];\n  head[x] = num;\n}\nvoid dfs(int x) {\n  sum[dep[x] & 1] += w[x];\n  for (int p = head[x]; p; p = nxt[p])\n    if (to[p] != fa[x]) {\n      if (!dep[to[p]])\n        dep[to[p]] = dep[x] + 1, fa[to[p]] = x, fr[to[p]] = p, dfs(to[p]);\n      else if ((dep[x] - dep[to[p]] + 1) & 1)\n        e = p;\n    }\n}\nvoid solve(int x) {\n  for (int p = head[x]; p; p = nxt[p])\n    if (fa[to[p]] == x) solve(to[p]), w[x] -= ans[p / 2];\n  ans[fr[x] / 2] = w[x];\n  w[x] -= ans[fr[x] / 2];\n}\nint main() {\n  num = 1;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &w[i]);\n  for (int i = 1; i <= m; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y);\n    addedge(y, x);\n  }\n  dep[1] = 1;\n  dfs(1);\n  if ((sum[1] - sum[0]) & 1) {\n    puts(\"NO\");\n    return 0;\n  }\n  if (!e && sum[1] != sum[0]) {\n    puts(\"NO\");\n    return 0;\n  }\n  if (e && sum[1] != sum[0]) {\n    if (dep[to[e]] & 1)\n      ans[e / 2] = (sum[1] - sum[0]) / 2, sum[1] = sum[0];\n    else\n      ans[e / 2] = (sum[0] - sum[1]) / 2, sum[0] = sum[1];\n    w[to[e]] -= ans[e / 2];\n    w[to[e ^ 1]] -= ans[e / 2];\n  }\n  solve(1);\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%I64d\\n\", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, tot = 1, sz, e, Dep[100000 + 5], Head[100000 + 5], Fa[100000 + 5],\n          Ord[100000 + 5];\nlong long Sum[2], A[100000 + 5], Ans[100000 + 5];\nstruct Edge {\n  int next, node;\n  long long w;\n} h[100000 + 5 << 1];\nvoid addedge(int u, int v) {\n  h[++tot].next = Head[u], Head[u] = tot;\n  h[tot].node = v;\n}\nvoid dfs(int z, int fa) {\n  Ord[z] = z;\n  Sum[Dep[z] & 1] += A[z];\n  for (int i = Head[z]; i; i = h[i].next) {\n    int d = h[i].node;\n    if (d == fa) continue;\n    if (Dep[d] && (Dep[d] + Dep[z] + 1 & 1))\n      e = i >> 1;\n    else if (!Dep[d]) {\n      Dep[d] = Dep[z] + 1;\n      Fa[d] = i;\n      dfs(d, z);\n    }\n  }\n}\nbool cmp(int u, int v) { return Dep[u] < Dep[v]; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", A + i);\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v);\n    addedge(v, u);\n  }\n  dfs(Dep[1] = 1, 0);\n  if (Sum[0] + Sum[1] & 1) {\n    puts(\"NO\");\n    return 0;\n  }\n  if (Sum[0] != Sum[1]) {\n    if (!e) {\n      puts(\"NO\");\n      return 0;\n    } else {\n      if (Dep[h[e << 1].node] & 1) {\n        Ans[e] = Sum[1] - Sum[0] >> 1;\n        Sum[1] = Sum[0];\n      } else {\n        Ans[e] = Sum[0] - Sum[1] >> 1;\n        Sum[0] = Sum[1];\n      }\n      A[h[e << 1].node] -= Ans[e];\n      A[h[e << 1 | 1].node] -= Ans[e];\n    }\n  }\n  sort(Ord + 1, Ord + n + 1, cmp);\n  for (int i = n; i > 1; i--) {\n    int z = Ord[i], t = Fa[z];\n    Ans[t >> 1] = A[z];\n    A[z] -= Ans[t >> 1];\n    A[h[t ^ 1].node] -= Ans[t >> 1];\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= m; i++) printf(\"%lld\\n\", Ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 9;\nvector<pair<long long, long long> > adj[N];\nlong long a[N], mrk[N], is = 1, root = 1, sum[N], ans[N];\nvector<long long> cyc;\npair<long long, long long> par[N];\nvoid DFS1(long long u) {\n  for (pair<long long, long long> v : adj[u]) {\n    if (!mrk[v.first]) {\n      mrk[v.first] = 3 - mrk[u];\n      par[v.first] = {u, v.second};\n      DFS1(v.first);\n    } else if (is && mrk[v.first] == mrk[u]) {\n      is = 0, root = u;\n      long long x = u;\n      while (x != v.first) {\n        cyc.push_back(par[x].second);\n        x = par[x].first;\n      }\n      cyc.push_back(v.second);\n    }\n  }\n}\nvoid DFS2(long long u) {\n  mrk[u] = 1;\n  for (pair<long long, long long> v : adj[u]) {\n    if (!mrk[v.first]) {\n      DFS2(v.first);\n      ans[v.second] = a[v.first] - sum[v.first];\n      sum[u] += ans[v.second];\n    }\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  for (long long i = 0; i < m; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back({v, i});\n    adj[v].push_back({u, i});\n  }\n  mrk[1] = 1;\n  DFS1(1);\n  fill(mrk, mrk + N, 0);\n  DFS2(root);\n  if (is && a[root] != sum[root]) return cout << \"NO\", 0;\n  cout << \"YES\" << endl;\n  if (!is)\n    for (long long i = 0, t = 1; i < cyc.size(); i++, t *= -1)\n      ans[cyc[i]] += t * (a[root] - sum[root]) / 2;\n  for (long long i = 0; i < m; i++) cout << ans[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 50;\nstruct Edg {\n  int d, ind;\n};\nvector<Edg> g[N];\nint n, m, col[N], vis[N], pre[N], pre_ind[N];\nint cir_s, cir_t, cir_edg, dfn[N];\nbool act[N], find_odd_circle;\nlong long ans[N], c[N];\nvoid dfs(int v) {\n  vis[v] = true;\n  for (auto t : g[v]) {\n    int d = t.d, ind = t.ind;\n    if (!vis[d]) {\n      col[d] = col[v] ^ 1;\n      pre[d] = v;\n      pre_ind[d] = ind;\n      dfn[d] = dfn[v] + 1;\n      act[ind] = true;\n      dfs(d);\n    } else if (dfn[d] < dfn[v]) {\n      if (col[v] == col[d]) {\n        find_odd_circle = true;\n        cir_s = v, cir_t = d;\n        cir_edg = ind;\n      }\n    }\n  }\n}\nvoid solve_tree(int v) {\n  vis[v] = 1;\n  ;\n  for (auto t : g[v]) {\n    int d = t.d, ind = t.ind;\n    if (vis[d] || (!act[ind])) continue;\n    solve_tree(d);\n    ;\n    ans[ind] = c[d];\n    c[d] = 0;\n    c[v] -= ans[ind];\n  }\n}\nint main(int argc, char *argv[]) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= (n); ++i) {\n    scanf(\"%lld\", c + i);\n  }\n  for (int i = 1; i <= (m); ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a].push_back(Edg{b, i});\n    g[b].push_back(Edg{a, i});\n  }\n  dfs(1);\n  if (!find_odd_circle) {\n    memset(vis, 0, sizeof(vis));\n    solve_tree(1);\n    if (c[1] == 0) {\n      printf(\"YES\\n\");\n      for (int i = 1; i <= (m); ++i) printf(\"%lld\\n\", ans[i]);\n      return 0;\n    } else {\n      printf(\"NO\\n\");\n    }\n  } else {\n    printf(\"YES\\n\");\n    memset(vis, 0, sizeof(vis));\n    solve_tree(cir_s);\n    ;\n    for (int i = 1; i <= (n); ++i)\n      ;\n    for (int i = 1; i <= (m); ++i)\n      ;\n    long long w = c[cir_s] / 2, f = 1;\n    for (int v = cir_s; v != cir_t; v = pre[v]) {\n      ans[pre_ind[v]] += f * w;\n      f = -f;\n    }\n    ans[cir_edg] += f * w;\n    for (int i = 1; i <= (m); ++i) printf(\"%lld\\n\", ans[i]);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D901 {\n\t\n\tint n;\n\tLinkedList<Edge>[] adj;\n\tlong[] c;\n\tHashMap<Edge,Edge> edges;\n\tEdge[] edgeArray;\n\t\n\tprivate void solve() throws Exception {\n\t\tn = nextInt();\n\t\tint m = nextInt();\n\t\t\n\t\tedgeArray = new Edge[m];\n\t\tedges = new HashMap<Edge,Edge>();\n\t\t\n\n\t\tc = new long[n];\n\t\tfor(int i = 0; i < n; i++) c[i] = nextInt();\n\t\t\t\n\t\t\n\t\tadj = new LinkedList[n];\n\t\tfor(int i = 0; i < n; i++) adj[i] = new LinkedList<Edge>();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u = nextInt()-1;\n\t\t\tint v = nextInt()-1;\n\t\t\tEdge e = new Edge(u, v);\n\t\t\tedgeArray[i] = e;\n\t\t\tadj[u].addLast(e);\n\t\t\tadj[v].addLast(e);\n\t\t\tedges.put(e,e);\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\tdfsOddDegree(0);\n\n\t\t\n\t\tbfs();\n\t\tboolean ok = true;\n\t\tif(oddCycle != null){\n\t\t\tdfsBipartite(oddCycle[0]);\n\t\t\tfor(int i = 0; i < oddCycle.length; i++) {\n\t\t\t\t int u = oddCycle[i];\n\t\t\t\t int v = oddCycle[(i+1)%oddCycle.length];\n\t\t\t\t Edge e = edges.get(new Edge(u,v));\n\t\t\t\t e.add((i%2==0?1L:-1L)*c[oddCycle[0]]/2L); \n\t\t\t }\n\t\t} else{//bipartite\n\t\t\tdfsBipartite(0);\n\t\t\tif(c[0] != 0L) ok = false; \n\t\t}\n\t\tif(ok){\n\t\t\tout.println(\"YES\");\n\t\t\tfor(int i = 0; i < m; i++) out.println(edgeArray[i].w);\n\t\t}else out.println(\"NO\");\n\t}\n\t\n\tvoid dfsBipartite(int u){\n\t\tvisited = new boolean[n];\n\t\tvisit(u);\n\t}\n\t\n\tvoid dfs(){\n\t\t visited = new boolean[n];\n\t\t int t = oddCycle.length;\n\t\t for(int i = 0; i < t; i++) visited[oddCycle[i]] = true;\n\t\t for(int i = 0; i < t; i++) visit(oddCycle[i]);\n\t\t long last = 0;\n\t\t for(int i = 0; i < t; i++) {\n\t\t\t int u = oddCycle[i];\n\t\t\t int v = oddCycle[(i+1)%t];\n\t\t\t Edge e = edges.get(new Edge(u,v));\n\t\t\t last = c[u]/2L-last;\n\t\t\t e.add(last);\t\t\t \n\t\t }\n\t\t last = 0;\n\t\t for(int i = t-1; i > 0; i--) {\n\t\t\t int u = oddCycle[i];\n\t\t\t int v = oddCycle[i-1];\n\t\t\t Edge e = edges.get(new Edge(u,v));\n\t\t\t last = c[u]/2L-last;\n\t\t\t e.add(last);\t\t\t \n\t\t }\n\t\t\n\t}\n\t\n\tboolean[] visited;\n\t\n\tvoid visit(int u){\n\t\tvisited[u] = true;\n\t\tfor(Edge e:adj[u]){\n\t\t\tint v = e.other(u);\n\t\t\tif(!visited[v]) {\n\t\t\t\tvisit(v);\n\t\t\t\tc[u] -= c[v];\n\t\t\t\te.add(c[v]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint[] p;\n\t\n\tInteger[] oddCycle;\n\t\n\tvoid bfs(){\n\t\tcolor = new int[n];\n\t\tp = new int[n];\n\t\tArrays.fill(color, -1);\n\t\tArrays.fill(p, -1);\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.addLast(0);\n\t\tcolor[0] = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint u = queue.removeFirst();\n\t\t\tfor(Edge e : adj[u]){\n\t\t\t\tint v = e.other(u);\n\t\t\t\tif(color[v] < 0){\n\t\t\t\t\tcolor[v] = 1-color[u];\n\t\t\t\t\tp[v] = u;\n\t\t\t\t\tqueue.addLast(v);\n\t\t\t\t} else if(color[v] + color[u] != 1){\n\t\t\t\t\toddCycle = oddCycle(u,v);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tInteger[] oddCycle(int u, int v){\n\t\tInteger[] pathU = pathToRoot(u);\n\t\tInteger[] pathV = pathToRoot(v);\n\t\tint idx = 0;\n\t\twhile(idx < pathU.length && pathU[idx] == pathV[idx]) idx++;\n\t\tLinkedList<Integer> cycleList = new LinkedList<Integer>();\n\t\tfor(int i = idx-1; i < pathU.length; i++) cycleList.addLast(pathU[i]);\n\t\tfor(int i = pathV.length-1; i >= idx; i--) cycleList.addLast(pathV[i]);\n\t\t\n\t\treturn cycleList.toArray(new Integer[0]);\n\t}\n\t\n\tInteger[] pathToRoot(int u){\n\t\tLinkedList<Integer> pathUList = new LinkedList<Integer>();\n\t\twhile(u >= 0) {\n\t\t\tpathUList.addFirst(u);\n\t\t\tu = p[u];\n\t\t}\n\t\treturn pathUList.toArray(new Integer[0]);\n\t}\n\t\n\tint[] color;\n\t\n\tboolean dfsOddDegree(int u){\n\t\tvisited[u] = true;\n\t\tboolean odd = (adj[u].size()%2==1);\n\t\tfor(Edge e:adj[u]){\n\t\t\tint v = e.other(u);\n\t\t\tif(!visited[v]) {\n\t\t\t\tboolean nextOdd = dfsOddDegree(v); \n\t\t\t\tif(nextOdd)\t{\n\t\t\t\t\te.add(1L);\n\t\t\t\t\tc[e.u]--;\n\t\t\t\t\tc[e.v]--;\n\t\t\t\t}\n\t\t\t\todd = odd ^ nextOdd;\n\t\t\t}\n\t\t}\n\t\treturn odd;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D901().run();\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate float nextFloat() throws IOException {\n\t\treturn Float.parseFloat(nextToken());\n\t}\n\n\tprivate String nextLine() throws IOException {\n\t\treturn new String(in.readLine());\n\t}\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Edge{\n\tint u;\n\tint v;\n\tlong w;\n\t\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + u;\n\t\tresult = prime * result + v;\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tEdge other = (Edge) obj;\n\t\tif (u != other.u)\n\t\t\treturn false;\n\t\tif (v != other.v)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t\n\tpublic Edge(int u, int v){\n\t\tthis.u = Math.min(u, v);\n\t\tthis.v = Math.max(u, v);\n\t\tthis.w = 0L;\n\t}\n\t\n\tpublic int other(int u){\n\t\tif(this.u == u) return this.v;\n\t\telse return this.u;\n\t}\n\t\n\tpublic void add(long s){\n\t\tthis.w += s;\n\t}\n\t\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > vec[100002];\ntuple<long long, long long> tp[100002];\nvector<long long> vt;\nlong long n, m;\nlong long cl[100002], edg = -1, te = 0, sum[3], ans[100002];\nlong long bip(long long x, long long y) {\n  cl[x] = y;\n  sum[y] += vt[x];\n  for (long long i = 0; i < vec[x].size(); ++i) {\n    long long u = vec[x][i].first;\n    long long v = vec[x][i].second;\n    if (cl[u]) {\n      if (cl[u] == cl[x]) edg = v, te = cl[u];\n      continue;\n    }\n    bip(u, 3 - y);\n  }\n  return 0;\n}\nlong long DFS(long long x, long long y, long long z) {\n  cl[x] = 1;\n  for (long long i = 0; i < vec[x].size(); ++i) {\n    long long u = vec[x][i].first;\n    long long v = vec[x][i].second;\n    if (!cl[u]) DFS(u, v, x);\n  }\n  if (x != 0) vt[z] -= vt[x], ans[y] = vt[x];\n  return 0;\n}\nint main() {\n  memset(cl, 0, sizeof(cl)), memset(sum, 0, sizeof(sum)),\n      memset(ans, 0, sizeof(ans));\n  cin >> n >> m;\n  for (long long i = 0; i < n; ++i) {\n    long long x;\n    cin >> x;\n    vt.push_back(x);\n  }\n  for (long long i = 0; i < m; ++i) {\n    long long x, y;\n    cin >> x >> y;\n    x--, y--, vec[x].push_back(make_pair(y, i)),\n        vec[y].push_back(make_pair(x, i));\n    tp[i] = make_tuple(x, y);\n  }\n  bip(0, 1);\n  if (edg == -1 && sum[1] != sum[2]) {\n    cout << \"NO\";\n    return 0;\n  }\n  if (edg != -1) {\n    long long cur = sum[te] - sum[3 - te];\n    if (cur & 1) {\n      cout << \"NO\";\n      return 0;\n    }\n    ans[edg] = cur / 2;\n    long long x = get<0>(tp[edg]);\n    long long y = get<1>(tp[edg]);\n    vt[x] -= cur / 2, vt[y] -= cur / 2;\n  }\n  memset(cl, 0, sizeof(cl));\n  DFS(0, 0, 0);\n  cout << \"YES\" << endl;\n  for (long long i = 0; i < m; ++i) cout << ans[i] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int INF = 2e9;\nconst long long INFLL = 1e18;\nconst int MAX_N = 100000;\nint N, M;\nvector<pair<int, int> > gp[MAX_N + 1];\nint lv[MAX_N + 1];\npair<int, int> p[MAX_N + 1];\nbool vst[MAX_N + 1];\nlong long cost[MAX_N + 1], sum[2];\nlong long ans[MAX_N + 1];\nvector<pair<int, int> > edge;\nint eidx;\nvector<int> v;\nvoid dfs(int x) {\n  vst[x] = true;\n  sum[lv[x] % 2] += cost[x];\n  for (pair<int, int> i : gp[x]) {\n    if (i.first == p[x].first) continue;\n    if (!vst[i.first]) {\n      p[i.first] = {x, i.second};\n      lv[i.first] = lv[x] + 1;\n      dfs(i.first);\n    } else {\n      if (lv[i.first] % 2 == lv[x] % 2) {\n        eidx = i.second;\n      }\n    }\n  }\n  v.push_back(x);\n}\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  eidx = -1;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%lld\", &cost[i]);\n  }\n  for (int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    gp[a].push_back({b, i});\n    gp[b].push_back({a, i});\n    edge.push_back({a, b});\n  }\n  lv[1] = 1;\n  dfs(1);\n  if ((sum[1] - sum[0]) % 2 != 0) {\n    printf(\"NO\");\n    return 0;\n  }\n  if (eidx != -1) {\n    int x = edge[eidx].first, y = edge[eidx].second;\n    long long d = 0;\n    if (lv[x] % 2) {\n      d = (sum[1] - sum[0]) / 2;\n    } else {\n      d = (sum[0] - sum[1]) / 2;\n    }\n    ans[eidx] = d;\n    cost[x] -= d;\n    cost[y] -= d;\n  } else if (sum[1] != sum[0]) {\n    printf(\"NO\");\n    return 0;\n  }\n  for (int i = 0; i < v.size() - 1; i++) {\n    int n = v[i];\n    long long c = cost[n];\n    ans[p[n].second] = c;\n    cost[n] -= c;\n    cost[p[n].first] -= c;\n  }\n  printf(\"YES\\n\");\n  for (int i = 0; i < M; i++) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct node {\n  int first, second, third;\n  node() {}\n  node(int a, int b, int c) { first = a, second = b, third = c; }\n} triple;\nvector<triple> G;\nvector<int> hd, mark, path, c, _path;\nvector<long long> wh;\nvoid add(int u, int v, int w) {\n  G.push_back(triple(v, hd[u], w));\n  hd[u] = G.size() - 1;\n}\nint trav(int x, int t) {\n  int i, j, tmp, k;\n  path.push_back(x);\n  mark[x] = t;\n  for (i = hd[x]; ~i; i = G[i].second) {\n    j = G[i].first;\n    if (mark[j]) {\n      if (mark[j] == mark[x]) {\n        for (k = path.size() - 1; path[k] != j; k--)\n          ;\n        _path.clear();\n        for (; k != path.size(); k++) _path.push_back(path[k]);\n        return j;\n      }\n    } else {\n      tmp = trav(j, 3 - t);\n      if (~tmp) return tmp;\n    }\n  }\n  path.pop_back();\n  return -1;\n}\nvoid wt(int x, int e) {\n  long long w;\n  int i, j, k;\n  mark[x] = 1;\n  w = c[x];\n  for (i = hd[x]; ~i; i = G[i].second) {\n    j = G[i].first;\n    k = G[i].third;\n    if (!mark[j]) {\n      wt(j, k);\n      w -= wh[k];\n    }\n  }\n  if (~e) wh[e] = w;\n}\nvoid cyc(int x, int t, long long d) {\n  int i, j;\n  for (i = hd[x]; ~i; i = G[i].second) {\n    j = G[i].first;\n    if (j != (t == _path.size() ? _path[0] : _path[t])) continue;\n    wh[G[i].third] += d;\n    if (t != _path.size()) cyc(j, t + 1, -d);\n    return;\n  }\n}\nint main() {\n  int n, m, i, u, v, vtx;\n  long long delt;\n  scanf(\"%d%d\", &n, &m);\n  c.clear();\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &v);\n    c.push_back(v);\n  }\n  hd.clear();\n  hd.resize(n, -1);\n  G.clear();\n  for (i = 0; i < m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    add(u, v, i), add(v, u, i);\n  }\n  wh.clear();\n  wh.resize(m, 0LL);\n  mark.clear();\n  mark.resize(n, 0);\n  path.clear();\n  vtx = trav(0, 1);\n  mark.clear();\n  mark.resize(n, 0);\n  wt(~vtx ? vtx : 0, -1);\n  delt = c[~vtx ? vtx : 0];\n  for (i = hd[~vtx ? vtx : 0]; ~i; i = G[i].second) {\n    delt -= wh[G[i].third];\n  }\n  if (vtx == -1 && delt != 0) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  if (~vtx) {\n    cyc(vtx, 1, delt / 2);\n  }\n  printf(\"YES\\n\");\n  for (i = 0; i < m; i++) {\n    printf(\"%lld\\n\", wh[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<int> g[100000];\nlong long c[100000];\nlong long w[100000];\nint uu[100000], vv[100000];\nint col[100000];\nint st[100000], sz = 0;\nvector<int> cyc;\nint cycv = 0;\nbool flag = true;\nbool dfs(int v, int co) {\n  st[sz++] = v;\n  col[v] = co;\n  for (int e : g[v]) {\n    int to = (uu[e] == v ? vv[e] : uu[e]);\n    if (col[to] == -1) {\n      if (dfs(to, co ^ 1)) {\n        if (flag) {\n          cyc.push_back(e);\n          if (v == cycv) {\n            flag = false;\n          }\n        }\n        return true;\n      }\n    } else if (col[to] == col[v] && cyc.empty()) {\n      cyc.push_back(e);\n      cycv = to;\n      flag = true;\n      return true;\n    }\n  }\n  --sz;\n  return false;\n}\nbool used[100000] = {};\nvoid solve(int v) {\n  used[v] = true;\n  for (int e : g[v]) {\n    int to = (uu[e] == v ? vv[e] : uu[e]);\n    if (used[to]) {\n      continue;\n    }\n    solve(to);\n    w[e] = -c[to];\n    c[to] += w[e];\n    c[v] += w[e];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < (int)(n); ++i) scanf(\"%I64d\", c + i), c[i] *= -1;\n  for (int i = 0; i < (int)(m); ++i) {\n    scanf(\"%d%d\", uu + i, vv + i), --uu[i], --vv[i];\n    g[uu[i]].push_back(i);\n    g[vv[i]].push_back(i);\n  }\n  memset(col, -1, sizeof col);\n  dfs(0, 0);\n  solve(cycv);\n  if (c[cycv] != 0) {\n    if (cyc.empty()) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n    long long need = -c[cycv] / 2;\n    for (int x : cyc) {\n      w[x] += need;\n      need *= -1;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < (int)(m); ++i) printf(\"%I64d\\n\", w[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nint n, m, s[MAXN], e[MAXN];\nlong long a[MAXN], w[MAXN];\nvector<pair<int, int> > G[MAXN];\nbool vis[MAXN], dye[MAXN], flag = 1;\nlong long dfs(int u) {\n  vis[u] = 1;\n  long long r = a[u];\n  for (auto e : G[u])\n    if (!vis[e.first]) {\n      dye[e.first] = dye[u] ^ 1;\n      w[e.second] = dfs(e.first);\n      r -= w[e.second];\n    } else if (dye[e.first] == dye[u])\n      flag = 0;\n  return r;\n}\nvoid print() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%lld\\n\", w[i]);\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", a + i);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d%d\", s + i, e + i);\n    G[s[i]].push_back(pair<int, int>(e[i], i));\n    G[e[i]].push_back(pair<int, int>(s[i], i));\n  }\n  long long first = dfs(1);\n  if (!first) {\n    print();\n    return 0;\n  }\n  if (flag) return puts(\"NO\"), 0;\n  int eid = 1;\n  for (; dye[s[eid]] != dye[e[eid]]; ++eid)\n    ;\n  memset(vis, 0, sizeof vis);\n  if (dye[s[eid]])\n    w[eid] = -first / 2;\n  else\n    w[eid] = first / 2;\n  a[s[eid]] -= w[eid];\n  a[e[eid]] -= w[eid];\n  dfs(1);\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ') {\n  while (!isdigit(ch = getchar()))\n    if (ch == '-') f = -1;\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f * x;\n}\nconst int N = 1e5 + 5;\nstruct Edge {\n  int next, to;\n  long long w;\n  Edge(int next = 0, int to = 0, long long w = 0) : next(next), to(to), w(w){};\n} edge[N << 1];\nint tot = 1, head[N];\nvoid _add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot; }\nvoid add(int x, int y) { _add(x, y), _add(y, x); }\nint n, m, f[N], g[N], d[N], vis[N], e[N], t;\nlong long c[N], w[N];\nlong long dfs(int x, int fi) {\n  vis[x] = 1, f[x] = fi;\n  for (int i = head[x]; i; i = edge[i].next)\n    if (i != fi) {\n      int y = edge[i].to;\n      if (vis[y] && ((d[y] ^ d[x] ^ 1) & 1))\n        g[x] = i;\n      else if (!vis[y])\n        vis[y] = 1, d[y] = d[x] + 1, c[x] -= dfs(y, i ^ 1);\n    }\n  return edge[fi].w = edge[fi ^ 1].w = c[x];\n}\nvoid print() {\n  puts(\"YES\");\n  for (int i = 1; i <= m; ++i) printf(\"%I64d\\n\", edge[i << 1].w);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; ++i) c[i] = read();\n  for (int i = 1; i <= m; ++i) {\n    int x = read(), y = read();\n    add(x, y);\n  }\n  d[1] = 1, dfs(1, 0);\n  if (c[1] == 0) return print(), 0;\n  if (~c[1] & 1)\n    for (int o = 1; o <= n; ++o)\n      if (g[o]) {\n        if (d[o] & 1)\n          edge[g[o]].w = edge[g[o] ^ 1].w += c[1] >> 1;\n        else\n          edge[g[o]].w = edge[g[o] ^ 1].w -= c[1] >> 1;\n        for (int i = f[edge[g[o]].to], j = d[edge[g[o]].to] - 1; j;\n             i = f[edge[i].to], --j)\n          if (j & 1)\n            edge[i].w = edge[i ^ 1].w += c[1] >> 1;\n          else\n            edge[i].w = edge[i ^ 1].w -= c[1] >> 1;\n        for (int i = f[o], j = d[o] - 1; j; i = f[edge[i].to], --j)\n          if (j & 1)\n            edge[i].w = edge[i ^ 1].w += c[1] >> 1;\n          else\n            edge[i].w = edge[i ^ 1].w -= c[1] >> 1;\n        return print(), 0;\n      }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 14;\nint n, m;\nstruct Edge {\n  int v, u;\n  long long w;\n  int o(int x) { return x == v ? u : v; }\n} e[maxn];\nvector<Edge*> g[maxn];\nvector<Edge*> cyc, cur;\nEdge* par[maxn];\nint col[maxn];\nlong long c[maxn];\nint mark[maxn];\nbool dfs(int v = 0, int c = 1) {\n  col[v] = c;\n  mark[v] = cur.size() + 1;\n  for (auto e : g[v]) {\n    int u = e->o(v);\n    if (!col[u]) {\n      par[u] = e;\n      cur.push_back(e);\n      if (dfs(u, 3 - c)) return 1;\n      cur.pop_back();\n    } else if (col[u] == c) {\n      cyc.push_back(e);\n      while (!mark[u]) cyc.push_back(par[u]), u = par[u]->o(u);\n      while (u != v) {\n        cyc.push_back(cur[mark[u] - 1]), u = cur[mark[u] - 1]->o(u);\n      }\n      return 1;\n    }\n  }\n  mark[v] = 0;\n  return 0;\n}\nvoid fix(int v, int p = -1) {\n  mark[v] = 1;\n  for (auto e : g[v]) {\n    int u = e->o(v);\n    if (!mark[u]) {\n      fix(u, v);\n      e->w = c[u];\n      c[v] -= c[u];\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  for (int i = 0; i < m; i++) {\n    cin >> e[i].v >> e[i].u;\n    e[i].v--, e[i].u--;\n    g[e[i].v].push_back(&e[i]);\n    g[e[i].u].push_back(&e[i]);\n  }\n  int root = 0;\n  bool hasCy = 0;\n  if (dfs()) {\n    root = -1;\n    for (auto x : {cyc[0]->v, cyc[0]->u})\n      for (auto y : {cyc.back()->v, cyc.back()->u})\n        if (x == y) root = x;\n    assert(root != -1);\n    hasCy = 1;\n  }\n  memset(mark, 0, sizeof mark);\n  fix(root);\n  if (hasCy) {\n    long long x = c[root] / 2;\n    c[root] = 0;\n    for (int i = 0; i < cyc.size(); i++) cyc[i]->w += (i & 1 ? -x : x);\n  }\n  if (!c[root]) {\n    cout << \"YES\\n\";\n    for (int i = 0; i < m; i++) cout << e[i].w << '\\n';\n  } else\n    cout << \"NO\\n\";\n}\n"
        }
    ]
}