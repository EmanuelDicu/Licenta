{
    "name": "1551_F. Equidistant Vertices",
    "source": "CODEFORCES",
    "description": "A tree is an undirected connected graph without cycles.\n\nYou are given a tree of n vertices. Find the number of ways to choose exactly k vertices in this tree (i. e. a k-element subset of vertices) so that all pairwise distances between the selected vertices are equal (in other words, there exists an integer c such that for all u, v (u \u2260 v, u, v are in selected vertices) d_{u,v}=c, where d_{u,v} is the distance from u to v).\n\nSince the answer may be very large, you need to output it modulo 10^9 + 7.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case is preceded by an empty line.\n\nEach test case consists of several lines. The first line of the test case contains two integers n and k (2 \u2264 k \u2264 n \u2264 100) \u2014 the number of vertices in the tree and the number of vertices to be selected, respectively. Then n - 1 lines follow, each of them contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) which describe a pair of vertices connected by an edge. It is guaranteed that the given graph is a tree and has no loops or multiple edges.\n\nOutput\n\nFor each test case output in a separate line a single integer \u2014 the number of ways to select exactly k vertices so that for all pairs of selected vertices the distances between the vertices in the pairs are equal, modulo 10^9 + 7 (in other words, print the remainder when divided by 1000000007).\n\nExample\n\nInput\n\n\n3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n\n\nOutput\n\n\n6\n0\n1",
    "difficulty": "F",
    "tags": [
        "brute force",
        "combinatorics",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "rating": 2200,
    "public_test": [
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n1\n"
        }
    ],
    "generated_test": [
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n4 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 6\n3 1\n6 2\n2 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 5\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 5\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n2 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n5\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 2\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n21\n5\n0\n1\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 11\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 11\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 3\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n2\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 3\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 2\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 2\n1 4\n7 1\n5 1\n10 2\n8 9\n2 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n21\n8\n0\n1\n"
        },
        {
            "input": "1\n\n6 4\n2 4\n1 2\n5 1\n6 1\n3 5\n",
            "output": "0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 3\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n2 5\n",
            "output": "6\n0\n4\n"
        },
        {
            "input": "3\n\n4 4\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 4\n2 5\n",
            "output": "0\n0\n10\n"
        },
        {
            "input": "1\n\n6 4\n1 4\n1 6\n3 1\n6 2\n1 5\n",
            "output": "1\n"
        },
        {
            "input": "3\n\n4 4\n1 2\n2 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n",
            "output": "0\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n1 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n7 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n5\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 3\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n1\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 3\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 2\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "0\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 3\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 4\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n8 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 1\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 1\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n2 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n3\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 2\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n1\n"
        },
        {
            "input": "8\n\n3 3\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "0\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 3\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n4 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 1\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n3 1\n6 2\n2 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n1 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 11\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n8 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n3 1\n6 1\n2 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n7 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n1 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 6\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n1\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n3 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 11\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n7 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n3 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n2 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n1 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n3 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n3 1\n6 1\n3 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n4 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n4 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n7 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 6\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 3\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n2 6\n7 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n3 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n5 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n8 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 5\n4 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n6 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 3\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 3\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n2\n0\n1\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n8 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n1 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n1 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 7\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 2\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n1 5\n",
            "output": "6\n0\n1\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 5\n4 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n1 4\n\n3 3\n1 3\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n1\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 6\n3 1\n1 2\n2 5\n",
            "output": "15\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n6 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 11\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 3\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 5\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 2\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 2\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n21\n5\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 5\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n3 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 4\n1 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n5 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 4\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n7 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n1 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n4 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 2\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n7 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 5\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n9 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 11\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 2\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 5\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n9 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 6\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 1\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n2 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n5\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n5 1\n6 1\n3 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 3\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 4\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n2 6\n7 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n3 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n5 17\n6 16\n3 14\n5 7\n2 10\n14 4\n1 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n8 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 11\n8 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n4 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n10 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n1 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n6 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 11\n1 8\n1 6\n2 11\n11 4\n1 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n4 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 5\n1 2\n2 3\n2 4\n4 5\n",
            "output": "6\n0\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 5\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 4\n2 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n2 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 5\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 9\n5 7\n2 10\n14 5\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "1\n\n6 2\n2 4\n1 2\n5 1\n6 1\n3 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 2\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 3\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 5\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 4\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 2\n1 3\n2 3\n2 4\n3 5\n",
            "output": "6\n0\n10\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n4 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 2\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 3\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 5\n2 5\n1 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 4\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 3\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n4 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n6 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "1\n\n6 2\n2 4\n1 6\n3 1\n6 2\n1 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 2\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 6\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n3 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n3 10\n1 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n1 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 7\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 5\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 2\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 11\n9 6\n5 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 9\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n8 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n10 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n4 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n3 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 3\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 2\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n2 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 2\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 10\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 5\n4 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 4\n5 15\n16 10\n5 9\n8 16\n9 11\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n1 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "5\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 2\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 2\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n5 1\n6 2\n3 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 2\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 5\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n2\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 5\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 5\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 4\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 3\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 1\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n6 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n1 8\n1 6\n2 11\n11 4\n4 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 2\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n6 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 2\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 1\n\n10 4\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 3\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n8 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 1\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 3\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n6 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n2 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 2\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n3 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n4 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n2 5\n",
            "output": "6\n0\n4\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n5 10\n9 4\n7 1\n6 1\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n5 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n1 3\n2 3\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n6 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 8\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n2 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 2\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 8\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 3\n1 3\n2 4\n\n10 2\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 1\n3 17\n6 16\n3 14\n5 7\n2 10\n14 2\n10 4\n16 1\n16 11\n14 12\n13 2\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "1\n\n6 2\n1 4\n1 2\n3 1\n6 2\n3 5\n",
            "output": "15\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n5 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n3\n"
        },
        {
            "input": "3\n\n17 14\n3 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 1\n9 5\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 2\n5 1\n1 3\n3 6\n5 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n0\n1\n21\n5\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n2 3\n2 4\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n10 9\n5 3\n2 4\n6 8\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n1\n4\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n4 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n4 8\n2 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 2\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n2 5\n2 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n1 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n1\n0\n2\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 5\n\n10 4\n2 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 9\n7 2\n\n2 2\n2 1\n\n7 5\n5 1\n1 3\n3 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n3 9\n1 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n1 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n5 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n1 3\n3 10\n4 9\n5 10\n1 4\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 13\n8 16\n9 6\n4 17\n6 16\n3 8\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n7 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n1 15\n16 10\n5 13\n8 16\n9 6\n6 17\n6 16\n3 4\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n4 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n5 7\n2 3\n\n10 4\n8 4\n1 6\n7 2\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        },
        {
            "input": "3\n\n4 2\n1 2\n4 3\n2 4\n\n3 3\n1 3\n2 3\n\n5 5\n1 2\n2 3\n3 4\n4 5\n",
            "output": "6\n0\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 9\n5 7\n2 10\n14 5\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n3 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "1\n\n6 4\n2 4\n1 2\n5 1\n6 2\n3 5\n",
            "output": "0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 5\n2 5\n1 10\n9 4\n7 2\n6 2\n9 5\n3 1\n8 7\n1 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 3\n1 6\n6 4\n3 7\n2 3\n\n10 3\n8 4\n1 4\n7 1\n5 1\n10 2\n8 9\n5 3\n2 1\n6 9\n\n5 5\n1 5\n3 4\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n0\n1\n0\n5\n0\n2\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 9\n8 16\n9 6\n4 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n1 6\n2 11\n11 4\n6 3\n4 10\n4 9\n5 10\n1 5\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 16\n9 6\n3 17\n6 16\n3 14\n5 7\n2 10\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 6\n2 8\n1 6\n2 7\n11 4\n6 3\n4 10\n4 9\n5 10\n2 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "3\n\n17 14\n5 15\n16 10\n5 10\n8 11\n9 6\n5 17\n6 16\n3 14\n5 7\n2 11\n14 4\n10 4\n16 1\n16 11\n14 12\n13 1\n\n2 2\n1 2\n\n11 10\n2 8\n2 6\n2 11\n11 4\n6 3\n3 10\n4 9\n5 10\n1 10\n7 6\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 3\n\n10 2\n1 5\n4 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 4\n\n2 2\n2 1\n\n7 4\n5 2\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 2\n5 1\n10 2\n8 9\n5 3\n2 4\n6 9\n\n5 5\n1 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 1\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n1\n"
        },
        {
            "input": "8\n\n3 2\n3 1\n1 2\n\n5 5\n4 1\n5 4\n1 3\n2 4\n\n10 2\n1 5\n3 10\n9 4\n7 1\n6 2\n9 6\n3 1\n8 7\n7 2\n\n2 2\n2 1\n\n7 4\n5 1\n1 4\n3 6\n6 4\n3 7\n2 3\n\n10 4\n8 4\n1 6\n7 1\n5 1\n10 2\n8 9\n2 3\n2 4\n6 9\n\n5 5\n2 5\n3 5\n1 2\n4 2\n\n8 3\n1 2\n5 8\n5 4\n2 7\n7 6\n8 7\n3 2\n",
            "output": "3\n0\n45\n1\n0\n0\n0\n2\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T>\nvector<T> make_unique(vector<T> a) {\n  sort((a).begin(), (a).end());\n  a.erase(unique((a).begin(), (a).end()), a.end());\n  return a;\n}\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst int N = 111;\nint q[N], dist[N], root[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int>> adj(n);\n    for (int _ = 0; _ < (int)(n - 1); _++) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << (long long int)n * (n - 1) / 2 << endl;\n      continue;\n    }\n    long long int ans = 0;\n    for (int s = 0; s < (int)(n); s++) {\n      fill_n(dist, n, INF);\n      int l = 0, r = 0;\n      dist[s] = 0;\n      q[r++] = s;\n      while (l < r) {\n        int u = q[l++];\n        for (auto v : adj[u]) {\n          if (dist[v] > dist[u] + 1) {\n            dist[v] = dist[u] + 1;\n            root[v] = (u == s ? v : root[u]);\n            q[r++] = v;\n          }\n        }\n      }\n      vector<map<int, int>> cnt(n);\n      for (int u = 0; u < (int)(n); u++) cnt[dist[u]][root[u]]++;\n      for (int d = 0; d < (int)(n); d++) {\n        vector<int> poly(n + 1);\n        poly[0] = 1;\n        for (auto x : cnt[d]) {\n          for (int i = (int)(n)-1; i >= ((int)0); i--) {\n            poly[i + 1] += (long long int)x.second * poly[i] % MOD;\n            if (poly[i + 1] >= MOD) poly[i + 1] -= MOD;\n          }\n        }\n        ans += poly[k];\n      }\n    }\n    cout << ans % MOD << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e18 + 10;\nconst long long mod = 1e9 + 7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst long double P = acos(-1.L);\nint n, k, cnt[105], s[105];\nlong long arr[105];\nvector<int> v[105];\nvector<int> sum[105];\nvoid dfs(int first, int pr, int dep) {\n  cnt[dep]++;\n  for (int i : v[first]) {\n    if (i == pr) continue;\n    dfs(i, first, dep + 1);\n  }\n}\nlong long fact[305], factInv[305];\nlong long mpow(long long first, long long m) {\n  if (!m) return 1;\n  long long tmp = mpow(first, m / 2);\n  tmp = tmp * tmp % mod;\n  if (m % 2) return tmp * first % mod;\n  return tmp;\n}\nlong long Com(long long first, long long r) {\n  return fact[first] * factInv[r] % mod * factInv[first - r] % mod;\n}\nvoid FFT(vector<complex<long double> > &f, bool rev) {\n  int n = f.size();\n  for (int i = 1, j = 0; i < n; i++) {\n    int bit = n >> 1;\n    for (; j >= bit; bit >>= 1) j -= bit;\n    j += bit;\n    if (i < j) swap(f[i], f[j]);\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    vector<complex<long double> > w(k);\n    for (int i = 0; i < k; i++) {\n      long double ang = (rev ? -2 * P * i / (k * 2) : 2 * P * i / (k * 2));\n      w[i] = complex<long double>(cos(ang), sin(ang));\n    }\n    for (int i = 0; i < n; i += (k << 1)) {\n      complex<long double> wp(1, 0);\n      for (int j = 0; j < k; j++) {\n        complex<long double> first = f[i + j], second = f[i + j + k] * w[j];\n        f[i + j] = first + second;\n        f[i + j + k] = first - second;\n      }\n    }\n  }\n  if (rev)\n    for (int i = 0; i < n; i++) f[i] /= n;\n}\nvoid calc(vector<complex<long double> > &a, vector<complex<long double> > &b) {\n  int n = 1;\n  while (n < 2 * max((int)a.size(), (int)b.size())) n <<= 1;\n  a.resize(n);\n  b.resize(n);\n  FFT(a, false);\n  FFT(b, false);\n  for (int i = 0; i < n; i++) a[i] *= b[i];\n  FFT(a, true);\n  for (int i = n - 1; i >= 0; i--) {\n    a[i] = ((long long)round(a[i].real())) % mod;\n  }\n  return;\n}\nvector<complex<long double> > gar;\nvector<complex<long double> > divt(int l, int r) {\n  if (l == r) {\n    gar.clear();\n    gar.push_back(arr[l]);\n    gar.push_back(1);\n    return gar;\n  } else {\n    int mid = (l + r) >> 1;\n    vector<complex<long double> > tmp = divt(l, mid);\n    vector<complex<long double> > tmp2 = divt(mid + 1, r);\n    calc(tmp, tmp2);\n    return tmp;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  fact[0] = 1;\n  for (int i = 1; i <= 300; i++) fact[i] = fact[i - 1] * i % mod;\n  factInv[300] = mpow(fact[300], mod - 2);\n  for (int i = 299; i >= 0; i--) factInv[i] = factInv[i + 1] * (i + 1) % mod;\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) v[i].clear();\n    for (int i = 1; i < n; i++) {\n      int first, second;\n      cin >> first >> second;\n      v[first].push_back(second), v[second].push_back(first);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    long long Ans = 0;\n    for (int i = 1; i <= n; i++) {\n      if (v[i].size() < k) continue;\n      for (int j = 1; j <= n; j++) sum[j].clear();\n      for (int j : v[i]) {\n        for (int l = 1; l <= n; l++) cnt[l] = 0;\n        dfs(j, i, 1);\n        for (int l = 1; l <= n; l++) {\n          if (cnt[l]) sum[l].push_back(cnt[l]);\n        }\n      }\n      for (int j = 1; j <= n; j++) {\n        if (sum[j].size() < k) continue;\n        int sz = sum[j].size();\n        for (int l = 0; l < sz; l++) arr[l + 1] = sum[j][l];\n        arr[sz + 1] = 0;\n        vector<complex<long double> > ans = divt(1, sz);\n        Ans += ans[sz - k].real();\n        Ans %= mod;\n      }\n    }\n    cout << Ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> g[101];\nvector<long long> v[101];\nbool check[101];\nlong long dp[101][101];\nvoid go(int root, int parent, int k) {\n  if (!check[k]) {\n    v[k].push_back(1);\n    check[k] = true;\n  } else\n    v[k].back()++;\n  for (int i = 0; i < (int)g[root].size(); i++)\n    if (g[root][i] != parent) go(g[root][i], root, k + 1);\n}\nlong long f(int k, int m, int t) {\n  if (k < 0) return m == 0 ? 1ll : 0ll;\n  if (dp[k][m] != -1) return dp[k][m];\n  long long temp = f(k - 1, m, t);\n  if (m > 0) temp = (temp + f(k - 1, m - 1, t) * v[t][k]) % 1000000007;\n  dp[k][m] = temp;\n  return temp;\n}\nint main() {\n  int t, n, k, a, b;\n  long long ans, temp;\n  scanf(\"%d\", &t);\n  for (; t > 0; t--) {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d %d\", &a, &b);\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    if (k == 2)\n      printf(\"%d\\n\", n * (n - 1) >> 1);\n    else {\n      ans = 0;\n      for (int i = 1; i <= n; i++) {\n        if ((int)g[i].size() < k) continue;\n        for (int j = 0; j < (int)g[i].size(); j++) {\n          memset(check, false, sizeof(check));\n          go(g[i][j], i, 1);\n        }\n        for (int j = 1; j <= n; j++) {\n          memset(dp, -1, sizeof(dp));\n          temp = f((int)v[j].size() - 1, k, j);\n          ans = (ans + temp) % 1000000007;\n          v[j].clear();\n        }\n      }\n      printf(\"%lld\\n\", ans);\n    }\n    for (int i = 1; i <= n; i++) g[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline void boostIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(0);\n}\nbool isPrime(int x) {\n  if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n  for (int i = 5; i * i <= x; i += 6)\n    if (x % i == 0 || x % (i + 2) == 0) return 0;\n  return 1;\n}\nlong long int gcd(long long int a, long long int b) {\n  return b ? gcd(b, a % b) : a;\n}\nlong long int lcm(long long int a, long long int b) {\n  return a * b / gcd(a, b);\n}\nbool BREAKTIME(long double v) { return 1.0 * clock() >= v * CLOCKS_PER_SEC; }\nlong long mod = 1e9 + 7;\nconst long long inf = 1e18;\nlong long n, k;\nvector<long long> D;\nvoid dfs(long long a, vector<vector<long long>>& adj, long long p) {\n  D[a] = D[p] + 1;\n  for (auto b : adj[a]) {\n    if (b == p) continue;\n    dfs(b, adj, a);\n  }\n}\nint32_t main() {\n  boostIO();\n  long long T;\n  cin >> T;\n  while (T--) {\n    cin >> n >> k;\n    vector<vector<long long>> adj(n + 1);\n    for (long long i = 0; i < (n - 1); ++i) {\n      long long a, b;\n      cin >> a >> b;\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n    long long ans = 0;\n    long long additional = 0;\n    for (long long s = 1; s <= n; ++s) {\n      vector<vector<long long>> A(n + 1);\n      for (auto a : adj[s]) {\n        D = vector<long long>(n + 1);\n        dfs(a, adj, s);\n        vector<long long> d(n + 1);\n        for (long long i = 1; i <= n; ++i) {\n          d[D[i]]++;\n        }\n        for (long long i = 1; i <= n; ++i) {\n          if (d[i] != 0) A[i].push_back(d[i]);\n        }\n      }\n      for (auto v : A) {\n        if (v.size() == 0) continue;\n        vector<long long> e(v.size());\n        for (long long i = 0; i < v.size(); ++i) {\n          e[i] = v[i];\n          if (i != 0) {\n            e[i] += e[i - 1];\n            e[i] %= mod;\n          }\n        }\n        for (long long j = 0; j < k - 1; ++j) {\n          vector<long long> e2(v.size());\n          for (long long i = 0; i < v.size(); ++i) {\n            if (i != 0) {\n              e2[i] = e[i - 1] * v[i];\n              e2[i] += e2[i - 1];\n              e2[i] %= mod;\n            }\n          }\n          e = e2;\n        }\n        ans += e.back();\n        ans %= mod;\n      }\n    }\n    if (k == 2) {\n      ans = n * (n - 1) / 2;\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, sum, vis[150], x, y, it;\nlong long f[105], res, f2[105][105];\nvector<int> v[205];\nvoid dfs(int x, int fa, int d) {\n  vis[x] = 1;\n  if (d == j) {\n    f[x]++;\n    return;\n  }\n  for (auto i : v[x]) {\n    if (i == fa) {\n      continue;\n    }\n    dfs(i, x, d + 1);\n    f[x] += f[i];\n  }\n}\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i <= n; i++) {\n      v[i].clear();\n    }\n    for (i = 1; i < n; i++) {\n      scanf(\"%d%d\", &x, &y);\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    if (m == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    res = 0;\n    for (i = 1; i <= n; i++) {\n      for (j = 1; j <= n; j++) {\n        memset(vis, 0, sizeof(vis));\n        memset(f, 0, sizeof(f));\n        memset(f2, 0, sizeof(f2));\n        dfs(i, 0, 0);\n        f2[0][0] = 1;\n        it = 0;\n        for (auto jj : v[i]) {\n          if (f[jj] == 0) {\n            continue;\n          }\n          for (k = 0; k <= it; k++) {\n            f2[it][k] %= 1000000007;\n            f2[it + 1][k] += f2[it][k];\n            f2[it + 1][k + 1] += f2[it][k] * f[jj] % 1000000007;\n          }\n          it++;\n        }\n        res += f2[it][m];\n        res %= 1000000007;\n      }\n    }\n    printf(\"%lld\\n\", res);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  map<long long, long long> st;\n  node() { st = {}; }\n};\nconst long long maxn = 100;\nvector<long long> g[maxn];\nlong long h[maxn];\nconst long long mod = 1e9 + 7;\nvector<node *> all;\nnode *dfs(long long v, long long p) {\n  if (p == -1)\n    h[v] = 0;\n  else\n    h[v] = h[p] + 1;\n  vector<long long> ans;\n  vector<node *> gg;\n  for (long long i = 0; i < g[v].size(); ++i) {\n    long long to = g[v][i];\n    if (to == p) continue;\n    gg.push_back(dfs(to, v));\n  }\n  if (h[v] != 0) {\n    node *res = new node();\n    long long id = 0;\n    for (long long j = 0; j < gg.size(); ++j) {\n      if (gg[id]->st.size() < gg[j]->st.size()) id = j;\n    }\n    if (gg.size() != 0) res = gg[id];\n    res->st[(h[v])]++;\n    for (long long k = 0; k < gg.size(); ++k) {\n      if (k == id) continue;\n      for (auto y : gg[k]->st) {\n        res->st[(y).first] += y.second;\n      }\n    }\n    if (h[v] == 1) all.push_back(res);\n    return res;\n  }\n  return new node();\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  cout.tie();\n  long long q;\n  cin >> q;\n  while (q--) {\n    long long n, k;\n    cin >> n >> k;\n    for (long long i = 0; i < n; ++i) {\n      g[i].clear();\n    }\n    for (long long m = 0; m < n - 1; ++m) {\n      long long a, b;\n      cin >> a >> b;\n      a--;\n      b--;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 % mod << \"\\n\";\n      continue;\n    }\n    long long ans = 0;\n    for (long long j = 0; j < n; ++j) {\n      all.clear();\n      dfs(j, -1);\n      for (long long i = 1; i < n; ++i) {\n        vector<long long> kol;\n        for (long long l = 0; l < all.size(); ++l) {\n          if (all[l]->st.count(i)) kol.push_back(all[l]->st[i]);\n        }\n        if (kol.size() < k) continue;\n        long long dp[kol.size() + 1][k + 1];\n        for (long long i1 = 0; i1 < kol.size() + 1; ++i1) {\n          for (long long l = 0; l < k + 1; ++l) {\n            dp[i1][l] = 0;\n          }\n        }\n        dp[0][0] = 1;\n        for (long long m = 1; m < kol.size() + 1; ++m) {\n          dp[m][0] = 1;\n          for (long long l = 1; l < k + 1; ++l) {\n            dp[m][l] += dp[m - 1][l];\n            dp[m][l] += dp[m - 1][l - 1] * kol[m - 1] % mod;\n            dp[m][l] %= mod;\n          }\n        }\n        ans = (ans + dp[kol.size()][k]) % mod;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    allans=[]\n    t=int(input())\n    for _ in range(t):\n        input()\n        n,k=readIntArr()\n        adj=[[] for __ in range(n)]\n        for __ in range(n-1):\n            u,v=readIntArr()\n            u-=1;v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        if k==2:\n            allans.append((n*(n-1))//2)\n            continue\n        \n        # for k>2, need a central node\n        centralNodes=[]\n        for node in range(n):\n            if len(adj[node])>=k: # need at least k degree\n                centralNodes.append(node)\n        \n        ans=0\n        for cn in centralNodes:\n            v=[False]*n\n            v[cn]=True\n            groups=[] # store [group] where group contains all elements from one of cn's immediate neighbour\n            for nex in adj[cn]:\n                v[nex]=True\n                groups.append([nex])\n            while len(groups)>=k:\n                # print(groups)##\n                \n                N=len(groups)\n                M=k\n                dp=[[0 for __ in range(M+1)] for ___ in range(N)]\n                # dp[i][j] = number of ways to choose j nodes from up to idx i\n                # dp[n-1][r]\n                for i in range(N):\n                    dp[i][0]=1\n                dp[0][1]=len(groups[0])\n                for i in range(1,N):\n                    for j in range(1,M+1):\n                        dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*len(groups[i]) # don't take i + take i\n                        dp[i][j]%=MOD\n                ans+=dp[N-1][M]\n                ans%=MOD\n                # for row in dp: ###\n                #     print(row)\n                # update groups\n                groups2=[]\n                for gp in groups:\n                    temp=[]\n                    for node in gp:\n                        for nex in adj[node]:\n                            if v[nex]: continue\n                            v[nex]=True\n                            temp.append(nex)\n                    if len(temp)>0:\n                        groups2.append(temp)\n                groups=groups2\n        allans.append(ans)\n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid _print(long long t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(long double t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\nvoid _print(unsigned long long t) { cerr << t; }\ntemplate <class T, class V>\nvoid _print(pair<T, V> p);\ntemplate <class T>\nvoid _print(vector<T> v);\ntemplate <class T>\nvoid _print(set<T> v);\ntemplate <class T, class V>\nvoid _print(map<T, V> v);\ntemplate <class T>\nvoid _print(multiset<T> v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nconst long long N = 102;\nlong long n, k;\nvector<long long> adj[N];\nvoid dfs(long long node, long long par, long long sub_index, long long dep,\n         long long &max_dep, vector<vector<long long>> &cnt) {\n  cnt[dep][sub_index]++;\n  max_dep = max(max_dep, dep);\n  for (auto i : adj[node]) {\n    if (i == par) continue;\n    ;\n    dfs(i, node, sub_index, dep + 1, max_dep, cnt);\n  }\n}\nlong long rec(long long pos, long long setsize, long long &dep, long long &root,\n              vector<vector<long long>> &cnt, vector<vector<long long>> &dp) {\n  if (pos == (long long)adj[root].size()) {\n    return setsize == k;\n  }\n  if (dp[pos][setsize] != -1) return dp[pos][setsize];\n  long long ans = 0;\n  if (setsize < k)\n    ans = (ans % 1000000007 + (rec(pos + 1, setsize + 1, dep, root, cnt, dp) %\n                               1000000007 * cnt[dep][pos] % 1000000007) %\n                                  1000000007) %\n          1000000007;\n  ans = (ans % 1000000007 +\n         rec(pos + 1, setsize, dep, root, cnt, dp) % 1000000007) %\n        1000000007;\n  return dp[pos][setsize] = ans;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (long long i = 0; i <= n; i++) adj[i].clear();\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    long long ans = (n * (n - 1) / 2) % 1000000007;\n    cout << ans << \"\\n\";\n    return;\n  }\n  long long ans = 0;\n  for (long long root = 0; root < n; root++) {\n    vector<vector<long long>> cnt(\n        n + 1, vector<long long>((long long)adj[root].size() + 1));\n    long long sub_index = 0;\n    long long max_dep = 1;\n    for (auto i : adj[root]) {\n      dfs(i, root, sub_index, 1, max_dep, cnt);\n      sub_index++;\n    }\n    for (long long i = 1; i <= max_dep; i++) {\n      vector<vector<long long>> dp((long long)adj[root].size(),\n                                   vector<long long>(k + 1, -1));\n      long long dep = i;\n      ans = (ans % 1000000007 + rec(0, 0, dep, root, cnt, dp) % 1000000007) %\n            1000000007;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (1e9 + 7);\nconst long long MAX_VALEURS = (101);\nvector<long long> Voisins[MAX_VALEURS];\nlong long Occ[MAX_VALEURS];\nlong long DP[MAX_VALEURS][MAX_VALEURS];\nlong long nbNoeuds, taille;\nvoid Dfs(long long noeud, long long pere, long long dist) {\n  Occ[dist]++;\n  for (long long dest : Voisins[noeud]) {\n    if (dest != pere) Dfs(dest, noeud, dist + 1);\n  }\n  return;\n}\nvoid Solve() {\n  scanf(\"%lld %lld\", &nbNoeuds, &taille);\n  for (long long i = 0; i < nbNoeuds; i++) {\n    Voisins[i].clear();\n  }\n  for (long long i = 1; i < nbNoeuds; i++) {\n    long long a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    Voisins[--a].push_back(--b);\n    Voisins[b].push_back(a);\n  }\n  if (taille == 2) {\n    printf(\"%lld\\n\", (nbNoeuds * (nbNoeuds - 1)) / 2);\n    return;\n  }\n  long long ans = 0;\n  for (long long i = 0; i < nbNoeuds; i++) {\n    for (long long j = 0; j < nbNoeuds; j++) {\n      fill_n(DP[j], nbNoeuds, 0LL);\n      DP[j][0] = 1;\n    }\n    for (long long dest : Voisins[i]) {\n      fill_n(Occ, nbNoeuds, 0LL);\n      Dfs(dest, i, 1);\n      for (long long d = 0; d < nbNoeuds; d++) {\n        for (long long j = nbNoeuds - 1; j > 0; j--) {\n          DP[d][j] += DP[d][j - 1] * Occ[d];\n          DP[d][j] %= MOD;\n        }\n      }\n    }\n    for (long long d = 0; d < nbNoeuds; d++) {\n      ans += DP[d][taille];\n    }\n    ans %= MOD;\n  }\n  printf(\"%lld\\n\", ans);\n  return;\n}\nsigned main() {\n  long long nbTests = 1;\n  scanf(\"%lld\", &nbTests);\n  while (nbTests--) {\n    Solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105, INF = 1 << 30, MOD = 1e9 + 7;\nint n, k;\nvector<int> adj[N];\nlong long cnt[N][N];\nlong long ans = 0, F[N];\nlong long sumOfProducts(vector<int>& arr, int n, int k) {\n  long long dp[n + 1][n + 1];\n  memset(dp, 0, sizeof(dp));\n  long long cur_sum = 0;\n  for (int i = 1; i <= n; i++) {\n    dp[1][i] = arr[i - 1];\n    (cur_sum += arr[i - 1]) %= MOD;\n  }\n  for (int i = 2; i <= k; ++i) {\n    long long temp_sum = 0;\n    for (int j = 1; j <= n; j++) {\n      (cur_sum -= dp[i - 1][j]) %= MOD;\n      dp[i][j] = (arr[j - 1] * cur_sum) % MOD;\n      (temp_sum += dp[i][j]) %= MOD;\n    }\n    cur_sum = temp_sum;\n  }\n  return (cur_sum + MOD) % MOD;\n}\nvoid dfs(int u, int root, int p, int d) {\n  ++cnt[root][d];\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    dfs(v, root, u, d + 1);\n  }\n}\nvoid solve(int u) {\n  memset(cnt, 0, sizeof(cnt));\n  if (adj[u].size() < k) return;\n  for (int v : adj[u]) {\n    dfs(v, v, u, 0);\n  }\n  for (int i = 0; i < n; ++i) {\n    int CNT = 0;\n    for (int v : adj[u])\n      if (cnt[v][i]) ++CNT;\n    if (CNT < k) break;\n    vector<int> C;\n    for (int v : adj[u])\n      if (cnt[v][i]) C.push_back(cnt[v][i]);\n    (ans += sumOfProducts(C, CNT, k)) %= MOD;\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  F[0] = 1;\n  for (int i = 1; i < N; ++i) F[i] = (F[i - 1] * i) % MOD;\n  int t;\n  cin >> t;\n  while (t--) {\n    ans = 0;\n    cin >> n >> k;\n    for (int i = 0; i < n; ++i) adj[i].clear();\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      adj[--u].push_back(--v);\n      adj[v].push_back(u);\n    }\n    if (k == 2)\n      cout << n * (n - 1) / 2 << '\\n';\n    else {\n      for (int i = 0; i < n; ++i) solve(i);\n      cout << ans % MOD << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long dx[4] = {1, 0, -1, 0}, dz[4] = {0, 1, 0, -1};\nconst long double pi = 3.14159265359;\nconst long long mod = 1e9 + 7;\nlong long p(long long x) {\n  while (x & (x - 1)) {\n    x = x & (x - 1);\n  }\n  return x;\n}\ntemplate <class T>\nvoid re(T& x) {\n  cin >> x;\n}\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2>& x) {\n  re(x.first);\n  re(x.second);\n}\ntemplate <class T>\nvoid re(vector<T>& x) {\n  for (long i = 0; i < x.size(); i++) {\n    re(x[i]);\n  }\n}\ntemplate <class T>\nvoid re(deque<T>& x) {\n  for (long i = 0; i < x.size(); i++) {\n    re(x[i]);\n  }\n}\ntemplate <class T>\nvoid out(T x) {\n  cout << x << \" \";\n}\ntemplate <class T1, class T2>\nvoid out(pair<T1, T2> x) {\n  out(x.first);\n  out(x.second);\n  cout << \"\\n\";\n}\ntemplate <class T>\nvoid out(vector<T> x, long l = 0, long r = 0) {\n  if (!r) {\n    r = x.size();\n  }\n  for (long i = l; i < r; i++) {\n    out(x[i]);\n  }\n  cout << \"\\n\";\n}\ntemplate <class T>\nvoid out(deque<T> x, long l = 0, long r = 0) {\n  if (!r) {\n    r = x.size();\n  }\n  for (long i = l; i < r; i++) {\n    out(x[i]);\n  }\n  cout << \"\\n\";\n}\ntemplate <class T>\nT cross(complex<T> x, complex<T> z) {\n  return (conj(x) * z).imag();\n}\ntemplate <class T>\nT dot(complex<T> x, complex<T> z) {\n  return (conj(x) * z).real();\n}\nvector<vector<long long> > edges, ways;\nvector<vector<vector<long long> > > dp;\nvector<vector<vector<bool> > > ok;\nvector<long> parent, to;\nlong n, k;\nvoid scan(long x, long p) {\n  parent[x] = p;\n  ways[x][0] = 1;\n  for (long long i = (0); i < (edges[x].size()); i++) {\n    if (edges[x][i] == p) {\n      continue;\n    }\n    scan(edges[x][i], x);\n    for (long long j = (1); j < (n + 1); j++) {\n      ways[x][j] += ways[edges[x][i]][j - 1];\n      ways[x][j] %= mod;\n    }\n  }\n}\nlong long solve(long x, long c, long d) {\n  if (c == 0) {\n    return 1;\n  }\n  if (x == 0) {\n    return 0;\n  }\n  if (ok[x][c][d]) {\n    return dp[x][c][d];\n  }\n  ok[x][c][d] = true;\n  dp[x][c][d] = solve(to[x], c, d);\n  dp[x][c][d] += (ways[x][d - 1] * solve(to[x], c - 1, d));\n  dp[x][c][d] %= mod;\n  return dp[x][c][d];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t, x, z, ans, d, son;\n  cin >> t;\n  for (long long i = (0); i < (t); i++) {\n    ans = 0;\n    cin >> n >> k;\n    edges.clear();\n    edges.resize(n + 1);\n    ways.clear();\n    ways.resize(n + 1);\n    for (long long j = (0); j < (n + 1); j++) {\n      ways[j].resize(n + 1);\n    }\n    dp.clear();\n    dp.resize(n + 1);\n    ok.clear();\n    ok.resize(n + 1);\n    for (long long j = (0); j < (n + 1); j++) {\n      dp[j].resize(n + 1);\n      ok[j].resize(n + 1);\n      for (long long l = (0); l < (n + 1); l++) {\n        dp[j][l].resize(n + 1);\n        ok[j][l].resize(n + 1);\n      }\n    }\n    to.clear();\n    to.resize(n + 1);\n    parent.clear();\n    parent.resize(n + 1);\n    for (long long j = (0); j < (n - 1); j++) {\n      cin >> x >> z;\n      edges[x].push_back(z);\n      edges[z].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    scan(1, 0);\n    for (long long j = (1); j < (n + 1); j++) {\n      for (long long l = (1); l < (edges[j].size()); l++) {\n        if (edges[j][l] == parent[j]) {\n          continue;\n        }\n        if (edges[j][l - 1] == parent[j]) {\n          if (l >= 2) {\n            to[edges[j][l]] = edges[j][l - 2];\n          }\n          continue;\n        }\n        to[edges[j][l]] = edges[j][l - 1];\n      }\n    }\n    for (long long j = (1); j < (n + 1); j++) {\n      for (long long l = (1); l < (n); l++) {\n        if (edges[j].back() == parent[j]) {\n          if (edges[j].size() > 1) {\n            ans += solve(edges[j][edges[j].size() - 2], k, l);\n          }\n        } else {\n          ans += solve(edges[j].back(), k, l);\n        }\n        ans %= mod;\n        x = parent[j];\n        son = j;\n        d = 1;\n        if (edges[j].back() == parent[j]) {\n          if (edges[j].size() > 1) {\n            z = solve(edges[j][edges[j].size() - 2], k - 1, l);\n          }\n        } else {\n          z = solve(edges[j].back(), k - 1, l);\n        }\n        while (x != 0) {\n          if (l - d == 0) {\n            ans += z * ways[x][l - d];\n            ans %= mod;\n            break;\n          } else {\n            ans += z * (mod + ways[x][l - d] - ways[son][l - d - 1]);\n            ans %= mod;\n          }\n          son = x;\n          x = parent[x];\n          d++;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 105;\nconst int INF = 1000000000;\nconst long long MOD = 1000000007LL;\nint n, k;\nvector<int> g[MAX_N];\nint byDist[MAX_N][MAX_N];\nlong long dp[MAX_N][MAX_N];\nlong long fact[MAX_N];\nlong long invFact[MAX_N];\nlong long binPow(long long a, long long x) {\n  if (x == 0) return 1LL;\n  if (x % 2 != 0) return (a * binPow(a, x - 1LL)) % MOD;\n  long long halfPow = binPow(a, x / 2LL);\n  return (halfPow * halfPow) % MOD;\n}\nvoid dfs(int u, int p, int d, int startI) {\n  byDist[startI][d]++;\n  for (int v : g[u])\n    if (v != p) dfs(v, u, d + 1, startI);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  fact[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact[i] = (fact[i - 1] * i) % MOD;\n  for (int i = 0; i < MAX_N; i++) invFact[i] = binPow(fact[i], MOD - 2LL);\n  int tests;\n  cin >> tests;\n  while (tests--) {\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) g[i].clear();\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    if (k == 2) {\n      long long c = (fact[n] * invFact[2]) % MOD;\n      c = (c * invFact[n - 2]) % MOD;\n      cout << c << '\\n';\n      continue;\n    }\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n      if ((int)g[i].size() < k) continue;\n      for (int j = 0; j < (int)g[i].size(); j++)\n        for (int d = 0; d < n; d++) byDist[j][d] = 0;\n      for (int j = 0; j < (int)g[i].size(); j++) dfs(g[i][j], i, 1, j);\n      for (int d = 1; d < n; d++) {\n        for (int j = 0; j <= (int)g[i].size(); j++)\n          for (int jj = 0; jj <= (int)g[i].size(); jj++) dp[j][jj] = 0;\n        dp[0][0] = 1LL;\n        for (int j = 0; j < (int)g[i].size(); j++)\n          for (int jj = 0; jj < (int)g[i].size(); jj++) {\n            dp[j + 1][jj] = (dp[j + 1][jj] + dp[j][jj]) % MOD;\n            dp[j + 1][jj + 1] =\n                (dp[j + 1][jj + 1] + dp[j][jj] * byDist[j][d]) % MOD;\n          }\n        result = (result + dp[(int)g[i].size()][k]) % MOD;\n      }\n    }\n    cout << result << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops\")\nconst int N = 2e5 + 5;\nconst long long int mod = 1e9 + 7;\nconst long long int Mod = 998244353;\nconst long double Pi = acos(-1);\nconst long long int Inf = 4e18;\nconst long double Eps = 1e-9;\nint dx[9] = {0, 1, -1, 0, 0, 1, 1, -1, -1};\nint dy[9] = {0, 0, 0, 1, -1, 1, -1, 1, -1};\nusing namespace std;\nlong long int d[101][101];\nvector<long long int> g[101];\nlong long int cnt;\nvoid Dfs(long long int t, long long int p, long long int k, long long int src) {\n  cnt += (d[src][t] == k);\n  for (auto u : g[t]) {\n    if (u != p) {\n      d[src][u] = d[src][t] + 1;\n      Dfs(u, t, k, src);\n    }\n  }\n}\nvoid TestCase() {\n  long long int n, k, ans = 0;\n  cin >> n >> k;\n  for (long long int i = 1, u, v; i < n; i++) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  memset(d, 0, sizeof(d));\n  if (k == 2)\n    cout << (n * (n - 1)) / 2;\n  else {\n    vector<long long int> take;\n    vector<vector<long long int> > dp;\n    for (long long int c = 2; c <= 100; c += 2) {\n      for (long long int i = 1; i <= n; i++) {\n        for (auto x : g[i]) {\n          cnt = 0;\n          d[i][x] = 1;\n          Dfs(x, i, c / 2, i);\n          take.push_back(cnt);\n        }\n        long long int m = (long long int)take.size();\n        dp.resize(m + 1);\n        for (long long int j = 0; j <= m; j++) dp[j].assign(k + 1, 0);\n        dp[0][0] = 1;\n        for (long long int j = 1; j <= m; j++) {\n          for (long long int u = 0; u <= k; u++) dp[j][u] = dp[j - 1][u];\n          for (long long int u = 1; u <= k; u++) {\n            dp[j][u] += (dp[j - 1][u - 1] * take[j - 1]) % mod;\n            dp[j][u] %= mod;\n          }\n        }\n        ans += dp[m][k];\n        ans %= mod;\n        take.clear();\n      }\n    }\n    cout << ans;\n  }\n  for (long long int i = 1; i <= n; i++) g[i].clear();\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    TestCase();\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int>> G(n + 1);\n    for (int i = 1; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    vector<vector<int>> C(n + 1, vector<int>(n + 1));\n    const int MOD = (int)1e9 + 7;\n    C[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      C[i][0] = C[i][i] = 1;\n      for (int j = 1; j < i; j++) {\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n      }\n    }\n    vector<int> d(n + 1);\n    vector<int> f(n + 1);\n    function<void(int, int, int)> dfs = [&](int cur, int fa,\n                                            int depth) -> void {\n      d[cur] = depth;\n      f[cur] = fa;\n      for (auto nx : G[cur]) {\n        if (nx == fa) {\n          continue;\n        }\n        dfs(nx, cur, depth + 1);\n      }\n    };\n    int ans = 0;\n    for (int root = 1; root <= n; root++) {\n      dfs(root, 0, 0);\n      if ((int)G[root].size() < k) {\n        continue;\n      }\n      vector<vector<int>> cnt(G[root].size(), vector<int>(n));\n      function<void(int, vector<int>&)> dfs2 = [&](int cur,\n                                                   vector<int>& count) -> void {\n        count[d[cur]] += 1;\n        for (auto nx : G[cur]) {\n          if (nx == f[cur]) {\n            continue;\n          }\n          dfs2(nx, count);\n        }\n      };\n      for (int i = 0; i < (int)G[root].size(); i++) {\n        dfs2(G[root][i], cnt[i]);\n      }\n      for (int depth = 1; depth < n; depth++) {\n        vector<int> a(G[root].size());\n        for (int i = 0; i < (int)G[root].size(); i++) {\n          a[i] = cnt[i][depth];\n        }\n        vector<int> dp(k + 1);\n        dp[0] = 1;\n        for (int i = 0; i < (int)G[root].size(); i++) {\n          for (int j = k; j >= 1; j--) {\n            dp[j] = (dp[j] + 1LL * dp[j - 1] * a[i]) % MOD;\n          }\n        }\n        ans = (ans + dp[k]) % MOD;\n      }\n    }\n    if (k == 2) {\n      ans = n * (n - 1) / 2;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nlong long sumproduct(vector<vector<int> > &cd, int k) {\n  long long res = 0;\n  for (auto a : cd) {\n    int m = a.size();\n    if (m < k) continue;\n    vector<vector<long long> > dp(m, vector<long long>(k + 1));\n    dp[0][1] = a[0];\n    for (int i = 0; i < m; ++i) {\n      dp[i][0] = 1;\n    }\n    for (int i = 1; i < m; ++i) {\n      for (int j = 1; j <= k; ++j) {\n        dp[i][j] = dp[i - 1][j] + 1LL * a[i] * dp[i - 1][j - 1];\n        dp[i][j] %= M;\n      }\n    }\n    res += dp[m - 1][k];\n    res %= M;\n  }\n  return res;\n}\nvoid bfs(vector<vector<int> > &e, vector<int> &d, int u) {\n  queue<int> q;\n  q.push(u);\n  d[u] = 1;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int v : e[u]) {\n      if (d[v] > 0) continue;\n      d[v] = d[u] + 1;\n      q.push(v);\n    }\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int> > e(n + 1);\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    long long res = 0;\n    for (int u = 1; u <= n; ++u) {\n      vector<vector<int> > cd(n + 1);\n      for (int v : e[u]) {\n        vector<int> d(n + 1);\n        d[u] = n + 1;\n        bfs(e, d, v);\n        d[u] = 0;\n        vector<int> cnt(n + 1);\n        for (int i = 1; i <= n; ++i) {\n          ++cnt[d[i]];\n        }\n        for (int i = 1; i <= n; ++i) {\n          if (cnt[i] > 0) cd[i].push_back(cnt[i]);\n        }\n      }\n      res += sumproduct(cd, k);\n      res %= M;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    input()\n    n, k = map(int, input().split())\n    G = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G[b].append(a)\n\n    if k == 2:\n        print(n * (n - 1) // 2 % mod)\n        continue\n\n    ans = 0\n    for r in range(n):\n        cnt = [0] * n\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(1, n):\n            dp[i][0] = 1\n\n        def dfs(i, par, d):\n            cnt[d] += 1\n            for j in G[i]:\n                if j == par: continue\n                dfs(j, i, d + 1)\n\n        for x in G[r]:\n            cnt = [0] * n\n            dfs(x, r, 1)\n            for i in range(1, n):\n                if cnt[i] == 0: break\n                for j in range(k, 0, -1):\n                    dp[i][j] += dp[i][j - 1] * cnt[i]\n                    dp[i][j] %= mod\n\n        for i in range(1, n):\n            ans += dp[i][k]\n            ans %= mod\n\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst LL mod = 1e9 + 7;\nint n, k, u, v;\nvector<int> graph[205];\nLL dp[205][205];\nbool vis[205];\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 1; i < n; ++i) {\n      scanf(\"%d%d\", &u, &v);\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n    if (k > 2) {\n      LL ans = 0;\n      for (int i = 1; i <= n; ++i) {\n        fill_n(vis + 1, n, false);\n        vis[i] = true;\n        vector<int> cnt(graph[i].size(), 0);\n        queue<tuple<int, int, int>> quu;\n        for (int j = 0; j < graph[i].size(); ++j) {\n          quu.push({graph[i][j], j, 1});\n        }\n        int nowHeight = 1;\n        while (!quu.empty()) {\n          auto cur = quu.front();\n          quu.pop();\n          vis[get<0>(cur)] = true;\n          if (get<2>(cur) > nowHeight) {\n            dp[0][0] = 1;\n            for (int j = 1; j <= graph[i].size(); ++j) {\n              for (int l = 0; l <= k; ++l) {\n                dp[j][l] = (dp[j - 1][l] + dp[j][l]) % mod;\n                if (l > 0) {\n                  dp[j][l] =\n                      (dp[j - 1][l - 1] * cnt[j - 1] % mod + dp[j][l]) % mod;\n                }\n              }\n            }\n            ans = (ans + dp[graph[i].size()][k]) % mod;\n            for (int j = 0; j <= graph[i].size(); ++j) {\n              for (int l = 0; l <= k; ++l) {\n                dp[j][l] = 0;\n              }\n            }\n            fill_n(cnt.begin(), graph[i].size(), 0);\n            ++nowHeight;\n          }\n          ++cnt[get<1>(cur)];\n          for (auto nxt : graph[get<0>(cur)]) {\n            if (vis[nxt]) continue;\n            quu.push({nxt, get<1>(cur), get<2>(cur) + 1});\n          }\n        }\n        dp[0][0] = 1;\n        for (int j = 1; j <= graph[i].size(); ++j) {\n          for (int l = 0; l <= k; ++l) {\n            dp[j][l] = (dp[j - 1][l] + dp[j][l]) % mod;\n            if (l > 0) {\n              dp[j][l] = (dp[j - 1][l - 1] * cnt[j - 1] % mod + dp[j][l]) % mod;\n            }\n          }\n        }\n        ans = (ans + dp[graph[i].size()][k]) % mod;\n        for (int j = 0; j <= graph[i].size(); ++j) {\n          for (int l = 0; l <= k; ++l) {\n            dp[j][l] = 0;\n          }\n        }\n        fill_n(cnt.begin(), graph[i].size(), 0);\n      }\n      printf(\"%lld\\n\", ans);\n    } else {\n      printf(\"%lld\\n\", 1ll * n * (n - 1) / 2 % mod);\n    }\n    for (int i = 1; i <= n; ++i) {\n      graph[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst LL mod = 1e9 + 7;\nint n, k, u, v;\nvector<int> graph[205];\nLL dp[205][205];\nbool vis[205];\nLL solve(int m, int k, vector<int> &cnt) {\n  dp[0][0] = 1;\n  for (int j = 1; j <= m; ++j) {\n    for (int l = 0; l <= k; ++l) {\n      dp[j][l] = (dp[j - 1][l] + dp[j][l]) % mod;\n      if (l > 0) {\n        dp[j][l] = (dp[j - 1][l - 1] * cnt[j - 1] % mod + dp[j][l]) % mod;\n      }\n    }\n  }\n  LL ans = dp[m][k];\n  for (int j = 0; j <= m; ++j) {\n    for (int l = 0; l <= k; ++l) {\n      dp[j][l] = 0;\n    }\n  }\n  fill_n(cnt.begin(), m, 0);\n  return ans;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 1; i < n; ++i) {\n      scanf(\"%d%d\", &u, &v);\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n    if (k > 2) {\n      LL ans = 0;\n      for (int i = 1; i <= n; ++i) {\n        fill_n(vis + 1, n, false);\n        vis[i] = true;\n        vector<int> cnt(graph[i].size(), 0);\n        queue<tuple<int, int, int>> quu;\n        for (int j = 0; j < graph[i].size(); ++j) {\n          quu.push({graph[i][j], j, 1});\n        }\n        int nowHeight = 1;\n        while (!quu.empty()) {\n          auto cur = quu.front();\n          quu.pop();\n          vis[get<0>(cur)] = true;\n          if (get<2>(cur) > nowHeight) {\n            ans = (ans + solve(graph[i].size(), k, cnt)) % mod;\n            ++nowHeight;\n          }\n          ++cnt[get<1>(cur)];\n          for (auto nxt : graph[get<0>(cur)]) {\n            if (vis[nxt]) continue;\n            quu.push({nxt, get<1>(cur), get<2>(cur) + 1});\n          }\n        }\n        ans = (ans + solve(graph[i].size(), k, cnt)) % mod;\n      }\n      printf(\"%lld\\n\", ans);\n    } else {\n      printf(\"%lld\\n\", 1ll * n * (n - 1) / 2 % mod);\n    }\n    for (int i = 1; i <= n; ++i) {\n      graph[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nconst int mod = 1000000007;\nint dp[N][N], cnt[N];\nvector<int> g[N];\nvoid dfs(int v, int p, int d) {\n  cnt[d]++;\n  for (int u : g[v]) {\n    if (u != p) dfs(u, v, d + 1);\n  }\n}\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n    }\n    for (int i = 2; i <= n; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].emplace_back(v);\n      g[v].emplace_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    int answer = 0;\n    for (int root = 1; root <= n; root++) {\n      if (g[root].size() < k) continue;\n      memset(dp, 0, sizeof(dp));\n      for (int d = 1; d <= n; d++) {\n        dp[d][0] = 1;\n      }\n      for (int v : g[root]) {\n        memset(cnt, 0, sizeof(cnt));\n        dfs(v, root, 1);\n        for (int d = 1; d <= n; d++) {\n          for (int cur = k - 1; cur >= 0; cur--) {\n            add(dp[d][cur + 1], dp[d][cur] * 1LL * cnt[d] % mod);\n          }\n        }\n      }\n      for (int d = 1; d <= n; d++) {\n        add(answer, dp[d][k]);\n      }\n    }\n    cout << answer << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nconst int N = 100 + 1, mod = 1e9 + 7;\nint D[N], H[N][N];\nvector<int> G[N];\nvoid add(int& a, int b) { a = (a + b) % mod; }\nvoid bfs(int v, int h) {\n  int q[N], l = 0, r = 0;\n  q[r++] = v;\n  D[v] = 1;\n  H[h][1]++;\n  while (l < r) {\n    int u = q[l++];\n    for (auto to : G[u]) {\n      if (D[to] != -1) continue;\n      q[r++] = to;\n      D[to] = D[u] + 1;\n      H[h][D[to]]++;\n    }\n  }\n}\nint cnt(int v, int k) {\n  memset(D, -1, sizeof(D));\n  ;\n  memset(H, 0, sizeof(H));\n  ;\n  D[v] = 0;\n  int m = G[v].size();\n  if (m < k) return 0;\n  for (int h = 0; h < m; ++h) {\n    auto to = G[v][h];\n    bfs(to, h);\n  }\n  int c = 0;\n  for (int d = 1; d < N; ++d) {\n    int dp[m + 1][k + 1];\n    memset(dp, 0, sizeof(dp));\n    ;\n    dp[0][0] = 1;\n    for (int h = 1; h <= m; ++h) {\n      dp[h][0] = 1;\n      for (int j = 1; j <= k; ++j) {\n        add(dp[h][j], dp[h - 1][j]);\n        add(dp[h][j], ((LL)dp[h - 1][j - 1] * H[h - 1][d]) % mod);\n      }\n    }\n    add(c, dp[m][k]);\n  }\n  return c;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int t;\n  cin >> t;\n  ;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) G[i].clear();\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    int res = 0;\n    for (int i = 1; i <= n; ++i) add(res, cnt(i, k));\n    cout << res << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<long long, long long>;\nconst long long INF = 1e9;\nconst long long MOD = 1e9 + 7;\nconst long long N = 105;\nlong long d[N];\nvoid dfs(long long node, long long par, long long depth,\n         vector<vector<long long>>& graph) {\n  ++d[depth];\n  for (auto i : graph[node]) {\n    if (i == par) continue;\n    dfs(i, node, depth + 1, graph);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    vector<vector<long long>> graph(n + 1);\n    for (long long i = 0; i < n - 1; i++) {\n      long long u, v;\n      cin >> u >> v;\n      graph[u].emplace_back(v);\n      graph[v].emplace_back(u);\n    }\n    if (k == 2) {\n      long long ans = (n * (n - 1) / 2) % MOD;\n      cout << ans << \"\\n\";\n      continue;\n    }\n    long long ans = 0;\n    for (long long root = 1; root <= n; root++) {\n      vector<vector<long long>> deps(n + 1);\n      for (auto c : graph[root]) {\n        memset(d, 0, sizeof d);\n        dfs(c, root, 1, graph);\n        for (long long i = 1; i <= n; i++) {\n          if (d[i]) deps[i].emplace_back(d[i]);\n        }\n      }\n      for (auto dep : deps) {\n        long long sz = dep.size();\n        if (sz < k) continue;\n        vector<vector<long long>> dp(sz + 1, vector<long long>(k + 1));\n        dp[0][0] = 1;\n        for (long long i = 1; i <= sz; i++) {\n          for (long long j = 0; j <= k; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j)\n              dp[i][j] = (dp[i][j] + (dp[i - 1][j - 1] * dep[i - 1])) % MOD;\n          }\n        }\n        ans = (ans + dp[sz][k]) % MOD;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long nCrModp(int n, int r, int p) {\n  if (r > n - r) r = n - r;\n  long long C[r + 1];\n  memset(C, 0, sizeof(C));\n  C[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = min(i, r); j > 0; j--) C[j] = (C[j] + C[j - 1]) % p;\n  }\n  return C[r];\n}\nint n, k;\nvector<vector<int> > graph(105);\nvector<bool> visited(105);\nlong long NCR[105][105];\nint dfs(int curr, int dist) {\n  visited[curr] = true;\n  if (dist == 0) return 1;\n  int ans = 0;\n  for (int a = 0; a < graph[curr].size(); a++) {\n    int x = graph[curr][a];\n    if (visited[x]) continue;\n    ans += dfs(x, dist - 1);\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int a = 0; a <= n; a++) {\n    graph[a].clear();\n  }\n  int x, y;\n  for (int a = 1; a < n; a++) {\n    cin >> x >> y;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << NCR[n][2] << '\\n';\n    return;\n  }\n  long long ans = 0;\n  long long pairs = 0;\n  long long dp[k + 1][2];\n  for (int a = 2; a < n; a += 2) {\n    for (int b = 1; b <= n; b++) {\n      if (graph[b].size() < k) {\n        continue;\n      }\n      for (int c = 1; c <= n; c++) {\n        visited[c] = false;\n      }\n      for (int c = 0; c <= k; c++) {\n        dp[c][0] = 0;\n        dp[c][1] = 0;\n      }\n      dp[0][1] = 1;\n      dp[0][0] = 1;\n      visited[b] = true;\n      int cnt = 0, last, now;\n      for (int c = 0; c < graph[b].size(); c++) {\n        now = c % 2;\n        last = (c + 1) % 2;\n        for (int d = 0; d <= min(c + 1, k); d++) {\n          dp[d][now] = dp[d][last];\n        }\n        cnt = dfs(graph[b][c], a / 2 - 1);\n        if (cnt == 0) {\n          continue;\n        }\n        for (int d = 1; d <= min(c + 1, k); d++) {\n          dp[d][now] += (cnt * dp[d - 1][last]) % 1000000007;\n          dp[d][now] %= 1000000007;\n        }\n      }\n      ans += dp[k][now];\n      ans %= 1000000007;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  for (int a = 0; a < 105; a++) {\n    for (int b = 0; b <= a; b++) {\n      NCR[a][b] = nCrModp(a, b, 1000000007);\n    }\n  }\n  int tt = 1;\n  cin >> tt;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static Scanner in = new Scanner(System.in);\n    static final long MOD = 1000000007L;\n    static ArrayDeque<Integer>[] edges;\n\n    public static void main(String[] args) {\n        int t = in.nextInt();\n        while (t-- != 0) {\n            solve();\n        }\n    }\n\n    public static void solve() {\n        int N = in.nextInt();\n        int K = in.nextInt();\n        edges = new ArrayDeque[N];\n        for(int i=0; i < N; i++)\n            edges[i] = new ArrayDeque<Integer>();\n        for(int i=1; i < N; i++)\n        {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            edges[a].add(b);    edges[b].add(a);\n        }\n        long res = 0L;\n        if(K == 2)\n            res = N*(N-1)/2;\n        else\n        {\n            for(int center=0; center < N; center++)\n            {\n                int[] label = new int[N];\n                int[] depth = new int[N];\n                ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n                q.add(center);\n                Arrays.fill(depth, -1);\n                depth[center] = 0;\n                while(q.size() > 0)\n                {\n                    int curr = q.poll();\n                    for(int next: edges[curr])\n                        if(depth[next] == -1)\n                        {\n                            depth[next] = depth[curr]+1;\n                            if(curr == center)\n                                label[next] = next;\n                            else\n                                label[next] = label[curr];\n                            q.add(next);\n                        }\n                }\n                //dp stuff\n                int[][] freq = new int[N][N];\n                for(int v=0; v < N; v++)\n                    if(v != center)\n                        freq[depth[v]][label[v]]++;\n                for(int d=0; d < N; d++)\n                {\n                    long[] dp = new long[K+1];\n                    dp[0] = 1L;\n                    for(int v=0; v < N; v++)\n                        if(freq[d][v] > 0)\n                            for(int i=K; i > 0; i--)\n                            {\n                                dp[i] += (freq[d][v]*dp[i-1])%MOD;\n                                if(dp[i] >= MOD)\n                                    dp[i] -= MOD;\n                            }\n                    res += dp[K];\n                    if(res >= MOD)\n                        res -= MOD;\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long md = 1e9 + 7;\nint t, n, k;\nlong long cnt[111][111], res[111][111], ans;\nvector<int> v[111];\nlong long ft[111], iv[111];\nlong long pw(long long x, long long y) {\n  long long rt = 1;\n  while (y) {\n    if (y & 1) {\n      rt *= x;\n      rt %= md;\n    }\n    x *= x;\n    x %= md;\n    y >>= 1;\n  }\n  return rt;\n}\nlong long C(long long x, long long y) {\n  return ft[x] * iv[y] % md * iv[x - y] % md;\n}\nvoid dfs(int x, int y, int rt, int d) {\n  cnt[x][d]++;\n  for (int i = 0; i < v[x].size(); i++) {\n    int z = v[x][i];\n    if (z == y) {\n      continue;\n    }\n    dfs(z, x, rt, d + 1);\n    if (x != rt) {\n      for (int j = 1; j <= n; j++) {\n        cnt[x][j] += cnt[z][j];\n      }\n    } else {\n      for (int j = 1; j <= n; j++) {\n        for (int kk = k; kk >= 1; kk--) {\n          res[j][kk] += res[j][kk - 1] * cnt[z][j] % md;\n          res[j][kk] %= md;\n        }\n      }\n    }\n  }\n}\nint main() {\n  ft[0] = 1;\n  iv[0] = 1;\n  for (int i = 1; i < 105; i++) {\n    ft[i] = ft[i - 1] * i % md;\n    iv[i] = pw(ft[i], md - 2);\n  }\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n      v[i].clear();\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int a, b;\n      cin >> a >> b;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << C(n, 2) << endl;\n      continue;\n    }\n    ans = 0;\n    for (int i = 1; i <= n; i++) {\n      memset(res, 0, sizeof(res));\n      for (int j = 1; j <= n; j++) {\n        res[j][0] = 1;\n      }\n      memset(cnt, 0, sizeof(cnt));\n      dfs(i, -1, i, 0);\n      for (int j = 1; j <= n; j++) {\n        ans += res[j][k];\n        ans %= md;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> vec_splitter(string s) {\n  for (char& c : s) c = c == ',' ? ' ' : c;\n  stringstream ss;\n  ss << s;\n  vector<string> res;\n  for (string z; ss >> z; res.push_back(z))\n    ;\n  return res;\n}\nvoid debug_out(vector<string> args, int idx) { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, Head H, Tail... T) {\n  if (idx > 0) cerr << \", \";\n  stringstream ss;\n  ss << H;\n  cerr << args[idx] << \" = \" << ss.str();\n  debug_out(args, idx + 1, T...);\n}\nvoid localTest() {}\nconst long long MOD = 1e9 + 7, N = 105;\nvector<long long> V[N];\nlong long dp[N][N], level[N];\nvoid dfs(long long node, long long p, long long l) {\n  level[l]++;\n  for (auto child : V[node]) {\n    if (child == p) {\n      continue;\n    }\n    dfs(child, node, l + 1);\n  }\n  return;\n}\nvoid add(long long& x, long long y) {\n  x += y;\n  x %= MOD;\n  return;\n}\nlong long mul(long long x, long long y) {\n  x %= MOD;\n  y %= MOD;\n  return (x * y) % MOD;\n}\nvoid solver() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    V[i].clear();\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    V[x].push_back(y);\n    V[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << (n * (n - 1)) / 2 << \"\\n\";\n    return;\n  }\n  long long ans = 0;\n  for (int root = 1; root <= n; ++root) {\n    if ((int)V[root].size() < k) {\n      continue;\n    }\n    memset(dp, 0, sizeof dp);\n    for (int i = 1; i <= n; ++i) {\n      dp[i][0] = 1;\n    }\n    for (auto u : V[root]) {\n      memset(level, 0, sizeof level);\n      dfs(u, root, 1);\n      for (int i = 1; i <= n; ++i) {\n        for (int j = k - 1; j >= 0; --j) {\n          add(dp[i][j + 1], mul(dp[i][j], level[i]));\n        }\n      }\n    }\n    for (int i = 1; i <= n; ++i) {\n      add(ans, dp[i][k]);\n    }\n  }\n  cout << ans << \"\\n\";\n  return;\n}\nint main() {\n  localTest();\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    solver();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\ninline long long read() {\n  char ch = getchar();\n  long long x = 0, r = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') r = 0;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  return r ? x : -x;\n}\nlong long t, n, k, x, y, cnt, ans, c, head[101], maxd;\nlong long d[101], num[101][101];\nstruct node {\n  long long v, next;\n} e[201];\nvoid add(long long u, long long v) {\n  e[++cnt].v = v;\n  e[cnt].next = head[u];\n  head[u] = cnt;\n}\nvoid dfs(long long x, long long fa, long long color) {\n  d[x] = d[fa] + 1;\n  maxd = max(maxd, d[x]);\n  num[d[x]][color]++;\n  for (long long i = head[x]; i; i = e[i].next) {\n    long long v = e[i].v;\n    if (v == fa) continue;\n    dfs(v, x, color);\n  }\n}\nlong long dp[101][101];\nvoid update(long long x) {\n  d[x] = 1;\n  c = 0;\n  maxd = 1;\n  for (long long i = head[x]; i; i = e[i].next) dfs(e[i].v, x, ++c);\n  for (long long i = 1; i <= maxd; ++i) {\n    dp[0][0] = 1;\n    for (long long j = 1; j <= c; ++j) {\n      dp[j][0] = 1;\n      for (long long kk = 1; kk <= j; ++kk)\n        dp[j][kk] =\n            (dp[j - 1][kk] + (dp[j - 1][kk - 1] * num[i][j] % mod)) % mod;\n    }\n    ans = (ans + dp[c][k]) % mod;\n    for (long long j = 1; j <= c; ++j)\n      for (long long kk = 0; kk <= j; ++kk) dp[j][kk] = 0;\n  }\n  for (long long i = 1; i <= maxd; ++i)\n    for (long long j = 1; j <= c; ++j) num[i][j] = 0;\n}\nsigned main() {\n  t = read();\n  while (t--) {\n    cnt = 0;\n    ans = 0;\n    memset(head, 0, sizeof(head));\n    n = read();\n    k = read();\n    for (long long i = 1; i < n; ++i) {\n      x = read();\n      y = read();\n      add(x, y);\n      add(y, x);\n    }\n    if (k == 2)\n      ans = n * (n - 1) / 2;\n    else\n      for (long long i = 1; i <= n; ++i) update(i);\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic Reader in;\n\tpublic static void main(String[] args) throws IOException {\n\t\tinput_output();\n\t\tMain solver = new Main();\n\t\tsolver.solve();\n\t\tout.close();\n\n\t\tout.flush();\n\t} \n\n\tstatic long INF = (long)1e18;\n\tstatic int MAXN = (int)1e5 + 5;\n\tstatic int MOD = (int)1e9 + 7;\n\tstatic int q, t, n, m, k;\n\tstatic double pi = Math.PI;\n\n\tstatic List<Integer> adj[];\n\tstatic long ans;\n\n\tvoid solve() throws IOException {\n\t\tt = in.nextInt();\n\t\t\n\t\twhile (t --> 0) {\n\t\t\tn = in.nextInt();\n\t\t\tk = in.nextInt();\n\n\t\t\tadj = new ArrayList[n+1];\n\t\t\tfor (int i = 1; i <= n; i++) adj[i] = new ArrayList<Integer>();\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tint u = in.nextInt(),\n\t\t\t\t\tv = in.nextInt();\n\t\t\t\tadj[u].add(v);\n\t\t\t\tadj[v].add(u);\n\t\t\t}\n\n\t\t\tans = 0;\n\n\t\t\tif (k == 2) {\n\t\t\t\tans = (((long)n*(n-1))/2L)%MOD;\n\t\t\t\tout.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] par = new int[n+1];\n\t\t\tint[][] down = new int[n+1][n+1],\n\t\t\t\t    up   = new int[n+1][n+1];\n\t\t\t\n\t\t\tboolean[] vis = new boolean[n+1];\n\t\t\tDFS_DOWN(1, vis, down, par);\n\t\t\tvis = new boolean[n+1];\n\t\t\tBFS_UP(1, vis, up, down, par);\n\n\t\t\tlong[] res = new long[k+1];\n\t\t\tres[0] = 1;\n\t\t\tfor (int root = 1; root <= n; root++) {\n\t\t\t\tfor (int depth = 1; depth < n; depth++) {\n\t\t\t\t\tfor (int i = 1; i <= k; i++) res[i] = 0;\n\n\t\t\t\t\tfor (int e: adj[root]) {\n\t\t\t\t\t\tif (e != par[root]) {\n\t\t\t\t\t\t\tfor (int i = k; i >= 1; i--) {\n\t\t\t\t\t\t\t\tres[i] = (res[i] + (res[i-1]*down[e][depth-1])%MOD)%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int i = k; i >= 1; i--) {\n\t\t\t\t\t\t\t\tres[i] = (res[i] + (res[i-1]*up[root][depth])%MOD)%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = (ans + res[k])%MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans);\n\t\t}\t\n\t}\n\n\tstatic void BFS_UP(int s, boolean[] vis, int[][] up, int[][] down, int[] par) {\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tdq.add(s);\n\t\tvis[s] = true;\n\n\t\twhile (dq.size() != 0) {\n\t\t\tint e = dq.pollFirst();\n\t\t\tup[e][0] = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tup[e][i+1] += down[par[e]][i]+up[par[e]][i]-(i == 0 || e == 1 ? 0: down[e][i-1])-(i == 0 && e != 1 ? 1: 0);\n\t\t\t}\n\n\t\t\tfor (int ee: adj[e]) {\n\t\t\t\tif (!vis[ee]) {\n\t\t\t\t\tvis[ee] = true;\n\t\t\t\t\tdq.addLast(ee);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void DFS_DOWN(int s, boolean[] vis, int[][] down, int[] par) {\n\t\tvis[s] = true;\n\t\tdown[s][0] = 1;\n\n\t\tfor (int e: adj[s]) {\n\t\t\tif (vis[e]) continue;\n\t\t\tpar[e] = s;\n\t\t\tDFS_DOWN(e, vis, down, par);\n\t\t\tfor (int i = 0; i < n; i++) down[s][i+1] += down[e][i];\n\t\t}\n\t}\n\n\tstatic class Reader {\n\t\tprivate InputStream mIs;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic Reader() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tpublic Reader(InputStream is) {\n\t\t\tmIs = is;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t}\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = mIs.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\tstatic void input_output() throws IOException {\n\t\tFile f = new File(\"in.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tin = new Reader(new FileInputStream(\"in.txt\"));\n\t\t} else in = new Reader();\n\t\tf = new File(\"out.txt\");\n\t\tif (f.exists() && !f.isDirectory()) {\n\t\t\tout = new PrintWriter(new File(\"out.txt\"));\n\t\t} else out = new PrintWriter(System.out);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class contestF {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int mod = (int)(1e9)+7;\n        int[][] C = new int[101][101];\n        for(int i=0;i<=100;++i){\n            for(int j=0;j<=100;++j){\n                if(j>i) C[i][j] = 0;\n                else if(j==i || j==0) C[i][j] = 1;\n                else{\n                    C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n                }\n            }\n        }\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            ArrayList<Integer>[] g = new ArrayList[n];\n            for(int i=0;i<n;++i) g[i] = new ArrayList<>();\n            for(int i=1;i<n;++i){\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                g[u].add(v);\n                g[v].add(u);\n            }\n            if(k==2){\n                System.out.println(C[n][2]);\n                continue;\n            }\n            int ans = 0;\n            for(int r=0;r<n;++r){\n                int[][] sz = new int[n][n];\n                int[] cnt = new int[n];\n                int[] d = new int[n];\n                for(int i=0;i<n;++i){\n                    Arrays.fill(sz[i],0);\n                    cnt[i] = 0;\n                    d[i] = -1;\n                }\n                ArrayList<Integer> list = new ArrayList<>();\n                d[r] = 0;\n                cnt[0]++;\n                list.add(r);\n                for(int i=0;i<list.size();++i){\n                    int v = list.get(i);\n                    for(int u:g[v]){\n                        if(d[u]==-1){\n                            d[u] = d[v]+1;\n                            cnt[d[u]] ++;\n                            list.add(u);\n                        }\n                    }\n                }\n                for(int i=list.size()-1;i>=0;--i){\n                    int u = list.get(i);\n                    sz[u][0] = 1;\n                    for(int v:g[u]){\n                        for(int j=1;j<n;++j) sz[u][j] += sz[v][j-1];\n                    }\n                }\n                int m = g[r].size();\n                for(int l=0;l<n&&cnt[l]>0;++l){\n                    int[][] dp = new int[m+1][m+1];\n                    for(int i=0;i<=m;++i) Arrays.fill(dp[i],0);\n                    dp[0][0] = 1;\n                    for(int i=1;i<=m;++i){\n                        int x = g[r].get(i-1);\n                        dp[i][0] = 1;\n                        for(int j=1;j<=i;++j){\n                            dp[i][j] = (int)((dp[i-1][j]+(1l*dp[i-1][j-1]*sz[x][l]))%mod);\n                        }\n                    }\n                    if(k<=m) ans = (ans+dp[m][k])%mod;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Set;\nimport java.util.Random;\nimport java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sarthakmanna\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FEquidistantVertices solver = new FEquidistantVertices();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class FEquidistantVertices {\n        final static Helper hp = new Helper();\n        int N;\n        int K;\n        Set<Integer>[] graph;\n        long ans;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int i, j, k;\n\n            N = in.nextInt();\n            K = in.nextInt();\n            graph = new TreeSet[N];\n            for (i = 0; i < N; ++i) graph[i] = new TreeSet<>();\n            for (i = 1; i < N; ++i) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n            }\n            if (K == 2) {\n                out.println(hp.ncr(N, 2));\n                return;\n            }\n\n            ans = 0;\n            for (int node = 0; node < N; ++node) {\n                ArrayList<ArrayList<Integer>> distances = new ArrayList<>();\n\n                for (int itr : graph[node]) {\n                    ArrayList<Integer> dist = new ArrayList<>();\n                    distances.add(dist);\n                    dfs(itr, node, 1, dist);\n                }\n\n                for (int idx = 0; ; ++idx) {\n                    ArrayList<Integer> equiDist = new ArrayList<>();\n                    for (ArrayList<Integer> itr : distances)\n                        if (itr.size() > idx) {\n                            equiDist.add(itr.get(idx));\n                        }\n                    if (equiDist.isEmpty()) break;\n                    calculate(equiDist);\n                }\n            }\n\n            out.println(ans);\n        }\n\n        void dfs(int node, int par, int dist, ArrayList<Integer> count) {\n            while (count.size() <= dist) count.add(0);\n            count.set(dist, count.get(dist) + 1);\n\n            for (int itr : graph[node])\n                if (itr != par) {\n                    dfs(itr, node, dist + 1, count);\n                }\n        }\n\n        void calculate(ArrayList<Integer> arr) {\n            long[] dp = new long[K + 1];\n            dp[0] = 1;\n\n            for (int itr : arr) {\n                long[] newDP = dp.clone();\n                for (int i = 1; i <= K; ++i) {\n                    newDP[i] += dp[i - 1] * itr % hp.MOD;\n                    newDP[i] %= hp.MOD;\n                }\n                dp = newDP;\n            }\n\n            ans = (ans + dp[K]) % hp.MOD;\n        }\n\n    }\n\n    static class Helper {\n        public final long MOD;\n        public final int MAXN;\n        final Random rnd;\n        public static long[] factorial;\n\n        public Helper() {\n            MOD = 1000_000_007;\n            MAXN = 1000_006;\n            rnd = new Random();\n        }\n\n        public Helper(long mod, int maxn) {\n            MOD = mod;\n            MAXN = maxn;\n            rnd = new Random();\n        }\n\n        public void setFactorial() {\n            factorial = new long[MAXN];\n            factorial[0] = 1;\n            for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;\n        }\n\n        public long ncr(int n, int r) {\n            if (r > n) return 0;\n            if (factorial == null) setFactorial();\n            long numerator = factorial[n];\n            long denominator = factorial[r] * factorial[n - r] % MOD;\n            return numerator * pow(denominator, MOD - 2, MOD) % MOD;\n        }\n\n        public long pow(long base, long exp, long MOD) {\n            base %= MOD;\n            long ret = 1;\n            while (exp > 0) {\n                if ((exp & 1) == 1) ret = ret * base % MOD;\n                base = base * base % MOD;\n                exp >>= 1;\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastReader {\n        static final int BUFSIZE = 1 << 20;\n        static byte[] buf;\n        static int index;\n        static int total;\n        static InputStream in;\n\n        public FastReader(InputStream is) {\n            try {\n                in = is;\n                buf = new byte[BUFSIZE];\n            } catch (Exception e) {\n            }\n        }\n\n        private int scan() {\n            try {\n                if (index >= total) {\n                    index = 0;\n                    total = in.read(buf);\n                    if (total <= 0)\n                        return -1;\n                }\n                return buf[index++];\n            } catch (Exception | Error e) {\n                System.err.println(e.getMessage());\n                return 13 / 0;\n            }\n        }\n\n        public String next() {\n            int c;\n            for (c = scan(); c <= 32; c = scan()) ;\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan())\n                sb.append((char) c);\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+')\n                c = scan();\n            for (; c >= '0' && c <= '9'; c = scan())\n                val = (val << 3) + (val << 1) + (c & 15);\n            return neg ? -val : val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 2147483647;\nconst int INF2 = 0x3f3f3f3f;\nconst long long INF64 = (long long)1e18;\nconst double INFD = 1e30;\nconst double EPS = 1e-9;\nconst double PI = std::acos(-1);\nconst int MOD = 1e9 + 7;\ntemplate <typename T>\ninline T read() {\n  T X = 0, w = 0;\n  char ch = 0;\n  while (!isdigit(ch)) {\n    w |= ch == '-';\n    ch = getchar();\n  }\n  while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();\n  return w ? -X : X;\n}\nconst int MAXN = 105;\nconst int MAXV = (1 << 17) + 5;\nint dr[4] = {0, 1, 0, -1};\nint dc[4] = {-1, 0, 1, 0};\nint dr2[8] = {1, 1, 1, -1, -1, -1, 0, 0};\nint dc2[8] = {1, 0, -1, 1, 0, -1, 1, -1};\nint CASE = 1;\nint A[MAXN];\nint fact[MAXN];\nstd::vector<int> G[MAXN];\nint dep[MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint fastExp(int x, int p, int mod) {\n  int ans = 1;\n  while (p) {\n    if (p & 1) ans = (long long)ans * x % mod;\n    x = (long long)x * x % mod;\n    p >>= 1;\n  }\n  return ans;\n}\nint getInv(int x, int mod) { return fastExp(x, MOD - 2, MOD); }\nint choose(int n, int k) {\n  if (k > n || n < 0 || k < 0) return 0;\n  return fact[n] * getInv(fact[k] * fact[n - k] % MOD, MOD) % MOD;\n}\nvoid dfs(int x, int p) {\n  for (auto v : G[x]) {\n    if (v == p) continue;\n    dep[v] = dep[x] + 1;\n    dfs(v, x);\n  }\n}\nvoid dfscnt(int x, int p, int pp) {\n  cnt[pp][dep[x]]++;\n  for (auto v : G[x]) {\n    if (v == p) continue;\n    dfscnt(v, x, pp);\n  }\n}\nvoid solve() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) G[i].clear();\n  for (int i = 1; i <= n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  if (k == 2) {\n    printf(\"%d\\n\", ((long long)n * (n - 1) / 2) % MOD);\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    dep[i] = 0;\n    dfs(i, i);\n    int sz = G[i].size();\n    if (sz < k) continue;\n    for (int a = 0; a <= n; a++) {\n      for (int b = 0; b <= n; b++) {\n        cnt[a][b] = 0;\n      }\n    }\n    for (int j = 0; j < sz; j++) {\n      auto v = G[i][j];\n      dfscnt(v, i, v);\n    }\n    for (int s = 1; s <= n; s++) {\n      dp[0][0] = 1;\n      for (int j = 1; j <= sz; j++) {\n        auto v = G[i][j - 1];\n        for (int l = 0; l <= k; l++) {\n          dp[j][l] = dp[j - 1][l];\n          if (l > 0) {\n            dp[j][l] = dp[j][l] + (long long)cnt[v][s] * dp[j - 1][l - 1] % MOD;\n            dp[j][l] %= MOD;\n          }\n        }\n      }\n      ans += dp[sz][k];\n      ans %= MOD;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i <= 100; i++) {\n    fact[i] = (long long)fact[i - 1] * i % MOD;\n  }\n  int T = read<int>();\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nM = 10**9+7\n\ndef gettot(dic,k):\n\n    nums = []\n    for key in dic:  nums.append(dic[key])\n\n    m = len(nums)\n\n    dp = [[0 for j in range(k+1)] for i in range(m+1)]\n    for i in range(m+1):  dp[i][0] = 1\n\n\n    for i in range(m-1,-1,-1):\n        for j in range(k+1):\n            if m-i<j:  break\n            dp[i][j] = dp[i+1][j]\n            if j>0: dp[i][j] += nums[i]*dp[i+1][j-1]%M\n            dp[i][j] = dp[i][j]%M\n\n    return dp[0][k]\n\ndef main(t):\n\n    s = input()\n    n,k = map(int,input().split())\n    neigh = [[] for i in range(n)]\n    for _ in range(n-1):\n        u,v = map(int,input().split())\n        neigh[u-1].append(v-1)\n        neigh[v-1].append(u-1)\n\n    ans = 0\n    if k==2:\n        print(n*(n-1)//2)\n        return\n\n    for root in range(n):\n        queue = deque()\n        layers = [{}]\n\n        for ele in neigh[root]:\n            queue.append([ele,ele,root,0])\n            layers[0][ele] = 1\n\n        while queue:\n            [index,ancestor,father,l] = queue.popleft()\n            for nextindex in neigh[index]:\n                if nextindex==father: continue\n                if l+1==len(layers): layers.append({})\n                if ancestor not in layers[l+1]: layers[l+1][ancestor] = 0\n                layers[l+1][ancestor] += 1\n                queue.append([nextindex,ancestor,index,l+1])\n\n        for dic in layers:\n            if len(dic)<k: break\n            ans += gettot(dic,k)\n            ans = ans%M\n\n\n    print(ans)\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <typename T1, typename T2>\ninline void chkmin(T1& x, const T2& y) {\n  if (y < x) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1& x, const T2& y) {\n  if (x < y) x = y;\n}\nmt19937 rnd(time(0));\nconst int MAXN = 10e3 + 228;\nvector<int> g[MAXN];\nint d[MAXN];\nint mod = 1000000007;\nint mul(int a, int b) { return 1ll * a * b % mod; }\nint add(int a, int b) {\n  if (a + b >= mod) return a + b - mod;\n  return a + b;\n}\nint sub(int a, int b) {\n  if (a - b < 0) return a - b + mod;\n  return a - b;\n}\nint binpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nint inv(int x) { return binpow(x, mod - 2); }\nint fact[MAXN];\nint rfact[MAXN];\nint cnk(int n, int k) {\n  if (n < 0 || k > n) return 0;\n  return mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\nint tpc[MAXN];\nvoid dfs(int v, int p, int tp) {\n  d[v] = d[p] + 1;\n  tpc[v] = tp;\n  for (int i : g[v]) {\n    if (i != p) {\n      int ntp = tp;\n      if (v == p) ntp = i;\n      dfs(i, v, ntp);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout.precision(20), cout.setf(ios::fixed);\n  fact[0] = 1;\n  for (int i = 1; i < MAXN; ++i) fact[i] = mul(fact[i - 1], i);\n  rfact[MAXN - 1] = inv(fact[MAXN - 1]);\n  for (int i = MAXN - 2; i >= 0; --i) rfact[i] = mul(rfact[i + 1], i + 1);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (int i = 0; i < n - 1; ++i) {\n      int a, b;\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      fill(d, d + n + 1, 0);\n      dfs(i, i, -1);\n      for (int dd = 2; dd <= n; ++dd) {\n        vector<int> cnts(n + 1);\n        for (int j = 1; j <= n; ++j) {\n          if (d[j] == dd) {\n            cnts[tpc[j]]++;\n          }\n        }\n        vector<int> itms;\n        for (int i : cnts) {\n          if (i) itms.push_back(i);\n        }\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int j : itms) {\n          vector<int> ndp = dp;\n          for (int x = 1; x <= 1; ++x) {\n            for (int gg = 0; gg + x <= n; ++gg) {\n              ndp[gg + x] = add(ndp[gg + x], mul(dp[gg], cnk(j, x)));\n            }\n          }\n          swap(dp, ndp);\n        }\n        ans = add(ans, dp[k]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll A = 26;\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ll BASE = 10000;\ndouble q;\nusing ll = long long;\ninline ll bit(ll x, ll y) { return (x & (1ll << y)); }\nvector<ll> a[101];\nll dp[101][101];\nll sum[10], Dp[10][10];\nll par[101];\nll n, k, kq;\nvoid dfs(ll u) {\n  dp[u][0] = 1;\n  for (auto x : a[u])\n    if (x != par[u]) {\n      par[x] = u;\n      dfs(x);\n      for (ll i = 1; i <= n; i++)\n        dp[u][i] = (dp[u][i] % mod + dp[x][i - 1] % mod) % mod;\n    }\n}\ninline ll powmod(ll a, ll b) {\n  ll res = 1ll;\n  a %= mod;\n  while (b) {\n    if (b & 1ll) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1ll;\n  }\n  return res % mod;\n}\nll d[100006], dk[100006];\nvoid init() {\n  d[0] = d[1] = dk[0] = dk[1] = 1ll;\n  for (ll i = 0; i <= 100000; i++) {\n    dk[i] = powmod(i, mod - 2);\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  init();\n  ll t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (ll i = 1; i <= n; i++) {\n      a[i].clear();\n    }\n    for (ll i = 1; i <= n - 1; i++) {\n      ll u, v;\n      cin >> u >> v;\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << ((n - 1) * n) / 2 << endl;\n      continue;\n    }\n    kq = 0;\n    for (ll i = 1; i <= n; i++)\n      if (a[i].size() >= k) {\n        for (ll j = 1; j <= n; j++) par[j] = j;\n        for (ll j = 1; j <= n; j++)\n          for (ll jj = 1; jj <= n; jj++) {\n            dp[j][jj] = 0;\n          }\n        dfs(i);\n        for (ll j = 0; j <= n - 1; j++) {\n          vector<vector<ll>> Dp(n + 1, vector<ll>(n + 1));\n          vector<ll> sum(k + 1, 0ll);\n          for (auto x : a[i]) {\n            Dp[x][1] = dp[x][j] % mod;\n            sum[1] += dp[x][j] % mod;\n            sum[1] %= mod;\n          }\n          for (ll jj = 2; jj <= k; jj++)\n            for (auto jjj : a[i]) {\n              Dp[jjj][jj] = (((sum[jj - 1] * dk[jj - 1]) % mod -\n                              Dp[jjj][jj - 1] + mod + mod) %\n                             mod * dp[jjj][j] % mod) %\n                            mod;\n              sum[jj] += Dp[jjj][jj];\n              sum[jj] %= mod;\n            }\n          kq = (kq + (sum[k] * dk[k]) % mod) % mod;\n        }\n      }\n    cout << kq << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid io() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n}\nconst int32_t MOD = 1e9 + 7;\nint32_t add(int32_t a, int32_t b) {\n  if (a + b < MOD) return a + b;\n  return a + b - MOD;\n}\nint32_t sub(int32_t a, int32_t b) {\n  if (a - b >= 0) return a - b;\n  return a - b + MOD;\n}\nint32_t mul(int32_t a, int32_t b) { return int64_t(a) * b % MOD; }\nvector<vector<int32_t>> g;\nint32_t n;\nvoid dfs(vector<vector<int32_t>> &cntH, int32_t v, int32_t p) {\n  cntH[v][0] = 1;\n  for (auto &u : g[v]) {\n    if (u != p) {\n      dfs(cntH, u, v);\n      for (int32_t i = 1; i < n; ++i) {\n        cntH[v][i] += cntH[u][i - 1];\n      }\n    }\n  }\n}\nvoid solve() {\n  int32_t k;\n  cin >> n >> k;\n  int32_t ans = 0;\n  g.clear();\n  g.resize(n);\n  for (int32_t i = 0; i + 1 < n; ++i) {\n    int32_t a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  for (int32_t v = 0; v < n; ++v) {\n    vector<vector<int32_t>> cntH(n, vector<int32_t>(n, 0));\n    dfs(cntH, v, v);\n    int32_t m = g[v].size();\n    for (int32_t h = 0; h < n; ++h) {\n      vector<int32_t> cnt;\n      cnt.reserve(m);\n      for (auto &u : g[v]) {\n        cnt.push_back(cntH[u][h]);\n      }\n      vector<vector<int32_t>> dp(m + 1, vector<int32_t>(k + 1, 0));\n      dp[0][0] = 1;\n      for (int32_t i = 0; i < m; ++i) {\n        dp[i + 1][0] = 1;\n        for (int32_t j = 1; j <= k; ++j) {\n          dp[i + 1][j] =\n              add(dp[i + 1][j], add(dp[i][j], mul(dp[i][j - 1], cnt[i])));\n        }\n      }\n      ans = add(ans, dp[m][k]);\n    }\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  io();\n  int32_t ttt;\n  std::cin >> ttt;\n  while (ttt-- > 0) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007LL;\nlong long C[105][105];\nint dis[105], headers[105];\nint cnt;\nstruct line {\n  int from;\n  int to;\n  int next;\n};\nstruct line que[205];\nvoid add(int from, int to) {\n  cnt++;\n  que[cnt].from = from;\n  que[cnt].to = to;\n  que[cnt].next = headers[from];\n  headers[from] = cnt;\n}\nint depth[105];\nvoid dfs(int place, int father) {\n  dis[place] = dis[father] + 1;\n  depth[dis[place]]++;\n  for (int i = headers[place]; i; i = que[i].next)\n    if (que[i].to != father) dfs(que[i].to, place);\n}\nint main() {\n  int n, t, u, v, k;\n  scanf(\"%d\", &t);\n  for (int i = 0; i <= 100; i++) C[i][0] = 1;\n  for (int i = 1; i <= 100; i++)\n    for (int j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n  while (t--) {\n    scanf(\"%d%d\", &n, &k);\n    cnt = 0;\n    for (int i = 1; i <= n; i++) headers[i] = 0;\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d%d\", &u, &v);\n      add(u, v);\n      add(v, u);\n    }\n    if (k == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      vector<vector<int>> son;\n      for (int j = headers[i]; j; j = que[j].next) {\n        vector<int> temp;\n        temp.push_back(0);\n        for (int k = 1; k <= n; k++) depth[k] = 0;\n        dis[i] = 0;\n        dfs(que[j].to, i);\n        for (int j = 1; j <= n; j++) temp.push_back(depth[j]);\n        son.push_back(temp);\n      }\n      vector<vector<long long>> f(son.size() + 1, vector<long long>(k + 1, 0));\n      for (int i = 0; i <= son.size(); i++) f[i][0] = 1;\n      for (int o = 1; o <= n; o++) {\n        for (int j = 1; j <= son.size(); j++)\n          for (int l = 1; l <= k; l++)\n            f[j][l] = (f[j - 1][l] + f[j - 1][l - 1] * son[j - 1][o]) % mod;\n        ans = (ans + f[son.size()][k]) % mod;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > ed;\nconst int m = 1e9 + 7;\nvoid dfs(int cur, int pr, vector<int>& dist) {\n  dist[cur] = dist[pr] + 1;\n  for (auto to : ed[cur]) {\n    if (to == pr) continue;\n    dfs(to, cur, dist);\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  ed.clear();\n  ed.resize(n + 1);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ed[u].push_back(v);\n    ed[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << \"\\n\";\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    vector<int> dist(n + 1);\n    vector<vector<int> > arr(n + 1, vector<int>(n + 1));\n    for (auto to : ed[i]) {\n      dfs(to, i, dist);\n      for (int j = 1; j <= n; ++j) {\n        if (dist[j] == 0) continue;\n        arr[to][dist[j]]++;\n      }\n      dist.assign(n + 1, 0);\n    }\n    for (int l = 1; l <= n; ++l) {\n      vector<vector<int> > dp(n + 1, vector<int>(n + 1));\n      int prev = 0;\n      dp[0][0] = 1;\n      for (auto to : ed[i]) {\n        for (int j = 0; j <= n; ++j) {\n          dp[to][j] = dp[prev][j];\n          if (j != 0)\n            dp[to][j] += (long long)dp[prev][j - 1] * arr[to][l] % m,\n                dp[to][j] %= m;\n        }\n        prev = to;\n      }\n      ans += dp[prev][k];\n      ans %= m;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int tst;\n  tst = 1;\n  cin >> tst;\n  while (tst--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 110;\nconst long long mod = 1e9 + 7;\nvoid speed() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nint n, k, used[maxn];\nlong long dp[maxn][maxn];\nvector<int> g[maxn];\nvoid bfs(int v) {\n  queue<int> q;\n  for (int i = 1; i <= n; i++) used[i] = -1;\n  used[v] = 0;\n  q.push(v);\n  while (!q.empty()) {\n    v = q.front();\n    q.pop();\n    for (int i = 0; i < g[v].size(); i++) {\n      int u = g[v][i];\n      if (used[u] == -1) {\n        used[u] = used[v] + 1;\n        q.push(u);\n      }\n    }\n  }\n}\nlong long dfs(int v, int par, int dis) {\n  if (used[v] == dis) return 1;\n  long long sum = 0;\n  for (int j = 0; j < g[v].size(); j++) {\n    int u = g[v][j];\n    if (u == par) continue;\n    sum = sum + dfs(u, v, dis);\n  }\n  return sum;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) g[i].clear();\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  if (k > 2) {\n    long long ans = 0;\n    for (int dis = 2; dis <= n; dis += 2) {\n      for (int i = 1; i <= n; i++) {\n        bfs(i);\n        dp[0][0] = 1;\n        int id = 1;\n        for (int j = 0; j < g[i].size(); j++) {\n          long long sum = dfs(g[i][j], i, dis / 2);\n          dp[id][0] = 1;\n          for (int p = 1; p <= k; p++)\n            dp[id][p] = (dp[id - 1][p] + dp[id - 1][p - 1] * sum) % mod;\n          id++;\n        }\n        ans = (ans + dp[id - 1][k]) % mod;\n      }\n    }\n    cout << ans << '\\n';\n  } else {\n    long long ans = 0;\n    for (int dis = 1; dis <= n; dis++) {\n      for (int i = 1; i <= n; i++) {\n        bfs(i);\n        for (int j = 1; j <= n; j++)\n          if (used[j] == dis) ans++;\n      }\n    }\n    cout << ans / 2 << '\\n';\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1e9 + 7;\nint cnt[110];\nvector<int> v[110];\nint dp[110][110];\nll add(ll x, ll y) { return (x + y) % MOD; }\nll mul(ll x, ll y) { return x * y % MOD; }\nll get_ans(int n, int k) {\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= k; j++) dp[i][j] = 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= k; j++) {\n      dp[i][j] = add(dp[i - 1][j], dp[i][j]);\n      dp[i][j] = add(dp[i][j], mul(dp[i - 1][j - 1], cnt[i]));\n    }\n  }\n  return dp[n][k];\n}\nvoid dfs(int u, int fa = -1) {\n  cout << u << endl;\n  for (auto t : v[u]) {\n    if (t == fa) continue;\n    dfs(t, u);\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) v[i].clear();\n    for (int i = 1; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    if (k == 2) {\n      printf(\"%lld\\n\", 1ll * n * (n - 1) / 2 % MOD);\n      continue;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n      vector<int> used(n + 1, 0);\n      used[i] = true;\n      int m = v[i].size();\n      vector<pair<int, int>> layer;\n      for (int j = 0; j < m; j++) {\n        int y = v[i][j];\n        layer.push_back({y, j + 1});\n        used[y] = true;\n        cnt[j + 1] = 1;\n      }\n      while (!layer.empty()) {\n        ans = add(ans, get_ans(m, k));\n        vector<pair<int, int>> newlayer;\n        for (auto now : layer) {\n          cnt[now.second]--;\n          for (auto next : v[now.first]) {\n            if (used[next]) continue;\n            newlayer.push_back({next, now.second});\n            used[next] = true;\n            cnt[now.second]++;\n          }\n        }\n        layer = newlayer;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nconst int p = 1e9 + 7;\nint read() {\n  int s = 0;\n  char c = getchar(), lc = '+';\n  while (c < '0' || '9' < c) lc = c, c = getchar();\n  while ('0' <= c && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return lc == '-' ? -s : s;\n}\nvoid write(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + '0');\n  else\n    write(x / 10), putchar(x % 10 + '0');\n}\nvoid print(int x, char c = '\\n') {\n  write(x);\n  putchar(c);\n}\nstruct edge {\n  int to, nxt;\n} e[N];\nint head[N], cnte = 0;\nvoid add_edge(int u, int v) {\n  e[++cnte].to = v;\n  e[cnte].nxt = head[u];\n  head[u] = cnte;\n}\nvoid clear() {\n  cnte = 0;\n  memset(head, 0, sizeof(head));\n}\nvector<int> a[N];\nint dp[N], deep[N], tot[N];\nint dfs(int now, int father) {\n  tot[deep[now] = deep[father] + 1]++;\n  int ret = deep[now];\n  for (int i = head[now]; i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (to == father) continue;\n    ret = max(ret, dfs(to, now));\n  }\n  return ret;\n}\nsigned main(signed Goodbye, char *Wangang[]) {\n  (void)Goodbye, (void)Wangang;\n  int T = read();\n  while (T--) {\n    int n = read(), k = read(), ans = 0;\n    for (int i = 1; i < n; i++) {\n      int u = read(), v = read();\n      add_edge(u, v);\n      add_edge(v, u);\n    }\n    if (k == 2) {\n      print(n * (n - 1) / 2), clear();\n      continue;\n    }\n    for (int rt = 1; rt <= n; rt++) {\n      deep[rt] = 0;\n      for (int i = head[rt]; i; i = e[i].nxt) {\n        int to = e[i].to, maxdeep = dfs(to, rt);\n        for (int j = 1; j <= maxdeep; j++) {\n          a[j].push_back(tot[j]);\n          tot[j] = 0;\n        }\n      }\n      for (int i = 1; i <= n; i++)\n        if (!a[i].empty()) {\n          memset(dp, 0, sizeof(dp));\n          dp[0] = 1;\n          for (int x : a[i])\n            for (int j = n; j >= 1; j--)\n              dp[j] = (dp[j] + 1LL * dp[j - 1] * x) % p;\n          ans = (ans + dp[k]) % p;\n          a[i].clear();\n        }\n    }\n    print(ans);\n    clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint tcase, n, K;\nlong long ans;\nvector<int> e[110];\nint cnt[110][110];\nlong long f[110];\nvoid dfs(int sn, int fa, int r, int d) {\n  cnt[r][d]++;\n  for (int fn : e[sn])\n    if (fn != fa) dfs(fn, sn, r, d + 1);\n}\nlong long gao(int r) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) cnt[i][j] = 0;\n  for (int fn : e[r]) dfs(fn, r, fn, 1);\n  long long ret = 0;\n  for (int t = 1; t <= n; t++) {\n    for (int i = 0; i <= n; i++) f[i] = 0;\n    f[0] = 1;\n    int lim = 0;\n    for (int fn : e[r]) {\n      lim++;\n      for (int i = min(lim, K); i; i--)\n        f[i] = (f[i] + f[i - 1] * cnt[fn][t]) % 1000000007;\n    }\n    ret = (ret + f[K]) % 1000000007;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &tcase);\n  while (tcase--) {\n    scanf(\"%d%d\", &n, &K);\n    for (int i = 1; i <= n; i++) e[i].clear();\n    for (int i = 1; i < n; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      e[a].push_back(b);\n      e[b].push_back(a);\n    }\n    if (K == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    ans = 0;\n    for (int i = 1; i <= n; i++) ans = (ans + gao(i)) % 1000000007;\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long nax = 125, mod = 1e9 + 7;\nlong long add(long long x, long long y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\nlong long mul(long long x, long long y) { return x * y % mod; }\nvector<long long> g[nax];\nlong long vis[nax], cnt[nax], dp[nax][nax];\nlong long find(long long n, long long k) {\n  for (long long i = 0; i <= n; i++)\n    for (long long j = 0; j <= k; j++) dp[i][j] = 0;\n  dp[0][0] = 1;\n  for (long long i = 0; i < n; i++)\n    for (long long j = 0; j <= k; j++) {\n      dp[i + 1][j] = add(dp[i + 1][j], dp[i][j]);\n      dp[i + 1][j + 1] = add(dp[i + 1][j + 1], mul(dp[i][j], cnt[i]));\n    }\n  return dp[n][k];\n}\nint32_t main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    for (long long i = 0; i < n; i++) g[i].clear();\n    for (long long i = 1; i < n; i++) {\n      long long x, y;\n      cin >> x >> y;\n      g[--x].push_back(--y);\n      g[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1) / 2) % mod << '\\n';\n      continue;\n    }\n    long long res = 0;\n    for (long long x = 0; x < n; x++) {\n      memset(vis, 0, sizeof(vis));\n      vis[x] = 1;\n      vector<pair<long long, long long> > e;\n      long long m = g[x].size();\n      for (long long i = 0; i < m; i++) {\n        long long y = g[x][i];\n        e.push_back({y, i});\n        cnt[i] = 1;\n        vis[y] = 1;\n      }\n      while (!e.empty()) {\n        res = add(res, find(m, k));\n        vector<pair<long long, long long> > ee;\n        for (auto p : e) {\n          cnt[p.second]--;\n          for (auto y : g[p.first])\n            if (!vis[y]) {\n              ee.push_back({y, p.second});\n              vis[y] = 1;\n              cnt[p.second]++;\n            }\n        }\n        e = ee;\n      }\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid io() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n}\nconst int32_t N = 500;\nconst int32_t MOD = 1e9 + 7;\nint32_t c[N][N];\nint32_t add(int32_t a, int32_t b) {\n  if (a + b < MOD) return a + b;\n  return a + b - MOD;\n}\nint32_t sub(int32_t a, int32_t b) {\n  if (a - b >= 0) return a - b;\n  return a - b + MOD;\n}\nint32_t mul(int32_t a, int32_t b) { return int64_t(a) * b % MOD; }\nvoid calc() {\n  c[0][0] = 1;\n  for (int32_t n = 1; n < N; ++n) {\n    c[n][0] = 1;\n    for (int32_t k = 1; k <= n; ++k) {\n      c[n][k] = add(c[n - 1][k - 1], c[n - 1][k]);\n    }\n  }\n}\nvector<vector<int32_t>> g;\nint32_t n;\nvoid dfs(vector<vector<int32_t>> &cntH, int32_t v, int32_t p) {\n  cntH[v][0] = 1;\n  for (auto &u : g[v]) {\n    if (u != p) {\n      dfs(cntH, u, v);\n      for (int32_t i = 1; i < n; ++i) {\n        cntH[v][i] += cntH[u][i - 1];\n      }\n    }\n  }\n}\nint32_t getC(int32_t n, int32_t k) { return c[n][k]; }\nvoid solve() {\n  int32_t k;\n  cin >> n >> k;\n  int32_t ans = 0;\n  g.clear();\n  g.resize(n);\n  for (int32_t i = 0; i + 1 < n; ++i) {\n    int32_t a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  for (int32_t v = 0; v < n; ++v) {\n    vector<vector<int32_t>> cntH(n, vector<int32_t>(n, 0));\n    dfs(cntH, v, v);\n    int32_t m = g[v].size();\n    for (int32_t h = 0; h < n; ++h) {\n      vector<int32_t> cnt;\n      cnt.reserve(m);\n      for (auto &u : g[v]) {\n        cnt.push_back(cntH[u][h]);\n      }\n      vector<vector<int32_t>> dp(m + 1, vector<int32_t>(k + 1, 0));\n      dp[0][0] = 1;\n      for (int32_t i = 0; i < m; ++i) {\n        dp[i + 1][0] = 1;\n        for (int32_t j = 1; j <= k; ++j) {\n          dp[i + 1][j] =\n              add(dp[i + 1][j], add(dp[i][j], mul(dp[i][j - 1], cnt[i])));\n        }\n      }\n      ans = add(ans, dp[m][k]);\n    }\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  io();\n  calc();\n  int32_t ttt;\n  std::cin >> ttt;\n  while (ttt-- > 0) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d[1000005];\nint f[505][505];\nvector<int> g[1000005];\nvoid dfs(int u, int r, int pr, int val, int dis = 1) {\n  if (dis == val) d[r]++;\n  for (auto &v : g[u])\n    if (v != pr) dfs(v, r, u, val, dis + 1);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t-- > 0) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (int i = 1; i < n; ++i) {\n      int u, v;\n      cin >> u >> v;\n      g[u].emplace_back(v);\n      g[v].emplace_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    int res = 0;\n    for (int i = 1; i <= n; ++i) {\n      if ((g[i]).size() < k) continue;\n      for (int j = 1; j < n; ++j) {\n        for (auto &v : g[i]) d[v] = 0;\n        for (auto &v : g[i]) dfs(v, v, i, j);\n        for (int first = 0; first <= (g[i]).size(); ++first)\n          for (int second = 0; second <= k; ++second) f[first][second] = 0;\n        f[0][0] = 1;\n        for (int first = 1; first <= (g[i]).size(); ++first) {\n          for (int second = 0; second <= k; ++second) {\n            f[first][second] = f[first - 1][second];\n            if (second > 0)\n              f[first][second] =\n                  (f[first][second] + (long long)f[first - 1][second - 1] *\n                                          d[g[i][first - 1]] % 1000000007) %\n                  1000000007;\n          }\n        }\n        res = (res + f[(g[i]).size()][k]) % 1000000007;\n      }\n    }\n    cout << res << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst long long N = 1e3;\nconst long long MOD = 1e9 + 7;\nconst long long inf = 1e10;\nconst long double eps = 1e-12;\nconst long double EPS = 1e-10;\nlong long rx[] = {1, -1, 0, 0};\nlong long ry[] = {0, 0, 1, -1};\nvector<long long> g[N];\nlong long used[N], dp[N][N], cnt[N];\nlong long rundp(long long m, long long k) {\n  for (long long i = 0; i <= m; ++i) {\n    for (long long j = 0; j <= k; ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (long long i = 0; i < m; ++i) {\n    for (long long j = 0; j <= k; ++j) {\n      dp[i + 1][j] += dp[i][j];\n      dp[i + 1][j] %= MOD;\n      dp[i + 1][j + 1] += (dp[i][j] * cnt[i]);\n      dp[i + 1][j + 1] %= MOD;\n    }\n  }\n  return dp[m][k];\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long Q;\n  cin >> Q;\n  while (Q--) {\n    long long n, k;\n    cin >> n >> k;\n    for (long long i = 0; i < n; ++i) g[i].clear();\n    for (long long i = 1; i < n; ++i) {\n      long long x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1) / 2) % MOD << '\\n';\n      continue;\n    }\n    long long ans = 0;\n    for (long long c = 0; c < n; ++c) {\n      fill(used, used + n, 0);\n      used[c] = 1;\n      vector<pair<long long, long long> > layer;\n      long long m = g[c].size();\n      for (long long i = 0; i < m; ++i) {\n        long long x = g[c][i];\n        layer.push_back({x, i});\n        cnt[i] = 1;\n        used[x] = 1;\n      }\n      while (!layer.empty()) {\n        ans = ans + rundp(m, k);\n        ans %= MOD;\n        vector<pair<long long, long long> > nlayer;\n        for (auto to : layer) {\n          cnt[to.second]--;\n          for (auto x : g[to.first]) {\n            if (used[x]) continue;\n            nlayer.push_back({x, to.second});\n            used[x] = 1;\n            cnt[to.second]++;\n          }\n        }\n        layer = nlayer;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int P = 1000000007;\nint norm(int x) {\n  if (x < 0) {\n    x += P;\n  }\n  if (x >= P) {\n    x -= P;\n  }\n  return x;\n}\ntemplate <class T>\nT power(T a, int b) {\n  T res = 1;\n  for (; b; b /= 2, a *= a) {\n    if (b % 2) {\n      res *= a;\n    }\n  }\n  return res;\n}\nstruct Z {\n  int x;\n  Z(int x = 0) : x(norm(x)) {}\n  int val() const { return x; }\n  Z operator-() const { return Z(norm(P - x)); }\n  Z inv() const {\n    assert(x != 0);\n    return power(*this, P - 2);\n  }\n  Z &operator*=(const Z &rhs) {\n    x = i64(x) * rhs.x % P;\n    return *this;\n  }\n  Z &operator+=(const Z &rhs) {\n    x = norm(x + rhs.x);\n    return *this;\n  }\n  Z &operator-=(const Z &rhs) {\n    x = norm(x - rhs.x);\n    return *this;\n  }\n  Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }\n  friend Z operator*(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res *= rhs;\n    return res;\n  }\n  friend Z operator+(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res += rhs;\n    return res;\n  }\n  friend Z operator-(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res -= rhs;\n    return res;\n  }\n  friend Z operator/(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res /= rhs;\n    return res;\n  }\n};\nvoid Solve() {\n  int n, k;\n  std::cin >> n >> k;\n  std::vector<std::vector<int>> e(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    std::cin >> u >> v;\n    --u;\n    --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  if (k == 2) {\n    std::cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  Z ans = 0;\n  auto bfs = [&](int s) {\n    int cnt = e[s].size();\n    if (cnt < k) return;\n    std::vector<int> x(cnt), vis(n);\n    std::vector<std::vector<int>> g(cnt);\n    vis[s] = 1;\n    for (int i = 0; i < cnt; i++) {\n      g[i].push_back(e[s][i]);\n      x[i] = vis[e[s][i]] = 1;\n    }\n    while (true) {\n      std::vector<std::vector<Z>> dp(cnt, std::vector<Z>(k + 1));\n      dp[0][0] = 1;\n      dp[0][1] = x[0];\n      for (int i = 1; i < cnt; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n          dp[i][j] = dp[i - 1][j] + x[i] * dp[i - 1][j - 1];\n        }\n      }\n      for (int i = 0; i < cnt; i++) {\n        for (int j = i + 2; j <= k; j++) {\n          assert(dp[i][j].x == 0);\n        }\n      }\n      ans += dp[cnt - 1][k];\n      fill(x.begin(), x.end(), 0);\n      std::vector<int> alive(cnt);\n      std::vector<std::vector<int>> newg(cnt);\n      for (int i = 0; i < cnt; i++) {\n        for (int u : g[i]) {\n          for (int v : e[u]) {\n            if (!vis[v]) {\n              vis[v] = 1;\n              newg[i].push_back(v);\n              x[i]++;\n              alive[i] = 1;\n            }\n          }\n        }\n      }\n      if (std::accumulate(alive.begin(), alive.end(), 0) < k) {\n        break;\n      }\n      std::swap(g, newg);\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    bfs(i);\n  }\n  std::cout << ans.x << '\\n';\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  int t;\n  std::cin >> t;\n  while (t--) {\n    Solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint c[101][101];\nint C(int n, int r) {\n  if (n == r || r == 0) return 1;\n  if (~c[n][r]) return c[n][r];\n  return c[n][r] = (C(n - 1, r - 1) + C(n - 1, r)) % mod;\n}\nvoid solve(int tc) {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n + 1);\n  vector<int> deg(n + 1);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k <= 2) {\n    cout << C(n, k) << '\\n';\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (g[i].size() >= k) {\n      vector<vector<int>> dep(g[i].size(), vector<int>(n + 1));\n      vector<int> dep_cnt(n + 1, 0);\n      for (int j = 0; j < g[i].size(); ++j) {\n        function<void(int, int, int)> dfs = [&](int u, int p, int d) {\n          dep[j][d]++;\n          for (int v : g[u])\n            if (v != p) dfs(v, u, d + 1);\n        };\n        dfs(g[i][j], i, 1);\n      }\n      for (int d = 1; d <= n; ++d) {\n        vector<vector<int>> dp(k, vector<int>(g[i].size(), 0));\n        int cnt = 0;\n        for (int j = 0; j < g[i].size(); ++j) {\n          cnt += !!dep[j][d];\n          dp[0][j] = dep[j][d];\n        }\n        if (cnt < k) break;\n        for (int l = 1; l < k; ++l) {\n          long long sum = 0;\n          for (int j = l; j < g[i].size(); ++j) {\n            sum = (sum + dp[l - 1][j - 1]) % mod;\n            dp[l][j] = sum * dp[0][j] % mod;\n          }\n        }\n        for (int j = k - 1; j < g[i].size(); ++j)\n          ans = (ans + dp[k - 1][j]) % mod;\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  memset(c, -1, sizeof c);\n  int t = 1;\n  cin >> t;\n  for (int i = 1; i <= t; ++i) solve(i);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long inf = 0x3f3f3f3f;\nconst double dinf = 1e100;\nusing namespace std;\nconst long long maxn = 205;\nconst long long mod = 1e9 + 7;\nlong long n, k;\nlong long d[maxn];\nlong long a[maxn][maxn];\nvector<long long> e[maxn];\nlong long dp[maxn][maxn], w[maxn];\nvoid dfs(long long u, long long fa, long long rt) {\n  d[u] = d[fa] + 1, a[rt][d[u]]++;\n  for (auto x : e[u]) {\n    if (x == fa) continue;\n    dfs(x, u, rt);\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = (1); i <= (n); ++i) e[i].clear();\n    for (long long i = (1); i <= ((n - 1)); ++i) {\n      long long l, r;\n      cin >> l >> r;\n      e[l].push_back(r), e[r].push_back(l);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n    } else {\n      long long ans = 0;\n      for (long long i = (1); i <= (n); ++i) {\n        d[i] = 0;\n        for (long long j = 0; j < e[i].size(); ++j) {\n          dfs(e[i][j], i, e[i][j]);\n        }\n        for (long long j = (1); j <= (n); ++j) {\n          long long p = 0;\n          for (auto x : e[i]) {\n            w[++p] = a[x][j];\n          }\n          memset(dp, 0, sizeof(dp));\n          dp[0][0] = 1;\n          for (long long i = (1); i <= (p); ++i) {\n            for (long long j = 0; j <= min(i, k); ++j) {\n              if (j > 0)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * w[i] % mod) % mod;\n              dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n            }\n          }\n          ans = (ans + dp[p][k]) % mod;\n        }\n        memset(a, 0, sizeof(a));\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing _ii = pair<int, int>;\nconst int N = 107;\nint t, n, k;\ni64 dp_in[N][N], dp_out[N][N], C[N][N], f[N][N], ans, mod = 1e9 + 7;\nvector<vector<int>> a;\nvoid Pre() {\n  for (int n = 0; n <= 100; n++) {\n    for (int k = 0; k <= n; k++) {\n      if (k == n) {\n        C[k][n] = 1;\n        continue;\n      }\n      if (k == 0) {\n        C[k][n] = 1;\n        continue;\n      }\n      if (k == 1) {\n        C[k][n] = n;\n        continue;\n      }\n      C[k][n] = (C[k - 1][n - 1] + C[k][n - 1]) % mod;\n    }\n  }\n}\nvoid Test(int h, int le, vector<int> &a) {\n  cerr << '\\n' << \"Node \" << h << \" distance \" << le << '\\n';\n  for (auto &i : a) cerr << i << ' ';\n}\nvoid DFS(int h, int legacy) {\n  for (auto &i : a[h]) {\n    if (i == legacy) continue;\n    DFS(i, h);\n    for (int j = 1; j <= n; j++)\n      dp_in[h][j] = (dp_in[h][j] + dp_in[i][j - 1]) % mod;\n  }\n  ++dp_in[h][0];\n}\nvoid Cal(vector<int> &a, int cnt) {\n  int m = a.size();\n  vector<i64> f(cnt + 1);\n  f[0] = 1;\n  for (auto &i : a) {\n    for (int j = cnt; j >= 1; j--) {\n      f[j] += f[j - 1] * i;\n      f[j] %= mod;\n    }\n  }\n  i64 temp = f[cnt];\n  ans = (ans + temp) % mod;\n}\nvoid Run(int h, int legacy) {\n  for (int j = 1; j <= n; j++) {\n    vector<int> d;\n    d.push_back(dp_out[h][j]);\n    for (auto &i : a[h]) {\n      if (i == legacy) continue;\n      d.push_back(dp_in[i][j - 1]);\n    }\n    Cal(d, k);\n  }\n  for (auto &i : a[h]) {\n    if (i == legacy) continue;\n    for (int j = 1; j <= n; j++) {\n      int temp = dp_in[h][j - 1] - (j - 2 >= 0 ? dp_in[i][j - 2] : 0);\n      dp_out[i][j] = temp + dp_out[h][j - 1];\n    }\n    Run(i, h);\n  }\n}\nvoid Test() {\n  for (int i = 1; i <= n; i++) {\n    cerr << '\\n' << \"Node \" << i << '\\n';\n    for (int j = 0; j <= n; j++)\n      cerr << j << ' ' << dp_in[i][j] << ' ' << dp_out[i][j] << '\\n';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    a.resize(n + 1);\n    for (auto &i : a) i.clear();\n    for (int i = 1; i <= n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      a[x].push_back(y);\n      a[y].push_back(x);\n    }\n    ans = 0;\n    memset(dp_in, 0, sizeof(dp_in));\n    memset(dp_out, 0, sizeof(dp_out));\n    Pre();\n    DFS(1, 0);\n    Run(1, 0);\n    if (k == 2) ans = (n * (n - 1) / 2) % mod;\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long N = 1e2 + 10;\nvector<long long> g[N];\nvoid dfs(long long node, long long par, long long dd, vector<long long>& fre) {\n  fre[dd]++;\n  for (auto x : g[node])\n    if (x != par) dfs(x, node, dd + 1, fre);\n}\nlong long n, k;\nlong long get(vector<long long>& arr) {\n  vector<long long> cur(k + 1, 0);\n  cur[0] = 1;\n  for (auto x : arr) {\n    for (long long i = k; i >= 1; i--) {\n      cur[i] += cur[i - 1] * x;\n      cur[i] %= MOD;\n    }\n  }\n  return cur[k];\n}\nlong long solve(long long x) {\n  long long sz = g[x].size();\n  vector<vector<long long> > go(sz, vector<long long>(n + 1, 0));\n  for (long long i = 0; i < sz; i++) dfs(g[x][i], x, 1, go[i]);\n  long long res = 0;\n  for (long long i = 1; i <= n; i++) {\n    vector<long long> arr;\n    for (auto v : go)\n      if (v[i] > 0) arr.push_back(v[i]);\n    res += get(arr);\n    res %= MOD;\n  }\n  return res;\n}\nvoid solve() {\n  cin >> n >> k;\n  long long u, v;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long res = 0;\n  if (k == 2) {\n    res = (n * (n - 1)) / 2;\n    res %= MOD;\n  } else {\n    for (long long i = 1; i <= n; i++) {\n      res += solve(i);\n      res %= MOD;\n    }\n  }\n  cout << res << '\\n';\n  for (long long i = 1; i <= n; i++) g[i].clear();\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e2 + 10;\nconst long long mod = 1e9 + 7;\nconst double eps = 1e-9;\nconst long long INF = 0x3f3f3f3f;\nlong long n, k;\nlong long ne[N], h[N], e[N], idx = 1;\nlong long dp[N][N], cnt[N][N];\nvoid add(long long a, long long b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nvoid dfs(long long u, long long fa) {\n  cnt[u][0] = 1;\n  for (long long i = h[u]; i; i = ne[i]) {\n    long long j = e[i];\n    if (j == fa) continue;\n    dfs(j, u);\n    for (long long deep = 1; deep <= n; deep++)\n      cnt[u][deep] += cnt[j][deep - 1];\n  }\n}\nlong long slove(long long u) {\n  memset(cnt, 0, sizeof(cnt));\n  dfs(u, -1);\n  vector<long long> son;\n  son.push_back(-1);\n  for (long long i = h[u]; i; i = ne[i]) son.push_back(e[i]);\n  long long len = (long long)son.size(), res = 0;\n  for (long long d = 0; d <= n; d++) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (long long i = 1; i < len; i++) {\n      dp[i][0] = 1;\n      for (long long j = 1; j <= i; j++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n        dp[i][j] = (dp[i][j] + (dp[i - 1][j - 1] * cnt[son[i]][d] % mod)) % mod;\n      }\n    }\n    res = (res + dp[len - 1][k]) % mod;\n  }\n  return res;\n}\nsigned main() {\n  long long tt;\n  cin >> tt;\n  while (tt--) {\n    for (long long i = 1; i <= idx; i++) h[i] = 0;\n    idx = 1;\n    cin >> n >> k;\n    for (long long i = 1; i < n; i++) {\n      long long a, b;\n      cin >> a >> b;\n      add(a, b);\n      add(b, a);\n    }\n    long long ans = 0;\n    if (k == 2)\n      ans = (n * (n - 1) / 2) % mod;\n    else\n      for (long long root = 1; root <= n; root++)\n        ans = (ans + slove(root)) % mod;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong double pi = 3.14159265358979323846;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int p = 1e9 + 7, n, k;\nlong long int dis[101][101];\nvoid dfs(long long int node, long long int par, vector<long long int> v[]) {\n  dis[node][0] = 1;\n  for (auto it : v[node]) {\n    if (it != par) {\n      dfs(it, node, v);\n      for (long long int i = 1; i < n; i++) dis[node][i] += dis[it][i - 1];\n    }\n  }\n}\nlong long int cal(vector<long long int> &temp) {\n  long long int size = temp.size(), ans = 0, i, j;\n  if (size < k) return 0;\n  long long int dp[size + 1][k + 1];\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (i = 1; i <= size; i++) {\n    dp[i][0] = 1;\n    for (long long int j = 1; j <= k; j++) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * temp[i - 1]) % p;\n    }\n  }\n  return dp[size][k];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int count;\n    cin >> n >> k;\n    count = n - 1;\n    vector<long long int> v[n];\n    while (count--) {\n      long long int x, y;\n      cin >> x >> y;\n      x--, y--;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    long long int ans = 0;\n    for (long long int i = 0; i < n; i++) {\n      queue<long long int> q;\n      q.push(i);\n      for (long long int x = 0; x < n; x++)\n        for (long long int y = 0; y < n; y++) dis[x][y] = 0;\n      dfs(i, -1, v);\n      for (long long int x = 0; x < n; x++) {\n        vector<long long int> temp;\n        for (auto it : v[i]) temp.push_back(dis[it][x]);\n        ans = (ans + cal(temp)) % p;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  vector<long long int> temp = {1, 1, 1, 6};\n  n = 4, k = 2;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 2147483647;\nconst int INF2 = 0x3f3f3f3f;\nconst long long INF64 = (long long)1e18;\nconst double INFD = 1e30;\nconst double EPS = 1e-9;\nconst double PI = std::acos(-1);\nconst int MOD = 1e9 + 7;\ntemplate <typename T>\ninline T read() {\n  T X = 0, w = 0;\n  char ch = 0;\n  while (!isdigit(ch)) {\n    w |= ch == '-';\n    ch = getchar();\n  }\n  while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();\n  return w ? -X : X;\n}\nconst int MAXN = 105;\nconst int MAXV = (1 << 17) + 5;\nint dr[4] = {0, 1, 0, -1};\nint dc[4] = {-1, 0, 1, 0};\nint dr2[8] = {1, 1, 1, -1, -1, -1, 0, 0};\nint dc2[8] = {1, 0, -1, 1, 0, -1, 1, -1};\nint CASE = 1;\nint A[MAXN];\nint fact[MAXN];\nstd::vector<int> G[MAXN];\nint dep[MAXN];\nint cnt[MAXN][MAXN];\nint dp[MAXN][MAXN];\nint fastExp(int x, int p, int mod) {\n  int ans = 1;\n  while (p) {\n    if (p & 1) ans = (long long)ans * x % mod;\n    x = (long long)x * x % mod;\n    p >>= 1;\n  }\n  return ans;\n}\nint getInv(int x, int mod) { return fastExp(x, MOD - 2, MOD); }\nint choose(int n, int k) {\n  if (k > n || n < 0 || k < 0) return 0;\n  return fact[n] * getInv(fact[k] * fact[n - k] % MOD, MOD) % MOD;\n}\nvoid dfs(int x, int p) {\n  for (auto v : G[x]) {\n    if (v == p) continue;\n    dep[v] = dep[x] + 1;\n    dfs(v, x);\n  }\n}\nvoid dfscnt(int x, int p, int pp) {\n  cnt[pp][dep[x]]++;\n  for (auto v : G[x]) {\n    if (v == p) continue;\n    dfscnt(v, x, pp);\n  }\n}\nvoid solve() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) G[i].clear();\n  for (int i = 1; i <= n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  if (k == 2) {\n    printf(\"%d\\n\", ((long long)n * (n - 1) / 2) % MOD);\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    dep[i] = 0;\n    dfs(i, i);\n    int sz = G[i].size();\n    if (sz < k) continue;\n    for (int a = 0; a <= n; a++) {\n      for (int b = 0; b <= n; b++) {\n        cnt[a][b] = 0;\n      }\n    }\n    for (int j = 0; j < sz; j++) {\n      auto v = G[i][j];\n      dfscnt(v, i, v);\n    }\n    for (int s = 1; s <= n; s++) {\n      dp[0][0] = 1;\n      for (int j = 1; j <= sz; j++) {\n        auto v = G[i][j - 1];\n        for (int l = 0; l <= k; l++) {\n          dp[j][l] = dp[j - 1][l];\n          if (l > 0) {\n            dp[j][l] = dp[j][l] + (long long)cnt[v][s] * dp[j - 1][l - 1] % MOD;\n            dp[j][l] %= MOD;\n          }\n        }\n      }\n      ans += dp[sz][k];\n      ans %= MOD;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i <= 100; i++) {\n    fact[i] = (long long)fact[i - 1] * i % MOD;\n  }\n  int T = read<int>();\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nconstexpr int P = 1000000007;\nint norm(int x) {\n  if (x < 0) {\n    x += P;\n  }\n  if (x >= P) {\n    x -= P;\n  }\n  return x;\n}\ntemplate <class T>\nT power(T a, int b) {\n  T res = 1;\n  for (; b; b /= 2, a *= a) {\n    if (b % 2) {\n      res *= a;\n    }\n  }\n  return res;\n}\nstruct Z {\n  int x;\n  Z(int x = 0) : x(norm(x)) {}\n  int val() const { return x; }\n  Z operator-() const { return Z(norm(P - x)); }\n  Z inv() const {\n    assert(x != 0);\n    return power(*this, P - 2);\n  }\n  Z &operator*=(const Z &rhs) {\n    x = i64(x) * rhs.x % P;\n    return *this;\n  }\n  Z &operator+=(const Z &rhs) {\n    x = norm(x + rhs.x);\n    return *this;\n  }\n  Z &operator-=(const Z &rhs) {\n    x = norm(x - rhs.x);\n    return *this;\n  }\n  Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }\n  friend Z operator*(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res *= rhs;\n    return res;\n  }\n  friend Z operator+(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res += rhs;\n    return res;\n  }\n  friend Z operator-(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res -= rhs;\n    return res;\n  }\n  friend Z operator/(const Z &lhs, const Z &rhs) {\n    Z res = lhs;\n    res /= rhs;\n    return res;\n  }\n};\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, std::pair<T, U> v) {\n  return os << '(' << v.first << \", \" << v.second << ')';\n}\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, std::set<T> s) {\n  if (s.empty()) return os << \"{}\";\n  os << '{';\n  for (auto it = s.begin(); it != prev(s.end()); it++) {\n    os << *it << \", \";\n  }\n  return os << *(prev(s.end())) << '}';\n}\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, std::vector<T> v) {\n  if (v.empty()) return os << \"[]\";\n  os << '[';\n  for (int i = 0; i < v.size() - 1; i++) {\n    os << v[i] << \", \";\n  }\n  return os << v.back() << ']';\n}\nvoid Solve() {\n  int n, k;\n  std::cin >> n >> k;\n  std::vector<std::vector<int>> e(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    std::cin >> u >> v;\n    --u;\n    --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  if (k == 2) {\n    std::cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  Z ans = 0;\n  auto bfs = [&](int s) {\n    int cnt = e[s].size();\n    if (cnt < k) return;\n    std::vector<int> x(cnt), vis(n);\n    std::vector<std::vector<int>> g(cnt);\n    vis[s] = 1;\n    for (int i = 0; i < cnt; i++) {\n      g[i].push_back(e[s][i]);\n      x[i] = vis[e[s][i]] = 1;\n    }\n    while (true) {\n      std::vector<std::vector<Z>> dp(cnt, std::vector<Z>(k + 1));\n      dp[0][0] = 1;\n      dp[0][1] = x[0];\n      for (int i = 1; i < cnt; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n          dp[i][j] = dp[i - 1][j] + x[i] * dp[i - 1][j - 1];\n        }\n      }\n      for (int i = 0; i < cnt; i++) {\n        for (int j = i + 2; j <= k; j++) {\n          assert(dp[i][j].x == 0);\n        }\n      }\n      ans += dp[cnt - 1][k];\n      fill(x.begin(), x.end(), 0);\n      std::vector<int> alive(cnt);\n      std::vector<std::vector<int>> newg(cnt);\n      for (int i = 0; i < cnt; i++) {\n        for (int u : g[i]) {\n          for (int v : e[u]) {\n            if (!vis[v]) {\n              vis[v] = 1;\n              newg[i].push_back(v);\n              x[i]++;\n              alive[i] = 1;\n            }\n          }\n        }\n      }\n      if (std::accumulate(alive.begin(), alive.end(), 0) < k) {\n        break;\n      }\n      std::swap(g, newg);\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    bfs(i);\n  }\n  std::cout << ans.x << '\\n';\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  int t;\n  std::cin >> t;\n  while (t--) {\n    Solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {new Main().run();}\n\n    FastReader in = new FastReader();\n    PrintWriter out = new PrintWriter(System.out);\n    void run() {\n        for(int q=ni();q>0;q--){\n            work();\n        }\n        out.flush();\n    }\n    long mod=1000000007;\n    long gcd(long a,long b) {\n        return a==0?b:gcd(b%a,a);\n    }\n    ArrayList<Integer>[] graph;\n    long ret;\n    int n,k;\n    void work() {\n        n=ni();\n        k=ni();\n        ret=0;\n        graph=ng(n,n-1);\n        if(k==2){\n            out.println((long)n*(n-1)/2%mod);\n            return;\n        }\n        for(int i=0;i<n;i++){\n            find(i);\n        }\n        out.println(ret);\n    }\n\n    int[][] dp;\n    private void find(int node) {\n        dp=new int[n][n];\n        dfs(node,new boolean[n]);\n        for(int i=1;i<=n;i++){\n            int c=0;\n            int[] rec=new int[n+1];\n            for(int nn:graph[node]){\n                if(dp[nn][i-1]>0){\n                    c++;\n                    rec[c]=dp[nn][i-1];\n                }\n            }\n            if(c<k){\n                break;\n            }\n            long[][] dp2=new long[c+1][k+1];\n            for(int j=0;j<=c;j++){\n                dp2[j][0]=1;\n            }\n            for(int j=1;j<=c;j++){\n                for(int p=1;p<=k;p++){\n                    dp2[j][p]=(dp2[j-1][p]+dp2[j-1][p-1]*rec[j]%mod)%mod;\n                }\n            }\n            ret=(ret+dp2[c][k])%mod;\n        }\n    }\n\n    private void dfs(int node,boolean[] vis) {\n        vis[node]=true;\n        for(int nn:graph[node]){\n            if(!vis[nn]){\n                dfs(nn,vis);\n                for(int i=1;i<n;i++){\n                    dp[node][i]+=dp[nn][i-1];\n                }\n            }\n        }\n        dp[node][0]=1;\n    }\n\n    //input\n    @SuppressWarnings(\"unused\")\n    private ArrayList<Integer>[] ng(int n, int m) {\n        ArrayList<Integer>[] graph=(ArrayList<Integer>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            int s=in.nextInt()-1,e=in.nextInt()-1;\n            graph[s].add(e);\n            graph[e].add(s);\n        }\n        return graph;\n    }\n\n    private ArrayList<long[]>[] ngw(int n, int m) {\n        ArrayList<long[]>[] graph=(ArrayList<long[]>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            long s=in.nextLong()-1,e=in.nextLong()-1,w=in.nextLong();\n            graph[(int)s].add(new long[] {e,w});\n            graph[(int)e].add(new long[] {s,w});\n        }\n        return graph;\n    }\n\n    private int ni() {\n        return in.nextInt();\n    }\n\n    private long nl() {\n        return in.nextLong();\n    }\n    private double nd() {\n        return in.nextDouble();\n    }\n    private String ns() {\n        return in.next();\n    }\n\n    private long[] na(int n) {\n        long[] A=new long[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextLong();\n        }\n        return A;\n    }\n\n    private int[] nia(int n) {\n        int[] A=new int[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextInt();\n        }\n        return A;\n    }\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n    InputStreamReader input;//no buffer\n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public FastReader(boolean isBuffer)\n    {\n        if(!isBuffer){\n            input=new InputStreamReader(System.in);\n        }else{\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n    }\n\n    public boolean hasNext(){\n        try{\n            String s=br.readLine();\n            if(s==null){\n                return  false;\n            }\n            st=new StringTokenizer(s);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    public String next()\n    {   \n        if(input!=null){\n            try {\n                StringBuilder sb=new StringBuilder();\n                int ch=input.read();\n                while(ch=='\\n'||ch=='\\r'||ch==32){\n                    ch=input.read();\n                }\n                while(ch!='\\n'&&ch!='\\r'&&ch!=32){\n                    sb.append((char)ch);\n                    ch=input.read();\n                }\n                return sb.toString();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n        while(st==null || !st.hasMoreElements())//\u56de\u8f66\uff0c\u7a7a\u884c\u60c5\u51b5\n        {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt()\n    {\n        return (int)nextLong();\n    }\n\n    public long nextLong() {\n        try {\n            if(input!=null){\n                long ret=0;\n                int b=input.read();\n                while(b<'0'||b>'9'){\n                    b=input.read();\n                }\n                while(b>='0'&&b<='9'){\n                    ret=ret*10+(b-'0');\n                    b=input.read();\n                }\n                return ret;\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, dis[102][102], ans, tmm, mod = 1e9 + 7, vis[102][102],\n                                         dp[102][102];\nvector<int> gr[102];\nvector<long long> v;\nvoid dfs(int x, int p) {\n  dis[x][0]++;\n  for (int i = 0; i < gr[x].size(); i++) {\n    int u = gr[x][i];\n    if (u == p) continue;\n    dfs(u, x);\n    for (int j = 0; j <= n; j++) dis[x][j] += dis[u][j - 1];\n  }\n}\nlong long f(int x, int nm) {\n  if (nm == k) return 1;\n  if (x == v.size()) return 0;\n  if (vis[x][nm] == tmm) return dp[x][nm];\n  long long ans = 0;\n  vis[x][nm] = tmm;\n  ans = (ans + f(x + 1, nm)) % mod;\n  ans = (ans + f(x + 1, nm + 1) * v[x]) % mod;\n  return dp[x][nm] = ans;\n}\nvoid root(int x, int p) {\n  for (int j = 1; j <= n; j++) {\n    for (int z = 0; z < gr[x].size(); z++) {\n      int u = gr[x][z];\n      if (dis[u][j - 1] > 0) v.push_back(dis[u][j - 1]);\n    }\n    if (v.size() >= k) {\n      tmm++;\n      ans = (ans + f(0, 0)) % mod;\n    }\n    v.clear();\n  }\n  for (int i = 0; i < gr[x].size(); i++) {\n    int u = gr[x][i];\n    if (u == p) continue;\n    for (int j = 1; j <= n; j++) dis[x][j] -= dis[u][j - 1];\n    for (int j = 1; j <= n; j++) dis[u][j] += dis[x][j - 1];\n    root(u, x);\n    for (int j = 1; j <= n; j++) dis[u][j] -= dis[x][j - 1];\n    for (int j = 1; j <= n; j++) dis[x][j] += dis[u][j - 1];\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    ans = 0;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j <= 100; j++) dis[i][j] = 0;\n      gr[i].clear();\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      gr[x].push_back(y);\n      gr[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << endl;\n      continue;\n    }\n    dfs(1, 0);\n    root(1, 0);\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid PV(vector<long long> v) {\n  for (long long i = 0; i < (long long)v.size(); i++) cout << v[i] << \" \";\n  cout << \"\\n\";\n}\nvoid PVV(vector<pair<long long, long long> > v) {\n  for (long long i = 0; i < (long long)v.size(); i++)\n    cout << v[i].first << \" \" << v[i].second << \"\\n\";\n}\nvoid PA(long long v[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cout << v[i] << ' ';\n  cout << \"\\n\";\n}\nvoid IN(long long a[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cin >> a[i];\n}\ninline void op() {}\nconst long long M = 1e9 + 7;\nconst long long IM = 1e18 + 37;\nconst long long N = 1000 + 10;\nvector<long long> v[N];\nmap<long long, long long> cn[N];\nlong long mx = 0;\nvoid dfs(long long x, long long baap, long long col, long long l) {\n  mx = max(mx, l);\n  cn[col][l]++;\n  for (long long it : v[x]) {\n    if (it != baap) dfs(it, x, col, l + 1);\n  }\n}\nlong long dp[N][N];\nlong long solve(long long l, long long k, long long d) {\n  if (l == 0) return (k == 0);\n  if (dp[l][k] != -1) return dp[l][k];\n  long long ans = 0;\n  ans = solve(l - 1, k, d) % M;\n  ans = (ans + (solve(l - 1, k - 1, d) * cn[l][d]) % M) % M;\n  return dp[l][k] = ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  op();\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    for (long long i = 0; i <= n; i++) {\n      v[i].clear();\n    }\n    for (long long i = 1; i < n; i++) {\n      long long x, y;\n      cin >> x >> y;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    long long ans = 0;\n    if (k == 2) {\n      ans = (n * (n - 1) / 2) % M;\n      cout << (ans) << \"\\n\";\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      mx = 0;\n      long long col = 1;\n      for (long long it : v[i]) {\n        dfs(it, i, col++, 1);\n      }\n      for (long long i = 1; i <= mx; i++) {\n        for (long long j = 0; j <= col; j++) fill(dp[j], dp[j] + k + 10, -1);\n        ans = (ans + solve(col, k, i)) % M;\n      }\n      for (long long j = 1; j <= col; j++) cn[j].clear();\n    }\n    cout << (ans) << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long cil(long long x, long long y) {\n  if (x % y == 0) {\n    return x / y;\n  };\n  return x / y + 1;\n}\nconst int32_t mod = 1e9 + 7;\nlong long power(long long a, long long b) {\n  long long ans = 1;\n  a %= mod;\n  while (b > 0) {\n    if (b % 2) {\n      ans = (ans * a) % mod;\n    }\n    a = (a * a) % mod;\n    b /= 2;\n  }\n  return ans;\n}\nlong long modi(long long a) { return power(a, mod - 2); }\nconst int32_t MXN = 1e5 + 5;\nlong long factorial[MXN + 1];\nlong long make_factorial() {\n  factorial[0] = 1;\n  for (long long i = 1; i <= MXN; i++) {\n    factorial[i] = i * factorial[i - 1];\n    factorial[i] %= mod;\n  }\n  return 0;\n}\nlong long ncr(long long n, long long r) {\n  if (n < r) return 0;\n  long long ans = factorial[n];\n  ans %= mod;\n  ans *= modi(factorial[r]);\n  ans %= mod;\n  ans *= modi(factorial[n - r]);\n  ans %= mod;\n  return ans;\n}\nconst int32_t N = 101;\nlong long n, k;\nvector<long long> adj[N];\nlong long sol(vector<long long>& a) {\n  if ((long long)(a).size() < k) return 0;\n  long long m = (long long)(a).size();\n  vector<vector<long long> > dp(m + 1, vector<long long>(k + 1, 0));\n  for (long long i = 0; i <= m; i++) dp[i][0] = 1;\n  for (long long i = 1; i <= m; i++) {\n    for (long long j = 1; j <= i; j++) {\n      if (j > k) break;\n      dp[i][j] = dp[i - 1][j - 1] * a[i - 1] + dp[i - 1][j];\n      dp[i][j] %= mod;\n    }\n  }\n  return dp[m][k];\n}\nlong long dfs(long long v, long long pre, long long curr, long long tar) {\n  if (curr == tar) return 1;\n  long long cnt = 0;\n  for (auto u : adj[v]) {\n    if (u == pre) continue;\n    long long d = dfs(u, v, curr + 1, tar);\n    cnt += d;\n  }\n  return cnt;\n}\nlong long calc(long long root) {\n  vector<long long> a[n + 1];\n  for (long long i = 1; i <= n; i++) {\n    for (auto u : adj[root]) {\n      long long x = dfs(u, root, 0, i - 1);\n      a[i].push_back(x);\n    }\n  }\n  long long ans = 0;\n  for (long long d = 1; d <= n; d++) {\n    ans += sol(a[d]);\n    ans %= mod;\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (long long i = 1; i <= n; i++) {\n    adj[i].clear();\n  }\n  for (long long i = 1; i < n; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  long long ans = 0;\n  if (k == 2) {\n    ans = ncr(n, 2);\n    cout << ans << '\\n';\n    return;\n  }\n  for (long long i = 1; i <= n; i++) {\n    ans += calc(i);\n    ans %= mod;\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  make_factorial();\n  long long tt = 1;\n  cin >> tt;\n  for (long long tc = 1; tc <= tt; tc++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<int, int>;\nusing pl = pair<ll, ll>;\nld const PI = 4 * atan((ld)1);\nconstexpr int mod = 1e9 + 7;\nconstexpr int MAX = 107;\ntemplate <int MOD = mod>\nstruct Mint {\n  int val;\n  Mint() : val(0) {}\n  Mint(int64_t _val) : val((int)(_val % MOD)) {\n    if (val < 0) val += MOD;\n  }\n  Mint &operator+=(const Mint &rhs) {\n    val += rhs.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint &operator-=(const Mint &rhs) {\n    val -= rhs.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  Mint &operator*=(const Mint &rhs) {\n    val = (int)(1ll * val * rhs.val % MOD);\n    return *this;\n  }\n  friend Mint fpow(Mint x, int64_t y) {\n    Mint res = 1;\n    for (; y > 0; y >>= 1, x *= x) {\n      if (y & 1) res *= x;\n    }\n    return res;\n  }\n  friend Mint inverse(Mint x) { return fpow(x, MOD - 2); }\n  Mint &operator/=(const Mint &rhs) { return *this *= inverse(rhs); }\n  friend Mint operator+(Mint a, const Mint &b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint &b) { return a -= b; }\n  friend Mint operator-(Mint a) { return 0 - a; }\n  friend Mint operator*(Mint a, const Mint &b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint &b) { return a /= b; }\n  friend ostream &operator<<(ostream &os, const Mint &a) { return os << a.val; }\n  friend bool operator==(const Mint &a, const Mint &b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint &a, const Mint &b) {\n    return a.val != b.val;\n  }\n};\nint n, k;\nMint<> fact[MAX], inv[MAX];\nvector<int> adj[MAX];\nMint<> dp[MAX][MAX];\ninline Mint<> choose(int a, int b) {\n  if (a < b) return 0;\n  return fact[a] * inv[b] * inv[a - b];\n}\ninline void getLevel(int node, int par, int h, vector<int> &level) {\n  level[h]++;\n  for (int to : adj[node]) {\n    if (to != par) getLevel(to, node, h + 1, level);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    adj[i].clear();\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << choose(n, 2) << '\\n';\n    return;\n  }\n  const auto get = [&](vector<int> nums) -> Mint<> {\n    int sz = (int)nums.size();\n    for (int i = 0; i <= sz; ++i) dp[i][0] = 1;\n    for (int i = 1; i <= sz; ++i)\n      for (int j = 1; j <= min(i, k); ++j)\n        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * nums[i - 1];\n    return dp[sz][k];\n  };\n  Mint<> res = 0;\n  for (int node = 1; node <= n; ++node) {\n    if ((int)adj[node].size() < k) continue;\n    vector<vector<int>> vec;\n    for (int to : adj[node]) {\n      vector<int> level(n, 0);\n      getLevel(to, node, 0, level);\n      vec.push_back(level);\n    }\n    for (int i = 0; i < n; ++i) {\n      vector<int> tmp;\n      for (int j = 0; j < (int)vec.size(); ++j) {\n        if (vec[j][i]) tmp.push_back(vec[j][i]);\n      }\n      if ((int)tmp.size() >= k) res += get(tmp);\n    }\n  }\n  cout << res << '\\n';\n}\nint main() {\n  ios ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  fact[0] = 1;\n  for (int i = 1; i < MAX; ++i) fact[i] = i * fact[i - 1];\n  inv[MAX - 1] = inverse(fact[MAX - 1]);\n  for (int i = MAX - 2; i >= 0; --i) inv[i] = (i + 1) * inv[i + 1];\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long int mod = 1e9 + 7;\nconst int M = 105;\nlong long int n, k;\nvector<long long int> a[M];\nlong long int d[M][M];\nlong long int child;\nvoid dfs(long long int v, long long int p, long long int dep) {\n  d[child][dep]++;\n  for (long long int u : a[v]) {\n    if (u == p) continue;\n    dfs(u, v, dep + 1);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int TT = clock();\n  long long int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long int i = 0; i < n; i++) a[i].clear();\n    for (long long int i = 0; i < n - 1; i++) {\n      long long int u, v;\n      cin >> u >> v;\n      u--, v--;\n      a[u].push_back(v);\n      a[v].push_back(u);\n    }\n    if (k == 2) {\n      long long int ans = n * (n - 1) / 2;\n      ans %= mod;\n      cout << ans << \"\\n\";\n      continue;\n    }\n    long long int ans = 0;\n    for (long long int i = 0; i < n; i++) {\n      memset(d, 0, sizeof(d));\n      for (long long int j = 0; j < a[i].size(); j++) {\n        child = j;\n        dfs(a[i][j], i, 1);\n      }\n      for (long long int dep = 1; dep <= n; dep++) {\n        vector<long long int> c;\n        for (long long int j = 0; j < n; j++)\n          if (d[j][dep] != 0) c.push_back(d[j][dep]);\n        long long int r = c.size();\n        if (r < k) continue;\n        vector<vector<long long int>> dp(r + 1, vector<long long int>(k + 2));\n        dp[r][k] = 1;\n        for (long long int i = r - 1; i >= 0; i--) {\n          for (long long int j = k; j >= 0; j--) {\n            dp[i][j] = (dp[i + 1][j] + dp[i + 1][j + 1] * c[i] % mod) % mod;\n          }\n        }\n        ans = (ans + dp[0][0]) % mod;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  cerr << \"\\n\\nTIME: \" << (long double)(clock() - TT) / CLOCKS_PER_SEC\n       << \" sec\\n\";\n  TT = clock();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Comparator.comparingInt;\n\npublic class Round {\n    FastScanner in;\n    PrintWriter out;\n\n    private void solve() throws IOException {\n        solveF();\n    }\n\n    private void solve_a() throws IOException {\n        int n = in.nextInt();\n        out.println(n / 3 + (n % 3 == 1 ? 1 : 0) + \" \" + (n / 3 + (n % 3 == 2 ? 1 : 0)));\n    }\n\n    private void solve_b1() throws IOException {\n        char[] s = in.next().toCharArray();\n        int n = s.length, k = 2, alpha = 'z' - 'a' + 1;\n\n        ArrayList<Integer>[] pos = new ArrayList[alpha];\n        for (int i = 0; i < alpha; i++)\n            pos[i] = new ArrayList<>();\n\n        for (int i = 0; i < n; i++)\n            pos[s[i] - 'a'].add(i);\n\n        int max_cnt = 0;\n        for (int i = 0; i < alpha; i++)\n            max_cnt += min(k, pos[i].size());\n\n        max_cnt -= max_cnt % k;\n\n        out.println(max_cnt / k);\n    }\n\n    private void solve_b2() throws IOException {\n        int n = in.nextInt(), k = in.nextInt();\n\n        ArrayList<Integer>[] pos = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            pos[i] = new ArrayList<>();\n\n        for (int i = 0; i < n; i++)\n            pos[in.nextInt() - 1].add(i);\n\n        int max_cnt = 0;\n        for (int i = 0; i < n; i++)\n            max_cnt += min(k, pos[i].size());\n\n        max_cnt -= max_cnt % k;\n\n        int[] c = new int[n];\n        int cur = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (pos[i].size() >= k) {\n                for (int j = 0; j < k; j++) {\n                    c[pos[i].get(j)] = cur % k + 1;\n                    cur++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n && cur < max_cnt; i++) {\n            if (pos[i].size() < k) {\n                for (int j = 0; j < pos[i].size() && cur < max_cnt; j++) {\n                    c[pos[i].get(j)] = cur % k + 1;\n                    cur++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            out.print(c[i] + \" \");\n        out.println();\n    }\n\n    private void solve_c() throws IOException {\n        int n = in.nextInt();\n        int[][] cnt = new int[n][6];\n        for (int i = 0; i < n; i++)\n            for (char c : in.next().toCharArray()) {\n                cnt[i][c - 'a']++;\n                cnt[i][5]++;\n            }\n\n        int ans = 0;\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            sort(cnt, comparingInt(o -> -(o[finalI] - (o[5] - o[finalI]))));\n            int cnti = 0, cnto = 0;\n            for (int j = 0; j < n; j++) {\n                cnti += cnt[j][i];\n                cnto += cnt[j][5] - cnt[j][i];\n                if (cnti > cnto)\n                    ans = max(ans, j + 1);\n                else\n                    break;\n            }\n        }\n        out.println(ans);\n    }\n\n    private void solve_d1() throws IOException {\n        int n = in.nextInt(), m = in.nextInt();\n        int horizontal = in.nextInt(), vertical = n * m / 2 - horizontal;\n\n        if (n % 2 == 1)\n            horizontal -= m / 2;\n\n        if (m % 2 == 1)\n            vertical -= n / 2;\n\n        out.println(vertical < 0 || vertical % 2 == 1 || horizontal < 0 || horizontal % 2 == 1 ? \"NO\" : \"YES\");\n    }\n\n    private void solve_d2() throws IOException {\n        int n = in.nextInt(), m = in.nextInt();\n        int horizontal = in.nextInt(), vertical = n * m / 2 - horizontal;\n\n        char[][] ans = new char[n][m];\n        TreeMap<Character, Character> pair = new TreeMap<>();\n        for (char i = 'a'; i < 'z'; i += 2) {\n            pair.put(i, (char) (i + 1));\n            pair.put((char) (i + 1), i);\n        }\n        int si = 0, sj = 0;\n\n        if (n % 2 == 1) {\n            horizontal -= m / 2;\n            char c = 'a';\n            for (int j = 0; j < m; j += 2) {\n                ans[si][j] = ans[si][j + 1] = c;\n                c = pair.get(c);\n            }\n            si++;\n        }\n\n        if (m % 2 == 1) {\n            vertical -= n / 2;\n            char c = 'a';\n            for (int i = 0; i < n; i += 2) {\n                ans[i][sj] = ans[i + 1][sj] = c;\n                c = pair.get(c);\n            }\n            sj++;\n        }\n\n        main:\n        for (int i = si; i < n; i += 2) {\n            for (int j = sj; j < m; j += 2) {\n                for (char c : pair.keySet()) {\n                    if ((i == 0 || (ans[i - 1][j] != c && ans[i - 1][j] != pair.get(c))) && (j == 0 || (ans[i][j - 1] != c && ans[i][j - 1] != pair.get(c)))) {\n                        if (horizontal > 0) {\n                            ans[i][j] = ans[i][j + 1] = c;\n                            ans[i + 1][j] = ans[i + 1][j + 1] = pair.get(c);\n                            horizontal -= 2;\n                        } else if (vertical > 0) {\n                            ans[i][j] = ans[i + 1][j] = c;\n                            ans[i][j + 1] = ans[i + 1][j + 1] = pair.get(c);\n                            vertical -= 2;\n                        } else {\n                            break main;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (vertical < 0 || vertical % 2 == 1 || horizontal < 0 || horizontal % 2 == 1) {\n            out.println(\"NO\");\n        } else {\n            out.println(\"YES\");\n\n            for (int i = 0; i < n; i++) {\n                out.println(new String(ans[i]));\n            }\n        }\n    }\n\n    private void solveE() throws IOException {\n        int n = in.nextInt(), k = in.nextInt();\n\n        int[] needRemove = new int[n];\n        for (int pos = 0; pos < n; pos++)\n            needRemove[pos] = pos - (in.nextInt() - 1);\n\n        out.println(Arrays.toString(needRemove));\n\n        int[][] dp = new int[n + 1][n + 1];\n        int ans = Integer.MAX_VALUE / 1613;\n        for (int pos = n - 1; pos >= 0; pos--) {\n            if (needRemove[pos] >= 0 && needRemove[pos] <= pos) {\n                for (int pos2 = pos + 1; pos2 < n; pos2++) {\n                    dp[needRemove[pos]][pos2]++;\n\n                }\n            }\n        }\n    }\n\n    int n, k;\n    ArrayList<Integer>[] graph;\n    long ans, mod = 1000_000_007L;\n    long[][] downCnt, fullCnt;\n\n    private void dfs(int v, int p) {\n        for (int u : graph[v])\n            if (u != p)\n                dfs(u, v);\n\n        downCnt[v][0]++;\n        for (int u : graph[v])\n            if (u != p)\n                for (int i = 1; i < n; i++)\n                    downCnt[v][i] += downCnt[u][i - 1];\n    }\n\n    private void dfs1(int v, int p) {\n        System.arraycopy(downCnt[v], 0, fullCnt[v], 0, n);\n        for (int u : graph[v])\n            if (u == p)\n                for (int dist = n - 1; dist > 0; dist--)\n                    fullCnt[v][dist] += fullCnt[u][dist - 1] - (dist >= 2 ? downCnt[v][dist - 2] : 0);\n\n        for (int u : graph[v])\n            if (u != p)\n                dfs1(u, v);\n    }\n\n    private void dfs2(int v, int p) {\n        for (int u : graph[v])\n            if (u != p)\n                dfs2(u, v);\n\n        long[][][] dp = new long[n][graph[v].size()][k + 1];\n        for (int dist = 1; dist < n; dist++) {\n            for (int i = 0; i < graph[v].size(); i++) {\n                int u = graph[v].get(i);\n                dp[dist][i][0] = 1;\n                for (int j = 1; j <= min(i + 1, k); j++) {\n                    dp[dist][i][j] = ((i == 0 ? 0 : dp[dist][i - 1][j]) +\n                            (i == 0 ? 1 : dp[dist][i - 1][j - 1]) *\n                                    (u == p ? fullCnt[u][dist - 1] - (dist < 2 ? 0 : downCnt[v][dist - 2]) + mod\n                                            : downCnt[u][dist - 1]) % mod) % mod;\n                }\n            }\n            /*if (dp[dist][graph[v].size() - 1][k] != 0) {\n                out.println(\"v = \" + (v + 1) + \" | dist = \" + dist + \" | k = \" + k + \" -> \" + dp[dist][graph[v].size() - 1][k]);\n                for (int i = 0; i < graph[v].size(); i++) {\n                    int u = graph[v].get(i);\n                    out.println(\"u = \" + (u + 1) + \" -> \" + (u == p ?\n                            fullCnt[u][dist - 1] + \" - \" + (dist < 2 ? 0 : downCnt[v][dist - 2]) + \" = \" + (fullCnt[u][dist - 1] - (dist < 2 ? 0 : downCnt[v][dist - 2]))\n                            : downCnt[u][dist - 1] + \"\"));\n                }\n            }*/\n            ans = (ans + dp[dist][graph[v].size() - 1][k]) % mod;\n        }\n    }\n\n    private void solveF() throws IOException {\n        n = in.nextInt();\n        k = in.nextInt();\n\n        graph = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            graph[i] = new ArrayList<>();\n\n        for (int i = 0; i < n - 1; i++) {\n            int v = in.nextInt() - 1, u = in.nextInt() - 1;\n            graph[v].add(u);\n            graph[u].add(v);\n        }\n\n        if (k == 2) {\n            out.println(n * (n - 1) / 2);\n            return;\n        }\n\n        ans = 0;\n        downCnt = new long[n][n];\n        dfs(0, -1);\n\n        // print(downCnt);\n\n        fullCnt = new long[n][n];\n        dfs1(0, -1);\n\n        // print(fullCnt);\n\n        dfs2(0, -1);\n        out.println(ans);\n    }\n\n    private void print(long[][] cnt) {\n        for (int i = 0; i < n; i++) {\n            out.print(i + 1 + \":\");\n            for (int j = 0; j < n; j++) {\n                out.print(\" \" + cnt[i][j]);\n            }\n            out.println();\n        }\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        for (int t = in.nextInt(); t-- > 0; )\n            solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Round().run();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "md = int(1e9) + 7\nN = 110\n\n\ndef add(x, y):\n    x += y\n    if x >= md:\n        x -= md\n    if x < 0:\n        x += md\n    return x\n\n\ndef mul(x, y):\n    x *= y\n    x %= md\n    return x\n\n\ndepth = [0] * N\ncnt = [0]\ng = [[] for _ in range(N)]\n\n\ndef Dfs(v, pr):\n    for to in g[v]:\n        if to != pr:\n            depth[to] = depth[v] + 1\n            cnt[depth[to]] += 1\n            Dfs(to, v)\n\n\ndef solve(n, k, v):\n    dp = [[1] + k * [0] for _ in range(n)]\n    depth[v] = 0\n    res = 0\n    for to in g[v]:\n        global cnt\n        cnt = [0] * n\n        depth[to] = 1\n        cnt[depth[to]] += 1\n        Dfs(to, v)\n        # print(cnt)\n        for dep in range(n):\n            for ct in reversed(range(k)):\n                dp[dep][ct + 1] = add(dp[dep][ct + 1],\n                                      mul(dp[dep][ct], cnt[dep]))\n        # print(n, k, v, cnt, dp)\n    for i in range(n):\n        res = add(res, dp[i][k])\n    return res\n\n\nt = int(input())\nfor _ in range(t):\n    input()\n    n, k = map(int, input().split())\n    for i in range(n):\n        g[i].clear()\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n\n    if k == 2:\n        print(int((n * (n - 1) / 2) % md))\n        continue\n\n    ans = 0\n    for i in range(n):\n        ans = add(ans, solve(n, k, i))\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint MOD = 1000000007;\nint expmod(long long int a, long long int b, int m) {\n  int res = 1;\n  a = a % m;\n  if (a == 0) return 0;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % m;\n    }\n    b = b >> 1;\n    a = (a * a) % m;\n  }\n  return res;\n}\nlong long prodsum(vector<int>& arr, int k) {\n  int n = arr.size();\n  if (k == 0) return 1;\n  if (n < k) return 0;\n  if (arr[0] == arr.back()) {\n    int common = arr[0];\n    long long ans = expmod(common, k, MOD);\n    for (int i = 1; i <= k; i++) {\n      ans *= n + 1 - i;\n      ans %= MOD;\n      ans *= expmod(i, MOD - 2, MOD);\n      ans %= MOD;\n    }\n    if (ans < 0) ans += MOD;\n    return ans;\n  }\n  vector<int> part(arr.begin() + 1, arr.end());\n  return prodsum(part, k) + arr[0] * prodsum(part, k - 1);\n}\nint solve(vector<vector<int>>& adj, int k) {\n  int n = adj.size();\n  if (k == 2) {\n    return (n * n - n) / 2;\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    set<int> visited = {i};\n    vector<map<int, int>> counts;\n    for (int nbr : adj[i]) {\n      visited.insert(nbr);\n      map<int, int> m;\n      set<int> current = {nbr};\n      int dist = 1;\n      m[1] = 1;\n      while (current.size()) {\n        m[dist] = current.size();\n        set<int> next;\n        for (int vtx : current) {\n          for (int next_nbr : adj[vtx]) {\n            if (!visited.count(next_nbr)) {\n              next.insert(next_nbr);\n              visited.insert(next_nbr);\n            }\n          }\n        }\n        current = next;\n        dist++;\n      }\n      counts.push_back(m);\n    }\n    bool done = false;\n    int dist = 1;\n    while (!done) {\n      vector<int> vals;\n      for (map<int, int> count : counts) {\n        if (count.find(dist) != count.end()) {\n          vals.push_back(count[dist]);\n        }\n      }\n      sort(vals.begin(), vals.end(), greater<int>());\n      if (vals.size() < k) {\n        done = true;\n      } else {\n        ans += prodsum(vals, k);\n        ans %= MOD;\n      }\n      dist++;\n    }\n  }\n  return ans;\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, k;\n    cin >> n >> k;\n    vector<vector<int>> adj(n);\n    while (n-- > 1) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n    cout << solve(adj, k) << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing cd = complex<double>;\nconst double PI = acos(-1);\nconst int N = 109;\nint c[N][N];\nint mod = 1e9 + 7;\nvector<vector<int>> adj;\nint d[N][N];\nvoid calc(int node, int par, int dep, int root) {\n  d[root][dep]++;\n  for (int ch : adj[node])\n    if (ch != par) calc(ch, node, dep + 1, root);\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  adj = vector<vector<int>>(n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u - 1].push_back(v - 1);\n    adj[v - 1].push_back(u - 1);\n  }\n  if (k == 2) {\n    cout << c[n][k] << \"\\n\";\n    return;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    memset(d, 0, sizeof d);\n    int cnt = adj[i].size();\n    vector<int> v;\n    for (int ch : adj[i]) {\n      calc(ch, i, 0, ch);\n      v.push_back(ch);\n    }\n    if (cnt < k) continue;\n    for (int di = 0; di <= n; di++) {\n      int dp[cnt + 1][k + 1];\n      memset(dp, 0, sizeof dp);\n      dp[0][0] = 1;\n      for (int i = 1; i <= cnt; i++) {\n        dp[i][0] = 1;\n        for (int r = 1; r <= k; r++) {\n          dp[i][r] =\n              (dp[i - 1][r] + 1ll * dp[i - 1][r - 1] * d[v[i - 1]][di] % mod) %\n              mod;\n        }\n      }\n      ans += dp[cnt][k];\n      ans %= mod;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  c[0][0] = 1;\n  for (int i = 1; i < N; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n  }\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long s = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\nconst long long p = 1e9 + 7;\nlong long qp(long long x, long long y) {\n  long long res = 1;\n  for (long long t = x; y; y >>= 1, t = t * t % p)\n    if (y & 1) res = res * t % p;\n  return res;\n}\nvector<long long> e[1003];\nlong long fac[1003], ifac[1003];\nlong long C(long long n, long long m) {\n  return fac[n] * ifac[n - m] % p * ifac[m] % p;\n}\nlong long n, K;\nlong long cnt[1003][1003];\nvoid dfs(long long x, long long fa, long long dep, long long id) {\n  ++cnt[id][dep];\n  for (long long i : e[x])\n    if (i != fa) dfs(i, x, dep + 1, id);\n  return;\n}\nlong long f[1003];\nsigned main() {\n  fac[0] = ifac[0] = 1;\n  for (long long i = 1; i <= 1000; ++i)\n    fac[i] = fac[i - 1] * i % p, ifac[i] = qp(fac[i], p - 2);\n  for (long long T = read(); T--;) {\n    n = read(), K = read();\n    for (long long i = 1; i <= n; ++i) e[i].clear();\n    for (long long i = 1; i < n; ++i) {\n      long long u = read(), v = read();\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    if (K == 2) {\n      printf(\"%lld\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    long long ans = 0;\n    for (long long i = 1; i <= n; ++i) {\n      long long c = 0;\n      for (long long j = 1; j <= n; ++j)\n        for (long long k = 1; k <= n; ++k) cnt[j][k] = 0;\n      for (long long j : e[i]) dfs(j, i, 1, ++c);\n      for (long long j = 1; j <= n; ++j) {\n        for (long long k = 1; k <= n; ++k) f[k] = 0;\n        f[0] = 1;\n        for (long long k = 1; k <= c; ++k) {\n          for (long long l = n; l >= 1; --l)\n            f[l] = (f[l] + f[l - 1] * cnt[k][j]) % p;\n        }\n        ans = (ans + f[K]) % p;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long n, k, nr[105][105], dp[105][105], t;\nvector<int> muchii[200005];\nbool use[200005];\nvoid dfs(int nod) {\n  use[nod] = 1;\n  nr[nod][0] = 1;\n  for (auto i : muchii[nod])\n    if (!use[i]) {\n      dfs(i);\n      for (int dist = 1; dist <= n; dist++)\n        nr[nod][dist] = (nr[nod][dist] + nr[i][dist - 1]) % mod;\n    }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) muchii[i].clear();\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    muchii[a].push_back(b);\n    muchii[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      use[j] = 0;\n      for (int dist = 0; dist <= n; dist++) nr[j][dist] = 0;\n    }\n    dfs(i);\n    for (int dist = 0; dist <= n; dist++) {\n      dp[0][0] = 1;\n      for (int j = 0; j < muchii[i].size(); j++) {\n        dp[j + 1][0] = 1;\n        for (int x = 1; x <= k; x++)\n          dp[j + 1][x] =\n              (dp[j][x] + dp[j][x - 1] * nr[muchii[i][j]][dist]) % mod;\n      }\n      ans = (ans + dp[muchii[i].size()][k]) % mod;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 109;\nconst long long mod = 1e9 + 7;\nvector<long long> vec[maxn];\nlong long deep[maxn], zi[maxn][maxn], n, k;\nvoid dfs(long long u, long long father, long long rt) {\n  deep[u] = deep[father] + 1;\n  zi[rt][deep[u]]++;\n  for (auto v : vec[u]) {\n    if (v == father) continue;\n    dfs(v, u, rt);\n  }\n}\nlong long f[maxn][maxn], w[maxn];\nvoid upd(long long &x, long long y) { x = (x + y) % mod; }\nlong long DP() {\n  for (long long i = 1; i <= w[0]; i++)\n    for (long long j = 0; j <= i && j <= k; j++) f[i][j] = 0;\n  f[0][0] = 1;\n  for (long long i = 1; i <= w[0]; i++)\n    for (long long j = 0; j <= i && j <= k; j++) {\n      if (j) upd(f[i][j], f[i - 1][j - 1] * w[i] % mod);\n      upd(f[i][j], f[i - 1][j]);\n    }\n  return f[w[0]][k];\n}\nsigned main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = 1; i < n; i++) {\n      long long l, r;\n      scanf(\"%lld%lld\", &l, &r);\n      vec[l].push_back(r);\n      vec[r].push_back(l);\n    }\n    if (k == 2)\n      cout << n * (n - 1) / 2 << endl;\n    else {\n      long long res = 0;\n      for (long long i = 1; i <= n; i++) {\n        deep[i] = 0;\n        for (auto v : vec[i]) dfs(v, i, v);\n        for (long long j = 1; j <= n; j++) {\n          w[0] = 0;\n          for (auto v : vec[i]) w[++w[0]] = zi[v][j];\n          res = (res + DP()) % mod;\n        }\n        for (auto v : vec[i])\n          for (long long j = 1; j <= n; j++) zi[v][j] = 0;\n      }\n      cout << res << endl;\n    }\n    for (long long i = 1; i <= n; i++) vec[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing PP = pair<ll, P>;\nconst ll n_ = 111 + 100, inf = 1e18, mod = 1e9 + 7, sqrtN = 333, p = 27;\nll dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\nll n, m, k, tc = 1, a, b, c, d, sum, x, y, z, w, base, ans;\nll gcd(ll x, ll y) {\n  if (!y) return x;\n  return gcd(y, x % y);\n}\nvector<ll> v[n_];\nll checked[n_], cnt[n_], dp[n_][n_];\nll f(ll x, ll y) {\n  for (int i = 0; i <= x; i++)\n    for (int j = 0; j <= y; j++) dp[i][j] = 0;\n  dp[0][0] = 1;\n  for (int i = 0; i < x; i++)\n    for (int j = 0; j <= y; j++) {\n      dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n      dp[i + 1][j + 1] = (dp[i + 1][j + 1] + (dp[i][j] * cnt[i]) % mod) % mod;\n    }\n  return dp[x][y];\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) v[i].clear();\n  for (int i = 0; i < n - 1; i++) {\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  ans = 0;\n  if (k == 2) {\n    ans = n * (n - 1) / 2;\n    cout << ans % mod << '\\n';\n    return;\n  }\n  for (int i = 1; i <= n; i++) {\n    memset(checked, 0, sizeof(checked));\n    checked[i] = true;\n    vector<P> temp;\n    for (int j = 0; j < v[i].size(); j++) {\n      temp.push_back({v[i][j], j});\n      cnt[j] = 1;\n      checked[v[i][j]] = true;\n    }\n    while (temp.size()) {\n      ans += f((ll)v[i].size(), k);\n      ans %= mod;\n      vector<P> V;\n      for (auto nxt : temp) {\n        cnt[nxt.second]--;\n        for (auto nxt2 : v[nxt.first]) {\n          if (checked[nxt2]) continue;\n          checked[nxt2] = true;\n          cnt[nxt.second]++;\n          V.push_back({nxt2, nxt.second});\n        }\n      }\n      temp = V;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  cin >> tc;\n  while (tc--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e2 + 5, INF = 0x3f3f3f3f, mod = 1e9 + 7;\nconst double PI = acos(-1), EPS = 1e-8;\nnamespace fast_IO {\nlong long read() {\n  long long num = 0;\n  char c;\n  bool tag = false;\n  while ((c = getchar()) != '-' && c != '+' && (c < '0' || c > '9') && ~c)\n    ;\n  if (!~c) return EOF;\n  if (c == '-')\n    tag = true;\n  else if (c == '+')\n    tag = false;\n  else\n    num = c ^ 48;\n  while ((c = getchar()) >= '0' && c <= '9')\n    num = (num << 1) + (num << 3) + (c ^ 48);\n  if (tag) return -num;\n  return num;\n}\n}  // namespace fast_IO\nvector<int> to[N];\nlong long C[N][N], a[N], dp[N][N];\nint q[N];\nbool vis[N];\nvoid dfs(int x, int step) {\n  int head = 0, tail = 0, sum = 1;\n  vis[x] = true;\n  q[head++] = x;\n  while (head != tail) {\n    if (--step == 0) {\n      if (sum) a[++*a] = sum;\n      return;\n    }\n    int tot = 0;\n    while (sum--) {\n      int x = q[tail++];\n      for (auto k : to[x]) {\n        if (vis[k]) continue;\n        vis[k] = true;\n        ++tot;\n        q[head++] = k;\n      }\n    }\n    sum = tot;\n  }\n}\nint main() {\n  C[0][0] = 1;\n  for (int i = 1; i <= 100; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n  }\n  int T = fast_IO::read();\n  while (T--) {\n    int n = fast_IO::read(), k = fast_IO::read();\n    long long ans = 0;\n    for (int i = 1; i <= n; ++i) to[i].clear();\n    for (int i = 1; i < n; ++i) {\n      int x = fast_IO::read(), y = fast_IO::read();\n      to[x].push_back(y);\n      to[y].push_back(x);\n    }\n    if (k > 2) {\n      for (int i = 1; i <= n; ++i) {\n        if (to[i].size() < k) continue;\n        for (int j = 1; j <= n; ++j) {\n          *a = 0;\n          memset(vis, 0, sizeof(vis));\n          vis[i] = true;\n          for (auto k : to[i]) dfs(k, j);\n          if (*a < k) continue;\n          for (int t = 0; t <= *a; ++t) dp[t][0] = 1;\n          for (int t = 1; t <= *a; ++t)\n            for (int p = 1; p <= t && p <= k; ++p)\n              dp[t][p] = (dp[t - 1][p] + dp[t - 1][p - 1] * a[t] % mod) % mod;\n          (ans += dp[*a][k]) %= mod;\n        }\n      }\n      printf(\"%lld\\n\", ans);\n    } else\n      printf(\"%lld\\n\", C[n][2]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long T, n, k, x, y, num[120][120], f[120][120];\nvector<long long> g[120];\nvector<long long> a;\nvoid dfs(long long u, long long fa) {\n  num[u][0] = 1;\n  for (long long i = 0; i < (long long)g[u].size(); i++) {\n    long long v = g[u][i];\n    if (v == fa) continue;\n    dfs(v, u);\n    for (long long j = 1; j <= n; j++) num[u][j] += num[v][j - 1];\n  }\n}\nsigned main() {\n  cin >> T;\n  while (T--) {\n    cin >> n >> k;\n    long long ans = 0;\n    for (long long i = 1; i < n; i++)\n      cin >> x >> y, g[x].push_back(y), g[y].push_back(x);\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      for (long long i = 1; i <= n; i++) g[i].clear();\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      dfs(i, 0);\n      for (long long j = 1; j <= n; j++) {\n        for (long long l = 0; l < (long long)g[i].size(); l++)\n          a.push_back(num[g[i][l]][j - 1]);\n        f[0][0] = 1;\n        for (long long x = 1; x <= (long long)a.size(); x++) {\n          f[x][0] = 1;\n          for (long long y = 1; y <= x; y++)\n            f[x][y] = (f[x - 1][y] + f[x - 1][y - 1] * a[x - 1] % 1000000007) %\n                      1000000007;\n        }\n        ans = (ans + f[a.size()][k]) % 1000000007;\n        for (long long x = 1; x <= (long long)a.size(); x++)\n          for (long long y = 1; y <= x; y++) f[x][y] = 0;\n        a.clear();\n      }\n      for (long long j = 1; j <= n; j++)\n        for (long long l = 0; l <= n; l++) num[j][l] = 0;\n    }\n    cout << ans << '\\n';\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 1; i <= n; i++)\n      for (long long j = 0; j <= n; j++) num[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 105;\nlong long f[N][N];\nlong long cnt[N][N];\nvector<int> q[N];\nint maxn = 0;\nvoid dfs(int rt, int u, int fa, int dep) {\n  cnt[rt][dep]++;\n  maxn = max(maxn, dep);\n  for (auto &v : q[u]) {\n    if (v == fa) continue;\n    dfs(rt, v, u, dep + 1);\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 0; i <= n; i++) {\n      q[i].clear();\n    }\n    for (int i = 1; i <= n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      q[u].push_back(v);\n      q[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << (long long)n * (n - 1) % mod / 2 % mod << '\\n';\n      continue;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      memset(cnt, 0, sizeof cnt);\n      int mx_d = 0;\n      for (auto &u : q[i]) {\n        maxn = 0;\n        dfs(u, u, i, 0);\n        mx_d = max(mx_d, maxn);\n      }\n      for (int w = 0; w <= mx_d; w++) {\n        memset(f, 0, sizeof f);\n        f[0][0] = 1;\n        f[0][1] = cnt[q[i][0]][w];\n        for (int ii = 1; ii < q[i].size(); ii++) {\n          f[ii][0] = 1;\n          for (int j = 1; j <= min(k, ii + 1); j++)\n            f[ii][j] = (f[ii - 1][j] +\n                        (long long)f[ii - 1][j - 1] * cnt[q[i][ii]][w] % mod) %\n                       mod;\n        }\n        ans = (ans + f[q[i].size() - 1][k]) % mod;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops\")\nlong long md = 1000000007;\nusing namespace std;\ntemplate <typename T>\nT pw(T a, T b) {\n  T c = 1, m = a;\n  while (b) {\n    if (b & 1) c = (c * m);\n    m = (m * m), b /= 2;\n  }\n  return c;\n}\ntemplate <typename T>\nT ceel(T a, T b) {\n  if (a % b == 0)\n    return a / b;\n  else\n    return a / b + 1;\n}\ntemplate <typename T>\nT my_log(T n, T b) {\n  T i = 1, ans = 0;\n  while (1) {\n    if (i > n) {\n      ans--;\n      break;\n    }\n    if (i == n) break;\n    i *= b, ans++;\n  }\n  return ans;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long pwmd(long long a, long long b) {\n  long long c = 1, m = a;\n  while (b) {\n    if (b & 1) c = (c * m) % md;\n    m = (m * m) % md;\n    b /= 2;\n  }\n  return c;\n}\nlong long modinv(long long n) { return pwmd(n, md - 2); }\nlong long inverse(long long i) {\n  if (i == 1) return 1;\n  return (md - ((md / i) * inverse(md % i)) % md + md) % md;\n}\nbool sortbysec(const pair<long long, long long> &a,\n               const pair<long long, long long> &b) {\n  return (a.second < b.second);\n}\nlong long t, n, k, x, y, h = 0;\nvector<long long> adj[101], vis(101), dist(101);\nlong long dis[101][101];\nvoid dfs(long long u) {\n  vis[u] = 1;\n  for (auto s : adj[u]) {\n    if (vis[s]) continue;\n    dist[s] = dist[u] + 1;\n    dis[dist[s]][h]++;\n    dfs(s);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = 0; i < n + 1; i++) adj[i].clear();\n    for (long long i = 0; i < n - 1; i++)\n      cin >> x >> y, adj[x].push_back(y), adj[y].push_back(x);\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    long long ans = 0;\n    for (long long i = 1; i < n + 1; i++) {\n      for (long long j = 1; j < n + 1; j++) vis[j] = 0;\n      if (adj[i].size() < k) continue;\n      long long o = adj[i].size();\n      h = 0;\n      for (long long j = 0; j < n + 1; j++)\n        for (long long p = 0; p < n + 1; p++) dis[j][p] = 0;\n      for (auto w : adj[i]) {\n        dis[1][h]++;\n        for (long long p = 0; p < n + 1; p++) vis[p] = 0, dist[p] = 0;\n        dist[w] = 1;\n        vis[i] = 1;\n        dfs(w), h++;\n      }\n      for (long long j = 1; j < n + 1; j++) {\n        vector<long long> v;\n        for (long long p = 0; p < n + 1; p++) {\n          if (dis[j][p]) v.push_back(dis[j][p]);\n        }\n        if (v.size() < k) continue;\n        long long g = v.size();\n        long long dp[g][k + 1];\n        for (long long dd = 0; dd < g; dd++)\n          for (long long tt = 0; tt < k + 1; tt++) dp[dd][tt] = 0;\n        dp[0][0] = 1, dp[0][1] = v[0];\n        for (long long dd = 1; dd < g; dd++) {\n          dp[dd][0] = 1;\n          for (long long tt = 1; tt < k + 1; tt++) {\n            dp[dd][tt] = dp[dd - 1][tt];\n            dp[dd][tt] %= md;\n            dp[dd][tt] += (dp[dd - 1][tt - 1] * v[dd]) % md;\n            dp[dd][tt] %= md;\n          }\n        }\n        ans = (ans + dp[g - 1][k]) % md;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid smin(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <class T>\nvoid smax(T &a, T b) {\n  a = max(a, b);\n}\nvoid yes() { cout << \"Yes\" << endl; }\nvoid no() { cout << \"No\" << endl; }\ntemplate <typename S, typename T>\nostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  for (int i = 0; i < (int)v.size(); i++) {\n    out << v[i];\n    if (i != (int)v.size() - 1) out << \", \";\n  }\n  out << \"]\";\n  return out;\n}\nconst long long MOD = 1e9 + 7;\nvector<int> merge(vector<vector<int>> &dists) {\n  vector<int> out;\n  for (int i = 0; i < dists.size(); i++) {\n    for (int j = 0; j < dists[i].size(); j++) {\n      out.push_back(dists[i][j]);\n    }\n  }\n  return out;\n}\nvector<vector<int>> get_children_lenghts(int head, vector<bool> &vis,\n                                         vector<vector<int>> &G) {\n  vector<vector<int>> out;\n  if (vis[head]) return out;\n  vis[head] = true;\n  for (auto el : G[head]) {\n    if (vis[el]) continue;\n    vector<int> row;\n    row.push_back(1);\n    vector<vector<int>> dists = get_children_lenghts(el, vis, G);\n    vector<int> lenghts = merge(dists);\n    for (auto el : lenghts) row.push_back(el + 1);\n    out.push_back(row);\n  }\n  return out;\n}\nvector<long long> transform(vector<int> &lenghts, int n) {\n  vector<long long> out(n + 1);\n  for (auto el : lenghts) {\n    out[el] += 1;\n  }\n  return out;\n}\nlong long combs(vector<long long> &nums, int k) {\n  int n = nums.size();\n  vector<vector<int>> dp(n, vector<int>(k + 1, 0));\n  dp[0][1] = nums[0] % MOD;\n  for (int i = 1; i < n; i++) dp[i][1] = (nums[i] + dp[i - 1][1]) % MOD;\n  for (int k_idx = 2; k_idx <= k; k_idx++) {\n    for (int i = k_idx - 1; i < n; i++) {\n      dp[i][k_idx] = (dp[i - 1][k_idx] + nums[i] * dp[i - 1][k_idx - 1]) % MOD;\n    }\n  }\n  return dp[n - 1][k];\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> G(n + 1);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  long long out = 0;\n  if (k == 2) {\n    cout << (n * (n - 1)) / 2 << endl;\n    return;\n  }\n  for (int i = 1; i <= n; i++) {\n    vector<bool> vis(n + 1, false);\n    vector<vector<int>> ls = get_children_lenghts(i, vis, G);\n    vector<vector<long long>> lenghts;\n    for (auto &el : ls) {\n      lenghts.push_back(transform(el, n));\n    }\n    vector<vector<long long>> poss;\n    for (int i = 1; i <= n; i++) {\n      vector<long long> nums;\n      for (auto &el : lenghts) {\n        if (el[i] != 0) nums.push_back(el[i]);\n      }\n      if (nums.size() >= k) {\n        poss.push_back(nums);\n      }\n    }\n    for (auto &nums : poss) {\n      out = (out + combs(nums, k)) % MOD;\n    }\n  }\n  cout << out << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> a) {\n  out << a.first << \" \" << a.second;\n  return out;\n}\ntemplate <typename T, typename T1>\nT maxs(T &a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT mins(T &a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\nconst long long MOD = 1000000007;\nstruct mod_int {\n  long long val;\n  mod_int(long long v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = v;\n  }\n  static long long mod_inv(long long a, long long m = MOD) {\n    long long g = m, r = a, first = 0, second = 1;\n    while (r != 0) {\n      long long q = g / r;\n      g %= r;\n      swap(g, r);\n      first -= q * second;\n      swap(first, second);\n    }\n    return first < 0 ? first + m : first;\n  }\n  explicit operator long long() const { return val; }\n  mod_int &operator+=(const mod_int &other) {\n    val += other.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n  mod_int &operator-=(const mod_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  static unsigned fast_mod(uint64_t first, unsigned m = MOD) {\n    return first % m;\n    unsigned x_high = first >> 32, x_low = (unsigned)first;\n    unsigned quot, rem;\n    asm(\"divl %4\\n\" : \"=a\"(quot), \"=d\"(rem) : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n    return rem;\n  }\n  mod_int &operator*=(const mod_int &other) {\n    val = fast_mod((uint64_t)val * other.val);\n    return *this;\n  }\n  mod_int &operator/=(const mod_int &other) { return *this *= other.inv(); }\n  friend mod_int operator+(const mod_int &a, const mod_int &b) {\n    return mod_int(a) += b;\n  }\n  friend mod_int operator-(const mod_int &a, const mod_int &b) {\n    return mod_int(a) -= b;\n  }\n  friend mod_int operator*(const mod_int &a, const mod_int &b) {\n    return mod_int(a) *= b;\n  }\n  friend mod_int operator/(const mod_int &a, const mod_int &b) {\n    return mod_int(a) /= b;\n  }\n  mod_int &operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n  mod_int &operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n  mod_int operator++(int32_t) {\n    mod_int before = *this;\n    ++*this;\n    return before;\n  }\n  mod_int operator--(int32_t) {\n    mod_int before = *this;\n    --*this;\n    return before;\n  }\n  mod_int operator-() const { return val == 0 ? 0 : MOD - val; }\n  bool operator==(const mod_int &other) const { return val == other.val; }\n  bool operator!=(const mod_int &other) const { return val != other.val; }\n  mod_int inv() const { return mod_inv(val); }\n  mod_int pow(long long p) const {\n    assert(p >= 0);\n    mod_int a = *this, result = 1;\n    while (p > 0) {\n      if (p & 1) result *= a;\n      a *= a;\n      p >>= 1;\n    }\n    return result;\n  }\n  friend ostream &operator<<(ostream &stream, const mod_int &m) {\n    return stream << m.val;\n  }\n  friend istream &operator>>(istream &stream, mod_int &m) {\n    return stream >> m.val;\n  }\n};\nlong long solve() {\n  long long n, k;\n  cin >> n >> k;\n  vector<vector<long long>> g(n + 1);\n  for (long long i = 0; i + 1 < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    mod_int v = n;\n    cout << v * (v - 1) / 2 << \"\\n\";\n    return 0;\n  }\n  function<void(long long, long long, long long, vector<long long> &)> dfs =\n      [&](long long u, long long p, long long h, vector<long long> &d) {\n        d[h]++;\n        for (auto i : g[u]) {\n          if (i != p) {\n            dfs(i, u, h + 1, d);\n          }\n        }\n      };\n  mod_int ans = 0;\n  auto solve = [&](long long r) {\n    vector<vector<long long>> vals;\n    for (auto i : g[r]) {\n      vector<long long> d(n + 1);\n      dfs(i, r, 1, d);\n      vals.push_back(d);\n    }\n    for (long long d = 1; d <= n; d++) {\n      vector<mod_int> dp(k + 1);\n      dp[0] = 1;\n      for (long long i = 0; i < vals.size(); i++) {\n        vector<mod_int> new_dp(k + 1);\n        for (long long j = 0; j <= k; j++) {\n          new_dp[j] = dp[j];\n          if (j >= 1) {\n            new_dp[j] += dp[j - 1] * (vals[i][d]);\n          }\n        }\n        swap(dp, new_dp);\n      }\n      ans += dp[k];\n    }\n  };\n  for (long long i = 1; i <= n; i++) {\n    solve(i);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint t;\nint n, k;\nvector<int> g[110];\nint dep[110], dp[110][110];\ninline void upd(int &x, int y) { x = (x + y) % mod; }\nvoid dfs(int x, int fa, int d, int &cnt) {\n  if (dep[x] == d) cnt++;\n  for (int i = 0; i < (int)g[x].size(); i++) {\n    int to = g[x][i];\n    if (to == fa) continue;\n    dep[to] = dep[x] + 1;\n    dfs(to, x, d, cnt);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) g[i].clear();\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << 1ll * n * (n - 1) / 2 % mod << endl;\n    return;\n  }\n  int ans = 0;\n  for (int r = 0; r < n; r++)\n    for (int d = 1; d <= n; d++) {\n      if ((int)g[r].size() < k) continue;\n      dp[0][0] = 1;\n      for (int i = 0; i < (int)g[r].size(); i++) {\n        int cnt = 0;\n        dep[g[r][i]] = 1;\n        dfs(g[r][i], r, d, cnt);\n        for (int j = 0; j <= i + 1; j++) dp[i + 1][j] = 0;\n        for (int j = 0; j <= i; j++) {\n          if (cnt > 0) upd(dp[i + 1][j + 1], 1ll * dp[i][j] * cnt % mod);\n          upd(dp[i + 1][j], dp[i][j]);\n        }\n      }\n      cout << endl;\n      upd(ans, dp[(int)g[r].size()][k]);\n    }\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\nmod=10**9+7\n\nFACT=[1]\nfor i in range(1,2*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]%mod*FACT_INV[a-b]%mod\n    else:\n        return 0\n\n\nt=int(input())\nfor tests in range(t):\n    _=input()\n    n,k=map(int,input().split())\n    E=[[] for i in range(n)]\n\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        a-=1\n        b-=1\n        E[a].append(b)\n        E[b].append(a)\n\n    if k==2:\n        print(n*(n-1)//2%mod)\n        continue\n\n    ANS=0\n\n    for center in range(n):\n        DIS=[-1]*n\n        Q=[center]\n        DIS[center]=0\n        P=[-1]*n\n\n        DISP=Counter()\n\n        while Q:\n            x=Q.pop()\n\n            for to in E[x]:\n                if DIS[to]==-1:\n                    DIS[to]=DIS[x]+1\n\n                    if x==center:\n                        P[to]=to\n                    else:\n                        P[to]=P[x]\n\n                    DISP[(P[to],DIS[to])]+=1\n                    Q.append(to)\n\n        L=[[] for i in range(n+1)]\n\n        for fr,dis in DISP:\n            L[dis].append(DISP[fr,dis])\n\n        #print(L)\n\n\n        for l in L:\n            if len(l)<k:\n                continue\n            #print(l)\n\n            DP=[0]*(k+1)\n            DP[0]=1\n\n            for x in l:\n                for j in range(k-1,-1,-1):\n                    if DP[j]!=0:\n                        DP[j+1]+=DP[j]*x\n\n            ANS=ANS+DP[k]\n            ANS%=mod\n\n            #print(DP,ANS)\n                \n    #print(ANS)\n\n                \n\n                \n        \n\n    print(ANS)\n            \n            \n            \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,tune=native\")\ntemplate <typename T>\nusing Prior = std::priority_queue<T>;\ntemplate <typename T>\nusing prior = std::priority_queue<T, std::vector<T>, std::greater<T>>;\nusing namespace std;\nconst long long md = 1e9 + 7;\ninline long long mod(long long x) { return (x % md + md) % md; }\nint n, k;\nvector<vector<long long>> g;\nint tra(int src, int dir, int step) {\n  if (!step) return 1;\n  int ret = 0;\n  for (auto nbr : g[dir]) {\n    if (nbr == src) continue;\n    ret += tra(dir, nbr, step - 1);\n  }\n  return ret;\n}\nlong long h(const vector<long long>& cef, int k) {\n  const int m = cef.size();\n  assert(m >= k);\n  vector<vector<long long>> dp(m + 1, vector<long long>(k + 1));\n  for (int i = 0; i <= m; ++i) dp[i][0] = 1;\n  for (int i = 1; i <= m; ++i)\n    for (int j = 1; j <= min(i, k); ++j)\n      dp[i][j] = mod(dp[i - 1][j] + mod(dp[i - 1][j - 1] * cef[i - 1]));\n  return dp[m][k];\n}\nvoid solve() {\n  cin >> n >> k;\n  g = vector<vector<long long>>(n);\n  for (auto [u, v] : vector<pair<long long, long long>>(n - 1)) {\n    cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  };\n  ;\n  if (k == 2) return cout << (n * (n - 1LL) >> 1) << '\\n', void();\n  long long ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int m = g[i].size();\n    for (int step = 1; step < n; ++step) {\n      vector<long long> cnt;\n      for (auto dir : g[i])\n        if (int tmp = tra(i, dir, step - 1)) cnt.push_back(tmp);\n      if (cnt.size() < k) continue;\n      ans = mod(ans + h(cnt, k));\n    }\n  }\n  return cout << ans << '\\n', void();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int _ = 1;\n  cin >> _;\n  vector<long long> __(_);\n  iota(begin(__), end(__), 1);\n  for (auto i : __) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst char nl = '\\n';\nconst long long inf = 1e9 + 10;\nconst long long inf2 = 1e18 + 99LL;\nconst long double inf3 = 1e17;\nconst long long mod = 1e9 + 7, mod2 = 998244353;\nconst long double eps = 1e-9;\nconst bool local = false;\nconst int logn = 17, maxn = 101, maxm = 200001, maxn2 = 3;\nvector<int> g[maxn], d, a[maxn];\nvoid dfs(int v, int p, int cd = 0) {\n  d[cd]++;\n  for (int x : g[v]) {\n    if (x == p) continue;\n    dfs(x, v, cd + 1);\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) g[i].clear();\n  for (int i = 0; i < n - 1; i++) {\n    int ta, b;\n    cin >> ta >> b;\n    ta--;\n    b--;\n    g[ta].push_back(b);\n    g[b].push_back(ta);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << nl;\n    return;\n  }\n  long long ans = 0;\n  for (int v = 0; v < n; v++) {\n    if ((int)((g[v]).size()) < k) continue;\n    for (int i = 0; i < n; i++) a[i].clear();\n    for (int x : g[v]) {\n      d.assign(n, 0);\n      dfs(x, v);\n      for (int j = 0; j < n; j++) {\n        if (d[j] == 0) break;\n        a[j].push_back(d[j]);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if ((int)((a[i]).size()) < k) break;\n      vector<vector<long long>> dp((int)((a[i]).size()) + 1,\n                                   vector<long long>(k + 1));\n      dp[0][0] = 1;\n      for (int j = 1; j <= (int)((a[i]).size()); j++) {\n        dp[j][0] = dp[j - 1][0];\n        for (int tk = 1; tk <= k; tk++) {\n          dp[j][tk] = dp[j - 1][tk - 1] * a[i][j - 1] + dp[j - 1][tk];\n          dp[j][tk] %= mod;\n        }\n      }\n      ans += dp.back().back();\n      ans %= mod;\n    }\n  }\n  cout << ans << nl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  ;\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr int N = 101;\nconstexpr int M = 1e9 + 7;\nll ans;\nint n, k;\nvector<int> edges[N];\nint depth[N][N];\nint arr[N];\nint dp[N][N];\nvoid dfs(int cur, int par) {\n  memset(depth[cur], 0, sizeof(int) * n);\n  depth[cur][0] = 1;\n  for (int i = (0); i < (edges[cur].size()); ++i) {\n    int nxt = edges[cur][i];\n    if (nxt == par) continue;\n    dfs(nxt, cur);\n    for (int j = (1); j < (n); ++j) {\n      depth[cur][j] += depth[nxt][j - 1];\n    }\n  }\n}\nvoid solve(int root) {\n  if (edges[root].size() < k) return;\n  dfs(root, -1);\n  for (int dist = (0); dist < (n); ++dist) {\n    for (int i = (0); i < (edges[root].size()); ++i) {\n      int child = edges[root][i];\n      int x = depth[child][dist];\n      arr[i] = x;\n    }\n    memset(dp, 0, sizeof(int) * N * N);\n    for (int i = (0); i < (edges[root].size()); ++i) {\n      dp[i][0] = 1;\n    }\n    for (int i = (1); i <= (edges[root].size()); ++i) {\n      for (int j = (1); j <= (min(i, k)); ++j) {\n        dp[i][j] = (dp[i - 1][j] + (ll)arr[i - 1] * dp[i - 1][j - 1]) % M;\n      }\n    }\n    ans += dp[edges[root].size()][k];\n    ans %= M;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    cin >> n >> k;\n    memset(edges, 0, sizeof(vector<int>) * N);\n    ans = 0;\n    for (int i = (0); i < (n - 1); ++i) {\n      int u, v;\n      cin >> u >> v;\n      u--;\n      v--;\n      edges[u].push_back(v);\n      edges[v].push_back(u);\n    }\n    if (k == 2) {\n      ans = n * (n - 1) / 2;\n      ans %= M;\n    } else {\n      for (int i = (0); i < (n); ++i) {\n        solve(i);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int64_t mod = 1e9 + 7;\nconstexpr int64_t mxn = 101;\nint64_t d[mxn][mxn];\nvector<int64_t> adj[mxn];\nvoid dfs(int64_t u, int64_t p, int64_t l, int64_t r) {\n  d[r][l]++;\n  for (auto& v : adj[u]) {\n    if (v != p) {\n      dfs(v, u, l + 1, r);\n    }\n  }\n}\nint64_t dp[mxn][mxn];\nint64_t compute(vector<int64_t>& f, int64_t k) {\n  int64_t m = f.size();\n  if (m < k) return 0;\n  memset(dp, 0, sizeof dp);\n  dp[0][0] = 1;\n  dp[0][1] = f[0];\n  for (int64_t i = 1; i < m; ++i) {\n    dp[i][0] = 1;\n    for (int64_t j = 1; j <= k; ++j) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * f[i] % mod) % mod;\n    }\n  }\n  return dp[m - 1][k];\n}\nvoid hike() {\n  int64_t n, k;\n  cin >> n >> k;\n  for (int64_t i = 0; i + 1 < n; ++i) {\n    int64_t u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << \"\\n\";\n    for (int64_t i = 1; i <= n; ++i) {\n      adj[i].clear();\n    }\n    return;\n  }\n  int64_t count = 0;\n  for (int64_t i = 1; i <= n; ++i) {\n    for (auto& v : adj[i]) {\n      dfs(v, i, 1, v);\n    }\n    for (int64_t l = 1; l < n; ++l) {\n      vector<int64_t> f;\n      for (int64_t j = 1; j <= n; ++j) {\n        if (d[j][l]) {\n          f.push_back(d[j][l]);\n        }\n      }\n      (count += compute(f, k)) %= mod;\n    }\n    for (int64_t i = 0; i <= n; ++i) {\n      for (int64_t j = 0; j <= n; ++j) {\n        d[i][j] = 0;\n      }\n    }\n  }\n  cout << count << \"\\n\";\n  for (int64_t i = 1; i <= n; ++i) {\n    adj[i].clear();\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int64_t t = 1;\n  cin >> t;\n  while (t--) hike();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ninput = sys.stdin.readline\n\nF = [None]*101\nF[0] = 1\nfor i in range(1,len(F)):\n\tF[i] = (F[i-1] * i) % int(1e9+7)\n\ndef rec(x, p, g, c, s):\n\tc[s] += 1\n\tfor v in g[x]:\n\t\tif v != p:\n\t\t\trec(v, x, g, c, s+1)\n\ndef solve():\n\tinput()\n\tn, k = map(int, input().split())\n\tg = [[] for i in range(n+1)]\n\tfor i in range(n-1):\n\t\tu, v = map(int, input().split())\n\t\tg[u].append(v)\n\t\tg[v].append(u)\n\tMOD = int(1e9+7)\n\tif k == 2:\n\t\tprint((n * (n-1) // 2) % MOD)\n\t\treturn\n\tr = 0\n\tfor x in range(1,n+1):\n\t\td = [[0]*n for i in range(k+1)]\n\t\td[0] = [1]*n\n\t\tfor v in g[x]:\n\t\t\tc = [0] * n\n\t\t\trec(v, x, g, c, 0)\n\t\t\t#print(x, v, c)\n\t\t\tfor i in range(k-1,-1,-1):\n\t\t\t\tfor j in range(n):\n\t\t\t\t\td[i+1][j] = (d[i+1][j] + d[i][j] * c[j]) % MOD\n\t\t#print(x,d)\n\t\tfor j in range(n):\n\t\t\tr = (r + d[k][j]) % MOD\n\tprint(r)\n\nfor i in range(int(input())):\n\tsolve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar Gc() {\n  static char now[1 << 20], *S, *T;\n  if (T == S) {\n    T = (S = now) + std::fread(now, 1, 1 << 20, stdin);\n    if (T == S) return EOF;\n  }\n  return *S++;\n}\ntemplate <typename T>\nvoid Read(T &x) {\n  x = 0;\n  int f = 1;\n  char c;\n  while ((c = Gc()) < '0' || c > '9')\n    if (c == '-') f = -1;\n  x = c - '0';\n  while ((c = Gc()) >= '0' && c <= '9') x = x * 10 + (c - '0');\n  x *= f;\n}\ntemplate <typename T, typename... Args>\nvoid Read(T &x, Args &...args) {\n  Read(x);\n  Read(args...);\n}\ntemplate <typename T>\nvoid checkmax(T &x, T y) {\n  if (x < y) x = y;\n}\ntemplate <typename T>\nvoid checkmin(T &x, T y) {\n  if (x > y) x = y;\n}\nconstexpr int kMod = 1e9 + 7;\ntemplate <typename T>\nT add(T a, T b) {\n  return (a + b) % kMod;\n}\ntemplate <typename T, typename... Args>\nT add(T a, T b, Args... args) {\n  return add(add(a, b), args...);\n}\ntemplate <typename T>\nT sub(T a, T b) {\n  return (a + kMod - b) % kMod;\n}\ntemplate <typename T>\nT mul(T a, T b) {\n  return a * static_cast<long long>(b) % kMod;\n}\ntemplate <typename T, typename... Args>\nT mul(T a, T b, Args... args) {\n  return mul(mul(a, b), args...);\n}\ntemplate <typename T>\nvoid Add(T &a, T b) {\n  a = add(a, b);\n}\ntemplate <typename T, typename... Args>\nvoid Add(T &a, T b, Args... args) {\n  Add(a, add(b, args...));\n}\ntemplate <typename T>\nvoid Sub(T &a, T b) {\n  a = sub(a, b);\n}\ntemplate <typename T>\nvoid Mul(T &a, T b) {\n  a = mul(a, b);\n}\ntemplate <typename T, typename... Args>\nvoid Mul(T &a, T b, Args... args) {\n  Mul(a, mul(b, args...));\n}\ntemplate <typename T1, typename T2>\nT1 Ksm(T1 a, T2 b) {\n  T1 s = 1;\n  while (b) {\n    if (b & 1) Mul(s, a);\n    Mul(a, a);\n    b >>= 1;\n  }\n  return s;\n}\nint fac[100001], inv[100001];\nvoid Init(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n  inv[n] = Ksm(fac[n], kMod - 2);\n  for (int i = n - 1; i >= 0; i--) inv[i] = mul(inv[i + 1], i + 1);\n}\nint C(int x, int y) {\n  if (x < y || y < 0) return 0;\n  return mul(fac[x], inv[x - y], inv[y]);\n}\nint t, n, k, p, cnt[101][101], dep[101], dp[101], ans;\nstd::vector<int> g[101];\nvoid Dfs(int u, int fa) {\n  cnt[p][dep[u] = dep[fa] + 1]++;\n  for (auto &&v : g[u]) {\n    if (v == fa) continue;\n    Dfs(v, u);\n  }\n}\nvoid Solve(int x) {\n  std::memset(dep, 0, sizeof(dep));\n  std::vector<int> tmp;\n  for (auto &&v : g[x]) {\n    p = v;\n    std::memset(cnt[v], 0, sizeof(cnt[v]));\n    Dfs(v, x);\n    tmp.emplace_back(v);\n  }\n  for (int i = 1; i <= n; i++) {\n    std::memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    for (std::size_t j = 0; j < tmp.size(); j++)\n      for (int l = k; l >= 1; l--) Add(dp[l], mul(cnt[tmp[j]][i], dp[l - 1]));\n    Add(ans, dp[k]);\n  }\n}\nint main(int argc, char const *argv[]) {\n  Read(t);\n  while (t--) {\n    Read(n, k);\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      Read(u, v);\n      g[u].emplace_back(v), g[v].emplace_back(u);\n    }\n    if (k == 2) {\n      std::printf(\"%d\\n\", n * (n - 1) / 2);\n    } else {\n      for (int i = 1; i <= n; i++) Solve(i);\n      std::printf(\"%d\\n\", ans);\n    }\n    ans = 0;\n    for (int i = 1; i <= n; i++) std::vector<int>().swap(g[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong double pi = 3.14159265358979323846;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int p = 1e9 + 7, n, k;\nlong long int dis[101][101];\nvoid dfs(long long int node, long long int par, vector<long long int> v[]) {\n  dis[node][0] = 1;\n  for (auto it : v[node]) {\n    if (it != par) {\n      dfs(it, node, v);\n      for (long long int i = 1; i < n; i++) dis[node][i] += dis[it][i - 1];\n    }\n  }\n}\nlong long int cal(vector<long long int> &temp) {\n  long long int size = temp.size(), ans = 0, i, j;\n  if (size < k) return 0;\n  long long int dp[size + 1][k + 1];\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (i = 1; i <= size; i++) {\n    dp[i][0] = 1;\n    for (long long int j = 1; j <= k; j++) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * temp[i - 1]) % p;\n    }\n  }\n  return dp[size][k];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int count;\n    cin >> n >> k;\n    count = n - 1;\n    vector<long long int> v[n];\n    while (count--) {\n      long long int x, y;\n      cin >> x >> y;\n      x--, y--;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    long long int ans = 0;\n    for (long long int i = 0; i < n; i++) {\n      queue<long long int> q;\n      q.push(i);\n      for (long long int x = 0; x < n; x++)\n        for (long long int y = 0; y < n; y++) dis[x][y] = 0;\n      dfs(i, -1, v);\n      for (long long int x = 0; x < n; x++) {\n        vector<long long int> temp;\n        for (auto it : v[i]) temp.push_back(dis[it][x]);\n        ans = (ans + cal(temp)) % p;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "for _ in range(int(input())):\n    c = input()\n    n, K = map(int, input().split())\n    e = [[] for i in range(n)]\n    for i in range(n-1):\n        t1, t2 = map(int, input().split())\n        t1 -= 1\n        t2 -= 1\n        e[t1].append(t2)\n        e[t2].append(t1)\n        \n    bj = [1]*101\n\n    ans = [0]\n    \n    def dfs(x, depth):\n        bj[x] = 0\n        for i in e[x]:\n            if bj[i]:\n                dfs(i, depth+1)\n                for j in range(n):\n                    a[x][j] += a[i][j]\n        a[x][depth] += 1\n\n        if depth == 0:\n            for i in range(n):\n                f = [0]*(K+1)\n                f[0] = 1\n                for j in e[x]:\n\n                    if bj[j] and a[j][i]:\n                        for k in range(K, 0, -1):\n                            f[k] = (f[k] + f[k-1]*a[j][i]) % 1000000007\n                ans[0] = (ans[0] + f[K]) % 1000000007\n        bj[x] = 1\n\n\n    for i in range(n):\n        a = [[0] * n for j in range(n)]\n        dfs(i, 0)\n    if K == 2:\n        print(n*(n-1)//2)\n    else:\n        print(ans[0]%1000000007)\n"
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\n\nclass SegmentTree:\n    def __init__(self, array):\n        self.n = len(array)\n        self.size = 1\n        while self.size < self.n:\n            self.size *= 2\n        self.func = lambda x, y: x if x[0] < y[0] else y\n        self.default = (10 ** 9, -1)\n        self.data = [self.default] * (2 * self.size)\n        self.process(array)\n    \n    def process(self, array):\n        self.data[self.size: self.size + self.n] = array\n        for i in range(self.size - 1, -1, -1):\n            self.data[i] = self.func(self.data[2 * i], self.data[2 * i + 1])\n    \n    def query(self, alpha, omega):\n        \"\"\"Returns the result of function over the range (inclusive)!\"\"\"\n        if alpha == omega:\n            return self.data[alpha + self.size]\n        res = self.default\n        alpha += self.size\n        omega += self.size + 1\n        while alpha < omega:\n            if alpha & 1:\n                res = self.func(res, self.data[alpha])\n                alpha += 1\n            if omega & 1:\n                omega -= 1\n                res = self.func(res, self.data[omega])\n            alpha >>= 1\n            omega >>= 1\n        return res\n    \n    def update(self, index, value):\n        \"\"\"Updates the element at index to given value!\"\"\"\n        index += self.size\n        self.data[index] = value\n        index >>= 1\n        while index:\n            self.data[index] = self.func(self.data[2 * index], self.data[2 * index + 1])\n            index >>= 1\n\n\nclass LCA:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.n = len(graph)\n        self.euler = []\n        self.first = [-1] * self.n\n        self.st = None\n        self.process(root)\n    \n    def process(self, root):\n        visited, parents, heights = [False] * self.n, [-1] * self.n, [1] * self.n\n        stack = [root]\n        while stack:\n            v = stack[-1]\n            if not visited[v]:\n                visited[v] = True\n                self.euler += [v]\n                if self.first[v] == -1:\n                    self.first[v] = len(self.euler) - 1\n                for u in self.graph[v]:\n                    if not visited[u]:\n                        stack.append(u)\n                        parents[u], heights[u] = v, heights[v] + 1\n            else:\n                self.euler += [parents[stack.pop()]]\n        self.euler = [(heights[k], k) for k in self.euler]\n        self.st = SegmentTree(self.euler)\n    \n    def query(self, x, y):\n        \"\"\"Returns the lowest common ancestor of nodes x and y!\"\"\"\n        p, q = min(self.first[x], self.first[y]), max(self.first[x], self.first[y])\n        return self.st.query(p, q)[1]\n\n\nfrom collections import deque\n\n\ndef bfs(graph, alpha=0):\n    \"\"\"Breadth first search on a graph!\"\"\"\n    n = len(graph)\n    q = deque([alpha])\n    used = [False] * n\n    used[alpha] = True\n    dist, parents = [0] * n, [-1] * n\n    while q:\n        v = q.popleft()\n        for u in graph[v]:\n            if not used[u]:\n                used[u] = True\n                q.append(u)\n                dist[u] = dist[v] + 1\n                parents[u] = v\n    return dist, parents\n\n\ndef shortest_path(graph, alpha, omega):\n    \"\"\"Returns the shortest path between two vertices!\"\"\"\n    used, dist, parents = bfs(graph, alpha)\n    if not used[omega]:\n        return []\n    path = [omega]\n    v = omega\n    while parents[v] != -1:\n        path += [parents[v]]\n        v = parents[v]\n    return path[::-1]\n\n\nmax_n=200\nmod=10 ** 9 + 7\nif 1:\n    max_n = min(max_n, mod - 1)\n    \n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n    \n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n\ndef sumOfProduct(arr, n, k):\n    # Initialising all the values to 0\n    dp = [[0 for x in range(n + 1)] for y in range(n + 1)]\n    cur_sum = 0\n    \n    # For k = 1, the answer will simply\n    # be the sum of all the elements\n    for i in range(1, n + 1):\n        dp[1][i] = arr[i - 1]\n        cur_sum += arr[i - 1]\n    \n    # Filling the table in bottom up manner\n    for i in range(2, k + 1):\n        \n        # To store the elements of the current\n        # row so that we will be able to use this sum\n        # for subsequent values of k\n        temp_sum = 0\n        \n        for j in range(1, n + 1):\n            # We will subtract previously computed value\n            # so as to get the sum of elements from j + 1\n            # to n in the (i - 1)th row\n            cur_sum -= dp[i - 1][j]\n            \n            dp[i][j] = arr[j - 1] * cur_sum\n            dp[i][j] %= mod\n            temp_sum += dp[i][j]\n        cur_sum = temp_sum\n    return cur_sum % mod\n\nfrom random import randint\n    \nfor _ in range(int(input()) if True else 1):\n    ok = input()\n    n, k = map(int, input().split())\n    # a, b = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    # s = input()\n    graph = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        x, y = map(int, input().split())\n        graph[x] += [y]\n        graph[y] += [x]\n    if k == 2:\n        ans = (n * (n-1)) // 2\n        print(ans % mod)\n        continue\n    \n    \n    ans = 0\n    for i in range(1, n+1):\n        count = [[0]*(n+7) for _ in range(n +1)]\n        dist, parents = bfs(graph, i)\n        one = 0\n        for j in range(1, n+1):\n            if dist[j] == 1:one += 1\n            elif dist[j] != 0:\n                x = j\n                while parents[x] != i:\n                    x = parents[x]\n                count[dist[j]][x] += 1\n                \n        for x in count:\n            p = []\n            for y in x:\n                if y:\n                    p+=[y]\n            if len(p) >= k:\n                #print(i,p)\n                ans += sumOfProduct(p, len(p), k)\n                ans %= mod\n        ans += nCr_mod(one, k)\n    \n    print(ans % mod)"
        },
        {
            "language": 3,
            "solution": "\nmod = 1000000007 \n\n# def power(x, m):\n#     if m == 0:\n#         return 1\n#     if m == 1:\n#         return x % mod\n#     if m % 2 == 1:\n#         return x * power(x, m - 1) % mod\n#     tmp = power(x, m // 2)\n#     return tmp * tmp % mod\n\n# def C(k, n):\n#     if k > n:\n#         return 0\n#     return gt[n] * pgt[k] % mod * pgt[n - k] % mod\n\n# def build():\n#     gt[0] = 1\n#     for i in range(1, 101):\n#         gt[i] = gt[i - 1] * i % mod\n#     pgt[100] = power(gt[100], mod - 2)\n#     for i in range(99, -1, -1):\n#         pgt[i] = pgt[i + 1] * (i + 1) % mod\n\ndef min(x, y):\n    if x < y:\n        return x\n    return y\n\ndef solve(m, x):\n    if m < k:\n        return 0\n    f = [[0 for _ in range(k + 1)] for _ in range(m + 1)]\n    f[0][0] = 1\n    # print(m, k, f[m][k], \"ccccc\")\n    for i in range(1, m + 1):\n        for j in range(0, min(k + 1, i + 1)):\n            if j == 0:\n                f[i][j] = 1\n            else:\n                f[i][j] = (f[i - 1][j] + cnt[i] * f[i - 1][j - 1] % mod) % mod\n            # print(i, j)\n    # print(f[m][k], \"ccc\", x)\n    return f[m][k]\n\ndef process(x):\n    # print(x)\n    check[x] = 1\n    res = 0\n    q = []\n    for i in range(len(a[x])):\n        v = a[x][i]\n        check[v] = 1\n        q.append([v, i + 1])\n    # print(q)\n    res = solve(len(a[x]), x)\n    while len(q):\n        cur = []\n        for i in range(len(q)):\n            u = q[i][0]\n            j = q[i][1]\n            cnt[j] -= 1\n            for v in a[u]:\n                if check[v] == 0:\n                    cur.append([v, j])\n                    check[v] = 1\n                    cnt[j] += 1\n        # print(cur)\n        q = cur\n        res += solve(len(a[x]), x)\n        # print(cnt[1:(len(a[x]) + 1)], x)\n        res %= mod\n    return res\n\n\nif __name__ == '__main__':\n    test = int(input())\n    # gt = [0 for _ in range(104)]\n    # pgt = [0 for _ in range(104)]\n    # build()\n    for _ in range(test):\n        input()\n        n, k = map(int, input().split())\n        a = [[] for _ in range(n + 1)]\n        \n        for _ in range(n - 1):\n            x, y = map(int, input().split())\n            a[x].append(y)\n            a[y].append(x)\n        \n        ans = 0\n\n        if k == 2:\n            print(n * (n - 1) // 2)\n            continue\n        \n        for x in range(1, n + 1):\n            check = [0 for _ in range(n + 1)]\n            cnt = [1 for _ in range(n + 1)]\n            ans = (ans + process(x)) % mod\n        \n        print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT max3(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <typename T>\nT max4(T a, T b, T c, T d) {\n  return max(max(a, d), max(b, c));\n}\ntemplate <typename T>\nT min3(T a, T b, T c) {\n  return min(a, min(b, c));\n}\ntemplate <typename T>\nT min4(T a, T b, T c, T d) {\n  return min(min(a, d), min(b, c));\n}\ntemplate <typename T>\nT binex(T a, T b, T mod) {\n  T ans = 1;\n  a %= mod;\n  while (b > 0) {\n    if (b & 1) {\n      ans *= a;\n      ans %= mod;\n    }\n    a *= a;\n    a %= mod;\n    b >>= 1;\n  }\n  return ans;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, multiset<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T, class Q>\nostream& operator<<(ostream& os, pair<T, Q> a) {\n  os << \"| \";\n  os << a.first << \", \" << a.second << \" \";\n  return os << \"|\";\n}\ntemplate <class P, class Q, class T>\nostream& operator<<(ostream& os, tuple<P, Q, T> a) {\n  os << \"| \" << (get<0>(a)) << \", \" << (get<1>(a)) << \", \" << (get<2>(a))\n     << \"|\";\n  return os;\n}\nvoid precomp() {}\nvoid solve() {\n  int64_t n, k;\n  cin >> n >> k;\n  vector<vector<int64_t>> edges(n + 1);\n  for (int64_t i = 0; i < n - 1; i++) {\n    int64_t a, b;\n    cin >> a >> b;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << ((n * (n - 1)) / 2) % int64_t(1000000007) << \"\\n\";\n    return;\n  }\n  int64_t fans = 0;\n  for (int64_t i = 1; i <= n; i++) {\n    int64_t root = i;\n    vector<bool> vis(n + 1, false);\n    vis[root] = true;\n    vector<vector<int64_t>> cnt;\n    int64_t maxaa = 0;\n    for (auto x : edges[root]) {\n      queue<int64_t> sto;\n      sto.push(x);\n      vis[x] = true;\n      vector<int64_t> depth(n + 1, -1);\n      int64_t maxa = 0;\n      depth[x] = 0;\n      while (!sto.empty()) {\n        int64_t te = sto.front();\n        sto.pop();\n        vis[te] = true;\n        for (auto x : edges[te]) {\n          if (vis[x]) {\n            continue;\n          }\n          sto.push(x);\n          depth[x] = depth[te] + 1;\n          maxa = depth[x];\n        }\n      }\n      maxaa = max(maxaa, maxa);\n      vector<int64_t> temp(maxa + 1);\n      for (int64_t i = 1; i <= n; i++) {\n        if (depth[i] != -1) {\n          temp[depth[i]]++;\n        }\n      }\n      cnt.push_back(temp);\n    }\n    for (int64_t i = 0; i < cnt.size(); i++) {\n      cnt[i].resize(maxaa + 1);\n    }\n    int64_t ans = 0;\n    for (int64_t i = 0; i < maxaa + 1; i++) {\n      vector<vector<int64_t>> dp(cnt.size(), vector<int64_t>(k + 1));\n      dp[0][0] = 1;\n      dp[0][1] = cnt[0][i];\n      for (int64_t j = 0; j < cnt.size() - 1; j++) {\n        for (int64_t l = 0; l <= k; l++) {\n          dp[j + 1][l] += dp[j][l];\n          dp[j + 1][l] %= int64_t(1000000007);\n          if (l >= k) {\n            continue;\n          }\n          dp[j + 1][l + 1] += (dp[j][l] * cnt[j + 1][i]) % int64_t(1000000007);\n          dp[j + 1][l + 1] %= int64_t(1000000007);\n        }\n      }\n      ans += dp[cnt.size() - 1][k];\n      ans %= int64_t(1000000007);\n    }\n    fans += ans;\n    fans %= int64_t(1000000007);\n  }\n  cout << fans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int64_t T;\n  cin >> T;\n  precomp();\n  for (int64_t I = 1; I <= T; I++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ar[205];\nchar ch[205];\nint n, m, ii, k;\nlong long fact[205], inv[205];\nlong long bigmod(long long e, long long x) {\n  if (!x) return 1;\n  long long p = bigmod(e, x / 2);\n  p = (p * p) % 1000000007;\n  if (x % 2) p = (p * e) % 1000000007;\n  return p;\n}\nvoid fact_cal() {\n  fact[0] = 1;\n  inv[0] = 1;\n  for (int i = 1; i <= 205 - 3; i++) {\n    fact[i] = (fact[i - 1] * i) % 1000000007;\n  }\n  inv[205 - 3] = bigmod(fact[205 - 3], 1000000007 - 2);\n  for (int i = 205 - 4; i >= 1; i--)\n    inv[i] = (inv[i + 1] * (i + 1)) % 1000000007;\n}\nlong long nCr(int nn, int r) {\n  if (nn < r) return 0;\n  long long re = fact[nn];\n  re = re * (inv[r] * inv[nn - r] % 1000000007) % 1000000007;\n  return re;\n}\nint add(int a, int b) {\n  a += b;\n  if (a >= 1000000007) a -= 1000000007;\n  return a;\n}\nlong long mul(long long a, long long b) {\n  a *= b;\n  if (a >= 1000000007) a %= 1000000007;\n  return a;\n}\nvector<int> g[105];\nint dist[105][105];\nlong long dp[105][105];\nint vis[105][105];\nvector<int> vv;\nlong long func(int i, int koy) {\n  if (i == m) return koy == k;\n  if (koy == k) return 1;\n  if (vis[i][koy] == ii) return dp[i][koy];\n  vis[i][koy] = ii;\n  long long re = func(i + 1, koy);\n  re = add(re, mul(vv[i], func(i + 1, koy + 1)));\n  return dp[i][koy] = re;\n}\nvoid dfs(int u, int p = -1) {\n  dist[u][0]++;\n  for (int v : g[u]) {\n    if (v == p) continue;\n    dfs(v, u);\n    for (int i = 0; i <= n; i++) {\n      dist[u][i + 1] += dist[v][i];\n    }\n  }\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int re = 0;\n  for (int i = 0; i <= n; i++) {\n    memset(dist, 0, sizeof(dist));\n    dfs(i);\n    for (int j = 0; j <= n + 2; j++) {\n      int nn = 0;\n      vv.clear();\n      for (int v : g[i]) {\n        if (dist[v][j]) {\n          vv.push_back(dist[v][j]);\n        }\n      }\n      ii++;\n      m = vv.size();\n      re = add(re, func(0, 0));\n    }\n  }\n  if (k == 2) {\n    printf(\"%lld\\n\", nCr(n, 2));\n  } else\n    printf(\"%d\\n\", re);\n  for (int i = 1; i <= n; i++) g[i].clear();\n}\nint main() {\n  int t = 1;\n  fact_cal();\n  scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e2 + 5;\nconst int mod = 1e9 + 7;\nlong long dp[M][M];\nint k, n, freq[M][M];\nvector<int> adj[M], dpV;\nvoid DFS(int x, int p) {\n  int i;\n  freq[x][0] = 1;\n  for (int y : adj[x]) {\n    if (p ^ y) {\n      DFS(y, x);\n      for (i = 1; i < n; i++) freq[x][i] += freq[y][i - 1];\n    }\n  }\n}\nlong long DP(int cur, int cnt) {\n  if (cnt > k) return 0;\n  if (cur == (int)dpV.size()) return (cnt == k);\n  long long &ans = dp[cur][cnt];\n  if (ans > -1) return ans;\n  ans = DP(cur + 1, cnt);\n  ans += dpV[cur] * DP(cur + 1, cnt + 1);\n  return ans %= mod;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long ans;\n  int i, j, t, x, y;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (i = 1; i <= n; i++) adj[i].clear();\n    for (i = 1; i < n; i++) {\n      cin >> x >> y;\n      adj[x].emplace_back(y);\n      adj[y].emplace_back(x);\n    }\n    if (k == 2)\n      ans = (1ll * n * (n - 1)) / 2;\n    else {\n      ans = 0;\n      for (i = 1; i <= n; i++) {\n        memset(freq, 0, sizeof(freq));\n        DFS(i, 0);\n        for (j = 0; j < n - 1; j++) {\n          dpV.clear();\n          for (int it : adj[i]) {\n            if (freq[it][j]) dpV.emplace_back(freq[it][j]);\n          }\n          if ((int)dpV.size() >= k) {\n            memset(dp, -1, sizeof(dp));\n            ans += DP(0, 0);\n            if (ans >= mod) ans -= mod;\n          }\n        }\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nint n, d[N], k, vis[N][N], dp[N][N], id, mod = 1e9 + 7, cnt[N][N];\nvector<int> adj[N], v;\nvoid dfs(int node, int par, int parCh) {\n  if (parCh) {\n    cnt[parCh][d[node]]++;\n  }\n  for (auto ch : adj[node]) {\n    if (ch == par) continue;\n    d[ch] = d[node] + 1;\n    if (node == par)\n      dfs(ch, node, ch);\n    else\n      dfs(ch, node, parCh);\n  }\n}\nint solve(int i, int rem) {\n  if (!rem) return 1;\n  if (i == (int)v.size()) return 0;\n  if (vis[i][rem] == id) return dp[i][rem];\n  vis[i][rem] = id;\n  int ans = solve(i + 1, rem);\n  if (v[i]) ans = (ans + 1ll * v[i] * solve(i + 1, rem - 1)) % mod;\n  return dp[i][rem] = ans;\n}\nvoid clear() {\n  for (int i = 0; i <= n; i++) {\n    adj[i].clear();\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      clear();\n      continue;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      memset(d, 0, sizeof(d));\n      memset(cnt, 0, sizeof(cnt));\n      dfs(i, i, 0);\n      for (int ds = 1; ds <= n; ds++) {\n        v.clear();\n        for (int ch = 1; ch <= n; ch++) {\n          v.push_back(cnt[ch][ds]);\n        }\n        id++;\n        ans = (ans + solve(0, k)) % mod;\n      }\n    }\n    cout << ans << '\\n';\n    clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 7;\nconst long long MOD = 1E9 + 7;\nlong long res = 0, fact[N], rev[N], dp[N][N];\nvector<int> G[N];\nint timer = 0, cnt[N], tin[N], depth[N], sum[N];\nvoid add(int pos, int val) {\n  if (tin[pos] != timer) {\n    tin[pos] = timer;\n    cnt[pos] = 0;\n  }\n  cnt[pos] += val;\n}\nint get(int pos) {\n  if (tin[pos] != timer) {\n    tin[pos] = timer;\n    cnt[pos] = 0;\n  }\n  return cnt[pos];\n}\nvoid dfs(int v, int par) {\n  depth[v] = depth[par] + 1;\n  add(depth[v], 1);\n  for (int to : G[v]) {\n    if (to == par) continue;\n    dfs(to, v);\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  res = 0;\n  for (int root = 1; root <= n; ++root) {\n    if (G[root].size() < k) continue;\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 1; j <= k; ++j) dp[i][j] = 0;\n      dp[i][0] = 1;\n      sum[i] = 0;\n    }\n    depth[root] = 0;\n    for (int v : G[root]) {\n      ++timer;\n      dfs(v, root);\n      for (int dep = 1; dep <= n; ++dep) {\n        if (get(dep) == 0) continue;\n        for (int ct = min(k - 1, sum[dep]); ct >= 0; --ct) {\n          dp[dep][ct + 1] = (dp[dep][ct + 1] + dp[dep][ct] * get(dep)) % MOD;\n        }\n        sum[dep] = min(sum[dep] + 1, k);\n      }\n    }\n    for (int dep = 1; dep <= n; ++dep) res = (res + dp[dep][k]) % MOD;\n  }\n  if (k == 2) {\n    res = long long(n) * (n - 1) / 2 % MOD;\n  }\n  if (k == 1) {\n    res = n;\n  }\n  cout << res << endl;\n  for (int i = 1; i <= n; ++i) G[i].clear();\n}\nlong long binpow(long long x, int power) {\n  long long mult = x % MOD;\n  x = 1;\n  while (power) {\n    if (power & 1) x = x * mult % MOD;\n    mult = mult * mult % MOD;\n    power = power >> 1;\n  }\n  return x;\n}\nint main() {\n  fact[0] = rev[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fact[i] = fact[i - 1] * i % MOD;\n    rev[i] = binpow(fact[i], MOD - 2);\n  }\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\nint t;\nint n, k;\nvector<int> v[100 + 1];\nll dp[100 + 1][100 + 1];\nbool vst[100 + 1];\nll ans;\nvoid dfs(int now, int cnt, int root) {\n  vst[now] = true;\n  dp[root][now] = cnt;\n  for (auto there : v[now]) {\n    if (!vst[there]) {\n      dfs(there, cnt + 1, root);\n    }\n  }\n}\nll c[128][128];\nll add(ll x, ll y) { return (x + y) % (ll)1000000007; }\nll mul(ll x, ll y) { return x * y % (ll)1000000007; }\nll rundp(vector<int>& arr, int m, int k) {\n  memset(c, 0, sizeof c);\n  c[0][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j <= k; j++) {\n      c[i + 1][j] = add(c[i + 1][j], c[i][j]);\n      c[i + 1][j + 1] = add(c[i + 1][j + 1], mul(c[i][j], arr[i]));\n    }\n  }\n  return c[m][k];\n}\nvoid solve(int now) {\n  if (v[now].size() < k) return;\n  memset(vst, false, sizeof vst);\n  memset(dp, 0, sizeof dp);\n  vst[now] = true;\n  for (auto there : v[now]) {\n    dfs(there, 1, there);\n  }\n  map<int, vector<int>> m;\n  for (auto there : v[now]) {\n    map<int, int> tmp;\n    for (int i = 1; i <= n; i++) {\n      if (dp[there][i] > 0) tmp[dp[there][i]]++;\n    }\n    for (auto it = tmp.begin(); it != tmp.end(); it++) {\n      m[it->first].push_back(it->second);\n    }\n  }\n  for (auto it = m.begin(); it != m.end(); it++) {\n    if (it->second.size() >= k) {\n      ans = (ans + rundp(it->second, it->second.size(), k)) % (ll)1000000007;\n    }\n  }\n}\nint comb[100 + 1][100 + 1];\nint pascal(int i, int j) {\n  if (comb[i][j] != 0) {\n    return comb[i][j];\n  }\n  if (j == 0 || j == i) {\n    comb[i][j] = 1;\n    return comb[i][j];\n  }\n  return comb[i][j] =\n             (pascal(i - 1, j) + pascal(i - 1, j - 1)) % (ll)1000000007;\n}\nint main(void) {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n - 1; i++) {\n      int a, b;\n      cin >> a >> b;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    ans = 0;\n    for (int i = 1; i <= n; i++) {\n      solve(i);\n    }\n    if (k == 2) {\n      ans = pascal(n, k);\n    }\n    cout << ans << \"\\n\";\n    for (int i = 1; i <= n; i++) {\n      v[i].clear();\n      vector<int>().swap(v[i]);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <typename T1, typename T2>\ninline void chkmin(T1& x, const T2& y) {\n  if (y < x) x = y;\n}\ntemplate <typename T1, typename T2>\ninline void chkmax(T1& x, const T2& y) {\n  if (x < y) x = y;\n}\nmt19937 rnd(time(0));\nconst int MAXN = 10e3 + 228;\nvector<int> g[MAXN];\nint d[MAXN];\nint mod = 1000000007;\nint mul(int a, int b) { return 1ll * a * b % mod; }\nint add(int a, int b) {\n  if (a + b >= mod) return a + b - mod;\n  return a + b;\n}\nint sub(int a, int b) {\n  if (a - b < 0) return a - b + mod;\n  return a - b;\n}\nint binpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nint inv(int x) { return binpow(x, mod - 2); }\nint fact[MAXN];\nint rfact[MAXN];\nint cnk(int n, int k) {\n  if (n < 0 || k > n) return 0;\n  return mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\nint tpc[MAXN];\nvoid dfs(int v, int p, int tp) {\n  d[v] = d[p] + 1;\n  tpc[v] = tp;\n  for (int i : g[v]) {\n    if (i != p) {\n      int ntp = tp;\n      if (v == p) ntp = i;\n      dfs(i, v, ntp);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout.precision(20), cout.setf(ios::fixed);\n  fact[0] = 1;\n  for (int i = 1; i < MAXN; ++i) fact[i] = mul(fact[i - 1], i);\n  rfact[MAXN - 1] = inv(fact[MAXN - 1]);\n  for (int i = MAXN - 2; i >= 0; --i) rfact[i] = mul(rfact[i + 1], i + 1);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (int i = 0; i < n - 1; ++i) {\n      int a, b;\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      fill(d, d + n + 1, 0);\n      dfs(i, i, -1);\n      for (int dd = 2; dd <= n; ++dd) {\n        vector<int> cnts(n + 1);\n        for (int j = 1; j <= n; ++j) {\n          if (d[j] == dd) {\n            cnts[tpc[j]]++;\n          }\n        }\n        vector<int> itms;\n        for (int i : cnts) {\n          if (i) itms.push_back(i);\n        }\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int j : itms) {\n          vector<int> ndp = dp;\n          for (int gg = 0; gg + 1 <= n; ++gg) {\n            ndp[gg + 1] = add(ndp[gg + 1], mul(dp[gg], j));\n          }\n          swap(dp, ndp);\n        }\n        ans = add(ans, dp[k]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict as dd\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    input()\n    n, k = map(int, input().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        edges[u].append(v)\n        edges[v].append(u)\n    if k == 2:\n        print(n * (n - 1) // 2)\n        return\n    \n    global ans\n    ans = 0\n    def dfs(pos, bpos):\n        ret = dd(int)\n        ret[0] = 1\n        if bpos == -1:\n            lst = dd(list)\n        for npos in edges[pos]:\n            if npos == bpos:\n                continue\n            x = dfs(npos, pos)\n            for k2, v in x.items():\n                k2 += 1\n                ret[k2] += v\n                if bpos == -1:\n                    lst[k2].append(v)\n        if bpos == -1:\n            return lst\n        else:\n            return ret\n    for i in range(n):\n        lst = dfs(i, -1)\n        for k2, v in lst.items():\n            if len(v) < k:\n                continue\n            dp = [0] * (k + 1)\n            dp[0] = 1\n            for i in v:\n                for j in range(k, 0, -1):\n                    dp[j] += dp[j - 1] * i\n                    dp[j] %= MOD\n            ans += dp[k]\n            ans %= MOD\n    print(ans % MOD)\n    \nfor _ in range(int(input())):\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  int ch = getchar(), f = 1;\n  long long x = 0;\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  return f * x;\n}\nint solve();\nint main() {\n  for (int t = read(); t--; solve())\n    ;\n  return 0;\n}\nconst int mod = 1e9 + 7;\nvector<vector<int>> e(105);\nint cnt[105];\nlong long sum[105][105];\nlong long fac[105], inv[105];\nlong long qpow(long long x, long long k) {\n  long long ans = 1;\n  for (; k; k >>= 1, x = x * x % mod) {\n    if (k & 1) ans = ans * x % mod;\n  }\n  return ans;\n}\nvoid dfs(int x, int fa, int dep) {\n  cnt[dep]++;\n  for (auto t : e[x]) {\n    if (t == fa) continue;\n    dfs(t, x, dep + 1);\n  }\n}\nlong long C(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint n, k;\nint solve() {\n  n = read(), k = read();\n  fac[0] = inv[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    fac[i] = fac[i - 1] * i % mod, inv[i] = qpow(fac[i], mod - 2);\n  if (k == 1) {\n    for (int i = 1; i < n; ++i) read(), read();\n    cout << n << endl;\n    return 0;\n  }\n  if (k == 2) {\n    for (int i = 1; i < n; ++i) read(), read();\n    cout << 1ll * n * (n - 1) / 2 % mod << endl;\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) e[i].clear();\n  for (int i = 1; i < n; ++i) {\n    int u = read(), v = read();\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  long long ans = 0;\n  memset(sum, 0, sizeof sum);\n  for (int i = 1; i <= n; ++i) {\n    memset(sum, 0, sizeof sum);\n    for (int i = 1; i <= n; ++i) sum[i][0] = 1;\n    for (auto t : e[i]) {\n      memset(cnt, 0, sizeof cnt);\n      dfs(t, i, 1);\n      for (int d = 1; d <= n; ++d) {\n        for (int j = k; j >= 1; --j) {\n          sum[d][j] += sum[d][j - 1] * cnt[d] % mod;\n          sum[d][j] %= mod;\n        }\n      }\n    }\n    for (int d = 1; d <= n; ++d) ans += sum[d][k], ans %= mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class ACMIND\n{\n    static FastReader scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 2_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null,null,\"_\",1<<27)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n    static int n,k, freq[][];\n    static ArrayList<Integer> adj[];\n    static void solve() throws IOException {\n        scan = new FastReader();\n        pw = new PrintWriter(System.out, true);\n        StringBuilder sb = new StringBuilder();\n\n        //pa(\"ncr\", ncr);\n        int t = ni();\n        while (t-->0) {\n            n = ni();\n            k = ni();\n            adj = new ArrayList[n+1];\n            for(int i=1;i<=n;i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for(int i=1;i<n;i++) {\n                int u = ni(), v = ni();\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            long ans = 0;\n            for(int i=1;i<=n;i++) {\n                freq = new int[n+1][n+1];\n                dfs(i, i);\n                // pa(\"freq\", freq);\n                int cc = adj[i].size();\n                for(int dis=1;dis<n;++dis) {\n                    long dp[][] = new long[cc+1][k+1];\n                    for(int j=0;j<=cc;++j) {\n                        dp[j][0] = 1;\n                    }\n                    for(int j=1;j<=cc;++j) {\n                        int child = adj[i].get(j-1);\n                        for(int left=1;left<=k;++left) {\n                            dp[j][left] = dp[j-1][left] + 1L * freq[child][dis-1] * dp[j-1][left-1];\n                            dp[j][left] %= MOD;\n                        }\n                    }\n\n                    ans+=dp[cc][k];\n                    if(ans>=MOD) ans-=MOD;\n                }\n            }\n\n            if(k==2) {\n                pl((n*(n-1))/2);\n            }\n            else {\n                pl(ans);\n            }\n        }\n\n        pw.flush();\n        pw.close();\n    }\n\n    static void dfs(int v, int par) {\n        // pl(\"in dfs v: \"+v+\" par: \"+par);\n        freq[v][0] = 1;\n        for(int e : adj[v]) {\n            if(e!=par) {\n                dfs(e, v);\n                for(int i=1;i<=n;i++) {\n                    // pl(\"e: \"+e + \" freq[e][i-1] : \"+freq[e][i-1]);\n                    freq[v][i]+=freq[e][i-1];\n                }\n            }\n        }\n    }\n\n    static void assert_in_range(String varName, int n, int l, int r) {\n        if (n >=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n    static void assert_in_range(String varName, long n, long l, long r) {\n        if (n>=l && n<=r) return;\n        System.out.println(varName + \" is not in range. Actual: \"+n+\" l : \"+l+\" r: \"+r);\n        System.exit(1);\n    }\n\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Set<Object> set)\n    {\n        pl(arrayName+\" : \");\n        for(Object o : set)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class FastReader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[1000000];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mxN = 1e3 + 5, mod = 1e9 + 7, LOG = 20;\nint n, k, cnt[mxN], ans;\nint dp[mxN][mxN];\nvector<int> adj[mxN];\nvoid calc(int v, int p, int dep = 1) {\n  ++cnt[dep];\n  for (auto to : adj[v]) {\n    if (to != p) calc(to, v, dep + 1);\n  }\n}\nvoid get(int node) {\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) dp[i][j] = 0;\n  }\n  for (int i = 1; i <= n; ++i) dp[0][i] = 1;\n  int now = 0;\n  for (auto to : adj[node]) {\n    calc(to, node);\n    ++now;\n    for (int d = 1; d <= n; ++d) {\n      for (int j = now; j > 0; j--)\n        dp[j][d] = (dp[j][d] + dp[j - 1][d] * 1ll * cnt[d] % mod) % mod;\n    }\n    for (int i = 1; i <= n; ++i) cnt[i] = 0;\n  }\n  for (int i = 1; i <= n; ++i) ans = (ans + dp[k][i]) % mod;\n}\nvoid solve() {\n  cin >> n >> k;\n  ans = 0;\n  for (int i = 1; i <= n; ++i) adj[i].clear();\n  for (int i = 1, u, v; i < n; ++i) {\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << (n * 1ll * (n - 1) / 2) % mod;\n    return;\n  }\n  for (int c = 1; c <= n; ++c) {\n    get(c);\n  }\n  cout << ans;\n}\nint main() {\n  ios ::sync_with_stdio(false), cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long T, n, k, x, y, num[120][120], f[120][120];\nstd::vector<long long> g[120];\nstd::vector<long long> a;\nvoid dfs(long long u, long long fa) {\n  num[u][0] = 1;\n  for (long long i = 0; i < (long long)g[u].size(); i++) {\n    long long v = g[u][i];\n    if (v == fa) continue;\n    dfs(v, u);\n    for (long long j = 1; j <= n; j++) num[u][j] += num[v][j - 1];\n  }\n}\nsigned main() {\n  cin >> T;\n  while (T--) {\n    cin >> n >> k;\n    long long ans = 0;\n    for (long long i = 1; i < n; i++)\n      cin >> x >> y, g[x].push_back(y), g[y].push_back(x);\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      for (long long i = 1; i <= n; i++) g[i].clear();\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      dfs(i, 0);\n      for (long long j = 1; j <= n; j++) {\n        for (long long l = 0; l < (long long)g[i].size(); l++)\n          a.push_back(num[g[i][l]][j - 1]);\n        f[0][0] = 1;\n        for (long long x = 1; x <= (long long)a.size(); x++) {\n          f[x][0] = 1;\n          for (long long y = 1; y <= x; y++)\n            f[x][y] = (f[x - 1][y] + f[x - 1][y - 1] * a[x - 1] % 1000000007) %\n                      1000000007;\n        }\n        ans = (ans + f[a.size()][k]) % 1000000007;\n        for (long long x = 1; x <= (long long)a.size(); x++)\n          for (long long y = 1; y <= x; y++) f[x][y] = 0;\n        a.clear();\n      }\n      for (long long j = 1; j <= n; j++)\n        for (long long l = 0; l <= n; l++) num[j][l] = 0;\n    }\n    cout << ans << '\\n';\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 1; i <= n; i++)\n      for (long long j = 0; j <= n; j++) num[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long oo = 1e18;\nconst long double eps = 1e-9;\nconst string yes = \"YES\";\nconst string no = \"NO\";\nconst long double PI = acos(-1.0);\nvoid io(long long x) {\n  if (!x) {\n    freopen(\n        \"1551f\"\n        \".inp\",\n        \"r\", stdin);\n    return;\n  }\n  if (x == 1) {\n    freopen(\n        \"1551f\"\n        \".inp\",\n        \"r\", stdin);\n    freopen(\n        \"1551f\"\n        \".out\",\n        \"w\", stdout);\n    return;\n  }\n  freopen(\n      \"1551f\"\n      \".out\",\n      \"w\", stdout);\n}\nlong long n, k;\nconst long long N = 105;\nvector<long long> g[N];\nlong long dp[N][N];\nvector<long long> cnt(N);\nconst long long MOD = 1e9 + 7;\nlong long fast_pow(long long a, long long b) {\n  long long res = 1;\n  for (; b; b /= 2) {\n    if (b & 1) {\n      ((res *= a) %= MOD);\n      b--;\n    }\n    ((a *= a) %= MOD);\n  }\n  return res;\n}\nlong long inv(long long x) { return fast_pow(x, MOD - 2); }\nvoid add(long long &a, long long b) { (a += b) %= MOD; }\nvoid sub(long long &a, long long b) { (a -= b - MOD) %= MOD; }\nvoid mul(long long &a, long long b) { (a *= b) %= MOD; }\nvoid div(long long &a, long long b) { (a *= inv(b)) %= MOD; }\nvoid init(long long x) {\n  for (long long i = 0; i <= x; i++) {\n    g[i].clear();\n  }\n}\nvoid dfs(long long u, long long pre, long long d, vector<long long> &cnt) {\n  cnt[d + 1]++;\n  for (long long v : g[u]) {\n    if (v ^ pre) dfs(v, u, d + 1, cnt);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  init(n);\n  for (long long i = 1; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << (n * (n - 1)) / 2 << '\\n';\n    return;\n  }\n  long long ans = 0;\n  for (long long u = 1; u <= n; u++) {\n    for (long long i = 0; i <= n; i++) {\n      for (long long j = 0; j <= n; j++) {\n        dp[i][j] = 0;\n        dp[0][j] = 1;\n      }\n    }\n    for (long long v : g[u]) {\n      for (long long i = 0; i <= n; i++) {\n        cnt[i] = 0;\n      }\n      dfs(v, u, 0, cnt);\n      for (long long i = k; i; i--) {\n        for (long long d = 1; d <= n; d++) {\n          add(dp[i][d], (dp[i - 1][d] * cnt[d]) % MOD);\n        }\n      }\n    }\n    for (long long d = 1; d <= n; d++) {\n      add(ans, dp[k][d]);\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long test_case = 1;\n  cin >> test_case;\n  for (long long tt = 1; tt <= test_case; tt++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\n\nfrom collections import deque\n\ndef bfs(graph, alpha=0):\n    \"\"\"Breadth first search on a graph!\"\"\"\n    n = len(graph)\n    q = deque([alpha])\n    used = [False] * n\n    used[alpha] = True\n    dist, parents = [0] * n, [-1] * n\n    while q:\n        v = q.popleft()\n        for u in graph[v]:\n            if not used[u]:\n                used[u] = True\n                q.append(u)\n                dist[u] = dist[v] + 1\n                parents[u] = v\n    return dist, parents\n\nfor _ in range(int(input()) if True else 1):\n    empty = input()\n    n, k = map(int, input().split())\n    # a, b = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    # s = input()\n    mod = 10**9 + 7\n    \n    graph = [[] for i in range(n + 1)]\n    for __ in range(n-1):\n        x, y = map(int, input().split())\n        graph[x] += [y]\n        graph[y] += [x]\n\n    if k == 2:\n        print((n * (n - 1)) // 2)\n        continue\n        \n    ans = 0\n    for root in range(1, n + 1):\n        dist, parents = bfs(graph, root)\n        check = [[0]*(n + 1) for p in range(n+1)]\n        for i in range(1, n + 1):\n            if i == root: continue\n            x = i\n            while parents[x] != root:\n                x = parents[x]\n            check[dist[i]][x] += 1\n        \n        for b in check:\n            a = [x for x in b if x]\n            if len(a) < k: continue\n            # dp[i] = sum of every i elements\n            dp = [0] * (k + 1)\n            dp[0] = 1\n            for i in range(len(a)):\n                dp2 = [0] * (k + 1)\n                dp2[0] = 1\n                for j in range(1, k + 1):\n                    dp2[j] = (dp[j] + dp[j-1] * a[i]) % mod\n                dp = list(dp2)\n            ans = (ans + dp[-1]) % mod\n    \n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\nostream& operator<<(ostream& out, const pair<A, B>& p) {\n  return out << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& v) {\n  out << \"[\";\n  for (int i = 0; i < v.size(); ++i) {\n    if (i) out << \", \";\n    out << v[i];\n  }\n  return out << \"]\";\n}\nconst int N = 106;\nint n, k;\nconst long long MOD = 1e9 + 7;\nlong long mul(long long o1, long long o2) { return o1 * o2 % MOD; }\nvector<int> adj[N];\nvector<int> dis[N];\nvoid init() {\n  for (int i = (0); i < (n); ++i) {\n    vector<int>().swap(adj[i]);\n    vector<int>().swap(dis[i]);\n    dis[i].resize(N);\n  }\n}\nvector<int> cnt;\nlong long getDP(int sub) {\n  long long dp[sub + 5][k + 5];\n  for (int i = (0); i < (sub + 2); ++i) {\n    for (int j = (0); j < (k + 1); ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (int i = (0); i < (sub); ++i) {\n    for (int j = 0; j <= k; ++j) {\n      dp[i + 1][j] += dp[i][j];\n      dp[i + 1][j] %= MOD;\n      dp[i + 1][j + 1] += mul(dp[i][j], cnt[i]);\n      dp[i + 1][j + 1] %= MOD;\n    }\n  }\n  return dp[sub][k];\n}\nvoid sol() {\n  cin >> n >> k;\n  for (int i = (0); i < (n); ++i) {\n    dis[i].resize(n);\n  }\n  for (int i = (1); i < (n); ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  long long ans = 0;\n  if (k == 2) {\n    ans = (1ll * n * (n - 1) / 2) % MOD;\n  } else {\n    bool vis[n];\n    for (int center = (0); center < (n); ++center) {\n      for (int i = (0); i < (n); ++i) {\n        vis[i] = false;\n      }\n      vis[center] = true;\n      vector<pair<int, int> > layer;\n      vector<int>(n).swap(cnt);\n      int sz = adj[center].size();\n      for (int i = (0); i < (sz); ++i) {\n        vis[adj[center][i]] = true;\n        layer.emplace_back(i, adj[center][i]);\n        cnt[i] = 1;\n      }\n      while (!layer.empty()) {\n        ans += getDP(sz);\n        ans %= MOD;\n        vector<pair<int, int> > next_layer;\n        for (pair<int, int> e : layer) {\n          --cnt[e.first];\n          for (int to : adj[e.second]) {\n            if (vis[to]) continue;\n            ++cnt[e.first];\n            next_layer.emplace_back(e.first, to);\n            vis[to] = true;\n          }\n        }\n        swap(next_layer, layer);\n        vector<pair<int, int> >().swap(next_layer);\n      }\n    }\n  }\n  cout << ans << endl;\n  init();\n}\nint main(int argc, char const* argv[]) {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  for (; t; --t) {\n    sol();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MulModL(long long B, long long P, long long M) {\n  long long R = 0;\n  while (P > 0) {\n    if ((P & 1ll) == 1) {\n      R = (R + B);\n      if (R >= M) R -= M;\n    }\n    P >>= 1ll;\n    B = (B + B);\n    if (B >= M) B -= M;\n  }\n  return R;\n}\nlong long MulModD(long long B, long long P, long long M) {\n  long long I = ((long double)B * (long double)P / (long double)M);\n  long long R = B * P - M * I;\n  R = (R % M + M) % M;\n  return R;\n}\nlong long BigMod(long long B, long long P, long long M) {\n  long long R = 1;\n  while (P > 0) {\n    if (P % 2 == 1) {\n      R = (R * B) % M;\n    }\n    P /= 2;\n    B = (B * B) % M;\n  }\n  return R;\n}\nlong long BigModML(long long B, long long P, long long M) {\n  long long R = 1;\n  while (P > 0) {\n    if (P % 2 == 1) {\n      R = MulModL(R, B, M);\n    }\n    P /= 2;\n    B = MulModL(B, B, M);\n  }\n  return R;\n}\ntemplate <class T1>\nvoid deb(T1 e1) {\n  cerr << e1 << \"\\n\";\n}\ntemplate <class T1, class T2>\nvoid deb(T1 e1, T2 e2) {\n  cerr << e1 << \" \" << e2 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3>\nvoid deb(T1 e1, T2 e2, T3 e3) {\n  cerr << e1 << \" \" << e2 << \" \" << e3 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid deb(T1 e1, T2 e2, T3 e3, T4 e4) {\n  cerr << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid deb(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5) {\n  cerr << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5, class T6>\nvoid deb(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5, T6 e6) {\n  cerr << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \" \" << e6\n       << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5, class T6, class T7>\nvoid deb(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5, T6 e6, T7 e7) {\n  cerr << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \" \" << e6\n       << \" \" << e7 << \"\\n\";\n}\ntemplate <class T1>\nvoid output(T1 e1) {\n  cout << e1 << \"\\n\";\n}\ntemplate <class T1, class T2>\nvoid output(T1 e1, T2 e2) {\n  cout << e1 << \" \" << e2 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3>\nvoid output(T1 e1, T2 e2, T3 e3) {\n  cout << e1 << \" \" << e2 << \" \" << e3 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid output(T1 e1, T2 e2, T3 e3, T4 e4) {\n  cout << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid output(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5) {\n  cout << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5, class T6>\nvoid output(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5, T6 e6) {\n  cout << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \" \" << e6\n       << \"\\n\";\n}\ntemplate <class T1, class T2, class T3, class T4, class T5, class T6, class T7>\nvoid output(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5, T6 e6, T7 e7) {\n  cout << e1 << \" \" << e2 << \" \" << e3 << \" \" << e4 << \" \" << e5 << \" \" << e6\n       << \" \" << e7 << \"\\n\";\n}\ntemplate <class T>\nT GCD(T a, T b) {\n  T b1;\n  while (b > 0) {\n    b1 = b;\n    b = a % b;\n    a = b1;\n  }\n  return a;\n}\ntemplate <class T>\nT LCM(T a, T b) {\n  return (a * b) / GCD(a, b);\n}\nconst int MOD = 1000000007;\nconst int MAX = 105;\nvector<vector<int> > g;\nvector<long long> dp;\nvector<vector<int> > cnt;\nint nCr[MAX][MAX];\nvoid precal() {\n  nCr[0][0] = 1;\n  for (int i = 0; i < int(MAX); i++) nCr[i][0] = nCr[i][i] = 1;\n  for (int i = 1; i < MAX; i++) {\n    for (int j = 1; j < i; j++) {\n      nCr[i][j] = nCr[i - 1][j - 1] + nCr[i - 1][j];\n      if (nCr[i][j] >= MOD) nCr[i][j] -= MOD;\n    }\n  }\n  return;\n}\nvoid dfs(int root, int u, int p, int d) {\n  cnt[root][d]++;\n  for (auto v : g[u]) {\n    if (v == p) continue;\n    dfs(root, v, u, d + 1);\n  }\n  return;\n}\nint solve(int n, int k) {\n  if (k == 2) return nCr[n][k];\n  int ret = 0;\n  for (int u = 0; u < int(n); u++) {\n    cnt = vector<vector<int> >(n, vector<int>(n, 0));\n    cnt[u][0] = 1;\n    for (auto v : g[u]) dfs(v, v, u, 1);\n    for (int i = 1; i < n; i++) {\n      dp = vector<long long>(k + 1, 0);\n      dp[0] = 1;\n      for (auto v : g[u]) {\n        for (int j = k; j > 0; j--) {\n          dp[j] = (dp[j - 1] * cnt[v][i] + dp[j]) % MOD;\n        }\n      }\n      ret += dp[k];\n      ret %= MOD;\n    }\n  }\n  return ret;\n}\nint main(int argc, const char* argv[]) {\n  std::ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  precal();\n  int t, n, k, u, v;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    g = vector<vector<int> >(n);\n    for (int i = 0; i < int(n - 1); i++) {\n      cin >> u >> v;\n      u--;\n      v--;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    output(solve(n, k));\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long maxn = 100 + 5, mod = 1e9 + 7, inf = mod;\nlong long n, k;\nvector<long long> g[maxn];\nlong long ans;\nlong long cnt[maxn];\nvector<long long> dis[maxn];\nlong long dp[maxn];\nvoid dfs(long long i, long long p, long long d) {\n  cnt[d]++;\n  for (long long j : g[i]) {\n    if (j != p) {\n      dfs(j, i, d + 1);\n    }\n  }\n}\nlong long get(vector<long long>& v) {\n  fill(begin(dp), end(dp), 0);\n  dp[0] = 1;\n  for (long long x : v) {\n    for (long long num = (long long)n; num >= (long long)1; num--) {\n      dp[num] = (dp[num] + dp[num - 1] * x) % mod;\n    }\n  }\n  return dp[k];\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long tc;\n  cin >> tc;\n  while (tc--) {\n    cin >> n >> k;\n    ans = 0;\n    fill(g + 1, g + n + 1, vector<long long>());\n    for (long long i = (long long)1; i <= (long long)n - 1; i++) {\n      long long u, v;\n      cin >> u >> v;\n      g[u].emplace_back(v);\n      g[v].emplace_back(u);\n    }\n    if (k == 1) {\n      cout << n << '\\n';\n      continue;\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    for (long long i = (long long)1; i <= (long long)n; i++) {\n      for (long long d = (long long)0; d <= (long long)n; d++) dis[d].clear();\n      for (long long j : g[i]) {\n        fill(begin(cnt), end(cnt), 0);\n        dfs(j, i, 1);\n        for (long long d = (long long)1; d <= (long long)n; d++) {\n          dis[d].emplace_back(cnt[d]);\n        }\n      }\n      for (long long d = (long long)1; d <= (long long)n; d++) {\n        ans += get(dis[d]);\n        ans %= mod;\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing ll = long long;\nusing datas = pair<ll, ll>;\nusing ddatas = pair<long double, long double>;\nusing tdata = pair<ll, datas>;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pvec = vector<datas>;\nusing pmat = vector<pvec>;\nconstexpr ll mod = 1000000007;\nconstexpr ll inf = 1LL << 60;\nconstexpr long double eps = 1e-9;\nconst long double PI = acosl(-1);\ntemplate <class T, class E>\nostream& operator<<(ostream& os, const pair<T, E>& p) {\n  return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const set<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const multiset<T>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T, class E>\nostream& operator<<(ostream& os, const map<T, E>& v) {\n  os << \"{\";\n  bool f = false;\n  for (auto& x : v) {\n    if (f) os << \",\";\n    os << x;\n    f = true;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <class T>\ninline bool chmax(T& a, const T b) {\n  bool x = a < b;\n  if (x) a = b;\n  return x;\n}\ntemplate <class T>\ninline bool chmin(T& a, const T b) {\n  bool x = a > b;\n  if (x) a = b;\n  return x;\n}\ninline void startupcpp(void) noexcept {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(15);\n}\nll modinv(ll a, const ll m = mod) noexcept {\n  ll b = m, u = 1, v = 0, t;\n  while (b) {\n    t = a / b;\n    a -= t * b;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  return (u + m) % m;\n}\nll moddevide(const ll a, const ll b) noexcept { return (a * modinv(b)) % mod; }\nvec modncrlistp, modncrlistm;\nll modncr(const ll n, const ll r) noexcept {\n  if (n < r) return 0;\n  ll i, size = modncrlistp.size();\n  if (size <= n) {\n    modncrlistp.resize(n + 1);\n    modncrlistm.resize(n + 1);\n    if (!size) {\n      modncrlistp[0] = modncrlistm[0] = 1;\n      size++;\n    }\n    for (i = size; i < (ll)n + 1; ++i)\n      modncrlistp[i] = modncrlistp[i - 1] * i % mod;\n    modncrlistm[n] = modinv(modncrlistp[n]);\n    for (i = n; i > size; --i) modncrlistm[i - 1] = modncrlistm[i] * i % mod;\n  }\n  return modncrlistp[n] * modncrlistm[r] % mod * modncrlistm[n - r] % mod;\n}\nll modpow(ll a, ll n, const ll m = mod) {\n  if (n < 0) return 0;\n  ll res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % m;\n    a = a * a % m;\n    n >>= 1;\n  }\n  return res;\n}\nconstexpr ll gcd(const ll a, const ll b) noexcept {\n  return (!b) ? abs(a) : (a % b == 0) ? abs(b) : gcd(b, a % b);\n}\nconstexpr ll lcm(const ll a, const ll b) noexcept { return a / gcd(a, b) * b; }\nll N, K;\nmat g;\ndeque<ll> dfs(ll now, ll par) {\n  deque<ll> res;\n  res.emplace_back(1);\n  for (auto x : g[now]) {\n    if (x == par) continue;\n    auto p = dfs(x, now);\n    p.emplace_front(0);\n    if (p.size() > res.size()) swap(res, p);\n    for (size_t i = 0; i < p.size(); ++i) res[i] += p[i];\n  }\n  return res;\n}\nll solve(vec& v) {\n  vec dp(K + 1, 0);\n  dp[0] = 1;\n  ll i;\n  for (auto x : v) {\n    for (i = K, --i; i >= (ll)0; --i) (dp[i + 1] += dp[i] * x) %= mod;\n  }\n  return dp[K];\n}\nint main() {\n  startupcpp();\n  int codeforces;\n  cin >> codeforces;\n  while (codeforces--) {\n    ll i, j, a, b;\n    cin >> N >> K;\n    g.clear();\n    g.resize(N);\n    for (i = 1; i < (ll)N; ++i) {\n      cin >> a >> b;\n      --a;\n      --b;\n      g[a].emplace_back(b);\n      g[b].emplace_back(a);\n    }\n    if (K == 2) {\n      cout << N * (N - 1) / 2 << \"\\n\";\n      continue;\n    }\n    ll ans = 0;\n    for (i = 0; i < (ll)N; ++i) {\n      if (ll(g[i].size()) < K) continue;\n      vector<deque<ll>> ch(g[i].size());\n      for (j = 0; j < (ll)g[i].size(); ++j) ch[j] = dfs(g[i][j], i);\n      for (j = 0; j < (ll)N; ++j) {\n        vec res;\n        for (auto& v : ch) {\n          if (j >= ll(v.size())) continue;\n          res.emplace_back(v[j]);\n        }\n        if (ll(res.size()) < K) break;\n        ans += solve(res);\n      }\n    }\n    cout << ans % mod << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nconst long long mod = 1e9 + 7LL;\nvector<int> lista[N];\nint vis[N], g[N], peso[N], qt;\nlong long dp[N][N], visdp[N][N], t = 0;\nlong long solve(int pos, int k) {\n  if (!k) return 1;\n  if (pos == qt) return 0;\n  long long &ans = dp[pos][k];\n  if (visdp[pos][k] == t) return ans;\n  visdp[pos][k] = t;\n  ans = (peso[pos] * solve(pos + 1, k - 1) + solve(pos + 1, k)) % mod;\n  return ans;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, c;\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> n >> c;\n    for (int i = 0; i <= n; ++i) {\n      vis[i] = 0;\n      lista[i].clear();\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      int a, b;\n      cin >> a >> b;\n      lista[a].push_back(b);\n      lista[b].push_back(a);\n    }\n    long long ans = 0;\n    if (c == 2) {\n      cout << n * (n - 1) / 2 << \"\\n\";\n      continue;\n    }\n    for (int i = 1; i <= n; ++i) {\n      queue<int> f, f1;\n      vis[i] = i;\n      qt = 0;\n      for (int u : lista[i]) {\n        g[u] = qt++;\n        peso[g[u]] = 1;\n        vis[u] = i;\n        f.push(u);\n      }\n      t++;\n      ans = (ans + solve(0, c)) % mod;\n      while (!f.empty()) {\n        while (!f.empty()) {\n          int u = f.front();\n          f.pop();\n          peso[g[u]]--;\n          for (int v : lista[u])\n            if (vis[v] != i) {\n              g[v] = g[u];\n              peso[g[v]]++;\n              vis[v] = i;\n              f1.push(v);\n            }\n        }\n        t++;\n        ans = (ans + solve(0, c)) % mod;\n        swap(f1, f);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105, mod = 1e9 + 7;\nint T, n, m, x, y, soncnt, cnt[N][N], dep[N], son[N];\nlong long ans;\nvector<int> G[N];\nlong long f[N][N];\ninline void dfs(int x, int fa, int col) {\n  dep[x] = dep[fa] + 1, ++cnt[col][dep[x]];\n  for (auto y : G[x])\n    if (y != fa) dfs(y, x, col);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> T;\n  while (T--) {\n    cin >> n >> m, ans = 0;\n    for (int i = 1; i <= n; ++i) G[i].clear();\n    for (int i = 1; i < n; ++i) {\n      cin >> x >> y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    if (m == 2) {\n      cout << (n * (n - 1) / 2) << endl;\n      continue;\n    }\n    for (int i = 1; i <= n; ++i) {\n      memset(cnt, 0, sizeof cnt);\n      dep[i] = soncnt = 0;\n      for (auto y : G[i]) dfs(y, i, y), son[++soncnt] = y;\n      for (int D = 1; D <= n; ++D) {\n        memset(f, 0, sizeof f);\n        f[0][0] = 1;\n        for (int j = 1; j <= soncnt; ++j) {\n          f[j][0] = f[j - 1][0];\n          for (int k = 1; k <= j; ++k)\n            f[j][k] =\n                (f[j - 1][k - 1] * cnt[son[j]][D] % mod + f[j - 1][k]) % mod;\n        }\n        (ans += f[soncnt][m]) %= mod;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e2 + 5, mod = 1e9 + 7;\nint e[N], ne[N], h[N], idx;\nint d[N];\nlong long f[N][N];\nvoid add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nvoid dfs(int x, int fa, int dis, int f) {\n  d[dis]++;\n  for (int i = h[x]; ~i; i = ne[i]) {\n    int u = e[i];\n    if (u == fa) continue;\n    dfs(u, x, dis + 1, f);\n  }\n}\nint main() {\n  int _;\n  cin >> _;\n  memset(h, -1, sizeof h);\n  while (_--) {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      add(a, b);\n      add(b, a);\n    }\n    long long ans = 0;\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n    } else {\n      vector<int> g[N];\n      for (int i = 1; i <= n; i++) {\n        for (int i = 1; i <= n; i++) g[i].clear();\n        int x = i;\n        for (int j = h[x]; ~j; j = ne[j]) {\n          memset(d, 0, sizeof d);\n          int u = e[j];\n          dfs(u, x, 1, x);\n          for (int i = 1; i <= n; i++) g[i].push_back(d[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n          f[0][0] = 1;\n          if (g[i].size() < k) continue;\n          for (int j = 1; j <= g[i].size(); j++) {\n            for (int w = 0; w <= k; w++) {\n              f[j][w] = f[j - 1][w];\n              if (w >= 1)\n                f[j][w] = (f[j][w] + f[j - 1][w - 1] * g[i][j - 1] % mod) % mod;\n            }\n          }\n          ans = (ans + f[g[i].size()][k]) % mod;\n        }\n      }\n      cout << ans << endl;\n    }\n    idx = 0;\n    for (int i = 1; i <= n; i++) h[i] = -1;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e2 + 10;\nconst long long mod = 1e9 + 7;\nconst double eps = 1e-9;\nconst long long INF = 0x3f3f3f3f;\nlong long n, k;\nlong long ne[N], h[N], e[N], idx = 1;\nlong long dp[N][N], cnt[N][N];\nvoid add(long long a, long long b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nvoid dfs(long long u, long long fa) {\n  cnt[u][0] = 1;\n  for (long long i = h[u]; i; i = ne[i]) {\n    long long j = e[i];\n    if (j == fa) continue;\n    dfs(j, u);\n    for (long long deep = 1; deep <= n; deep++)\n      cnt[u][deep] += cnt[j][deep - 1];\n  }\n}\nlong long slove(long long u) {\n  for (long long i = 0; i <= n; i++)\n    for (long long j = 0; j <= n; j++) cnt[i][j] = 0;\n  dfs(u, -1);\n  vector<long long> son;\n  son.push_back(-1);\n  for (long long i = h[u]; i; i = ne[i]) son.push_back(e[i]);\n  long long len = (long long)son.size(), res = 0;\n  for (long long d = 0; d <= n; d++) {\n    dp[0][0] = 1;\n    for (long long i = 1; i < len; i++) {\n      dp[i][0] = 1;\n      for (long long j = 1; j <= i; j++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n        dp[i][j] = (dp[i][j] + (dp[i - 1][j - 1] * cnt[son[i]][d] % mod)) % mod;\n      }\n    }\n    res = (res + dp[len - 1][k]) % mod;\n    for (long long i = 1; i < len; i++)\n      for (long long j = 1; j <= i; j++) dp[i][j] = 0;\n  }\n  return res;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long tt;\n  cin >> tt;\n  while (tt--) {\n    for (long long i = 1; i <= idx; i++) h[i] = 0;\n    idx = 1;\n    cin >> n >> k;\n    for (long long i = 1; i < n; i++) {\n      long long a, b;\n      cin >> a >> b;\n      add(a, b);\n      add(b, a);\n    }\n    long long ans = 0;\n    if (k == 2)\n      ans = (n * (n - 1) / 2) % mod;\n    else\n      for (long long root = 1; root <= n; root++)\n        ans = (ans + slove(root)) % mod;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint modadd(int x, int y) {\n  int result = x + y;\n  if (result >= MOD) result -= MOD;\n  return result;\n}\nint modmult(int x, int y) { return (x * int64_t(y)) % MOD; }\nint modaddto(int& x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n  return x;\n}\nint64_t modpow(int64_t b, int64_t e) {\n  int64_t ans = 1;\n  for (; e; b = b * b % MOD, e /= 2)\n    if (e & 1) ans = ans * b % MOD;\n  return ans;\n}\nint modinv(int x) { return modpow(x, MOD - 2); }\nvector<int> get_parents(const vector<vector<int>>& adj, int root) {\n  int n = adj.size();\n  vector<int> parents(n, -1);\n  stack<pair<int, int>> st;\n  st.emplace(root, -1);\n  while (!st.empty()) {\n    int node = st.top().first;\n    parents[node] = st.top().second;\n    st.pop();\n    for (int i : adj[node]) {\n      if (i != parents[node]) {\n        st.emplace(i, node);\n      }\n    }\n  }\n  return parents;\n}\nvector<vector<int>> get_children(const vector<int>& parents) {\n  int n = parents.size();\n  vector<vector<int>> children(n);\n  for (int i = 0; i < n; ++i) {\n    if (parents[i] >= 0) {\n      children[parents[i]].push_back(i);\n    }\n  }\n  return children;\n}\nvector<int> get_depth(const vector<vector<int>>& children, int root) {\n  int n = children.size();\n  vector<int> depth(n);\n  vector<int> q(1, root);\n  int d = 0;\n  while (!q.empty()) {\n    vector<int> q2;\n    for (int i : q) {\n      depth[i] = d;\n      for (int j : children[i]) {\n        q2.push_back(j);\n      }\n    }\n    q2.swap(q);\n    d++;\n  }\n  return depth;\n}\nint solve(const vector<int>& u, const vector<int>& v, int k) {\n  int n = u.size() + 1;\n  if (k == 2) {\n    return n * (n - 1) / 2;\n  }\n  vector<vector<int>> adj(n);\n  for (int i = 0; i < n - 1; ++i) {\n    adj[u[i]].push_back(v[i]);\n    adj[v[i]].push_back(u[i]);\n  }\n  int ways = 0;\n  for (int root = 0; root < n; ++root) {\n    if (int(adj[root].size()) < k) continue;\n    vector<int> parents = get_parents(adj, root);\n    vector<vector<int>> children = get_children(parents);\n    vector<int> depth = get_depth(children, root);\n    int max_depth = *max_element(depth.begin(), depth.end());\n    int nch = children[root].size();\n    vector<vector<int>> depths(nch, vector<int>(max_depth, 0));\n    for (int chi = 0; chi < nch; ++chi) {\n      stack<int> st;\n      st.push(children[root][chi]);\n      while (!st.empty()) {\n        int node = st.top();\n        st.pop();\n        depths[chi][depth[node] - 1]++;\n        for (int j : children[node]) {\n          st.push(j);\n        }\n      }\n    }\n    for (int d = 0; d < max_depth; ++d) {\n      vector<int> dp(1, 1);\n      for (int chi = 0; chi < nch; ++chi) {\n        vector<int> dp2(chi + 2, 0);\n        dp2[0] = dp[0];\n        for (int i = 1; i < chi + 2; ++i) {\n          dp2[i] = (i < chi + 1) ? dp[i] : 0;\n          modaddto(dp2[i], modmult(dp[i - 1], depths[chi][d]));\n        }\n        dp2.swap(dp);\n      }\n      assert(int(dp.size()) > k);\n      modaddto(ways, dp[k]);\n    }\n  }\n  return ways;\n}\nvoid test_case() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> u(n - 1), v(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    cin >> u[i] >> v[i];\n    --u[i];\n    --v[i];\n  }\n  cout << solve(u, v, k) << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; ++i) {\n    test_case();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nstream Butter!\neggyHide eggyVengeance\nI need U\nxiao rerun when\n */\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1551F\n{\n    static final long MOD = 1000000007L;\n    static ArrayDeque<Integer>[] edges;\n    public static void main(String hi[]) throws Exception\n    {\n        fac = new long[201]; invfac = new long[201];\n        fac[0] = invfac[0] = 1L;\n        for(int i=1; i <= 200; i++)\n        {\n            fac[i] = (fac[i-1]*i)%MOD;\n            invfac[i] = power(fac[i], MOD-2, MOD);\n        }\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            infile.readLine();\n            st = new StringTokenizer(infile.readLine());\n            int N = Integer.parseInt(st.nextToken());\n            int K = Integer.parseInt(st.nextToken());\n            edges = new ArrayDeque[N];\n            for(int i=0; i < N; i++)\n                edges[i] = new ArrayDeque<Integer>();\n            for(int i=1; i < N; i++)\n            {\n                st = new StringTokenizer(infile.readLine());\n                int a = Integer.parseInt(st.nextToken())-1;\n                int b = Integer.parseInt(st.nextToken())-1;\n                edges[a].add(b);    edges[b].add(a);\n            }\n            long res = 0L;\n            if(K == 2)\n                res = N*(N-1)/2;\n            else\n            {\n                for(int center=0; center < N; center++)\n                {\n                    int[] label = new int[N];\n                    int[] depth = new int[N];\n                    ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n                    q.add(center);\n                    Arrays.fill(depth, -1);\n                    depth[center] = 0;\n                    while(q.size() > 0)\n                    {\n                        int curr = q.poll();\n                        for(int next: edges[curr])\n                            if(depth[next] == -1)\n                            {\n                                depth[next] = depth[curr]+1;\n                                if(curr == center)\n                                    label[next] = next;\n                                else\n                                    label[next] = label[curr];\n                                q.add(next);\n                            }\n                    }\n                    //dp stuff\n                    int[][] freq = new int[N][N];\n                    for(int v=0; v < N; v++)\n                        if(v != center)\n                            freq[depth[v]][label[v]]++;\n                    for(int d=0; d < N; d++)\n                    {\n                        long[] dp = new long[K+1];\n                        dp[0] = 1L;\n                        for(int v=0; v < N; v++)\n                            if(freq[d][v] > 0)\n                                for(int i=K; i > 0; i--)\n                                {\n                                    dp[i] += (freq[d][v]*dp[i-1])%MOD;\n                                    if(dp[i] >= MOD)\n                                        dp[i] -= MOD;\n                                }\n                        res += dp[K];\n                        if(res >= MOD)\n                            res -= MOD;\n                    }\n                }\n            }\n            sb.append(res+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    static long[] fac, invfac;\n    public static long power(long x, long y, long p)\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%p;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%p;\n            y >>= 1;\n            x = (x*x)%p;\n        }\n        return res;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, z, a, b;\n    cin >> n >> z;\n    vector<int> c(n + 1);\n    vector<vector<int>> v(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n      cin >> a >> b;\n      c[a]++, c[b]++;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    if (z == 2)\n      cout << (n * (n - 1)) / 2 << '\\n';\n    else {\n      long long int ans = 0;\n      for (int i = 1; i <= n; i++) {\n        if (c[i] >= z) {\n          vector<vector<long long int>> m(n + 1);\n          for (int j = 0; j < (int)v[i].size(); j++) {\n            queue<pair<int, int>> q;\n            vector<int> check(n + 1), cd(n + 1);\n            q.push({v[i][j], 1});\n            check[v[i][j]] = 1;\n            check[i] = 1;\n            while (!q.empty()) {\n              pair<int, int> atual = q.front();\n              q.pop();\n              cd[atual.second]++;\n              for (int k = 0; k < (int)v[atual.first].size(); k++) {\n                int prox = v[atual.first][k];\n                if (!check[prox]) {\n                  check[prox] = 1;\n                  q.push({prox, atual.second + 1});\n                }\n              }\n            }\n            for (int k = 1; k <= n; k++) {\n              if (cd[k]) {\n                m[k].push_back(cd[k]);\n              }\n            }\n          }\n          for (int j = 1; j <= n; j++) {\n            if ((int)m[j].size() >= z) {\n              vector<vector<int>> dp(((int)m[j].size() + 1),\n                                     vector<int>(z + 1));\n              for (int k = 0; k <= (int)m[j].size(); k++) dp[k][z] = 1;\n              for (int k = z - 1; k >= 0; k--) {\n                for (int l = (int)m[j].size() - 1; l >= 0; l--) {\n                  dp[l][k] += (m[j][l] * dp[l + 1][k + 1]) % M;\n                  dp[l][k] = (dp[l][k] + dp[l + 1][k]) % M;\n                }\n              }\n              ans = (ans + dp[0][0]) % M;\n            }\n          }\n        }\n      }\n      cout << ans << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\n\nfrom math import cos, sin\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nmod = 10 ** 9 + 7\n\nMX = 101\nfact = [1]\n\nfor i in range(1, MX):\n    fact.append(fact[-1] * i % mod)\n\ninv = [pow(fact[i], mod - 2, mod) for i in range(MX)]\n\n\ndef ncr(n, r):\n    if n < 0 or r < 0 or n < r:\n        return 0\n    return (fact[n] * inv[n - r] * inv[r]) % mod\n\n\ndef dfs(x, par):\n    for i in a[x]:\n        if i != par:\n            ndp[i] = ndp[x] + 1\n            ct[-1].append(ndp[i])\n            dfs(i, x)\n\n\n\ndef solve(ck):\n    dp1 = [0] * len(ck)\n\n    for i in range(len(ck)):\n        dp1[i] = ck[i]\n        if i > 0:\n            dp1[i] += dp1[i - 1]\n\n    for i in range(2, k + 1):\n        ndp1 = [0] * len(ck)\n        for j in range(i - 1, len(ck)):\n            ndp1[j] = dp1[j - 1] * ck[j]\n            ndp1[j] %= mod\n        tot = 0\n        for j in range(len(ck)):\n            tot += ndp1[j]\n            tot %= mod\n            dp1[j] = tot\n    return tot\n\n\nfor _ in range(int(input())):\n    input()\n    n, k = map(int, input().split())\n    a = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        x, y = map(int, input().split())\n        a[x].append(y)\n        a[y].append(x)\n\n    ans = 0\n    if k == 2:\n        print(ncr(n, 2) % mod)\n        continue\n    for i in range(1, n + 1):\n        ndp = [0] * (n + 1)\n        ct = []\n        for j in a[i]:\n            ndp[j]=1\n            ct.append([])\n            ct[-1].append(1)\n            dfs(j,i)\n\n        if len(ct) < k:\n            continue\n        for j in range(len(ct)):\n            ct[j].sort(reverse=True)\n        # print('ct ->', ct,i)\n        t = 1\n        size = len(ct)\n        while size >= k:\n            ck = []\n            for j in range(len(ct)):\n                if len(ct[j]):\n                    tt = 0\n                    while ct[j] and ct[j][-1] == t:\n                        tt += 1\n                        ct[j].pop()\n                    if not ct[j]:\n                        size -= 1\n                    if tt == 0:\n                        continue\n\n                    ck.append(tt)\n            # print(ck,ct)\n            ans += solve(ck)\n            ans%=mod\n            t += 1\n\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long TC;\nlong long N, K, a, b;\nvector<long long> adj[101], B[101];\nlong long twok[101][10];\nvoid dfs(long long x, long long p, long long d) {\n  B[d].push_back(x);\n  twok[x][0] = p;\n  for (long long i = 1; i <= long long(9); ++i) {\n    if (twok[x][i - 1] == -1) break;\n    twok[x][i] = twok[twok[x][i - 1]][i - 1];\n  }\n  for (auto i : adj[x])\n    if (i != p) dfs(i, x, d + 1);\n}\nlong long kpar(long long x, long long k) {\n  for (long long i = 0; i <= long long(9); ++i)\n    if (k & (1 << i)) x = twok[x][i];\n  return x;\n}\nlong long C[101];\nlong long qexp(long long x, long long y) {\n  long long res = 1;\n  while (y > 0) {\n    if (y & 1) (res *= x) %= 1000000007;\n    y >>= 1;\n    (x *= x) %= 1000000007;\n  }\n  return res;\n}\nlong long dp[101][101];\nlong long getnum(vector<long long> &v, long long k) {\n  if (k > v.size()) return 0;\n  for (long long i = 0; i <= long long(v.size() - 1); ++i)\n    for (long long j = 0; j <= long long(k); ++j) {\n      if (j == 0)\n        dp[i][j] = 1;\n      else if (i + 1 < j)\n        dp[i][j] = 0;\n      else if (i == 0)\n        dp[i][j] = v[i];\n      else\n        dp[i][j] = (((v[i] * dp[i - 1][j - 1]) % 1000000007) + dp[i - 1][j]) %\n                   1000000007;\n    }\n  return dp[v.size() - 1][k];\n}\nvoid solve() {\n  cin >> N >> K;\n  for (long long i = 1; i <= long long(N); ++i) adj[i].clear();\n  for (long long i = 1; i <= long long(N - 1); ++i) {\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  if (K == 2) {\n    cout << (N * (N - 1)) / 2 << '\\n';\n    return;\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= long long(N); ++i) {\n    for (long long j = 0; j <= long long(N - 1); ++j) B[j].clear();\n    memset(twok, -1, sizeof twok);\n    dfs(i, -1, 0);\n    for (long long c = 2; c < N; c += 2) {\n      if (B[c].size() < K - 1) continue;\n      for (auto j : B[c]) {\n        C[kpar(j, c / 2 - 1)]++;\n      }\n      for (auto j : B[c / 2]) {\n        vector<long long> v;\n        for (auto k : adj[j])\n          if (k != twok[j][0])\n            if (C[k] > 0) v.push_back(C[k]);\n        ans += getnum(v, K - 1);\n        ans %= 1000000007;\n      }\n      for (auto j : B[c]) {\n        C[kpar(j, c / 2 - 1)] = 0;\n      }\n    }\n  }\n  cout << (ans * qexp(K, 1000000007 - 2)) % 1000000007 << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false), cin.tie(0);\n  cin >> TC;\n  for (long long i = 1; i <= long long(TC); ++i) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Map.Entry;\n\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic final int mod = 1000000007;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputReader in = new InputReader(System.in);\n\t\t// Scanner in = new Scanner(System.in);\n\t\t// Scanner in = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// InputReader in = new InputReader(new\n\t\t// File(\"ethan_traverses_a_tree.txt\"));\n\t\t// PrintWriter out = new PrintWriter(new\n\t\t// File(\"ethan_traverses_a_tree-output.txt\"));\n\n\t\tint pi = in.nextInt();\n\t\tfor (int qi = 0; qi < pi; qi++) {\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\n\t\t\tList<List<Integer>> g = new ArrayList<List<Integer>>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint u = in.nextInt() - 1;\n\t\t\t\tint v = in.nextInt() - 1;\n\n\t\t\t\tg.get(u).add(v);\n\t\t\t\tg.get(v).add(u);\n\t\t\t}\n\n\t\t\tif (k == 2) {\n\t\t\t\tint ans = n * (n - 1) / 2;\n\t\t\t\tout.printf(\"%d\\n\", ans);\n\t\t\t} else {\n\t\t\t\tint ans = 0;\n\t\t\t\tfor (int root = 0; root < n; root++) {\n\t\t\t\t\tList<List<Integer>> tree = new ArrayList<List<Integer>>();\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\ttree.add(new ArrayList<Integer>());\n\t\t\t\t\t}\n\n\t\t\t\t\ttoRootedTree(g, tree, root, -1);\n\t\t\t\t\tList<List<Integer>> count = new ArrayList<List<Integer>>();\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tcount.add(new ArrayList<Integer>(n));\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tcount.get(i).add(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdfs(tree, root, count);\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tList<Integer> listfordp = new ArrayList<Integer>();\n\t\t\t\t\t\tfor (Integer v : tree.get(root)) {\n\t\t\t\t\t\t\tint value = count.get(v).get(i);\n\t\t\t\t\t\t\tif (value > 0) {\n\t\t\t\t\t\t\t\tlistfordp.add(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (listfordp.size() >= k) {\n\t\t\t\t\t\t\tint nowans = dp(listfordp, k);\n\t\t\t\t\t\t\tans = (ans + nowans) % mod;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tout.printf(\"%d\\n\", ans);\n\t\t\t}\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tpublic static int dp(List<Integer> list, int k) {\n\t\tint n = list.size();\n\t\tlong[][] dp = new long[n][k + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][1] = list.get(i);\n\t\t\t} else {\n\t\t\t\tfor (int j = 1; j <= k; j++) {\n\t\t\t\t\tif (j > i + 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j] + list.get(i) * dp[i - 1][j - 1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (int) (dp[n - 1][k]);\n\t}\n\n\tpublic static void dfs(List<List<Integer>> tree, int now, List<List<Integer>> count) {\n\t\tfor (Integer v : tree.get(now)) {\n\t\t\tdfs(tree, v, count);\n\n\t\t\tfor (int i = 0; i < count.get(v).size(); i++) {\n\t\t\t\tint value = count.get(v).get(i);\n\n\t\t\t\tif (value == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount.get(now).set(i + 1, count.get(now).get(i + 1) + value);\n\t\t\t}\n\t\t}\n\n\t\tcount.get(now).set(0, 1);\n\t}\n\n\tpublic static void toRootedTree(List<List<Integer>> g, List<List<Integer>> tree, int now, int parent) {\n\t\tfor (Integer v : g.get(now)) {\n\t\t\tif (v != parent) {\n\t\t\t\ttree.get(now).add(v);\n\t\t\t\ttoRootedTree(g, tree, v, now);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic InputReader(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve();\nvoid _print(long long x) { cerr << x; }\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cout << \" [ \";\n  for (T i : v) {\n    _print(i);\n    cout << \" \";\n  }\n  cout << \"]\";\n}\nlong long o = 0;\nlong long M = 1e9 + 7;\nunsigned long long fac[101];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  chrono::high_resolution_clock::time_point t1 =\n      chrono::high_resolution_clock::now();\n  long long t;\n  fac[0] = 1;\n  for (int i = 1; i <= 100; i++) fac[i] = (fac[i - 1] * i) % M;\n  cin >> t;\n  while (t--) {\n    solve();\n    cout << endl;\n  }\n  chrono::high_resolution_clock::time_point t2 =\n      chrono::high_resolution_clock::now();\n  chrono::duration<double, std::milli> time_span = t2 - t1;\n  return 0;\n}\nunsigned long long power(unsigned long long x, int y, int p) {\n  unsigned long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nunsigned long long modInverse(unsigned long long n, int p) {\n  return power(n, p - 2, p);\n}\nunsigned long long nCrModPFermat(unsigned long long n, int r, int p) {\n  if (n < r) return 0;\n  if (r == 0) return 1;\n  return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) %\n         p;\n}\nlong long k;\nlong long fooo(int* a, long long n) {\n  vector<long long> g(n + 1), t(n + 1);\n  g[0] = 1;\n  for (long long d = (0); d < (n); d++) {\n    for (long long i = (1); i < (n + 1); i++)\n      t[i] = (-a[d] * g[i] + g[i - 1]) % M;\n    t[0] = (-a[d] * g[0]) % M;\n    g = t;\n  }\n  return abs(g[n - k]);\n}\nvoid solve() {\n  long long n;\n  cin >> n >> k;\n  vector<vector<long long>> edges(n + 1);\n  for (long long i = (0); i < (n - 1); i++) {\n    long long x, y;\n    cin >> x >> y;\n    edges[x].push_back(y);\n    edges[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << nCrModPFermat(n, 2, M);\n    return;\n  }\n  vector<long long> deg(n + 1);\n  map<long long, map<long long, long long>> temp;\n  long long ans = 0;\n  function<void(long long, long long, long long, long long)> dfs =\n      [&](long long a, long long p, long long d, long long s) {\n        temp[d][s]++;\n        for (auto x : edges[a]) {\n          if (x == p) continue;\n          if (s == -1)\n            dfs(x, a, d + 1, x);\n          else\n            dfs(x, a, d + 1, s);\n        }\n        return;\n      };\n  for (long long i = (1); i < (n + 1); i++) {\n    deg[i] = edges[i].size();\n  }\n  for (long long i = (1); i < (n + 1); i++) {\n    if (deg[i] >= k) {\n      temp.clear();\n      dfs(i, -1, 0, -1);\n      long long p = 0;\n      for (auto x : temp) {\n        long long t = 1;\n        int gg[101] = {0};\n        int pp = 0;\n        for (auto y : x.second) {\n          gg[pp++] = (y.second);\n        }\n        if (pp < k) continue;\n        ans += fooo(gg, pp);\n        ans %= M;\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nimport sys\ninput=sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306f\u3059\u308b\u306a\uff01\uff01\n\n\n\nt=int(input())\n\nmod=10**9+7\n\n#############\ncnb_max=1000\n#############\n\nkai=[1]*(cnb_max+1)\nrkai=[1]*(cnb_max+1)\nfor i in range(cnb_max):\n    kai[i+1]=kai[i]*(i+1)%mod\n\nrkai[cnb_max]=pow(kai[cnb_max],mod-2,mod)\nfor i in range(cnb_max):\n    rkai[cnb_max-1-i]=rkai[cnb_max-i]*(cnb_max-i)%mod\n\ndef cnb(x,y):\n    if y>x:\n        return 0\n    if x<0:return 0\n    if y<0:return 0\n    return kai[x]*rkai[y]*rkai[x-y]%mod\n\n\n\n\n\nfor iii in range(t):\n    num=input()+\"#\"\n    n,k=map(int,input().split())\n    root=[[] for _ in range(n+1)]\n    for i in range(n-1):\n        u,v=map(int,input().split())\n        root[u].append(v)\n        root[v].append(u)\n\n\n\n    # record=[[] for i in range(n+1)]\n\n    def tree_search(n, G, s, func1, func2, func3):\n        # n...\u9802\u70b9\u306e\u6570\n        # G...G[v]\u306f\u9802\u70b9v\u304b\u3089\u884c\u3051\u308b\u9802\u70b9\u306e\u914d\u5217\n        # s...s\u304c\u6839\n        # func1(now)...\u3042\u308b\u9802\u70b9\u306b\u521d\u3081\u3066\u8a2a\u308c\u305f\u6642\u3001\u305d\u306e\u9802\u70b9\u306e\u307f\u3067\u3059\u308b\u51e6\u7406\u3002\u306a\u3044\u5834\u5408\u306f0\n        # func2(now,next)...now\u304b\u3089next\u306b\u79fb\u52d5\u3059\u308b\u6642\u306b\u884c\u3046\u51e6\u7406\u3002\u306a\u3044\u5834\u5408\u306f0\n        # func3(now)...now\u3092\u53bb\u308b\u6642\u306b\u3059\u308b\u51e6\u7406\u3002\u306a\u3051\u308c\u30700\n\n        seen = [0] * (n + 1)\n        ind = [0] * (n + 1)\n        search = [s]\n        while search:\n            now = search[-1]\n            if seen[now] == 0 and func1 != 0: func1(now)\n            seen[now] = 1\n            if len(G[now]) > ind[now]:\n                next = G[now][ind[now]]\n                ind[now] += 1\n                if seen[next] > 0: continue\n                if func2 != 0: func2(now, next)\n                search.append(next)\n            else:\n                if func3 != 0: func3(now)\n                search.pop()\n\n\n\n    ans=0\n    if k==2:\n        print(cnb(n,2))\n        continue\n\n    for i in range(1,n+1):\n        dp=[0]*(n+3)*(n+3)\n        def _(i,j):\n            return i*(n+1)+j\n\n        def f3(x):\n            dp[_(x,1)]=1\n            for d in range(2,n+1):\n                for y in root[x]:\n                    dp[_(x,d)]+=dp[_(y,d-1)]\n                    dp[_(x,d)]%=mod\n\n        tree_search(n,root,i,0,0,f3)\n        for d in range(1,n+1):\n            sub=[]\n            for x in root[i]:\n                if dp[_(x,d)]>0:\n                    sub.append(dp[_(x,d)])\n            if len(sub)==0:continue\n\n            sub=[1]+sub\n            m=len(sub)-1\n            f=[[0]*(m+1) for l in range(m+1)]\n            f[0][0]=1\n            for x in range(m+1):\n                for y in range(m+1):\n                    if y==0:\n                        f[x][y]=1\n                        continue\n                    f[x][y]=f[x-1][y]+f[x-1][y-1]*sub[x]\n                    f[x][y]%=mod\n            if k<=m:ans+=f[m][k]\n            ans%=mod\n\n    print(ans)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nvector<int> sieve;\nvoid calc_sieve(int n) {\n  sieve.reserve(n + 1);\n  for (int i = 0, nnnn = (n + 1); i < nnnn; ++i) sieve[i] = i;\n  for (int i = 2, nnnn = (n + 1); i < nnnn; ++i) {\n    if (sieve[i] == i) {\n      for (ll j = i * i; j <= n; j += i) {\n        if (sieve[j] == j) sieve[j] = i;\n      }\n    }\n  }\n}\nll norm(ll a, ll P) {\n  while (a >= P) a -= P;\n  while (a < 0) a += P;\n  return a;\n}\nll mul_mod(ll a, ll b, ll P) { return a * b % P; }\nll pow_mod(ll a, ll b, ll P) {\n  ll curr = a, ans = 1;\n  while (b != 0) {\n    if (b & 1) {\n      ans *= curr;\n      ans %= P;\n    }\n    curr *= curr;\n    curr %= P;\n    b >>= 1;\n  }\n  return ans;\n}\nll inv_mod(ll a, ll P) { return pow_mod(a, P - 2ll, P); }\nll div_mod(ll a, ll b, ll P) { return a * inv_mod(b, P) % P; }\nint msb(ll a) {\n  for (int i = 62; i >= 0; i--) {\n    if (a & ((ll)1 << i)) return i + 1;\n  }\n  return 0;\n}\nvector<ll> fact;\nvoid calc_fact(int n, ll P) {\n  if (fact.size() < 1) fact.push_back(1);\n  for (int i = fact.size(), nnnn = (n + 1); i < nnnn; ++i)\n    fact.push_back(fact[i - 1] * i % P);\n}\nvector<ll> fact_inv;\nvoid calc_fact_inv(int n, ll P) {\n  if (fact_inv.size() < 1) fact_inv.push_back(1);\n  for (int i = fact_inv.size(), nnnn = (n + 1); i < nnnn; ++i)\n    fact_inv.push_back(fact_inv[i - 1] * inv_mod(i, P) % P);\n}\nll nCr(int n, int r, ll P) {\n  if (r > n) return 0;\n  calc_fact(n, P);\n  calc_fact_inv(n, P);\n  return (fact[n] * fact_inv[r] % P) * fact_inv[n - r] % P;\n}\nll nCr_inv(int n, int r, ll P) {\n  if (r > n) return 0;\n  calc_fact(n, P);\n  calc_fact_inv(n, P);\n  return (fact_inv[n] * fact[r] % P) * fact[n - r] % P;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long double eps = 1e-9;\nconst long long mod = 1000000007;\nconst int MAXN = 100;\nvector<int> adjlist[MAXN];\nvoid dfs(int curr, int dist, int p, vector<int> &v) {\n  v[dist]++;\n  for (int i : adjlist[curr]) {\n    if (i != p) {\n      dfs(i, dist + 1, curr, v);\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0, nnnn = (n); i < nnnn; ++i) adjlist[i].clear();\n  for (int i = 0, nnnn = (n - 1); i < nnnn; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adjlist[a - 1].push_back(b - 1);\n    adjlist[b - 1].push_back(a - 1);\n  }\n  if (k == 2) {\n    cout << (n - 1) * n / 2 << endl;\n  } else {\n    ll ans = 0;\n    for (int i = 0, nnnn = (n); i < nnnn; ++i) {\n      vector<vector<int>> v =\n          vector<vector<int>>(adjlist[i].size(), vector<int>(n, 0));\n      for (int j = 0, nnnn = (adjlist[i].size()); j < nnnn; ++j) {\n        dfs(adjlist[i][j], 0, i, v[j]);\n      }\n      for (int j = 0, nnnn = (n); j < nnnn; ++j) {\n        ll dp[k];\n        memset(dp, 0, sizeof dp);\n        for (int l = 0, nnnn = (adjlist[i].size()); l < nnnn; ++l) {\n          for (int m = k - 1; m >= 1; m--)\n            dp[m] += dp[m - 1] * v[l][j], dp[m] %= mod;\n          dp[0] += v[l][j];\n        }\n        ans += dp[k - 1];\n      }\n    }\n    cout << ans % mod << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout << setprecision(12) << fixed;\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"O3\"\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int N = 1e6 + 7;\nconst int T = 1 << 20;\nvector<vector<int> > G;\nvector<int> przesun(vector<int> a) {\n  vector<int> ret((int)a.size() + 1);\n  for (int i = 0; i < (int)a.size(); i++) ret[i + 1] = a[i];\n  return ret;\n}\nvector<int> operator+(vector<int> a, vector<int> b) {\n  int n = max((int)a.size(), (int)b.size());\n  a.resize(n);\n  b.resize(n);\n  vector<int> ret(n);\n  for (int i = 0; i < n; i++) ret[i] = a[i] + b[i];\n  return ret;\n}\nlong long ans = 0;\nint n, k;\nint dp[101][101];\nvector<int> dfs(int start, int prz = -1) {\n  vector<vector<int> > kubki;\n  for (auto& u : G[start])\n    if (u != prz) kubki.push_back(przesun(dfs(u, start)));\n  if (prz != -1) {\n    vector<int> ret = {1};\n    for (auto& u : kubki) ret = ret + u;\n    return ret;\n  } else {\n    for (int odl = 1; odl < n; odl++) {\n      for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++) dp[i][j] = 0;\n      dp[0][0] = 1;\n      for (int i = 0; i < (int)kubki.size(); i++) {\n        for (int j = 0; j <= i; j++) dp[i + 1][j] = dp[i][j];\n        for (int j = 0; j <= i; j++)\n          dp[i + 1][j + 1] =\n              (dp[i + 1][j + 1] +\n               1ll * dp[i][j] *\n                   ((int)kubki[i].size() > odl ? kubki[i][odl] : 0)) %\n              INF;\n      }\n      ans = (ans + dp[(int)kubki.size()][k]) % INF;\n    }\n  }\n  return {};\n}\nint dist[1004][1004];\nvoid solve() {\n  cin >> n >> k;\n  ans = 0;\n  G = vector<vector<int> >(n + 1);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  if (k == 2)\n    cout << n * (n - 1) / 2 << '\\n';\n  else {\n    for (int i = 1; i <= n; i++) {\n      vector<int> siema(n + 1);\n      dfs(i);\n    }\n    cout << ans << '\\n';\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int test = 1;\n  cin >> test;\n  for (int i = 0; i < test; i++) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nconst int maxx = 105;\nconst int mod = 1000000007;\nll power(ll n, ll first, ll mod) {\n  if (first < 0) return 0ll;\n  if (first == 0) return 1ll;\n  ll cur = power(n, first / 2, mod);\n  if (first & 1) return (cur % mod * cur % mod * n) % mod;\n  return (cur % mod * cur % mod) % mod;\n}\nll mul(ll a, ll b, ll mod) {\n  if (b == 0) return 0ll;\n  ll cur = mul(a, b / 2, mod);\n  if (b & 1) {\n    return (2 * cur + a) % mod;\n  }\n  return (2 * cur) % mod;\n}\nll gcd(ll a, ll b, ll& first, ll& second) {\n  if (b == 0) {\n    first = 1;\n    second = 0;\n    return a;\n  }\n  ll x1, y1;\n  ll g = gcd(b, a % b, x1, y1);\n  first = y1;\n  y1 = x1 - a / b * y1;\n  return g;\n}\nvector<int> edge[maxx];\nll f[maxx][maxx], h[maxx], visit[maxx], cnt[maxx];\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i <= n; ++i) {\n    edge[i].clear();\n  }\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << (n * (n - 1) / 2) % mod << '\\n';\n    return;\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    memset(visit, 0, sizeof visit);\n    visit[i] = 1;\n    vector<pair<int, int> > tmp;\n    int m = edge[i].size();\n    for (int e = 0; e < m; ++e) {\n      tmp.push_back({edge[i][e], e});\n      cnt[e] = 1;\n      visit[edge[i][e]] = 1;\n    }\n    while (1) {\n      if (tmp.empty()) break;\n      memset(f, 0, sizeof f);\n      for (int j = 0; j <= m; ++j) f[j][0] = 1;\n      for (int j = 1; j <= m; ++j) {\n        for (int t = 1; t <= k; ++t) {\n          f[j][t] = (f[j][t] + f[j - 1][t]) % mod;\n          f[j][t] = (f[j][t] + cnt[j - 1] * f[j - 1][t - 1] % mod) % mod;\n        }\n      }\n      ans = (ans + f[m][k]) % mod;\n      vector<pair<int, int> > cur;\n      for (auto p : tmp) {\n        cnt[p.second]--;\n        for (auto second : edge[p.first])\n          if (!visit[second]) {\n            cur.emplace_back(second, p.second);\n            visit[second] = true;\n            cnt[p.second]++;\n          }\n      }\n      tmp = cur;\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename _T>\ninline void read(_T &x) {\n  x = 0;\n  char s = getchar();\n  long long f = 1;\n  while (s < '0' || s > '9') {\n    f = 1;\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + s - '0';\n    s = getchar();\n  }\n  x *= f;\n}\nconst long long np = 105;\nconst long long mod = 1e9 + 7;\nlong long fac[np], inv[np];\ninline long long power(long long a, long long b) {\n  long long res(1);\n  while (b) {\n    if (b & 1) res = res * a, res %= mod;\n    a = a * a;\n    a %= mod;\n    b >>= 1;\n  }\n  return res;\n}\ninline long long c(long long n_, long long m_) {\n  return ((fac[n_] * inv[n_ - m_] % mod) * inv[m_]) % mod;\n}\nlong long head[np], nxt[np * 2], ver[np * 2], tit;\ninline void add(long long x, long long y) {\n  ver[++tit] = y;\n  nxt[tit] = head[x];\n  head[x] = tit;\n}\nlong long dep[np], maxn;\nlong long sub[np][np];\nlong long dp[np][np];\nlong long n, k;\ninline void dfs(long long x, long long ff, long long id) {\n  dep[x] = dep[ff] + 1;\n  maxn = max(dep[x], maxn);\n  sub[id][dep[x]]++;\n  for (long long i = head[x], v; i; i = nxt[i]) {\n    v = ver[i];\n    if (v == ff) continue;\n    dfs(v, x, id);\n  }\n}\nsigned main() {\n  fac[0] = 1;\n  for (long long i = 1; i <= 100; i++) fac[i] = fac[i - 1] * i, fac[i] %= mod;\n  for (long long i = 0; i <= 100; i++) inv[i] = power(fac[i], mod - 2);\n  long long T;\n  read(T);\n  while (T--) {\n    read(n);\n    read(k);\n    for (long long i = 1, a, b; i < n; i++) {\n      read(a);\n      read(b);\n      add(a, b);\n      add(b, a);\n    }\n    if (k == 2) {\n      long long ans = c(n, 2);\n      printf(\"%lld\\n\", ans);\n      memset(head, 0, sizeof(head));\n      tit = 0;\n      continue;\n    }\n    long long Ans = 0;\n    for (long long i = 1; i <= n; i++) {\n      dep[i] = 1;\n      long long ql = 0;\n      maxn = 0;\n      for (long long q = head[i]; q; q = nxt[q]) dfs(ver[q], i, ++ql);\n      if (ql >= k) {\n        for (long long h = 1; h <= maxn; h++) {\n          dp[0][0] = 1;\n          for (long long a = 1; a <= ql; a++)\n            for (long long b = 0; b <= k; b++)\n              dp[a][b] =\n                  (dp[a - 1][b] + (dp[a - 1][b - 1] * sub[a][h]) % mod) % mod;\n          Ans += dp[ql][k];\n          Ans %= mod;\n        }\n      }\n      memset(sub, 0, sizeof(sub));\n      memset(dp, 0, sizeof(dp));\n      memset(dep, 0, sizeof(dep));\n    }\n    printf(\"%lld\\n\", Ans);\n    for (long long i = 1; i <= n; i++) head[i] = 0;\n    tit = 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod1 = 998244353;\nconst long long mod2 = 1000000007;\nint t, n, k, u, v;\nvector<int> con[105];\nint dp[105][105];\nint cnt[105][105];\nint par[105];\nint res, mx;\nint dfs(int i, int p = -1) {\n  par[i] = p;\n  int ret = -1;\n  for (int j = 0, l = con[i].size(); j < l; ++j)\n    if (con[i][j] != p) ret = max(ret, dfs(con[i][j], i));\n  return ++ret;\n}\nint cnts(int i, int d) {\n  if (cnt[i][d] != -1) return cnt[i][d];\n  if (d == 0) return cnt[i][d] = 1;\n  int ret = 0;\n  for (int j = 0, l = con[i].size(); j < l; ++j)\n    if (con[i][j] != par[i]) ret += cnts(con[i][j], d - 1);\n  return cnt[i][d] = ret;\n}\nvoid Q() {\n  cin >> n >> k;\n  res = 0;\n  for (int i = 1; i <= (n); ++i) con[i].clear();\n  for (int i = 1; i < n; ++i) {\n    cin >> u >> v;\n    con[u].push_back(v);\n    con[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << 1ll * (n - 1) * n / 2 % mod2 << endl;\n    return;\n  }\n  for (int r = 1; r <= n; ++r) {\n    memset(cnt, -1, sizeof(cnt));\n    mx = dfs(r);\n    for (int d = 1; d <= mx; ++d) {\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1;\n      for (int i = 0, l = con[r].size(); i <= l; ++i)\n        for (int j = 0; j <= i && j <= k; ++j) {\n          dp[i + 1][j] += dp[i][j];\n          if (dp[i + 1][j] >= mod2) dp[i + 1][j] -= mod2;\n          if (i != l) {\n            dp[i + 1][j + 1] += 1ll * dp[i][j] * cnts(con[r][i], d - 1) % mod2;\n            if (dp[i + 1][j + 1] >= mod2) dp[i + 1][j + 1] -= mod2;\n          }\n        }\n      res += dp[con[r].size()][k];\n      if (res >= mod2) res -= mod2;\n    }\n  }\n  cout << res << endl;\n}\nint main() {\n  cin >> t;\n  while (t--) Q();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mul(int x, int y) { return (long long)x * y % 1000000007; }\nint add(int x, int y) {\n  x += y;\n  while (x >= 1000000007) x -= 1000000007;\n  while (x < 0) x += 1000000007;\n  return x;\n}\nvoid dfs(int node, int dad, int d, int i, vector<vector<int>>& freq,\n         vector<vector<int>>& v) {\n  if (freq[i].size() == d) {\n    freq[i].push_back(0);\n  }\n  freq[i][d]++;\n  for (int go : v[node]) {\n    if (go != dad) {\n      dfs(go, node, d + 1, i, freq, v);\n    }\n  }\n}\nint calc(int node, vector<vector<int>>& v, int k) {\n  int n = v.size() >> 1;\n  vector<vector<int>> freq(n);\n  for (int i = 0; i < v[node].size(); i++) {\n    freq[i].push_back(0);\n    dfs(v[node][i], node, 1, i, freq, v);\n  }\n  int res = 0;\n  for (int d = 1 + (node < n); d < n * 2; d += 2) {\n    vector<vector<int>> dp(v[node].size() + 1, vector<int>(k + 1, 0));\n    dp[0][0] = 1;\n    for (int id = 1; id <= v[node].size(); id++) {\n      int i = id - 1;\n      for (int c = 0; c <= k; c++) {\n        int val = 0;\n        if (freq[i].size() > d) {\n          val = freq[i][d];\n        }\n        dp[id][c] = add(dp[id - 1][c], mul(c > 0 ? dp[id - 1][c - 1] : 0, val));\n      }\n    }\n    res = add(res, dp[v[node].size()][k]);\n  }\n  return res;\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> v(n << 1);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    v[x].push_back(n + i);\n    v[n + i].push_back(x);\n    v[n + i].push_back(y);\n    v[y].push_back(n + i);\n  }\n  if (k == 1) {\n    cout << n << \"\\n\";\n    return;\n  }\n  int ans = 0;\n  for (int i = 0; i < 2 * n; i++) {\n    ans = add(ans, calc(i, v, k));\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long MOD = 1e9 + 7;\nint t, n, k, u, v;\nvector<vector<int> > adj;\nvector<int> dep, part;\nvoid dfs(int i, int p, int d) {\n  dep[i] = d;\n  for (int nb : adj[i])\n    if (nb != p) {\n      part[nb] = part[i];\n      dfs(nb, i, d + 1);\n    }\n}\nlong long calc(int i) {\n  dep.clear();\n  dep.resize(n, 0);\n  part.clear();\n  part.resize(n, i);\n  for (int nb : adj[i]) {\n    part[nb] = nb;\n    dfs(nb, i, 1);\n  }\n  long long ans = 0;\n  for (int d = (1); d < (n); ++d) {\n    map<int, long long> freq;\n    for (int i = (0); i < (n); ++i)\n      if (dep[i] == d) freq[part[i]]++;\n    if (freq.size() < k) break;\n    vector<long long> vals;\n    for (auto p : freq) vals.push_back(p.second);\n    vector<vector<long long> > dp(vals.size(), vector<long long>(k, 0));\n    dp[0][0] = vals[0];\n    for (int i = (1); i < (vals.size()); ++i) {\n      dp[i][0] = (vals[i] + dp[i - 1][0]) % MOD;\n      for (int j = (1); j < (k); ++j) {\n        dp[i][j] = (dp[i - 1][j] + vals[i] * dp[i - 1][j - 1]) % MOD;\n      }\n    }\n    ans = (ans + dp[vals.size() - 1][k - 1]) % MOD;\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> n >> k;\n  adj.clear();\n  adj.resize(n);\n  for (int i = (0); i < (n - 1); ++i) {\n    cin >> u >> v;\n    u--;\n    v--;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  long long ans = 0;\n  for (int i = (0); i < (n); ++i) ans = (ans + calc(i)) % MOD;\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tint tcCnt = in.nextInt();\n\t\tfor (int tc = 1; tc <= tcCnt; tc++)\n\t\t\tsolver.solve(tc, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tfinal long MOD = (long)(1e9 + 7);\n\t\tint n, k;\n\t\tList<Integer>[] list;\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tn = in.nextInt();\n\t\t\tk = in.nextInt();\n\t\t\tlist = new ArrayList[n+1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tlist[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tlist[u].add(v);\n\t\t\t\tlist[v].add(u);\n\t\t\t}\n\t\t\tif (k == 2) {\n\t\t\t\tout.println(((1l * n * (n-1)) / 2) % MOD);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tans = (ans + noOfSets(i)) % MOD;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tlong noOfSets(int node) {\n\t\t\tQueue<Integer> queue = new LinkedList<>();\n\t\t\tint[] subtreeIndex = new int[n+1];\n\t\t\tsubtreeIndex[node] = -1;\n\t\t\tfor (int i = 0; i < list[node].size(); i++) {\n\t\t\t\tint next = list[node].get(i);\n\t\t\t\tsubtreeIndex[next] = i+1;\n\t\t\t\tqueue.add(next);\n\t\t\t}\n\n\t\t\tint nn = list[node].size();\n\t\t\tint[] cnt = new int[nn+1];\n\t\t\tArrays.fill(cnt, 1);\n\n\t\t\t// dp[i][j] is the number of sets of length j from the first i subtrees\n\t\t\tlong[][] dp = new long[nn+1][k+1];\n\t\t\tlong ans = 0;\n\n\t\t\twhile(!queue.isEmpty()) {\n\n\t\t\t\tfor (int i = 0; i <= nn; i++) {\n\t\t\t\t\tfor (int j = 0; j <= i && j <= k; j++) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdp[i][j] = (dp[i-1][j] + (j > 0 ? (dp[i-1][j-1] * cnt[i]) % MOD : 0)) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = (ans + dp[nn][k]) % MOD;\n\n\t\t\t\tfor (int i = queue.size(); i > 0 ; i--) {\n\t\t\t\t\tint curr = queue.remove();\n\t\t\t\t\tcnt[subtreeIndex[curr]]--;\n\t\t\t\t\tfor (int next: list[curr]) {\n\t\t\t\t\t\tif (subtreeIndex[next] == 0) {\n\t\t\t\t\t\t\tcnt[subtreeIndex[curr]]++;\n\t\t\t\t\t\t\tsubtreeIndex[next] = subtreeIndex[curr];\n\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int size) {\n\t\t\tint[] arr = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "/**\n * author: derrick20\n * created: 8/3/21 10:50 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class F_EquidistantVertices {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) {\n        int T = sc.nextInt();\n        while (T-->0) {\n            int N = sc.nextInt();\n            int K = sc.nextInt();\n            adjList = new ArrayList[N];\n            Arrays.setAll(adjList, i -> new ArrayList<>());\n            for (int i = 0; i < N - 1; i++) {\n                int u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n                adjList[u].add(v);\n                adjList[v].add(u);\n            }\n            if (K == 2) {\n                out.println(N * (N - 1) / 2);\n                continue;\n            }\n            long ans = 0;\n            for (int node = 0; node < N; node++) {\n                long[][] depthWays = new long[K + 1][N];\n                Arrays.fill(depthWays[0], 1);\n                for (int adj : adjList[node]) { // this and prev loop sum to 2(N-1)\n                    int[] branchFreq = new int[N];\n                    dfs(adj, node, 0, branchFreq);\n                    // then KN\n                    for (int k = K; k >= 1; k--) {\n                        for (int depth = 0; depth < N; depth++) {\n                            depthWays[k][depth] = (depthWays[k][depth] + depthWays[k - 1][depth] * branchFreq[depth] % mod) % mod;\n                        }\n                    }\n                }\n                // So, O(KN^2)\n                for (int depth = 0; depth < N; depth++) {\n                    ans = (ans + depthWays[K][depth]) % mod;\n                }\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n\n    static ArrayList<Integer>[] adjList;\n    static long mod = (long) 1e9 + 7;\n\n    static void dfs(int node, int par, int depth, int[] freq) {\n        freq[depth]++;\n        for (int adj : adjList[node]) {\n            if (adj != par) {\n                dfs(adj, node, depth + 1, freq);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n    \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n    \n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n    \n        int nextInt() {\n            return (int) nextLong();\n        }\n    \n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n    \n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n    \n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    \n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    \n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nconst int dxx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n          dyy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long mod = 1000000007;\nconst int base = 311;\nconst int N = 105;\nint n, k;\nvector<int> adj[N];\nint h[N];\nvoid dfs(int u, int pre, int &cnt, int len) {\n  if (h[u] == len) cnt++;\n  for (int v : adj[u])\n    if (v != pre) {\n      h[v] = h[u] + 1;\n      dfs(v, u, cnt, len);\n    }\n}\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nvoid gogo() {\n  cin >> n >> k;\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  int ans = 0;\n  if (k == 2)\n    cout << 1LL * n * (n - 1) / 2 << '\\n';\n  else {\n    for (int len = 0; len <= n; ++len) {\n      for (int i = 1; i <= n; ++i) {\n        memset(h, 0, sizeof(h));\n        vector<int> all;\n        for (int u : adj[i]) {\n          int cnt = 0;\n          dfs(u, i, cnt, len);\n          all.push_back(cnt);\n        }\n        vector<int> dp(k + 5);\n        dp[0] = 1;\n        for (int ptr = 0; ptr < (int)all.size(); ++ptr) {\n          vector<int> f(k + 5, 0);\n          for (int j = 0; j <= k; ++j) {\n            if (dp[j] == 0) continue;\n            add(f[j], dp[j]);\n            add(f[j + 1], (long long)dp[j] * all[ptr] % mod);\n          }\n          swap(dp, f);\n        }\n        add(ans, dp[k]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  for (int i = 1; i <= n; ++i) adj[i].clear();\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  if (fopen(\"sol\"\n            \".inp\",\n            \"r\")) {\n    freopen(\n        \"sol\"\n        \".inp\",\n        \"r\", stdin);\n    freopen(\n        \"sol\"\n        \".out\",\n        \"w\", stdout);\n  }\n  int t;\n  cin >> t;\n  while (t--) gogo();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst int N = 1e2 + 10;\nvector<int> v[N];\nvoid dfs(int x, vector<int>& cnt, int fa = 0, int d = 0) {\n  cnt[d]++;\n  for (auto& y : v[x]) {\n    if (y == fa) continue;\n    dfs(y, cnt, x, d + 1);\n  }\n}\nvector<int> multy(vector<int>& v1, vector<int>& v2) {\n  while (v1.size() > 1 && v1.back() == 0) v1.pop_back();\n  while (v2.size() > 1 && v2.back() == 0) v2.pop_back();\n  vector<int> ret(v1.size() + v2.size() - 1);\n  for (int i = 0; i < v1.size(); i++) {\n    for (int j = 0; j < v2.size(); j++) {\n      ret[i + j] = (ret[i + j] + 1LL * v1[i] * v2[j]) % INF;\n    }\n  }\n  return ret;\n}\nint solve(vector<int>& vp, int k) {\n  if (vp.size() < k) return 0;\n  vector<int> ret;\n  ret.push_back(1);\n  for (auto& x : vp) {\n    vector<int> v{1, x};\n    ret = multy(ret, v);\n  }\n  if (ret.size() <= k)\n    return 0;\n  else\n    return ret[k];\n}\nint main() {\n  int ncase;\n  scanf(\"%d\", &ncase);\n  while (ncase--) {\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 1; i <= n; i++) v[i].clear();\n    for (int i = 1; i < n; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    if (k == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      vector<vector<int>> key(n);\n      for (auto& j : v[i]) {\n        vector<int> cnt(n, 0);\n        dfs(j, cnt, i, 0);\n        for (int k = 0; k < n; k++) {\n          if (cnt[k] > 0) key[k].push_back(cnt[k]);\n        }\n      }\n      for (auto& vp : key) {\n        ans += solve(vp, k);\n      }\n    }\n    printf(\"%lld\\n\", ans % INF);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom sys import stdin\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv):\n    return fac[n] * inv[n-r] * inv[r] % mod\n\nfrom collections import deque\n\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    idlis = [None] * n\n    idlis[start] = start\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                if now == start:\n                    idlis[nex] = nex\n                else:\n                    idlis[nex] = idlis[now]\n                q.append(nex)\n\n    return ret,idlis\n\ndef NC_Dij2(lis,u,v):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[u] = 0\n    ret[v] = 0\n    \n    q = deque([u,v])\n    plis = [i for i in range(len(lis))]\n    idlis = [None] * n\n    idlis[u] = u\n    idlis[v] = v\n\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                idlis[nex] = idlis[now]\n                q.append(nex)\n\n    return ret,idlis\n\nmod = 10**9+7\nfac,inv = modfac(200,mod)\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    tmp = stdin.readline()\n    n,k = map(int,stdin.readline().split())\n\n    lis = [ [] for i in range(n) ]\n    uv = []\n\n    for i in range(n-1):\n        u,v = map(int,stdin.readline().split())\n        u -= 1\n        v -= 1\n\n        lis[u].append(v)\n        lis[v].append(u)\n        uv.append((u,v))\n\n    if k == 2:\n        print (n*(n-1)//2 % mod)\n        continue\n\n    ans = 0\n    for st in range(n):\n\n        dlis,idlis = NC_Dij(lis,st)\n        tdic = {}\n        for i in range(n):\n            tup = (dlis[i],idlis[i])\n            if tup not in tdic:\n                tdic[tup] = 0\n            tdic[tup] += 1\n\n        dp = [[0] * (k+1) for i in range(max(dlis)+1)]\n        for i in range(len(dp)):\n            dp[i][0] = 1\n\n        for tup in tdic:\n            nd,nid = tup\n            for j in range(k-1,-1,-1):\n                dp[nd][j+1] += dp[nd][j] * tdic[tup]\n                dp[nd][j+1] %= mod\n\n        for i in range(len(dp)):\n            ans += dp[i][k]\n        \n\n    #print (ans,file=sys.stderr)\n    print (ans % mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f, mod = 1000000007;\nconst double pi = 3.1415926535897932, eps = 1e-6;\nvoid chmax(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid chmin(int &x, int y) {\n  if (x > y) x = y;\n}\nint qpow(int x, int y) {\n  int ret = 1;\n  while (y) {\n    if (y & 1) ret = (long long)ret * x % mod;\n    x = (long long)x * x % mod;\n    y >>= 1;\n  }\n  return ret;\n}\nint T, n, k;\nvector<int> v[105];\nint dis[105][105], C[105][105], siz[105], dp[105][105];\nvector<int> s;\nbool p[105];\nvoid dfs(int x, int fa) {\n  siz[x] = p[x];\n  for (int(i) = (0); (i) < (v[x].size()); (i)++) {\n    int to = v[x][i];\n    if (to == fa) continue;\n    dfs(to, x);\n    siz[x] += siz[to];\n  }\n}\nvoid solve() {\n  for (int(i) = (1); (i) <= (n); (i)++) v[i].clear();\n  scanf(\"%d%d\", &n, &k);\n  for (int(i) = (1); (i) <= (n); (i)++)\n    for (int(j) = (1); (j) <= (n); (j)++) dis[i][j] = inf;\n  for (int(i) = (1); (i) < (n); (i)++) {\n    int t1, t2;\n    scanf(\"%d%d\", &t1, &t2);\n    v[t1].push_back(t2);\n    v[t2].push_back(t1);\n    dis[t1][t2] = dis[t2][t1] = 1;\n  }\n  if (k == 2) {\n    printf(\"%d\\n\", n * (n - 1) / 2);\n    return;\n  }\n  for (int(k) = (1); (k) <= (n); (k)++)\n    for (int(i) = (1); (i) <= (n); (i)++)\n      for (int(j) = (1); (j) <= (n); (j)++)\n        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n  int ans = 0;\n  for (int(root) = (1); (root) <= (n); (root)++) {\n    for (int(d) = (1); (d) <= (n); (d)++) {\n      int num = 0;\n      s.clear();\n      for (int(i) = (1); (i) <= (n); (i)++)\n        if (dis[root][i] == d)\n          p[i] = 1;\n        else\n          p[i] = 0;\n      dfs(root, 0);\n      for (int(i) = (0); (i) < (v[root].size()); (i)++) {\n        int to = v[root][i];\n        if (siz[to]) {\n          num++;\n          s.push_back(siz[to]);\n        }\n      }\n      for (int(i) = (0); (i) <= (num); (i)++)\n        for (int(j) = (0); (j) <= (k); (j)++) dp[i][j] = 0;\n      dp[0][0] = 1;\n      for (int(i) = (1); (i) <= (num); (i)++) {\n        for (int(j) = (0); (j) <= (k); (j)++) {\n          if (j) dp[i][j] += (long long)dp[i - 1][j - 1] * s[i - 1] % mod;\n          dp[i][j] += dp[i - 1][j];\n          if (dp[i][j] >= mod) dp[i][j] -= mod;\n        }\n      }\n      ans += dp[num][k];\n      if (ans >= mod) ans -= mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  C[0][0] = 1;\n  for (int(i) = (1); (i) <= (100); (i)++)\n    for (int(j) = (0); (j) <= (i); (j)++) {\n      C[i][j] = C[i - 1][j];\n      if (j) {\n        C[i][j] += C[i - 1][j - 1];\n        if (C[i][j] >= mod) C[i][j] -= mod;\n      }\n    }\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t, n, ver[210], nxt[210], hed[210], tot = 0, k, f[110][110], dep[110],\n                                              dp[110][110];\nvoid add(long long x, long long y) {\n  ver[++tot] = y, nxt[tot] = hed[x], hed[x] = tot;\n}\nvoid pre() {\n  tot = 0;\n  memset(ver, 0, sizeof(ver));\n  memset(nxt, 0, sizeof(nxt));\n  memset(hed, 0, sizeof(hed));\n}\nvoid dfs(long long x) {\n  for (long long i = hed[x]; i; i = nxt[i])\n    if (!dep[ver[i]]) dep[ver[i]] = dep[x] + 1, dfs(ver[i]);\n}\nvoid dbfs(long long x, long long num) {\n  f[num][dep[x]]++;\n  for (long long i = hed[x]; i; i = nxt[i])\n    if (dep[ver[i]] > dep[x]) dbfs(ver[i], num);\n}\nlong long work(long long x) {\n  memset(dp, 0, sizeof(dp));\n  memset(f, 0, sizeof(f));\n  memset(dep, 0, sizeof(dep));\n  long long cnt = 0, anss = 0;\n  dep[x] = 1;\n  dfs(x);\n  for (int i = hed[x]; i; i = nxt[i]) dbfs(ver[i], ++cnt);\n  for (int i = 2; i <= n; ++i) {\n    long long cntt = 0;\n    for (int j = 1; j <= cnt; ++j)\n      if (f[j][i]) cntt++;\n    if (cntt < k) break;\n    for (int j = 0; j <= cnt; ++j) dp[j][0] = 1;\n    for (long long j = 1; j <= cnt; ++j)\n      for (long long l = 1; l <= j; ++l)\n        dp[j][l] = (dp[j - 1][l] + dp[j - 1][l - 1] * f[j][i] % 1000000007) %\n                   1000000007;\n    anss = (anss + dp[cnt][k]) % 1000000007;\n  }\n  return anss;\n}\nint main() {\n  scanf(\"%lld\", &t);\n  while (t--) {\n    pre();\n    long long ans = 0;\n    scanf(\"%lld%lld\", &n, &k);\n    for (long long i = 1, x, y; i < n; ++i)\n      scanf(\"%lld%lld\", &x, &y), add(x, y), add(y, x);\n    if (k == 2)\n      printf(\"%lld\\n\", n * (n - 1) / 2);\n    else {\n      for (long long i = 1; i <= n; ++i) ans = (ans + work(i)) % 1000000007;\n      printf(\"%lld\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT max3(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <typename T>\nT max4(T a, T b, T c, T d) {\n  return max(max(a, d), max(b, c));\n}\ntemplate <typename T>\nT min3(T a, T b, T c) {\n  return min(a, min(b, c));\n}\ntemplate <typename T>\nT min4(T a, T b, T c, T d) {\n  return min(min(a, d), min(b, c));\n}\ntemplate <typename T>\nT binex(T a, T b, T mod) {\n  T ans = 1;\n  a %= mod;\n  while (b > 0) {\n    if (b & 1) {\n      ans *= a;\n      ans %= mod;\n    }\n    a *= a;\n    a %= mod;\n    b >>= 1;\n  }\n  return ans;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, multiset<T> a) {\n  for (auto x : a) {\n    os << x << \" \";\n  }\n  return os;\n}\ntemplate <class T, class Q>\nostream& operator<<(ostream& os, pair<T, Q> a) {\n  os << \"| \";\n  os << a.first << \", \" << a.second << \" \";\n  return os << \"|\";\n}\ntemplate <class P, class Q, class T>\nostream& operator<<(ostream& os, tuple<P, Q, T> a) {\n  os << \"| \" << (get<0>(a)) << \", \" << (get<1>(a)) << \", \" << (get<2>(a))\n     << \"|\";\n  return os;\n}\nvoid precomp() {}\nvoid solve() {\n  int64_t n, k;\n  cin >> n >> k;\n  vector<vector<int64_t>> edges(n + 1);\n  for (int64_t i = 0; i < n - 1; i++) {\n    int64_t a, b;\n    cin >> a >> b;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << (n * (n - 1)) / 2 << \"\\n\";\n    return;\n  }\n  int64_t fans = 0;\n  for (int64_t i = 1; i <= n; i++) {\n    int64_t root = i;\n    vector<bool> vis(n + 1, false);\n    vis[root] = true;\n    vector<vector<int64_t>> cnt;\n    int64_t maxaa = 0;\n    for (auto x : edges[root]) {\n      queue<int64_t> sto;\n      sto.push(x);\n      vis[x] = true;\n      vector<int64_t> depth(n + 1, -1);\n      int64_t maxa = 0;\n      depth[x] = 0;\n      while (!sto.empty()) {\n        int64_t te = sto.front();\n        sto.pop();\n        vis[te] = true;\n        for (auto x : edges[te]) {\n          if (vis[x]) {\n            continue;\n          }\n          sto.push(x);\n          depth[x] = depth[te] + 1;\n          maxa = depth[x];\n        }\n      }\n      maxaa = max(maxaa, maxa);\n      vector<int64_t> temp(maxa + 1);\n      for (int64_t i = 1; i <= n; i++) {\n        if (depth[i] != -1) {\n          temp[depth[i]]++;\n        }\n      }\n      cnt.push_back(temp);\n    }\n    for (int64_t i = 0; i < cnt.size(); i++) {\n      cnt[i].resize(maxaa + 1);\n    }\n    int64_t ans = 0;\n    for (int64_t i = 0; i < maxaa + 1; i++) {\n      vector<vector<int64_t>> dp(cnt.size(), vector<int64_t>(k + 1));\n      dp[0][0] = 1;\n      dp[0][1] = cnt[0][i];\n      for (int64_t j = 1; j < cnt.size(); j++) {\n        for (int64_t l = 0; l <= k; l++) {\n          dp[j][l] += dp[j - 1][l];\n          dp[j][l] %= int64_t(1000000007);\n          if (l == 0) {\n            continue;\n          }\n          dp[j][l] += dp[j - 1][l - 1] * cnt[j][i];\n          dp[j][l] %= int64_t(1000000007);\n        }\n      }\n      ans += dp[cnt.size() - 1][k];\n      ans %= int64_t(1000000007);\n    }\n    fans += ans;\n    fans %= int64_t(1000000007);\n  }\n  cout << fans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int64_t T;\n  cin >> T;\n  precomp();\n  for (int64_t I = 1; I <= T; I++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 205;\nconst int MOD = 1e9 + 7;\ninline int read() {\n  char c = getchar();\n  int x = 0, f = 1;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = 0;\n  for (; c <= '9' && c >= '0'; c = getchar())\n    x = (x << 1) + (x << 3) + (c ^ 48);\n  return f ? x : -x;\n}\ninline int max(int a, int b) { return a > b ? a : b; }\ninline int min(int a, int b) { return a < b ? a : b; }\nint n, m, num[M][M], f[M][M];\nvector<int> a;\nstruct edge {\n  int v, nxt;\n} ed[M << 1];\nint head[M], cnt_edge;\ninline void add_edge(int u, int v) {\n  ed[++cnt_edge] = (edge){v, head[u]}, head[u] = cnt_edge;\n}\ninline void dfs(int x, int fa) {\n  num[x][0] = 1;\n  for (int i = head[x]; i; i = ed[i].nxt) {\n    int v = ed[i].v;\n    if (v != fa) {\n      dfs(v, x);\n      for (int j = 1; j <= n; j++) num[x][j] += num[v][j - 1];\n    }\n  }\n}\nint main() {\n  int T = read();\n  while (T--) {\n    n = read(), m = read();\n    int ans = 0;\n    cnt_edge = 0;\n    for (int i = 0; i <= n; i++) head[i] = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j <= n; j++) num[i][j] = 0;\n    }\n    for (int i = 1; i < n; i++) {\n      int u = read(), v = read();\n      add_edge(u, v), add_edge(v, u);\n    }\n    if (m == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      continue;\n    }\n    for (int i = 1; i <= n; i++) {\n      dfs(i, 0);\n      for (int j = 1; j <= n; j++) {\n        for (int k = 1; k <= a.size(); k++) {\n          for (int l = 1; l <= k; l++) f[k][l] = 0;\n        }\n        a.clear();\n        for (int l = head[i]; l; l = ed[l].nxt)\n          a.push_back(num[ed[l].v][j - 1]);\n        f[0][0] = 1;\n        for (int k = 1; k <= a.size(); k++) {\n          f[k][0] = 1;\n          for (int l = 1; l <= k; l++)\n            f[k][l] = (f[k - 1][l] + f[k - 1][l - 1] * a[k - 1] % MOD) % MOD;\n        }\n        ans = (ans + f[a.size()][m]) % MOD;\n      }\n      for (int j = 1; j <= n; j++) {\n        for (int l = 0; l <= n; l++) num[j][l] = 0;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<int> V[110];\nint count[110][110][110];\nvoid func(int k, int prev, int top1, int top2, int height) {\n  count[top1][top2][height]++;\n  for (int i = 0; i < V[k].size(); i++) {\n    if (V[k][i] == prev) continue;\n    func(V[k][i], k, top1, top2, height + 1);\n  }\n}\nint x[110];\nlong long int DP[110][110];\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    for (int i = 1; i <= a; i++) V[i].clear();\n    for (int i = 1; i <= a; i++)\n      for (int j = 1; j <= a; j++)\n        for (int k = 0; k <= a; k++) count[i][j][k] = 0;\n    for (int i = 1; i < a; i++) {\n      int c, d;\n      scanf(\"%d%d\", &c, &d);\n      V[c].push_back(d);\n      V[d].push_back(c);\n    }\n    if (b == 2) {\n      printf(\"%d\\n\", a * (a - 1) / 2);\n      continue;\n    }\n    for (int i = 1; i <= a; i++)\n      for (int j = 0; j < V[i].size(); j++) func(V[i][j], i, V[i][j], i, 1);\n    long long int ans = 0;\n    for (int i = 1; i <= a; i++) {\n      if (V[i].size() >= b) {\n        for (int j = 2; j <= a; j += 2) {\n          int t = V[i].size();\n          for (int k = 0; k < t; k++) x[k] = count[V[i][k]][i][j / 2];\n          for (int k = 1; k <= b; k++) DP[t][k] = 0;\n          DP[t][0] = 1;\n          for (int l = t - 1; l >= 0; l--) {\n            for (int k = 0; k <= b; k++) DP[l][k] = DP[l + 1][k];\n            for (int k = 1; k <= b; k++)\n              DP[l][k] += DP[l + 1][k - 1] * x[l], DP[l][k] %= 1000000007;\n          }\n          ans += DP[0][b], ans %= 1000000007;\n        }\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops\")\nlong long md = 1000000007;\nusing namespace std;\ntemplate <typename T>\nT pw(T a, T b) {\n  T c = 1, m = a;\n  while (b) {\n    if (b & 1) c = (c * m);\n    m = (m * m), b /= 2;\n  }\n  return c;\n}\ntemplate <typename T>\nT ceel(T a, T b) {\n  if (a % b == 0)\n    return a / b;\n  else\n    return a / b + 1;\n}\ntemplate <typename T>\nT my_log(T n, T b) {\n  T i = 1, ans = 0;\n  while (1) {\n    if (i > n) {\n      ans--;\n      break;\n    }\n    if (i == n) break;\n    i *= b, ans++;\n  }\n  return ans;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long pwmd(long long a, long long b) {\n  long long c = 1, m = a;\n  while (b) {\n    if (b & 1) c = (c * m) % md;\n    m = (m * m) % md;\n    b /= 2;\n  }\n  return c;\n}\nlong long modinv(long long n) { return pwmd(n, md - 2); }\nlong long inverse(long long i) {\n  if (i == 1) return 1;\n  return (md - ((md / i) * inverse(md % i)) % md + md) % md;\n}\nbool sortbysec(const pair<long long, long long> &a,\n               const pair<long long, long long> &b) {\n  return (a.second < b.second);\n}\nlong long t, n, k, x, y, h = 0;\nvector<long long> adj[101], vis(101), dist(101);\nlong long dis[101][101];\nvoid dfs(long long u) {\n  vis[u] = 1;\n  for (auto s : adj[u]) {\n    if (vis[s]) continue;\n    dist[s] = dist[u] + 1;\n    dis[dist[s]][h]++;\n    dfs(s);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = 0; i < n + 1; i++) adj[i].clear();\n    for (long long i = 0; i < n - 1; i++)\n      cin >> x >> y, adj[x].push_back(y), adj[y].push_back(x);\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    long long ans = 0;\n    for (long long i = 1; i < n + 1; i++) {\n      for (long long j = 1; j < n + 1; j++) vis[j] = 0;\n      if (adj[i].size() < k) continue;\n      long long o = adj[i].size();\n      h = 0;\n      for (long long j = 0; j < n + 1; j++)\n        for (long long p = 0; p < o; p++) dis[j][p] = 0;\n      for (auto w : adj[i]) {\n        dist[w] = 1;\n        dis[1][h]++;\n        for (long long p = 0; p < n + 1; p++) vis[p] = 0;\n        vis[i] = 1;\n        dfs(w), h++;\n      }\n      for (long long j = 1; j < n + 1; j++) {\n        vector<long long> v;\n        for (long long p = 0; p < o; p++) {\n          if (dis[j][p]) v.push_back(dis[j][p]);\n        }\n        if (v.size() < k) continue;\n        long long g = v.size();\n        long long dp[g][k + 1];\n        for (long long dd = 0; dd < g; dd++)\n          for (long long tt = 0; tt < k + 1; tt++) dp[dd][tt] = 0;\n        dp[0][0] = 1, dp[0][1] = v[0];\n        for (long long dd = 1; dd < g; dd++) {\n          dp[dd][0] = 1;\n          for (long long tt = 1; tt < k + 1; tt++) {\n            dp[dd][tt] += dp[dd - 1][tt];\n            dp[dd][tt] %= md;\n            dp[dd][tt] += (dp[dd - 1][tt - 1] * v[dd]) % md;\n            dp[dd][tt] %= md;\n          }\n        }\n        ans = (ans + dp[g - 1][k]) % md;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque\n\nM = 10**9+7\n\ndef gettot(dic,k):\n   \n    nums = []\n    for key in dic:  nums.append(dic[key])\n\n#    print(nums)\n    m = len(nums)\n\n    dp = [[0 for j in range(k+1)] for i in range(m+1)]\n    for i in range(m+1):  dp[i][0] = 1\n    \n\n    for i in range(m-1,-1,-1):\n        for j in range(k+1):\n            if m-i<j:  break\n            dp[i][j] = dp[i+1][j] \n            if j>0: dp[i][j] += nums[i]*dp[i+1][j-1]%M \n            dp[i][j] = dp[i][j]%M\n\n    return dp[0][k]\n\n\n#dic = {0:4,1:3,2:2,3:2}\n#print(gettot(dic,4))\n\n\n\n    \n\n\ndef main(t):\n\n    s = input()\n    n,k = map(int,input().split())\n    neigh = [[] for i in range(n)]\n    for _ in range(n-1):\n        u,v = map(int,input().split())\n        neigh[u-1].append(v-1)\n        neigh[v-1].append(u-1)\n\n    ans = 0\n    if k==2:  \n        print(n*(n-1)//2)\n        return \n\n\n    for root in range(n):\n        queue = deque()\n        layers = [{}]\n      \n        for ele in neigh[root]:\n            queue.append([ele,ele,root,0])\n            layers[0][ele] = 1\n        \n        while queue:\n            [index,ancestor,father,l] = queue.popleft()\n            for nextindex in neigh[index]:\n                if nextindex==father: continue \n                if l+1==len(layers): layers.append({})\n                if ancestor not in layers[l+1]: layers[l+1][ancestor] = 0\n                layers[l+1][ancestor] += 1\n                queue.append([nextindex,ancestor,index,l+1]) \n\n#        print(layers)\n        \n        for dic in layers:\n            if len(dic)<k: break\n            ans += gettot(dic,k)\n            ans = ans%M\n            \n            \n        \n\n    \n\n\n\n\n\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1e9 + 7;\nstd::vector<long long int> v[104];\nlong long int mark[104];\nvoid dfs(long long int in, long long int d,\n         std::map<long long int, long long int> &m) {\n  long long int i, j;\n  mark[in] = 1;\n  m[d]++;\n  d++;\n  for (auto x : v[in]) {\n    if (!mark[x]) {\n      dfs(x, d, m);\n    }\n  }\n}\nlong long int solve(std::vector<long long int> v, long long int k) {\n  long long int i, j, n = ((long long int)v.size());\n  if (n == 0) return 0;\n  long long int dp[n + 2][k + 2];\n  memset(dp, 0, sizeof(dp));\n  for (i = 0; i < n; i++) {\n    for (j = 1; j < k + 1; j++) {\n      if (i == 0) {\n        if (j == 1) dp[i][j] += v[i];\n        break;\n      }\n      if (j == 1) {\n        dp[i][j] += v[i] + dp[i - 1][j];\n        dp[i][j] %= MOD;\n      } else {\n        dp[i][j] += v[i] * dp[i - 1][j - 1] % MOD;\n        dp[i][j] += dp[i - 1][j];\n        dp[i][j] %= MOD;\n      }\n    }\n  }\n  return dp[n - 1][k];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int test = 1;\n  cin >> test;\n  while (test--) {\n    long long int n, k, i, j;\n    cin >> n >> k;\n    for (i = 0; i < n + 1; i++) v[i].clear();\n    for (i = 0; i < n - 1; i++) {\n      long long int a, b;\n      cin >> a >> b;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << \"\\n\";\n      continue;\n    }\n    long long int ans = 0;\n    for (i = 1; i < n + 1; i++) {\n      for (j = 1; j < n + 1; j++) mark[j] = 0;\n      mark[i] = 1;\n      std::vector<long long int> t[n + 1];\n      for (auto x : v[i]) {\n        std::map<long long int, long long int> m;\n        dfs(x, 1, m);\n        for (auto y : m) {\n          t[y.first].push_back(y.second);\n        }\n      }\n      for (j = 1; j < n + 1; j++) {\n        ans += solve(t[j], k);\n        ans %= MOD;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  cerr << \"Time Taken:\" << (float)clock() / CLOCKS_PER_SEC * 1000 << \"ms\"\n       << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nint dp[N][N];\nint cnt[N];\nint dep[N];\nvector<int> v[N];\nconst int mod = 1e9 + 7;\nvoid dfs(int u, int fa, int d) {\n  cnt[d]++;\n  for (auto j : v[u]) {\n    if (j == fa) continue;\n    dfs(j, u, d + 1);\n  }\n}\nvoid solve() {\n  memset(dp, 0, sizeof dp);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) v[i].clear();\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  if (m == 2) {\n    cout << n * (n - 1) / 2 << endl;\n    return;\n  }\n  int ans = 0;\n  for (int root = 1; root <= n; root++) {\n    int ct = 0;\n    for (int dd = 1; dd <= n; dd++) {\n      dp[root][0] = 1;\n      for (auto j : v[root]) {\n        for (int kk = 1; kk <= n; kk++) cnt[kk] = 0;\n        dfs(j, root, 1);\n        if (cnt[dd])\n          for (int k = m; k >= 1; k--)\n            dp[root][k] =\n                (1ll * cnt[dd] * dp[root][k - 1] % mod + dp[root][k]) % mod;\n      }\n      ans = (ans + dp[root][m]) % mod;\n      for (int j = 1; j <= m; j++) dp[root][j] = 0;\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid PV(vector<long long> v) {\n  for (long long i = 0; i < (long long)v.size(); i++) cout << v[i] << \" \";\n  cout << \"\\n\";\n}\nvoid PVV(vector<pair<long long, long long> > v) {\n  for (long long i = 0; i < (long long)v.size(); i++)\n    cout << v[i].first << \" \" << v[i].second << \"\\n\";\n}\nvoid PA(long long v[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cout << v[i] << ' ';\n  cout << \"\\n\";\n}\nvoid IN(long long a[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cin >> a[i];\n}\ninline void op() {}\nconst long long M = 1e9 + 7;\nconst long long IM = 1e18 + 37;\nconst long long N = 1000 + 10;\nvector<long long> v[N];\nmap<long long, long long> cn[N];\nlong long dp[N][N];\nlong long mx = 0;\nlong long n, k;\nvoid dfs(long long x, long long baap, long long col, long long l) {\n  mx = max(mx, l);\n  cn[col][l]++;\n  for (long long it : v[x]) {\n    if (it != baap) dfs(it, x, col, l + 1);\n  }\n}\nlong long solve(long long l, long long k, long long d) {\n  if (l == 0) return (k == 0);\n  if (dp[l][k] != -1) return dp[l][k];\n  return dp[l][k] =\n             (solve(l - 1, k, d) + (solve(l - 1, k - 1, d) * cn[l][d]) % M) % M;\n}\nvoid clear(long long n) {\n  for (long long i = 0; i <= n; i++) fill(dp[i], dp[i] + k + 10, -1);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  op();\n  long long t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = 0; i <= n; i++) {\n      v[i].clear();\n    }\n    for (long long i = 1; i < n; i++) {\n      long long x, y;\n      cin >> x >> y;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    long long ans = 0, col;\n    if (k == 2) {\n      ans = (n * (n - 1) / 2) % M;\n      cout << (ans) << \"\\n\";\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      mx = 0, col = 1;\n      for (long long it : v[i]) dfs(it, i, col++, 1);\n      for (long long dis = 1; dis <= mx; dis++) {\n        clear(col);\n        ans = (ans + solve(col, k, dis)) % M;\n      }\n      for (long long j = 1; j <= col; j++) cn[j].clear();\n    }\n    cout << (ans) << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> g[n + 1];\n  for (long long i = 1; i < n; i++) {\n    long long u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 % mod << \"\\n\";\n    return;\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long len = (long long)g[i].size();\n    vector<vector<long long>> cnt(n + 1, vector<long long>(len + 1));\n    queue<pair<long long, pair<long long, long long>>> q;\n    vector<bool> used(n + 1);\n    used[i] = true;\n    for (long long j = 0; j < len; j++) {\n      used[g[i][j]] = true;\n      q.push({g[i][j], {1, j + 1}});\n      cnt[1][j + 1]++;\n    }\n    while (!q.empty()) {\n      auto cur = q.front();\n      q.pop();\n      long long v = cur.first, depth = cur.second.first,\n                subtree = cur.second.second;\n      for (long long u : g[v]) {\n        if (!used[u]) {\n          used[u] = true;\n          q.push({u, {depth + 1, subtree}});\n          cnt[depth + 1][subtree]++;\n        }\n      }\n    }\n    for (long long depth = 1; depth <= n; depth++) {\n      vector<vector<long long>> dp(len + 1, vector<long long>(k + 1));\n      dp[0][0] = 1;\n      for (long long j = 1; j <= len; j++) {\n        for (long long vers = 0; vers <= k; vers++) {\n          dp[j][vers] += dp[j - 1][vers];\n          if (vers > 0) dp[j][vers] += dp[j - 1][vers - 1] * cnt[depth][j];\n          dp[j][vers] %= mod;\n        }\n      }\n      ans += dp[len][k];\n      ans %= mod;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 105;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst double eps = 1e-6;\nconst double Pi = acos(-1.0);\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nlong long n, k;\nlong long ans;\nvector<int> e[N];\nint deg[N];\nint dep[N][N];\nint cnt[N][N];\nvoid dfs(int rt, int u, int fa) {\n  dep[rt][u] = dep[rt][fa] + 1;\n  cnt[rt][dep[rt][u]]++;\n  for (int v : e[u])\n    if (v != fa) {\n      dfs(rt, v, u);\n    }\n}\nlong long dp[N][N];\nvoid check(int u) {\n  for (int v : e[u]) {\n    dep[v][u] = 0;\n    for (int i = 1; i <= n; ++i) {\n      cnt[v][i] = 0;\n    }\n    dfs(v, v, u);\n  }\n  for (int d = 1; d <= n; ++d) {\n    memset(dp, 0, sizeof dp);\n    dp[0][0] = 1;\n    for (int i = 1; i <= e[u].size(); ++i) {\n      for (int j = 0; j <= k; ++j) {\n        dp[i][j] += dp[i - 1][j];\n      }\n      for (int j = 1; j <= k; ++j) {\n        dp[i][j] += dp[i - 1][j - 1] * cnt[e[u][i - 1]][d] % mod;\n        dp[i][j] %= mod;\n      }\n    }\n    ans += dp[e[u].size()][k];\n    ans %= mod;\n  }\n}\nvoid main0() {\n  int T;\n  cin >> T;\n  while (T--) {\n    ans = 0;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) {\n      e[i].clear();\n      deg[i] = 0;\n    }\n    for (int i = 1; i <= n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      deg[u]++, deg[v]++;\n      e[u].push_back(v);\n      e[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    for (int i = 1; i <= n; ++i) {\n      if (deg[i] >= k) check(i);\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int N = 1e2 + 5;\nint add(int a, int b) {\n  int res = a + b;\n  if (res >= MOD) res -= MOD;\n  return res;\n}\nint mult(int a, int b) {\n  long long res = 1LL * a * b;\n  if (res >= MOD) res %= MOD;\n  return res;\n}\nint ans;\nvector<vector<int>> g;\nint dfs(int node, int p, int dist) {\n  if (dist == 0) return 1;\n  int res = 0;\n  for (auto to : g[node]) {\n    if (to != p) res += dfs(to, node, dist - 1);\n  }\n  return res;\n}\nvector<int> delta;\nvector<vector<int>> dp;\nint max_n;\nint solve(int p, int left) {\n  if (left == 0) return 1;\n  if (p >= max_n) return 0;\n  int &res = dp[p][left];\n  if (~res) return res;\n  res = 0;\n  res = add(res, solve(p + 1, left));\n  res = add(res, mult(delta[p], solve(p + 1, left - 1)));\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    ans = 0;\n    g.clear();\n    g.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n      int st, et;\n      cin >> st >> et;\n      --st;\n      --et;\n      g[st].emplace_back(et);\n      g[et].emplace_back(st);\n    }\n    if (k == 2) {\n      for (int i = n - 1; i >= 1; i--) {\n        ans = add(ans, i);\n      }\n    } else {\n      for (int distance = 1; distance <= n; distance++) {\n        for (int i = 0; i < n; i++) {\n          delta.clear();\n          for (auto to : g[i]) delta.emplace_back(dfs(to, i, distance - 1));\n          max_n = (int)delta.size();\n          if (max_n < k) continue;\n          dp = vector<vector<int>>(max_n, vector<int>(k + 1, -1));\n          ans = add(ans, solve(0, k));\n        }\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\nt=int(input())\nmod=10**9+7\nfor _ in range(t):\n    tmp=input()\n    n,k=map(int,input().split())\n    g=[[] for i in range(n)]\n    for __ in range(n-1):\n        u,v=map(int,input().split())\n        g[u-1].append(v-1)\n        g[v-1].append(u-1)\n    f=[1]*101\n    ans=0\n    def dfs(u,depth):\n        global ans\n        f[u]=0\n        for v in g[u]:\n            if f[v]:\n                dfs(v,depth+1)\n                for j in range(n):\n                    dp[u][j]+=dp[v][j]\n        dp[u][depth]+=1\n        if depth==0:\n            for i in range(n):\n                c=[0]*(k+1)\n                c[0]=1\n                for to in g[u]:\n                    if f[to] and dp[to][i]:\n                        for kk in range(1,k+1)[::-1]:\n                            c[kk]+=c[kk-1]*dp[to][i]%mod\n                            c[kk]%=mod\n                ans=(ans+c[k])%mod\n        f[u]=1\n    for i in range(n):\n        dp=[[0]*n for i in range(n)]\n        dfs(i,0)\n    if k==2:\n        print(n*(n-1)//2)\n    else:\n        print(ans%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nint T, mod = 1e9 + 7, n, k, deep[N], timer, sz;\nlong long ans, fact[N], mem[N][N], vis[N][N];\nvector<int> adj[N], v;\nmap<int, int> mp[N];\nvoid _clear() {\n  ans = 0;\n  for (int i = 1; i <= n; i++) adj[i].clear();\n}\nlong long po(long long x, long long os) {\n  if (os == 0) return 1;\n  long long z = po(x, os / 2);\n  if (os & 1) return z * z % mod * x % mod;\n  return z * z % mod;\n}\nlong long modInv(long long x) { return po(x, mod - 2); }\nlong long c(long long n, long long r) {\n  return fact[n] * modInv(fact[r] * fact[n - r] % mod) % mod;\n}\nvoid dfs(int u, int v) {\n  deep[u] = deep[v] + 1;\n  mp[u][deep[u]]++;\n  for (auto &x : adj[u])\n    if (x != v) {\n      dfs(x, u);\n      for (auto &p : mp[x]) mp[u][p.first] += p.second;\n    }\n}\nlong long dp(int i, int k) {\n  if (k == 0) return 1;\n  if (i == sz) return 0;\n  long long &ret = mem[i][k];\n  if (vis[i][k] == timer) return ret;\n  vis[i][k] = timer;\n  return ret = (dp(i + 1, k) + dp(i + 1, k - 1) * v[i] % mod) % mod;\n}\nlong long calc(int p) {\n  deep[p] = 0;\n  for (int i = 1; i <= n; i++) mp[i].clear();\n  dfs(p, p);\n  long long ret = 0;\n  for (int i = 2; i <= n; i++) {\n    int num = 0;\n    v.clear();\n    for (auto &x : adj[p])\n      if (mp[x].find(i) != mp[x].end()) {\n        num++;\n        v.push_back(mp[x][i]);\n      }\n    if (num < k) continue;\n    timer++;\n    sz = (int)(v.size());\n    ret = (ret + dp(0, k)) % mod;\n  }\n  return ret;\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N; i++) fact[i] = fact[i - 1] * i % mod;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &n, &k);\n    _clear();\n    for (int i = 1; i <= n - 1; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n    if (k == 2) {\n      printf(\"%lld\\n\", c(n, 2));\n      continue;\n    }\n    for (int i = 1; i <= n; i++) ans = (ans + calc(i)) % mod;\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename T1>\nT amax(T &a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT amin(T &a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\nconst long long N = 1e2 + 5;\nlong long freq[N], n, k;\nvector<long long> v[N];\nvoid dfs(long long z, long long p, long long d = 1) {\n  freq[d]++;\n  for (long long x : v[z])\n    if (x ^ p) dfs(x, z, d + 1);\n}\nvoid test_case() {\n  cin >> n >> k;\n  for (long long i = 1; i < n + 1; i++) v[i].clear();\n  for (long long i = 1; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    v[x].push_back(y), v[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << \"\\n\";\n    return;\n  }\n  long long ans = 0;\n  for (long long center = 1; center < n + 1; center++) {\n    vector<vector<long long>> cnt(n + 1);\n    for (long long x : v[center]) {\n      memset(freq, 0, sizeof freq);\n      dfs(x, center);\n      for (long long j = 0; j < n; j++) {\n        if (freq[j]) cnt[j].push_back(freq[j]);\n      }\n    }\n    for (long long dep = 0; dep < n; dep++) {\n      vector<long long> dp(k + 1);\n      dp[0] = 1;\n      for (long long x : cnt[dep]) {\n        for (long long j = k - 1; j >= 0; j--) {\n          dp[j + 1] = (dp[j + 1] + dp[j] * x) % 1000000007;\n        }\n      }\n      ans = (ans + dp[k]) % 1000000007;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  for (long long i = 0; i < t; i++) {\n    test_case();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dx[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nlong long dy[8] = {1, 0, -1, 0, -1, 1, 1, -1};\nclass pa3 {\n public:\n  long long x;\n  long long y, z;\n  pa3(long long x = 0, long long y = 0, long long z = 0) : x(x), y(y), z(z) {}\n  bool operator<(const pa3& p) const {\n    if (x != p.x) return x < p.x;\n    if (y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator>(const pa3& p) const {\n    if (x != p.x) return x > p.x;\n    if (y != p.y) return y > p.y;\n    return z > p.z;\n  }\n  bool operator==(const pa3& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  bool operator!=(const pa3& p) const {\n    return !(x == p.x && y == p.y && z == p.z);\n  }\n};\nclass pa4 {\n public:\n  long long x;\n  long long y, z, w;\n  pa4(long long x = 0, long long y = 0, long long z = 0, long long w = 0)\n      : x(x), y(y), z(z), w(w) {}\n  bool operator<(const pa4& p) const {\n    if (x != p.x) return x < p.x;\n    if (y != p.y) return y < p.y;\n    if (z != p.z) return z < p.z;\n    return w < p.w;\n  }\n  bool operator>(const pa4& p) const {\n    if (x != p.x) return x > p.x;\n    if (y != p.y) return y > p.y;\n    if (z != p.z) return z > p.z;\n    return w > p.w;\n  }\n  bool operator==(const pa4& p) const {\n    return x == p.x && y == p.y && z == p.z && w == p.w;\n  }\n};\nclass pa2 {\n public:\n  long long x, y;\n  pa2(long long x = 0, long long y = 0) : x(x), y(y) {}\n  pa2 operator+(pa2 p) { return pa2(x + p.x, y + p.y); }\n  pa2 operator-(pa2 p) { return pa2(x - p.x, y - p.y); }\n  bool operator<(const pa2& p) const { return y != p.y ? y < p.y : x < p.x; }\n  bool operator>(const pa2& p) const { return x != p.x ? x < p.x : y < p.y; }\n  bool operator==(const pa2& p) const {\n    return abs(x - p.x) == 0 && abs(y - p.y) == 0;\n  }\n  bool operator!=(const pa2& p) const {\n    return !(abs(x - p.x) == 0 && abs(y - p.y) == 0);\n  }\n};\nstring itos(long long i) {\n  ostringstream s;\n  s << i;\n  return s.str();\n}\nlong long Gcd(long long v, long long b) {\n  if (v == 0) return b;\n  if (b == 0) return v;\n  if (v > b) return Gcd(b, v);\n  if (v == b) return b;\n  if (b % v == 0) return v;\n  return Gcd(v, b % v);\n}\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extgcd(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\npair<long long, long long> operator+(const pair<long long, long long>& l,\n                                     const pair<long long, long long>& r) {\n  return {l.first + r.first, l.second + r.second};\n}\npair<long long, long long> operator-(const pair<long long, long long>& l,\n                                     const pair<long long, long long>& r) {\n  return {l.first - r.first, l.second - r.second};\n}\nostream& operator<<(ostream& os, const vector<long long>& VEC) {\n  for (auto v : VEC) os << v << \" \";\n  return os;\n}\nostream& operator<<(ostream& os, const pair<long long, long long>& PAI) {\n  os << PAI.first << \" : \" << PAI.second;\n  return os;\n}\nostream& operator<<(ostream& os, const pa3& PAI) {\n  os << PAI.x << \" : \" << PAI.y << \" : \" << PAI.z;\n  return os;\n}\nostream& operator<<(ostream& os, const pa4& PAI) {\n  os << PAI.x << \" : \" << PAI.y << \" : \" << PAI.z << \" : \" << PAI.w;\n  return os;\n}\nostream& operator<<(ostream& os,\n                    const vector<pair<long long, long long> >& VEC) {\n  for (auto v : VEC) os << v << \" \";\n  return os;\n}\nostream& operator<<(ostream& os, const vector<pa3>& VEC) {\n  for (auto v : VEC) {\n    os << v << \" \";\n    os << endl;\n  }\n  return os;\n}\nlong long beki(long long wa, long long rr, long long warukazu) {\n  if (rr == 0) return 1 % warukazu;\n  if (rr == 1) return wa % warukazu;\n  wa %= warukazu;\n  if (rr % 2 == 1)\n    return ((long long)beki(wa, rr - 1, warukazu) * (long long)wa) % warukazu;\n  long long zx = beki(wa, rr / 2, warukazu);\n  return (zx * zx) % warukazu;\n}\nlong long pr[2521000];\nlong long inv[2521000];\nconst long long mod = 1000000007;\nlong long comb(long long nn, long long rr) {\n  if (rr < 0 || rr > nn || nn < 0) return 0;\n  long long r = pr[nn] * inv[rr];\n  r %= mod;\n  r *= inv[nn - rr];\n  r %= mod;\n  return r;\n}\nvoid gya(long long ert) {\n  pr[0] = 1;\n  for (long long i = 1; i <= ert; i++) {\n    pr[i] = ((long long)pr[i - 1] * i) % mod;\n  }\n  inv[ert] = beki(pr[ert], mod - 2, mod);\n  for (long long i = ert - 1; i >= 0; i--) {\n    inv[i] = (long long)inv[i + 1] * (i + 1) % mod;\n  }\n}\nlong long beki2(long long wa, long long rr) {\n  if (rr == 0) return 1;\n  if (rr == 1) return wa;\n  if (rr % 2 == 1) return ((long long)beki2(wa, rr - 1) * (long long)wa) % mod;\n  long long zx = beki2(wa, rr / 2);\n  return (zx * zx) % mod;\n}\nlong long beki3(long long a, long long b) {\n  long long ANS = 1;\n  long long be = a;\n  while (b) {\n    if (b & 1) {\n      ANS *= be;\n      ANS %= mod;\n    }\n    be *= be;\n    be %= mod;\n    b /= 2;\n  }\n  return ANS;\n}\nvector<long long> G[20002];\nlong long d[200][200] = {};\nvoid dfs(long long r, long long p, long long di, long long it) {\n  d[it][di]++;\n  for (auto v : G[r])\n    if (v != p) dfs(v, r, di + 1, it);\n}\nlong long dp[200][200] = {};\nlong long solve(vector<long long> ve, long long k) {\n  long long n = ve.size();\n  for (long long i = 0; i <= n; i++)\n    for (long long j = 0; j <= n; j++) dp[i][j] = 0;\n  dp[0][0] = 1;\n  for (long long i = 0; i < n; i++)\n    for (long long j = 0; j <= i; j++) {\n      dp[i + 1][j] += dp[i][j];\n      dp[i + 1][j] %= mod;\n      dp[i + 1][j + 1] += dp[i][j] * ve[i] % mod;\n      dp[i + 1][j + 1] %= mod;\n    }\n  return dp[n][k];\n}\nlong long solve(long long r, long long k) {\n  if ((long long)G[r].size() < k) return 0;\n  long long it = 0;\n  for (auto v : G[r]) {\n    dfs(v, r, 0, it);\n    it++;\n  }\n  long long e = G[r].size();\n  long long ans = 0;\n  for (long long kk = 0; kk < 110; kk++) {\n    long long ko = 0;\n    vector<long long> ve;\n    for (long long j = 0; j < e; j++) {\n      if (d[j][kk]) ko++, ve.push_back(d[j][kk]);\n    }\n    if (ko < k) break;\n    ans += solve(ve, k);\n  }\n  for (long long i = 0; i <= 110; i++)\n    for (long long j = 0; j < e; j++) d[j][i] = 0;\n  return ans % mod;\n}\nlong long ke(long long n) {\n  for (long long i = 0; i < n; i++) G[i].clear();\n  return 0;\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long y, yy;\n    cin >> y >> yy;\n    y--, yy--;\n    G[y].push_back(yy);\n    G[yy].push_back(y);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 % mod << endl;\n    ke(n);\n    return;\n  }\n  long long ans = 0;\n  for (long long i = 0; i < n; i++) ans += solve(i, k);\n  ke(n);\n  cout << ans % mod << endl;\n}\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  long long n = 1;\n  cin >> n;\n  for (long long i = 0; i < n; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nint ans;\nvector<vector<int> > g;\nvector<int> cnt;\nint mul(int a, int b) { return ((a * 1LL * b) % mod); }\nvoid add(int& a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nvoid calculate(int t, int k) {\n  vector<vector<int> > dp(t + 1, vector<int>(k + 1));\n  dp[0][0] = 1;\n  for (int tree_no = 1; tree_no <= t; tree_no++) {\n    dp[tree_no][0] = 1;\n    for (int sel = 1; sel <= k; sel++) {\n      add(dp[tree_no][sel], dp[tree_no - 1][sel]);\n      add(dp[tree_no][sel], mul(dp[tree_no - 1][sel - 1], cnt[tree_no]));\n    }\n  }\n  add(ans, dp[t][k]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    g.clear();\n    g.resize(n);\n    ans = 0;\n    for (int i = 0; i < n - 1; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[--u].push_back(--v);\n      g[v].push_back(u);\n    }\n    if (k == 2) {\n      if (n & 1)\n        cout << mul(n, (n - 1) / 2) << '\\n';\n      else\n        cout << mul(n / 2, n - 1) << '\\n';\n      continue;\n    }\n    for (int i = 0; i < n; i++) {\n      int t = g[i].size();\n      vector<int> visited(n);\n      cnt.resize(t + 1);\n      vector<pair<int, int> > layer;\n      visited[i] = 1;\n      for (int j = 0; j < t; j++) {\n        layer.push_back(make_pair(g[i][j], j + 1));\n        cnt[j + 1] = 1;\n        visited[g[i][j]] = 1;\n      }\n      while (!layer.empty()) {\n        calculate(t, k);\n        vector<pair<int, int> > new_layer;\n        while (!layer.empty()) {\n          int v = (layer.back()).first;\n          int tree_no = (layer.back()).second;\n          layer.pop_back();\n          cnt[tree_no]--;\n          for (int child : g[v]) {\n            if (!visited[child]) {\n              visited[child] = 1;\n              new_layer.push_back(make_pair(child, tree_no));\n              cnt[tree_no]++;\n            }\n          }\n        }\n        layer = new_layer;\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\npublic class EdA {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n\tstatic int[] depth;\n\tstatic int[][] depthCount;\n\tstatic ArrayList<ArrayList<Integer>> graph;\n    public static PrintWriter out;\n\tpublic static void main(String[] largewang) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tint t = sc.nextInt();\n \t\twhile (t-->0) {\n \t\t\tgraph = new ArrayList<>();\n \t\t\tint n = sc.nextInt();\n \t\t\tint k = sc.nextInt();\n \t\t\t\n \t\t\tfor(int j =0;j<=n;j++){\n \t\t\t\tgraph.add(new ArrayList<>());\n \t\t\t}\n \t\t\tfor(int j = 0;j<n-1;j++){\n \t\t\t\tint v1 = sc.nextInt();\n \t\t\t\tint v2 = sc.nextInt();\n \t\t\t\tgraph.get(v1).add(v2);\n \t\t\t\tgraph.get(v2).add(v1);\n \t\t\t}\n \t\t\tif (k == 2){\n \t\t\t\tout.println(n*(n-1)/2);\n \t\t\t\tcontinue;\n \t\t\t} \n \t\t\tlong ans = 0;\n \t\t\tfor(int v = 1;v<=n;v++){\n \t\t\t\tdepth = new int[n+1];\n \t\t\t\tdepthCount = new int[graph.get(v).size()][101];\n \t\t\t\tlong[][][] power = new long[graph.get(v).size()][101][k+1];\n \t\t\t\t\n \t\t\t\tint count = 0;\n \t\t\t\tfor(int j : graph.get(v)){\n \t\t\t\t\tdfs(j, v, count);\n \t\t\t\t\tcount++;\n \t\t\t\t}\n \t\t\t\tfor(int a = 0;a<graph.get(v).size();a++){\n \t\t\t\t\tfor(int b = 0;b<=100;b++){\n \t\t\t\t\t\tpower[a][b][0] = 1;\n \t\t\t\t\t\tfor(int c = 1;c<=k;c++){\n \t\t\t\t\t\t\tpower[a][b][c] = power[a][b][c-1]*depthCount[a][b];\n \t\t\t\t\t\t\tpower[a][b][c] %= mod;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (graph.get(v).size() < k)\n \t\t\t\t\tcontinue;\n \t\t\t\tfor(int j = 1;j<=100;j++){\n \t\t\t\t\tlong[] p = new long[k+1];\n \t\t\t\t\tlong[] s = new long[k+1];\n \t\t\t\t\tp[0] = graph.get(v).size();\n \t\t\t\t\tfor(int q = 1;q<=k;q++){//which P_\n \t\t\t\t\t\tfor(int e = 0;e<graph.get(v).size();e++){\n \t\t\t\t\t\t\tp[q] += power[e][j][q];\n \t\t\t\t\t\t\tp[q] %= mod;\n \t\t\t\t\t\t}\n \t\t\t\t\t\ts[q] = p[q];\n \t\t\t\t\t\tint sign = 1;\n \t\t\t\t\t\tfor(int e = 1;e<=q-1;e++){\n \t\t\t\t\t\t\ts[q] -= sign*p[q-e]*s[e];\n \t\t\t\t\t\t\ts[q] %= mod;\n \t\t\t\t\t\t\ts[q] += mod;\n \t\t\t\t\t\t\ts[q] %= mod;\n \t\t\t\t\t\t\tsign = -sign;\n \t\t\t\t\t\t}\n \t\t\t\t\t\ts[q] *= sign;\n \t\t\t\t\t\ts[q] %= mod;\n \t\t\t\t\t\ts[q] += mod;\n \t\t\t\t\t\ts[q] %= mod;\n \t\t\t\t\t\ts[q] *= inv(q);\n \t\t\t\t\t\ts[q] %= mod;\n \t\t\t\t\t}\n \t\t\t\t\tans += s[k];\n \t\t\t\t\tans %= mod;\n \t\t\t\t}\n \t\t\t\t\n \t\t\t}\n \t\t\tout.println(ans);\n \t\t}\n \t\tout.close();\n \t\t\n \t}\n\tpublic static long inv(long n){\n\t\treturn power(n, mod-2);\n\t}\n\tpublic static void dfs(int v, int p, int k){\n\t\tdepth[v] = depth[p] + 1;\n\t\tdepthCount[k][depth[v]]++;\n\t\tfor(int child : graph.get(v)){\n\t\t\tif (child == p)\n\t\t\t\tcontinue;\n\t\t\tdfs(child, v, k);\n\t\t}\n\t}\n \t\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7, mod = 1e9 + 7;\nlong long dp[105][105], ans;\nvector<int> G[105], d;\nint n, k, mx;\nvoid dfs(int x, int f, int dep) {\n  ++d[dep];\n  if (dep > mx) mx = dep;\n  for (int i : G[x]) {\n    if (i == f) continue;\n    dfs(i, x, dep + 1);\n  }\n}\ninline void solve() {\n  cin >> n >> k;\n  ans = 0;\n  for (int i = 1; i <= n; ++i) G[i].clear();\n  for (int i = 2, x, y; i <= n; ++i) {\n    cin >> x >> y;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  vector<int> t(n + 1);\n  for (int root = 1; root <= n; ++root) {\n    vector<vector<int> > v;\n    mx = 0;\n    for (int x : G[root]) {\n      d = t;\n      dfs(x, root, 1);\n      v.emplace_back(d);\n    }\n    int m = v.size();\n    if (m < k) continue;\n    for (int i = 1; i <= mx; ++i) {\n      vector<int> p;\n      int q = 0;\n      for (auto &x : v) p.emplace_back(x[i]), q |= x[i];\n      if (!q) break;\n      for (int j = 1; j <= m; ++j)\n        for (int x = 0; x <= k; ++x) dp[j][x] = 0;\n      dp[0][0] = 1;\n      for (int j = 1; j <= m; ++j) {\n        for (int x = 0; x <= k; ++x) dp[j][x] = dp[j - 1][x];\n        for (int x = 1; x <= k; ++x)\n          dp[j][x] = (dp[j][x] + dp[j - 1][x - 1] * p[j - 1]) % mod;\n      }\n      ans = (ans + dp[m][k]) % mod;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int _ = 1;\n  cin >> _;\n  while (_--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 100 + 10;\nconst long long mod = 1e9 + 7;\nvector<long long> G[N];\nlong long deep[N], st[N][N], n, k;\nvoid dfs(long long u, long long father, long long rt) {\n  deep[u] = deep[father] + 1;\n  st[rt][deep[u]]++;\n  for (auto v : G[u]) {\n    if (v == father) continue;\n    dfs(v, u, rt);\n  }\n}\nlong long f[N][N], w[N];\nvoid upd(long long &x, long long y) { x = (x + y) % mod; }\nlong long DP() {\n  for (long long i = 1; i <= w[0]; i++)\n    for (long long j = 0; j <= i && j <= k; j++) f[i][j] = 0;\n  f[0][0] = 1;\n  for (long long i = 1; i <= w[0]; i++)\n    for (long long j = 0; j <= i && j <= k; j++) {\n      if (j) upd(f[i][j], f[i - 1][j - 1] * w[i] % mod);\n      upd(f[i][j], f[i - 1][j]);\n    }\n  return f[w[0]][k];\n}\nsigned main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (long long i = 1; i < n; i++) {\n      long long l, r;\n      scanf(\"%lld%lld\", &l, &r);\n      G[l].push_back(r);\n      G[r].push_back(l);\n    }\n    if (k == 2)\n      cout << n * (n - 1) / 2 << endl;\n    else {\n      long long res = 0;\n      for (long long i = 1; i <= n; i++) {\n        deep[i] = 0;\n        for (auto v : G[i]) dfs(v, i, v);\n        for (long long j = 1; j <= n; j++) {\n          w[0] = 0;\n          for (auto v : G[i]) w[++w[0]] = st[v][j];\n          res = (res + DP()) % mod;\n        }\n        for (auto v : G[i])\n          for (long long j = 1; j <= n; j++) st[v][j] = 0;\n      }\n      cout << res << endl;\n    }\n    for (long long i = 1; i <= n; i++) G[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A, class B>\nostream& operator<<(ostream& out, const pair<A, B>& p) {\n  return out << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& v) {\n  out << \"[\";\n  for (int i = 0; i < v.size(); ++i) {\n    if (i) out << \", \";\n    out << v[i];\n  }\n  return out << \"]\";\n}\nconst int N = 106;\nint n, k;\nconst long long MOD = 1e9 + 7;\nlong long mul(long long o1, long long o2) { return o1 * o2 % MOD; }\nvector<int> adj[N];\nvector<int> dis[N];\nvoid init() {\n  for (int i = (0); i < (n); ++i) {\n    vector<int>().swap(adj[i]);\n    vector<int>().swap(dis[i]);\n    dis[i].resize(N);\n  }\n}\nvector<int> cnt;\nlong long getDP(int sub) {\n  long long dp[N][N];\n  for (int i = (0); i < (sub + 1); ++i) {\n    for (int j = (0); j < (k + 1); ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (int i = (0); i < (sub); ++i) {\n    for (int j = 0; j <= k; ++j) {\n      dp[i + 1][j] += dp[i][j];\n      dp[i + 1][j] %= MOD;\n      dp[i + 1][j + 1] += mul(dp[i][j], cnt[i]);\n      dp[i + 1][j + 1] %= MOD;\n    }\n  }\n  return dp[sub][k];\n}\nvoid sol() {\n  cin >> n >> k;\n  for (int i = (0); i < (n); ++i) {\n    dis[i].resize(n);\n  }\n  for (int i = (1); i < (n); ++i) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    --y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  long long ans = 0;\n  if (k == 2) {\n    ans = (1ll * n * (n - 1) / 2) % MOD;\n  } else {\n    bool vis[n];\n    for (int center = (0); center < (n); ++center) {\n      for (int i = (0); i < (n); ++i) {\n        vis[i] = false;\n      }\n      vis[center] = true;\n      vector<pair<int, int> > layer;\n      vector<int>(n).swap(cnt);\n      int sz = adj[center].size();\n      for (int i = (0); i < (sz); ++i) {\n        vis[adj[center][i]] = true;\n        layer.emplace_back(i, adj[center][i]);\n        cnt[i] = 1;\n      }\n      while (!layer.empty()) {\n        ans += getDP(sz);\n        ans %= MOD;\n        vector<pair<int, int> > next_layer;\n        for (pair<int, int> e : layer) {\n          --cnt[e.first];\n          for (int to : adj[e.second]) {\n            if (vis[to]) continue;\n            ++cnt[e.first];\n            next_layer.emplace_back(e.first, to);\n            vis[to] = true;\n          }\n        }\n        swap(next_layer, layer);\n        vector<pair<int, int> >().swap(next_layer);\n      }\n    }\n  }\n  cout << ans << endl;\n  init();\n}\nint main(int argc, char const* argv[]) {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  for (; t; --t) {\n    sol();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int pct(long long x) { return __builtin_popcountll(x); }\nconstexpr int bits(int x) { return x == 0 ? 0 : 31 - __builtin_clz(x); }\nconstexpr int bits(long long x) { return x == 0 ? 0 : 63 - __builtin_clzll(x); }\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\ntemplate <class T, class U>\nT ipow(T a, U p) {\n  T ans = 1;\n  assert(p >= 0);\n  for (; p; p /= 2, a *= a)\n    if (p & 1) ans *= a;\n  return ans;\n}\ntemplate <class T, class U>\nT ipow(T a, U p, T m) {\n  T ans = 1;\n  assert(p >= 0);\n  for (; p; p /= 2, a = (a * a) % m)\n    if (p & 1) ans = (ans * a) % m;\n  return ans;\n}\ntemplate <class T, class U>\nT fstTrue(T lo, T hi, U f) {\n  hi++;\n  assert(lo <= hi);\n  while (lo < hi) {\n    T mid = lo + (hi - lo) / 2;\n    f(mid) ? hi = mid : lo = mid + 1;\n  }\n  return lo;\n}\ntemplate <class T, class U>\nT lstTrue(T lo, T hi, U f) {\n  lo--;\n  assert(lo <= hi);\n  while (lo < hi) {\n    T mid = lo + (hi - lo + 1) / 2;\n    f(mid) ? lo = mid : hi = mid - 1;\n  }\n  return lo;\n}\ntemplate <class T>\nT sum(vector<T> &v) {\n  if (v.empty()) return 0LL;\n  T sum = v[0];\n  for (int i = 1; i < (int)v.size(); i++) {\n    sum += v[i];\n  }\n  return sum;\n}\ntemplate <class F>\nF posmod(F a, F b) {\n  return ((a % b) + b) % b;\n}\ntemplate <class F>\nstruct Point {\n  F x, y;\n  Point() : x(0), y(0) {}\n  Point(const F &cx, const F &cy) : x(cx), y(cy) {}\n};\ntemplate <class F>\nF ceildiv(F a, F d) {\n  F res = a / d;\n  if (res * d != a) res += 1 & ((a < 0) ^ (d > 0));\n  return res;\n}\ntemplate <class F>\nF sq(F a) {\n  return a * a;\n}\nlong long inv(long long a, long long b) {\n  return 1 < a ? b - inv(b % a, a) * b / a : 1;\n}\ntemplate <class T>\nbool ckmin(T &a, const T &b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\nint rint(int a, int b) { return uniform_int_distribution<int>(a, b)(rng); }\ndouble rdouble(double a, double b) {\n  return uniform_real_distribution<double>(a, b)(rng);\n}\ntemplate <class T>\nvoid remdup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), end(v));\n}\ntemplate <class F>\nvoid print(const Point<F> &point) {\n  cout << \"x: \" << point.x << \"\\ty: \" << point.y << '\\n';\n}\ntemplate <class F>\nvoid print(const vector<F> &a) {\n  for (int i = 0; i < (int)a.size(); i++) {\n    if (i > 0) {\n      cout << ' ';\n    }\n    cout << a[i];\n  }\n  cout << '\\n';\n}\ntemplate <class F>\nvoid print2(const vector<vector<F>> &a) {\n  for (int i = 0; i < (int)a.size(); i++) {\n    for (int j = 0; j < (int)a[i].size(); j++) {\n      if (j > 0) {\n        cout << ' ';\n      }\n      cout << a[i][j];\n    }\n    cout << '\\n';\n  }\n}\ntemplate <class F>\nvoid fill2(vector<vector<F>> &a, F val) {\n  for (int i = 0; i < (int)a.size(); i++) {\n    for (int j = 0; j < (int)a[i].size(); j++) {\n      a[i][j] = val;\n    }\n  }\n}\ntemplate <class F>\nvoid fill3(vector<vector<vector<F>>> &a, F val) {\n  for (int i = 0; i < (int)a.size(); i++) {\n    for (int j = 0; j < (int)a[i].size(); j++) {\n      for (int k = 0; k < (int)a[i][j].size(); k++) {\n        a[i][j][k] = val;\n      }\n    }\n  }\n}\nint gen_base(const int before, const int after) {\n  int base = rint(before + 1, after);\n  return base % 2 == 0 ? base - 1 : base;\n}\nstruct phash {\n  static const int mod = (int)1e9 + 123;\n  static vector<int> pow1;\n  static vector<ull> pow2;\n  static int base;\n  vector<int> pref1;\n  vector<ull> pref2;\n  phash(const string &s)\n      : pref1(int((s).size()) + 1u, 0), pref2(int((s).size()) + 1u, 0) {\n    assert(base < mod);\n    const int n = int((s).size());\n    while (int((pow1).size()) <= n) {\n      pow1.push_back((int)((ll)pow1.back() * base % mod));\n      pow2.push_back(pow2.back() * base);\n    }\n    for (int i = 0; i < n; i++) {\n      assert(base > s[i]);\n      pref1[i + 1] = (int)((pref1[i] + (ll)s[i] * pow1[i]) % mod);\n      pref2[i + 1] = pref2[i] + s[i] * pow2[i];\n    }\n  }\n  inline std::pair<int, ull> operator()(const int pos, const int len,\n                                        int mxPow = -1) const {\n    if (mxPow == -1) mxPow = (int)pref1.size() - 1;\n    int hash1 = pref1[pos + len] - pref1[pos];\n    ull hash2 = pref2[pos + len] - pref2[pos];\n    if (hash1 < 0) hash1 += mod;\n    if (mxPow != 0) {\n      hash1 = (int)((ll)hash1 * pow1[mxPow - (pos + len - 1)] % mod);\n      hash2 *= pow2[mxPow - (pos + len - 1)];\n    }\n    return {hash1, hash2};\n  }\n};\nvector<int> phash::pow1{1};\nvector<ull> phash::pow2{1};\nint phash::base = gen_base(256, phash::mod);\nvector<vector<int>> adj;\nint n, k;\nvoid depth(int u, int p, int d, vector<int> &depths) {\n  depths[d]++;\n  for (auto &v : adj[u]) {\n    if (v != p) {\n      depth(v, u, d + 1, depths);\n    }\n  }\n}\nll dp[100][100];\nll comb(vector<int> &tot, int i, int rem) {\n  if (rem == 0) return 1;\n  if (i == int((tot).size()) - 1) {\n    if (tot[i] == 0) return 1;\n    return tot[i];\n  } else {\n    if (dp[i][rem] != -1) return dp[i][rem];\n    ll t = tot[i] * comb(tot, i + 1, rem - 1);\n    t %= (int)(1e9 + 7);\n    if (int((tot).size()) - (i + 1) >= rem) {\n      t += comb(tot, i + 1, rem);\n    }\n    t %= (int)(1e9 + 7);\n    dp[i][rem] = t;\n    return t;\n  }\n}\nll value(vector<vector<int>> &depths) {\n  ll tot = 0;\n  for (int z = 0; z < (101); ++z) {\n    int sum = 0;\n    vector<int> act;\n    for (int i = 0; i < (int((depths).size())); ++i) {\n      if (depths[i][z] != 0) {\n        sum += depths[i][z];\n        act.push_back(depths[i][z]);\n      }\n    }\n    if (sum == 0 || int((act).size()) < k) return tot;\n    for (int i = 0; i < (int((act).size())); ++i) {\n      for (int j = 0; j < (k + 1); ++j) {\n        dp[i][j] = -1;\n      }\n    }\n    tot += comb(act, 0, k);\n  }\n  return tot;\n}\nll calc(int u) {\n  vector<vector<int>> depths;\n  for (auto &v : adj[u]) {\n    vector<int> dv(100, 0);\n    depth(v, u, 0, dv);\n    depths.push_back(dv);\n  }\n  return value(depths);\n}\nll calcedge(int u, int v) {\n  vector<vector<int>> depths;\n  vector<int> d1(100, 0);\n  depth(v, u, 0, d1);\n  depths.push_back(d1);\n  vector<int> d2(100, 0);\n  depth(u, v, 0, d2);\n  depths.push_back(d2);\n  sort((depths).begin(), (depths).end());\n  return value(depths);\n}\nvoid solve() {\n  cin >> n >> k;\n  adj.assign(n, vector<int>());\n  for (int i = 0; i < (n - 1); ++i) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  ll ans = 0;\n  for (int i = 0; i < (n); ++i) {\n    ans += calc(i);\n    ans %= (int)(1e9 + 7);\n  }\n  for (int u = 0; u < (n); ++u) {\n    for (auto &v : adj[u]) {\n      if (v > u) continue;\n      ans += calcedge(u, v);\n      ans %= (int)(1e9 + 7);\n    }\n  }\n  cout << ans << '\\n';\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\ndef memoize(function):\n    cache = {}\n    def decorated_function(*args):\n        try:\n            return cache[args]\n        except KeyError:\n            val = function(*args)\n            cache[args] = val\n            return val\n    return decorated_function\n\n@memoize\ndef inverseMod(n, mod):\n    if 1 == n: return 1\n\n    return ((mod - mod//n) * inverseMod(mod % n, mod)) % mod\n\nM = 10**9 + 7\n\nF = [1, 1]\nfor n in range(2, 10**5 + 1):\n    F.append((F[-1] * n) % M)\n\nRF = [1, 1]\nfor n in range(2, 10**5 + 1):\n    RF.append((RF[-1] * inverseMod(n, M)) % M)\n\ndef C(n, k):\n    return (F[n] * RF[n - k] * RF[k]) % M\n\ndef count(Q, k):\n    size = len(Q)\n    dp = [[0] * size for _ in range(k + 1)]\n    for used in range(size):\n        dp[0][used] = 1\n\n    for taken in range(1, k + 1):\n        for used in range(taken - 1, size):\n            dp[taken][used] = (dp[taken][used - 1] + dp[taken - 1][used - 1]*len(Q[used])) % M\n            \n#    for d in dp:\n#        print(d)\n    return dp[k][size - 1]\n\n#print(\"!\", count([[14], [51], [17]], 3))\n\n#exit(2)\n\nT = int(input())\n\nfor _ in range(T):\n    input()\n    n, k = map(int, input().split(' '))\n\n    G = defaultdict(list)\n    for _ in range(n - 1):\n        s, e = map(int, input().split(' '))\n        G[s].append(e)\n        G[e].append(s)\n\n    if k == 2:\n        r = C(n, k)\n    else:\n        r = 0\n        for s in range(1, n + 1):\n            Q = [[g] for g in G[s]]\n            r += count(Q, k)\n\n            V = {s}\n            while len(Q) > 0:\n                nQ = []\n                for sq in Q:\n                    nsq = []\n                    for e in sq:\n                        V.add(e)\n                        for g in G[e]:\n                            if g not in V:\n                                nsq.append(g)\n                    if len(nsq) > 0:\n                        nQ.append(nsq)\n\n                if len(nQ) >= k:\n                    r += count(nQ, k)\n                if len(nQ) <= 1:\n                    break\n                Q = nQ\n\n    print(r % M)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long dp[2000];\nint binpow(long long base, long long pow) {\n  if (pow == 0) return 1;\n  long long half = binpow(base, pow / 2);\n  long long ret = (half * half) % mod;\n  if (pow % 2 == 1) ret *= base;\n  return ret % mod;\n}\nlong long choose(long long a, long long b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  long long ret = dp[a];\n  long long denom = (dp[a - b] * dp[b]) % mod;\n  ret *= binpow(denom, mod - 2);\n  ret %= mod;\n  return ret;\n}\nint main() {\n  dp[0] = 1;\n  for (int i = 1; i < 2000; i++) {\n    dp[i] = (dp[i - 1] * i) % mod;\n  }\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int T, N, K, u, v;\n  cin >> T;\n  while (T--) {\n    cin >> N >> K;\n    long long ret = 0;\n    vector<int> adj[N + 1];\n    for (int i = 0; i < N - 1; i++) {\n      cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    for (int i = 1; i <= N; i++) {\n      if (adj[i].size() < K) continue;\n      vector<pair<long long, int> > bfs;\n      vector<int> vis;\n      vis.resize(N + 1);\n      vis[i] = 1;\n      for (int n : adj[i]) {\n        bfs.push_back(pair<long long, int>(n, n));\n      }\n      while (!bfs.empty()) {\n        unordered_map<int, int> sz;\n        vector<pair<long long, int> > step;\n        for (pair<long long, int> j : bfs) {\n          sz[j.second]++;\n          vis[j.first] = 1;\n          for (int n : adj[j.first]) {\n            if (!vis[n]) step.push_back(pair<long long, int>(n, j.second));\n          }\n        }\n        if (sz.size() < K) {\n          break;\n        }\n        int second = sz.size();\n        vector<int> all;\n        for (auto i : sz) {\n          all.push_back(i.second);\n        }\n        long long dp[second + 1][K + 1];\n        for (int i = 0; i <= second; i++) {\n          for (int j = 0; j <= K; j++) {\n            dp[i][j] = (j == 0);\n          }\n        }\n        for (int i = 1; i <= second; i++) {\n          for (int j = 1; j <= K; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j != 0) dp[i][j] += dp[i - 1][j - 1] * all[i - 1];\n            dp[i][j] %= mod;\n          }\n        }\n        ret += dp[second][K];\n        ret %= mod;\n        swap(step, bfs);\n      }\n    }\n    cout << (K == 2 ? (N) * (N - 1) / 2 : ret) << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, c[105][105], d[105], u[105], f[105][105];\nvector<int> e[105];\nvoid dfs(int x, int fa) {\n  d[x] = d[fa] + 1;\n  u[d[x]]++;\n  for (int y : e[x])\n    if (y != fa) dfs(y, x);\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) e[i].clear();\n  for (int i = 1; i <= n - 1; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    e[x].push_back(y);\n    e[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << 1LL * n * (n - 1) / 2 << endl;\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    memset(f, 0, sizeof(f));\n    for (int j = 1; j <= n; j++) f[j][0] = 1;\n    d[i] = 0;\n    for (int y : e[i]) {\n      memset(u, 0, sizeof(u));\n      dfs(y, i);\n      for (int j = 1; j <= n; j++)\n        for (int w = k; w >= 1; w--)\n          f[j][w] = (f[j][w] + 1LL * u[j] * f[j][w - 1]) % 1000000007;\n    }\n    for (int j = 1; j <= n; j++) ans = (ans + f[j][k]) % 1000000007;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<long long>;\ntemplate <typename T>\nstd::istream& operator>>(std::istream& input, std::pair<T, T>& data) {\n  input >> data.first >> data.second;\n  return input;\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& input, std::vector<T>& data) {\n  for (T& first : data) input >> first;\n  return input;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& output, const pair<T, T>& data) {\n  output << \"(\" << data.first << \",\" << data.second << \")\";\n  return output;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& output, const std::vector<T>& data) {\n  for (const T& first : data) output << first << \" \";\n  return output;\n}\nlong long div_up(long long a, long long b) {\n  return a / b + ((a ^ b) > 0 && a % b);\n}\nlong long div_down(long long a, long long b) {\n  return a / b - ((a ^ b) < 0 && a % b);\n}\nlong long math_mod(long long a, long long b) { return a - b * div_down(a, b); }\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nlong long gcd(long long a, long long b) {\n  while (b) {\n    tie(a, b) = make_pair(b, a % b);\n  }\n  return a;\n}\nlong long Bit(long long mask, long long bit) { return (mask >> bit) & 1; }\ntemplate <long long MOD, long long RT>\nstruct mint {\n  static const long long mod = MOD;\n  static constexpr mint rt() { return RT; }\n  long long v;\n  explicit operator long long() const { return v; }\n  mint() { v = 0; }\n  mint(long long _v) {\n    v = (long long)((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const mint& a, const mint& b) { return a.v == b.v; }\n  friend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n  friend bool operator<(const mint& a, const mint& b) { return a.v < b.v; }\n  friend string ts(mint a) { return to_string(a.v); }\n  mint& operator+=(const mint& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  mint& operator*=(const mint& m) {\n    v = (long long)((long long)v * m.v % MOD);\n    return *this;\n  }\n  mint& operator/=(const mint& m) { return (*this) *= inv(m); }\n  friend mint pow(mint a, long long p) {\n    mint ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  mint& operator^=(const long long& p) { return (*this) = pow(this, p); }\n  friend mint inv(const mint& a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  mint operator-() const { return mint(-v); }\n  mint& operator++() { return *this += 1; }\n  mint& operator--() { return *this -= 1; }\n  friend mint operator+(mint a, const mint& b) { return a += b; }\n  friend mint operator-(mint a, const mint& b) { return a -= b; }\n  friend mint operator*(mint a, const mint& b) { return a *= b; }\n  friend mint operator/(mint a, const mint& b) { return a /= b; }\n  friend mint operator^(mint a, const long long p) { return pow(a, p); }\n};\nconst long long MOD = 1e9 + 7;\ntypedef mint<MOD, 5> mi;\nstd::ostream& operator<<(std::ostream& o, const mi& a) {\n  cout << a.v;\n  return o;\n}\nvector<vector<mi> > scmb;\nvoid genComb(long long SZ) {\n  scmb.assign(SZ, vector<mi>(SZ));\n  scmb[0][0] = 1;\n  for (long long i = (1); i < (SZ); ++i)\n    for (long long j = (0); j < (i + 1); ++j)\n      scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\nvector<mi> invs, fac, ifac;\nvoid genFac(long long SZ) {\n  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);\n  invs[1] = fac[0] = ifac[0] = 1;\n  for (long long i = (2); i < (SZ); ++i)\n    invs[i] = mi(-(long long)MOD / i * (long long)invs[MOD % i]);\n  for (long long i = (1); i < (SZ); ++i) {\n    fac[i] = fac[i - 1] * i;\n    ifac[i] = ifac[i - 1] * invs[i];\n  }\n}\nmi comb(long long a, long long b) {\n  if (a < b || b < 0) return 0;\n  assert(a < fac.size());\n  return fac[a] * ifac[b] * ifac[a - b];\n}\nconst long long N = 3e6 + 7;\nvoid sol() {\n  long long k, n;\n  cin >> n >> k;\n  vector<vector<long long> > w(n + 3);\n  long long a, b;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> a >> b;\n    w[a - 1].push_back(b - 1);\n    w[b - 1].push_back(a - 1);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << \"\\n\";\n    return;\n  }\n  mi ans = 0;\n  for (long long i = 0; i < n; i++) {\n    ;\n    vector<long long> dist(n, -1);\n    dist[i] = 0;\n    vector<long long> subtree(n, -1);\n    subtree[i] = i + 1;\n    deque<long long> q;\n    q.push_back(i);\n    ;\n    while (q.size() != 0) {\n      long long ver = q.front();\n      q.pop_front();\n      for (auto to : w[ver]) {\n        if (dist[to] == -1) {\n          dist[to] = 1 + dist[ver];\n          q.push_back(to);\n          if (ver == i)\n            subtree[to] = to + 1;\n          else\n            subtree[to] = subtree[ver];\n        }\n      }\n    };\n    vector<vector<long long> > dist_subtree(n, vector<long long>(n + 1));\n    for (long long ij = 0; ij < n; ij++) {\n      dist_subtree[dist[ij]][subtree[ij]]++;\n    }\n    for (long long loc_dist = 1; loc_dist < n; loc_dist++) {\n      long long not0 = 0;\n      for (long long ij = 0; ij <= n; ij++) {\n        if (dist_subtree[loc_dist][ij] != 0) not0++;\n      }\n      if (not0 < k) continue;\n      vector<mi> X(n + 1);\n      X[0] = 1;\n      vector<mi> Y(n + 1);\n      vector<mi> deg(n + 1);\n      for (long long ij = 0; ij <= n; ij++) {\n        deg[ij] = dist_subtree[loc_dist][ij];\n      };\n      for (long long l = 1; l <= n; l++) {\n        for (auto el : deg) Y[l] += el;\n        mi sign_ = 1;\n        mi sum = 0;\n        for (long long j = l - 1; j >= 0; j--) {\n          sum += sign_ * X[j] * Y[l - j];\n          sign_ = -sign_;\n        }\n        X[l] = sum / mi(l);\n        for (long long ij = 0; ij <= n; ij++) {\n          deg[ij] *= dist_subtree[loc_dist][ij];\n        }\n      }\n      ans += X[k];\n    }\n  }\n  cout << ans << \"\\n\";\n}\nvoid FastIO() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n}\nsigned main() {\n  genFac(N);\n  FastIO();\n  long long tst;\n  cin >> tst;\n  while (tst--) {\n    sol();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst int INF = INT_MAX;\nconst long long LLINF = 1000000000000000000LL;\nconst long long MAX = 105;\nconst long long MOD = 1000000007;\nlong long N, K, deg;\nlong long tree[MAX][MAX];\nlong long cache[MAX][MAX];\nvector<int> adj[MAX];\nbool visited[MAX];\nvoid sub(long long i, long long d, long long idx) {\n  tree[i][d]++;\n  visited[idx] = true;\n  for (auto& it : adj[idx]) {\n    if (!visited[it]) {\n      sub(i, d + 1, it);\n    }\n  }\n}\nlong long DP(long long n, long long k, long long d) {\n  if (k == 0) {\n    return 1;\n  }\n  if (n == deg) {\n    return 0;\n  }\n  long long& ret = cache[n][k];\n  if (ret != -1) {\n    return ret;\n  }\n  ret = DP(n + 1, k, d) + DP(n + 1, k - 1, d) * tree[n][d];\n  ret %= MOD;\n  return ret;\n}\nlong long root(long long n) {\n  deg = adj[n].size();\n  visited[n] = true;\n  int idx = 0;\n  for (auto& it : adj[n]) {\n    sub(idx, 0, it);\n    ++idx;\n  }\n  long long ans = 0;\n  for (int d = 0; d <= N; d++) {\n    memset(cache, -1, sizeof(cache));\n    ans += DP(0, K, d);\n    ans %= MOD;\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> N >> K;\n  for (int i = 0; i < N; i++) {\n    adj[i].clear();\n  }\n  for (int i = 0; i < N - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  if (K == 2) {\n    cout << N * (N - 1) / 2 << \"\\n\";\n    return;\n  }\n  long long ret = 0;\n  for (int i = 0; i < N; i++) {\n    if (adj[i].size() >= K) {\n      memset(tree, 0, sizeof(tree));\n      memset(visited, 0, sizeof(visited));\n      ret += root(i);\n      ret %= MOD;\n    }\n  }\n  cout << ret << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nstruct Tree {\n  int n;\n  int r;\n  int l;\n  std::vector<std::vector<int>> prit;\n  std::vector<std::vector<int>> t;\n  std::vector<int> par;\n  std::vector<int> dpt;\n  std::vector<int> tour;\n  std::vector<std::vector<int>> appear_on_tour;\n  std::vector<std::vector<int>> anc;\n  Tree() {}\n  Tree(int n) : n(n) {\n    prit.resize(n);\n    t.resize(n);\n    par.resize(n);\n    dpt.resize(n);\n  }\n  void add_edge(int u, int v) {\n    prit[u].push_back(v);\n    prit[v].push_back(u);\n  }\n  void build(int r_) {\n    r = r_;\n    for (int i = 0; i < n; i++) dpt[i] = -1;\n    std::queue<int> que;\n    par[r] = -1;\n    dpt[r] = 0;\n    que.push(r);\n    while (que.size()) {\n      int u = que.front();\n      que.pop();\n      for (int v : prit[u]) {\n        if (dpt[v] == -1) {\n          t[u].push_back(v);\n          par[v] = u;\n          dpt[v] = dpt[u] + 1;\n          que.push(v);\n        }\n      }\n    }\n  }\n  void rebuild(int r_) {\n    for (int u = 0; u < n; u++) t[u].clear();\n    build(r_);\n  }\n  void dfs(int u, int &k) {\n    appear_on_tour[u].push_back(k);\n    tour[k++] = u;\n    for (int v : t[u]) {\n      dfs(v, k);\n      appear_on_tour[u].push_back(k);\n      tour[k++] = u;\n    }\n  }\n  void build_euler_tour() {\n    tour.resize(n * 2 - 1);\n    appear_on_tour.resize(n);\n    int k = 0;\n    dfs(r, k);\n  }\n  void build_lca() {\n    for (l = 1; l <= n; l++) {\n      if ((1 << (l - 1)) >= n) break;\n    }\n    anc.resize(l);\n    for (int j = 0; j < l; j++) anc[j].resize(n);\n    for (int i = 0; i < n; i++) anc[0][i] = par[i];\n    for (int j = 1; j < l; j++) {\n      for (int i = 0; i < n; i++) {\n        if (anc[j - 1][i] == -1)\n          anc[j][i] = -1;\n        else\n          anc[j][i] = anc[j - 1][anc[j - 1][i]];\n      }\n    }\n  }\n  int lca(int u, int v) {\n    if (dpt[u] < dpt[v]) std::swap(u, v);\n    int dpt_diff = dpt[u] - dpt[v];\n    for (int j = l - 1; j >= 0; j--) {\n      if ((dpt_diff >> j) & 1) u = anc[j][u];\n    }\n    if (u == v) return u;\n    for (int j = l - 1; j >= 0; j--) {\n      if (anc[j][u] != anc[j][v]) {\n        u = anc[j][u];\n        v = anc[j][v];\n      }\n    }\n    return anc[0][u];\n  }\n};\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    int a[102], b[102];\n    for (int i = 0; i < n - 1; i++) {\n      cin >> a[i] >> b[i];\n      a[i]--;\n      b[i]--;\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    long long ans = 0;\n    for (int r = 0; r < n; r++) {\n      Tree t(n);\n      for (int i = 0; i < n - 1; i++) t.add_edge(a[i], b[i]);\n      t.build(r);\n      long long d[102][102];\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) d[i][j] = 0;\n      }\n      for (int u = 0; u < n; u++) {\n        if (u == r) continue;\n        int v = u;\n        while (t.par[v] != r) v = t.par[v];\n        d[v][t.dpt[u]]++;\n      }\n      for (int dpt = 1; dpt < n; dpt++) {\n        vector<int> p;\n        for (int u = 0; u < n; u++) {\n          if (d[u][dpt]) p.push_back(u);\n        }\n        if ((int)p.size() < k) break;\n        long long dp[102]{0};\n        dp[0] = 1;\n        for (int u : p) {\n          long long dp2[102]{0};\n          for (int i = 0; i <= k; i++) dp2[i] = dp[i];\n          for (int i = 1; i <= k; i++)\n            dp2[i] = (dp2[i] + dp[i - 1] * d[u][dpt]) % MOD;\n          swap(dp, dp2);\n        }\n        ans = (ans + dp[k]) % MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nvector<vector<long long> > d(110);\nvector<bool> u(110);\nvector<long long> t;\nlong long dfs(long long v, long long dist, long long pr) {\n  u[v] = 1;\n  if (!dist) {\n    return 1;\n  }\n  long long m = 0;\n  for (long long i = 0; i < d[v].size(); i++)\n    if (!u[d[v][i]]) {\n      long long b = dfs(d[v][i], dist - 1, pr);\n      m += b;\n      if (v == pr && b) t.push_back(b);\n    }\n  return m;\n}\nlong long f(long long k) {\n  long long m = mod - 2;\n  long long a = 1;\n  while (m) {\n    if (m % 2) a = 1ll * a * k % mod;\n    k = 1ll * k * k % mod;\n    m /= 2;\n  }\n  return a;\n}\nvoid solve() {\n  long long n, m, k, ans = 0;\n  cin >> n >> k;\n  for (long long i = 0; i < n; i++) d[i].clear();\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    d[u].push_back(v);\n    d[v].push_back(u);\n  }\n  if (k == 1) {\n    cout << n << '\\n';\n    return;\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << '\\n';\n    return;\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 1; j < n; j++) {\n      long long ans1 = 0;\n      for (long long h = 0; h < n; h++) u[h] = 0;\n      t.clear();\n      m = dfs(i, j, i);\n      if (t.size() >= k) {\n        long long dp[110][110] = {0};\n        for (long long j = 0; j < k; j++) {\n          long long sum;\n          if (!j)\n            sum = 1;\n          else\n            sum = dp[j - 1][j - 1];\n          for (long long i = j; i < t.size(); i++) {\n            dp[i][j] = 1ll * sum * t[i] % mod;\n            if (j) sum = (sum + dp[i][j - 1]) % mod;\n          }\n        }\n        for (long long i = 0; i < t.size(); i++)\n          ans1 = (ans1 + dp[i][k - 1]) % mod;\n        ans = (ans + ans1) % mod;\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// Don't place your source in a package\n\n\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        //reading /writing file\n        //Scanner sc=new Scanner(new File(\"input.txt\"));\n        //PrintWriter pr=new PrintWriter(\"output.txt\");\n\n\n        int T=Int();\n        for(int t=0;t<T;t++){\n            int n=Int();\n            int k=Int();\n            int edges[][]=new int[n-1][2];\n            for(int i=0;i<edges.length;i++){\n                edges[i][0]=Int()-1;\n                edges[i][1]=Int()-1;\n            }\n            Solution sol=new Solution(out);\n            sol.solution(n,k,edges);\n        }\n        out.close();\n\n    }\n\n\n\n\n    public static int[] Arr(int n){\n        int A[]=new int[n];\n        for(int i=0;i<n;i++)A[i]=Int();\n        return A;\n    }\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\n\n\nclass Solution {\n    PrintWriter out;\n    int INF = Integer.MAX_VALUE;\n    int MOD = 1000000007;\n    int mod = MOD;\n    public Solution(PrintWriter out) {\n        this.out = out;\n    }\n\n\n\n    List<Integer>graph[];\n    int dis[][];\n    int s = -1;\n    public void solution(int n,int k,int edges[][]) {\n        if(k==2){\n            out.println(n*(n-1)/2);\n            return;\n        }\n\n        graph=new ArrayList[n];\n        Arrays.setAll(graph,e->new ArrayList<>());\n        for(int edge[]:edges){\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        long res = 0;\n\n        for(int root=0;root<n;root++){\n            dis=new int[n+1][n+1];\n            for(int next:graph[root]){\n                s=next;\n                dfs(root,next,1);\n            }\n\n\n\n            for(int dep = 1;dep<=n;dep++){\n                List<Integer>list=new ArrayList<>();\n                for(int next:graph[root]){\n                    int cnt = dis[next][dep];\n                    if(cnt!=0){\n                        list.add(cnt);\n                    }\n                }\n                long v = cal(list,k);\n                res+=v;\n                res%=MOD;\n            }\n\n        }\n\n\n        out.println(res);\n    }\n\n    public long cal(List<Integer>list,int k){\n        if(list.size()<k){\n            return 0;\n        }\n\n        long dp[][]=new long[list.size()+1][k+1];\n        dp[0][0]=1;\n        for(int i = 1;i<=list.size();i++){\n            int cnt = list.get(i-1);\n            dp[i][0]=1;\n            for(int j = 1;j<=k;j++){\n                dp[i][j]=dp[i-1][j];\n                dp[i][j]+=(dp[i-1][j-1]*cnt);\n                dp[i][j]%=MOD;\n            }\n        }\n        return dp[list.size()][k];\n    }\n\n    public void dfs(int parent,int root,int level){\n        dis[s][level]++;\n        for(int next:graph[root]){\n            if(next!=parent){\n                dfs(root,next,level+1);\n            }\n        }\n    }\n\n\n\n\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long N = 1e2 + 10;\nvector<long long> g[N];\nvoid dfs(long long node, long long par, long long dd, vector<long long>& fre) {\n  fre[dd]++;\n  for (auto x : g[node])\n    if (x != par) dfs(x, node, dd + 1, fre);\n}\nlong long n, k;\nlong long get(vector<long long>& arr) {\n  vector<long long> cur(k + 1, 0);\n  cur[0] = 1;\n  for (auto x : arr) {\n    for (long long i = k; i >= 1; i--) {\n      cur[i] += cur[i - 1] * x;\n      cur[i] %= MOD;\n    }\n  }\n  return cur[k];\n}\nlong long solve(long long x) {\n  long long sz = g[x].size();\n  vector<vector<long long> > go(sz, vector<long long>(n + 1, 0));\n  for (long long i = 0; i < sz; i++) dfs(g[x][i], x, 1, go[i]);\n  long long res = 0;\n  for (long long i = 1; i <= n; i++) {\n    vector<long long> arr;\n    for (auto v : go) arr.push_back(v[i]);\n    res += get(arr);\n    res %= MOD;\n  }\n  return res;\n}\nvoid solve() {\n  cin >> n >> k;\n  long long u, v;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long res = 0;\n  if (k == 2) {\n    res = (n * (n - 1)) / 2;\n    res %= MOD;\n  } else {\n    for (long long i = 1; i <= n; i++) {\n      res += solve(i);\n      res %= MOD;\n    }\n  }\n  cout << res << '\\n';\n  for (long long i = 1; i <= n; i++) g[i].clear();\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,abm,mmx,tune=native\")\nusing namespace std;\nlong long gcd(long long i, long long j) {\n  if (j == 0)\n    return i;\n  else\n    return gcd(j, i % j);\n}\ntemplate <typename T>\ninline T getint() {\n  T val = 0;\n  char c;\n  bool neg = false;\n  while ((c = getchar()) && !(c >= '0' && c <= '9')) {\n    neg |= c == '-';\n  }\n  do {\n    val = (val * 10) + c - '0';\n  } while ((c = getchar()) && (c >= '0' && c <= '9'));\n  return val * (neg ? -1 : 1);\n}\nconst long long INF = 1e18 + 100;\nconst int mod = 1000000007;\nconst long double eps = 1e-10, pi = acosl(-1);\nconst long long maxN = 200010, maxT = 25000, A = 179, mid = 150;\nmt19937 mt_rand(time(0));\nlong long bp(long long et, long long b) {\n  b %= mod - 1;\n  long long res = 1;\n  for (int i = 30; i >= 0; --i) {\n    res = (res * res) % mod;\n    if ((b & (1 << i)) != 0) res = (res * et) % mod;\n  }\n  return res;\n}\nvoid panic() {\n  cout << \"-1\\n\";\n  exit(0);\n}\nvector<vector<int>> g;\nvector<int> cnt;\nvoid dfs(int v, int d, int p = -1) {\n  ++cnt[d];\n  for (auto x : g[v]) {\n    if (x == p) continue;\n    dfs(x, d + 1, v);\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  g.assign(n, vector<int>());\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << \"\\n\";\n    return;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    vector<vector<int>> dp(n, vector<int>(k + 1));\n    for (int i = 0; i < n; ++i) dp[i][0] = 1;\n    for (auto x : g[i]) {\n      cnt.assign(n, 0);\n      dfs(x, 1, i);\n      for (int d = 0; d < n; ++d) {\n        if (cnt[d] == 0) continue;\n        for (int j = k - 1; j >= 0; --j) {\n          dp[d][j + 1] = (dp[d][j + 1] + (long long)cnt[d] * dp[d][j]) % mod;\n        }\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      ans = (ans + dp[i][k]) % mod;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(10);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int T, N, K, u, v;\n  cin >> T;\n  while (T--) {\n    cin >> N >> K;\n    long long ret = 0;\n    vector<int> adj[N + 1];\n    for (int i = 0; i < N - 1; i++) {\n      cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    for (int i = 1; i <= N; i++) {\n      if (adj[i].size() < K) continue;\n      vector<pair<long long, int> > bfs;\n      vector<int> vis;\n      vis.resize(N + 1);\n      vis[i] = 1;\n      for (int n : adj[i]) {\n        bfs.push_back(pair<long long, int>(n, n));\n      }\n      while (!bfs.empty()) {\n        unordered_map<int, int> sz;\n        vector<pair<long long, int> > step;\n        for (pair<long long, int> j : bfs) {\n          sz[j.second]++;\n          vis[j.first] = 1;\n          for (int n : adj[j.first]) {\n            if (!vis[n]) step.push_back(pair<long long, int>(n, j.second));\n          }\n        }\n        if (sz.size() < K) {\n          break;\n        }\n        int second = sz.size();\n        vector<int> all;\n        for (auto i : sz) {\n          all.push_back(i.second);\n        }\n        long long dp[second + 1][K + 1];\n        for (int i = 0; i <= second; i++) {\n          for (int j = 0; j <= K; j++) {\n            dp[i][j] = (j == 0);\n          }\n        }\n        for (int i = 1; i <= second; i++) {\n          for (int j = 1; j <= K; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j != 0) dp[i][j] += dp[i - 1][j - 1] * all[i - 1];\n            dp[i][j] %= mod;\n          }\n        }\n        ret += dp[second][K];\n        ret %= mod;\n        swap(step, bfs);\n      }\n    }\n    cout << (K == 2 ? (N) * (N - 1) / 2 : ret) << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long Mod = (long long)1e9 + 7;\nconst long long MAXFAC = (long long)2e6 + 10;\nlong long fac[MAXFAC];\ninline long long pw(long long x, long long y) {\n  long long res = 1;\n  while (y) {\n    if (y & 1ll) res = res * x % Mod;\n    x = x * x % Mod;\n    y /= 2;\n  }\n  return res;\n}\nvoid init_fac(long long maxn = MAXFAC) {\n  fac[0] = 1;\n  for (long long i = 1; i < maxn; ++i) {\n    fac[i] = fac[i - 1] * i % Mod;\n  }\n}\ninline long long inv(long long x) { return pw(x, Mod - 2); };\ninline long long choose(long long n, long long r) {\n  return fac[n] * (inv(fac[n - r]) * inv(fac[r]) % Mod) % Mod;\n}\nvoid preproc() { init_fac(110); }\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  vector<vector<long long>> g(n + 1);\n  for (long long e = 1; e <= n - 1; ++e) {\n    long long u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << choose(n, 2) << '\\n';\n    return;\n  }\n  vector<vector<long long>> f(n + 1, vector<long long>(n + 1));\n  vector<vector<long long>> h(n + 1, vector<long long>(n + 1));\n  function<void(long long, long long)> dfs_f = [&](long long u, long long pr) {\n    f[u][0] = 1;\n    for (auto it = g[u].begin(); it != g[u].end(); ++it)\n      if (*it == pr) {\n        g[u].erase(it);\n        break;\n      }\n    for (long long v : g[u])\n      if (v != pr) {\n        dfs_f(v, u);\n        for (long long d = 1; d <= n; ++d) f[u][d] += f[v][d - 1];\n      }\n  };\n  dfs_f(1, 0);\n  function<void(long long)> dfs_g = [&](long long u) {\n    h[u][0] = 1;\n    long long childs = (long long)g[u].size();\n    vector<vector<long long>> pref(childs, vector<long long>(n + 1));\n    vector<vector<long long>> suff(childs, vector<long long>(n + 1));\n    for (long long i = 0; i < childs; ++i) {\n      long long vi = g[u][i];\n      long long rev_i = childs - i - 1;\n      long long rev_vi = g[u][rev_i];\n      for (long long d = 0; d <= n; ++d) {\n        pref[i][d] = f[vi][d] + (i - 1 >= 0 ? pref[i - 1][d] : 0ll);\n        suff[rev_i][d] =\n            f[rev_vi][d] + (rev_i + 1 <= childs - 1 ? suff[rev_i + 1][d] : 0ll);\n      }\n    }\n    for (long long i = 0; i < childs; ++i) {\n      long long vi = g[u][i];\n      for (long long d = 1; d <= n; ++d) {\n        h[vi][d] += h[u][d - 1];\n        if (d - 2 >= 0 and i - 1 >= 0) h[vi][d] += pref[i - 1][d - 2];\n        if (d - 2 >= 0 and i + 1 <= childs - 1) h[vi][d] += suff[i + 1][d - 2];\n      }\n    }\n    for (long long v : g[u]) dfs_g(v);\n  };\n  dfs_g(1);\n  long long res = 0;\n  for (long long u = 1; u <= n; ++u) {\n    long long neigh = (long long)g[u].size() + (u != 1);\n    if (neigh < k) continue;\n    for (long long d = 1; d <= n; ++d) {\n      vector<long long> a;\n      if (h[u][d] > 0) a.push_back(h[u][d]);\n      for (long long v : g[u])\n        if (f[v][d - 1] > 0) a.push_back(f[v][d - 1]);\n      if ((long long)a.size() < k) break;\n      long long sz = (long long)a.size();\n      vector<vector<long long>> dp(sz + 1, vector<long long>(k + 1));\n      for (long long i = 0; i <= sz; ++i) dp[i][0] = 1;\n      for (long long vk = 1; vk <= k; ++vk)\n        for (long long i = 1; i <= sz; ++i)\n          dp[i][vk] = (dp[i - 1][vk] + dp[i - 1][vk - 1] * a[i - 1]) % Mod;\n      res = (res + dp[sz][k]) % Mod;\n    }\n  }\n  res = (res) % Mod;\n  cout << res << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.precision(10);\n  cout << fixed;\n  preproc();\n  long long tc = 1;\n  cin >> tc;\n  for (long long Tt = 1; Tt <= tc; ++Tt) {\n    solve();\n  }\n  return EXIT_SUCCESS;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-Ofast\", \"-funroll-all-loops\")\nusing namespace std;\nconst int MAXN = 1e2 + 10, mod = 1e9 + 7;\ninline int add(int first, int second) {\n  return first + second > mod ? first + second - mod : first + second;\n}\ninline int mul(int first, int second) { return 1ll * first * second % mod; }\nint ch[MAXN][MAXN], dp[MAXN][MAXN];\nvector<int> G[MAXN];\nvoid dfs(int first, int prev, int d, int j) {\n  ch[j][d] += 1;\n  for (int(i) = (0); (i) < (G[first].size()); (i) += (1)) {\n    if (G[first][i] == prev) continue;\n    dfs(G[first][i], first, d + 1, j);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int n, t, k, ans, a, b;\n  bool f;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    ans = 0;\n    for (int(i) = (1); (i) <= (n); (i) += (1)) G[i].clear();\n    for (int(i) = (1); (i) < (n); (i) += (1)) {\n      cin >> a >> b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    for (int(i) = (1); (i) <= (n); (i) += (1)) {\n      memset(ch, 0, sizeof(ch));\n      if (G[i].size() < k) continue;\n      for (int(j) = (0); (j) < (G[i].size()); (j) += (1)) {\n        dfs(G[i][j], i, 1, j + 1);\n      }\n      for (int(z) = (1); (z) < (n); (z) += (1)) {\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int(j) = (1); (j) <= (G[i].size()); (j) += (1)) {\n          for (int(u) = (0); (u) <= (min(j, k)); (u) += (1)) {\n            if (u) dp[j][u] = add(dp[j][u], mul(dp[j - 1][u - 1], ch[j][z]));\n            dp[j][u] = add(dp[j - 1][u], dp[j][u]);\n          }\n        }\n        ans = add(ans, dp[G[i].size()][k]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing _ii = pair<int, int>;\nconst int N = 107;\nint t, n, k;\ni64 dp_in[N][N], dp_out[N][N], ans, mod = 1e9 + 7;\nvector<vector<int>> a;\nvoid DFS(int h, int legacy) {\n  for (auto &i : a[h]) {\n    if (i == legacy) continue;\n    DFS(i, h);\n    for (int j = 1; j <= n; j++)\n      dp_in[h][j] = (dp_in[h][j] + dp_in[i][j - 1]) % mod;\n  }\n  ++dp_in[h][0];\n}\nvoid Cal(vector<int> &a, int cnt) {\n  int m = a.size();\n  vector<i64> f(cnt + 1);\n  f[0] = 1;\n  for (auto &i : a) {\n    for (int j = cnt; j >= 1; j--) {\n      f[j] += f[j - 1] * i;\n      f[j] %= mod;\n    }\n  }\n  ans = (ans + f[cnt]) % mod;\n}\nvoid Run(int h, int legacy) {\n  for (int j = 1; j <= n; j++) {\n    vector<int> d;\n    d.push_back(dp_out[h][j]);\n    for (auto &i : a[h]) {\n      if (i == legacy) continue;\n      d.push_back(dp_in[i][j - 1]);\n    }\n    Cal(d, k);\n  }\n  for (auto &i : a[h]) {\n    if (i == legacy) continue;\n    for (int j = 1; j <= n; j++) {\n      int temp = dp_in[h][j - 1] - (j - 2 >= 0 ? dp_in[i][j - 2] : 0);\n      dp_out[i][j] = temp + dp_out[h][j - 1];\n    }\n    Run(i, h);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    a.resize(n + 1);\n    for (auto &i : a) i.clear();\n    for (int i = 1; i <= n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      a[x].push_back(y);\n      a[y].push_back(x);\n    }\n    ans = 0;\n    memset(dp_in, 0, sizeof(dp_in));\n    memset(dp_out, 0, sizeof(dp_out));\n    DFS(1, 0);\n    Run(1, 0);\n    if (k == 2) ans = (n * (n - 1) / 2) % mod;\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long N = 1e2 + 10;\nvector<long long> g[N];\nvoid dfs(long long node, long long par, long long dd, vector<long long>& fre) {\n  fre[dd]++;\n  for (auto x : g[node])\n    if (x != par) dfs(x, node, dd + 1, fre);\n}\nlong long n, k;\nlong long get(vector<long long>& arr) {\n  if (arr.size() < k) return 0;\n  vector<long long> cur(k + 1, 0);\n  cur[0] = 1;\n  for (auto x : arr) {\n    vector<long long> nex(k + 1, 0);\n    for (long long i = 0; i <= k; i++) {\n      nex[i] = cur[i];\n      if (i > 0) nex[i] += cur[i - 1] * x;\n      nex[i] %= MOD;\n    }\n    swap(cur, nex);\n  }\n  return cur[k];\n}\nlong long solve(long long x) {\n  long long sz = g[x].size();\n  vector<vector<long long> > go(sz, vector<long long>(n + 1, 0));\n  for (long long i = 0; i < sz; i++) dfs(g[x][i], x, 1, go[i]);\n  long long res = 0;\n  for (long long i = 1; i <= n; i++) {\n    vector<long long> arr;\n    for (auto v : go)\n      if (v[i] > 0) arr.push_back(v[i]);\n    if (arr.empty()) break;\n    res += get(arr);\n    res %= MOD;\n  }\n  return res;\n}\nvoid solve() {\n  cin >> n >> k;\n  long long u, v;\n  for (long long i = 0; i < n - 1; i++) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long res = 0;\n  if (k == 2) {\n    res = (n * (n - 1)) / 2;\n    res %= MOD;\n  } else {\n    for (long long i = 1; i <= n; i++) {\n      res += solve(i);\n      res %= MOD;\n    }\n  }\n  cout << res << '\\n';\n  for (long long i = 1; i <= n; i++) g[i].clear();\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst int N = 128;\nint t, n, k;\nint cnt[N];\nbool vis[N];\nlong long dp[N][N];\nvector<int> path[N];\nlong long calc(int, int);\nint main() {\n  int a, b;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i <= n; i++) path[i].clear();\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d %d\", &a, &b);\n      path[a].push_back(b);\n      path[b].push_back(a);\n    }\n    if (k == 2) {\n      printf(\"%lld\\n\", (n - 1ll) * n / 2 % MOD);\n      continue;\n    }\n    long long ans = 0;\n    for (int root = 1; root <= n; root++) {\n      memset(vis, false, sizeof(vis));\n      vis[root] = true;\n      int size = path[root].size();\n      vector<pair<int, int>> layer;\n      for (int i = 0; i < size; i++) {\n        int son = path[root][i];\n        layer.emplace_back(son, i);\n        cnt[i] = 1;\n        vis[son] = true;\n      }\n      while (!layer.empty()) {\n        ans = (ans + calc(size, k)) % MOD;\n        vector<pair<int, int>> newLayer;\n        for (auto node : layer) {\n          cnt[node.second]--;\n          for (auto son : path[node.first]) {\n            if (vis[son]) continue;\n            vis[son] = true;\n            cnt[node.second]++;\n            newLayer.emplace_back(son, node.second);\n          }\n        }\n        layer = newLayer;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\nlong long calc(int x, int y) {\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (int i = 0; i < x; i++)\n    for (int j = 0; j <= y; j++) {\n      dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n      dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * cnt[i] % MOD) % MOD;\n    }\n  return dp[x][y];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\ninline void add(int &x, int &y) { (x += y) >= mod ? x -= mod : 0; }\ninline int pl(int x, int y) { return (x += y) >= mod ? x -= mod : x; }\nint T, n, m;\nvector<int> E[110];\nint C[110][110];\nint cnt[110][110], tot, dp[110];\nvoid getdis(int x, int fa, int dis) {\n  ++cnt[tot][dis];\n  for (auto y : E[x]) {\n    if (y == fa) continue;\n    getdis(y, x, dis + 1);\n  }\n}\nint main() {\n  C[0][0] = 1;\n  for (int i = 1; i <= 100; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j) C[i][j] = pl(C[i - 1][j - 1], C[i - 1][j]);\n  }\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1, x, y; i < n; ++i) {\n      scanf(\"%d %d\", &x, &y);\n      E[x].emplace_back(y);\n      E[y].emplace_back(x);\n    }\n    if (m == 2) {\n      printf(\"%d\\n\", n * (n - 1) / 2);\n      for (int i = 1; i <= n; ++i) E[i].clear();\n      continue;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n      for (auto x : E[i]) ++tot, getdis(x, i, 1);\n      for (int j = 1; j <= n; ++j) {\n        int cnt1 = 0;\n        for (int k = 1; k <= tot; ++k) cnt1 += cnt[k][j] != 0;\n        if (cnt1 < m) break;\n        dp[0] = 1;\n        for (int k = 1; k <= tot; ++k)\n          for (int l = k; l; --l)\n            dp[l] = (dp[l] + 1ll * dp[l - 1] * cnt[k][j]) % mod;\n        add(ans, dp[m]);\n        memset(dp, 0, tot + 1 << 2);\n      }\n      for (int j = 1; j <= tot; ++j) memset(cnt[j] + 1, 0, n << 2);\n      tot = 0;\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 1; i <= n; ++i) E[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 110;\nconst long long int mod = 1e9 + 7;\nint head[maxn], sons[maxn][maxn];\nlong long int c[maxn][maxn], dp[maxn][maxn];\nvector<int> son;\nstruct edge {\n  int to, next;\n} e[maxn * 2];\nint cnt, maxdep, mindep, k;\nvoid add(int x, int y) {\n  e[cnt].to = y;\n  e[cnt].next = head[x];\n  head[x] = cnt++;\n}\nvoid dfs(int rt, int u, int fa, int deep) {\n  sons[rt][deep]++;\n  for (int i = head[u]; i != -1; i = e[i].next) {\n    int v = e[i].to;\n    if (v == fa) continue;\n    dfs(rt, v, u, deep + 1);\n  }\n}\nlong long int cal(vector<int> son) {\n  memset(dp, 0, sizeof(dp));\n  int n = son.size() - 1;\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j) {\n        dp[i][j] += dp[i - 1][j - 1] * son[i];\n      }\n      dp[i][j] += dp[i - 1][j];\n      dp[i][j] %= mod;\n    }\n  }\n  return dp[n][k];\n}\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n    }\n  }\n  int t, n, x, y;\n  cin >> t;\n  while (t--) {\n    long long int ans = 0;\n    cnt = 0;\n    memset(head, -1, sizeof(head));\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n      cin >> x >> y;\n      add(x, y);\n      add(y, x);\n    }\n    if (k == 2) {\n      cout << c[n][2] << endl;\n      continue;\n    }\n    for (int i = 1; i <= n; i++) {\n      memset(sons, 0, sizeof(sons));\n      for (int u = head[i]; u != -1; u = e[u].next) {\n        int v = e[u].to;\n        dfs(v, v, i, 1);\n      }\n      for (int j = 1; j <= 100; j++) {\n        long long int tmp = 1;\n        int tot = 0;\n        son.clear();\n        son.push_back(-1);\n        for (int u = head[i]; u != -1; u = e[u].next) {\n          int v = e[u].to;\n          son.push_back(sons[v][j]);\n        }\n        ans = (ans + cal(son)) % mod;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long add(long long a, long long b) { return (a + b) % mod; }\nlong long sub(long long a, long long b) { return ((a - b) % mod + mod) % mod; }\nlong long mul(long long a, long long b) { return (a * b) % mod; }\nlong long power(long long a, long long b) {\n  if (b == 0) return 1LL;\n  long long tmp = power(a, b / 2);\n  tmp = mul(tmp, tmp);\n  if (b & 1) tmp = mul(tmp, a);\n  return tmp;\n}\nconst int maxn = 105;\nlong long dp[maxn][maxn], fact[maxn], ifact[maxn], ans;\nvector<int> adjlist[maxn];\nint n, k, depth[maxn], groupsize[maxn][maxn];\nvoid precalc() {\n  fact[0] = ifact[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    fact[i] = mul(i, fact[i - 1]);\n    ifact[i] = power(fact[i], mod - 2);\n  }\n}\nlong long ncr(long long n, long long r) {\n  if (r > n) return 0LL;\n  return mul(fact[n], mul(ifact[n - r], ifact[r]));\n}\nvoid pivot(int p) {\n  if (adjlist[p].size() < k) return;\n  memset(depth, 0, sizeof(depth));\n  memset(dp, 0, sizeof(dp));\n  memset(groupsize, 0, sizeof(groupsize));\n  depth[p] = 1;\n  queue<pair<int, int>> q;\n  for (auto u : adjlist[p]) {\n    q.push({u, u});\n    depth[u] = 2;\n  }\n  while (!q.empty()) {\n    pair<int, int> cur = q.front();\n    q.pop();\n    groupsize[cur.second][depth[cur.first]]++;\n    for (auto u : adjlist[cur.first]) {\n      if (depth[u] != 0) continue;\n      depth[u] = depth[cur.first] + 1;\n      q.push({u, cur.second});\n    }\n  }\n  for (int i = 0; i <= adjlist[p].size(); i++) {\n    dp[i][0] = 1;\n  }\n  for (int d = 2; d < maxn; d++) {\n    int tot = 0;\n    for (auto u : adjlist[p]) {\n      tot += min(groupsize[u][d], 1);\n    }\n    if (tot < k) break;\n    for (int i = 0; i < adjlist[p].size(); i++) {\n      for (int j = 1; j <= min(i + 1, k); j++) {\n        dp[i + 1][j] =\n            add(dp[i][j], mul(dp[i][j - 1], groupsize[adjlist[p][i]][d]));\n      }\n    }\n    ans = add(ans, dp[adjlist[p].size()][k]);\n  }\n}\nvoid solve() {\n  ans = 0;\n  memset(dp, 0, sizeof(dp));\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    adjlist[i].clear();\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    adjlist[u].push_back(v);\n    adjlist[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << ncr(n, 2);\n    return;\n  }\n  for (int i = 1; i <= n; i++) {\n    pivot(i);\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  precalc();\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e2 + 5;\nvector<int> g[N], a[N];\nlong long ans, cur[N], f[N][N], mod = 1e9 + 7;\nvoid dfs(int u, int p, int l) {\n  cur[l]++;\n  for (int i = 0; i < g[u].size(); i++) {\n    int v = g[u][i];\n    if (v == p) continue;\n    dfs(v, u, l + 1);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    ans = 0;\n    for (int i = 1; i <= n; i++) {\n      g[i].clear();\n      cur[i] = 0;\n      a[i].clear();\n    }\n    for (int i = 1; i < n; i++) {\n      int u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    for (int r = 1; r <= n; r++) {\n      for (int i = 1; i <= n; i++) {\n        a[i].clear();\n      }\n      if (g[r].size() < k) continue;\n      for (int i = 0; i < g[r].size(); i++) {\n        for (int i = 1; i <= n; i++) {\n          cur[i] = 0;\n        }\n        dfs(g[r][i], r, 1);\n        for (int i = 1; i <= n; i++) {\n          a[i].push_back(cur[i]);\n        }\n      }\n      for (int i = 1; i <= n; i++) {\n        f[0][0] = 1;\n        for (int j = 1; j <= a[i].size(); j++) {\n          for (int l = 0; l <= min(k, j); l++) {\n            f[j][l] = f[j - 1][l] % mod;\n            if (l > 0 && a[i][j - 1] > 0)\n              f[j][l] = (f[j][l] + f[j - 1][l - 1] * a[i][j - 1]) % mod;\n          }\n        }\n        ans = (ans + f[a[i].size()][k]) % mod;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nconst ll MOD = 1e9 + 7;\nVVI G;\nVI V;\nVVL M;\nll f(int i, int j) {\n  if (j < 0 or j > i) return 0;\n  ll& res = M[i][j];\n  if (res != -1) return res;\n  if (j == 0) return res = 1;\n  return res = (f(i - 1, j) + V[i - 1] * f(i - 1, j - 1)) % MOD;\n}\nvoid dfs(int x, int p, int d, VI& V) {\n  if (d >= (int)V.size())\n    V.push_back(1);\n  else\n    ++V[d];\n  for (int y : G[x])\n    if (y != p) dfs(y, x, d + 1, V);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    G = VVI(n);\n    for (int r = 0; r < n - 1; ++r) {\n      int x, y;\n      cin >> x >> y;\n      --x;\n      --y;\n      G[x].push_back(y);\n      G[y].push_back(x);\n    }\n    if (k == 2)\n      cout << n * (n - 1) / 2 << endl;\n    else {\n      ll res = 0;\n      for (int x = 0; x < n; ++x) {\n        int m = G[x].size();\n        VVI T(m);\n        int mx = 0;\n        for (int i = 0; i < m; ++i) {\n          dfs(G[x][i], x, 0, T[i]);\n          mx = max(mx, (int)T[i].size());\n        }\n        for (int d = 0; d < mx; ++d) {\n          V.clear();\n          for (int i = 0; i < m; ++i)\n            if (d < (int)T[i].size()) V.push_back(T[i][d]);\n          int q = V.size();\n          if (q >= k) {\n            M = VVL(q + 1, VL(k + 1, -1));\n            res = (res + f(q, k)) % MOD;\n          }\n        }\n      }\n      cout << res << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long p = 1e9 + 7;\nconst long long maxn = 105;\nvector<long long> a[maxn];\nbool used[maxn];\nlong long l[maxn][maxn];\nlong long ans;\nlong long c;\nlong long k;\nlong long slv1(vector<long long> v, long long k) {\n  long long dp[v.size() + 1][k + 1];\n  for (long long i = 0; i <= v.size(); ++i)\n    for (long long j = 0; j <= k; ++j) dp[i][j] = 0;\n  dp[0][0] = 1;\n  for (long long i = 0; i < v.size(); ++i)\n    for (long long j = 0; j <= k; ++j) {\n      if (j != k) {\n        dp[i + 1][j + 1] += (dp[i][j] * v[i]);\n        dp[i + 1][j + 1] %= p;\n      }\n      {\n        dp[i + 1][j] += (dp[i][j]);\n        dp[i + 1][j] %= p;\n      }\n    }\n  return dp[v.size()][k];\n}\nvoid dfs(long long x) {\n  for (long long i = 0; i < maxn; ++i) l[x][i] = 0;\n  l[x][0]++;\n  used[x] = true;\n  vector<long long> z;\n  for (auto v : a[x]) {\n    if (used[v]) continue;\n    dfs(v);\n    z.push_back(v);\n    for (long long i = 0; i < maxn; ++i) l[x][i + 1] += l[v][i];\n  }\n  used[x] = false;\n  if (x == c) {\n    for (long long i = 0; i < maxn; ++i) {\n      vector<long long> v;\n      for (auto h : z) {\n        v.push_back(l[h][i]);\n      }\n      long long o = slv1(v, k);\n      ans += o;\n      ans %= p;\n      ans += p;\n      ans %= p;\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n >> k;\n    ans = 0;\n    for (long long i = 0; i < maxn; ++i) {\n      a[i].clear();\n      used[i] = false;\n    }\n    for (long long i = 0; i < (n - 1); ++i) {\n      long long x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      a[x].push_back(y);\n      a[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << endl;\n      continue;\n    }\n    for (long long i = 0; i < n; ++i) {\n      c = i;\n      dfs(i);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1551f {\n\n    static int n, k;\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        while (t --> 0) {\n            rline();\n            n = rni();\n            k = ni();\n            Graph g = tree(n);\n            if (k == 2) {\n                prln(mmul(n, n - 1, minv(2)));\n                continue;\n            }\n            int ans = 0;\n            for (int i = 0; i < n; ++i) {\n                int cnt[][] = new int[g.get(i).size()][n];\n                dfs(g, i, cnt);\n                int dp[][] = new int[n][k + 1];\n                for (int d = 1; d < n; ++d) {\n                    dp[d][0] = 1;\n                    for (int c[] : cnt) {\n                        for (int j = k; j > 0; --j) {\n                            dp[d][j] = madd(dp[d][j], mmul(dp[d][j - 1], c[d]));\n                        }\n                    }\n                    ans = madd(ans, dp[d][k]);\n                }\n            }\n            prln(ans);\n        }\n        close();\n    }\n\n    static void dfs(Graph g, int i, int[][] cnt) {\n        int l = 0;\n        for (int j : g.get(i)) {\n            dfs(g, j, i, cnt[l++], 1);\n        }\n    }\n\n    static void dfs(Graph g, int i, int p, int[] cnt, int dep) {\n        ++cnt[dep];\n        for (int j : g.get(i)) {\n            if (j != p) {\n                dfs(g, j, i, cnt, dep + 1);\n            }\n        }\n    }\n\n    static int mmod = 1000000007;\n\n    static int madd(int a, int b) {\n        return (a + b) % mmod;\n    }\n\n    static int madd(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = madd(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int msub(int a, int b) {\n        return (a - b + mmod) % mmod;\n    }\n\n    static int mmul(int a, int b) {\n        return (int) ((long) a * b % mmod);\n    }\n\n    static int mmul(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = mmul(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int minv(int x) {\n        // return mpow(x, mmod - 2);\n        return (exgcd(x, mmod)[0] % mmod + mmod) % mmod;\n    }\n\n    static int mpow(int a, long b) {\n        if (a == 0) {\n            return 0;\n        }\n        int ans = 1;\n        while (b > 0) {\n            if ((b & 1) > 0) {\n                ans = mmul(ans, a);\n            }\n            a = mmul(a, a);\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    static Graph graph(int n) {\n        Graph g = new Graph();\n        for (int i = 0; i < n; ++i) {\n            g.add(new ArrayList<>());\n        }\n        return g;\n    }\n\n    static Graph graph(int n, int m) throws IOException {\n        Graph g = graph(n);\n        for (int i = 0; i < m; ++i) {\n            g.c(rni() - 1, ni() - 1);\n        }\n        return g;\n    }\n\n    static Graph digraph(int n, int m) throws IOException {\n        Graph g = graph(n);\n        for (int i = 0; i < m; ++i) {\n            g.cto(rni() - 1, ni() - 1);\n        }\n        return g;\n    }\n\n    static Graph tree(int n) throws IOException {\n        return graph(n, n - 1);\n    }\n\n    static Graph graph(List<? extends Collection<Integer>> g) {\n        int n = g.size();\n        Graph h = graph(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j : g.get(i)) {\n                h.cto(i, j);\n            }\n        }\n        return h;\n    }\n\n    static class Graph extends ArrayList<List<Integer>> {\n        void cto(int u, int v) {\n            get(u).add(v);\n        }\n\n        void c(int u, int v) {\n            cto(u, v);\n            cto(v, u);\n        }\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long Fact_Length = 1e5 + 1;\nlong long Power(long long base, long long expo) {\n  long long $result = 1;\n  base %= mod;\n  while (expo) {\n    if (expo % 2 == 1) $result = ($result * base) % mod;\n    base = (base * base) % mod;\n    expo /= 2;\n  }\n  return $result;\n}\nlong long Mod_Inv(long long $a) { return Power($a, mod - 2); }\nlong long Factorial[Fact_Length];\nlong long Make_Factorial() {\n  Factorial[0] = 1;\n  for (long long i = 1; i < Fact_Length; i++) {\n    Factorial[i] = (i * Factorial[i - 1]) % mod;\n  }\n  return 0;\n}\nlong long Implement_Make_Factorial = Make_Factorial();\nlong long nCr(long long $n, long long $r) {\n  if ($n < $r || $n < 0 || $r < 0) return 0;\n  long long $ans = (Factorial[$n] * Mod_Inv(Factorial[$r])) % mod;\n  $ans = ($ans * Mod_Inv(Factorial[$n - $r])) % mod;\n  return $ans;\n}\nconst long long N = 101;\nvector<long long> adj[N];\nlong long n, k;\nlong long dep[N];\nvoid DFS(long long chi, long long par, long long cur) {\n  dep[cur]++;\n  for (auto x : adj[chi]) {\n    if (x == par) continue;\n    DFS(x, chi, cur + 1);\n  }\n}\nlong long calc(long long b[], long long m) {\n  if (m < k) return 0;\n  long long dp[m + 1][k + 1];\n  memset(dp, 0, sizeof(dp));\n  for (long long i = 0; i <= m; i++) dp[i][0] = 1;\n  for (long long i = 1; i <= m; i++) {\n    for (long long j = 1; j <= k; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * b[i];\n      dp[i][j] %= mod;\n    }\n  }\n  return dp[m][k];\n}\nlong long val(long long root) {\n  vector<long long> a[n + 1];\n  long long m = adj[root].size();\n  for (auto x : adj[root]) {\n    for (long long i = 1; i <= n; i++) dep[i] = 0;\n    DFS(x, root, 1);\n    for (long long i = 1; i <= n; i++) a[i].push_back(dep[i]);\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    sort(a[i].begin(), a[i].end());\n    long long b[m + 1];\n    for (long long j = 1; j <= m; j++) b[j] = a[i][j - 1];\n    ans += calc(b, m);\n    ans %= mod;\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (long long i = 1; i <= n; i++) adj[i].clear();\n  for (long long i = 1; i <= n - 1; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    long long ans = (n * (n - 1)) / 2;\n    cout << ans << endl;\n    return;\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) {\n    ans += val(i);\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 205, P = 1000000007;\nlong long T, n, k, x, y, num[N][N], f[N][N];\nstd::vector<long long> g[N], a;\nvoid dfs(long long u, long long fa) {\n  num[u][0] = 1;\n  for (long long i = 0; i < (long long)g[u].size(); i++) {\n    long long v = g[u][i];\n    if (v == fa) continue;\n    dfs(v, u);\n    for (long long j = 1; j <= n; j++) num[u][j] += num[v][j - 1];\n  }\n}\nsigned main() {\n  std::cin >> T;\n  while (T--) {\n    std::cin >> n >> k;\n    long long ans = 0;\n    for (long long i = 1; i < n; i++)\n      std::cin >> x >> y, g[x].push_back(y), g[y].push_back(x);\n    if (k == 2) {\n      std::cout << n * (n - 1) / 2 << '\\n';\n      for (long long i = 1; i <= n; i++) g[i].clear();\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      dfs(i, 0);\n      for (long long j = 1; j <= n; j++) {\n        for (long long l = 0; l < (long long)g[i].size(); l++)\n          a.push_back(num[g[i][l]][j - 1]);\n        f[0][0] = 1;\n        for (long long x = 1; x <= (long long)a.size(); x++) {\n          f[x][0] = 1;\n          for (long long y = 1; y <= x; y++)\n            f[x][y] = (f[x - 1][y] + f[x - 1][y - 1] * a[x - 1] % P) % P;\n        }\n        ans = (ans + f[a.size()][k]) % P;\n        for (long long x = 1; x <= (long long)a.size(); x++)\n          for (long long y = 1; y <= x; y++) f[x][y] = 0;\n        a.clear();\n      }\n      for (long long j = 1; j <= n; j++)\n        for (long long l = 0; l <= n; l++) num[j][l] = 0;\n    }\n    std::cout << ans << '\\n';\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 1; i <= n; i++)\n      for (long long j = 0; j <= n; j++) num[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 128;\nconst long long mod = 1000 * 1000 * 1000 + 7;\nlong long add(long long x, long long y) { return (x + y) % mod; }\nlong long mul(long long x, long long y) { return x * y % mod; }\nvector<int> g[MAX_N];\nbool used[MAX_N];\nint cnt[MAX_N];\nlong long dp[MAX_N][MAX_N];\nlong long rundp(int m, int k) {\n  for (int i = 0; i <= m; i++)\n    for (int j = 0; j <= k; j++) dp[i][j] = 0;\n  dp[0][0] = 1;\n  for (int i = 0; i < m; i++)\n    for (int j = 0; j <= k; j++) {\n      dp[i + 1][j] = add(dp[i + 1][j], dp[i][j]);\n      dp[i + 1][j + 1] = add(dp[i + 1][j + 1], mul(dp[i][j], cnt[i]));\n    }\n  return dp[m][k];\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) g[i].clear();\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    g[--a].push_back(--b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1LL) / 2 % mod << '\\n';\n    return;\n  }\n  long long ans = 0;\n  for (int center = 0; center < n; center++) {\n    memset(used, 0, n);\n    used[center] = true;\n    vector<pair<int, int>> layer;\n    int m = g[center].size();\n    for (int i = 0; i < m; i++) {\n      int y = g[center][i];\n      layer.emplace_back(y, i);\n      cnt[i] = 1;\n      used[y] = true;\n    }\n    while (!layer.empty()) {\n      ans = add(ans, rundp(m, k));\n      vector<pair<int, int>> newlayer;\n      for (auto p : layer) {\n        cnt[p.second]--;\n        for (auto y : g[p.first])\n          if (!used[y]) {\n            newlayer.emplace_back(y, p.second);\n            used[y] = true;\n            cnt[p.second]++;\n          }\n      }\n      layer = newlayer;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (is_same<int, long long>::value ? 1e18 + 666 : 1e9 + 666);\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <class t1, class t2>\ninline bool cmin(t1 &a, const t2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class t1, class t2>\ninline bool cmax(t1 &a, const t2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline int bpow(long long a, long long b, int mod) {\n  int res = 1;\n  a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) {\n      res = int((1ll * a * res) % mod);\n      res %= mod;\n    }\n    a *= a;\n    a %= mod;\n  }\n  return res;\n}\nvoid UseFiles(const string &s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\nvoid run();\nsigned main() {\n  iostream::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  run();\n}\nvoid solve();\nvoid run() {\n  int n;\n  cin >> n;\n  while (n-- > 0) {\n    solve();\n  }\n}\nvoid solve() {\n  constexpr int mod = 1e9 + 7;\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << (n * (n - 1) >> 1) << endl;\n    return;\n  }\n  function<vector<int>(int, int)> dfs = [&g, &dfs](int v, int p) {\n    vector<int> res;\n    for (auto &x : g[v]) {\n      if (x == p) continue;\n      vector<int> ret = dfs(x, v);\n      if (((int)(ret).size()) > ((int)(res).size())) {\n        swap(ret, res);\n      }\n      for (int i = 1; i <= ((int)(ret).size()); ++i) {\n        res[((int)(res).size()) - i] += ret[((int)(ret).size()) - i];\n      }\n    }\n    res.push_back(1);\n    return res;\n  };\n  int ans = 0;\n  for (int center = 0; center < n; ++center) {\n    if (((int)(g[center]).size()) < k) continue;\n    vector<vector<int>> dverts;\n    for (auto &v : g[center]) {\n      dverts.push_back(dfs(v, center));\n      reverse(dverts.back().begin(), dverts.back().end());\n    }\n    for (int i = 0;; ++i) {\n      vector<int> dp(k + 1, 0);\n      dp[0] = 1;\n      for (auto &x : dverts) {\n        if (((int)(x).size()) <= i) continue;\n        for (int j = k; j > 0; --j) {\n          dp[j] += int(1ll * dp[j - 1] * x[i] % mod);\n          if (dp[j] >= mod) {\n            dp[j] -= mod;\n          }\n        }\n      }\n      if (dp[k] == 0) break;\n      ans += dp[k];\n      if (ans >= mod) {\n        ans -= mod;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nint n, d[N], k, vis[N][N], dp[N][N], id, mod = 1e9 + 7, cnt[N][N];\nvector<int> adj[N], v;\nvoid dfs(int node, int par, int parCh) {\n  if (parCh) {\n    cnt[parCh][d[node]]++;\n  }\n  for (auto ch : adj[node]) {\n    if (ch == par) continue;\n    d[ch] = d[node] + 1;\n    if (node == par)\n      dfs(ch, node, ch);\n    else\n      dfs(ch, node, parCh);\n  }\n}\nint solve(int i, int rem) {\n  if (!rem) return 1;\n  if (i == (int)v.size()) return 0;\n  if (vis[i][rem] == id) return dp[i][rem];\n  vis[i][rem] = id;\n  int ans = solve(i + 1, rem);\n  ans = (ans + 1ll * v[i] * solve(i + 1, rem - 1)) % mod;\n  return dp[i][rem] = ans;\n}\nvoid clear() {\n  for (int i = 0; i <= n; i++) {\n    adj[i].clear();\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      adj[x].push_back(y);\n      adj[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      clear();\n      continue;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      memset(d, 0, sizeof(d));\n      memset(cnt, 0, sizeof(cnt));\n      dfs(i, i, 0);\n      for (int ds = 1; ds <= n; ds++) {\n        v.clear();\n        for (int ch = 1; ch <= n; ch++) {\n          if (cnt[ch][ds]) v.push_back(cnt[ch][ds]);\n        }\n        id++;\n        ans = (ans + solve(0, k)) % mod;\n      }\n    }\n    cout << ans << '\\n';\n    clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n  if (v.size() == 0) {\n    os << \"empty vector\\n\";\n    return os;\n  }\n  for (auto element : v) os << element << \" \";\n  return os;\n}\ntemplate <typename T, typename second>\nostream& operator<<(ostream& os, pair<T, second>& p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T>& v) {\n  if (v.size() == 0) {\n    os << \"empty set\\n\";\n    return os;\n  }\n  auto endit = v.end();\n  endit--;\n  os << \"[\";\n  for (auto it = v.begin(); it != v.end(); it++) {\n    os << *it;\n    if (it != endit) os << \", \";\n  }\n  os << \"]\";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, multiset<T>& v) {\n  if (v.size() == 0) {\n    os << \"empty multiset\\n\";\n    return os;\n  }\n  auto endit = v.end();\n  endit--;\n  os << \"[\";\n  for (auto it = v.begin(); it != v.end(); it++) {\n    os << *it;\n    if (it != endit) os << \", \";\n  }\n  os << \"]\";\n  return os;\n}\ntemplate <typename T, typename second>\nostream& operator<<(ostream& os, map<T, second>& v) {\n  if (v.size() == 0) {\n    os << \"empty map\\n\";\n    return os;\n  }\n  auto endit = v.end();\n  endit--;\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++) {\n    os << \"(\" << (*it).first << \" : \" << (*it).second << \")\";\n    if (it != endit) os << \", \";\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<vector<T>>& v) {\n  for (auto& subv : v) {\n    for (auto& e : subv) os << e << \" \";\n    os << \"\\n\";\n  }\n  return os;\n}\nbool do_debug = false;\nlong long n, k;\nvector<long long> adj[110], par(101);\nvector<vector<long long>> level(101, vector<long long>(101)),\n    parent(101, vector<long long>(101));\nvoid DFS(long long node, long long par, vector<long long>& levels,\n         vector<long long>& parents) {\n  for (auto x : adj[node]) {\n    if (x != par) {\n      parents[x] = node;\n      levels[x] = levels[node] + 1;\n      DFS(x, node, levels, parents);\n    }\n  }\n}\nlong long dp[110][110];\nlong long solve(long long i, long long j, vector<long long>& num) {\n  if (j <= 0) return 1;\n  if (i < 0) return 0;\n  if (dp[i][j] != -1) return dp[i][j];\n  long long ans = 0;\n  long long tem = num[i] * solve(i - 1, j - 1, num);\n  tem %= 1000000007;\n  ans = solve(i - 1, j, num) % 1000000007;\n  return dp[i][j] = (ans + tem) % 1000000007;\n}\nlong long ways(vector<long long>& num) {\n  long long siz = num.size();\n  for (long long i = 0; i < siz + 1; i++)\n    for (long long j = 0; j < k + 1; j++) dp[i][j] = -1;\n  return solve(siz - 1, k, num);\n}\nvoid Runtime_Terror() {\n  cin >> n >> k;\n  for (long long i = 1; i < n + 1; i++) adj[i].clear();\n  for (long long i = 0; i < n + 1; i++)\n    for (long long j = 0; j < n + 1; j++) level[i][j] = 0;\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << n * (n - 1) / 2 << endl;\n    return;\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    parent[i][i] = -1;\n    DFS(i, -1, level[i], parent[i]);\n  }\n  long long ans = 0;\n  for (long long i = 1; i < n + 1; i++) {\n    vector<vector<long long>> dis(n + 1);\n    for (long long j = 1; j < n + 1; j++) {\n      dis[level[i][j]].push_back(j);\n    }\n    if (dis[1].size() >= k) {\n      vector<long long> num;\n      for (long long j = 0; j < dis[1].size(); j++) num.push_back(1);\n      ans += ways(num);\n      ans %= 1000000007;\n      set<long long> one;\n      for (auto& x : dis[1]) one.insert(x);\n      ;\n      for (long long j = 2; j < n + 1; j++) {\n        ;\n        map<long long, long long> onecnt;\n        onecnt.clear();\n        for (long long z = 0; z < dis[j].size(); z++) {\n          long long cur = dis[j][z];\n          ;\n          while (one.find(cur) == one.end()) {\n            ;\n            cur = parent[i][cur];\n          }\n          onecnt[cur]++;\n        };\n        num.clear();\n        for (auto& x : onecnt) num.push_back(x.second);\n        ans += ways(num);\n        ;\n        ;\n        ;\n        ans %= 1000000007;\n      }\n    };\n    ;\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  cin >> t;\n  for (long long i = 0; i < t; i++) Runtime_Terror();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 105, MOD = 1e9 + 7;\nvector<vector<long long>> adj;\nmap<long long, map<long long, long long>> cnt;\nlong long dep[N], ans, dp[N];\nlong long n, k;\nvoid dfs(long long u, long long p, long long root) {\n  cnt[root][dep[u]]++;\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dep[v] = dep[u] + 1;\n    dfs(v, u, root);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  adj.clear();\n  adj.resize(n + 1);\n  for (long long i = 0; i < n - 1; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  ans = 0;\n  if (k == 2) {\n    ans = n * (n - 1) / 2;\n  } else {\n    for (long long i = 1; i <= n; i++) {\n      cnt.clear();\n      for (auto v : adj[i]) {\n        dep[v] = 1;\n        dfs(v, i, v);\n      }\n      for (long long j = 1; j <= 100; j++) {\n        fill(dp, dp + N, 0);\n        dp[0] = 1;\n        for (auto v : adj[i]) {\n          for (long long kk = 100; ~kk; kk--) {\n            dp[kk + 1] = (dp[kk + 1] + dp[kk] * cnt[v][j] % MOD);\n          }\n        }\n        ans = (ans + dp[k]) % MOD;\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e2 + 5;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1e9 + 9;\nvector<long long> g[maxn];\nlong long dp[maxn][maxn];\nlong long depth[maxn][maxn];\nlong long maxdep, cc;\nvoid dfs(long long x, long long p, long long t, long long level) {\n  maxdep = max(maxdep, level);\n  if (t == -1) {\n    long long tot = 0;\n    for (auto i : g[x]) dfs(i, x, ++tot, 1);\n    cc = tot;\n  } else {\n    depth[t][level]++;\n    for (auto i : g[x]) {\n      if (i == p) continue;\n      dfs(i, x, t, level + 1);\n    }\n  }\n}\nlong long rundp(long long n, long long level, long long k) {\n  dp[0][0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    for (long long c = 0; c <= cc; c++) {\n      if (c == 0)\n        dp[i][c] = dp[i - 1][c];\n      else\n        dp[i][c] =\n            (dp[i - 1][c] + dp[i - 1][c - 1] * depth[i][level] % mod) % mod;\n    }\n  }\n  return dp[cc][k];\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k, ans = 0;\n    cin >> n >> k;\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 1; i < n; i++) {\n      long long u, v;\n      cin >> u >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << n * (n - 1) / 2 << '\\n';\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      maxdep = 0;\n      memset(depth, 0, sizeof(depth));\n      dfs(i, -1, -1, 0);\n      for (long long j = 1; j <= maxdep; j++) {\n        memset(dp, 0, sizeof(dp));\n        ans = (rundp(n, j, k) + ans) % mod;\n      }\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t;\nlong long k, n;\nlong long u_, v_;\nvector<long long> g[107];\nlong long d[107][107];\nlong long f[107][107];\nlong long v[107];\nlong long dfs(long long root, long long cur, long long dis) {\n  d[root][dis]++;\n  v[cur] = 1;\n  for (auto nxt : g[cur]) {\n    if (v[nxt] == 0) {\n      dfs(root, nxt, dis + 1);\n    }\n  }\n}\nsigned main() {\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    long long ans = 0;\n    for (long long i = 1; i <= n; ++i) {\n      g[i].clear();\n    }\n    for (long long i = 1; i <= n - 1; ++i) {\n      cin >> u_ >> v_;\n      g[u_].push_back(v_);\n      g[v_].push_back(u_);\n    }\n    if (k == 2) {\n      cout << ((n * (n - 1)) / 2) << endl;\n      continue;\n    }\n    for (long long i = 1; i <= n; ++i) {\n      if (g[i].size() >= k) {\n        memset(d, 0, sizeof(d));\n        memset(v, 0, sizeof(v));\n        v[i] = 1;\n        for (long long j = 0; j < g[i].size(); ++j) {\n          dfs(j + 1, g[i][j], 1);\n        }\n        for (long long dep = 1; dep <= n; dep++) {\n          for (long long j = 0; j <= g[i].size(); j++) {\n            f[j][0] = 1;\n          }\n          for (long long j = 1; j <= g[i].size(); j++) {\n            for (long long k = 1; k <= j; k++) {\n              f[j][k] =\n                  (f[j - 1][k] + (f[j - 1][k - 1] * d[j][dep]) % 1000000007) %\n                  1000000007;\n            }\n          }\n          ans += f[g[i].size()][k];\n          ans %= 1000000007;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 521, mod = 1e9 + 7;\nint n, K, cnt, mxdep, tot;\nint v[N], dep[N][N], f[N][N];\nstruct Edge {\n  int to, next;\n} e[N << 1];\nvoid add(int x, int y) {\n  e[++tot].to = y;\n  e[tot].next = v[x];\n  v[x] = tot;\n}\nvoid dfs(int x, int ff, int depth) {\n  ++dep[cnt][depth];\n  mxdep = max(mxdep, depth);\n  for (int p = v[x]; p; p = e[p].next)\n    if (e[p].to != ff) dfs(e[p].to, x, depth + 1);\n}\nint fpow(int x, int y) {\n  int res = 1;\n  for (; y; y >>= 1, x = 1ll * x * x % mod)\n    if (y & 1) res = 1ll * res * x % mod;\n  return res;\n}\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint main() {\n  int aq = read();\n  while (aq--) {\n    n = read();\n    K = read();\n    for (int i = 1; i <= n; i++) v[i] = 0;\n    tot = 0;\n    for (int x, y, i = 1; i < n; i++)\n      x = read(), y = read(), add(x, y), add(y, x);\n    if (K == 2) {\n      cout << 1ll * n * (n - 1) % mod * fpow(2, mod - 2) % mod << endl;\n      continue;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      cnt = mxdep = 0;\n      for (int j = 0; j <= n; j++)\n        for (int k = 0; k <= n; k++) dep[j][k] = 0;\n      for (int p = v[i]; p; p = e[p].next) ++cnt, dfs(e[p].to, i, 1);\n      for (int j = 1; j <= mxdep; j++) {\n        f[0][0] = 1;\n        for (int k = 1; k <= cnt; k++) {\n          f[k][0] = 1;\n          for (int t = 1; t <= min(k, K); t++) {\n            f[k][t] =\n                (f[k - 1][t] + 1ll * f[k - 1][t - 1] * dep[k][j] % mod) % mod;\n          }\n        }\n        (ans += f[cnt][K]) %= mod;\n      }\n    }\n    cout << ans << endl;\n    for (int i = 1; i <= n; i++) v[i] = 0;\n    tot = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong double pi = 3.14159265358979323846;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int p = 1e9 + 7, n, k;\nlong long int dis[101][101];\nvoid dfs(long long int node, long long int par, vector<long long int> v[]) {\n  dis[node][0] = 1;\n  for (auto it : v[node]) {\n    if (it != par) {\n      dfs(it, node, v);\n      for (long long int i = 1; i < n; i++) dis[node][i] += dis[it][i - 1];\n    }\n  }\n}\nlong long int cal(vector<long long int> &temp) {\n  long long int size = temp.size(), ans = 0, i, j;\n  if (size < k) return 0;\n  long long int dp[size + 1][k + 1];\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (i = 1; i <= size; i++) {\n    dp[i][0] = 1;\n    for (long long int j = 1; j <= k; j++) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * temp[i - 1]) % p;\n    }\n  }\n  return dp[size][k];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int count;\n    cin >> n >> k;\n    count = n - 1;\n    vector<long long int> v[n];\n    while (count--) {\n      long long int x, y;\n      cin >> x >> y;\n      x--, y--;\n      v[x].push_back(y);\n      v[y].push_back(x);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1)) / 2 << \"\\n\";\n      continue;\n    }\n    long long int ans = 0;\n    for (long long int i = 0; i < n; i++) {\n      for (long long int x = 0; x < n; x++)\n        for (long long int y = 0; y < n; y++) dis[x][y] = 0;\n      dfs(i, -1, v);\n      for (long long int x = 0; x < n; x++) {\n        vector<long long int> temp;\n        for (auto it : v[i]) temp.push_back(dis[it][x]);\n        ans = (ans + cal(temp)) % p;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 205, P = 1000000007;\nlong long T, n, k, x, y, num[N][N], f[N][N];\nstd::vector<long long> g[N];\nstd::vector<long long> a;\nvoid dfs(long long u, long long fa) {\n  num[u][0] = 1;\n  for (long long i = 0; i < (long long)g[u].size(); i++) {\n    long long v = g[u][i];\n    if (v == fa) continue;\n    dfs(v, u);\n    for (long long j = 1; j <= n; j++) num[u][j] += num[v][j - 1];\n  }\n}\nsigned main() {\n  std::cin >> T;\n  while (T--) {\n    std::cin >> n >> k;\n    long long ans = 0;\n    for (long long i = 1; i < n; i++)\n      std::cin >> x >> y, g[x].push_back(y), g[y].push_back(x);\n    if (k == 2) {\n      std::cout << n * (n - 1) / 2 << '\\n';\n      for (long long i = 1; i <= n; i++) g[i].clear();\n      continue;\n    }\n    for (long long i = 1; i <= n; i++) {\n      dfs(i, 0);\n      for (long long j = 1; j <= n; j++) {\n        for (long long l = 0; l < (long long)g[i].size(); l++)\n          a.push_back(num[g[i][l]][j - 1]);\n        f[0][0] = 1;\n        for (long long x = 1; x <= (long long)a.size(); x++) {\n          f[x][0] = 1;\n          for (long long y = 1; y <= x; y++)\n            f[x][y] = (f[x - 1][y] + f[x - 1][y - 1] * a[x - 1] % P) % P;\n        }\n        ans = (ans + f[a.size()][k]) % P;\n        for (long long x = 1; x <= (long long)a.size(); x++)\n          for (long long y = 1; y <= x; y++) f[x][y] = 0;\n        a.clear();\n      }\n      for (long long j = 1; j <= n; j++)\n        for (long long l = 0; l <= n; l++) num[j][l] = 0;\n    }\n    std::cout << ans << '\\n';\n    for (long long i = 1; i <= n; i++) g[i].clear();\n    for (long long i = 1; i <= n; i++)\n      for (long long j = 0; j <= n; j++) num[i][j] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nlong long mod = 1e9 + 7;\nint n, k;\nvector<int> e[maxn];\nint f[102][102], num[102][102];\nvoid dfs(int u, int p, int len, int fa) {\n  num[fa][len]++;\n  for (int v : e[u]) {\n    if (v == p) continue;\n    dfs(v, u, len + 1, fa);\n  }\n}\nint cal(vector<int> v) {\n  memset(f, 0, sizeof(f));\n  int res = 0;\n  int m = v.size();\n  f[0][0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j)\n        f[i][j] = (f[i - 1][j] + 1ll * f[i - 1][j - 1] * v[i - 1]) % mod;\n      else\n        f[i][j] = f[i - 1][j];\n    }\n  }\n  res = f[m][k] % mod;\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int _;\n  cin >> _;\n  while (_--) {\n    cin >> n >> k;\n    for (int i = (1); i <= (n - 1); ++i) {\n      int u, v;\n      cin >> u >> v;\n      e[u].push_back(v), e[v].push_back(u);\n    }\n    if (k == 2) {\n      cout << (n * (n - 1) / 2ll) % mod << endl;\n      for (int i = (1); i <= (n); ++i) e[i].clear();\n      continue;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      memset(num, 0, sizeof(num));\n      for (int v : e[i]) dfs(v, i, 1, v);\n      for (int d = 1; d <= n; d++) {\n        vector<int> vv;\n        for (int v : e[i]) vv.push_back(num[v][d]);\n        ans = (ans + cal(vv)) % mod;\n      }\n    }\n    cout << ans << endl;\n    for (int i = (1); i <= (n); ++i) e[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fastIO() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n}\nvector<int> edge[110];\nint dist[110];\nconst long long MOD = 1e9 + 7;\nint cnt[110][110];\nlong long dp[110][110][110];\nvoid dfs(int node, int pa = 0) {\n  for (int nx : edge[node]) {\n    if (nx == pa) continue;\n    dist[nx] = dist[node] + 1;\n    dfs(nx, node);\n  }\n}\nint main() {\n  fastIO();\n  int T;\n  cin >> T;\n  while (T--) {\n    int N, K;\n    cin >> N >> K;\n    for (int i = 1; i <= N; i++) edge[i].clear();\n    for (int i = 1; i <= N - 1; i++) {\n      int a, b;\n      cin >> a >> b;\n      edge[a].push_back(b);\n      edge[b].push_back(a);\n    }\n    if (K == 2) {\n      cout << (long long)N * (N - 1) / 2 << \"\\n\";\n      continue;\n    }\n    long long tot = 0;\n    for (int i = 1; i <= N; i++) {\n      for (int j = 0; j < (int)edge[i].size(); j++) {\n        for (int k = 0; k <= N; k++) {\n          cnt[j][k] = 0;\n          dist[k] = 0;\n        }\n        dist[edge[i][j]] = 1;\n        dfs(edge[i][j], i);\n        for (int k = 1; k <= N; k++) {\n          cnt[j][dist[k]]++;\n        }\n      }\n      for (int j = 0; j <= (int)edge[i].size(); j++) {\n        for (int k = 0; k <= K; k++) {\n          for (int l = 0; l <= N; l++) {\n            dp[j][k][l] = 0;\n          }\n        }\n        for (int l = 0; l <= N; l++) {\n          dp[j][0][l] = 1;\n        }\n      }\n      for (int j = 1; j <= (int)edge[i].size(); j++) {\n        for (int k = 1; k <= K; k++) {\n          for (int l = 1; l <= N; l++) {\n            dp[j][k][l] =\n                dp[j - 1][k - 1][l] * cnt[j - 1][l] % MOD + dp[j - 1][k][l];\n            dp[j][k][l] %= MOD;\n          }\n        }\n      }\n      for (int l = 1; l <= N; l++) {\n        tot += dp[(int)edge[i].size()][K][l];\n        tot %= MOD;\n      }\n    }\n    cout << tot << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nvector<int> sieve;\nvoid calc_sieve(int n) {\n  sieve.reserve(n + 1);\n  for (int i = 0, nnnn = (n + 1); i < nnnn; ++i) sieve[i] = i;\n  for (int i = 2, nnnn = (n + 1); i < nnnn; ++i) {\n    if (sieve[i] == i) {\n      for (ll j = i * i; j <= n; j += i) {\n        if (sieve[j] == j) sieve[j] = i;\n      }\n    }\n  }\n}\nll norm(ll a, ll P) {\n  while (a >= P) a -= P;\n  while (a < 0) a += P;\n  return a;\n}\nll mul_mod(ll a, ll b, ll P) { return a * b % P; }\nll pow_mod(ll a, ll b, ll P) {\n  ll curr = a, ans = 1;\n  while (b != 0) {\n    if (b & 1) {\n      ans *= curr;\n      ans %= P;\n    }\n    curr *= curr;\n    curr %= P;\n    b >>= 1;\n  }\n  return ans;\n}\nll inv_mod(ll a, ll P) { return pow_mod(a, P - 2ll, P); }\nll div_mod(ll a, ll b, ll P) { return a * inv_mod(b, P) % P; }\nint msb(ll a) {\n  for (int i = 62; i >= 0; i--) {\n    if (a & ((ll)1 << i)) return i + 1;\n  }\n  return 0;\n}\nvector<ll> fact;\nvoid calc_fact(int n, ll P) {\n  if (fact.size() < 1) fact.push_back(1);\n  for (int i = fact.size(), nnnn = (n + 1); i < nnnn; ++i)\n    fact.push_back(fact[i - 1] * i % P);\n}\nvector<ll> fact_inv;\nvoid calc_fact_inv(int n, ll P) {\n  if (fact_inv.size() < 1) fact_inv.push_back(1);\n  for (int i = fact_inv.size(), nnnn = (n + 1); i < nnnn; ++i)\n    fact_inv.push_back(fact_inv[i - 1] * inv_mod(i, P) % P);\n}\nll nCr(int n, int r, ll P) {\n  if (r > n) return 0;\n  calc_fact(n, P);\n  calc_fact_inv(n, P);\n  return (fact[n] * fact_inv[r] % P) * fact_inv[n - r] % P;\n}\nll nCr_inv(int n, int r, ll P) {\n  if (r > n) return 0;\n  calc_fact(n, P);\n  calc_fact_inv(n, P);\n  return (fact_inv[n] * fact[r] % P) * fact[n - r] % P;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long double eps = 1e-9;\nconst long long mod = 1000000007;\nconst int MAXN = 100;\nvector<int> adjlist[MAXN];\nvector<vector<int>> v;\nint n, k;\nll f[MAXN], invf[MAXN];\nvoid dfs(int curr, int dist, int p, vector<int> &v) {\n  v[dist]++;\n  for (int i : adjlist[curr]) {\n    if (i != p) {\n      dfs(i, dist + 1, curr, v);\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 0, nnnn = (n); i < nnnn; ++i) adjlist[i].clear();\n  for (int i = 0, nnnn = (n - 1); i < nnnn; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adjlist[a - 1].push_back(b - 1);\n    adjlist[b - 1].push_back(a - 1);\n  }\n  if (k == 2) {\n    cout << (n - 1) * n / 2 << endl;\n  } else {\n    ll ans = 0;\n    for (int i = 0, nnnn = (n); i < nnnn; ++i) {\n      v = vector<vector<int>>(adjlist[i].size(), vector<int>(n, 0));\n      for (int j = 0, nnnn = (adjlist[i].size()); j < nnnn; ++j) {\n        dfs(adjlist[i][j], 0, i, v[j]);\n      }\n      for (int j = 0, nnnn = (n); j < nnnn; ++j) {\n        ll dp[k];\n        memset(dp, 0, sizeof dp);\n        for (int l = 0, nnnn = (adjlist[i].size()); l < nnnn; ++l) {\n          for (int m = k - 1; m >= 1; m--)\n            dp[m] += dp[m - 1] * v[l][j], dp[m] %= mod;\n          dp[0] += v[l][j];\n        }\n        ans += dp[k - 1];\n      }\n    }\n    cout << ans % mod << endl;\n  }\n}\nint main() {\n  f[0] = 1;\n  invf[0] = 1;\n  for (int i = 1, nnnn = (MAXN); i < nnnn; ++i)\n    f[i] = f[i - 1] * i % mod, invf[i] = invf[i - 1] * inv_mod(i, mod) % mod;\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout << setprecision(12) << fixed;\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        }
    ]
}