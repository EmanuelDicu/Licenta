{
    "name": "698_B. Fix a Tree",
    "source": "CODEFORCES",
    "description": "A tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).\n\n<image> For this rooted tree the array p is [2, 3, 3, 2].\n\nGiven a sequence p1, p2, ..., pn, one is able to restore a tree:\n\n  1. There must be exactly one index r that pr = r. A vertex r is a root of the tree. \n  2. For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. \n\n\n\nA sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\nInput\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 200 000) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 n).\n\nOutput\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\nExamples\n\nInput\n\n4\n2 3 3 4\n\n\nOutput\n\n1\n2 3 4 4 \n\n\nInput\n\n5\n3 2 2 5 3\n\n\nOutput\n\n0\n3 2 2 5 3 \n\n\nInput\n\n8\n2 3 5 4 1 6 6 7\n\n\nOutput\n\n2\n2 3 7 8 1 6 6 7\n\nNote\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red.\n\n<image>\n\nIn the second sample, the given sequence is already valid.",
    "difficulty": "B",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "rating": 1700,
    "public_test": [
        {
            "input": "5\n3 2 2 5 3\n",
            "output": "0\n3 2 2 5 3 "
        },
        {
            "input": "8\n2 3 5 4 1 6 6 7\n",
            "output": "2 \n2 3 5 4 4 4 6 7 \n"
        },
        {
            "input": "4\n2 3 3 4\n",
            "output": "1 \n2 3 3 3 \n"
        }
    ],
    "generated_test": [
        {
            "input": "6\n6 2 1 2 4 2\n",
            "output": "0\n6 2 1 2 4 2\n"
        },
        {
            "input": "7\n1 2 3 4 5 1 7\n",
            "output": "5\n1 1 1 1 1 1 1\n"
        },
        {
            "input": "7\n4 3 2 6 5 5 2\n",
            "output": "1\n4 5 2 6 5 5 2\n"
        },
        {
            "input": "7\n1 2 3 4 7 1 7\n",
            "output": "4\n1 1 1 1 7 1 1\n"
        },
        {
            "input": "7\n4 3 1 6 5 5 2\n",
            "output": "0\n4 3 1 6 5 5 2\n"
        },
        {
            "input": "7\n1 2 3 7 7 1 7\n",
            "output": "3\n1 1 1 7 7 1 1\n"
        },
        {
            "input": "6\n3 2 6 2 4 2\n",
            "output": "0\n3 2 6 2 4 2\n"
        },
        {
            "input": "2\n2 2\n",
            "output": "0\n2 2\n"
        },
        {
            "input": "8\n2 1 2 2 6 5 6 2\n",
            "output": "2\n1 1 2 2 1 5 6 2\n"
        },
        {
            "input": "7\n7 5 3 1 4 1 5\n",
            "output": "1\n3 5 3 1 4 1 5\n"
        },
        {
            "input": "4\n3 3 3 4\n",
            "output": "1\n3 3 3 3\n"
        },
        {
            "input": "7\n1 2 3 4 5 1 4\n",
            "output": "4\n1 1 1 1 1 1 4\n"
        },
        {
            "input": "7\n4 3 2 6 5 5 3\n",
            "output": "1\n4 5 2 6 5 5 3\n"
        },
        {
            "input": "7\n4 3 1 6 5 2 2\n",
            "output": "1\n5 3 1 6 5 2 2\n"
        },
        {
            "input": "7\n4 1 1 6 5 2 2\n",
            "output": "1\n5 1 1 6 5 2 2\n"
        },
        {
            "input": "7\n1 2 3 1 5 1 4\n",
            "output": "3\n1 1 1 1 1 1 4\n"
        },
        {
            "input": "7\n4 1 1 6 5 3 2\n",
            "output": "1\n5 1 1 6 5 3 2\n"
        },
        {
            "input": "7\n4 1 1 6 4 3 2\n",
            "output": "1\n1 1 1 6 4 3 2\n"
        },
        {
            "input": "7\n4 1 1 6 4 3 1\n",
            "output": "1\n1 1 1 6 4 3 1\n"
        },
        {
            "input": "7\n7 1 2 6 4 3 1\n",
            "output": "1\n1 1 2 6 4 3 1\n"
        },
        {
            "input": "7\n7 1 2 6 4 3 2\n",
            "output": "1\n1 1 2 6 4 3 2\n"
        },
        {
            "input": "7\n7 2 2 6 4 3 2\n",
            "output": "0\n7 2 2 6 4 3 2\n"
        },
        {
            "input": "7\n7 4 2 6 4 3 2\n",
            "output": "1\n7 2 2 6 4 3 2\n"
        },
        {
            "input": "3\n2 2 1\n",
            "output": "0\n2 2 1\n"
        },
        {
            "input": "18\n2 3 4 5 2 7 8 9 2 7 11 12 14 15 13 17 18 18\n",
            "output": "4\n2 11 4 5 2 7 8 9 2 7 11 11 11 15 13 17 18 11\n"
        },
        {
            "input": "7\n1 2 3 5 5 6 7\n",
            "output": "5\n1 1 1 5 1 1 1\n"
        },
        {
            "input": "7\n4 3 2 7 3 5 2\n",
            "output": "1\n4 2 2 7 3 5 2\n"
        },
        {
            "input": "7\n7 5 3 1 2 1 6\n",
            "output": "2\n3 3 3 1 2 1 6\n"
        },
        {
            "input": "7\n1 6 4 2 5 6 7\n",
            "output": "3\n1 6 4 2 1 1 1\n"
        },
        {
            "input": "5\n5 2 2 5 3\n",
            "output": "0\n5 2 2 5 3\n"
        },
        {
            "input": "6\n4 2 1 2 4 2\n",
            "output": "0\n4 2 1 2 4 2\n"
        },
        {
            "input": "7\n4 3 4 6 5 5 3\n",
            "output": "0\n4 3 4 6 5 5 3\n"
        },
        {
            "input": "7\n5 3 1 6 5 5 2\n",
            "output": "0\n5 3 1 6 5 5 2\n"
        },
        {
            "input": "7\n7 2 3 1 4 1 5\n",
            "output": "2\n2 2 2 1 4 1 5\n"
        },
        {
            "input": "4\n3 3 1 4\n",
            "output": "1\n4 3 1 4\n"
        },
        {
            "input": "7\n6 3 2 6 5 5 3\n",
            "output": "1\n6 5 2 6 5 5 3\n"
        },
        {
            "input": "7\n4 3 1 6 5 1 2\n",
            "output": "1\n5 3 1 6 5 1 2\n"
        },
        {
            "input": "7\n1 2 2 7 5 1 4\n",
            "output": "3\n1 1 2 1 1 1 4\n"
        },
        {
            "input": "7\n4 1 1 6 5 1 2\n",
            "output": "1\n5 1 1 6 5 1 2\n"
        },
        {
            "input": "7\n1 2 3 1 3 1 4\n",
            "output": "2\n1 1 1 1 3 1 4\n"
        },
        {
            "input": "7\n5 1 1 6 5 3 2\n",
            "output": "0\n5 1 1 6 5 3 2\n"
        },
        {
            "input": "7\n4 1 1 6 2 3 1\n",
            "output": "1\n1 1 1 6 2 3 1\n"
        },
        {
            "input": "7\n7 2 2 6 4 3 4\n",
            "output": "0\n7 2 2 6 4 3 4\n"
        },
        {
            "input": "7\n1 4 4 6 4 3 2\n",
            "output": "1\n1 4 4 1 4 3 2\n"
        },
        {
            "input": "18\n2 3 4 5 2 7 4 9 2 7 11 12 14 15 13 17 18 18\n",
            "output": "4\n2 11 4 5 2 7 4 9 2 7 11 11 11 15 13 17 18 11\n"
        },
        {
            "input": "6\n4 2 1 2 4 3\n",
            "output": "0\n4 2 1 2 4 3\n"
        },
        {
            "input": "7\n4 3 4 6 3 5 3\n",
            "output": "1\n4 3 4 4 3 5 3\n"
        },
        {
            "input": "7\n5 3 2 6 5 5 2\n",
            "output": "1\n5 5 2 6 5 5 2\n"
        },
        {
            "input": "4\n3 3 2 4\n",
            "output": "1\n3 3 4 4\n"
        },
        {
            "input": "7\n4 3 1 7 5 1 2\n",
            "output": "1\n5 3 1 7 5 1 2\n"
        },
        {
            "input": "7\n1 2 2 7 5 1 3\n",
            "output": "2\n1 1 2 7 1 1 3\n"
        },
        {
            "input": "7\n1 2 3 2 3 1 4\n",
            "output": "2\n1 1 1 2 3 1 4\n"
        },
        {
            "input": "7\n4 1 1 7 2 3 1\n",
            "output": "1\n1 1 1 7 2 3 1\n"
        },
        {
            "input": "7\n7 2 1 6 4 3 4\n",
            "output": "1\n2 2 1 6 4 3 4\n"
        },
        {
            "input": "18\n2 3 4 5 2 7 4 6 2 7 11 12 14 15 13 17 18 18\n",
            "output": "4\n2 11 4 5 2 7 4 6 2 7 11 11 11 15 13 17 18 11\n"
        },
        {
            "input": "6\n4 2 1 2 1 3\n",
            "output": "0\n4 2 1 2 1 3\n"
        },
        {
            "input": "7\n5 3 2 6 5 1 2\n",
            "output": "1\n5 5 2 6 5 1 2\n"
        },
        {
            "input": "7\n4 3 1 7 5 1 1\n",
            "output": "1\n5 3 1 7 5 1 1\n"
        },
        {
            "input": "7\n1 2 3 7 5 1 4\n",
            "output": "4\n1 1 1 1 1 1 4\n"
        },
        {
            "input": "7\n7 1 1 6 4 3 1\n",
            "output": "1\n1 1 1 6 4 3 1\n"
        },
        {
            "input": "7\n1 4 2 6 4 3 2\n",
            "output": "1\n1 1 2 6 4 3 2\n"
        },
        {
            "input": "7\n6 1 1 6 4 3 2\n",
            "output": "1\n1 1 1 6 4 3 2\n"
        },
        {
            "input": "7\n4 1 2 6 4 3 2\n",
            "output": "1\n1 1 2 6 4 3 2\n"
        },
        {
            "input": "7\n5 1 2 6 4 3 2\n",
            "output": "1\n1 1 2 6 4 3 2\n"
        },
        {
            "input": "7\n1 4 2 7 5 1 3\n",
            "output": "2\n1 1 2 7 1 1 3\n"
        }
    ],
    "solution": [
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BFixATree solver = new BFixATree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BFixATree {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] arr = new int[n + 1];\n            ArrayList<Integer> roots = new ArrayList<>();\n            ArrayList<Integer> loops = new ArrayList<>();\n            BFixATree.DisjointSet ds = new BFixATree.DisjointSet(n);\n            for (int i = 1; i <= n; i++) {\n                arr[i] = in.nextInt();\n                if (arr[i] == i) roots.add(i);\n                else {\n                    if (ds.isInSameSet(arr[i], i)) {\n                        loops.add(i);\n                    } else ds.union(arr[i], i);\n                }\n            }\n            if (roots.size() == 0 && loops.size() == 0) {\n                out.printf(\"%d\\n\", 0);\n                for (int i = 1; i <= n; i++) out.printf(\"%d \", arr[i]);\n                return;\n            }\n            int changes = 0;\n            int top;\n            if (roots.size() != 0) top = roots.get(0);\n            else top = loops.get(0);\n            for (int x : loops) {\n                if (arr[x] != top) changes++;\n                arr[x] = top;\n            }\n            for (int x : roots) {\n                if (arr[x] != top) changes++;\n                arr[x] = top;\n            }\n            out.printf(\"%d\\n\", changes);\n            for (int i = 1; i <= n; i++) out.printf(\"%d \", arr[i]);\n        }\n\n        static class DisjointSet {\n            private int[] parent;\n            private int[] setSize;\n            private int numOfSets;\n\n            private DisjointSet(int n) {\n                parent = new int[n + 1];\n                setSize = new int[n + 1];\n                for (int i = 1; i <= n; i++) {\n                    parent[i] = i;\n                    setSize[i] = i;\n                }\n            }\n\n            private int root(int x) {\n                if (x == parent[x]) return x;\n                return parent[x] = root(parent[x]);\n            }\n\n            private boolean union(int n1, int n2) {\n                return _union(root(n1), root(n2));\n            }\n\n            private boolean _union(int n1, int n2) {\n                if (n1 == n2) return false;\n                if (setSize[n1] > setSize[n2]) {\n                    parent[n2] = parent[n1];\n                    setSize[n1] += setSize[n2];\n                } else {\n                    parent[n1] = parent[n2];\n                    setSize[n2] += setSize[n1];\n                }\n                numOfSets--;\n                return true;\n            }\n\n            private boolean isInSameSet(int n1, int n2) {\n                return root(n1) == root(n2);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public InputReader(FileInputStream file) {\n            this.stream = file;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = (res << 3) + (res << 1) + c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Wolfgang Beyer\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] p = in.readIntArray(n);\n\n            boolean[] visited = new boolean[n];\n            boolean[] visitedCurrently = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                visited[i] = false;\n                visitedCurrently[i] = false;\n                p[i]--;\n            }\n\n            int result = 0;\n            int root = -1;\n            int i = 0;\n            while ((i < n) && (p[i] != i)) i++;\n            if (i < n) root = i;\n            else {\n                int current = 0;\n                visitedCurrently[current] = true;\n                while (!visitedCurrently[p[current]]) {\n                    current = p[current];\n                    visitedCurrently[current] = true;\n                }\n                root = current;\n                result++;\n                p[root] = root;\n            }\n            //System.out.println(\"root: \" + root);\n\n            for (i = 0; i < n; i++) visitedCurrently[i] = false;\n\n            for (i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    visited[i] = true;\n                    visitedCurrently[i] = true;\n                    int current = i;\n                    while (!visited[p[current]]) {\n                        current = p[current];\n                        visited[current] = true;\n                        visitedCurrently[current] = true;\n                    }\n                    if ((p[current] != root) && (visitedCurrently[p[current]])) {\n                        result++;\n                        p[current] = root;\n                    }\n                    //for (int j = 0; j < n; j++) visitedCurrently[j] = false;\n                    current = i;\n                    while (visitedCurrently[current]) {\n                        visitedCurrently[current] = false;\n                        current = p[current];\n                    }\n                }\n            }\n\n            out.println(result);\n            for (i = 0; i < n; i++) out.print((p[i] + 1) + \" \");\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = nextInt();\n            }\n            return ar;\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 2e5 + 5;\nint n, answer, root, curr;\nint parent[NMAX];\nint vis[NMAX];\nvector<int> roots;\nvoid dfs(int node) {\n  if (vis[node] != 0) {\n    if (vis[node] == curr) {\n      parent[node] = node;\n      roots.push_back(node);\n    } else {\n      return;\n    }\n  }\n  vis[node] = curr;\n  if (node != parent[node]) {\n    dfs(parent[node]);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> parent[i];\n    if (parent[i] == i) {\n      root = i;\n      roots.push_back(i);\n    }\n  }\n  if (roots.empty()) answer = 1;\n  for (int i = 1; i <= n; ++i) {\n    ++curr;\n    dfs(i);\n  }\n  for (int &x : roots) {\n    parent[x] = roots[0];\n    ++answer;\n  }\n  --answer;\n  cout << answer << '\\n';\n  for (int i = 1; i <= n; ++i) {\n    cout << parent[i] << ' ';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int[] id;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int P[] = new int[N];\n            id = new int[N];\n            int root = -1;\n            int ans = 0;\n\n            for (int i = 0; i < N; i++) {\n                P[i] = in.nextInt() - 1;\n                if (P[i] == i) {\n                    root = i;\n                    ans = -1;\n                }\n            }\n\n            for (int i = 0; i < N; i++) id[i] = i;\n\n            for (int i = 0; i < N; i++) {\n                if (!union(P[i], i)) {\n                    if (root == -1) {\n                        root = i;\n                    }\n                    ans++;\n                    P[i] = root;\n                }\n            }\n\n            out.println(ans);\n            for (int i = 0; i < N; i++) out.print(P[i] + 1 + \" \");\n            out.println();\n        }\n\n        private boolean union(int p, int q) {\n            p = find(p);\n            q = find(q);\n\n            if (p == q) return false;\n\n            id[p] = q;\n            return true;\n        }\n\n        private int find(int p) {\n            return id[p] == p ? p : (id[p] = find(id[p]));\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O2\")\nusing namespace std;\nstruct debugger {\n  static void call(const char* it) {}\n  template <typename T, typename... valT>\n  static void call(const char* it, T val, valT... rest) {\n    string var = \"\";\n    for (; *it && *it != ','; it++)\n      if (*it != ' ') var += *it;\n    cerr << var << '=' << val << \" \";\n    call(++it, rest...);\n  }\n};\nconst int MAX = 2e5 + 10;\nint P[MAX], V[MAX], root = -1, cnt = 0;\nvoid dfs(int u) {\n  V[u] = 1;\n  int v = P[u];\n  if (!V[v]) {\n    dfs(v);\n  } else if (V[v] == 1) {\n    if (root != u) {\n      if (root == -1) root = u;\n      P[u] = root, cnt++;\n    }\n  }\n  V[u] = 2;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < (int)n; i++) {\n    scanf(\"%d\", &P[i + 1]);\n    if (P[i + 1] == i + 1) root = i + 1;\n  }\n  for (int i = 0; i < (int)n; i++) {\n    int u = i + 1;\n    if (!V[u]) {\n      dfs(u);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  for (int i = 0; i < (int)n; i++) {\n    printf(\"%d \", P[i + 1]);\n  }\n  puts(\"\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    static final String FILE = \"\";\n\n    int n;\n    int[] parent;\n    int[] ms;\n    boolean[] used;\n\n    int getParent(int v) {\n        if (parent[v] != -1)\n            return parent[v];\n        if (used[v]) {\n            parent[v] = v;\n            return parent[v];\n        }\n        used[v] = true;\n        if (ms[v] == v) {\n            parent[v] = v;\n            return parent[v];\n        }\n        parent[v] = getParent(ms[v]);\n        return parent[v];\n    }\n\n    public void solve() {\n        n = in.nextInt();\n        parent = new int[n];\n        ms = new int[n];\n        used = new boolean[n];\n        Arrays.fill(parent, -1);\n        for (int i = 0; i < n; i++)\n            ms[i] = in.nextInt() - 1;\n        int[] ans = ms.clone();\n        int cur = -1;\n        Set<Integer> set = new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            int par = getParent(i);\n            if (ms[par] == par) {\n                cur = par;\n            }\n            set.add(par);\n        }\n        if (cur == -1)\n            cur = getParent(0);\n        for (Integer it : set)\n            ans[it] = cur;\n        int raz = 0;\n        for (int i = 0; i < n; i++ ){\n            if (ms[i] != ans[i])\n                raz++;\n        }\n        out.println(raz);\n        for (Integer it : ans)\n            out.print((it + 1) + \" \");\n    }\n\n    public void run() {\n        if (FILE.equals(\"\")) {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                in = new FastScanner(new FileInputStream(FILE +\n                        \".in\"));\n                out = new PrintWriter(new FileOutputStream(FILE +\n                        \".out\"));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        (new Main()).run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n    }\n\n    class Pair<A extends Comparable<A>, B extends Comparable<B>>\n            implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> o) {\n            if (o == null || o.getClass() != getClass())\n                return 1;\n            int cmp = a.compareTo(o.a);\n            if (cmp == 0)\n                return b.compareTo(o.b);\n            return cmp;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (a != null ? !a.equals(pair.a) : pair.a != null) return\n                    false;\n            return !(b != null ? !b.equals(pair.b) : pair.b != null);\n        }\n    }\n\n    class PairInt extends Pair<Integer, Integer> {\n        public PairInt(Integer u, Integer v) {\n            super(u, v);\n        }\n    }\n\n    class PairLong extends Pair<Long, Long> {\n        public PairLong(Long u, Long v) {\n            super(u, v);\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class FixATree {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt(), root = -1;\n            DSU dsu = new DSU(n);\n            int[] res = new int[n];\n            ArrayList<Integer> np = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int parent = inp.nextInt() - 1;\n                if (i == parent && root == -1) {\n                    root = i;\n                    res[i] = i;\n                } else if (i == parent || dsu.sameSet(i, parent)) {\n                    np.add(i);\n                } else {\n                    dsu.union(i, parent);\n                    res[i] = parent;\n                }\n            }\n            out.println(np.size());\n            if (root == -1) {\n                root = np.remove(0);\n                res[root] = root;\n            }\n            for (int i: np) res[i] = root;\n            for (int i: res) out.print((i+1) + \" \");\n        }\n\n        public class DSU {\n            int[] p;\n\n            public DSU(int n) {\n                p = new int[n];\n                clear();\n            }\n\n            private void clear() {\n                for (int i = 0; i < p.length; i++) p[i] = i;\n            }\n\n            public int get(int x) {\n                int x2 = x;\n                while (x2 != p[x2]) x2 = p[x2];\n                while (x != p[x]) {\n                    int t = p[x];\n                    p[x] = x2;\n                    x = t;\n                }\n                return x2;\n            }\n\n            public void union(int a, int b) {\n                a = get(a);\n                b = get(b);\n                p[a] = b;\n            }\n\n            public boolean sameSet(int a, int b) {\n                return get(a) == get(b);\n            }\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class fixatree {\n\tpublic static void main(String[] aes)\n\t{\n\t\tInputReader in=new InputReader(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] parent=new int[n];\n\t\tint globalparent=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tparent[i]=in.nextInt()-1;\n\t\t\tif(parent[i]==i && globalparent==-1)\n\t\t\t{\n\t\t\t\tglobalparent=i;\n\t\t\t}\n\t\t}\n\t\tdisjointset ds=new disjointset(n);\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i!=parent[i])\n\t\t\t{\n\t\t\tif(ds.findset(i)==ds.findset(parent[i]))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\t//System.out.println(\"for i\"+i);\n\t\t\t\tif(globalparent!=-1)\n\t\t\t\t{\n\t\t\t\tparent[i]=globalparent;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[i]=i;\n\t\t\t\t\tglobalparent=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.mergeset(i, parent[i]);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count2=0;\n\t\tint last=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(parent[i]==i)\n\t\t\t{\n\t\t\t\tcount2++;\n\t\t\t\tlast=i;\n\t\t\t}\n\t\t}\n\t\tint count3=count2;\n\t\t\n\t\tfor(int i=0;i<n;i++ )\n\t\t{\n\t\t\tif(parent[i]==i && count2>1)\n\t\t\t{\n\t\t\t\tcount2--;\n\t\t\t\tparent[i]=last;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(count+\" \"+count3);\n\t\tint ans=count+count3-1;\n\t\tpw.println(ans);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpw.print((parent[i]+1)+\" \");\n\t\t}\n\t\tpw.close();\n\t\t\n\t}\n\tstatic class InputReader {\n\t\t \n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\nstatic  class disjointset {\n\tstatic int[] parent;\n\tstatic int[] rank;\n\tpublic disjointset(int n)\n\t{\n\t\tparent=new int[n];\n\t\trank=new int[n];\n\t\tthis.createSet(n);\n\t}\n\tpublic static void createSet(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t\treturn;\n\t}\n\tpublic static int findset(int x)\n\t{\n\t\tif(x!=parent[x])\n\t\t{\n\t\t\tparent[x]=findset(parent[x]);\n\t\t}\n\t\treturn parent[x];\n\t}\n\tpublic static void mergeset(int x,int y)\n\t{\n\t\tint px=findset(x);\n\t\tint py=findset(y);\n\t\tif(rank[px]>rank[py])\n\t\t{\n\t\t\tparent[py]=px;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[px]=py;\n\t\t}\n\t\tif(rank[px]==rank[py])\n\t\t{\n\t\t\trank[py]++;\n\t\t}\n\t}\n\n}\n\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200200;\nint a[N], cmp, ans;\nvector<int> adj[N];\nqueue<int> q;\nint visited[N];\nvoid dfs(int u, int par = -1) {\n  visited[u] = cmp;\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      dfs(v, u);\n    } else if (visited[v] == cmp) {\n      q.push(v);\n    }\n  }\n}\nint main() {\n  int n, x, root = -1;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    a[i] = x;\n    adj[i].push_back(x);\n    if (x == i) {\n      root = i;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      ++cmp;\n      dfs(i);\n    }\n  }\n  if (root == -1) {\n    root = q.front();\n    q.pop();\n    a[root] = root;\n    ++ans;\n  }\n  while (!q.empty()) {\n    a[q.front()] = root;\n    if (q.front() != root) ans++;\n    q.pop();\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", a[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint P[200005], N;\nvector<int> E[200005];\nint Color[200005];\nint BRKA, Root[200005], Size[200005], Sink[200005];\nvoid dfs(int x) {\n  if (Color[x]) return;\n  Color[x] = BRKA;\n  Size[BRKA]++;\n  for (int y : E[x]) dfs(y);\n}\nint nadji(int x, int step) {\n  while (step--) {\n    x = P[x];\n  }\n  return x;\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", P + i);\n    E[i].push_back(P[i]);\n    E[P[i]].push_back(i);\n  }\n  for (int i = 1; i <= N; i++) {\n    if (!Color[i]) {\n      BRKA++;\n      Root[BRKA] = i;\n      dfs(i);\n    }\n  }\n  for (int i = 1; i <= BRKA; i++) {\n    Sink[i] = nadji(Root[i], Size[i]);\n  }\n  int ima = -1;\n  for (int i = 1; i <= BRKA; i++) {\n    if (Sink[i] == P[Sink[i]]) ima = i;\n  }\n  if (ima != -1) {\n    swap(Root[ima], Root[1]);\n    swap(Size[ima], Size[1]);\n    swap(Sink[ima], Sink[1]);\n  }\n  int chg = 0;\n  for (int i = BRKA; i > 1; i--) {\n    P[Sink[i]] = Root[i - 1];\n    chg++;\n  }\n  if (ima == -1) {\n    P[Sink[1]] = Sink[1];\n    chg++;\n  }\n  printf(\"%d\\n\", chg);\n  for (int i = 1; i <= N; i++) printf(\"%d%c\", P[i], i == N ? '\\n' : ' ');\n  scanf(\"%d\", &N);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * @author pttrung\n */\n\npublic class B_Round_363_Div1 {\n\n    public static long MOD = 1000000007;  \n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner(); \n        int n = in.nextInt();\n        int[]data = new int[n];\n        int[]u = new int[n];\n        for(int i = 0; i< n; i++){\n            data[i] = in.nextInt() - 1;\n            u[i] = i;\n        }\n        int root = -1;\n        ArrayList<Integer> list = new ArrayList();\n        for(int i = 0; i < n ; i++){\n            if(data[i] == i){\n                if(root == -1){\n                    root = i;\n                }else{\n                    list.add(i);\n                }\n            }else{\n                if(find(i, u) != find(data[i], u)){\n                    u[find(i,u)] = find(data[i],u);\n                }else{\n                    list.add(i);\n                }\n            }\n        }\n        int result = 0;\n        if(root == -1){\n            result ++;\n            root = list.get(0);\n            data[root] = root;\n            list.remove((int)0);\n        }\n        for(int i : list){\n            result++;\n            data[i] = root;\n        }\n        out.println(result);\n        for(int i : data){\n            out.print((i + 1) + \" \" );\n        }\n        \n        out.close();\n    }\n    \n    static int find(int index, int[]u){\n        return u[index] = (index == u[index] ? index : find(u[index], u));\n    }\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b, long MOD) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2, MOD);\n        if (b % 2 == 0) {\n            return val * val % MOD;\n        } else {\n            return val * (val * a % MOD) % MOD;\n\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    class DSU {\n        int n;\n        int[] parent;\n        int comps;\n        DSU(int n) {\n            this.n = n;\n            parent = new int[n];\n            clear();\n        }\n\n        void clear() {\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n            comps = n;\n        }\n\n        int get(int u) {\n            if (parent[u] == u) {\n                return u;\n            }\n            return parent[u] = get(parent[u]);\n        }\n\n        boolean unite(int u, int v) {\n            u = get(u);\n            v = get(v);\n            if (u == v) {\n                return false;\n            }\n            parent[u] = v;\n            comps--;\n            return true;\n        }\n    }\n\n    public void solve() {\n        int n = in.nextInt();\n        DSU dsu = new DSU(n);\n        int root = -1;\n        int[] a = new int[n];\n        int[] ans = new int[n];\n\n        for (int i = 0; i < n; i++ ){\n            a[i] = in.nextInt() - 1;\n            dsu.unite(i, a[i]);\n            if (i == a[i] && root == -1) {\n                root = i;\n            }\n        }\n        ans = a.clone();\n\n        if (root == -1) {\n            dsu.clear();\n            for (int i = 0; i < n; i++) {\n                if (!dsu.unite(i, a[i])) {\n                    ans[i] = i;\n                    root = i;\n                    break;\n                }\n            }\n        }\n\n        dsu.clear();\n        for (int i = 0; i < n; i++) {\n            if (i == root) {\n                continue;\n            }\n            if (!dsu.unite(i, a[i])) {\n                ans[i] = root;\n                dsu.unite(i, ans[i]);\n            }\n        }\n\n        int diff = 0;\n        for (int i = 0; i < n; i++) {\n            diff += (a[i] != ans[i]) ? 1 : 0;\n        }\n        out.println(diff);\n        for (int i = 0; i < n; i++) {\n            out.print((ans[i] + 1) + \" \");\n        }\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new B().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod1 = 998244353;\nconst long long mod2 = 1000000007;\nint n, a[200005], c[200005], cnt;\nvector<int> g[200005];\nvector<int> fc[200005];\nvector<int> v;\nvoid dfs(int i) {\n  if (c[i] != 0) return;\n  c[i] = cnt;\n  fc[cnt].push_back(i);\n  for (int j = 0; j < (g[i].size()); j++) dfs(g[i][j]);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    g[i].push_back(a[i]);\n    g[a[i]].push_back(i);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (c[i] != 0) continue;\n    cnt++;\n    dfs(i);\n    int p = fc[cnt][0];\n    for (int j = 0; j < (fc[cnt].size()); j++) p = a[p];\n    v.push_back(p);\n  }\n  int s = -1;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] == i) {\n      cnt--;\n      s = i;\n      break;\n    }\n  }\n  if (s == -1) {\n    s = v[0];\n    a[s] = s;\n  }\n  for (int i = 0; i < (v.size()); i++)\n    if (v[i] != s) a[v[i]] = s;\n  cout << cnt << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << a[i];\n    cout << ((i == n) ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class FixaTree {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\t\tint a[] = new int[n];\n\t\tDisjointSets ds = new DisjointSets(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tif (!ds.inSameSet(i, p)) \n\t\t\t\tds.union(i, p);\n\t\t\ta[i] = p;\n\t\t}\n\n\t\tint root = -1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] == i) {\n\t\t\t\troot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (root == -1) {\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\tif (ds.parent[i] == -1) {\n\t\t\t\t\troot = i;\n\t\t\t\t\tds.parent[i] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) \n\t\t\tif (ds.parent[i] == -1) \n\t\t\t\tds.parent[i] = root;\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) \n\t\t\tif (ds.parent[i] != a[i])\n\t\t\t\tans++;\n\n\t\tout.println(ans);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(ds.parent[i] + 1);\n\t\t}\n\n\t\tout.println();\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class DisjointSets {\n\t\tint representative[];\n\t\tint rank[];\n\t\tint parent[];\n\n\t\tpublic DisjointSets(int n) {\n\t\t\trepresentative = new int[n];\n\t\t\trank = new int[n];\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < representative.length; i++)\n\t\t\t\trepresentative[i] = i;\n\t\t\tArrays.fill(rank, 1);\n\t\t\tArrays.fill(parent, -1);\n\t\t}\n\n\t\tint findSet(int x) {\n\t\t\tif (x == representative[x])\n\t\t\t\treturn x;\n\t\t\treturn representative[x] = findSet(representative[x]);\n\t\t}\n\n\t\tboolean inSameSet(int x,int y){\n\t\t\treturn (findSet(x) == findSet(y));\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tint x1 = findSet(x);\n\t\t\tint y1 = findSet(y);\n\t\t\tif (x1 != y1) {\n\t\t\t\tif (rank[x1] > rank[y1]) {\n\t\t\t\t\trepresentative[y1] = x1;\n\t\t\t\t} else if (rank[x1] < rank[y1]) {\n\t\t\t\t\trepresentative[x1] = y1;\n\t\t\t\t} else {\n\t\t\t\t\trepresentative[x1] = y1;\n\t\t\t\t\trank[y1]++;\n\t\t\t\t}\n\n\t\t\t\tparent[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean Ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput(long time) {\n\t\t\tlong ct = System.currentTimeMillis();\n\t\t\twhile(System.currentTimeMillis() - ct < time) {};\n\t\t}\n\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod1 = 998244353;\nconst long long mod2 = 1000000007;\nint n, p[200005], newp[200005];\nbool s[200005];\nbool cmp(int a, int b) { return abs(a - p[a]) < abs(b - p[b]); }\nint main() {\n  cin >> n;\n  for (int i = 0; i < (n); i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  vector<int> v;\n  for (int i = 0; i < (n); i++)\n    if (!s[i]) {\n      set<int> st;\n      int j;\n      for (j = i; !s[j]; j = p[j]) {\n        st.insert(j);\n        s[j] = 1;\n      }\n      if (st.count(j)) v.push_back(j);\n    }\n  sort(v.begin(), v.end(), cmp);\n  for (int i = 0; i < (n); i++) newp[i] = p[i];\n  for (int i = 0; i < (v.size()); i++) newp[v[i]] = v[0];\n  int ans = 0;\n  for (int i = 0; i < (n); i++) ans += (p[i] != newp[i]);\n  cout << ans << endl;\n  for (int i = 0; i < (n); i++)\n    cout << 1 + newp[i] << (i == n - 1 ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, ans[200005], A[200005], root = -1, f;\nbool b[200005];\nvector<int> v[200005];\nvector<int> cyc;\nvoid dfs(int u, int p) {\n  for (auto x : v[u]) {\n    if (b[x] && x != p) {\n      if (A[x] == u)\n        cyc.push_back(x);\n      else\n        cyc.push_back(u);\n    } else if (!b[x]) {\n      b[x] = 1;\n      dfs(x, u);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &A[i]);\n    if (A[i] == i) {\n      root = i;\n      f = 1;\n    }\n    v[i].push_back(A[i]);\n    v[A[i]].push_back(i);\n    ans[i] = A[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!b[i]) b[i] = 1, dfs(i, -1);\n  }\n  if (root == -1) {\n    root = cyc[0];\n  }\n  for (int i = 0; i < (int)cyc.size(); i++) ans[cyc[i]] = root;\n  int q = 0;\n  for (int i = 1; i <= n; i++)\n    if (A[i] != ans[i]) q++;\n  printf(\"%d\\n\", q);\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n\nI FOLLOW THE WAY OF THE RIGHT HONOURABLE JIM KWIK,\nGOD BLESS YOU SIR\n\n1.  I AM A 'NEWBIE' IN RATING\n2.  I WILL FAIL MANY TIMES, BUT I WILL NOT FAIL TO LEARN FROM FAILURE\n3.  I WILL NEVER SURRENDER MY GOAL, NO MATTER HOW MUCH I FAIL\n4.  I WILL PROVE MY SKILLS WHEN THE TIME COMES\n\n\n*/\n\n\n\n\n\nimport java.util.*;\nimport java.io.*;\npublic class A {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static boolean tests = false;\n    static ArrayList<Integer> roots, cycles, temp, graph[];\n    static boolean[] vis;\n    static void addEdge(int from, int to){\n        if (graph[from] == null) graph[from] = new ArrayList<>();\n        if (graph[to] == null) graph[to] = new ArrayList<>();\n        graph[from].add(to);\n        graph[to].add(-from);\n    }\n    static void find_root(int v){\n        if (vis[v]){\n            // detected a cycle\n            cycles.add(v);\n            return;\n        }\n        vis[v] = true;\n        temp.add(v);\n        for (int to : graph[v]) if (v == to){\n            roots.add(v);\n            return;\n        }\n        for (int to : graph[v]) if (to < 0){\n            find_root(-to);\n        }\n    }\n    static void mark_component(int v){\n        //out.print(Math.abs(v)+\" \");\n        vis[Math.abs(v)] = true;\n        for (int to : graph[Math.abs(v)]) if (!vis[Math.abs(to)]){\n            mark_component(to);\n        }\n    }\n    static void solve(){\n        int n = fs.nextInt();\n        int[] seq = fs.readIntArray(n);\n        graph = new ArrayList[n+1];\n        roots = new ArrayList<>();\n        cycles = new ArrayList<>();\n        temp = new ArrayList<>();\n        vis = new boolean[n+1];\n        for (int i = 1; i <= n; ++i){\n            addEdge(seq[i-1], i);\n        }\n        for (int i = 1; i <= n; ++i){\n            if (vis[i]) continue;\n            find_root(i);\n            for (int v : temp) vis[v] = false;\n            mark_component(i);\n            temp.clear();\n        }\n        for (int x : cycles) roots.add(x);\n       // out.println(roots.size()-1);\n        int cnt = 0;\n        for (int i = 0; i < roots.size(); ++i){\n            int p = seq[roots.get(i)-1];\n            seq[roots.get(i)-1] = roots.get(0);\n            if (p != seq[roots.get(i)-1]) ++cnt;\n        }\n        out.println(cnt);\n        for (int x : seq) out.print(x+\" \");\n        out.println();\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static FastScanner fs;\n    static PrintWriter out;\n    static int int_max = (int)1e9, mod = int_max+7;\n    public static void main(String[] args) {\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        int t = 1;\n        if (tests) t = fs.nextInt();\n        while (t-- > 0) solve();\n        out.close();\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readIntArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long[] readLongArray(int n){\n            long a[] = new long[n];\n            for (int i = 0; i < n; ++i){\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 1000 * 1000 * 1000 + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    List<List<Integer>> graph = new ArrayList<>();\n    List<List<Integer>> comp = new ArrayList<>();\n    boolean[] vis;\n    int[] arr;\n    void solve() throws IOException {\n        n = nextInt();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        arr = nextIntArr(n);\n        for (int i = 0; i < n; i++) {\n            int u = i;\n            int v = arr[i] - 1;\n            if (u != v) {\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n            }\n        }\n\n        int same = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == arr[i] - 1) {\n                same++;\n            }\n        }\n\n        vis = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!vis[i]) {\n                List<Integer> ls = new ArrayList<>();\n                findComp(i, ls, -1);\n                comp.add(ls);\n            }\n        }\n\n        Arrays.fill(vis, false);\n        List<Integer> roots = new ArrayList<>();\n        for (List<Integer> com : comp) {\n            roots.add(findRoot(com));\n        }\n\n        if (comp.size() == 1) {\n            if (same == 1) {\n                outln(0);\n                for (int i = 0; i < n; i++) {\n                    out(arr[i] + \" \");\n                }\n                return;\n            }\n        }\n\n        int[] res = Arrays.copyOf(arr, n);\n        int cnt = 0;\n        int root = -1;\n        for (int v : roots) {\n            if (v == arr[v] - 1) {\n                root = v;\n            }\n        }\n\n        if (root == -1) {\n            root = roots.get(0);\n            if (root != arr[root] - 1) {\n                cnt++;\n                res[root] = root + 1;\n            }\n            for (int i = 0; i < roots.size(); i++) {\n                int cur = roots.get(i);\n                if (cur != root) {\n                    cnt++;\n                    res[cur] = root + 1;\n                }\n            }\n\n            outln(cnt);\n            for (int i = 0; i < n; i++) {\n                out(res[i] + \" \");\n            }\n\n            return;\n        }\n\n        for (int v : roots) {\n            if (v != root) {\n                cnt++;\n                res[v] = root + 1;\n            }\n        }\n\n        outln(cnt);\n        for (int i = 0; i < n; i++) {\n            out(res[i] + \" \");\n        }\n    }\n\n    int findRoot(List<Integer> com) {\n        int start = com.get(0);\n        while (true) {\n            if (vis[start]) {\n                break;\n            }\n\n            vis[start] = true;\n            start = arr[start] - 1;\n        }\n\n        return start;\n    }\n\n    void findComp(int cur, List<Integer> ls, int parent) {\n        if (vis[cur]) {\n            return;\n        }\n\n        ls.add(cur);\n        vis[cur] = true;\n        for (int nxt : graph.get(cur)) {\n            if (nxt == parent) {\n                continue;\n            }\n            findComp(nxt, ls, cur);\n        }\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        System.out.format(\"%.9f%n\", val);\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int oo = (int)1e9;\n\tstatic int mod = 1_000_000_007;\n\t\n\tstatic int[] di = {-1, 1, 0, 0};\n\tstatic int[] dj = {0, 0, -1, 1};\n\t\n\tstatic int cnt = 0;\n\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = in.nextInt();\n\t\tint[] par = new int[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tpar[i] = in.nextInt() - 1;\n\t\t}\n\t\tint root = -1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(par[i] == i)\n\t\t\t\troot = i;\n\t\t}\n\t\tint[] seen = new int[n];\n\t\tArrays.fill(seen, -1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint idx = i;\n\t\t\twhile(seen[idx] == -1 && par[idx] != idx) {\n\t\t\t\tseen[idx] = i;\n\t\t\t\tidx = par[idx];\n\t\t\t}\n\t\t\tif(seen[idx] == i) {\n\t\t\t\tcnt++;\n\t\t\t\tif(root == -1) {\n\t\t\t\t\troot = idx;\n\t\t\t\t}\n\t\t\t\tpar[idx] = root;\n\t\t\t}\n\t\t\telse if(par[idx] == idx && idx != root) {\n\t\t\t\tcnt++;\n\t\t\t\tpar[idx] = root;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\tfor(int p : par)\n\t\t\tSystem.out.print(p+1 + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int findRoot(int[] par, int[] r, boolean[] visit, int i, int root) {\n\t\tif(par[i] == i)\n\t\t\treturn r[i] = i;\n\t\tif(r[i] != 0)\n\t\t\treturn r[i];\n\t\tif(visit[i]) {\n\t\t\tcnt++;\n\t\t\treturn r[i] = par[i] = (root == -1 ? i : root);\n\t\t}\n\t\tvisit[i] = true;\n\t\treturn r[i] = findRoot(par, r, visit, par[i], root);\n\t}\n\t\n\tstatic class SegmentTree {\n\t\tint n;\n\t\tlong[] a, seg;\n\t\tint DEFAULT_VALUE = 0;\n\t\t\n\t\tpublic SegmentTree(long[] a, int n) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.n = n;\n\t\t\tseg = new long[n * 4 + 1];\n\t\t\tbuild(1, 0, n-1);\n\t\t}\n\t\t\n\t\tprivate long build(int node, int i, int j) {\n\t\t\tif(i == j)\n\t\t\t\treturn seg[node] = a[i];\n\t\t\tlong first = build(node * 2, i, (i+j) / 2);\n\t\t\tlong second = build(node * 2 + 1, (i+j) / 2 + 1, j);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong update(int k, long value) {\n\t\t\treturn update(1, 0, n-1, k, value);\n\t\t}\n\t\t\n\t\tprivate long update(int node, int i, int j, int k, long value) {\n\t\t\tif(k < i || k > j)\n\t\t\t\treturn seg[node];\n\t\t\tif(i == j && j == k) {\n\t\t\t\ta[k] = value;\n\t\t\t\tseg[node] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = update(node * 2, i, m, k, value);\n\t\t\tlong second = update(node * 2 + 1, m + 1, j, k, value);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong query(int l, int r) {\n\t\t\treturn query(1, 0, n-1, l, r);\n\t\t}\n\t\t\n\t\tprivate long query(int node, int i, int j, int l, int r) {\n\t\t\tif(l <= i && j <= r)\n\t\t\t\treturn seg[node];\n\t\t\tif(j < l || i > r)\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = query(node * 2, i, m, l, r);\n\t\t\tlong second = query(node * 2 + 1, m+1, j, l, r);\n\t\t\treturn combine(first, second);\n\t\t}\n \n\t\tprivate long combine(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n\t\n\tstatic class DisjointSet {\n\t\tint n;\n\t\tint[] g;\n\t\tint[] h;\n\t\tpublic DisjointSet(int n) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tg = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = i;\n\t\t\t\th[i] = 1;\n\t\t\t}\n\t\t}\n\t\tint find(int x) {\n\t\t\tif(g[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn g[x] = find(g[x]);\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = find(x); y = find(y);\n\t\t\tif(x == y)\n\t\t\t\treturn;\n\t\t\tif(h[x] >= h[y]) {\n\t\t\t\tg[y] = x;\n\t\t\t\tif(h[x] == h[y])\n\t\t\t\t\th[x]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tstatic int[] getPi(char[] a) {\n\t\tint m = a.length;\n\t\tint j = 0;\n\t\tint[] pi = new int[m];\n\t\tfor(int i = 1; i < m; ++i) {\n\t\t\twhile(j > 0 && a[i] != a[j])\n\t\t\t\tj = pi[j-1];\n\t\t\tif(a[i] == a[j]) {\n\t\t\t\tpi[i] = j + 1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn pi;\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n\t\t\n//\t\t@Override\n//\t\tpublic int compareTo(Pair o) {\n//\t\t\treturn this.first != o.first ? o.first - this.first : o.second - this.second;\n//\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class FixATree { \n\tstatic int[] arr1 = new int[200001];\n\tstatic int[] arr2 = new int[200001];\n\tstatic int find(int x){\n\t\tif(arr2[x]==x) return x;\n\t\treturn arr2[x]=find(arr2[x]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tint n,m,a,b;\n\t\tint ans=0;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tm=-1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tarr1[i]=in.nextInt();\n\t\tfor(int i=1;i<=n;i++) \n\t\t\tarr2[i]=i;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta=find(i);\n\t\t\tb=find(arr1[i]);\n\t\t\tif(a!=b) \n\t\t\t\tarr2[a]=b;\n\t\t\tif(m<0&&arr1[i]==i) \n\t\t\t\tm=i;\n\t\t}\n\t\tif(m<0){\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(arr2[i]==i) { \n\t\t\t\t\tm=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(arr2[i]==i&&arr1[i]!=m){\n\t\t\t\tarr1[i]=m;\n\t\t\t \tans++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tSystem.out.print(arr1[i]+\" \");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT next_int() {\n  T x = 0, p = 1;\n  char ch;\n  do {\n    ch = getchar();\n  } while (ch <= ' ');\n  if (ch == '-') {\n    p = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * p;\n}\nconst int max_n = (int)1e6 + 227 + 1;\nconst int max_int = (int)1e9 + 227 + 1;\nconst int mod = (int)1e9 + 7;\nvector<vector<int> > a;\nvector<bool> used;\nvector<int> lol;\nvoid go(int v, int pr) {\n  if (used[v]) return;\n  used[v] = 1;\n  for (int i = 0; i < a[v].size(); i++) {\n    if (a[v][i] == pr) continue;\n    if (used[a[v][i]]) {\n      lol.back() = v;\n    }\n    go(a[v][i], v);\n  }\n}\nint main() {\n  int n = next_int<int>();\n  int k = 0;\n  vector<int> p(n);\n  a.resize(n);\n  for (int i = 0; i < n; i++) {\n    p[i] = next_int<int>() - 1;\n    k += (p[i] == i);\n    a[p[i]].push_back(i);\n    a[i].push_back(p[i]);\n  }\n  used.resize(n);\n  for (int i = 0; i < n; i++) used[i] = 0;\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) lol.push_back(-1);\n    go(i, -1);\n  }\n  int pe = -1;\n  for (int i = 0; i < lol.size(); i++) {\n    if (p[lol[i]] == lol[i]) pe = i;\n  }\n  cout << (int)lol.size() - (pe != -1) << \"\\n\";\n  if (pe == -1) {\n    p[lol[0]] = lol[0];\n    pe = 0;\n  }\n  for (int i = 0; i < lol.size(); i++) {\n    if (i == pe) continue;\n    p[lol[i]] = lol[pe];\n  }\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(time(0));\nconst long long N = 2e5 + 7;\nconst long long MOD = 1e9 + 7;\nlong long pw(long long b, long long p) {\n  b %= MOD;\n  long long res = 1;\n  while (p > 0) {\n    if (p & 1) res = res * b % MOD;\n    b = b * b % MOD;\n    p >>= 1;\n  }\n  return res;\n}\nvector<long long> par(N);\nlong long find(long long x) {\n  if (par[x] == x) return x;\n  return par[x] = find(par[x]);\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  for (long long i = 1; i < n + 1; i++) {\n    par[i] = i;\n  }\n  vector<long long> a(n + 1);\n  long long cnt = 0, root = 0;\n  for (long long i = 1; i < n + 1; i++) {\n    cin >> a[i];\n    if (a[i] == i) {\n      root = i;\n      cnt++;\n    } else {\n      long long x = find(i), y = find(a[i]);\n      if (x == y) {\n        a[i] = i;\n        cnt++;\n      } else {\n        par[i] = a[i];\n      }\n    }\n  }\n  if (root == 0) {\n    for (long long i = 1; i < n + 1; i++) {\n      if (a[i] == i) root = i;\n    }\n    cnt++;\n  }\n  cout << cnt - 1 << '\\n';\n  for (long long i = 1; i < n + 1; i++) {\n    cout << ((a[i] == i) ? root : a[i]) << ' ';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main \n{\n\tint V;\n\tLinkedList<Integer> list[];\n\tstatic int value = Integer.MAX_VALUE;\n\t\n\tMain(int V)\n\t{\n\t\tthis.V = V;\n\t\tlist = new LinkedList[V+1];\n\t\tfor(int i=1;i<=V;i++)\n\t\t\tlist[i] = new LinkedList<Integer>();\n\t}\n\t\n\t\n\tpublic void addEdge(int src, int dest)\n\t{\n\t\tlist[src].add(dest);\n\t\tlist[dest].add(src);\n\t}\n\t\n\t\n\tpublic void dfs(int src, boolean visited[], int cost[])\n\t{\n\t\tvisited[src] =true;\n\t\tif(value>cost[src])\n\t\t\tvalue=cost[src];\n\t\tfor(Integer x:list[src])\n\t\t{\n\t\t\tif(!visited[x])\n\t\t\t{\n\t\t\t\tdfs(x, visited, cost);\n\t\t\t}\n\t\t}\n\t}\n\tpublic long dfs(int cost[])\n\t{\n\t\tlong answer = 0;\n\n\t\tboolean visited[] = new boolean[V+1];\n\t\tfor(int i=1;i<=V;i++)\n\t\t{\n\t\t\tif(!visited[i])\n\t\t\t{\n\t\t\t\tdfs(i, visited, cost);\n//\t\t\t\tSystem.out.println(value);\n//\t\t\t\tSystem.out.println(Arrays.toString(visited));\n\t\t\t\tanswer += value;\n\t\t\t\tvalue = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint parent[] = new int[n+1];\n\t\tDisjointSetImplementationUsingArray set = new DisjointSetImplementationUsingArray(n);\n\t\tint par = -1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tparent[i]  = scan.nextInt();\n\t\t\tif(parent[i] == i)\n\t\t\t\tpar = i;\n\t\t}\n\n\t\tint count =0;\n\t\t\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tboolean flag  = set.union(parent[i], i);\n\t\t\tif(!flag && par ==-1)\n\t\t\t{\n\t\t\t\tpar = i;\n\t\t\t\tparent[i] = par;\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!flag && i!=par)\n\t\t\t{\n\t\t\t\tset.union(i, par);\n\t\t\t\tparent[i] = par;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(\"\");\n\t\tsb.append(count+\"\\n\");\n\t\tfor(int i=1;i<=n;i++)\n\t    \tsb.append(parent[i]+\" \");\n\t    System.out.println(sb);\n\t}\n\t\n}class DisjointSetImplementationUsingArray \n{\n\tpublic int [] rank;\n\tpublic int [] parent;\n\tpublic int size[] ;\n\t\n\t\t\t\n\tint n;\n\t\n\tpublic DisjointSetImplementationUsingArray(int n) \n\t{\n\n\t\tparent = new int[n+1];\n\t\tthis.n= n;\n\t\tsize = new int[n+1];\n\t\tmakeSet();\n\t}\n\t\n\t\n\tpublic void makeSet()\n\t{\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\tpublic boolean union(int x, int y) \n    { \n        int xRoot = findSet(x), yRoot = findSet(y); \n        if (xRoot == yRoot) \n            return false; \n  \n        if (size[xRoot] < size[yRoot])  \n        {\n            parent[xRoot] = yRoot; \n            size[yRoot] += size[xRoot];\n        }\n        else if (size[yRoot] < size[xRoot]) \n        {\n\n            size[xRoot] += size[yRoot];\n            parent[yRoot] = xRoot; \n        }\n  \n        else \n        {  \n            parent[yRoot] = xRoot; \n            size[xRoot] += size[yRoot];\n            // And increment the the result tree's \n           // rank by 1 \n        } \n        return true;\n    }\n\t\n\t\n\t\n\tpublic int findSet(int x)\n\t{\n\t\t\n\t\tif(parent[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t{\n\t\t\twhile(parent[x]!=x)\n\t\t\t{\n\t\t\t\tx=parent[x];\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\t\n\t\n\tpublic int findSetSize(int element)\n\t{\n\t\tint parent = findSet(element);\n\t\treturn size[parent];\n\t}\n\t\n\tpublic int findNoOfSets() \n\t{\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\thash.add(findSet(i));\n\t\t}\n\t\treturn hash.size();\n\t}\n}\n\t"
        },
        {
            "language": 3,
            "solution": "from collections import  defaultdict\nfrom sys import stdin,setrecursionlimit\nsetrecursionlimit(10**6)\nimport threading\ndef f(a):\n\tn=len(a)\n\ta=list(map(lambda s:s-1,a))\n\troot=None\n\tfor i in range(len(a)):\n\t\tif a[i]==i:\n\t\t\troot=i\n\tvis=[0]*(n)\n\ttraitors=[]\n\tfor i in range(0,n):\n\t\tcycle=-1\n\t\tcur=i\n\t\tmove=set()\n\n\t\twhile vis[cur]==0:\n\t\t\tvis[cur]=1\n\t\t\tmove.add(cur)\n\t\t\tif a[cur] in move:\n\t\t\t\tcycle=cur\n\t\t\tcur=a[cur]\n\t\tif cycle!=-1:\n\t\t\ttraitors.append(cycle)\n\tans=len(traitors)-1\n\tif root==None:\n\t\ta[traitors[0]]=traitors[0]\n\t\troot=traitors[0]\n\t\tans+=1\n\tfor i in traitors:\n\t\tif i!=root:\n\t\t\ta[i]=root\n\tprint(ans)\n\ta=list(map(lambda s:s+1,a))\n\treturn a\nn=input()\na=list(map(int,input().strip().split()))\nprint(*f(a))"
        },
        {
            "language": 4,
            "solution": "\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main2 {\n\t\n\tvoid solve() {\n\t\tint N = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(N);\n\t\tfor (int i = 0; i < N; i++) a[i]--;\n\t\tint[] mark = new int[N];\n\t\t\n\t\tint root = 0;\n\t\tint rootNum = 0;\n\t\tfor (int i = 0; i < N; i++) if (a[i] == i) {\n\t\t\trootNum++;\n\t\t\troot = i;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tif (rootNum == 0) {\n\t\t\tint v = 0;\n\t\t\twhile (mark[v] == 0){\n\t\t\t\tmark[v] = 1;\n\t\t\t\tv = a[v];\n\t\t\t}\n\t\t\ta[v] = v;\n\t\t\troot = v;\n\t\t\tans++;\n\t\t} else if (rootNum >= 2) {\n\t\t\tfor (int i = 0; i < N; i++) if (a[i] == i && i != root) {\n\t\t\t\ta[i] = root;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(mark, 0);\n\t\tint age = 0;\n\t\tmark[root] = ++age;\n\t\tfor (int i = 0; i < N; i++) if (mark[i] == 0) {\n\t\t\t++age;\n\t\t\tint v = i;\n\t\t\twhile (mark[v] == 0) {\n\t\t\t\tmark[v] = age;\n\t\t\t\tv = a[v];\n\t\t\t}\n\t\t\tif (mark[v] == age) {\n\t\t\t\ta[v] = root;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\tfor (int i = 0; i < N; i++) a[i]++;\n\t\tprint(a);\n\t}\n\t\n\tstatic void tr(Object... os) { System.err.println(deepToString(os)); }\n\tstatic void tr(int[][] as) { for (int[] a : as) tr(a); }\n\n\tvoid print(int[] a) {\n\t\tif (a.length > 0) out.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main2().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing LL = long long;\nconst int N = 200000 + 5;\nint A[N], n;\nint vis[N], tim;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", A + i);\n  }\n  std::vector<int> bad;\n  for (int i = 1; i <= n; ++i) {\n    if (vis[i] == 0) {\n      tim++;\n      for (int u = i;; u = A[u]) {\n        vis[u] = tim;\n        if (vis[A[u]] == tim) {\n          bad.emplace_back(u);\n          break;\n        } else if (vis[A[u]]) {\n          break;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < (int)bad.size(); ++i) {\n    if (A[bad[i]] == bad[i]) {\n      std::rotate(bad.begin(), bad.begin() + i, bad.end());\n      break;\n    }\n  }\n  int cost = (int)bad.size() - (A[bad[0]] == bad[0]);\n  for (int x : bad) A[x] = bad[0];\n  printf(\"%d\\n\", cost);\n  for (int i = 1; i <= n; ++i) {\n    printf(\"%d%c\", A[i], \" \\n\"[i == n]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nconst int inf = 1e9;\nint p[maxn], f[maxn], n;\nint root(int x) {\n  if (!f[x]) return x;\n  return f[x] = root(f[x]);\n}\nint merge(int x, int y) {\n  x = root(x);\n  y = root(y);\n  if (x == y) return 0;\n  f[x] = y;\n  return 1;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n    if (merge(i, p[i]))\n      cnt++;\n    else if (i != p[i])\n      p[i] = -1;\n  }\n  int x = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!f[i] && p[i] != -1) {\n      x = i;\n      break;\n    }\n  }\n  if (x == 0) {\n    x = root(1);\n    cnt--;\n  }\n  printf(\"%d\\n\", n - 1 - cnt);\n  for (int i = 1; i <= n; i++) {\n    if (!f[i]) {\n      p[i] = x;\n    }\n    printf(\"%d \", p[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 200100;\nint n, a[MAX], czas[MAX];\nvector<int> cykl;\nvoid wczytaj_dane() {\n  cin >> n;\n  for (int i = (1); i <= (n); i++) cin >> a[i];\n}\nint znajdz_cykl(int v, int t) {\n  while (czas[v] == 0) {\n    czas[v] = t;\n    v = a[v];\n  }\n  return czas[v] == t ? v : -1;\n}\nvoid wypelnij_cykl() {\n  fill(czas, czas + MAX, 0);\n  int t = 1;\n  for (int v = (1); v <= (n); v++) {\n    int u = znajdz_cykl(v, t++);\n    if (u != -1) cykl.push_back(u);\n  }\n}\nint znajdz_staly_cykl() {\n  for (int i = 0; i < ((int((cykl).size()))); i++)\n    if (a[cykl[i]] == cykl[i]) return cykl[i];\n  return -1;\n}\nint rozwiaz() {\n  int staly = znajdz_staly_cykl(), licz = 0;\n  if (staly == -1) {\n    a[cykl[0]] = cykl[0];\n    staly = cykl[0];\n    licz++;\n  }\n  for (int i = 0; i < ((int((cykl).size()))); i++)\n    if (a[cykl[i]] != staly) {\n      a[cykl[i]] = staly;\n      licz++;\n    }\n  return licz;\n}\nvoid wypisz_rozwiazanie() {\n  for (int i = (1); i <= (n); i++) cout << a[i] << ' ';\n  cout << '\\n';\n}\nvoid zrob_test() {\n  wczytaj_dane();\n  wypelnij_cykl();\n  cout << rozwiaz() << '\\n';\n  wypisz_rozwiazanie();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  zrob_test();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tboolean[] visited;\n\tboolean[] cur;\n\tint findRoot(int[] par, int u) {\n\t\tif (cur[par[u]]) return par[u];\n\t\tif (visited[par[u]]) return -1;\n\t\t\n\t\tcur[u] = true;\n\t\tvisited[u] = true;\n\t\t\n\t\tint res = findRoot(par, par[u]);\n\t\tcur[u] = false;\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = in.nextInt() - 1;\n\t\t}\n\t\tint[] q = Arrays.copyOf(p, n);\n\n\t\tint res = 0;\n\t\tint[] roots = new int[n];\n\t\tvisited = new boolean[n];\n\t\tcur = new boolean[n];\n\t\tint size = 0;\n\t\tint root = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tint nextRoot = findRoot(q, i);\n\t\t\tif (nextRoot != -1) {\n\t\t\t\tif (q[nextRoot] != nextRoot) {\n\t\t\t\t\tq[nextRoot] = nextRoot;\n\t\t\t\t} else {\n\t\t\t\t\troot = nextRoot;\n\t\t\t\t}\n\t\t\t\troots[size++] = nextRoot;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (root == -1) {\n\t\t\troot = roots[0];\n\t\t\tres = size;\n\t\t} else \n\t\t\tres = size - 1;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tif (roots[i] == root) continue;\n\t\t\t\n\t\t\tint u = roots[i];\n\t\t\tq[u] = root;\n\t\t}\n\t\t\n\t\tout.println(res);\n\t\tfor (int x : q) \n\t\t\tout.print((x+1) + \" \");\n\t\tout.println();\n\t\tout.close();\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\treturn nextIntArray(n, 0);\n\t\t}\n\n\t\tint[] nextIntArray(int n, int margin) {\n\t\t\tint[] array = new int[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\treturn nextLongArray(n, 0);\n\t\t}\n\n\t\tlong[] nextLongArray(int n, int margin) {\n\t\t\tlong[] array = new long[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\treturn nextDoubleArray(n, 0);\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n, int margin) {\n\t\t\tdouble[] array = new double[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class  c9_2 {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n =in.nextInt();\n\t\tint[] p = new int[n+1];\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tp[i] = in.nextInt();\n\t\t}\n\t\tint root = -1;\n\t\tint numchanges = 0;\n\t\tint[] seen = new int[n+1];\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tif(p[i] == i){\n\t\t\t\troot = i;\n\t\t\t\tseen[i] = n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int a = 1; a <=n; a++){\n\t\t\tif(seen[a] != 0) continue;\n\t\t\tseen[a] = a;\n\t\t\tint at = a;\n\t\t\twhile(seen[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = a;\n\t\t\t}\n\t\t\tif(seen[p[at]] == a){\n\t\t\t\tnumchanges++;\n\t\t\t\tif(root != -1){\n\t\t\t\t\tp[at] = root;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(numchanges);\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tSystem.out.print(p[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tin.close();\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    private void solve() throws IOException {\n        int n = in.nextInt();\n        int[] a = in.nextInts(n);\n        Integer root = null;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            a[i]--;\n            if (a[i] == i) {\n                if (root == null) {\n                    root = i;\n                } else {\n                    ans++;\n                    a[i] = root;\n                }\n            }\n        }\n        int[] was = new int[n];\n        int time = 1;\n        if (root == null) {\n            loop:\n            for (int i = 0; i < n; i++) {\n                if (was[i] == 0) {\n                    int cur = i;\n                    while (true) {\n                        was[cur] = time;\n                        if (was[a[cur]] != 0) {\n                            if (was[a[cur]] == time) {\n                                ans++;\n                                a[cur] = cur;\n                                root = cur;\n                            }\n                            time++;\n                            break loop;\n                        } else {\n                            cur = a[cur];\n                        }\n                    }\n                }\n            }\n        }\n        if (root == null) throw new RuntimeException();\n        was[root] = time++;\n        // just remove cycles\n        for (int i = 0; i < n; i++) {\n            if (i != root && was[i] == 0) {\n                int cur = i;\n                while (true) {\n                    was[cur] = time;\n                    if (was[a[cur]] != 0) {\n                        if (was[a[cur]] == time) {\n                            ans++;\n                            a[cur] = root;\n                        }\n                        break;\n                    } else {\n                        cur = a[cur];\n                    }\n                }\n                time++;\n            }\n        }\n        out.println(ans);\n        for (int e : a) {\n            out.print(e + 1 + \" \");\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner();\n        out = new PrintWriter(System.out, false);\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Thread(null, () -> {\n            try {\n                new Main().run();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }, \"\", 1 << 27).run();\n    }\n}\n\nclass FastScanner {\n    private final BufferedReader br;\n    private StringTokenizer st;\n    private String last;\n\n    public FastScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public FastScanner(String path) throws IOException {\n        br = new BufferedReader(new FileReader(path));\n    }\n\n    public FastScanner(String path, String decoder) throws IOException {\n        br = new BufferedReader(new InputStreamReader(new FileInputStream(path), decoder));\n    }\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreElements())\n            st = new StringTokenizer(br.readLine());\n        last = null;\n        return st.nextToken();\n    }\n\n    String nextLine() throws IOException {\n        st = null;\n        return (last == null) ? br.readLine() : last;\n    }\n\n    boolean hasNext() {\n        if (st != null && st.hasMoreElements())\n            return true;\n\n        try {\n            while (st == null || !st.hasMoreElements()) {\n                last = br.readLine();\n                st = new StringTokenizer(last);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    String[] nextStrings(int n) throws IOException {\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = next();\n        return arr;\n    }\n\n    String[] nextLines(int n) throws IOException {\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextLine();\n        return arr;\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    int[] nextInts(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextInt();\n        return arr;\n    }\n\n    Integer[] nextIntegers(int n) throws IOException {\n        Integer[] arr = new Integer[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextInt();\n        return arr;\n    }\n\n    int[][] next2Ints(int n, int m) throws IOException {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                arr[i][j] = nextInt();\n        return arr;\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    long[] nextLongs(int n) throws IOException {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextLong();\n        return arr;\n    }\n\n    long[][] next2Longs(int n, int m) throws IOException {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                arr[i][j] = nextLong();\n        return arr;\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next().replace(',', '.'));\n    }\n\n    double[] nextDoubles(int size) throws IOException {\n        double[] arr = new double[size];\n        for (int i = 0; i < size; i++)\n            arr[i] = nextDouble();\n        return arr;\n    }\n\n    boolean nextBool() throws IOException {\n        String s = next();\n        if (s.equalsIgnoreCase(\"true\") || s.equals(\"1\"))\n            return true;\n\n        if (s.equalsIgnoreCase(\"false\") || s.equals(\"0\"))\n            return false;\n\n        throw new IOException(\"Boolean expected, String found!\");\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint color[200001];\nint root;\nint save[200001];\nvector<int> data[200001];\nint changes;\nvoid dfs(int source) {\n  color[source] = 1;\n  int len = data[source].size();\n  for (int i = 0; i < len; i++) {\n    if (source == data[source][i]) {\n      if (root == 0)\n        root = source;\n      else if (root != source) {\n        save[source] = root;\n        changes++;\n      }\n    } else if (color[data[source][i]] == 0) {\n      dfs(data[source][i]);\n    } else if (color[data[source][i]] == 1) {\n      if (root == 0) root = source;\n      save[source] = root;\n      changes++;\n    }\n  }\n  color[source] = 2;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> save[i];\n    data[i].push_back(save[i]);\n    if (root == 0 && i == save[i]) root = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (color[i] == 0) dfs(i);\n  }\n  cout << changes << \"\\n\";\n  for (int i = 1; i <= n; i++) cout << save[i] << ' ';\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1 << 28;\nconst long long LINF = 1ll << 61;\ninline long long getnum() {\n  register long long r = 0;\n  register bool ng = 0;\n  register char c;\n  c = getchar();\n  while (c != '-' && (c < '0' || c > '9')) c = getchar();\n  if (c == '-') ng = 1, c = getchar();\n  while (c != ' ' && c != '\\n') r = r * 10 + c - '0', c = getchar();\n  if (ng) r = -r;\n  return r;\n}\ntemplate <class T>\ninline void putnum(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  register short a[20] = {}, sz = 0;\n  while (x > 0) a[sz++] = x % 10, x /= 10;\n  if (sz == 0) putchar('0');\n  for (int i = sz - 1; i >= 0; i--) putchar('0' + a[i]);\n}\ninline void putsp() { putchar(' '); }\ninline void putendl() { putchar('\\n'); }\ninline char mygetchar() {\n  register char c = getchar();\n  while (c == ' ' || c == '\\n') c = getchar();\n  return c;\n}\nint n;\nint head[200111], nxt[400111], to[400111], tot = 1;\nbool vis[200111];\nint p[200111];\nint X, Y;\nvoid dfs(int x, int pre) {\n  vis[x] = 1;\n  for (int i = head[x]; i; i = nxt[i]) {\n    if (!vis[to[i]]) {\n      dfs(to[i], i / 2);\n    } else if (i / 2 != pre) {\n      X = x;\n      Y = to[i];\n    }\n  }\n}\nint main() {\n  n = getnum();\n  int ans = 0, fb = 0;\n  for (int i = 1; i <= n; i++) {\n    p[i] = getnum();\n    nxt[++tot] = head[i];\n    head[i] = tot;\n    to[tot] = p[i];\n    nxt[++tot] = head[p[i]];\n    head[p[i]] = tot;\n    to[tot] = i;\n    if (i == p[i]) fb = i;\n  }\n  if (fb) dfs(fb, -1);\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      X = Y = -1;\n      dfs(i, -1);\n      if (p[Y] == X) swap(X, Y);\n      if (!fb) {\n        ans++;\n        p[X] = X, fb = X;\n      } else {\n        ans++;\n        p[X] = fb;\n      }\n    }\n  }\n  putnum(ans), putendl();\n  for (int i = 1; i <= n; i++) putnum(p[i]), putsp();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nconst unsigned long long int mod = 1e9 + 7;\nlong long int power(long long int x, long long int y) {\n  long long int res = 1;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % mod;\n    y = y >> 1;\n    x = (x * x) % mod;\n  }\n  return res % mod;\n}\nvector<long long int> arr, ans1, ans;\nlong long int res = 0, total;\nlong long int get(long long int x) {\n  if (x == arr[x]) return arr[x];\n  return get(arr[x]);\n}\nvoid merge(long long int a, long long int b, long long int kk[]) {\n  long long int t1 = a, t2 = b;\n  if (a == b) return;\n  a = get(a);\n  b = get(b);\n  if (a == b) {\n    return;\n  }\n  arr[b] = a;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int t;\n  t = 1;\n  while (t--) {\n    long long int n, k = -1;\n    cin >> n;\n    long long int kk[n], aa[n];\n    arr.resize(n);\n    for (long long int i = 0; i < n; i++) arr[i] = i;\n    bool flag = true;\n    for (long long int i = 0; i < n; i++) {\n      cin >> kk[i];\n      aa[i] = kk[i];\n      if (kk[i] == i + 1) {\n        if (flag)\n          k = i;\n        else\n          ans.push_back(i);\n        flag = false;\n      } else if (get(i) == get(kk[i] - 1)) {\n        ans.push_back(i);\n      } else\n        merge(kk[i] - 1, i, kk);\n    }\n    long long int i = 0;\n    if (k == -1) k = ans[0], i = 1, kk[ans[0]] = ans[0] + 1;\n    for (i; i < ans.size(); i++) {\n      kk[ans[i]] = k + 1;\n    }\n    for (long long int i = 0; i < n; i++) {\n      if (kk[i] != aa[i]) res++;\n    }\n    cout << res << '\\n';\n    for (auto x : kk) cout << x << \" \";\n  }\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n + 1];\n            int ans = 0;\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.nextInt();\n            }\n            int root = 1;\n            for (; root <= n; root++) {\n                if (a[root] == root) break;\n            }\n            if (root > n) {\n                root = -1;\n            }\n            int[] visited = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                if (visited[i] == 0) {\n                    visited[i] = i;\n                    int cur = i;\n                    while (visited[a[cur]] == 0) {\n                        cur = a[cur];\n                        visited[cur] = i;\n                    }\n                    if (visited[a[cur]] == i) {\n                        if (root == -1 || cur == root) {\n                            if (a[cur] == cur) {\n                                root = cur;\n                            } else {\n                                a[cur] = cur;\n                                root = cur;\n                                ans++;\n                            }\n                        } else {\n                            a[cur] = root;\n                            ans++;\n                        }\n                    }\n                }\n            }\n            out.println(ans);\n            for (int i = 1; i <= n; i++) out.print(a[i] + \" \");\n        }\n\n    }\n\n    static class InputReader {\n        private StringTokenizer tokenizer;\n        private BufferedReader reader;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private void fillTokenizer() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        public String next() {\n            fillTokenizer();\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int Read() {\n  int s = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      f = -1;\n    }\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    s = s * 10 + ch - '0';\n    ch = getchar();\n  }\n  return s * f;\n}\ninline void Wte(int x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) {\n    Wte(x / 10);\n  }\n  putchar(x % 10 + '0');\n}\ninline void Write(int x) {\n  Wte(x);\n  putchar(' ');\n}\nconst int MAXN = 200010;\nint N;\nint a[MAXN];\nbool vis[MAXN];\nvector<vector<int> > cycle, tree;\nint p[MAXN];\nvoid iint() {\n  for (int i = 0; i < N; i++) {\n    p[i] = i;\n  }\n}\nint dsu(int x) { return x == p[x] ? x : p[x] = dsu(p[x]); }\nvoid Merge(int x, int y) { p[dsu(x)] = dsu(y); }\nvoid solve() {\n  int cost = 0;\n  N = Read();\n  iint();\n  for (int i = 0; i < N; i++) {\n    a[i] = Read();\n    a[i]--;\n    Merge(i, a[i]);\n  }\n  for (int i = 0; i < N; i++) {\n    p[i] = dsu(p[i]);\n  }\n  vector<int> v;\n  for (int i = 0; i < N; i++) {\n    if (p[i] == i) {\n      v.push_back(i);\n      cost++;\n    }\n  }\n  int root = -1;\n  for (int i = 0; i < N; i++) {\n    if (a[i] == i) {\n      cost--;\n      root = i;\n      break;\n    }\n  }\n  if (root == -1) {\n    root = v[0];\n    a[root] = root;\n  }\n  for (int i = 0; i < v.size(); i++) {\n    if (v[i] != root) {\n      a[v[i]] = root;\n    }\n  }\n  Write(cost);\n  puts(\"\");\n  for (int i = 0; i < N; i++) {\n    Write(a[i] + 1);\n  }\n  puts(\"\");\n}\nvoid Times(int T) {\n  while (T--) {\n    solve();\n  }\n}\nint main() {\n  int T;\n  T = 1;\n  Times(T);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\nstruct UnionFind {\n  vector<int> ig;\n  vector<vector<int>> gi;\n  int gn;\n  UnionFind(int N) {\n    ig.resize(N);\n    gi.resize(N);\n    for (int i = 0; i < N; i++) {\n      ig[i] = i;\n      gi[i] = {i};\n    }\n    gn = N;\n  }\n  void merge(int a, int b) {\n    if (same(a, b)) return;\n    gn--;\n    int x = ig[a], y = ig[b];\n    if (gi[x].size() < gi[y].size()) swap(x, y);\n    for (int j : gi[y]) {\n      ig[j] = x;\n    }\n    gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n    gi[y].clear();\n  }\n  bool same(int a, int b) { return ig[a] == ig[b]; }\n};\nconst int MN = 200200;\nint n;\nint a[MN];\nbool used[MN];\nint par(int p) {\n  if (used[p]) return p;\n  used[p] = true;\n  return par(a[p]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    a[i]--;\n  }\n  int ans = 0;\n  int rt = -1;\n  for (int i = 0; i < n; i++) {\n    if (a[i] == i) rt = i;\n  }\n  if (rt == -1) {\n    rt = par(0);\n    ans++;\n    a[rt] = rt;\n    fill_n(used, MN, false);\n  }\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++) {\n    uf.merge(i, a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (uf.same(rt, i)) continue;\n    int nw = par(i);\n    ans++;\n    a[nw] = rt;\n    uf.merge(rt, i);\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", a[i] + 1);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint pre[maxn], a[maxn];\nint Find(int x) { return x == pre[x] ? x : pre[x] = Find(pre[x]); }\nvoid Union(int x, int y) {\n  int fx = Find(x), fy = Find(y);\n  if (fx != fy) pre[fx] = fy;\n}\nint main() {\n  int n, root = -1, cnt = 0;\n  scanf(\"%d\", &n);\n  bool flag = false;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    pre[i] = i;\n    if (i == a[i]) root = a[i], flag = true;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (a[i] == i)\n      Union(i, root), a[i] = root, cnt++;\n    else if (Find(i) != Find(a[i]))\n      Union(i, a[i]);\n    else {\n      if (root == -1) root = i;\n      Union(i, root), a[i] = root, cnt++;\n    }\n  }\n  printf(\"%d\\n\", cnt - flag);\n  for (int i = 1; i <= n; i++) printf(\"%d \", a[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[200005], parent[200005];\nvector<int> komponen;\nint findParent(int x) {\n  return parent[x] == x ? x : parent[x] = findParent(parent[x]);\n}\nvoid merge(int x, int y) {\n  x = findParent(x);\n  y = findParent(y);\n  if (x != y) {\n    parent[y] = x;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    parent[i] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    merge(a[i], i);\n  }\n  int root = -1;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] == i) root = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (findParent(i) == i) {\n      if (root == -1) root = i;\n      komponen.push_back(i);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < komponen.size(); i++) {\n    if (a[komponen[i]] != root) {\n      a[komponen[i]] = root;\n      ans++;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; i++) {\n    if (i > 1) printf(\" \");\n    printf(\"%d\", a[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class PowersOfTwo {\n\n    public static void main(String [] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            arr[i] = in.nextInt();\n        }\n\n        int a = -1;\n        int res = 0;\n\n        int[] mas = new int[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            if (arr[i] == i) {\n                a = i;\n                mas[i] = n + 1;\n                break;\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (mas[i] != 0) continue;\n            mas[i] = i;\n            int index = i;\n\n            while (mas[arr[index]] == 0) {\n                index = arr[index];\n                mas[index] = i;\n            }\n\n            if (mas[arr[index]] == i) {\n                res++;\n                if (a != -1) {\n                    arr[index] = a;\n                } else {\n                    arr[index] = index;\n                    a = index;\n                }\n            } \n        }\n\n        System.out.println(res);\n        for (int i = 1; i <= n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> p(n + 1);\n  set<int> done, visited;\n  vector<vector<int> > S(n + 1);\n  int index = -1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n    S[p[i]].push_back(i);\n    if (p[i] == i) index = i;\n  }\n  int node, counter = 0;\n  for (int i = 1; i <= n; i++) {\n    if (done.find(i) != done.end()) continue;\n    visited.clear();\n    stack<int> dfs;\n    dfs.push(i);\n    while (!dfs.empty()) {\n      node = dfs.top();\n      dfs.pop();\n      if (visited.find(node) != visited.end()) {\n        if (index == -1) {\n          index = node;\n          counter++;\n          p[node] = node;\n        } else {\n          p[node] = index;\n          if (p[node] != node) counter++;\n        }\n        break;\n      }\n      visited.insert(node);\n      for (int j = 0; j < S[node].size(); j++) {\n        if (done.find(S[node][j]) == done.end()) {\n          dfs.push(S[node][j]);\n        }\n      }\n    }\n    for (set<int>::iterator it = visited.begin(); it != visited.end(); it++) {\n      done.insert(*it);\n    }\n  }\n  printf(\"%d\\n\", counter);\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", p[i]);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "input()\n\nA = list(map(int, input().split(' ')))\n\nroot = -1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author George Marcus\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        int root;\n        int[] v;\n        int[] P;\n        int ans;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.readInt();\n            P = new int[N];\n            for (int i = 0; i < N; i++) {\n                P[i] = in.readInt();\n                P[i]--;\n            }\n\n            root = -1;\n            for (int i = 0; i < N; i++) {\n                if (P[i] == i) {\n                    root = i;\n                    break;\n                }\n            }\n\n            v = new int[N];\n            ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (v[i] == 0) {\n                    dfs(i);\n                }\n            }\n\n            out.println(ans);\n            for (int i = 0; i < N; i++) {\n                out.print((P[i] + 1) + \" \");\n            }\n            out.println();\n        }\n\n        private void dfs(int node) {\n            v[node] = 1;\n\n            int x = P[node];\n            if (v[x] == 1) {\n                if (root == -1) {\n                    root = node;\n                }\n                if (P[node] != root) {\n                    ans++;\n                }\n                P[node] = root;\n            }\n            if (v[x] == 0) {\n                dfs(x);\n            }\n            v[node] = 2;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, in[200005], a[200005], sta[200005], top, now, root, ans, flag;\nbool vis[200005], mark[200005];\nint read() {\n  int x, f = 1;\n  char ch;\n  while (!(isdigit(ch = getchar()))) ch == '-' ? f = -1 : f;\n  x = ch - 48;\n  while ((isdigit(ch = getchar()))) x = x * 10 + ch - 48;\n  return f * x;\n}\nvoid Topology() {\n  while (now < top) {\n    now++;\n    int tmp = sta[now];\n    vis[tmp] = 1;\n    in[a[tmp]]--;\n    if (!in[a[tmp]]) sta[++top] = a[tmp];\n  }\n}\nvoid dfs(int u) {\n  vis[u] = 1;\n  if (!vis[a[u]]) dfs(a[u]);\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) {\n    a[i] = read();\n    in[a[i]]++;\n    if (a[i] == i) {\n      flag = 1;\n      root = i;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (!in[i]) sta[++top] = i;\n  Topology();\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      if (!root) root = i;\n      ans++;\n      dfs(a[i]);\n      a[i] = root;\n      mark[i] = 1;\n    }\n  }\n  printf(\"%d\\n\", ans - flag);\n  for (int i = 1; i <= n; i++) {\n    if (mark[i]) a[i] = root;\n    printf(\"%d \", a[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint f[200005], a[200005];\nint ans[200005];\nint find(int x) {\n  if (x == f[x])\n    return x;\n  else\n    return f[x] = find(f[x]);\n}\nvoid Union(int x, int y) {\n  int fx = find(x);\n  int fy = find(y);\n  if (fx != fy) f[fx] = fy;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) f[i] = i;\n  int cnt = 0;\n  int t = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (find(a[i]) == find(i)) {\n      ans[cnt++] = i;\n      if (a[i] == i) {\n        t = find(i);\n      }\n    }\n    Union(i, a[i]);\n  }\n  int cnt1 = 0;\n  if (t == 0) {\n    for (int i = 1; i <= n; i++) {\n      if (find(i) == find(a[i])) {\n        t = find(i);\n      }\n    }\n  }\n  for (int i = 0; i < cnt; i++) {\n    if (a[ans[i]] != t) {\n      a[ans[i]] = t;\n      cnt1++;\n    }\n  }\n  cout << cnt1 << endl;\n  for (int i = 1; i <= n; i++) {\n    if (i == 1)\n      printf(\"%d\", a[i]);\n    else\n      printf(\" %d\", a[i]);\n  }\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\nusing namespace std;\nusing ld = long double;\ntemplate <class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\nstruct Dscc {\n public:\n  pair<vector<vector<int>>, vector<vector<int>>> get(\n      const vector<vector<int>> &edges) {\n    nums.resize(edges.size());\n    fill(nums.begin(), nums.end(), -1);\n    vector<vector<int>> revedges(edges.size());\n    for (int i = 0; i < edges.size(); ++i) {\n      for (auto j : edges[i]) {\n        revedges[j].push_back(i);\n      }\n    }\n    int num = 0;\n    for (int i = 0; i < edges.size(); ++i) {\n      dfs(i, num, edges);\n    }\n    vector<int> big(nums.size());\n    for (int i = 0; i < nums.size(); ++i) {\n      big[nums[i]] = i;\n    }\n    reverse(big.begin(), big.end());\n    unis.resize(edges.size());\n    fill(unis.begin(), unis.end(), -1);\n    num = 0;\n    for (int i = 0; i < big.size(); ++i) {\n      dfs2(big[i], num, revedges);\n      num++;\n    }\n    vector<int> nums;\n    for (int i = 0; i < unis.size(); ++i) {\n      nums.push_back(unis[i]);\n    }\n    sort(nums.begin(), nums.end());\n    nums.erase(unique(nums.begin(), nums.end()), nums.end());\n    map<int, int> mp;\n    for (int i = 0; i < nums.size(); ++i) {\n      mp[nums[i]] = i;\n    }\n    for (int i = 0; i < unis.size(); ++i) {\n      unis[i] = mp[unis[i]];\n    }\n    vector<vector<int>> belongs(nums.size());\n    for (int i = 0; i < unis.size(); ++i) {\n      belongs[unis[i]].push_back(i);\n    }\n    vector<vector<int>> newedges(nums.size());\n    for (int i = 0; i < edges.size(); ++i) {\n      for (auto j : edges[i]) {\n        if (unis[i] != unis[j]) {\n          newedges[unis[i]].push_back(unis[j]);\n        }\n      }\n    }\n    return make_pair(belongs, newedges);\n  }\n\n private:\n  vector<int> nums;\n  vector<int> unis;\n  void dfs(const int id, int &num, const vector<vector<int>> &edges) {\n    if (nums[id] != -1)\n      return;\n    else {\n      nums[id] = -2;\n      for (auto i : edges[id]) {\n        dfs(i, num, edges);\n      }\n    }\n    nums[id] = num++;\n    return;\n  }\n  void dfs2(const int id, const int &num, const vector<vector<int>> &edges) {\n    if (unis[id] != -1)\n      return;\n    else {\n      unis[id] = -2;\n      for (auto i : edges[id]) dfs2(i, num, edges);\n    }\n    unis[id] = num;\n    return;\n  }\n} dscc;\nint main() {\n  int N;\n  cin >> N;\n  vector<int> as(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> as[i];\n    as[i]--;\n  }\n  vector<int> selfs;\n  for (int i = 0; i < N; ++i) {\n    selfs.push_back(as[i] == i);\n  }\n  int ans = 0;\n  int pa;\n  if (accumulate(selfs.begin(), selfs.end(), 0) == 0) {\n    bool flag = false;\n    vector<vector<int>> edges(N);\n    for (int i = 0; i < N; ++i) {\n      edges[i].push_back(as[i]);\n    }\n    auto p = dscc.get(edges);\n    for (int i = 0; i < p.first.size(); ++i) {\n      if (p.second[i].empty()) {\n        if (!flag) {\n          pa = p.first[i][0];\n          as[pa] = pa;\n          ans++;\n          flag = true;\n        } else {\n          as[p.first[i][0]] = pa;\n          ans++;\n        }\n      }\n    }\n  } else {\n    bool flag = false;\n    for (int i = 0; i < N; ++i) {\n      if (!flag) {\n        if (as[i] == i) {\n          pa = i;\n          flag = true;\n        }\n      } else {\n        if (as[i] == i) {\n          as[i] = pa;\n          ans++;\n        }\n      }\n    }\n    vector<vector<int>> edges(N);\n    for (int i = 0; i < N; ++i) {\n      edges[i].push_back(as[i]);\n    }\n    auto p = dscc.get(edges);\n    for (int i = 0; i < p.first.size(); ++i) {\n      if (p.second[i].empty()) {\n        if (!flag) {\n          pa = p.first[i][0];\n          as[pa] = pa;\n          ans++;\n          flag = true;\n        } else {\n          if (as[p.first[i][0]] != pa) {\n            as[p.first[i][0]] = pa;\n            ans++;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  for (int i = 0; i < as.size(); ++i) {\n    cout << as[i] + 1;\n    if (i == as.size() - 1)\n      cout << endl;\n    else\n      cout << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint a[200001];\nint visited[200001];\nvector<long long> fixedpt;\nvector<long long> repair;\nbool empt;\nvoid dfs(int u) {\n  visited[u] = 2;\n  int v = a[u];\n  if (v == u) {\n  } else if (visited[v] == 2) {\n    repair.push_back(v);\n  } else if (visited[v] == 1) {\n  } else {\n    dfs(v);\n  }\n  visited[u] = 1;\n}\nint main() {\n  int n;\n  int cnt = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n    if (a[i] == i) fixedpt.push_back(i);\n  }\n  empt = false;\n  if (fixedpt.empty()) empt = true;\n  if (!fixedpt.empty()) {\n    for (int i = 0; i < fixedpt.size(); i++) {\n      a[fixedpt[i]] = fixedpt[0];\n      if (i > 0) cnt++;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!visited[i]) dfs(i);\n  }\n  for (int i = 0; i < repair.size(); i++) {\n    if (fixedpt.empty()) {\n      a[repair[i]] = repair[0];\n    } else {\n      a[repair[i]] = fixedpt[0];\n    }\n    cnt++;\n  }\n  printf(\"%d\\n\", cnt);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", a[i] + 1);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long dx[4] = {-1, 1, 0, 0};\nconst long long dy[4] = {0, 0, -1, 1};\nvector<long long> r;\nvector<vector<long long> > c;\nlong long a[200005], col[200005];\nsigned main() {\n  long long n;\n  cin >> n;\n  for (long long i = (0); i < (n); i++) {\n    cin >> a[i];\n    a[i]--;\n    if (i == a[i]) r.push_back(i);\n  }\n  long long color = 1;\n  for (long long i = (0); i < (n); i++)\n    if (!col[i]) {\n      long long pos = i;\n      vector<long long> vv;\n      while (1) {\n        if (col[pos] && col[pos] != color) break;\n        if (col[pos] == color) {\n          c.push_back(vector<long long>(1, pos));\n          for (long long j = ((long long)vv.size()) - 2; j >= 0; j--)\n            if (vv[i] == pos)\n              break;\n            else\n              c[((long long)c.size()) - 1].push_back(vv[i]);\n          break;\n        }\n        if (a[pos] == pos) break;\n        col[pos] = color;\n        pos = a[pos];\n      }\n      color++;\n    }\n  if (!((long long)r.size())) {\n    cout << ((long long)c.size()) << '\\n';\n    a[c[0][0]] = c[0][0];\n    for (long long i = (1); i < (((long long)c.size())); i++)\n      a[c[i][0]] = c[0][0];\n    for (long long i = (0); i < (n); i++) cout << a[i] + 1 << ' ';\n  } else {\n    cout << ((long long)r.size()) + ((long long)c.size()) - 1 << '\\n';\n    for (long long i = (1); i < (((long long)r.size())); i++) a[r[i]] = r[0];\n    for (long long i = (0); i < (((long long)c.size())); i++) a[c[i][0]] = r[0];\n    for (long long i = (0); i < (n); i++) cout << a[i] + 1 << ' ';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint f[N], n, a[N], p[N], opt, b[N], rt = -1, ans;\nbool d;\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) f[i] = i;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == i) rt = i;\n    if (i == find(a[i]))\n      b[++opt] = i;\n    else\n      f[i] = a[i];\n  }\n  if (rt == -1)\n    rt = b[opt];\n  else\n    d = 1;\n  for (int i = 1; i <= opt; i++) a[b[i]] = rt;\n  printf(\"%d\\n\", opt - d);\n  for (int i = 1; i <= n; i++) printf(\"%d \", a[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int Read() {\n  int s = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      f = -1;\n    }\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    s = s * 10 + ch - '0';\n    ch = getchar();\n  }\n  return s * f;\n}\ninline void Wte(int x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) {\n    Wte(x / 10);\n  }\n  putchar(x % 10 + '0');\n}\ninline void Write(int x) {\n  Wte(x);\n  putchar(' ');\n}\nconst int MAXN = 200010;\nint N;\nbool vis[MAXN];\nint a[MAXN], ans[MAXN];\nbool cmp(int x, int y) { return abs(x - a[x]) < abs(y - a[y]); }\nvoid solve() {\n  int cost = 0;\n  N = Read();\n  for (int i = 0; i < N; i++) {\n    a[i] = Read() - 1;\n    ans[i] = a[i];\n  }\n  vector<int> v;\n  for (int i = 0; i < N; i++) {\n    set<int> st;\n    int j;\n    for (j = i; !vis[j]; j = a[j]) {\n      vis[j] = 1;\n      st.insert(j);\n    }\n    if (!st.count(j)) {\n      continue;\n    }\n    v.push_back(j);\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (int i = 0; i < v.size(); i++) {\n    ans[v[i]] = v[0];\n  }\n  for (int i = 0; i < N; i++) {\n    cost += (ans[i] != a[i]);\n  }\n  Write(cost);\n  puts(\"\");\n  for (int i = 0; i < N; i++) {\n    Write(ans[i] + 1);\n  }\n  puts(\"\");\n}\nvoid Times(int T) {\n  while (T--) {\n    solve();\n  }\n}\nint main() {\n  int T;\n  T = 1;\n  Times(T);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class c{ \n\nstatic PrintWriter out = new PrintWriter(System.out);\nstatic int flag=0;\nstatic void dfs(LinkedList<Integer> l[],int s,int p,boolean v[],HashSet<Integer> h){\n                       v[s]=true;\n                     for(Integer i: l[s])\n                          if(v[i]==false)\n                             dfs(l,i,s,v,h);\n                          else if(i!=p&&flag==0)\n                            { h.add(i); flag=1;}\n\n}\npublic static void main(String[] args)throws IOException { \n \n\n        int n = ni();\n        int p[] = new int[n];\n        LinkedList<Integer> l[] = new LinkedList[n];\n               for(int i=0;i<n;i++) l[i] = new LinkedList();\n          int f=-1;\n         for(int i=0;i<n;i++) {\n                   p[i] = ni()-1;\n                    if(p[i]==i)f=i;\n                   l[i].add(p[i]);\n                   l[p[i]].add(i);\n          }\n        boolean v[] = new boolean[n];\n        HashSet<Integer> h = new HashSet<Integer>();\n        int cc=0,ans=0;\n           for(int i=0;i<n;i++)\n                if(v[i]==false)\n                  { cc++;flag=0; dfs(l,i,-1,v,h);}\n          if(cc!=1){\n                      if(f==-1){ \n                                  for(Integer i: h){\n                                        if(f==-1){\n                                            f=i;   \n                                            p[i]=i;\n                                         }\n                                        else\n                                          p[i]=f;\n                                   }\n                          ans=cc;\n                      }\n                    else{\n                            for(Integer i: h)\n                                 if(i!=f)\n                                    p[i]=f;   \n                           ans=cc-1;             \n                     }\n          }\n        else if(f==-1){\n                 for(Integer i : h)\n                      p[i]=i;\n                      ans =1;\n          }\n             out.println(ans);\n          for(int i=0;i<n;i++)\n             out.print((p[i]+1)+\" \");\n      out.flush();\n}   \n    static FastReader sc=new FastReader(); \n \n      static int ni(){\n                 int x = sc.nextInt();\n                 return(x);\n        }\n      static long nl(){\n              long x = sc.nextLong();\n              return(x);\n         }\n      static String n(){\n                 String str = sc.next();\n                     return(str);\n       }\n     static String ns(){\n                 String str = sc.nextLine();\n                   return(str);\n      }\n     static double nd(){\n               double d = sc.nextDouble();\n                 return(d);\n       }\n  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class  c9_2 {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n =in.nextInt();\n\t\tint[] p = new int[n+1];\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tp[i] = in.nextInt();\n\t\t}\n\t\tint root = -1;\n\t\tint nm = 0;\n\t\tint[] sn = new int[n+1];\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tif(p[i] == i){\n\t\t\t\troot = i;\n\t\t\t\tsn[i] = n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int a = 1; a <=n; a++){\n\t\t\tif(sn[a] != 0) continue;\n\t\t\tsn[a] = a;\n\t\t\tint at = a;\n\t\t\twhile(sn[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tsn[at] = a;\n\t\t\t}\n\t\t\tif(sn[p[at]] == a){\n\t\t\t\tnm++;\n\t\t\t\tif(root != -1){\n\t\t\t\t\tp[at] = root;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(nm);\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tSystem.out.print(p[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic long sx = 0, sy = 0, m = (long) (1e9 + 7);\n\n\tstatic ArrayList<Integer>[] a;\n\tstatic int[][] dp;\n\tstatic long[] farr;\n\t// static boolean b = true;\n\tstatic HashMap<Integer, Integer> hm = new HashMap<>();\n\n\t// static TreeMap<Integer, Integer> hm = new TreeMap<>();\n\tpublic static PrintWriter out;\n\tstatic ArrayList<pair> p = new ArrayList<>();\n\tstatic long[] fact = new long[(int) 1e6];\n\tstatic boolean b = false;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic boolean cycle = false;\n\tstatic long mod = 998244353;\n\tstatic int[] col;\n\t// static HashSet<Integer> p = new HashSet<>();\n\tstatic int cnt;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Scanner scn = new Scanner(System.in);\n\n\t\tReader scn = new Reader();\n\t\tout = new PrintWriter(System.out);\n\n\t\tint n = scn.nextInt();\n\t\tint[] a = new int[n + 1];\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = scn.nextInt();\n\n\t\tint[] c = Arrays.copyOf(a, n + 1);\n\n\t\tdsu d = new dsu(n);\n\n\t\tint cnt = -5;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tif (a[i] == i) {\n\n\t\t\t\tif (cnt == -5)\n\t\t\t\t\tcnt = a[i];\n\t\t\t\telse\n\t\t\t\t\ta[i] = -1;\n\t\t\t}\n\n\t\t\telse if (!d.merge(i, a[i])) {\n\t\t\t\ta[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\t  if(a[i] == -1){\n\t\t\t\t   if(cnt!=-5)\n\t\t\t\t\t    a[i] = cnt;\n\t\t\t\t   else{\n\t\t\t\t\t   a[i] = i;\n\t\t\t\t\t   cnt = i;\n\t\t\t\t   }\n\t\t\t  }\n\t\t\t  \n\t\t\t  if(a[i]!=c[i])ans++;\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tSystem.out.print(a[i] + \" \");\n\n\t}\n\n\tprivate static class dsu {\n\n\t\tstatic int[] size;\n\t\tstatic int[] par;\n\n\t\tdsu(int n) {\n\n\t\t\tsize = new int[n + 1];\n\t\t\tpar = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tsize[i] = 1;\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tpublic static boolean merge(int u, int v) {\n\n\t\t\tint p1 = find(u);\n\n\t\t\tint p2 = find(v);\n\n\t\t\tif (p1 == p2)\n\t\t\t\treturn false;\n\n\t\t\tif (size[p1] >= size[p2]) {\n\t\t\t\tsize[p1] += size[p2];\n\t\t\t\tpar[p2] = p1;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tsize[p2] += size[p1];\n\t\t\t\tpar[p1] = par[p2];\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic static int find(int v) {\n\n\t\t\tif (v == par[v])\n\t\t\t\treturn v;\n\n\t\t\tpar[v] = find(par[v]);\n\n\t\t\treturn par[v];\n\t\t}\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\t// private static int gcd(int a, int b) {\n\t// if (a == 0)\n\t// return b;\n\t//\n\t// return gcd(b % a, a);\n\t// }\n\n\t// static class comp implements Comparator<Integer> {\n\t//\n\t// @Override\n\t// public int compare(Integer o1, Integer o2) {\n\t// if (b[o1])\n\t// return -1;\n\t// else if (b[o2])\n\t// return 1;\n\t// else\n\t// return (int) (a[o2].size() - a[o1].size());\n\t// }\n\t//\n\t// }\n\n\t// public static long pow(long a, long b) {\n\t//\n\t// if(b<0)return 0;\n\t// if (b == 0 || b == 1)\n\t// return (long) Math.pow(a, b);\n\t//\n\t// if (b % 2 == 0) {\n\t//\n\t// long ret = pow(a, b / 2);\n\t// ret = (ret % mod * ret % mod) % mod;\n\t// return ret;\n\t// }\n\t//\n\t// else {\n\t// return ((pow(a, b - 1) % mod) * a % mod) % mod;\n\t// }\n\t// }\n\n\tprivate static class pair implements Comparable<pair> {\n\n\t\tint tb, tbw;\n\n\t\tpair() {\n\t\t\ttb = tbw = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tprivate static String reverse(String s) {\n\n\t\treturn new StringBuilder(s).reverse().toString();\n\t}\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[1000000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t// kickstart - Solution\n\t\t// atcoder - Main\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\npublic class Contest9Solution2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n            ArrayList<Integer> ar = new ArrayList<>();\n            int[] b = new int[N + 1];\n            int[] a = new int[N + 1];\n            boolean[] v = new boolean[N + 1];\n            for (int i = 1; i <= N; i++) {\n                a[i] = in.nextInt();\n                b[i] = a[i];\n                if (a[i] == i) {\n                    ar.add(i);\n                    v[i] = true;\n                    continue;\n                }\n            }\n            int root = ar.isEmpty() ? -1 : ar.get(0);\n            for (int i = 1; i <= N; i++) {\n                if (v[i]) continue;\n                v[i] = true;\n                if (i == b[i]) continue;\n                HashSet<Integer> v2 = new HashSet<>();\n                v2.add(i);\n                int p = b[i];\n                while (true) {\n                    if (v2.contains(p)) {\n                        if (root == -1) {\n                            root = p;\n                        }\n                        a[p] = root;\n                        break;\n                    }\n                    v2.add(p);\n                    if (v[p]) break;\n                    v[p] = true;\n                    p = b[p];\n                }\n            }\n            for (int i = 1; i < ar.size(); i++) {\n                a[ar.get(i)] = root;\n            }\n            int diff = 0;\n            for (int i = 1; i <= N; i++) {\n                if (b[i] != a[i]) diff++;\n            }\n            System.out.println(diff);\n            for (int i = 1; i <= N; i++) {\n                if (i > 1) System.out.print(' ');\n                System.out.print(a[i]);\n            }\n            System.out.println();\n        \n        }\n\n    }"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    int dfs(int x, int p, int[][] g, boolean[] used) {\n        used[x] = true;\n        int cycleVertex = -1;\n        for (int y : g[x]) {\n            if (p == y) continue;\n            if (!used[y]) {\n                int r = dfs(y, x, g, used);\n                if (r != -1) cycleVertex = r;\n            } else {\n                cycleVertex = y;\n            }\n        }\n        return cycleVertex;\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        int[] a = readIntArray(n);\n        GraphBuilder gb = new GraphBuilder(n, n);\n        GraphBuilder rgb = new GraphBuilder(n, n);\n        for (int i = 0; i < n; i++) {\n            gb.add(a[i] - 1, i);\n            rgb.add(i, a[i] - 1);\n        }\n        boolean[] used = new boolean[n];\n        int[][] g = gb.build();\n        int[][] rg = rgb.build();\n        List<Integer> roots = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (i == a[i] - 1) {\n                dfs(i, i, g, used);\n                roots.add(i);\n            }\n        }\n        List<Integer> cycleRoots = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                cycleRoots.add(dfs(i, i, rg, used));\n            }\n        }\n        int rootsCount = roots.size();\n        int cycleCount = cycleRoots.size();\n        int answer = 0;\n        if (rootsCount == 0) {\n            rootsCount++;\n            answer++;\n            cycleCount--;\n            a[cycleRoots.get(0)] = cycleRoots.get(0) + 1;\n            roots.add(cycleRoots.remove(0));\n        }\n        answer += rootsCount - 1;\n        answer += cycleCount;\n        out.println(answer);\n\n        for (int i = 1; i < roots.size(); i++) {\n            a[roots.get(i)] = roots.get(0) + 1;\n        }\n        for (int x : cycleRoots) {\n            a[x] = roots.get(0) + 1;\n        }\n        for (int x : a) {\n            out.print(x + \" \");\n        }\n\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "\n\t\n\t    /*\n\t     * Author- Priyam Vora\n\t     * BTech 2nd Year DAIICT\n\t     */\n\t     \n\t            \n\t    import java.io.*;\n\t    import java.math.*;\n\t    import java.util.*;\n\t    import javax.print.attribute.SetOfIntegerSyntax;\n\t     \n\t    public class CodeMonk_Graph{\n\t    \tprivate static InputStream stream;\n\t    \tprivate static byte[] buf = new byte[1024];\n\t    \tprivate static int curChar;\n\t    \tprivate static int numChars;\n\t    \tprivate static SpaceCharFilter filter;\n\t    \tprivate static PrintWriter pw;\n\t    \tprivate static long count = 0,mod=1000000007;\n\t    \tprivate static TreeSet<Integer>ts[]=new TreeSet[200000];\n\t    \tprivate static HashSet hs=new HashSet();\n\t     \n\t        public static void main(String[] args) {\n\t        \tInputReader(System.in);\n\t    \t\tpw = new PrintWriter(System.out); \n\t            new Thread(null ,new Runnable(){\n\t               public void run(){\n\t                   try{\n\t                       soln();\n\t                       pw.close();\n\t                   } catch(Exception e){\n\t                       e.printStackTrace();\n\t                   }\n\t               }\n\t           },\"1\",1<<26).start();\n\t       }\n\t    \n\t    \tpublic static long gcd(long x, long y) {\n\t    \t\tif (x == 0)\n\t    \t\t\treturn y;\n\t    \t\telse\n\t    \t\t\treturn gcd( y % x,x);\n\t    \t}\n\t    \t\n\t    \tprivate static int BinarySearch(int a[], int low, int high, int target) {\n\t    \t\tif (low > high)\n\t    \t\t\treturn -1;\n\t    \t\tint mid = low + (high - low) / 2;\n\t    \t\tif (a[mid] == target)\n\t    \t\t\treturn mid;\n\t    \t\tif (a[mid] > target)\n\t    \t\t\thigh = mid - 1;\n\t    \t\tif (a[mid] < target)\n\t    \t\t\tlow = mid + 1;\n\t    \t\treturn BinarySearch(a, low, high, target);\n\t    \t}\n\t    \t\n\t    \tpublic static String reverseString(String s) {\n\t    \t\tStringBuilder sb = new StringBuilder(s);\n\t    \t\tsb.reverse();\n\t    \t\treturn (sb.toString());\n\t    \t}\n\t    \t\n\t    \tpublic static long pow(long n, long p) {\n\t    \t\tif(p==0)\n\t    \t\t\treturn 1;\n\t    \t\tif(p==1)\n\t    \t\t\treturn n%mod;\n\t    \t\tif(p%2==0){\n\t    \t\t\tlong temp=pow(n, p/2);\n\t    \t\treturn (temp*temp)%mod;\n\t    \t\t}else{\n\t    \t\t\t \tlong temp=pow(n,p/2);\n\t    \t\t\t \ttemp=(temp*temp)%mod;\n\t    \t\t\t \treturn(temp*n)%mod;\n\t    \t\t\t \t\n\t    \t\t}\n\t    \t}\n\t     \n\t    \t\t\n\t     \n\t    \tpublic static int[] radixSort(int[] f) {\n\t    \t\tint[] to = new int[f.length];\n\t    \t\t{\n\t    \t\t\tint[] b = new int[65537];\n\t    \t\t\tfor (int i = 0; i < f.length; i++)\n\t    \t\t\t\tb[1 + (f[i] & 0xffff)]++;\n\t    \t\t\tfor (int i = 1; i <= 65536; i++)\n\t    \t\t\t\tb[i] += b[i - 1];\n\t    \t\t\tfor (int i = 0; i < f.length; i++)\n\t    \t\t\t\tto[b[f[i] & 0xffff]++] = f[i];\n\t    \t\t\tint[] d = f;\n\t    \t\t\tf = to;\n\t    \t\t\tto = d;\n\t    \t\t}\n\t    \t\t{\n\t    \t\t\tint[] b = new int[65537];\n\t    \t\t\tfor (int i = 0; i < f.length; i++)\n\t    \t\t\t\tb[1 + (f[i] >>> 16)]++;\n\t    \t\t\tfor (int i = 1; i <= 65536; i++)\n\t    \t\t\t\tb[i] += b[i - 1];\n\t    \t\t\tfor (int i = 0; i < f.length; i++)\n\t    \t\t\t\tto[b[f[i] >>> 16]++] = f[i];\n\t    \t\t\tint[] d = f;\n\t    \t\t\tf = to;\n\t    \t\t\tto = d;\n\t    \t\t}\n\t    \t\treturn f;\n\t    \t}\n\t     \n\t    \tpublic static int nextPowerOf2(final int a) {\n\t    \t\tint b = 1;\n\t    \t\twhile (b < a) {\n\t    \t\t\tb = b << 1;\n\t    \t\t}\n\t    \t\treturn b;\n\t    \t}\n\t     \n\t    \tpublic static boolean PointInTriangle(int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8) {\n\t    \t\tint s = p2 * p5 - p1 * p6 + (p6 - p2) * p7 + (p1 - p5) * p8;\n\t    \t\tint t = p1 * p4 - p2 * p3 + (p2 - p4) * p7 + (p3 - p1) * p8;\n\t     \n\t    \t\tif ((s < 0) != (t < 0))\n\t    \t\t\treturn false;\n\t     \n\t    \t\tint A = -p4 * p5 + p2 * (p5 - p3) + p1 * (p4 - p6) + p3 * p6;\n\t    \t\tif (A < 0.0) {\n\t    \t\t\ts = -s;\n\t    \t\t\tt = -t;\n\t    \t\t\tA = -A;\n\t    \t\t}\n\t    \t\treturn s > 0 && t > 0 && (s + t) <= A;\n\t    \t}\n\t     \n\t    \tpublic static float area(int x1, int y1, int x2, int y2, int x3, int y3) {\n\t    \t\treturn (float) Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);\n\t    \t}\n\t     \n\t    \tpublic static boolean isPrime(int n) {\n\t    \t\t// Corner cases\n\t    \t\tif (n <= 1)\n\t    \t\t\treturn false;\n\t    \t\tif (n <= 3)\n\t    \t\t\treturn true;\n\t     \n\t    \t\t// This is checked so that we can skip \n\t    \t\t// middle five numbers in below loop\n\t    \t\tif (n % 2 == 0 || n % 3 == 0)\n\t    \t\t\treturn false;\n\t     \n\t    \t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t    \t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t    \t\t\t\treturn false;\n\t     \n\t    \t\treturn true;\n\t    \t}\n\t     \n\t    \t//merge Sort\n\t     \n\t    \tstatic long sort(int a[])\n\t    \t{  int n=a.length;\n\t    \t\tint b[]=new int[n];\t\n\t    \t\treturn mergeSort(a,b,0,n-1);}\n\t    \tstatic long mergeSort(int a[],int b[],long left,long right)\n\t    \t{ long c=0;if(left<right)\n\t    \t {   long mid=left+(right-left)/2;\n\t    \t\t c= mergeSort(a,b,left,mid);\n\t    \t\t c+=mergeSort(a,b,mid+1,right);\n\t    \t\t c+=merge(a,b,left,mid+1,right); }\t\n\t    \t\treturn c;\t }\n\t    \tstatic long merge(int a[],int  b[],long left,long mid,long right)\n\t    \t{long c=0;int i=(int)left;int j=(int)mid; int k=(int)left;\n\t    \twhile(i<=(int)mid-1&&j<=(int)right)\n\t    \t{ if(a[i]>a[j]) {b[k++]=a[i++]; }\n\t    \telse\t{ b[k++]=a[j++];c+=mid-i;}}\n\t    \twhile (i <= (int)mid - 1)   b[k++] = a[i++]; \n\t    \twhile (j <= (int)right) b[k++] = a[j++];\n\t    \tfor (i=(int)left; i <= (int)right; i++) \n\t    \t\ta[i] = b[i];  return c;  }\n\t    \tpublic static boolean isSubSequence(String large, String small, int largeLen, int smallLen) {\n\t    \t\t//base cases\n\t    \t\tif (largeLen == 0)\n\t    \t\t\treturn false;\n\t    \t\tif (smallLen == 0)\n\t    \t\t\treturn true;\n\t    \t\t// If last characters of two strings are matching\n\t    \t\tif (large.charAt(largeLen - 1) == small.charAt(smallLen - 1))\n\t    \t\t\tisSubSequence(large, small, largeLen - 1, smallLen - 1);\n\t    \t\t// If last characters are not matching\n\t    \t\treturn isSubSequence(large, small, largeLen - 1, smallLen);\n\t    \t}\n\t     \n\t    \t// To Get Input\n\t    \t// Some Buffer Methods\n\t     \n\t    \tpublic static void InputReader(InputStream stream1) {\n\t    \t\tstream = stream1;\n\t    \t}\n\t     \n\t    \tprivate static boolean isWhitespace(int c) {\n\t    \t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    \t}\n\t     \n\t    \tprivate static boolean isEndOfLine(int c) {\n\t    \t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t    \t}\n\t     \n\t    \tprivate static int read() {\n\t    \t\tif (numChars == -1)\n\t    \t\t\tthrow new InputMismatchException();\n\t    \t\tif (curChar >= numChars) {\n\t    \t\t\tcurChar = 0;\n\t    \t\t\ttry {\n\t    \t\t\t\tnumChars = stream.read(buf);\n\t    \t\t\t} catch (IOException e) {\n\t    \t\t\t\tthrow new InputMismatchException();\n\t    \t\t\t}\n\t    \t\t\tif (numChars <= 0)\n\t    \t\t\t\treturn -1;\n\t    \t\t}\n\t    \t\treturn buf[curChar++];\n\t    \t}\n\t     \n\t    \tprivate static int nextInt() {\n\t    \t\tint c = read();\n\t    \t\twhile (isSpaceChar(c))\n\t    \t\t\tc = read();\n\t    \t\tint sgn = 1;\n\t    \t\tif (c == '-') {\n\t    \t\t\tsgn = -1;\n\t    \t\t\tc = read();\n\t    \t\t}\n\t    \t\tint res = 0;\n\t    \t\tdo {\n\t    \t\t\tif (c < '0' || c > '9')\n\t    \t\t\t\tthrow new InputMismatchException();\n\t    \t\t\tres *= 10;\n\t    \t\t\tres += c - '0';\n\t    \t\t\tc = read();\n\t    \t\t} while (!isSpaceChar(c));\n\t    \t\treturn res * sgn;\n\t    \t}\n\t     \n\t    \tprivate static long nextLong() {\n\t    \t\tint c = read();\n\t    \t\twhile (isSpaceChar(c))\n\t    \t\t\tc = read();\n\t    \t\tint sgn = 1;\n\t    \t\tif (c == '-') {\n\t    \t\t\tsgn = -1;\n\t    \t\t\tc = read();\n\t    \t\t}\n\t    \t\tlong res = 0;\n\t    \t\tdo {\n\t    \t\t\tif (c < '0' || c > '9')\n\t    \t\t\t\tthrow new InputMismatchException();\n\t    \t\t\tres *= 10;\n\t    \t\t\tres += c - '0';\n\t    \t\t\tc = read();\n\t    \t\t} while (!isSpaceChar(c));\n\t    \t\treturn res * sgn;\n\t    \t}\n\t     \n\t    \tprivate static String nextToken() {\n\t    \t\tint c = read();\n\t    \t\twhile (isSpaceChar(c))\n\t    \t\t\tc = read();\n\t    \t\tStringBuilder res = new StringBuilder();\n\t    \t\tdo {\n\t    \t\t\tres.appendCodePoint(c);\n\t    \t\t\tc = read();\n\t    \t\t} while (!isSpaceChar(c));\n\t    \t\treturn res.toString();\n\t    \t}\n\t     \n\t    \tprivate static String nextLine() {\n\t    \t\tint c = read();\n\t    \t\twhile (isSpaceChar(c))\n\t    \t\t\tc = read();\n\t    \t\tStringBuilder res = new StringBuilder();\n\t    \t\tdo {\n\t    \t\t\tres.appendCodePoint(c);\n\t    \t\t\tc = read();\n\t    \t\t} while (!isEndOfLine(c));\n\t    \t\treturn res.toString();\n\t    \t}\n\t     \n\t    \tprivate static int[] nextIntArray(int n) {\n\t    \t\tint[] arr = new int[n];\n\t    \t\tfor (int i = 0; i < n; i++) {\n\t    \t\t\tarr[i] = nextInt();\n\t    \t\t}\n\t    \t\treturn arr;\n\t    \t}\n\t     \n\t    \tprivate static int[][] next2dArray(int n, int m) {\n\t    \t\tint[][] arr = new int[n][m];\n\t    \t\tfor (int i = 0; i < n; i++) {\n\t    \t\t\tfor (int j = 0; j < m; j++) {\n\t    \t\t\t\tarr[i][j] = nextInt();\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\treturn arr;\n\t    \t}\n\t    \tprivate static char[][] nextCharArray(int n,int m){\n\t    \t\tchar [][]c=new char[n][m];\n\t    \t\tfor(int i=0;i<n;i++){\n\t    \t\t\tString s=nextLine();\n\t    \t\t\tfor(int j=0;j<s.length();j++){\n\t    \t\t\t\tc[i][j]=s.charAt(j);\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\treturn c;\n\t    \t}\n\t     \n\t    \tprivate static long[] nextLongArray(int n) {\n\t    \t\tlong[] arr = new long[n];\n\t    \t\tfor (int i = 0; i < n; i++) {\n\t    \t\t\tarr[i] = nextLong();\n\t    \t\t}\n\t    \t\treturn arr;\n\t    \t}\n\t     \n\t    \tprivate static void pArray(int[] arr) {\n\t    \t\tfor (int i = 0; i < arr.length; i++) {\n\t    \t\t\tpw.print(arr[i] + \" \");\n\t    \t\t}\n\t    \t\tpw.println();\n\t    \t\treturn;\n\t    \t}\n\t     \n\t    \tprivate static void pArray(long[] arr) {\n\t    \t\tfor (int i = 0; i < arr.length; i++) {\n\t    \t\t\tpw.print(arr[i] + \" \");\n\t    \t\t}\n\t    \t\tpw.println();\n\t    \t\treturn;\n\t    \t}\n\t     \n\t    \tprivate static void pArray(boolean[] arr) {\n\t    \t\tfor (int i = 0; i < arr.length; i++) {\n\t    \t\t\tpw.print(arr[i] + \" \");\n\t    \t\t}\n\t    \t\tpw.println();\n\t    \t\treturn;\n\t    \t}\n\t     \n\t    \tprivate static boolean isSpaceChar(int c) {\n\t    \t\tif (filter != null)\n\t    \t\t\treturn filter.isSpaceChar(c);\n\t    \t\treturn isWhitespace(c);\n\t    \t}\n\t     \n\t    \tprivate interface SpaceCharFilter {\n\t    \t\tpublic boolean isSpaceChar(int ch);\n\t    \t}\n\t\n\t\t//----------------------------------------My Code------------------------------------------------//\n\t    \tprivate static void soln() {\n\t    \t\t//-1 west 1 east 2 north -2 south\n\t  \n\t    \t\tint n=nextInt();\n\t    \t\tint a[]=new int [n+1];\n\t    \t\tint parent_mat=-1;\n\t    \t\tfor(int i=1;i<=n;i++){\n\t    \t\t\ta[i]=nextInt();\n\t    \t\t\tif(i==a[i])\n\t    \t\t\t\tparent_mat=i;\n\t    \t\t}\n\t    \t\n\t    \t\tHashSet<Integer> usable =new HashSet();\n\t    \t\tDsu d=new Dsu(n);\n\t    \t\tfor(int i=1;i<=n;i++){\n\t    \t\t\tif(d.find(i)==d.find(a[i]) && i!=parent_mat && a[i]!=parent_mat){\n\t    \t\t\t\tusable.add(i);\n\t    \t\t\t}else\n\t    \t\t\td.union(i, a[i]);\n\t    \t\t}\n\t    \t\t\n\t    \t\tHashSet<Integer> hs=new HashSet<Integer>();\n\t    \t\tfor(int i=1;i<=n;i++){\n\t    \t\t\tint pa=d.find(i);\n\t    \t\t//\tSystem.out.println(pa);\n\t    \t\t\t\n\t    \t\t\ths.add(pa);\n\t    \t\t}\n\t    \t\n\t    \t\tArrayList<Integer> elements_in_par[]=new ArrayList[n+1];\n\t    \t\tfor(int i=1;i<=n;i++)\n\t    \t\t\telements_in_par[i]=new ArrayList<Integer>();\n\t    \t\tfor(int i=1;i<=n;i++){\n\t    \t\t\telements_in_par[d.find(i)].add(i);\n\t    \t\t}\n\t    \t\t/*for(int x:hs){\n\t    \t\t\tfor(int j=0;j<elements_in_par[x].size();j++){\n\t    \t\t\t\tSystem.out.print(elements_in_par[x].get(j)+\" \");\n\t    \t\t\t}\n\t    \t\t\tSystem.out.println();\n\t    \t\t}*/\n\t    \t\tlong c=0;\n\t    \t\tif(parent_mat!=-1){\n\t    \t\t\tfor(int x:hs){\n\t    \t\t\t\tif(!elements_in_par[x].contains(parent_mat)){\n\t    \t\t\t\tfor(int i=0;i<elements_in_par[x].size();i++){\n\t    \t\t\t\t\tif(usable.contains(elements_in_par[x].get(i))){\n\t    \t\t\t\t\t\ta[elements_in_par[x].get(i)]=parent_mat;\n\t    \t\t\t\t\t\tbreak;\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t\tc++;}\n\t    \t\t\t}\n\t    \t\t\n\t    \t\t\n\t    \t\t}else{\n\t    \t\t\tfor(int x:hs){\n\t    \t\t\tfor(int i=0;i<elements_in_par[x].size();i++){\n\t    \t\t\t\tif(usable.contains(elements_in_par[x].get(i))){\n\t    \t\t\t\tparent_mat=elements_in_par[x].get(i);\n\t    \t\t\t\ta[parent_mat]=parent_mat;\n\t    \t\t\t\tc++;\n\t    \t\t\t\tbreak;\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t\tfor(int x:hs){\n\t    \t\t\t\tif(!elements_in_par[x].contains(parent_mat)){\n\t    \t\t\t\tfor(int i=0;i<elements_in_par[x].size();i++){\n\t    \t\t\t\t\tif(usable.contains(elements_in_par[x].get(i))){\n\t    \t\t\t\t\t\ta[elements_in_par[x].get(i)]=parent_mat;\n\t    \t\t\t\t\t\tbreak;\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t\tc++;}\n\t    \t\t}\n\t    \t\t\n\t    \t}\t    \t\n\t    \n\t    pw.println(c);\n\t    \t\tfor(int i=1;i<=n;i++){\n\t    \t\t\tpw.print(a[i]+\" \");\n\t    \t\t}\n\t    }\t    \t\n\t    \t\t//-----------------------------------------The End--------------------------------------------------------------------------//\n\t    \t\n\t    \n\t    \n\t    \n\t }\n\t    \t\n\t   \n\t    \n\t\tclass Pair implements Comparable<Pair>{\n\t\t   \n\t\t\tint ind;\n\t\t\tint len;\n\t\t\tPair(int ind,int len){\n\t\t\t\tthis.ind=ind;\n\t\t\t\tthis.len=len;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Pair o) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t//\tSort in increasing order\nreturn len-o.len;\n\t\t\t}\n\t\t\n\t\t}\n\t        class Graph{\n\t        \tprivate static int V,level[][],count=-1,lev_dfs[],degree=0,no_vert_conn_comp=0;\n\t        \tprivate Stack <Integer>st=new Stack();\n\t        \tprivate static LinkedList<Integer > adj[];\n\t        \tprivate boolean[][] Visite;\n\t        \tprivate static boolean [] Visited;\n\t        \tprivate static HashSet<Integer> Vis=new HashSet();\n\t        \tprivate static Stack<Integer> topo_sort=new Stack<>();\n\t        \tprivate static HashMap<String,Integer> hm=new HashMap<>();\n\t  \n\t\t    \n\t\t    \t\n\t    Graph(int V){\n\t    V++;\n\t    this.V=(V);\n\t    adj=new LinkedList[V];\n\t    Visite=new boolean[100][100];\n\t    \n \t    Visited=new boolean[V];\n\t    level=new int[100][100];\n\t    lev_dfs=new int[V]; \n\t   for(int i=0;i<V;i++)\n\t\t   adj[i]=new LinkedList<Integer>();\n\t\n\t    }\n\t    void setup(int n,int m){\n\t    \t//HashMap<String,Integer> hm=new HashMap<>();\n    \t\tint co=1;\n\t    \tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<m;j++){\n    \t\t\t\tString s=\"\";\n    \t\t\t\ts+=(i)+\" \"+(j);\n    \t\t\t\thm.put(s, co);\n    \t\t\tco++;\n    \t\t\t}\n    \t\t}\n\t    }\n\t   void addEdge(int v,int w){\n\t    \t\n\t    \tif(adj[v]==null){\n\t    \t\tadj[v]=new LinkedList();\n\t    \t}\n\t    \tadj[v].add(w);\n\t     \n\t    \t\n\t    }\n\t  \n\t public static void top_ans(){\n\twhile(topo_sort.size()!=0)\n{\n\tSystem.out.print(hm.get(topo_sort.peek()));\ntopo_sort.pop();\n}\n\t\n\t }\n\t public static void topoSort(int startVert){\n\t\t if(!Vis.contains(startVert)){\n\t\t\t topoSortUtil(startVert);\n\t\t }\n\t }\n\t    public static void topoSortUtil(int curr_Vert){\n\t    \tVis.add(curr_Vert);\n\t    \tIterator<Integer> it=adj[curr_Vert].listIterator();\n\t    \t\n\t    \twhile(it.hasNext()){\n\t    \t\tint n=it.next();\n\t   // \t\tSystem.out.println(n);\n\t    \t\tif(!Vis.contains(n)){\n\t    \t\t\ttopoSortUtil(n);\n\t    \t\t}\n\t    \t\t\n\t    \t}\n\t    \ttopo_sort.push(curr_Vert);\n\t    }\n\t    \n\t    public static int BFS2(int startVert){\n\t    \tVisited=new boolean[V];\n\t    \tfor(int i=1;i<V;i++){\n\t    \t\tlev_dfs[i]=-1;\n\t    \t}\n\t    //\tSystem.out.println(startVert);\n\t    \tQueue<Integer> q=new LinkedList<Integer>();\n\t    \tq.add(startVert);\n\t    \t\n\t    \tlev_dfs[startVert]=0;\n\t    \twhile(!q.isEmpty()){\n\t    \t\tint top=q.poll();\n\t    \t\t\n\t    \t\tIterator<Integer> i= adj[top].listIterator();\n\t    \t\twhile(i.hasNext()){\n\t    \t\t\tint n=i.next();\n\t    \t//\t\tSystem.out.println(top+\" \"+n);\n\t    \t\t\tif(!Visited[n]){\n\t    \t\t\t\tq.add(n);\n\t    \t\t\t\tVisited[n]=true;\n\t    \t\t\t\tlev_dfs[n]=lev_dfs[top]+1;\n\t    \t\t\t\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \n\t    //\tq.clear();\n\t    \treturn -1;\n\t    }\n\t    public static int getAn(int end){\n\t    \treturn lev_dfs[end];\n\t    }\n\t    public int getEd(){\n\t    \treturn degree/2;\n\t    }\n\t    public void get(int from,int to){\n\t    \tint h=lev_dfs[from]-lev_dfs[to];\n\t    \tif(h<=0){\n\t    \t\tSystem.out.println(-1);\n\t    \t}else{\n\t    \t\tSystem.out.println(h-1);\n\t    \t}\n\t    }\n\t    private static boolean check(int x,int y,char c[][]){\n\t\t\n\t\t\tif((x>=0 && y>=0) && (x<c.length && y<c[0].length) && c[x][y]!='#'){\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t    public int BFS(int x,int y,int k,char[][] c)\n\t    {\n\t    \t LinkedList<Pair> queue = new LinkedList<Pair>();\n\t        //Visited[s]=true;\n\t   //     queue.add(new Pair(x,y));\n\t       int count=0;\n\t   level[x][y]=-1;\n\t   c[x][y]='M';\n\t        while (!queue.isEmpty())\n\t        {\n\t            Pair temp = queue.poll();\n\t        \n\t            \n\t        }\n\t        return V;\n\t    }\n\t    \n\t   \n\t    \n\t     public long dfs(int startVertex,int end){\n\t    //\t getAns(startVertex);\n\t    \t Visited=new boolean[V];\n\t    \t if(!Visited[startVertex])  {\n\t    \n\t   return dfsUtil(startVertex,end);\n\t    \t//return getAns();\n\t    \t}\n\t    \t \n\t    \n\t     \n\t    return 0;\n\t    \t}\n\t private long dfsUtil(int startVertex,int end) {//0-Blue 1-Pink\n\t\t int c=1;\n\t\n\t\t long cout=0;\n\t      degree=0;\n\t    \tVisited[startVertex]=true;\n\t    \tlev_dfs[startVertex]=0;\n\t      st.push(startVertex);\n\t      int temp=-1;\n\t      \n\t    while(!st.isEmpty()){\n\t    \t\n\t    \tint top=st.pop();\n\t    temp=Math.max(temp, top);\n\t    //\tts.add(top);\n\t    \tIterator<Integer> i=adj[top].listIterator();\n\t     \n\t    while(i.hasNext()){\n\t    //\tSystem.out.println(top);\n\t    \tint n=i.next();\n\t     if( !Visited[n]){\n\t    \t\t\t\tVisited[n]=true;\n\t    \t\t\t\t\n\t    \t\t\t//\tcol_freq[col[n-1]]++;\n\t    \t\t\t\tc++;\n\t    \t\t\t\tst.push(n);\n\t    \t\t\t\t\tlev_dfs[n]=lev_dfs[top]+1;\n\t    \t\t\t\t\tif(n==end){\n\t    \t    \t\t\t\treturn lev_dfs[n];\t\n\t    \t    \t\t\t\t}\n\t    \t\t }\n\t         }\n\t }\n\t //   System.out.println(temp);\n\t    if(lev_dfs[temp]+(end-temp)<=0){\n\t    \treturn end-startVertex;\n\t    }\n\t    return Math.min(end-startVertex, lev_dfs[temp]+(end-temp));\n\t    \t\n\t    }\n\t        \n\t        }     \n\t       \t        \n\t    class Dsu{\n\t    \tprivate int rank[], parent[] ,n;\n\t    \t\n\t    \tDsu(int size){\n\t    \t\tthis.n=size+1;\n\t    \t\trank=new int[n];\n\t    \t\tparent=new int[n];\n\t    \tmakeSet();\n\t    \t}\n\t    \t\n\t    \tvoid makeSet(){\n\t    \t\tfor(int i=0;i<n;i++){\n\t    \t\t\tparent[i]=i;\n\t    \t\t}\n\t    \t}\n\t    \t\n\t    \tint find(int x){\n\t    \t\tif(parent[x]!=x){\n\t    \t\t\t\n\t    \t\t\tparent[x]=find(parent[x]);\n\t    \t\t}\n\t    \t\treturn parent[x];\n\t    \t}\t\n\t    \t\n\t    \tvoid union(int x,int y){\n\t    \t\tint xRoot=find(x);\n\t    \t\tint yRoot=find(y);\n\t    \t\t\n\t    \t\tif(xRoot==yRoot)\n\t    \t\t\treturn;\n\t    \t\tif(rank[xRoot]<rank[yRoot]){\n\t    \t\tparent[xRoot]=yRoot;\t\n\t    \t\t}else if(rank[yRoot]<rank[xRoot]){\n\t    \t\t\tparent[yRoot]=xRoot;\n\t    \t\t}else{\n\t    \t\t\tparent[yRoot]=xRoot;\n\t    \t\t\trank[xRoot]++;\n\t    \t\t}\n\t    \t\t\n\t    \t}\n\t     \n\t    }\n\t    class Heap{\n\t    \t\n\t    \tpublic static void build_max_heap(long []a,int size){\n\t    \t\t\n\t    \t\tfor(int i=size/2;i>0;i--){\n\t    \t\t\tmax_heapify(a, i,size);\n\t    \t\t}\n\t    \t\t\n\t    \t\t\t}\n\t    \tprivate static void max_heapify(long[] a,int i,int size){\n\t    \t\tint left_child=2*i;\n\t    \t\tint right_child=(2*i+1);\n\t    \t\tint largest=0;\n\t    \t\t\n\t    \t\tif(left_child<size && a[left_child]>a[i]){\n\t    \t\t\tlargest=left_child;\n\t    \t\t}else{\n\t    \t\t\tlargest=i;\n\t    \t\t}\n\t    \t\t\n\t    \t\tif(right_child<size && a[right_child]>a[largest]){\n\t    \t\t\tlargest=right_child;\n\t    \t\t}\n\t    \t\tif(largest!=i){\n\t    \t\t\tlong temp=a[largest];\n\t    \t\t\ta[largest]=a[i];\n\t    \t\t\ta[i]=temp;\n\t    \t\t\tmax_heapify(a, largest,size);\n\t    \t\t}\n\t    \t}\n\t    \tprivate static void min_heapify(int[] a,int i){\n\t    \t\tint left_child=2*i;\n\t    \t\tint right_child=(2*i+1);\n\t    \t\tint largest=0;\n\t    \t\t\n\t    \t\tif(left_child<a.length && a[left_child]<a[i]){\n\t    \t\t\tlargest=left_child;\n\t    \t\t}else{\n\t    \t\t\tlargest=i;\n\t    \t\t}\n\t    \t\t\n\t    \t\tif(right_child<a.length && a[right_child]<a[largest]){\n\t    \t\t\tlargest=right_child;\n\t    \t\t}\n\t    \t\tif(largest!=i){\n\t    \t\t\tint temp=a[largest];\n\t    \t\t\ta[largest]=a[i];\n\t    \t\t\ta[i]=temp;\n\t    \t\t\tmin_heapify(a, largest);\n\t    \t\t}\n\t    \t}\n\t    \tpublic static void extract_max(int size,long a[]){\n\t    \t\tif(a.length>1){\n\t    \t\t\tlong max=a[1];\n\t    \t\t\ta[1]=a[a.length-1];\n\t    \t\t\tsize--;\n\t    \t\t\tmax_heapify(a, 1,a.length-1);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    \n\t    class MyComp implements Comparator<Long>{\n\t        \n\t\t\t@Override\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\tif(o1<o2){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else if(o1>o2){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t}\n\t    }"
        },
        {
            "language": 1,
            "solution": "import itertools\nimport sys\n\n\ndef readline_int(delta=0):\n    return [int(i) + delta for i in raw_input().split()]\n\nclass Solution(object):\n    def find(self, ident, fa):\n        \"\"\"\n        if fa[ident] != ident:\n             fa[ident] = self.find(fa[ident], fa)\n        return fa[ident]\n        \"\"\"\n        root = ident\n        while fa[root] != root:\n            root = fa[root]\n        cursor = ident\n        while cursor != root:\n            fa_cursor = fa[cursor]\n            fa[cursor] = root\n            cursor = fa_cursor\n        return root\n\n    def merge(self, ident_child, ident_father, fa):\n        fa_child = self.find(ident_child, fa)\n        fa_father = self.find(ident_father, fa)\n        fa[fa_child] = fa_father\n\n    def solve(self):\n        n = self.n\n        p = self.p\n        issues = []\n        roots = []\n        fa = [i for i in xrange(n)]\n\n        for current in xrange(n):\n            parent = p[current]\n            if parent == current:\n                roots.append(current)\n                continue\n\n            parent_set_id = self.find(parent, fa)\n            if parent_set_id == current:\n                issues.append(current)\n                continue\n\n            self.merge(current, parent, fa)\n\n        root = None\n        changes = 0\n        if len(roots) > 0:\n            root = roots[0]\n            changes = len(roots) + len(issues) - 1\n        elif len(roots) == 0:\n            root = roots[0] if len(roots) > 0 else issues[0]\n            changes = len(roots) + len(issues)\n\n        for ident in itertools.chain(roots, issues):\n            p[ident] = root\n\n        return (changes, p, )\n\n    def read_data(self):\n        self.n = readline_int()[0]\n        self.p = readline_int(delta=-1) # make sure to restore index while printing result\n\n    def print_result(self, result):\n        changes, p = result\n        print(changes)\n        for idx, parent in enumerate(p):\n            sys.stdout.write(str(parent + 1))\n            if idx != len(p) - 1:\n                sys.stdout.write(' ')\n        sys.stdout.write('\\n')\n\n\n    def run(self):\n        self.read_data()\n        result = self.solve()\n        self.print_result(result)\n\n\nSolution().run()\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 10;\nint N, A[MAXN], ans[MAXN];\nvector<int> cyc[MAXN];\nbool vis[MAXN];\nint main() {\n  scanf(\"%d\", &N);\n  int isame = -1;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &A[i]);\n    if (i == A[i]) {\n      isame = i;\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    ans[i] = A[i];\n  }\n  for (int i = 1; i <= N; i++) {\n    if (vis[i]) {\n      continue;\n    }\n    vector<int> vc;\n    int cur = i;\n    while (true) {\n      vc.push_back(cur);\n      vis[cur] = true;\n      int ncur = A[cur];\n      if (vis[ncur]) {\n        auto it = find(vc.begin(), vc.end(), ncur);\n        if (it == vc.end()) {\n          break;\n        }\n        vc.erase(vc.begin(), it);\n        if (i == 1 && isame == -1) {\n          isame = vc.back();\n          ans[isame] = isame;\n        } else {\n          ans[vc.back()] = isame;\n        }\n        break;\n      }\n      cur = A[cur];\n    }\n  }\n  int ndiff = 0;\n  for (int i = 1; i <= N; i++) {\n    ndiff += (A[i] != ans[i]);\n  }\n  printf(\"%d\\n\", ndiff);\n  for (int i = 1; i <= N; i++) {\n    printf(\"%d \", ans[i]);\n  }\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nconst int mod = 1e9 + 7;\nconst ll inf = ll(0x3f3f3f3f3f3f3f3f);\nconst double PI = acos(-1), eps = 1e-9;\nconst int mxn = 2e5, mxa = 1e5, mxk = 2e3;\nint n, p[mxn + 5], vis[mxn + 5];\nvoid solve() {\n  cin >> n;\n  int par = -1;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n    if (p[i] == i) par = i;\n  }\n  int ans = 0, id = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (vis[i]) continue;\n    ++id;\n    int x = i;\n    while (!vis[x]) {\n      vis[x] = id;\n      x = p[x];\n    }\n    if (vis[x] != id) continue;\n    if (par == -1) {\n      par = x;\n      p[x] = par;\n      ++ans;\n    }\n    if (x != par) {\n      p[x] = par;\n      ++ans;\n    }\n  }\n  cout << ans << '\\n';\n  for (int i = 1; i <= n; ++i) cout << p[i] << ' ';\n  cout << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  t = 1;\n  while (t-- > 0) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 50;\nconst int INF = 0x3f3f3f3f;\nint a[maxn], fa[maxn], b[maxn];\nint vis[maxn], c[maxn], tot = 0;\nint findfa(int x) { return fa[x] == x ? x : fa[x] = findfa(fa[x]); }\nvoid uni(int x, int y) {\n  int fax = findfa(x);\n  int fay = findfa(y);\n  if (fax != fay)\n    fa[fax] = fay;\n  else\n    b[++tot] = x;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < maxn; i++) fa[i] = i;\n  int p = 0;\n  int root;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == i) {\n      p++;\n      if (p == 1)\n        root = i;\n      else\n        b[++tot] = i;\n    } else\n      uni(i, a[i]);\n  }\n  int st = 1;\n  if (p == 0) {\n    a[b[1]] = b[1];\n    root = b[1];\n  }\n  printf(\"%d\\n\", tot);\n  for (int i = 1; i <= tot; i++) {\n    if (b[i] == root) continue;\n    if (findfa(root) == findfa(b[i])) continue;\n    a[b[i]] = root;\n  }\n  for (int i = 1; i <= n; i++) printf(\"%d \", a[i]);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Solve{\n    static int[] par;\n    static int[] p;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        par=new int[n+1];\n        p=new int[n+1];\n        for(int i=0;i<=n;i++){\n            p[i]=i;\n        }\n        int pa=-1;\n        for(int i=1;i<=n;i++){\n            par[i]=sc.nextInt();\n            if(pa<0 && par[i]==i)pa=i;\n            int a=find(i);\n            int b=find(par[i]);\n            if(a!=b)p[a]=b;\n        }\n        if(pa<0){\n            for(int i=1;i<=n;i++){\n                if(p[i]==i){\n                    pa=i;\n                    break;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1;i<=n;i++){\n            if(p[i]==i && par[i]!=pa){\n                par[i]=pa;\n                ans++;\n            }\n        }\n        System.out.println(ans);\n\n            for(int i=1;i<=n;i++)System.out.print(par[i]+\" \");\n   \n        \n    }\n    static int find(int n){\n        if(p[n]==n)return n;\n         return p[n]=find(p[n]);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i)\n                a[i] = in.nextInt() - 1;\n            ArrayList<Integer> cyc = new ArrayList<>();\n            int bc = -1;\n            int[] u = new int[n];\n            for (int i = 0; i < n; ++i) {\n                if (u[i] != 0) continue;\n                int x = i;\n                ArrayList<Integer> marked = new ArrayList<>();\n                do {\n                    u[x] = 1;\n                    marked.add(x);\n                    x = a[x];\n                } while (u[x] == 0);\n                if (u[x] == 1) {\n                    cyc.add(x);\n                    if (a[x] == x) bc = x;\n                }\n                for (int y : marked) {\n                    u[y] = 2;\n                }\n            }\n            int res = cyc.size();\n            if (bc != -1) --res;\n            else {\n                int x = cyc.get(0);\n                a[x] = x;\n                bc = x;\n            }\n            out.printLine(res);\n            for (int x : cyc) {\n                if (x != bc) a[x] = bc;\n            }\n            for (int i = 0; i < n; ++i) {\n                out.print((a[i] + 1) + \" \");\n            }\n            out.printLine();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "/*-\n * Codeforces problem :\n * http://codeforces.com/problemset/problem/698/B\n *\n * In the first line print the minimum number of elements to change,\n * in order to get a valid sequence.\n * In the second line, print any valid sequence possible to get\n * from (a1,\u2009a2,\u2009...,\u2009an) in the minimum number of changes.\n * If there are many such sequences, any of them will be accepted.\n */\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * @author Karthik Venkataraman\n * @email kafy83@gmail.com\n */\npublic class FixATree {\n\n    int n;\n    int sn;\n    int[] pi;\n    int[] mi;\n    int[] ri;\n\n    private void compute() {\n        InputReader sc = new InputReader(System.in);\n        n = sc.nextInt();\n        pi = new int[n + 1];\n        mi = new int[n + 1];\n        ri = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pi[i] = sc.nextInt();\n            if (sn == 0 && i == pi[i]) {\n                sn = i;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            if (mi[i] == 0) {\n                dfs(i);\n            }\n        }\n        int result = 0;\n        if (sn == 0) {\n            result++;\n            sn = pi[ri[1]] = ri[1];\n        }\n        for (int i = 1; i <= n; i++) {\n            if (sn != pi[ri[i]]) {\n                pi[ri[i]] = sn;\n                result++;\n            }\n        }\n        System.out.println(result);\n        for (int i = 1; i <= n; i++) {\n            System.out.print(pi[i] + \" \");\n        }\n    }\n\n    private int dfs(int i) {\n        mi[i] = 1;\n        int pmi = mi[pi[i]];\n        int sr;\n        switch (pmi) {\n            case 0:\n                sr = dfs(pi[i]);\n                break;\n            case 1:\n                sr = i;\n                break;\n            case 2:\n            default:\n                sr = ri[pi[i]];\n                break;\n        }\n        mi[i] = 2;\n        return ri[i] = sr;\n    }\n\n    class InputReader {\n\n        private static final int INPUT_KB = 1024;\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), INPUT_KB);\n        }\n\n        String readNext() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException ex) {\n                    throw new IllegalArgumentException(ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(readNext());\n        }\n    }\n\n    public static void main(String... args) {\n        FixATree fat = new FixATree();\n        fat.compute();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\npublic class Tester {\n\tpublic static int[] parent;\n\tstatic int arr[];;\n\tpublic static void main(String args[])\n\t{\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tint n=in.nextInt(),root=-1;\n\t\tparent=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t\tarr=new int[n];\n\t\tarr=nextIntArray(in,n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t\tif(arr[i]==i)\n\t\t\t\troot=i;\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(find(parent,i)!=find(parent,arr[i]))\n\t\t\t{\n\t\t\t\tmerge(i,arr[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(root==-1)\n\t\t\t\t{\n\t\t\t\t\troot=find(parent,i);\n\t\t\t\t}\n\t\t\t\tif(arr[i]!=root)\n\t\t\t\t{\n\t\t\t\t\tarr[i]=root;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(count);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tout.print((arr[i]+1)+\" \");\n\t\t}\n\t\tout.close();\n\t}\n\tstatic int find(int[] arr,int x)\n\t{\n\t\tif(arr[x]==x)\n\t\t\treturn x;\n\t\treturn find(arr,parent[x]);\n\t}\n\tstatic void merge(int x,int y)\n\t{\n\t\tint px=find(parent,x);\n\t\tint py=find(parent,y);\n\t\tparent[px]=py;\n\t}\n\tprivate static int[] nextIntArray(InputReader in,int n)\t\n\t{\n\t\tint[] a=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=in.nextInt()-1;\n\t\treturn a;\n\t}\n\tpublic static double dis(double x1,double x2,double y1)\n\t{\n\t\treturn Math.sqrt(((x1-x2)*(x1-x2))+(y1*y1));\n\t}\n\tprivate static String[] nextStringArray(InputReader in,int n)\t\n\t{\n\t\tString[] a=new String[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=in.next();\n\t\treturn a;\n\t}\n\tprivate static void show(int[] a)\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tprivate static void show2DArray(char[][] a)\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t{\n\t\t\tfor(int j=0;j<a[0].length;j++)\n\t\t\t\tSystem.out.print(a[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n static long fact(long x)\n {\n\t long i=x,mul=1;\n\t while(i>0)\n\t {\n\t\t mul=(mul%1000000007)*(i%1000000007)%1000000007;\n\t\t i--;\n\t }\n\t return mul;\n }\n static class LengthComparator implements Comparator<String> {\n\t    public int compare(String arg0, String arg1) {\n\t\t// Use Integer.compare to compare the two Strings' lengths.\n\t\treturn (arg0+arg1).compareTo(arg1+arg0);\n\t    }\n\t}\n// static long output(ArrayList<Integer> h[],int j,boolean[] v)\n// {\n//\t int k;\n//\t v[j]=true;\n//\t sum++;\n//\t for(k=0;k<h[j].size();k++)\n//\t {\n//\t\t if(v[h[j].get(k)]==false)\n//\t\t {\n//\t\t\t output(h,h[j].get(k),v);\n//\t\t }\n//\t }\n//\t return sum;\n// }\n static long func(boolean v[],int j,ArrayList<Integer> h[],long ban[])\n {\n\t \tv[j]=true;\n\t \t int k;\n\t \tlong sum=0;\n\t    sum=sum+ban[j];\n\t \t//System.out.println(h[j].size());\n\t \tfor(k=0;k<h[j].size();k++)\n\t \t{\n\t \t\tif(v[h[j].get(k)]==false)\n\t \t\t{\n\t \t\t\tv[h[j].get(k)]=true;\n\t \t\t\tsum+=func(v,h[j].get(k),h,ban);\n\t \t\t}\n\t \t}\n\t \treturn sum;\n }\n/*static class Graph {\n    \t\n    \tprivate static Deque<Integer> stack = new ArrayDeque<Integer>();\n \t\tprivate int least,count,v;\n \t\t\n\t\tSet<Integer>[] cities;\n    \tprivate int[] risk;\n    \t\n    \tGraph(int n,String[] risk){\n    \t\t\n    \t\tcities = new HashSet[n];\n    \t\tthis.risk = new int[n];\n    \t\tfor(int i =0;i<n;i++){\n    \t\t\tcities[i] = new HashSet<>();\n    \t\t}\n    \t\tfor(int i =0;i<n;i++){\n    \t\t\tthis.risk[i] = Integer.parseInt(risk[i]);\n    \t\t}\n    \t\tvisited = new boolean[n];\n    \t}\n    \t\n    \t\n    \tpublic void add(int x,int y){\n    \t\tcities[x].add(y);\n    \t\tcities[y].add(x);\n    \t}\n}*/\n\tstatic int root(int arr[],int i)\n\t{\n\t\twhile(arr[i]!=i)\n\t\t{\n\t\t\ti=arr[i];\n\t\t}\n\t\treturn i;\n\t}\n\tstatic boolean find(int arr[],int a,int b)\n\t{\n\t\tif(root(arr,a)==root(arr,b))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\tstatic void weighted_union(int arr[],int size[],int a,int b)\n\t{\n\t\tint root_a=root(arr,a);\n\t\tint root_b=root(arr,b);\n\t\tif(root_a!=root_b)\n\t\t{\n\t\t\tif(size[root_a]<size[root_b])\n\t\t\t{\n\t\t\t\tarr[root_a]=arr[root_b];\n\t\t\t\tsize[root_b]+=size[root_a];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarr[root_b]=arr[root_a];\n\t\t\t\tsize[root_a]+=size[root_b];\n\t\t\t}\n\t\t//\tcount--;\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair>\n\t{\n\t\tprivate long first;\n\t\tprivate long index;\n\t\t//private long second;;\n\n\t\tpublic Pair(long i, long j) \n\t\t{ \n\t\t\tthis.first = i;\n\t\t\tthis.index = j;\n\t\t}\n\t\tpublic long getFirst() { return first; }\n\t\t//public long getSecond() { return second; }\n\t\tpublic long getIndex() { return index ;}\n\t\tpublic void setFirst(long k) { this.first=k ; }\n\t\tpublic void setIndex(long k) { this.index=k ;}\n\t\t//public void setSecond(long k) { this.second=k ;}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) \n\t\t{\n\t\t\treturn Long.compare(this.first, o.first);\n\t\t}\n\t}\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream inputstream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(inputstream));\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String nextLine(){\n\t\t\tString fullLine=null;\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tfullLine=reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn fullLine;\n\t\t\t}\n\t\t\treturn fullLine;\n\t\t}\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 200000;\nint N, P[MAX_N + 5], V[MAX_N + 5], r, g, ans;\nvoid dfs(int nw) {\n  if (nw == r) return;\n  if (V[nw] == g) {\n    P[nw] = r;\n    ans++;\n    return;\n  } else if (V[nw])\n    return;\n  V[nw] = g;\n  dfs(P[nw]);\n}\nint main() {\n  int i;\n  scanf(\"%d\", &N);\n  for (i = 1; i <= N; i++) scanf(\"%d\", P + i);\n  for (i = 1; i <= N; i++)\n    if (P[i] == i) r = i;\n  for (i = 1; i <= N; i++) {\n    ++g;\n    dfs(i);\n  }\n  printf(\"%d\\n\", ans);\n  for (i = 1; i <= N; i++) {\n    if (!P[i]) {\n      if (!r) r = i;\n      printf(\"%d \", r);\n    } else\n      printf(\"%d \", P[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint n, p[maxn], old[maxn], rt, vis[maxn];\nvoid gen_root() {\n  for (int i = 0; i < n; i++) {\n    if (p[i] == i) {\n      rt = i;\n      return;\n    }\n  }\n  int cur = 0;\n  while (!vis[cur]) {\n    vis[cur] = true;\n    cur = p[cur];\n  }\n  p[cur] = cur;\n  rt = cur;\n}\nvoid connect() {\n  memset(vis, 0, sizeof(vis));\n  for (int i = 0; i < n; i++) {\n    if (p[i] == i) {\n      p[i] = rt;\n      vis[i] = true;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!vis[i]) {\n      int cur = i;\n      while (vis[cur] == 0) {\n        vis[cur] = 100 + i;\n        cur = p[cur];\n      }\n      if (vis[cur] == 100 + i) {\n        p[cur] = rt;\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  memcpy(old, p, sizeof(old));\n  gen_root();\n  connect();\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    if (p[i] != old[i]) {\n      ++res;\n    }\n  }\n  cout << res << '\\n';\n  for (int i = 0; i < n; i++) {\n    cout << p[i] + 1;\n    if (i + 1 < n) {\n      cout << ' ';\n    }\n  }\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\n# Para revisar la correctitud pueden probar el codigo en el codeforce que va a dar accepted\n\n# ver si hay un camino que llega a el a partir\n# de su padre entonces hay un ciclo\n\n\ndef Padre(x, padre):\n    while x != padre[x]:\n        x = padre[x]\n    return x\n\n\ndef FixATree():\n    n = int(input())\n    A = list(map(lambda x: int(x)-1, input().split()))\n\n    padre = [x for x in range(0, n)]\n    ciclosC = 0\n    ciclos = deque([])\n    root = []\n\n    # ir haciendo Merge a cada arista\n    for i in range(0, n):\n\n        p = Padre(A[i], padre)\n        # Si dicha arista perticipa en un ciclo\n        if p == i:\n            # Si es un ciclo del tipo raiz y no hay raiz\n            if not root and (i == A[i]):\n                root = [i, A[i]]\n            else:\n                ciclos.append([i, A[i]])\n                ciclosC += 1\n        # Si no hay ciclo\n        else:\n            padre[i] = A[i]\n\n    print(str(ciclosC))\n    # si existe al menos un ciclo diferente d raiz\n    if ciclosC:\n        i = 0\n        # si no hay raiz el primer ciclo lo hago raiz\n        if not root:\n            root = ciclos.popleft()\n            i = 1\n\n        # los restantes ciclos hago que su padre sea la raiz\n        while ciclos:\n            ciclo = ciclos.popleft()\n            padre[ciclo[0]] = root[0]\n\n    PC = [x + 1 for x in padre]\n    print(*PC, sep=\" \")\n\n\nFixATree()\n\n\n# Casos de prueba:\n# 4\n# 2 3 3 4\n# respuesta\n# 1\n#  2 3 3 3\n\n# 5\n# 3 2 2 5 3\n# respuesta\n# 0\n# 3 2 2 5 3\n\n# 8\n# 2 3 5 4 1 6 6 7\n# respuesta\n# 2\n# 2 3 5 4 1 4 6 7\n\n# El codigo da accepted en el codeforce por lo que los casos de prueba que emplee son los que ahi estan\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = mod * mod;\nint p[210000];\nint v[210000];\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  for (int i = 0; i < a; i++) {\n    scanf(\"%d\", p + i);\n    p[i]--;\n  }\n  int ret = 0;\n  int par = -1;\n  int sec = -1;\n  for (int i = 0; i < a; i++) {\n    if (v[i]) continue;\n    int at = i;\n    vector<int> vis;\n    v[at] = 2;\n    vis.push_back(at);\n    while (1) {\n      int to = p[at];\n      if (v[to] == 1) break;\n      if (v[to] == 2) {\n        if (to != at) {\n          ret++;\n          p[at] = -1;\n          sec = at;\n        } else {\n          if (!~par) {\n            par = at;\n          } else {\n            ret++;\n            p[at] = par;\n          }\n        }\n        break;\n      }\n      v[to] = 2;\n      at = to;\n      vis.push_back(to);\n    }\n    for (int j = 0; j < vis.size(); j++) {\n      v[vis[j]] = 1;\n    }\n  }\n  for (int i = 0; i < a; i++) {\n    if (p[i] == -1) {\n      if (~par)\n        p[i] = par;\n      else\n        p[i] = sec;\n    }\n  }\n  printf(\"%d\\n\", ret);\n  for (int i = 0; i < a; i++) {\n    if (i) printf(\" \");\n    printf(\"%d\", p[i] + 1);\n  }\n  printf(\"\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct nod {\n  int pre, con, hao;\n} edge[410000];\nint use2[210000], ans, use[210000], num[210000], dl[210000], n, i, j, all, p,\n    pos[210000];\nvoid build(int a, int b) {\n  p++;\n  edge[p].pre = pos[a];\n  edge[p].con = b;\n  edge[p].hao = i;\n  pos[a] = p;\n}\nvoid search(int d, int fa) {\n  int w;\n  if (num[d] == d && use2[d] == 0) dl[++all] = d, use2[d] = 1;\n  use[d] = 1;\n  for (w = pos[d]; w; w = edge[w].pre)\n    if (edge[w].hao != fa) {\n      if (use[edge[w].con] == 1) {\n        if (use2[edge[w].hao] == 0) {\n          dl[++all] = edge[w].hao;\n          use2[edge[w].hao] = 1;\n        }\n        continue;\n      }\n      search(edge[w].con, edge[w].hao);\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &num[i]);\n    if (num[i] != i) {\n      build(num[i], i);\n      build(i, num[i]);\n    }\n  }\n  for (i = 1; i <= n; i++)\n    if (use[i] == 0) search(i, 0);\n  if (all != 0) {\n    for (i = 1; i <= all; i++)\n      if (num[dl[i]] == dl[i]) break;\n    if (i > all) i = 1, ans++;\n    num[dl[i]] = dl[i];\n    for (j = 1; j <= all; j++)\n      if (j != i) {\n        num[dl[j]] = num[dl[i]];\n        ans++;\n      }\n  }\n  printf(\"%d\\n\", ans);\n  for (i = 1; i <= n; i++) printf(\"%d \", num[i]);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static int root(int[] parentIds, int c) {\n        while(c != parentIds[c]) {\n            parentIds[c] = parentIds[parentIds[c]];\n            c = parentIds[c];\n        }\n        return c;\n    }\n    private static boolean union(int[] parentIds, int[] groupSizes, int a, int b) {\n        int rootA = root(parentIds, a);\n        int rootB = root(parentIds, b);\n        if(rootA == rootB) {\n            return false;\n        }\n        if(groupSizes[rootA] < groupSizes[rootB]) {\n            parentIds[rootA] = rootB;\n            groupSizes[rootB] += groupSizes[rootA];\n        } else {\n            parentIds[rootB] = rootA;\n            groupSizes[rootA] += groupSizes[rootB];\n        }\n        return true;\n    }\n    public static void main(String[] args) throws IOException{\n        //BufferedReader f = new BufferedReader(new FileReader(\"uva.in\"));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = Integer.parseInt(f.readLine());\n        int[] a = new int[n];\n        int[] parentIds = new int[n];\n        int[] groupSizes = new int[n];\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int r = -1;\n        for(int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken())-1;\n            parentIds[i] = i;\n            groupSizes[i] = i;\n            if(i == a[i]) {\n                r = i;\n            }\n        }\n        int count = 0;\n        for(int i = 0; i < n; i++) {\n            if(i != a[i] && !union(parentIds, groupSizes, i, a[i])) {\n                a[i] = r == -1 ? i : r;\n                count++;\n            }\n            if(i == a[i] && r == -1) {\n                r = a[i];\n            }\n        }\n        for(int i = 0; i < n; i++) {\n            if(i == a[i] && i != r) {\n                a[i] = r;\n                count++;\n            }\n        }\n        out.println(count);\n        out.print(a[0]+1);\n        for(int i = 1; i < n; i++) {\n            out.print(\" \" + (a[i]+1));\n        }\n        out.println();\n        f.close();\n        out.close();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n    \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    FastReader sc = new FastReader();\n\t    int n = sc.nextInt(), p[] = new int[n+1], i, root = -1, c = 0, seen[] = new int[n+1];\n\t\t\n\t\tfor (i=1; i<n+1; i++)\n\t\t\tp[i] = sc.nextInt();\n\t\t\n\t\tfor(i=1; i<n+1; i++)\n\t\t\tif(p[i] == i){\n\t\t\t\tseen[i] = n+1;\n\t\t\t\troot = i;\n\t\t\t\tbreak;\t\t\t\t\n\t\t\t}\n\t\t\n\t\tfor (i=1; i<n+1; i++){\n\t\t\t\n\t\t\tif(seen[i] != 0) continue;\n\t\t\tseen[i] = i;\n\t\t\tint at = i;\n\t\t\t\n\t\t\twhile(seen[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(seen[p[at]] == i){\n\t\t\t\tc++;\n\t\t\t\tif(root != -1)\n\t\t\t\t\tp[at] = root;\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(c);\n\t\tfor(i =1; i <= n; i++)\n\t\t\tSystem.out.print(p[i] + \" \");\n\t    \n\t    \n\t    \n\t}\n}\n\n\nclass FastReader {\n \n    BufferedReader bf;\n    StringTokenizer st;\n \n    public FastReader() {\n        bf = new BufferedReader(new InputStreamReader(System.in));\n    }\n \n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(bf.readLine());\n            } catch (Exception e) {\n                System.out.println(e);\n            }\n        }\n        return st.nextToken();\n    }\n \n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    long nextLong() {\n        return Long.parseLong(next());\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n    String nextLine() {\n        String str = \"\";\n        try {\n            str = bf.readLine();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n        return str;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            MiscUtils.decreaseByOne(a);\n            int root = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == i) {\n                    root = i;\n                    break;\n                }\n            }\n            if (root == -1) {\n                boolean[] was = new boolean[n];\n                int current = 0;\n                while (!was[current]) {\n                    was[current] = true;\n                    current = a[current];\n                }\n                root = current;\n            }\n            int answer = 0;\n            if (a[root] != root) {\n                a[root] = root;\n                answer++;\n            }\n            int[] was = new int[n];\n            was[root] = 2;\n            for (int i = 0; i < n; i++) {\n                if (was[i] != 0) {\n                    continue;\n                }\n                int current = i;\n                while (was[current] == 0) {\n                    was[current] = 1;\n                    current = a[current];\n                }\n                boolean change = false;\n                int at = -1;\n                if (was[current] == 1) {\n                    change = true;\n                    at = current;\n                }\n                current = i;\n                while (was[current] == 1) {\n                    was[current] = 2;\n                    current = a[current];\n                }\n                if (change) {\n                    a[at] = root;\n                    answer++;\n                }\n            }\n            out.printLine(answer);\n            for (int i = 0; i < n; i++) {\n                a[i]++;\n            }\n            out.printLine(a);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class disjoint2 {\n    static PrintWriter out;\n    static BufferedReader in;\n    static StringTokenizer st;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        //out = new PrintWriter(\"test.out\");\n        //in = new BufferedReader(new FileReader(\"test.in\"));\n        out = new PrintWriter(System.out);\n        in = new BufferedReader(new InputStreamReader(System.in));\n        new disjoint2().Run();\n        out.close();\n    }\n\n    String ns() {\n        try {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    int nextint() {\n        return Integer.valueOf(ns());\n    }\n\n\n    int nodesCount = nextint();\n    int[] to = new int[nodesCount];\n    int[] parentNodes = new int[nodesCount];\n\n    private int findSet(int x) {\n        if (parentNodes[x] == x) {\n            return x;\n        } else {\n            return parentNodes[x] = findSet(parentNodes[x]);\n        }\n    }\n\n    private boolean isSameSet(int x, int y)\n    {\n        return findSet(x) == findSet(y);\n    }\n\n    private boolean union(int x, int y) {\n        x = findSet(x);\n        y = findSet(y);\n\n        if (x == y) {\n            return false;\n        }\n        parentNodes[x] = y;\n        return true;\n\n    }\n\n    ArrayList<Integer> circle = new ArrayList<>();\n    ArrayList<Integer> parent = new ArrayList<>();\n    public void Run() {\n\n        for (int i = 0; i < nodesCount; i++) {\n            to[i] = nextint() - 1;\n            parentNodes[i] = i;\n        }\n\n        for (int i = 0; i < nodesCount; i++) {\n            if (isSameSet(to[i],i))\n                circle.add(i);\n        }\n\n        for (int i = 0; i < nodesCount; i++) {\n            if (!union(to[i], i)) {\n                parent.add(i);\n            }\n        }\n        int [] to2 = to.clone();\n        int last;\n        if (circle.size() == 0) last = parent.get(0);\n        else last = circle.get(0);\n        for(int i: circle)\n        {\n            if (to[i] != last)\n                to[i] = last;\n        }\n\n        for (int i: parent)\n        {\n            if (to[i] !=last)\n                to[i] = last;\n        }\n        int count = 0;\n        for (int i = 0; i < to.length; i++) {\n\n            if (to[i] != to2[i]) {\n                count++;\n            }\n             if (i ==  to.length - 1) out.println(count);\n        }\n\n        for (int i = 0; i < nodesCount; i++) {\n            out.print(to[i] + 1 + \" \");\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int[] a = sc.nextIntArray(n);\n        int root = -1;\n        for (int i = 0; i < n; i++)\n            if (--a[i] == i) root = i;\n        int ans = 0;\n        DSU dsu = new DSU(n);\n        for (int i = 0; i < n; i++) {\n            if (i == root) continue;\n            boolean cycle = dsu.union(i, a[i]);\n            if (cycle) {\n                ans++;\n                if (root == -1)\n                    root = i;\n                a[i] = root;\n                dsu.union(root, i);\n            }\n        }\n        out.println(ans);\n        for (int x : a)\n            out.print(x + 1 + \" \");\n        out.close();\n        out.flush();\n\n    }\n\n    static class DSU {\n        int n;\n        int[] size, p;\n\n        public DSU(int n) {\n            this.n = n;\n            size = new int[n];\n            p = new int[n];\n            for (int i = 0; i < n; i++) {\n                size[i] = 1;\n                p[i] = i;\n            }\n        }\n\n        int findParent(int x) {\n            if (p[x] == x) return x;\n            return p[x] = findParent(p[x]);\n        }\n\n        boolean union(int x, int y) {\n            x = findParent(x);\n            y = findParent(y);\n            if (x == y) return true;\n            if (size[x] > size[y]) {\n                size[x] += size[y];\n                p[y] = x;\n            } else {\n                size[y] += size[x];\n                p[x] = y;\n            }\n            return false;\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Wolfgang Beyer\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] p = in.readIntArray(n);\n\n            boolean[] visited = new boolean[n];\n            //boolean[] visitedCurrently = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                visited[i] = false;\n                //visitedCurrently[i] = false;\n                p[i]--;\n            }\n\n            int result = 0;\n            int root = -1;\n            int i = 0;\n            while ((i < n) && (p[i] != i)) i++;\n            if (i < n) root = i;\n        /*else {\n            int current = 0;\n            visitedCurrently[current] = true;\n            while (!visitedCurrently[p[current]]) current = p[current];\n            root = current;\n            result++;\n            p[root] = root;\n        }*/\n            //System.out.println(\"root: \" + root);\n\n            //for (i = 0; i < n; i++) visitedCurrently[i] = false;\n\n            for (i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    visited[i] = true;\n                    //visitedCurrently[i] = true;\n                    HashSet<Integer> hSet = new HashSet<Integer>();\n                    hSet.add(i);\n                    int current = i;\n                    while (!visited[p[current]]) {\n                        current = p[current];\n                        visited[current] = true;\n                        //visitedCurrently[current] = true;\n                        hSet.add(current);\n                    }\n                    //if ((p[current] != root) && (visitedCurrently[p[current]])) {\n                    if ((p[current] != root) && (hSet.contains(p[current]))) {\n                        if (root == -1) {\n                            root = current;\n                        }\n                        result++;\n                        p[current] = root;\n                    }\n                    //for (int j = 0; j < n; j++) visitedCurrently[j] = false;\n                /*current = i;\n                while (visitedCurrently[current]) {\n                    visitedCurrently[current] = false;\n                    current = p[current];\n                }*/\n                }\n            }\n            //System.out.println(\"root: \" + root);\n\n\n            out.println(result);\n            for (i = 0; i < n; i++) out.print((p[i] + 1) + \" \");\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = nextInt();\n            }\n            return ar;\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "/*\n * \n * CREATED BY : NAITIK V\n * \n *     JAI HIND\n * \n */\n\nimport java.util.*;\nimport java.io.*;\npublic class A\t\t\n{ \n\t\t\t static FastReader sc=new FastReader(); \n\t\t\t static long dp[][];\n\t\t\t static int mod=1000000007;\n\t\t     public static void main(String[] args)\n\t\t    {\n\t\t\t  PrintWriter out=new PrintWriter(System.out);\n\t\t\t  StringBuffer sb=new StringBuffer(\"\");\n\t\t\t \n\t\t  int ttt=1;\n\t\t //  ttt =i();\n\t\t    outer :while (ttt-- > 0) \n\t\t\t{\n\t\t    \tint n=i();\n\t\t    \tint B[]=input(n);\n\t\t    \tint C[]=new int[n];\n\t\t    \tfor(int i=0;i<n;i++)\n\t\t    \t\tC[i]=B[i];\n\t\t    \tArrayList<Integer> A[]=new ArrayList[n+1];\n\t        \tfor(int i=0;i<A.length;i++) {\n\t        \t\tA[i]=new ArrayList<Integer>();\n\t        \t}\n\t        \tArrayList<ArrayList<Integer>> l=new ArrayList<>();\n\t        \t//HashMap<Integer,Integer> set=new HashMap<>();\n\t        \tArrayList<Integer> cou=new ArrayList<Integer>();\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tA[i+1].add(B[i]);\n\t        \t\tif(B[i]!=(i+1))\n\t        \t\tA[B[i]].add(i+1);\n\t        \t\t\n\t        \t}\n\t        \tboolean v[]=new boolean[n+1];\n\t        \tfor(int i=1;i<=n;i++) {\n\t        \t\tcou.clear();\n\t        \t\tif(v[i])\n\t        \t\t\tcontinue;\n\t        \t\tdfs(A, i, v, cou);\n\t        \t\tArrayList<Integer> ll=new ArrayList<Integer>();\n\t        \t\tfor(int k : cou) {\n\t        \t\t\tll.add(k);\n\t        \t\t}\n\t        \t\tl.add(ll);\n\t        \t}\n//\t        \tfor(int i : l.get(0).keySet()) {\n//\t        \t\tSystem.out.print(i+\" \");\n//\t        \t}\n//\t        \tSystem.out.println();\n\t        \tint par=-1;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(B[i]==(i+1)) {\n\t        \t\t\tpar=B[i];\n\t        \t\t\tbreak;\n\t        \t\t}\n\t        \t}\n\t        \tArrays.fill(v, false);\n\t        \tboolean u[]=new boolean[n+1];\n\t        \tif(par==-1) {\n\t        \t\tArrayList<Integer> m=l.get(0);\n\t        \t\tfor(int key : m) {\n\t        \t\t\tint a=B[key-1];\n\t        \t\t\tint b=B[a-1];\n\t        \t\t\tif(key==b) {\n\t        \t\t\t\tpar=a;\n\t        \t\t\t\tB[a-1]=a;\n\t        \t\t\t\tbreak;\n\t        \t\t\t}\n\t        \t\t}\n\t        \t\tif(par==-1) {\n\t        \t\t\tint child=cycle(A, m.get(0), v, -1);\n//\t\t        \t\tint pr=cyclepar(A, m.firstKey(), u, -1);\n//\t\t        \t\tSystem.out.println(child+\" \"+pr);\n\t        \t\t\tpar=child;\n\t        \t\t\tB[child-1]=child;\n\t\t        \t\t\n//\t\t        \t\tfor(int k : m.keySet()) {\n//\t\t        \t\t\tint a=B[k-1];\n//\t\t        \t\t\tint b=B[a-1];\n//\t\t        \t\t\tif((a==child && pr==b) || (a==pr && b==child)) {\n//\t\t        \t\t\t\tpar=k;\n//\t\t        \t\t\t\tB[k-1]=par;\n//\t\t        \t\t\t\tbreak;\n//\t\t        \t\t\t}\n//\t\t        \t\t}\n\t\t        \t\t\n\t        \t\t}\n\t        \t\tout : for(int i=1;i<l.size();i++) {\n\t\t        \t\t m=l.get(i);\n\t\t        \t\t\n\t\t        \t\tfor(int key : m) {\n\t\t        \t\t\tint a=B[key-1];\n\t\t        \t\t\tint b=B[a-1];\n\t\t        \t\t\tif(key==b) {\n\t\t        \t\t\t\tB[a-1]=par;\n\t\t        \t\t\t\tcontinue out;\n\t\t        \t\t\t}\n\t\t        \t\t}\n\t\t        \t\t\n\t\t        \t\tint child=cycle(A, m.get(0), v, -1);\n//\t\t        \t\tint pr=cyclepar(A, m.firstKey(), u, -1);\n//\t\t        \t\tfor(int k : m.keySet()) {\n//\t\t        \t\t\tint a=B[k-1];\n//\t\t        \t\t\tint b=B[a-1];\n//\t\t        \t\t\tif((a==child && pr==b) || (a==pr && b==child)) {\n//\t\t        \t\t\t\tB[k-1]=par;\n//\t\t        \t\t\t\tcontinue out;\n//\t\t        \t\t\t}\n//\t\t        \t\t}\n\t\t        \t\tB[child-1]=par;\n\t\t        \t\t\n\t\t        \t}\n\t        \t}\n\t        \telse {\n\t        \tout : for(int i=0;i<l.size();i++) {\n\t        \t\tArrayList<Integer> m=l.get(i);\n\t        \t\t\n\t        \t\tfor(int key : m) {\n\t        \t\t\tint a=B[key-1];\n\t        \t\t\tint b=B[a-1];\n\t        \t\t\tif(key==b) {\n\t        \t\t\t\tB[a-1]=par;\n\t        \t\t\t\tcontinue out;\n\t        \t\t\t}\n\t        \t\t}\n\t        \t\t\n\t        \t\tint child=cycle(A, m.get(0), v, -1);\n//\t        \t\tint pr=cyclepar(A, m.firstKey(), u, -1);\n//\t        \t\tfor(int k : m.keySet()) {\n//\t        \t\t\tint a=B[k-1];\n//\t        \t\t\tint b=B[a-1];\n//\t        \t\t\tif((a==child && pr==b) || (a==pr && b==child)) {\n//\t        \t\t\t\tB[k-1]=par;\n//\t        \t\t\t\tcontinue out;\n//\t        \t\t\t}\n//\t        \t\t}\n\t        \t\tB[child-1]=par;\n\t        \t\t\n\t        \t}\n\t        \t}\n\t        \tint ans=0;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(B[i]!=C[i]) {\n\t        \t\t\tans++;\n\t        \t\t}\n\t        \t}\n\t        \tSystem.out.println(ans);\n\t        \tfor(int i : B) {\n\t        \t\tout.print(i+\" \");\n\t        \t}\n\t\t    \t\n\t\t\t}\n\t\t   out.close();\n\t\t  // System.out.println(sb.toString());\n\t\t   \n\t\t   \n\t\t   //CHECK FOR N=1                    //CHECK FOR M=0\n\t\t    //CHECK FOR N=1                    //CHECK FOR M=0\n\t\t   \t//CHECK FOR N=1\n\t\t   \t//CHECK FOR N=1\n\t\t   \t//CHECK FOR N=1\n    }\n\t\t\t  \n\t\t     \n\t\t    \n\n\t\t\t  \n\t\t\t  private static void dfs(ArrayList<Integer>[] A, int i, boolean[] v,ArrayList<Integer> l) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t  v[i]=true;\n\t\t\t\t l.add(i);\n\t\t\t\t  for(int child : A[i]) {\n\t\t\t\t\t  if(!v[child]) {\n\t\t\t\t\t\t  dfs(A, child, v,l);\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t}\n\n\t\t\t  private static int cycle(ArrayList<Integer>[] A, int i, boolean[] v, int par) {\n\t\t\t\t\t\n\t\t\t\t\tv[i]=true;\n\t\t\t\t\t//System.out.println(i);\n\t\t\t\t\tfor(int child : A[i]) {\n\t\t\t\t\t\tif(!v[child]) {\n\t\t\t\t\t\t\tint res=cycle(A, child, v, i);\n\t\t\t\t\t\t\tif(res!=-1)\n\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(child !=par && par!=-1) {\n\t\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t  private static int cyclepar(ArrayList<Integer>[] A, int i, boolean[] v, int par) {\n\t\t\t\t\t\n\t\t\t\t\tv[i]=true;\n\t\t\t\t\tfor(int child : A[i]) {\n\t\t\t\t\t\tif(!v[child]) {\n\t\t\t\t\t\t\tint res=cyclepar(A, child, v, i);\n\t\t\t\t\t\t\tif(res!=-1)\n\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(child !=par && par!=-1) {\n\t\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t     \n\t\t     \n\t\t     \n\t\t     \n\t\t     \n\t\t     \n\t\t     \n\t\t     \n  static class Pair implements Comparable<Pair>\n   {\n\t   int x;\n\t   int y;\n\t  \t Pair(int x,int y){\n\t  \t\t this.x=x;\n\t  \t\t this.y=y;\n\t  \t }\n\t@Override\n//\tpublic int compareTo(Pair o) {\n//\t\tif(this.x>o.x)\n//\t\t\treturn 1;\n//\t\telse if(this.x<o.x)\n//\t\t\treturn -1;\n//\t\telse {\n//\t\t\tif(this.y<o.y)\n//\t\t\t\treturn 1;\n//\t\t\telse if(this.y>o.y)\n//\t\t\t\treturn -1;\n//\t\t\telse\n//\t\t\t\treturn 0;\n//\t\t}\n//\t}\n\t\n\t\n\tpublic int compareTo(Pair o) {\n\t\t\tif (x > o.x) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (x < o.x) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (y > o.y) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (y < o.y) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n }\nstatic int[] input(int n) {\n  \tint A[]=new int[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t   }\n  \t   return A;\n     }\n  static long[] inputL(int n) {\n  \tlong A[]=new long[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextLong();\n  \t   }\n  \t   return A;\n     }\n  static String[] inputS(int n) {\n  \tString A[]=new String[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.next();\n  \t   }\n  \t   return A;\n     }\n  static long sum(int A[]) {\n  \tlong sum=0;\n  \tfor(int i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n  static long sum(long A[]) {\n  \tlong sum=0;\n  \tfor(long i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n\n  static void input(int A[],int B[]) {\n  \t   for(int i=0;i<A.length;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t\t   B[i]=sc.nextInt();\n  \t   }\n  }\n  static int[][] input(int n,int m){\n  \tint A[][]=new int[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=i();\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static char[][] charinput(int n,int m){\n  \tchar A[][]=new char[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tString s=s();\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=s.charAt(j);\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static int max(int A[]) {\n  \tint max=Integer.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static int min(int A[]) {\n  \tint min=Integer.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long max(long A[]) {\n  \tlong max=Long.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static long min(long A[]) {\n  \tlong min=Long.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long mod(long x) {\n  \t int mod=1000000007;\n  \t  return ((x%mod + mod)%mod);\n  }\n  static String reverse(String s) {\n  \tStringBuffer p=new StringBuffer(s);\n  \tp.reverse();\n  \treturn p.toString();\n  }\n\n       static int i() {\n      \t return sc.nextInt();\n       }\n       static String s() {\n      \t return sc.next();\n       }\n       static long l() {\n      \t return sc.nextLong();\n       }  \n       static void sort(int[] A){\n          int n = A.length;\n          Random rnd = new Random();\n          for(int i=0; i<n; ++i){\n              int tmp = A[i];\n              int randomPos = i + rnd.nextInt(n-i);\n              A[i] = A[randomPos];\n              A[randomPos] = tmp;\n          }\n          Arrays.sort(A);\n       }\n       static void sort(long[] A){\n  \t        int n = A.length;\n  \t        Random rnd = new Random();\n  \t        for(int i=0; i<n; ++i){\n  \t            long tmp = A[i];\n  \t            int randomPos = i + rnd.nextInt(n-i);\n  \t            A[i] = A[randomPos];\n  \t            A[randomPos] = tmp;\n  \t        }\n  \t        Arrays.sort(A);\n  \t     }\n    static String sort(String s) {\n   \t Character ch[]=new Character[s.length()];\n   \t for(int i=0;i<s.length();i++) {\n   \t\t ch[i]=s.charAt(i);\n   \t }\n   \t Arrays.sort(ch);\n   \t StringBuffer st=new StringBuffer(\"\");\n for(int i=0;i<s.length();i++) {\n\t st.append(ch[i]);\n }\n return st.toString();\n}\nstatic HashMap<Integer,Integer> hash(int A[]){\n  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic HashMap<Long,Integer> hash(long A[]){\n\t  HashMap<Long,Integer> map=new HashMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\nstatic TreeMap<Integer,Integer> tree(int A[]){\n  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic TreeMap<Long,Integer> tree(long A[]){\n\t  TreeMap<Long,Integer> map=new TreeMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\nstatic void primefact(int n) {\n\t  for(int i=2;i*i<=n;i++) {\n\t\t  if(n%i==0) {\n\t\t\t  int cnt=0;\n\t\t\t  while(n%i==0) {\n\t\t\t\t  cnt++;\n\t\t\t\t  n/=i;\n\t\t\t  }\n\t\t\t  System.out.println(i+\"^\"+cnt);\n\t\t\t  \n\t\t  }\n\t  }\n\t  if(n>1) {\n\t\t  System.out.println(n+\"^ 1\");\n\t  }\n}\n   static boolean prime(int n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static boolean prime(long n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static long power(long x, long y, long p)\n   {\n\n       long res = 1;\n       x = x % p;\n\n       while (y > 0) {\n\n           if (y % 2 == 1)\n               res = (res * x) % p;\n\n           y = y >> 1; \n           x = (x * x) % p;\n       }\n\n       return res;\n   }\n\n   static long modInverse(long n, long p)\n   {\n       return power(n, p - 2, p);\n   }\n   static int gcd(int a, int b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n   static long gcd(long a, long b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n  \n      \n  static class FastReader \n  { \n      BufferedReader br; \n      StringTokenizer st; \n\n      public FastReader() \n      { \n          br = new BufferedReader(new\n                   InputStreamReader(System.in)); \n      } \n\n      String next() \n      { \n          while (st == null || !st.hasMoreElements()) \n          { \n              try\n              { \n                  st = new StringTokenizer(br.readLine()); \n              } \n              catch (IOException  e) \n              { \n                  e.printStackTrace(); \n              } \n          } \n          return st.nextToken(); \n      } \n\n      int nextInt() \n      { \n          return Integer.parseInt(next()); \n      } \n\n      long nextLong() \n      { \n          return Long.parseLong(next()); \n      } \n\n      double nextDouble() \n      { \n          return Double.parseDouble(next()); \n      } \n\n      String nextLine() \n      { \n          String str = \"\"; \n              try\n              { \n                  str = br.readLine(); \n              } \n              catch (IOException e) \n              { \n                  e.printStackTrace(); \n              } \n              return str; \n          } \n      } \n  } \n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*; import java.io.*; import java.math.*;\npublic class Main{\n\tstatic void solve(){//Here is the main function\n      int N = nextInt();\n      Node[] list = new Node[N];\n      UnionFind uf = new UnionFind(N);\n      for(int i = 0; i < N; i++){\n        list[i] = new Node(i);\n      }\n      int count = 0;\n      ArrayList<Integer> root = new ArrayList<>();\n      for(int i = 0; i < N; i++){\n        int p = nextInt() - 1;\n        if(i != p && uf.isSame(p, i)){\n          list[i].parent = i;\n        }else{\n          uf.doUnion(i, p);\n          list[i].parent = p;\n          if(i == p){\n            root.add(i);\n          }\n        }\n      }\n      int r = -1;\n      if(root.size() > 0){\n        r = root.get(0);\n      }\n      for(int i = 0; i < N; i++){\n        if(list[i].parent == i){\n          if(r == -1){\n            r = i;\n            count++;\n          }else{\n            if(r != i){\n              list[i].parent = r;\n              count++;\n            }\n          }\n        }\n      }\n      myout(count);\n      String[] output = new String[N];\n      for(int i = 0; i < N; i++){\n        output[i] = String.valueOf(list[i].parent + 1);\n      }\n      myout(myconv(output, 8));\n\t}\n\t//Method addition frame start\n\nstatic class Node{\n  int no;\n  int parent = -1;\n  Node(int no){\n    this.no = no;\n  }\n}\n\nstatic class UnionFind{\n        int[] list;\n        int group;\n        UnionFind(int size){\n                list = new int[size];\n                Arrays.fill(list, -1);\n                group = size;\n        }\n        boolean isSame(int L, int R){\n                return getRootIndex(L) == getRootIndex(R);\n        }\n        int getRootIndex(int index){\n                if(list[index] < 0){\n                        return index;\n                }else{\n                        list[index] = getRootIndex(list[index]);\n                        return list[index];\n                }\n        }\n        void doUnion(int L, int R){\n                int Lroot = getRootIndex(L);\n                int Rroot = getRootIndex(R);\n                if(Lroot != Rroot){\n                        group--;\n                        if(getSize(Lroot) >= getSize(Rroot)){\n                                int tmp = Lroot;\n                                Lroot = Rroot;\n                                Rroot = tmp;\n                        }\n                        list[Lroot] += list[Rroot];\n                        list[Rroot] = Lroot;\n                }\n        }\n        int getSize(int index){\n                return -list[getRootIndex(index)];\n        }\n        int getGroupCount(){\n                return group;\n        }\n        boolean isRoot(int index){\n                return getRootIndex(index) == index;\n        }\n}\n  \n\t//Method addition frame end\n\n\t//Don't have to see. start------------------------------------------\n\tstatic class InputIterator{\n\t\tArrayList<String> inputLine = new ArrayList<>(1024);\n\t\tint index = 0; int max; String read;\n\t\tInputIterator(){\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttry{\n\t\t\t\twhile((read = br.readLine()) != null){\n\t\t\t\t\tinputLine.addAll(Arrays.asList(read.split(\" \")));\n\t\t\t\t}\n\t\t\t}catch(IOException e){}\n\t\t\tmax = inputLine.size();\n\t\t}\n\t\tboolean hasNext(){return (index < max);}\n\t\tString next(){\n\t\t\tif(hasNext()){\n\t\t\t\treturn inputLine.get(index++);\n\t\t\t}else{\n\t\t\t\tthrow new IndexOutOfBoundsException(\"There is no more input\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic HashMap<Integer, String> CONVSTR = new HashMap<>();\n\tstatic InputIterator ii = new InputIterator();//This class cannot be used in reactive problem.\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic void flush(){out.flush();}\n\tstatic void myout(Object t){out.println(t);}\n\tstatic void myerr(Object t){System.err.print(\"debug:\");System.err.println(t);}\n\tstatic String next(){return ii.next();}\n\tstatic boolean hasNext(){return ii.hasNext();}\n\tstatic int nextInt(){return Integer.parseInt(next());}\n\tstatic long nextLong(){return Long.parseLong(next());}\n\tstatic double nextDouble(){return Double.parseDouble(next());}\n\tstatic ArrayList<String> nextCharArray(){return myconv(next(), 0);}\n\tstatic ArrayList<String> nextStrArray(int size){\n\t\tArrayList<String> ret = new ArrayList<>(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tret.add(next());\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic ArrayList<Integer> nextIntArray(int size){\n\t\tArrayList<Integer> ret = new ArrayList<>(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tret.add(Integer.parseInt(next()));\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic ArrayList<Long> nextLongArray(int size){\n\t\tArrayList<Long> ret = new ArrayList<>(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tret.add(Long.parseLong(next()));\n\t\t}\n\t\treturn ret;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic String myconv(Object list, int no){//only join\n\t\tString joinString = CONVSTR.get(no);\n\t\tif(list instanceof String[]){\n\t\t\treturn String.join(joinString, (String[])list);\n\t\t}else if(list instanceof ArrayList){\n\t\t\treturn String.join(joinString, (ArrayList)list);\n\t\t}else{\n\t\t\tthrow new ClassCastException(\"Don't join\");\n\t\t}\n\t}\n\tstatic ArrayList<String> myconv(String str, int no){//only split\n\t\tString splitString = CONVSTR.get(no);\n\t\treturn new ArrayList<String>(Arrays.asList(str.split(splitString)));\n\t}\n\tpublic static void main(String[] args){\n\t\tCONVSTR.put(8, \" \"); CONVSTR.put(9, \"\\n\"); CONVSTR.put(0, \"\");\n\t\tsolve();flush();\n\t}\n\t//Don't have to see. end------------------------------------------\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> e[200005];\nint n;\nint a[200005];\nint on[200005];\nint fa[200005];\nint ans;\nint gf(int x) {\n  if (x == fa[x])\n    return x;\n  else {\n    return fa[x] = gf(fa[x]);\n  }\n}\nint main() {\n  cin >> n;\n  int r = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (a[i] == i) {\n      r = i;\n    }\n    fa[i] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    int u = gf(i);\n    int v = gf(a[i]);\n    if (u == v) {\n      if (r == 0) r = i;\n      on[i] = 1;\n    } else {\n      fa[u] = v;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (on[i] && a[i] != r) {\n      ans++;\n      a[i] = r;\n    }\n  }\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << a[i] << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.io.*;\nimport java.math.*;\nimport java.text.DecimalFormat;\npublic class Rough{     \n    static class InputReader { \n        private final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \tpublic InputReader(InputStream st) {\n            this.stream = st;\n\t} \n\tpublic int read() {\n            if (snumChars == -1)\n\t \tthrow new InputMismatchException();\n            if (curChar >= snumChars) {\n\t\tcurChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n\t\t} \n                catch (IOException e) {\n                    throw new InputMismatchException();\n           \t}\n\t\tif (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n\t}\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n               \tc = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n\t\tsgn = -1;\n\t\tc = read();\n            }\n            int res = 0;\n            do {\n\t\tres *= 10;\n\t\tres += c - '0';\n\t\tc = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n\t\ta[i] = ni();\n            }\n            return a;\n\t} \n\tpublic String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n\t\tc = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n\t\tres.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n\t}\n\tpublic String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n\t\tc = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n\tpublic boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n\t} \n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static boolean f,v[];\n    static int p[],root=-1;\n    \n    \n    \n    \n    static void isCycle(int i,Set<Integer> g){\n        if(i==p[i]||v[i]){\n            v[i]=true;\n            return;\n        }\n        if(g.contains(p[i])){\n            if(root==-1){\n                root=i;\n                p[i]=i;\n            }\n            else{\n                p[i]=root;\n            }\n            v[i]=true;\n            return;\n        }\n        g.add(i);\n        v[i]=true;\n        isCycle(p[i],g);\n    }\n    public static void main(String[] args) throws IOException {   \n        InputReader sc=new InputReader(System.in);\n        int n=sc.ni();\n        \n        p=new int[n+1];\n        \n        int t[]=new int[n+1];\n        v=new boolean[n+1];\n        \n        for(int i=1;i<=n;i++){\n            \n            int a=sc.ni();\n            t[i]=a;\n            p[i]=a;\n            \n        }\n        for(int i=1;i<=n;i++){\n            if(i==p[i]){\n                root=i;\n                break;\n            }\n        }\n        \n        for(int i=1;i<=n;i++){\n            if(!v[i]){\n                isCycle(i,new HashSet<Integer>() );\n            }\n        }\n        Set<Integer> g=new HashSet<Integer>();\n        Arrays.fill(v,false);\n        for(int i=1;i<=n;i++){\n            int j=i;\n            if(!v[j]){\n                while(j!=p[j]&&!v[j]){\n                    v[j]=true;\n                    j=p[j];\n                }\n                if(!v[j]){\n                    g.add(j);\n                    v[j]=true;\n                }\n                \n            }\n        }\n        Iterator itr=g.iterator();\n        //int root=-1;\n        while(itr.hasNext()){\n            int a=(int)itr.next();\n            if(root==-1){\n                root=a;\n            }\n            else p[a]=root;\n        }\n        int co=0;\n        for(int i=1;i<=n;i++){\n            if(t[i]!=p[i])\n                co++;\n        }\n        w.println(co);\n        for(int i=1;i<=n;i++){\n            w.print(p[i]+\" \");\n        }\n        w.println();\n        w.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.TreeMap;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Alex\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskB {\n        int[] a;\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            a = IOUtils.readIntArray(in, n);\n            MiscUtils.decreaseByOne(a);\n            RecursiveIndependentSetSystem iss = new RecursiveIndependentSetSystem(n);\n            for (int i = 0; i < a.length; i++) iss.join(i, a[i]);\n            TreeMap<Integer, Group> tm = new TreeMap<>();\n            for (int i = 0; i < a.length; i++) {\n                int g = iss.get(i);\n                if (!tm.containsKey(g)) tm.put(g, new Group());\n                tm.get(g).nodes.add(i);\n            }\n            for (Group g : tm.values()) {\n                g.run();\n            }\n            ArrayList<Group> grouparr = new ArrayList<>();\n            for (Group g : tm.values()) {\n                grouparr.add(g);\n            }\n            Group bestgroup = Collections.min(grouparr, Comparator.comparing((Group g) -> g.changed.size()));\n            int changeto = bestgroup.changer;\n            int res = 0;\n            for (Group g : grouparr) {\n                boolean chang = false;\n                for (int val : g.changed) {\n                    a[val] = changeto;\n                    res++;\n                    chang = true;\n                }\n                if (!chang && g != bestgroup) {\n                    a[g.changer] = changeto;\n                    res++;\n                }\n            }\n            out.printLine(res);\n            for (int i = 0; i < a.length; i++) a[i]++;\n            out.printLine(a);\n        }\n        class Group {\n            ArrayList<Integer> nodes = new ArrayList<>();\n            HashSet<Integer> changed = new HashSet<>();\n            HashMap<Integer, Integer> visited = new HashMap<>();\n            int good = 0;\n            int changer = -1;\n            void run() {\n                int iii = 1;\n                for (int val : nodes) {\n                    dfs(val, iii++);\n                }\n                if (changed.size() > 1) throw new RuntimeException();\n                good = visited.size() - changed.size();\n                int ccc = 0;\n                for (int val : nodes) {\n                    if (val == a[val]) {\n                        changer = val;\n                        ccc++;\n                    }\n                    if (changed.contains(val)) {\n                        changer = val;\n                        ccc++;\n                    }\n                    if (ccc > 1) throw new RuntimeException();\n                }\n            }\n            void dfs(int cur, int counter) {\n                if (a[cur] == cur) return;\n                if (visited.containsKey(cur) && visited.get(cur) != counter) return;\n                visited.put(cur, counter);\n                int nxt = a[cur];\n                if (visited.containsKey(nxt) && visited.get(nxt) == counter) {\n                    changed.add(cur);\n                } else {\n                    dfs(nxt, counter);\n                }\n            }\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++)\n                    array[i]--;\n            }\n        }\n    }\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = in.readInt();\n            return array;\n        }\n    }\n    static class RecursiveIndependentSetSystem implements IndependentSetSystem {\n        private final int[] color;\n        private final int[] rank;\n        private int setCount;\n        private IndependentSetSystem.Listener listener;\n        public RecursiveIndependentSetSystem(int size) {\n            color = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                color[i] = i;\n            }\n            setCount = size;\n        }\n        public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n            color = other.color.clone();\n            rank = other.rank.clone();\n            setCount = other.setCount;\n        }\n        public boolean join(int first, int second) {\n            first = get(first);\n            second = get(second);\n            if (first == second) {\n                return false;\n            }\n            if (rank[first] < rank[second]) {\n                int temp = first;\n                first = second;\n                second = temp;\n            } else if (rank[first] == rank[second]) {\n                rank[first]++;\n            }\n            setCount--;\n            color[second] = first;\n            if (listener != null) {\n                listener.joined(second, first);\n            }\n            return true;\n        }\n        public int get(int index) {\n            int start = index;\n            while (color[index] != index) {\n                index = color[index];\n            }\n            while (start != index) {\n                int next = color[start];\n                color[start] = index;\n                start = next;\n            }\n            return index;\n        }\n    }\n    static interface IndependentSetSystem {\n        public static interface Listener {\n            public void joined(int joinedRoot, int root);\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(array[i]);\n            }\n        }\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n        public void close() {\n            writer.close();\n        }\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.io.UncheckedIOException;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.Optional;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            BFixATree solver = new BFixATree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class BFixATree {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n            for (int i = 0; i < n; i++) {\n                nodes[i].p = nodes[in.readInt() - 1];\n            }\n\n            Set<Node> set = new HashSet<>();\n            for (Node node : nodes) {\n                set.add(findCircle(node));\n            }\n\n\n            int ans = 0;\n            Node root = null;\n            for (Node node : set) {\n                if (node.p == node) {\n                    root = node;\n                    set.remove(root);\n                    break;\n                }\n            }\n\n            if (root == null) {\n                ans++;\n                root = set.stream().findFirst().get();\n                set.remove(root);\n                root.p = root;\n            }\n\n            for (Node node : set) {\n                ans++;\n                node.p = root;\n            }\n\n            out.println(ans);\n            for (Node node : nodes) {\n                out.append(node.p.id + 1).append(' ');\n            }\n\n        }\n\n        public Node findCircle(Node root) {\n            if (root.visited) {\n                if (root.instk) {\n                    return root;\n                }\n                return root.circle;\n            }\n            root.visited = true;\n            root.instk = true;\n            root.circle = findCircle(root.p);\n            root.instk = false;\n            return root.circle;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        Node p;\n        int id;\n        boolean visited;\n        boolean instk;\n        Node circle;\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author praveen123\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n                a[i]--;\n            }\n            Graph graph = new Graph(n);\n            for (int i = 0; i < n; i++) {\n                graph.addEdge(i, a[i]);\n                graph.addEdge(a[i], i);\n            }\n            int ans = graph.countComponents() - 1;\n            boolean[] visited = new boolean[n];\n            List<Integer> verts = graph.collectVerticesFromDistinctComponents();\n            List<Integer> goodVerts = new ArrayList<>();\n            for (int x : verts) {\n                int cur = x;\n                while (!visited[cur]) {\n                    visited[cur] = true;\n                    cur = a[cur];\n                }\n                goodVerts.add(cur);\n            }\n            boolean found = false;\n            for (int i = 0; i < goodVerts.size(); i++) {\n                if (a[goodVerts.get(i)] == goodVerts.get(i)) {\n                    found = true;\n                    int temp = goodVerts.get(i);\n                    goodVerts.set(i, goodVerts.get(goodVerts.size() - 1));\n                    goodVerts.set(goodVerts.size() - 1, temp);\n                    break;\n                }\n            }\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                b[i] = a[i];\n            }\n            for (int i = 0; i + 1 < goodVerts.size(); i++) {\n                b[goodVerts.get(i)] = goodVerts.get(i + 1);\n            }\n            if (!found) {\n                ans++;\n            }\n            b[goodVerts.get(goodVerts.size() - 1)] = goodVerts.get(goodVerts.size() - 1);\n            System.out.println(ans);\n            for (int i = 0; i < n; i++) {\n                System.out.print(b[i] + 1);\n                if (i + 1 < n) {\n                    System.out.print(\" \");\n                }\n            }\n            System.out.println();\n        /*\n        DirectedGraph newGraph = new DirectedGraph(n);\n        int root = 0;\n        for (int i = 0; i < n; i++) {\n            newGraph.addEdge(b[i], i);\n            if (b[i] == i) {\n                root = i;\n            }\n        }\n        newGraph.dfs(root);\n        if (!newGraph.checkAllVisited()) {\n            throw new RuntimeException(\"Bad stuff\");\n        }\n        */\n        }\n\n        class Graph {\n            List<List<Integer>> g;\n            int[] visited;\n            int n;\n            int comp = 1;\n\n            Graph() {\n\n            }\n\n            Graph(int n) {\n                this.n = n;\n                g = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    g.add(new ArrayList<>());\n                }\n                visited = new int[n];\n            }\n\n            void addEdge(int from, int to) {\n                g.get(from).add(to);\n                g.get(to).add(from);\n            }\n\n            int countComponents() {\n                int ans = 0;\n                for (int i = 0; i < n; i++) {\n                    if (visited[i] == 0) {\n                        dfs(i);\n                        ans++;\n                        comp++;\n                    }\n                }\n                return ans;\n            }\n\n            private void dfs(int from) {\n                visited[from] = comp;\n                for (int to : g.get(from)) {\n                    if (visited[to] == 0) {\n                        dfs(to);\n                    }\n                }\n            }\n\n            List<Integer> collectVerticesFromDistinctComponents() {\n                Set<Integer> usedComponents = new HashSet<>();\n                List<Integer> res = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    if (!usedComponents.contains(visited[i])) {\n                        usedComponents.add(visited[i]);\n                        res.add(i);\n                    }\n                }\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic long sx = 0, sy = 0, m = (long) (1e9 + 7);\n\n\tstatic ArrayList<Integer>[] a;\n\tstatic int[][] dp;\n\tstatic long[] farr;\n\t// static boolean b = true;\n\tstatic HashMap<Integer, Integer> hm = new HashMap<>();\n\n\t// static TreeMap<Integer, Integer> hm = new TreeMap<>();\n\tpublic static PrintWriter out;\n\tstatic ArrayList<pair> p = new ArrayList<>();\n\tstatic long[] fact = new long[(int) 1e6];\n\tstatic boolean b = false;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic boolean cycle = false;\n\tstatic long mod = 998244353;\n\tstatic int[] col;\n\t// static HashSet<Integer> p = new HashSet<>();\n\tstatic int cnt;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Scanner scn = new Scanner(System.in);\n\n\t\tReader scn = new Reader();\n\t\tout = new PrintWriter(System.out);\n\n\t\tint n = scn.nextInt();\n\t\tint[] a = new int[n + 1];\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = scn.nextInt();\n\n\t\tint[] c = Arrays.copyOf(a, n + 1);\n\n\t\tdsu d = new dsu(n);\n\n\t\tint cnt = -5; // generic head\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tif (a[i] == i) {\n\n\t\t\t\tif (cnt == -5)\n\t\t\t\t\tcnt = a[i]; // if a component have head it will have no\n\t\t\t\t\t\t\t\t// cycle\n\t\t\t\telse\n\t\t\t\t\ta[i] = -1; // sabhi root ko -1\n\t\t\t}\n\n\t\t\telse if (!d.merge(i, a[i])) { // this component will have no head so\n\t\t\t\t\t\t\t\t\t\t\t// this node at which we got cycle\n\t\t\t\t\t\t\t\t\t\t\t// will be the head\n\t\t\t\ta[i] = -1;\n\t\t\t} // if a component have cycle no head\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tif (a[i] == -1) {\n\n\t\t\t\tif (cnt != -5)\n\t\t\t\t\ta[i] = cnt;\n\n\t\t\t\telse {\n\t\t\t\t\ta[i] = i;\n\t\t\t\t\tcnt = i;          // if all components had cycle then generic head wont be initialise upar\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a[i] != c[i])\n\t\t\t\tans++;\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tSystem.out.print(a[i] + \" \");\n\n\t}\n\n\tprivate static class dsu {\n\n\t\tstatic int[] size;\n\t\tstatic int[] par;\n\n\t\tdsu(int n) {\n\n\t\t\tsize = new int[n + 1];\n\t\t\tpar = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tsize[i] = 1;\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tpublic static boolean merge(int u, int v) {\n\n\t\t\tint p1 = find(u);\n\n\t\t\tint p2 = find(v);\n\n\t\t\tif (p1 == p2)\n\t\t\t\treturn false;\n\n\t\t\tif (size[p1] >= size[p2]) {\n\t\t\t\tsize[p1] += size[p2];\n\t\t\t\tpar[p2] = p1;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tsize[p2] += size[p1];\n\t\t\t\tpar[p1] = par[p2];\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic static int find(int v) {\n\n\t\t\tif (v == par[v])\n\t\t\t\treturn v;\n\n\t\t\tpar[v] = find(par[v]);\n\n\t\t\treturn par[v];\n\t\t}\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\t// private static int gcd(int a, int b) {\n\t// if (a == 0)\n\t// return b;\n\t//\n\t// return gcd(b % a, a);\n\t// }\n\n\t// static class comp implements Comparator<Integer> {\n\t//\n\t// @Override\n\t// public int compare(Integer o1, Integer o2) {\n\t// if (b[o1])\n\t// return -1;\n\t// else if (b[o2])\n\t// return 1;\n\t// else\n\t// return (int) (a[o2].size() - a[o1].size());\n\t// }\n\t//\n\t// }\n\n\t// public static long pow(long a, long b) {\n\t//\n\t// if(b<0)return 0;\n\t// if (b == 0 || b == 1)\n\t// return (long) Math.pow(a, b);\n\t//\n\t// if (b % 2 == 0) {\n\t//\n\t// long ret = pow(a, b / 2);\n\t// ret = (ret % mod * ret % mod) % mod;\n\t// return ret;\n\t// }\n\t//\n\t// else {\n\t// return ((pow(a, b - 1) % mod) * a % mod) % mod;\n\t// }\n\t// }\n\n\tprivate static class pair implements Comparable<pair> {\n\n\t\tint tb, tbw;\n\n\t\tpair() {\n\t\t\ttb = tbw = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tprivate static String reverse(String s) {\n\n\t\treturn new StringBuilder(s).reverse().toString();\n\t}\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[1000000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t// kickstart - Solution\n\t\t// atcoder - Main\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nconst li INF = 1e18;\nconst int M = 1e9 + 7;\nconst int N = 2e5 + 13;\nint p[N];\nvector<int> g[N];\nint ans = 0;\nint used[N];\nint root = -1;\nint dfs1(int v) {\n  if (v == root) {\n    return -1;\n  }\n  used[v] = 1;\n  int u = p[v];\n  int res = -1;\n  if (used[u] == 0) {\n    res = dfs1(u);\n  } else if (used[u] == 1) {\n    res = u;\n  }\n  used[v] = 2;\n  return res;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    if (p[i] == i) {\n      if (root == -1) {\n        root = i;\n      } else {\n        ans++;\n        p[i] = root;\n      }\n    }\n    g[p[i]].push_back(i);\n  }\n  if (root == -1) {\n    root = dfs1(0);\n    p[root] = root;\n    ans++;\n  }\n  for (int i = 0; i < n; i++) {\n    if (used[i] == 0) {\n      int v = dfs1(i);\n      if (v != -1) {\n        ans++;\n        p[v] = root;\n      }\n    }\n  }\n  cout << ans << endl;\n  for (int i = 0; i < n; i++) {\n    cout << p[i] + 1 << ' ';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n/**\n * Date: 18 Nov, 2018\n * Link:\n *\n * @author Prasad-Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class newProgram9 {\n\n    public static void main(String[] args) throws IOException {\n        // TODO code application logic here\n        FastIO in = new FastIO();\n        int n = in.ni();\n        int p[] = in.gia(n);\n        FastUnionFind uf = new FastUnionFind(n);\n        int count = 0;\n        int q[] = new int[n];\n        int root = -1;\n        for (int i = 0; i < n; i++) {\n            if (p[i] == i + 1) {\n                root = i + 1;\n            }\n            if (uf.find(i + 1) != uf.find(p[i])) {\n                uf.union(i + 1, p[i]);\n            } else {\n                q[i] = -1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (q[i] == -1) {\n                if (root == -1) {\n                    root = i + 1;\n                }\n                if (p[i] != root) {\n                    p[i] = root;\n                    count++;\n                }\n            }\n        }\n        System.out.println(count);\n        for (int i : p) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    static class FastUnionFind {\n\n        int noOfComponents, n;\n        private int[] parent, rank;\n\n        public FastUnionFind(int n) {\n            this.n = n;\n            this.noOfComponents = n;\n            parent = new int[n + 1];\n            rank = new int[n + 1];\n            for (int i = 0; i <= n; i++) {\n                parent[i] = i;\n                rank[i] = 1;\n            }\n        }\n\n        public int find(int p) {\n            if (parent[p] == p) {\n                return p;\n            } else {\n                return find(parent[p]);\n            }\n        }\n\n        public void union(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a != b) {\n                if (rank[a] > rank[b]) {\n                    parent[b] = a;\n                } else if (rank[b] > rank[a]) {\n                    parent[a] = b;\n                } else {\n                    parent[b] = a;\n                    rank[a]++;\n                }\n                noOfComponents--;\n            }\n        }\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n        private StringBuilder sb;\n\n        public FastIO() throws IOException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            s = br.readLine().split(\" \");\n            sb = new StringBuilder();\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public int[][] gg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            if (a == o.a) {\n                return Integer.compare(b, o.b);\n            }\n            return Integer.compare(a, o.a);\n        }\n\n        public static void sort(int a[]) {\n            Data d[] = new Data[a.length];\n            for (int i = 0; i < a.length; i++) {\n                d[i] = new Data(a[i], 0);\n            }\n            Arrays.sort(d);\n            for (int i = 0; i < a.length; i++) {\n                a[i] = d[i].a;\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[200005];\nint vis[200005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while (cin >> n) {\n    int cnt = 1;\n    int rt = -1;\n    int num = 0;\n    memset(vis, 0, sizeof(vis));\n    for (int i = (1); i <= (n); i++) {\n      cin >> a[i];\n      if (a[i] == i) rt = i;\n    }\n    for (int i = (1); i <= (n); i++) {\n      int id = i;\n      while (vis[id] == 0) {\n        vis[id] = cnt;\n        if (vis[a[id]] == cnt) {\n          if (a[id] != rt) {\n            a[id] = -1;\n            num++;\n            break;\n          }\n        }\n        id = a[id];\n      }\n      cnt++;\n    }\n    printf(\"%d\\n\", num);\n    for (int i = (1); i <= (n); i++) {\n      if (a[i] == -1 && rt == -1) rt = i;\n      if (a[i] != -1)\n        printf(\"%d \", a[i]);\n      else\n        printf(\"%d \", rt);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n// Sachin_2961 submission //\npublic class CodeforcesA {\n\n    int N = 200005;\n    int[]parent = new int[N];\n    int[]ar = new int[N];\n    public int getParent(int x){\n        if(parent[x]!=x)\n            parent[x] = getParent(parent[x]);\n        return parent[x];\n    }\n    public void add(int i,int p){\n        if(i == p){\n            return;\n        }\n\n    }\n    public void solve() {\n        int n = fs.nInt();\n        int R = -1;\n        for(int i=1;i<=n;i++)parent[i] = i;\n        for(int i=1;i<=n;i++) {\n            ar[i] = fs.nInt();\n            if( R < 0 && ar[i] == i )R = i;\n            int a = getParent(i) , b = getParent(ar[i]);\n            if( a!= b )parent[a] = b;\n        }\n        if( R < 0 ){\n            for(int i=1;i<=n;i++){\n                if(parent[i]==i) {\n                    R = i;\n                    break;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=1;i<=n;i++){\n            if(parent[i]==i&& ar[i]!=R){\n                ar[i] = R;\n                ans++;\n            }\n        }\n        out.println(ans);\n        for(int i=1;i<=n;i++){\n            out.print(ar[i]+\" \");\n        }\n\n    }\n    static boolean multipleTestCase = false; static FastScanner fs; static PrintWriter out;\n    public void run(){\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        int tc = (multipleTestCase)?fs.nInt():1;\n        while (tc-->0)solve();\n        out.flush();\n        out.close();\n    }\n    public static void main(String[]args){\n        try{\n            new CodeforcesA().run();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nlong long int parent[N], connected[N];\nstruct DSU {\n  void intialize(int x) {\n    for (long long int i = 1; i < x; i++) {\n      parent[i] = i;\n      connected[i] = 1;\n    }\n  }\n  long long int getparent(long long int k) {\n    while (k != parent[k]) {\n      parent[k] = parent[parent[k]];\n      k = parent[k];\n    }\n    return k;\n  }\n  long long int getsize(long long int k) { return connected[getparent(k)]; }\n  bool unionn(long long int u, long long int v) {\n    long long int parent1 = getparent(u), parent2 = getparent(v);\n    if (parent1 == parent2) return 0;\n    if (connected[parent1] > connected[parent2]) swap(parent1, parent2);\n    connected[parent2] += connected[parent1];\n    connected[parent1] = 0;\n    parent[parent1] = parent[parent2];\n    return 1;\n  }\n};\nvoid solve() {\n  long long int n;\n  cin >> n;\n  DSU dsu;\n  dsu.intialize(n + 3);\n  long long int root = -1;\n  long long int a[n + 1];\n  for (long long int i = 1; i <= n; i++) cin >> a[i];\n  long long int ans = 0;\n  vector<long long int> v;\n  for (long long int i = 1; i <= n; i++) {\n    if (a[i] == i) root = i;\n  }\n  for (long long int i = 1; i <= n; i++) {\n    bool chk = dsu.unionn(a[i], i);\n    if (!chk) {\n      if (root == -1) root = i;\n      dsu.unionn(i, root);\n      if (a[i] == root) continue;\n      ans++;\n      a[i] = root;\n    }\n  }\n  cout << ans << \"\\n\";\n  for (long long int i = 1; i <= n; i++) cout << a[i] << \" \";\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  srand(time(NULL));\n  ;\n  long long int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\n\n# ver si hay un camino que llega a el a partir\n# de su padre entonces hay un ciclo\n\n\ndef Padre(x, padre):\n    while x != padre[x]:\n        x = padre[x]\n    return x\n\n\ndef DFS(x, color, padre, ciclos, adyacentes, raiz):\n    color[x] = 1  # nodo gris\n    for y in adyacentes[x]:\n        # el adyacente es blanco\n        if color[y] == 0:\n            DFS(y, color, padre, ciclos, adyacentes, raiz)\n            padre[y] = x\n\n        elif color[y] == 2:\n            padre[y] = x\n        # ese adyacente es gris entonces <u,v>  rista de retroceso\n        else:\n            if y == x and not raiz:\n                raiz = x\n            else:\n                ciclos.append([x, y])\n    color[x] = 2  # nodo negro\n\n\ndef Solucion():\n    n = int(input())\n    A = list(map(lambda x: int(x)-1, input().split()))\n\n    padre = [x for x in range(0, n)]\n    ciclosC = 0\n    ciclos = deque([])\n    root = []\n\n    # ir haciendo Merge a cada arista\n    for i in range(0, n):\n\n        p = Padre(A[i], padre)\n        # Si dicha arista perticipa en un ciclo\n        if p == i:\n            # Si es un ciclo del tipo raiz y no hay raiz\n            if not root and (i == A[i]):\n                root = [i, A[i]]\n            else:\n                ciclos.append([i, A[i]])\n                ciclosC += 1\n        # Si no hay ciclo\n        else:\n            padre[i] = A[i]\n\n    print(str(ciclosC))\n    # si existe al menos un ciclo diferente d raiz\n    if ciclosC:\n        i = 0\n        # si no hay raiz el primer ciclo lo hago raiz\n        if not root:\n            root = ciclos.popleft()\n            i = 1\n\n        # los restantes ciclos hago que su padre sea la raiz\n        while ciclos:\n            ciclo = ciclos.popleft()\n            padre[ciclo[0]] = root[0]\n\n    PC = [x + 1 for x in padre]\n    print(*PC, sep=\" \")\n\n\nSolucion()\n\n\n# Casos de prueba:\n# 4\n# 2 3 3 4\n# respuesta\n# 1\n#  2 3 3 3\n\n# 5\n# 3 2 2 5 3\n# respuesta\n# 0\n# 3 2 2 5 3\n\n# 8\n# 2 3 5 4 1 6 6 7\n# respuesta\n# 2\n# 2 3 5 4 1 4 6 7\n\n# 200000\n# hacer con el generador\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic int mod = (int) 1e9 + 7;\n\tstatic String output = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tFasterScanner s = new FasterScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint test = 1;\n\t\ttestloop: while (test-- > 0) {\n\t\t\tint n = s.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = s.nextInt() - 1;\n\t\t\tArrayList<Integer> cycles = new ArrayList<>();\n\t\t\tint[] list = new int[n];\n\t\t\tint count = 0;\n\t\t\tboolean[] done = new boolean[n];\n\t\t\tboolean[] now = new boolean[n];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint i = j;\n\t\t\t\tif (!done[i]) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\twhile (!now[i]) {\n\t\t\t\t\t\tif (done[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tnow[i] = true;\n\t\t\t\t\t\tlist[count++] = i;\n\t\t\t\t\t\ti = a[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (now[i])\n\t\t\t\t\t\tcycles.add(i);\n\t\t\t\t\twhile (count > 0) {\n\t\t\t\t\t\tdone[list[--count]] = true;\n\t\t\t\t\t\tnow[list[count]] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint root = -1;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (i == a[i]) {\n\t\t\t\t\troot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (root == -1) {\n\t\t\t\tout.println(cycles.size());\n\t\t\t\troot = cycles.get(0);\n\t\t\t\ta[root] = root;\n\t\t\t} else\n\t\t\t\tout.println(cycles.size() - 1);\n\t\t\tfor (int i : cycles) {\n\t\t\t\ta[i] = root;\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++)\n\t\t\t\tout.print((a[i] + 1) +\" \");\n\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic class FasterScanner {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[200010], vs[200010];\nvector<int> cyc;\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%d\", &p[i]);\n  int vc = 0, root = -1;\n  for (int i = 1; i <= N; i++) {\n    if (vs[i] > 0) continue;\n    int st = vc, now = i;\n    for (;;) {\n      if (vs[now] == 0) {\n        vs[now] = ++vc;\n      } else {\n        if (vs[now] > st) {\n          int sz = vc - vs[now] + 1;\n          if (sz == 1) root = now;\n          cyc.push_back(now);\n        }\n        break;\n      }\n      now = p[now];\n    }\n  }\n  int ans = 0;\n  if (!cyc.empty()) {\n    if (root == -1) root = cyc[0];\n    for (int x : cyc) {\n      if (p[x] != root) {\n        p[x] = root;\n        ans++;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= N; i++) printf(\"%d \", p[i]);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def find_group(i):\n    if group[i] != group[group[i]]:\n        group[i] = find_group(group[group[i]])\n    return group[i]\n\n\nn = int(raw_input())\ngroup = range(n)\nsize = [1] * n\nroots = []\nroot = None\n\nparent = map(lambda x: int(x) - 1, raw_input().split())\n\nfor i in xrange(n):\n    c_group = find_group(i)\n    p_group = find_group(parent[i])\n\n    if c_group != p_group:\n        if size[c_group] > size[p_group]:\n            size[c_group] += size[p_group]\n            group[p_group] = c_group\n        else:\n            size[p_group] += size[c_group]\n            group[c_group] = p_group\n    else:\n        roots.append(i)\n        if parent[i] == i:\n            root = i\n\nanswer = len(roots) - 1\n\nif root is None:\n    root = roots[0]\n    answer += 1\n\nfor r in roots:\n    parent[r] = root\n\nprint answer\nfor i in xrange(n):\n    print parent[i] + 1,\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nlong long n;\nlong long a[N], vis[N], root[N];\nlong long dfs(long long k) {\n  if (vis[k]) return root[k];\n  vis[k] = 1;\n  root[k] = k;\n  root[k] = dfs(a[k]);\n  return root[k];\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  for (long long i = 1; i <= n; i++) dfs(a[i]);\n  long long ans = -1, actualroot = -1;\n  for (long long i = 1; i <= n; i++) {\n    ans += (i == dfs(a[i]));\n    if (i == a[i]) actualroot = i;\n  }\n  if (actualroot == -1) {\n    ans++;\n    for (long long i = 1; i <= n; i++) {\n      if (i == dfs(a[i])) {\n        actualroot = i;\n        a[i] = i;\n        break;\n      }\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (i == dfs(a[i])) {\n      a[i] = actualroot;\n    }\n  }\n  cout << ans << \"\\n\";\n  for (long long i = 1; i <= n; i++) cout << a[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n\tstatic int cnt;\n\tstatic int[] p;\n\tstatic int[] v;\n\tstatic int root;\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        p = new int[n];\n        v = new int[n];\n        for(int i=0;i<n;i++){\n        \tp[i] = in.nextInt()-1;\n        \tv[i] = 0;\n        }\n        int dep = 0;\n        root = -1;\n        for(int i=0;i<n;i++){\n        \tif(p[i] == i){\n        \t\troot = i;\n        \t}\n        }\n        for(int i=0;i<n;i++){\n        \tif(v[i]==0){\n        \t\tdep++;\n        \t\tdfs(i, dep);\n        \t}\n        }\n        out.println(cnt);\n        for(int i=0;i<n;i++){\n        \tout.print((p[i]+1) + \" \");\n        }\n        out.flush();\n\t}\n\t\n\tstatic void dfs(int u, int dep){\n\t\tv[u] = dep;\n\t\tif(v[p[u]]==0){\n\t\t\tdfs(p[u], dep);\n\t\t} else if(v[p[u]] == dep){\n\t\t\t//circle found\n\t\t\tupdate(u);\n\t\t}\n\t}\n\t\n\tstatic void update(int u){\n\t\tif(root == u) return;\n\t\tif(root==-1){\n\t\t\troot = u;\n\t\t\tp[u] = u;\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tp[u] = root;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong(){\n        \treturn Long.parseLong(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n\npublic class con9_2 {\n    \n\tstatic int n,m,a,b,ans;\n\tstatic int[] d=new int[200005];\n\tstatic int[] s=new int[200005];\n\tstatic int find(int x){\n\t\tif(s[x]==x) return x;\n\t\treturn s[x]=find(s[x]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tm=-1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\td[i]=in.nextInt();\n\t\tfor(int i=1;i<=n;i++) \n\t\t\ts[i]=i;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta=find(i);\n\t\t\tb=find(d[i]);\n\t\t\tif(a!=b) \n\t\t\t\ts[a]=b;\n\t\t\tif(m<0&&d[i]==i) \n\t\t\t\tm=i;\n\t\t}\n\t\tif(m<0){\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(s[i]==i) { \n\t\t\t\t\tm=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(s[i]==i&&d[i]!=m) {\n\t\t\t d[i]=m;\n\t\t\t ans++;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tSystem.out.print(d[i]+\" \");\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\n\n\npublic class B {\n\n\tprivate static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static PrintStream out = System.out;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tString[] s = in.readLine().split(\" \");\n\t\tint[] parents = new int[n];\n\t\tint root = -1;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tparents[i] = Integer.parseInt(s[i]) - 1;\n\t\t\tif (i == parents[i])\n\t\t\t\troot = i;\n\t\t}\n\t\tint cnt = 0;\n\t\tint[] seen = new int[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tseen[i] = -1;\n\t\tfor (int curr = 0; curr < n; ++curr) {\n\t\t\tint idx = curr;\n\t\t\twhile (seen[idx] == -1 && parents[idx] != idx) {\n\t\t\t\tseen[idx] = curr;\n\t\t\t\tidx = parents[idx];\n\t\t\t}\n\t\t\tif (seen[idx] == curr && parents[idx] != idx) {\n\t\t\t\t++cnt;\n\t\t\t\tif (root == -1) {\n\t\t\t\t\tparents[idx] = idx;\n\t\t\t\t\troot = idx;\n\t\t\t\t} else\n\t\t\t\t\tparents[idx] = root;\n\t\t\t} else if (parents[idx] == idx && idx != root) {\n\t\t\t\t++cnt;\n\t\t\t\tparents[idx] = root;\n\t\t\t}\n\t\t}\n\t\tout.println(cnt);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tout.print((parents[i] + 1) + \" \");\n\t\tout.println();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5;\nint n, fa[N], p[N], cnt, mk, la[N], size[N];\nint getfa(int x) {\n  if (fa[x] == x) return x;\n  return fa[x] = getfa(fa[x]);\n}\nvoid merge(int x, int y) {\n  int fx = getfa(x), fy = getfa(y);\n  if (fx == fy) return;\n  fa[fx] = fy;\n  size[fy] += size[fx];\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> p[i];\n  for (int i = 1; i <= n; i++) {\n    fa[i] = i;\n    size[i] = 1;\n    if (p[i] == i) {\n      if (!mk)\n        mk = i;\n      else\n        p[i] = mk, cnt++;\n    }\n  }\n  if (!mk) {\n    for (int i = 1; i <= n; i++) merge(i, p[i]);\n    int now = 0;\n    for (int i = 1; i <= n; i++) {\n      if (size[i] > now) {\n        now = size[i];\n        mk = i;\n      }\n    }\n    for (int i = 1; i <= n; i++) fa[i] = i;\n    p[mk] = mk;\n    cnt++;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (p[i] == i) continue;\n    if (getfa(i) == getfa(p[i])) p[i] = mk, cnt++;\n    merge(i, p[i]);\n  }\n  cout << cnt << endl;\n  for (int i = 1; i <= n; i++) cout << p[i] << \" \";\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces698B {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tint n = Integer.parseInt(f.readLine());\n\t\t\tint[] a = new int[n];\n\t\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint root = -1;\n\t\t\tint numChanges = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(a[i] == i)\n\t\t\t\t\troot = i;\n\t\t\t}\n\t\t\tif(root == -1) {\n\t\t\t\tboolean[] visited = new boolean[n];\n\t\t\t\tvisited[0] = true;\n\t\t\t\tint current = 0;\n\t\t\t\twhile(!visited[a[current]]) {\n\t\t\t\t\tvisited[a[current]] = true;\n\t\t\t\t\tcurrent = a[current];\n\t\t\t\t}\n\t\t\t\ta[current] = current;\n\t\t\t\tnumChanges++;\n\t\t\t\troot = current;\n\t\t\t}\n\t\t\tint[] component = new int[n];\n\t\t\tcomponent[root] = 1;\n\t\t\tint color = 1;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(component[i] == 0) {\n\t\t\t\t\tcolor++;\n\t\t\t\t\tint current = i;\n\t\t\t\t\tcomponent[current] = color;\n\t\t\t\t\twhile(component[a[current]] == 0) {\n\t\t\t\t\t\tcomponent[a[current]] = color;\n\t\t\t\t\t\tcurrent = a[current];\n\t\t\t\t\t}\n\t\t\t\t\tif(component[a[current]] == color) {\n\t\t\t\t\t\ta[current] = root;\n\t\t\t\t\t\tnumChanges++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(numChanges);\n\t\t\tStringBuffer s = new StringBuffer(\"\");\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ts.append((a[i] + 1) + \" \");\n\t\t\t}\n\t\t\tSystem.out.println(s.toString().trim());\n\t\t}\n\t\tcatch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class studyDemo\n{\n    /********************************************** a list of common variables **********************************************/\n    private MyScanner scan = new MyScanner();\n    private PrintWriter out = new PrintWriter(System.out);\n    private final double PI = Math.PI;\n    private final int INF = (int)(1e9);\n    private final double EPS = 1e-6;\n    private final int SIZEN = (int)(1e7);\n    private final int MOD = (int)(1e9 + 7);\n    private final long MODH = 10000000007L, BASE = 10007;\n    private final int[] DX = {0, 1, 0, -1}, DY = {-1, 0, 1, 0};\n\n\n    public void foo1()\n    {\n        int n = scan.nextInt();\n        int a = 0, b = 0, c = 0;\n        int a1 = 0, b1 = 0, c1 = 0;\n        for(int i = 0;i < n;++i) {\n            int x = scan.nextInt();\n            if (x == 0) {\n                a1 = Math.min(a, Math.min(b, c)) + 1;\n                b1 = 1000;\n                c1 = 1000;\n            } else if (x == 1) {\n                a1 = Math.min(a, Math.min(b, c)) + 1;\n                b1 = Math.min(a, c);\n                c1 = 1000;\n            } else if (x == 2) {\n                a1 = Math.min(a, Math.min(b, c)) + 1;\n                b1 = 1000;\n                c1 = Math.min(a, b);\n            } else {\n                a1 = Math.min(a, Math.min(b, c)) + 1;\n                b1 = Math.min(a, c);\n                c1 = Math.min(a, b);\n            }\n            a = a1;\n            b = b1;\n            c = c1;\n        }\n        out.println(Math.min(a, Math.min(b, c)));\n    }\n\n    public void foo() {\n        int n = scan.nextInt();\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        for (int i = 1;i <= n;++i) {\n            a[i] = scan.nextInt();\n            b[i] = a[i];\n        }\n        boolean[] vis = new boolean[n + 1];\n        boolean[] vis2 = new boolean[n + 1];\n        int root = -1;\n        for(int i = 1;i <= n;++i) {\n            if (i == a[i]) {\n                root = i;\n                vis[i] = true;\n                break;\n            }\n        }\n        int ans = 0;\n        for (int i = 1;i <= n;++i) {\n            if (vis[i]) {\n                continue;\n            }\n            if (i == a[i]) {\n                if (i != root) {\n                    b[i] = root;\n                    ++ans;\n                }\n                vis[i] = true;\n            } else {\n                int u = i;\n                while (!vis[u] && !vis2[u]) {\n                    vis2[u] = true;\n                    u = a[u];\n                }\n                if (vis2[u]) {\n                    if (root == -1) {\n                        root = u;\n                    }\n                    b[u] = root;\n                    ++ans;\n                }\n                u = i;\n                while (!vis[u]) {\n                    vis[u] = true;\n                    vis2[u] = false;\n                    u = a[u];\n                }\n            }\n        }\n        out.println(ans);\n        for(int i = 1;i <= n;++i) {\n            out.print(b[i] + \" \");\n        }\n        out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        studyDemo m = new studyDemo();\n        m.foo();\n        m.out.close();\n    }\n\n    /********************************************** a list of common algorithms **********************************************/\n    /**\n     * 1---Get greatest common divisor\n     * @param a :\tfirst number\n     * @param b :\tsecond number\n     * @return\t\tgreatest common divisor\n     */\n    public long gcd(long a, long b)\n    {\n        return 0 == b ? a : gcd(b, a % b);\n    }\n\n    /**\n     * 2---Get the distance from a point to a line\n     * @param x1\tthe x coordinate of one endpoint of the line\n     * @param y1\tthe y coordinate of one endpoint of the line\n     * @param x2\tthe x coordinate of the other endpoint of the line\n     * @param y2\tthe y coordinate of the other endpoint of the line\n     * @param x\t\tthe x coordinate of the point\n     * @param y\t\tthe x coordinate of the point\n     * @return\t\tthe distance from a point to a line\n     */\n    public double getDist(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        long a = y2 - y1;\n        long b = x1 - x2;\n        long c = y1 * (x2 - x1) - x1 * (y2 - y1);\n        return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);\n    }\n\n    /**\n     * 3---Get the distance from one point to a segment (not a line)\n     * @param x1\tthe x coordinate of one endpoint of the segment\n     * @param y1\tthe y coordinate of one endpoint of the segment\n     * @param x2\tthe x coordinate of the other endpoint of the segment\n     * @param y2\tthe y coordinate of the other endpoint of the segment\n     * @param x\t\tthe x coordinate of the point\n     * @param y\t\tthe y coordinate of the point\n     * @return\t\tthe distance from one point to a segment (not a line)\n     */\n    public double ptToSeg(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        double cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n        if(cross <= 0)\n        {\n            return (x - x1) * (x - x1) + (y - y1) * (y - y1);\n        }\n        double d = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        if(cross >= d)\n        {\n            return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n        }\n        double r = cross / d;\n        double px = x1 + (x2 - x1) * r;\n        double py = y1 + (y2 - y1) * r;\n        return (x - px) * (x - px) + (y - py) * (y - py);\n    }\n\n    /**\n     * 4---KMP match, i.e. kmpMatch(\"abcd\", \"bcd\") = 1, kmpMatch(\"abcd\", \"bfcd\") = -1.\n     * @param t:\tString to match.\n     * @param p:\tString to be matched.\n     * @return\t\tif can match, first index; otherwise -1.\n     */\n    public int kmpMatch(char[] t, char[] p)\n    {\n        int n = t.length;\n        int m = p.length;\n        int[] next = new int[m + 1];\n        next[0] = -1;\n        int j = -1;\n        for(int i = 1;i < m;++i)\n        {\n            while(j >= 0 && p[i] != p[j + 1])\n            {\n                j = next[j];\n            }\n            if(p[i] == p[j + 1])\n            {\n                ++j;\n            }\n            next[i] = j;\n        }\n        j = -1;\n        for(int i = 0;i < n;++i)\n        {\n            while(j >= 0 && t[i] != p[j + 1])\n            {\n                j = next[j];\n            }\n            if(t[i] == p[j + 1])\n            {\n                ++j;\n            }\n            if(j == m - 1)\n            {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 5---Get the hash code of a String\n     * @param\ts:\tinput string\n     * @return\thash code\n     */\n    public long hash(String s)\n    {\n        long key = 0, t = 1;\n        for(int i = 0;i < s.length();++i)\n        {\n            key = (key + s.charAt(i) * t) % MODH;\n            t = t * BASE % MODH;\n        }\n        return key;\n    }\n\n    /**\n     * 6---Get x ^ n % MOD quickly.\n     * @param\tx:\tbase\n     * @param \tn:\ttimes\n     * @return\tx ^ n % MOD\n     */\n    public long quickMod(long x, long n)\n    {\n        long ans = 1;\n        while(n > 0)\n        {\n            if(1 == n % 2)\n            {\n                ans = ans * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return ans;\n    }\n\n    /**\n     * 7---judge if a point is located inside a polygon\n     * @param x0\tthe x coordinate of the point\n     * @param y0\tthe y coordinate of the point\n     * @return true if it is inside the polygon, otherwise false\n     */\n\t/*public boolean contains(double x0, double y0)\n\t{\n\t\tint cross = 0;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tdouble s = x[i + 1] == x[i] ? 100000000 : (double)(y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n\t\t\tboolean b1 = x[i] <= x0 && x0 < x[i + 1];\n\t\t\tboolean b2 = x[i + 1] <= x0 && x0 < x[i];\n\t\t\tboolean b3 = y0 < s * (x0 - x[i]) + y[i];\n\t\t\tif((b1 || b2) && b3) ++cross;\n\t\t}\n\t\treturn cross % 2 != 0;\n\t}*/\n\n    /**\n     * 8---judge if a point is located on the segment\n     * @param\tx1\tthe x coordinate of one point of the segment\n     * @param\ty1\tthe y coordinate of one point of the segment\n     * @param \tx2\tthe x coordinate of another point of the segment\n     * @param \ty2\tthe y coordinate of another point of the segment\n     * @param\tx\tthe x coordinate of the point\n     * @param \ty\tthe y coordinate of the point\n     * @return\ttrue if it is located on the segment, otherwise false\n     */\n    public boolean isOnSeg(long x1, long y1, long x2, long y2, long x, long y)\n    {\n        return (x - x1) * (y2 - y1) == (x2 - x1) * (y - y1) &&\n                x >= Math.min(x1, x2) && x <= Math.max(x1, x2) &&\n                y >= Math.min(y1, y2) && y <= Math.max(y1, y2);\n    }\n\n    /**\n     * 9---get the cross product\n     * @param \tp1\tpoint A\n     * @param \tp2\tpoint B\n     * @param \tp\tpoint O\n     * @return\tcross product of OA x OB\n     */\n\t/*public long cross(Point p1, Point p2, Point p)\n\t{\n\t\treturn (long)(p1.x - p.x) * (p2.y - p.y) - (long)(p2.x - p.x) * (p1.y - p.y);\n\t}*/\n\n    /**\n     * 10---implement topsort and tell if it is possible\n     * @return true if it is possible to implement topsort, otherwise false\n     */\n\t/*public boolean topsort()\n\t{\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint[] in = new int[26];\n\t\tfor(int i = 0;i < 26;++i)\n\t\t{\n\t\t\tif(0 == in[i]) \n\t\t\t{\n\t\t\t\tans.append((char)('a' + i));\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tint u = q.poll();\n\t\t\tfor(int i = 0;i < 26;++i)\n\t\t\t{\n\t\t\t\tif(map[u][i])\n\t\t\t\t{\n\t\t\t\t\t--in[i];\n\t\t\t\t\tif(0 == in[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tans.append((char)('a' + i));\n\t\t\t\t\t\tq.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 26 == ans.length();\n\t}*/\n\n    class MyScanner\n    {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        BufferedInputStream bis = new BufferedInputStream(System.in);\n\n        public int read()\n        {\n            if (-1 == numChars)\n            {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = bis.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9')\n                {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c & 15;\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                    {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9')\n                    {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c & 15) * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String next()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n            {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c)\n        {\n            return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class B extends PrintWriter {\n\n    boolean dfs(int u, int f, int[] p, int[] color) {\n        if (color[u] == 2) {\n            return false;\n        }\n        if (color[u] == 1) {\n            return true;\n        }\n\n        color[u] = 1;\n\n        int v = p[u];\n        if (v != f) {\n            if (dfs(v, f, p, color)) {\n                p[u] = f;\n            }\n        }\n\n        color[u] = 2;\n        return false;\n    }\n\n    void run() {\n        int n = nextInt();\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = nextInt() - 1;\n        }\n\n        int f = -1;\n        int[] t = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            t[i] = p[i];\n            if (p[i] == i) {\n                if (f == -1) {\n                    f = i;\n                } else {\n                    t[i] = f;\n                }\n            }\n        }\n\n        if (f == -1) {\n            boolean[] use = new boolean[n];\n            int u = 0;\n\n            while (true) {\n                use[u] = true;\n                int v = t[u];\n                if (use[v]) {\n                    f = t[u] = u;\n                    break;\n                }\n                u = v;\n            }\n        }\n\n        int[] color = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            dfs(i, f, t, color);\n        }\n\n        int cnt = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (t[i] != p[i]) {\n                ++cnt;\n            }\n        }\n\n        println(cnt);\n\n        for (int i = 0; i < n; i++) {\n            print(t[i] + 1);\n            print(' ');\n        }\n        println();\n    }\n\n    int[][] nextMatrix(int n, int m) {\n        int[][] matrix = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                matrix[i][j] = nextInt();\n        return matrix;\n    }\n\n    String next() {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    boolean hasNext() {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = nextLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    int[] nextArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException err) {\n            return null;\n        }\n    }\n\n    public B(OutputStream outputStream) {\n        super(outputStream);\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n    static Random rnd = new Random();\n    static boolean OJ;\n\n    public static void main(String[] args) throws IOException {\n        OJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n        B solution = new B(System.out);\n        if (OJ) {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            solution.run();\n        } else {\n            reader = new BufferedReader(new FileReader(new File(B.class.getName() + \".txt\")));\n            long timeout = System.currentTimeMillis();\n            while (solution.hasNext()) {\n                solution.run();\n                solution.println();\n                solution.println(\"----------------------------------\");\n            }\n            solution.println(\"time: \" + (System.currentTimeMillis() - timeout));\n        }\n        solution.close();\n        reader.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint up[N], n, a[N], root, cnt;\nint f(int u) {\n  if (up[u] == u) return u;\n  return up[u] = f(up[u]);\n}\nvoid uni(int u, int v) { up[f(u)] = f(v); }\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) up[i] = i;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    uni(i, a[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (f(i) == i) {\n      if (a[i] == i) root = i;\n      cnt++;\n    }\n  }\n  if (root)\n    cout << cnt - 1 << endl;\n  else\n    cout << cnt << endl;\n  if (!root) root = f(1);\n  for (int i = 1; i <= n; i++) {\n    if (f(i) == i)\n      cout << root << ' ';\n    else\n      cout << a[i] << ' ';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.Math;\nimport java.math.BigInteger;\n\nimport com.sun.corba.se.impl.encoding.OSFCodeSetRegistry.Entry;\n\npublic class Problem {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Problem().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\tRandom rnd = new Random();\n\tstatic final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tProblem() throws FileNotFoundException {\n\n\t\tif (ONLINE_JUDGE) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\ttok = new StringTokenizer(\"\");\n\t}\n\n\tList<Integer>[] graph;\n\tboolean[] used;\n\tint[] ans;\n\tint[] colors;\n\tint counter=0;\n\tArrayList<Integer> roots = new ArrayList<>();\n\tint main_root=-1;\n\tvoid solve() throws IOException {\n\t\t\n\t\tint n = rI();\n\t\tgraph = new ArrayList[n];\n\t\tused = new boolean[n];\n\t\tcolors = new int[n];\n\t\tans = new int[n];\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n;++i){\n\t\t\tans[i] = rI()-1;\n\t\t\tif(i!=ans[i]){\n\t\t\t\tgraph[i].add(ans[i]);\n\t\t\t}else{\n\t\t\t\troots.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(ans[i]==i){\n\t\t\t\tmain_root=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(colors[i]==0){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(counter);\n\t\tfor(int a: ans){\n\t\t\tout.print(a+1+\" \");\n\t\t}\n\n\t}\n\tvoid dfs(int from){\n\t\tcolors[from] = 1;\n\t\tif(ans[from]!=from){\n\t\t\tfor(int to: graph[from]){\n\t\t\t\tif(colors[to]==0){\n\t\t\t\t\tdfs(to);\n\t\t\t\t}else if(colors[to]==1){\n\t\t\t\t\tif(main_root==-1){\n\t\t\t\t\t\tans[from] = from;\n\t\t\t\t\t\tmain_root=from;\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans[from] = main_root;\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(ans[from]!=main_root){\n\t\t\t\tans[from] = main_root;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcolors[from] = 2;\n\t}\n\t// ======================================================\n\tclass SegmentTree {\n\n\t\tint[] tree;\n\n\t\tSegmentTree(int n) {\n\t\t\ttree = new int[n];\n\t\t}\n\n\t\tvoid build(int[] a, int v, int curL, int curR) {\n\t\t\tif (curL == curR) {\n\t\t\t\tthis.tree[v] = a[curL];\n\t\t\t} else {\n\t\t\t\tint mid = (curL + curR) / 2;\n\t\t\t\tbuild(a, v * 2, curL, mid);\n\t\t\t\tbuild(a, v * 2 + 1, mid + 1, curR);\n\t\t\t\tthis.tree[v] = this.tree[v * 2] + this.tree[v * 2 + 1];\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Dsu {\n\t\tint[] parents;\n\t\tint countUnions;\n\n\t\tDsu(int size) {\n\t\t\tthis.parents = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\tparents[i] = i;\n\t\t\t}\n\t\t\tthis.countUnions = size;\n\t\t}\n\n\t\tint get(int v) {\n\t\t\tif (v == parents[v])\n\t\t\t\treturn v;\n\t\t\treturn parents[v] = get(parents[v]);\n\t\t}\n\n\t\tboolean union(int a, int b) {\n\t\t\ta = get(a);\n\t\t\tb = get(b);\n\t\t\tif (a == b) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rnd.nextBoolean()) {\n\t\t\t\tparents[a] = b;\n\t\t\t} else {\n\t\t\t\tparents[b] = a;\n\t\t\t}\n\t\t\tthis.countUnions--;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// ======================================================\n\tvoid run() throws IOException {\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tchar[] reverseCharArray(char[] arr) {\n\t\tchar[] ans = new char[arr.length];\n\t\tfor (int i = 0; i < arr.length; ++i) {\n\t\t\tans[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint sqrt(double m) {\n\t\tint l = 0;\n\t\tint r = 1000000000 + 9;\n\t\tint i = 1000;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (r + l) / 2;\n\t\t\tif (mid * mid > m) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\tint countPow(int m, int n) {\n\t\tint ans = 0;\n\t\twhile (m % n == 0 && m > 0) {\n\t\t\tans++;\n\t\t\tm /= n;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tlong binPow(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b % 2 == 1) {\n\t\t\treturn a * binPow(a, b - 1);\n\t\t} else {\n\t\t\tlong c = binPow(a, b / 2);\n\t\t\treturn c * c;\n\t\t}\n\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a%b);\n\t}\n\n\tlong pow(long x, long k) {\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < k; ++i) {\n\t\t\tans *= x;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ////////////////////////////////////////////////////////////////////\n\n\tString delimiter = \" \";\n\n\tString readLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tString rS() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\tString nextLine = readLine();\n\t\t\tif (null == nextLine)\n\t\t\t\treturn null;\n\n\t\t\ttok = new StringTokenizer(nextLine);\n\t\t}\n\n\t\treturn tok.nextToken(delimiter);\n\t}\n\n\tint rI() throws IOException {\n\t\treturn Integer.parseInt(rS());\n\t}\n\n\tlong rL() throws IOException {\n\t\treturn Long.parseLong(rS());\n\t}\n\n\tint[] rA(int b) {\n\t\tint a[] = new int[b];\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\ttry {\n\t\t\t\ta[i] = rI();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = rI();\n\t\t}\n\t\tArrays.sort(array);\n\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\n\t\treturn sortedArray;\n\t}\n\n\tint[] sortedIntArray(int size, int[] array) throws IOException {\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = rI();\n\t\t}\n\t\tArrays.sort(array);\n\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\n\t\treturn sortedArray;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n/*\n3\n2 3 1\n\n */\npublic class B {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner qwe = new Scanner(System.in);\n\t\t\n\t\tint n =qwe.nextInt();\n\t\tint[] p = new int[n+1];\n\t\t\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tp[i] = qwe.nextInt();\n\t\t}\n\t\t\n\t\tint root = -1;\n\t\t\n\t\tint numchanges = 0;\n\t\t\n\t\tint[] seen = new int[n+1];\n\t\t\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tif(p[i] == i){\n\t\t\t\troot = i;\n\t\t\t\tseen[i] = n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 1; a <=n; a++){\n\t\t\tif(seen[a] != 0) continue;\n\t\t\tseen[a] = a;\n\t\t\tint at = a;\n\t\t\t\n\t\t\twhile(seen[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = a;\n\t\t\t}\n\t\t\t\n\t\t\tif(seen[p[at]] == a){\n\t\t\t\tnumchanges++;\n\t\t\t\tif(root != -1){\n\t\t\t\t\tp[at] = root;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(numchanges);\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tSystem.out.print(p[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tqwe.close();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nlong long par[N], vis[N], root, changes = 0;\nvoid solve() {\n  long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    cin >> par[i];\n    if (par[i] == i) root = i;\n  }\n  for (long long i = 1, T = 0; i <= n; i++) {\n    if (!vis[i]) {\n      T++;\n      long long cur = i;\n      while (!vis[cur]) {\n        vis[cur] = T;\n        cur = par[cur];\n      }\n      if (vis[cur] == T) {\n        if (!root) {\n          par[cur] = cur;\n          root = cur;\n          changes++;\n        } else if (par[cur] != root) {\n          par[cur] = root;\n          changes++;\n        }\n      }\n    }\n  }\n  cout << changes << '\\n';\n  for (long long i = 1; i <= n; i++) cout << par[i] << ' ';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long T = 1;\n  for (long long i = 1; i <= T; i++) {\n    solve();\n  }\n  cerr << \"\\nTime: \" << clock() << \" ms\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000 + 5;\nint pre[N];\nint t[N];\nvector<int> s;\nint Find(int x) { return x == pre[x] ? x : pre[x] = Find(pre[x]); }\nvoid Union(int x, int y) {\n  int fx = Find(x), fy = Find(y);\n  if (fx != fy) pre[fx] = fy;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) pre[i] = i;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &t[i]);\n    Union(i, t[i]);\n  }\n  int cot = 0;\n  int e = 0;\n  for (int i = 1; i <= n; i++)\n    if (i == Find(pre[i]) && t[i] == i) {\n      e = i;\n      break;\n    }\n  for (int i = 1; i <= n; i++) {\n    if (i == e) continue;\n    if (i == Find(pre[i])) {\n      cot++;\n      if (e)\n        t[i] = e;\n      else {\n        t[i] = i;\n        e = i;\n      }\n    }\n  }\n  cout << cot << endl;\n  for (int i = 1; i < n; i++) printf(\"%d \", t[i]);\n  cout << t[n] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Igor Kraskevich\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\n    ArrayList<Integer>[] g;\n    int color[];\n    boolean[] bad;\n\n    void dfs(int v) {\n        color[v] = 1;\n        for (int to : g[v]) {\n            if (color[to] == 1)\n                bad[v] = true;\n            else if (color[to] == 0)\n                dfs(to);\n        }\n        color[v] = 2;\n    }\n\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int n = in.nextInt();\n        g = new ArrayList[n];\n        bad = new boolean[n];\n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<>();\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = in.nextInt() - 1;\n            g[i].add(p[i]);\n        }\n        color = new int[n];\n        for (int i = 0; i < n; i++)\n            if (color[i] == 0)\n                dfs(i);\n        int root = -1;\n        for (int i = 0; i < n; i++)\n            if (p[i] == i) {\n                root = i;\n                break;\n            }\n        if (root == -1) {\n            for (int i = 0; i < n; i++)\n                if (bad[i]) {\n                    root = i;\n                    break;\n                }\n        }\n        if (root == -1)\n            throw new AssertionError();\n        int[] ans = new int[n];\n        int cnt = 0;\n        for (int i = 0; i < n; i++)\n            if (bad[i]) {\n                ans[i] = root;\n                if (ans[i] != p[i])\n                    cnt++;\n            } else {\n                ans[i] = p[i];\n            }\n        out.println(cnt);\n        for (int i = 0; i < n; i++)\n            out.print(ans[i] + 1 + \" \");\n        out.println();\n    }\n}\n\nclass FastScanner {\n    private StringTokenizer tokenizer;\n    private BufferedReader reader;\n\n    public FastScanner(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = null;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                }\n            if (line == null)\n                return null;\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nn = int(sys.stdin.readline())\na = [int(u)-1 for u in sys.stdin.readline().split()]    # fathers\n\nparents = [None] * n\n\nqueue = []\nopened = [False] * n\nclosed = [False] * n\n\nfor i in xrange(n):\n    if closed[i]:\n        continue\n    assert not opened[i]\n    \n    queue.append(i)\n    \n    while len(queue) > 0:\n        x = queue[-1]\n        \n        if a[x] == x:\n            opened[x] = True\n            closed[x] = True\n            parents[x] = x\n            queue.pop()\n        \n        elif closed[x]:\n            queue.pop()\n        \n        elif opened[x]:\n            closed[x] = True\n            if parents[a[x]] is not None:\n                parents[x] = parents[a[x]]\n            else:\n                # loop\n                parents[x] = x\n            queue.pop()\n        \n        else:\n            opened[x] = True\n            queue.append(a[x])\n\n# print parents\n\nrelevant = list(set(parents))\n# print relevant\n\n# choose root\nroot = relevant[0]\nfor x in relevant:\n    if a[x] == x:\n        root = x\n\n# do changes\nnum_changes = 0\nfor x in relevant:\n    if a[x] != root:\n        a[x] = root\n        num_changes += 1\n\nprint num_changes\nfor x in xrange(n):\n    print a[x]+1,\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner qwe = new Scanner(System.in);\n\t\t\n\t\tint n =qwe.nextInt();\n\t\tint[] p = new int[n+1];\n\t\t\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tp[i] = qwe.nextInt();\n\t\t}\n\t\t\n\t\tint root = -1;\n\t\t\n\t\tint numchanges = 0;\n\t\t\n\t\tint[] seen = new int[n+1];\n\t\t\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tif(p[i] == i){\n\t\t\t\troot = i;\n\t\t\t\tseen[i] = n+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 1; a <=n; a++){\n\t\t\tif(seen[a] != 0) continue;\n\t\t\tseen[a] = a;\n\t\t\tint at = a;\n\t\t\t\n\t\t\twhile(seen[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = a;\n\t\t\t}\n\t\t\t\n\t\t\tif(seen[p[at]] == a){\n\t\t\t\tnumchanges++;\n\t\t\t\tif(root != -1){\n\t\t\t\t\tp[at] = root;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(numchanges);\n\t\tfor(int i =1; i <= n; i++){\n\t\t\tSystem.out.print(p[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tqwe.close();\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\nusing namespace std;\nconst int maxn = (int)2e5 + 13;\nconst long long INFL = 9223372036854775807;\nconst int INF = 2147483646;\nconst long long MOD = (int)1e9 + 21;\nconst long long base = 257;\nvector<int> gr[maxn];\nbool vis[maxn];\nvoid dfs(int v, vector<int> &c, int &r, int p = -1) {\n  vis[v] = 1;\n  c.push_back(v);\n  for (auto t : gr[v]) {\n    if (!vis[t] && t != p) {\n      dfs(t, c, r, v);\n    } else if (t != p) {\n      r = t;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n + 1);\n  vector<int> roots;\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n    if (i != p[i])\n      gr[i].push_back(p[i]), gr[p[i]].push_back(i);\n    else\n      roots.push_back(i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      vector<int> v;\n      int r = -1;\n      dfs(i, v, r);\n      if (r != -1 && roots.size() != 0)\n        p[r] = roots[0], ans++;\n      else if (r != -1 && roots.size() == 0)\n        p[r] = r, ans++, roots.push_back(r);\n    }\n  }\n  for (int i = 1; i < roots.size(); ++i) {\n    p[roots[i]] = roots[0];\n    ans++;\n  }\n  cout << ans << \"\\n\";\n  for (int i = 1; i <= n; ++i) cout << p[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[200005];\nint vis[200005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while (cin >> n) {\n    memset(vis, 0, sizeof(vis));\n    for (int i = (1); i <= (n); i++) cin >> a[i];\n    int cnt = 1;\n    int rt = -1;\n    int num = 0;\n    for (int i = (1); i <= (n); i++) {\n      if (a[i] == i && rt == -1) {\n        rt = i;\n        vis[i] = 1;\n        cnt++;\n        continue;\n      }\n      if (vis[i] == 0) {\n        int id = i;\n        while (vis[id] == 0) {\n          vis[id] = cnt;\n          id = a[id];\n          if (vis[id] == cnt) {\n            if (id != a[id] || rt != -1) {\n              a[id] = -1;\n              num++;\n            } else\n              rt = id;\n          }\n        }\n        cnt++;\n      }\n    }\n    printf(\"%d\\n\", num);\n    for (int i = (1); i <= (n); i++) {\n      if (a[i] == -1 && rt == -1) rt = i;\n      if (a[i] != -1)\n        printf(\"%d \", a[i]);\n      else\n        printf(\"%d \", rt);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Alex\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskB {\n        int[] a;\n        int[] visited;\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            a = IOUtils.readIntArray(in, n);\n            visited = new int[n];\n            MiscUtils.decreaseByOne(a);\n            RecursiveIndependentSetSystem iss = new RecursiveIndependentSetSystem(n);\n            for (int i = 0; i < a.length; i++) iss.join(i, a[i]);\n            TreeMap<Integer, Group> tm = new TreeMap<>();\n            for (int i = 0; i < a.length; i++) {\n                int g = iss.get(i);\n                if (!tm.containsKey(g)) tm.put(g, new Group());\n                tm.get(g).nodes.add(i);\n            }\n            for (Group g : tm.values()) g.run();\n            Group rock = null;\n            for (Group g : tm.values()) if (g.tochange == -1) rock = g;\n            int rockval = (rock == null ? -1 : rock.parent);\n            if (rockval == -1) for (Group g : tm.values()) rockval = g.tochange;\n            int[] res = a.clone();\n            for (Group g : tm.values()) {\n                if (g.tochange != -1) res[g.tochange] = rockval;\n                else res[g.parent] = rockval;\n            }\n            int count = 0;\n            for (int i = 0; i < n; i++) if (res[i] != a[i]) count++;\n            out.printLine(count);\n            for (int i = 0; i < n; i++) res[i]++;\n            out.printLine(res);\n        }\n        class Group {\n            ArrayList<Integer> nodes = new ArrayList<>();\n            int parent = -1;\n            int tochange = -1;\n            int index = 1;\n            void run() {\n                for (int val : nodes) dfs(val, index++);\n                for (int val : nodes) if (a[val] == val) parent = val;\n            }\n            void dfs(int cur, int counter) {\n                if (cur == a[cur]) return;\n                if (visited[cur] != 0 && visited[cur] != counter) return;\n                visited[cur] = counter;\n                int nxt = a[cur];\n                if (visited[nxt] == counter) {\n                    tochange = cur;\n                } else {\n                    dfs(nxt, counter);\n                }\n            }\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++)\n                    array[i]--;\n            }\n        }\n    }\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = in.readInt();\n            return array;\n        }\n    }\n    static class RecursiveIndependentSetSystem implements IndependentSetSystem {\n        private final int[] color;\n        private final int[] rank;\n        private int setCount;\n        private IndependentSetSystem.Listener listener;\n        public RecursiveIndependentSetSystem(int size) {\n            color = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                color[i] = i;\n            }\n            setCount = size;\n        }\n        public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n            color = other.color.clone();\n            rank = other.rank.clone();\n            setCount = other.setCount;\n        }\n        public boolean join(int first, int second) {\n            first = get(first);\n            second = get(second);\n            if (first == second) {\n                return false;\n            }\n            if (rank[first] < rank[second]) {\n                int temp = first;\n                first = second;\n                second = temp;\n            } else if (rank[first] == rank[second]) {\n                rank[first]++;\n            }\n            setCount--;\n            color[second] = first;\n            if (listener != null) {\n                listener.joined(second, first);\n            }\n            return true;\n        }\n        public int get(int index) {\n            int start = index;\n            while (color[index] != index) {\n                index = color[index];\n            }\n            while (start != index) {\n                int next = color[start];\n                color[start] = index;\n                start = next;\n            }\n            return index;\n        }\n    }\n    static interface IndependentSetSystem {\n        public static interface Listener {\n            public void joined(int joinedRoot, int root);\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(array[i]);\n            }\n        }\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n        public void close() {\n            writer.close();\n        }\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[200001], a[200001], b[200001];\nint Find(int x) {\n  if (a[x] == x) return x;\n  return Find(a[x]);\n}\nvoid Union(int x, int y) {\n  x = Find(x), y = Find(y);\n  if (x != y) a[x] = y;\n}\nint main() {\n  int n, cnt = 0, sgn = 0;\n  cin >> n;\n  for (int i = 0; i <= n; ++i) a[i] = i, b[i] = false;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n    if (p[i] != i && Find(i) == Find(p[i]))\n      p[i] = i, sgn++, b[i] = true;\n    else\n      Union(i, p[i]);\n  }\n  int flag = 0, root = 0, tmp = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (p[i] == i) {\n      if (b[i] == false) {\n        root = i, flag = 1;\n        break;\n      }\n      tmp = i;\n    }\n  }\n  if (flag != 1) root = tmp, cnt++;\n  flag = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (i != root && p[i] == i) {\n      tmp = Find(i);\n      a[tmp] = root;\n      p[i] = root;\n      cnt++, flag++;\n    }\n  }\n  cout << cnt << endl << p[1];\n  for (int i = 2; i <= n; ++i) cout << \" \" << p[i];\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MOD = 1000 * 1000 * 1000 + 7;\nint n;\nvector<int> P;\nvector<bool> marked;\nvector<int> root;\nvoid dfs(int v) {\n  if (marked[v]) return;\n  marked[v] = true;\n  set<int> seen{v};\n  while (seen.find(P[v]) == seen.end()) {\n    v = P[v];\n    if (marked[v]) return;\n    marked[v] = true;\n    seen.insert(v);\n  }\n  root.push_back(v);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  P.resize(n);\n  marked.resize(n);\n  for (int i = 0; i < n; ++i) {\n    int par;\n    cin >> par;\n    P[i] = --par;\n  }\n  for (int i = 0; i < n; ++i) dfs(i);\n  int real_root = -1;\n  for (int i = 0; i < root.size(); ++i)\n    if (P[root[i]] == root[i]) {\n      real_root = root[i];\n      break;\n    }\n  int ans = root.size() - 1;\n  if (real_root == -1) {\n    real_root = root[0];\n    ++ans;\n  }\n  for (int i = 0; i < root.size(); ++i) P[root[i]] = real_root;\n  cout << ans << endl;\n  for (int i = 0; i < n; ++i)\n    if (i < n - 1)\n      cout << P[i] + 1 << ' ';\n    else\n      cout << P[i] + 1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ar[200001];\nbool visited[200001];\nbool visiting[200001];\nint root = 0;\nint c = 0;\nint n;\nvoid func(int u) {\n  if (visited[u]) return;\n  visited[u] = true;\n  visiting[u] = true;\n  if (visiting[ar[u]]) {\n    if (root == 0 && ar[u] == u) {\n      root = u;\n    } else if (ar[u] != root) {\n      c++;\n      ar[u] = 0;\n    }\n  } else\n    func(ar[u]);\n  visiting[u] = false;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    visiting[i] = false;\n    visited[i] = false;\n    cin >> ar[i];\n  }\n  for (int i = 1; i <= n; ++i) func(i);\n  int pr = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (ar[i] != 0) continue;\n    if (root != 0) {\n      if (ar[i] == 0) ar[i] = root;\n    } else {\n      if (pr == 0) {\n        pr = i;\n        ar[i] = pr;\n      } else\n        ar[i] = pr;\n    }\n  }\n  cout << c << \"\\n\";\n  for (int i = 1; i <= n; ++i) cout << ar[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n\tstatic final int EXP = 1, VIS = 2, UNVIS = 0;\n\tstatic int ans;\n\tstatic int[] p, state;\n\tstatic boolean[] inCycle;\n\t\n\tstatic void dfs(int u)\n\t{\n\t\tstate[u] = EXP;\n\t\tif(p[u] == u)\n\t\t{\n\t\t\tstate[u] = VIS;\n\t\t\treturn;\n\t\t}\n\t\tif(state[p[u]] == UNVIS)\n\t\t\tdfs(p[u]);\n\t\telse if(state[p[u]] == EXP)\n\t\t{\n\t\t\t++ans;\n\t\t\tp[u] = u;\n\t\t\tinCycle[u] = true;\n\t\t}\n\t\tstate[u] = VIS;\n\t}\n\t\n\t//stackoverflow\n\tpublic static void sol() throws IOException \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\t\tp = new int[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tp[i] = sc.nextInt() - 1;\n\t\tstate = new int[n];\n\t\tinCycle = new boolean[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(state[i] == UNVIS)\n\t\t\t\tdfs(i);\n\t\t\n\t\tint root = -1;\n\t\tfor(int i = 0; root == -1 && i < n; ++i)\n\t\t\tif(p[i] == i && !inCycle[i])\n\t\t\t\troot = i;\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(i != root && p[i] == i)\n\t\t\t\tif(root == -1)\n\t\t\t\t\troot = i;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(!inCycle[i])\n\t\t\t\t\t\t++ans;\n\t\t\t\t\tp[i] = root;\n\t\t\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(ans+\"\\n\");\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tsb.append((p[i] + 1) + \" \");\n\t\tout.println(sb);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\t\n\tpublic static void main(String[] args) {new Thread(null, new Runnable() { public void run() {try {\n\t\tsol();\n\t} catch (IOException e) {\n\t\t\n\t\te.printStackTrace();\n\t}}}, \"2\",1<<26).start();}\n\t\n\t\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\npublic class B {\t\n\tBufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter out;\n\n    public void go(ArrayList<Integer> sorted, boolean[] reached, int[] parents, int cur) {\n        if (reached[cur]) return;\n        reached[cur] = true;\n        go (sorted, reached, parents, parents[cur]);\n        sorted.add(cur);\n    }\n\n\tpublic void solve() throws IOException {\t\t\t\t\n\t\tint N = nextInt();\n\t\tint[] parents = new int[N];\n        for (int i = 0; i < N; i++) {\n            parents[i] = nextInt()-1;\n        }\n\n        ArrayList<Integer> sorted = new ArrayList<Integer>();\n        boolean[] visited = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            go(sorted, visited, parents, i);\n        }\n\n        Collections.reverse(sorted);\n//        for (int v: sorted) {\n//            out.println(v);\n//        }\n\n        boolean[] loopRoot = new boolean[N];\n        boolean[] root = new boolean[N];\n        Arrays.fill(visited, false);\n        for (int v: sorted) {\n            if (visited[v]) continue;\n\n            int cur = v;\n            visited[cur] = true;\n            HashSet<Integer> seen = new HashSet<Integer>();\n            seen.add(cur);\n            while (!visited[parents[cur]]) {\n//                if (v == 0) out.println(\"-->\" + cur);\n\n                cur = parents[cur];\n                visited[cur] = true;\n                seen.add(cur);\n            }\n\n            if (seen.contains(parents[cur])) {\n                loopRoot[cur] = true;\n            }\n        }\n\n\n\n//        boolean[] reached = new boolean[N];\n//        boolean[] loopRoot = new boolean[N];\n//        boolean[] root = new boolean[N];\n//        for (int i = 0; i < N; i++) {\n//            if (reached[i]) continue;\n//\n//            if (parents[i] == i) {\n//                reached[i] = true;\n//                continue;\n//            }\n//\n//            int cur = i;\n//            while (!reached[parents[cur]]) {\n//                reached[cur] = true;\n//                cur = parents[cur];\n//            }\n//\n//            if (parents[cur] != cur) {\n//                loopRoot[cur] = true;\n//            }\n//        }\n        for (int i = 0; i < N; i++) {\n            if (i == parents[i]) {\n                root[i] = true;\n            }\n        }\n\n\n//        for (int i = 0; i < N; i++) {\n//            out.println(i + \": \" + root[i] + \", \" + loopRoot[i]);\n//        }\n\n        int ansRoot = -1;\n        for (int i = 0; i < N; i++) {\n            if (root[i]) ansRoot = i;\n        }\n\n        int ans = 0;\n        if (ansRoot == -1) {\n            for (int i = 0; i < N; i++) {\n                if (loopRoot[i]) {\n                    loopRoot[i] = false;\n                    ansRoot = i;\n                    parents[i] = i;\n                    ans++;\n                    break;\n                }\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (i != ansRoot && (root[i] || loopRoot[i])) {\n                parents[i] = ansRoot;\n                ans++;\n            }\n//            out.println(i + \": \" + root[i] + \", \" + loopRoot[i]);\n        }\n\n        out.println(ans);\n        for (int i = 0; i < N; i++) {\n            out.print((parents[i] +1)+ \" \");\n        }\n        out.println();\n\n\t}\n\n    public void go(int[] parents, boolean[] reached, int cur) {\n        if (reached[parents[cur]]) {\n\n        }\n    }\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\t\n\tpublic void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            out = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <int um>\nclass UF {\n public:\n  vector<int> par;\n  UF() {\n    par = vector<int>(um, 0);\n    for (int i = 0; i < um; i++) par[i] = i;\n  }\n  int operator[](int x) {\n    return par[x] == x ? x : par[x] = operator[](par[x]);\n  }\n  void operator()(int x, int y) {\n    x = operator[](x);\n    y = operator[](y);\n    if (x != y) par[x] = y;\n  }\n};\nint n;\nint a[201010];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n  UF<201010> uf;\n  vector<int> roots, loops;\n  for (int i = 0; i < n; i++) {\n    if (a[i] == i) {\n      roots.push_back(i);\n      continue;\n    }\n    if (uf[i] == uf[a[i]])\n      loops.push_back(i);\n    else\n      uf(i, a[i]);\n  }\n  int ans = 0;\n  if (roots.size() == 0) {\n    if (loops.size() != 0) {\n      int root = loops[0];\n      a[root] = root;\n      ans++;\n      for (int i = 1; i < loops.size(); i++) a[loops[i]] = root, ans++;\n    }\n  } else {\n    int root = roots[0];\n    a[root] = root;\n    for (int i = 1; i < roots.size(); i++) a[roots[i]] = root, ans++;\n    for (int i = 0; i < loops.size(); i++) a[loops[i]] = root, ans++;\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 0; i < n; i++) printf(\"%d \", a[i] + 1);\n  printf(\"\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nint n;\nint a[200010];\nint par[200010];\nint find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\nint unio(int x, int y) {\n  int _x = find(x);\n  int _y = find(y);\n  if (_x != _y) par[_x] = _y;\n}\nint main() {\n  cin >> n;\n  int root = 0, ans = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    par[i] = i;\n    if (a[i] == i) root = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (i == root) continue;\n    if (i == a[i] && i != root) {\n      a[i] = root;\n      ans++;\n    } else {\n      if (find(i) != find(a[i])) {\n        unio(i, a[i]);\n      } else {\n        ans++;\n        if (!root) {\n          a[i] = i;\n          root = i;\n          continue;\n        }\n        a[i] = root;\n      }\n    }\n  }\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << a[i] << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        new Main().run(in, out);\n        out.close();\n    }\n\n    int N;\n    List<Integer>[] adj;\n    void run(FastScanner in, PrintWriter out) {\n\n        N = in.nextInt();\n\n        LinkedList<Integer> freeSet = new LinkedList<>();\n        int[] a = new int[N+1];\n        UnionFind uf = new UnionFind(N);\n        int count = 0;\n\n        int root = -1;\n        for (int u = 1; u <= N; u++) {\n            int v = in.nextInt();\n            a[u] = v;\n\n            if (uf.findParent(u) != uf.findParent(v)) {\n                uf.merge(u, v);\n                continue;\n            }\n\n            if (u == v && root == -1) {\n                root = u;\n                continue;\n            }\n\n            count++;\n            // already same union\n            if (!freeSet.isEmpty()) {\n                int top = freeSet.pollFirst();\n                a[top] = u;\n                uf.merge(top, u);\n            }\n            freeSet.offer(u);\n        }\n\n        if (!freeSet.isEmpty()) {\n            int top = freeSet.pollFirst();\n            if (root == -1) a[top] = top;\n            else a[top] = root;\n        }\n\n        out.println(count);\n        for (int i = 1; i <= N; i++) {\n            out.print(a[i] + \" \");\n        }\n        out.println();\n\n\n\n    }\n\n    class UnionFind {\n        int[] parent;\n        int[] rank;\n        UnionFind(int N) {\n            parent = new int[N+1];\n            rank = new int[N+1];\n            for (int i = 1; i <= N; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int findParent(int x) {\n            int init = x;\n            while (x != parent[x]) x = parent[x];\n            return parent[init] = x;\n        }\n\n        void merge(int x, int y) {\n            int px = findParent(x);\n            int py = findParent(y);\n            if (px == py) return;\n\n            int rx = rank[px];\n            int ry = rank[py];\n            if (rx <= ry) {\n                parent[px] = py;\n                if (rx == ry) rank[py]++;\n            } else {\n                parent[py] = px;\n            }\n        }\n\n    }\n\n\n\n\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (~(1 << 31)) - 5;\nint n, rt;\nint a[200005], vis[200005], cnt, ans;\nvoid work(int x) {\n  ++cnt;\n  int t = x;\n  vis[x] = cnt;\n  while (!vis[a[t]]) {\n    vis[a[t]] = cnt;\n    t = a[t];\n  }\n  if (vis[a[t]] == cnt) {\n    if (!rt) rt = t;\n    if (a[t] != rt) a[t] = rt, ans++;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == i) rt = i;\n  }\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) work(i);\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) printf(\"%d \", a[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint var, p[200001], root = -1, n, cnt, T = 0, v[200001];\nvoid dfs(int s) {\n  v[s] = T;\n  if (!v[p[s]])\n    dfs(p[s]);\n  else {\n    if (v[p[s]] == T) {\n      if (root == -1) {\n        cnt++;\n        p[s] = s;\n        root = s;\n      } else if (s != root) {\n        cnt++;\n        p[s] = root;\n      }\n    }\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    if (i == p[i]) root = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!v[i]) {\n      T++;\n      dfs(i);\n    }\n  }\n  cout << cnt << endl;\n  for (int i = 1; i <= n; i++) cout << p[i] << \" \";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class _698_B {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[] a = new int[n];\n\t\tint[] res = new int[n];\n\t\tStringTokenizer line = new StringTokenizer(in.readLine());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(line.nextToken()) - 1;\n\t\t\tres[i] = a[i];\n\t\t}\n\t\tint[] components = new int[n];\n\t\tint curcomp = 1;\n\t\tArrayList<Integer> reps = new ArrayList<Integer>();\n\t\tint head = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(components[i] != 0) continue;\n\t\t\tint rep = dfs(a, i, components, curcomp);\n\t\t\tcurcomp++;\n\t\t\tif(rep == -1) continue;\n\t\t\treps.add(rep);\n\t\t\tif(a[rep] == rep) head = rep;\n\t\t}\n\t\tint count = 0;\n\t\tif(head == -1) {\n\t\t\thead = reps.get(0);\n\t\t\tres[reps.get(0)] = reps.get(0); \n\t\t\tcount++;\n\t\t}\n\t\tfor(int i = 0; i < reps.size(); i++) {\n\t\t\tif(reps.get(i) == head) continue;\n\t\t\tres[reps.get(i)] = head;\n\t\t\tcount++;\n\t\t}\n\t\tout.println(count);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tsb.append(res[i] + 1);\n\t\t\tsb.append(' ');\n\t\t}\n\t\tout.println(sb.toString());\n\t\tin.close();\n\t\tout.close();\n\t}\n\tstatic int dfs(int[] a, int node, int[] components, int curcomp) {\n\t\tif(components[node] == curcomp) return node;\n\t\tif(components[node] != 0) return -1;\n\t\tcomponents[node] = curcomp;\n\t\treturn dfs(a, a[node], components, curcomp);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Luck{\n\tpublic static InputReader sc;\n    public static PrintWriter out;\n    public static final long MOD = (long) (1e9 + 7);\n    static int[] visited;\n    public static void main(String[] args){\n    \tsc=new InputReader(System.in);\t\n    \tout=new PrintWriter(System.out);\n    \tint n=sc.nextInt();\n    \tint[] A=new int[n+1];\n    \tvisited=new int[n+1];\n    \tfor(int i=1;i<=n;i++){\n    \t\tA[i]=sc.nextInt();\n    \t}\n    \tint round=1;\n    \tint root=0;\n    \tTreeSet<Integer> set=new TreeSet<Integer>();\n    \tfor(int i=1;i<=n;i++){\n    \t\tif(visited[i]!=0){\n    \t\t\tcontinue;\n    \t\t}\n    \t\tint curr=i;\n    \t\tint par=A[i];\n    \t\twhile(true){\n    \t\t\t//out.println(curr+\" \"+par+\" \"+root);\n    \t\t\tif(visited[curr]>0){\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tvisited[curr]=round;\n    \t\t\tif(par==curr){\n    \t\t\t\tif(root==0){\n    \t\t\t\t\troot=curr;\n    \t\t\t\t}\n    \t\t\t\telse if(curr!=root){\n    \t\t\t\t\tset.add(curr);\n    \t\t\t\t\t//out.println(\"add1: \"+curr);\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tif(visited[curr]==visited[par]){\n    \t\t\t\tset.add(curr);\n    \t\t\t\t//out.println(\"add2: \"+curr);\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tcurr=par;\n    \t\t\tpar=A[curr];\n    \t\t}\n    \t\tround+=1;\n    \t}\n    \tout.println(set.size());\n    \tif(root==0){\n    \t\troot=set.first();\n    \t}\n    \tfor(int i:set){\n    \t\tA[i]=root;\n    \t}\n    \tfor(int i=1;i<=n;i++){\n    \t\tout.print(A[i]+\" \");\n    \t}\n        out.close();\n    }\n    static int gcd(int a,int b){\n    \tif(b==0){\n    \t\treturn a;\n    \t}\n    \treturn gcd(b,a%b);\n    \t\n    }\n    static int lcm(int a,int b){\n    \tint g;\n    \tif(a<b){\n    \t\tg=gcd(b,a);\n    \t}\n    \telse{\n    \t\tg=gcd(a,b);\n    \t}\n    \treturn (a*b)/g;\n    }\n    static long bigmod ( long a, long p, long m ) {\n        long res = 1 % m, x = a % m;\n        while ( p>0 ) {\n            if ( (p & 1)==1 ) res = ( res * x ) % m;\n            x = ( x * x ) % m; p >>= 1;\n        }\n        return res;\n    }\n    static boolean isPrime(int n){\n    \t if (n == 2)\n    \t        return true;\n    \t    for (long i = 2; i * i <= n; i++) {\n    \t        if (n % i == 0)\n    \t            return false;\n    \t    }\n    \t    return true;\n    }\n    \n    static void shuffle(int[] A){\n    \tfor(int i=A.length-1;i>0;i--){\n    \t\tint j=(int)(Math.random()*(i+1));\n    \t\tint temp=A[j];\n    \t\tA[j]=A[i];\n    \t\tA[i]=temp;\n    \t}\n    }\n    \n\tpublic static class Node implements Comparable<Node>{\n\t    int u;\n\t    int v;\n\t    public Node(){\n\t    \t;\n\t    }\n\t    public Node (int u, int v) {\n\t    \tthis.u = u;\n\t        this.v = v;\n\t    }\n\t    \n\t    public void print() {\n\t        out.println(v + \" \" + u + \" \");\n\t    }\n\t   \n\t    public int compareTo(Node n1){\n\t    \treturn this.u-n1.u;\n\t    }\n\t}\n\n\tpublic static BigInteger pow(BigInteger base, BigInteger exp) {\n\t    if(exp.equals(new BigInteger(String.valueOf(0)))){\n\t        return new BigInteger(String.valueOf(1));\n\t    }    \n\t    if(exp.equals(new BigInteger(String.valueOf(1))))\n\t        return base;\n\t    BigInteger temp=exp.divide(new BigInteger(String.valueOf(2)));\n\t    BigInteger val = pow(base, temp);\n\t    BigInteger result = val.multiply(val);\n\t    result=result.remainder(new BigInteger(String.valueOf(MOD)));\n\t    BigInteger AND=exp.and(new BigInteger(String.valueOf(1)));\n\t    if(AND.equals(new BigInteger(String.valueOf(1)))){\n\t        result = result.multiply(base);\n\t        result=result.remainder(new BigInteger(String.valueOf(MOD)));\n\t    }    \n\t    return result;\n\t}\n\t    \n\tstatic class InputReader {\n\n\t    private InputStream stream;\n\t    private byte[] buf = new byte[8192];\n\t    private int curChar, snumChars;\n\t    private SpaceCharFilter filter;\n\n\t    public InputReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\n\t    public int snext() {\n\t        if (snumChars == -1)\n\t            throw new InputMismatchException();\n\t        if (curChar >= snumChars) {\n\t            curChar = 0;\n\t            try {\n\t                snumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (snumChars <= 0)\n\t                return -1;\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = snext();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public long nextLong() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = snext();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t        int a[] = new int[n];\n\t        for (int i = 0; i < n; i++)\n\t            a[i] = nextInt();\n\t        return a;\n\t    }\n\n\t    public String readString() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    public boolean isSpaceChar(int c) {\n\t        if (filter != null)\n\t            return filter.isSpaceChar(c);\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    public interface SpaceCharFilter {\n\t        public boolean isSpaceChar(int ch);\n\t    }\n\t}\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null,new Main(),\"\",1024L * 1024 * 100).start();\n\t}\n\n\tint n;\n\tint[] f;\n\tint[] col;\n\tint[] root;\n\t\n\t@Override\n\tpublic void run() {\n\t\tIO io = new IO();\n\t\tn = io.nextInt();\n\t\tf = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tf[i] = io.nextInt() - 1;\n\t\t}\n\t\tcol = new int[n];\n\t\troot = new int[n];\n\t\tArrays.fill(root, -1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (col[i] == 0) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tint superRoot = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (f[i] == i) {\n\t\t\t\tsuperRoot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tif (superRoot == -1) {\n\t\t\tsuperRoot = f[root[0]] = root[0];\n\t\t\tans++;\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (f[root[i]] != superRoot) {\n\t\t\t\tf[root[i]] = superRoot;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tio.println(ans);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tio.print(' ');\n\t\t\t}\n\t\t\tio.print(f[i] + 1);\n\t\t}\n\t\tio.println();\n\t\tio.flush();\n\t}\n\t\n\tpublic int dfs(int v) {\n\t\tcol[v] = 1;\n\t\tint r;\n\t\tint c = col[f[v]];\n\t\tif (c == 2) {\n\t\t\tr = root[f[v]];\n\t\t}else if(c == 1) {\n\t\t\tr = v;\n\t\t}else{\n\t\t\tr = dfs(f[v]);\n\t\t}\n\t\tcol[v] = 2;\n\t\treturn root[v] = r;\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint s[200005];\nint p[200005];\nvector<int> uv;\nint fd(int x) { return (p[x] == x) ? x : (p[x] = fd(p[x])); }\nint gp;\nvector<int> v;\nvoid merge(int x, int y) {\n  int tx = fd(x), ty = fd(y);\n  if (tx != ty) {\n    gp--;\n    p[tx] = ty;\n  } else {\n    v.push_back(x);\n  }\n}\nvoid init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &s[i]);\n    p[i] = i;\n    if (s[i] == i) uv.push_back(i);\n  }\n}\nvoid process() {\n  gp = n;\n  for (int i = 1; i <= n; i++) {\n    merge(i, s[i]);\n  }\n  if (uv.size() == 0) {\n    s[v[0]] = v[0];\n    uv.push_back(v[0]);\n    gp++;\n  }\n  printf(\"%d\\n\", gp - 1);\n  for (int i = 0; i < (int)v.size(); i++)\n    if (v[i] != uv[0]) {\n      s[v[i]] = uv[0];\n    }\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", s[i], \" \\n\"[i == n]);\n}\nint main() {\n  init();\n  process();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n\npublic class Main {\n    static int[]parent;\n    static int[]rank;\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        int n = in.nextInt();\n        int[]a = new int[n];\n        rank = new int[n];\n        for (int i =0;i<n;i++)\n            a[i]=in.nextInt()-1;\n        parent = new int[n];\n        for (int i=0;i<n;i++)\n            parent[i]=i;\n        int root = -1;\n        for( int i=0;i<n;i++)\n        {\n            if (a[i]==i)\n            {\n                root=i;\n\n            }\n        }\n        int ans=0;\n        List<Integer> l = new ArrayList<>();\n        for (int i =0;i<n;i++)\n        {\n\n            int p = getParent(i);\n            int p2 = getParent(a[i]);\n            if (p==p2&&i!=root)\n            {\n                l.add(i);\n                ans++;\n            }\n                parent[p] = p2;\n            rank[p2]++;\n\n\n        }\n\n        if (root==-1)\n        {\n            ans++;\n            root=l.get(0);\n            a[root]=root;\n\n\n        }\n\n\n        for (int i =0;i<l.size();i++)\n        {\n           if (l.get(i)!=root)\n           {\n               a[l.get(i)]=root;\n           }\n           else\n               ans--;\n        }\n\n        out.printLine(ans);\n        for (int item:a\n                ) {\n            out.print((1+item)+\" \");\n        }\n\n        out.flush();\n    }\n    static int getParent(int i)\n    {\n        while (i!=parent[i])\n            i=parent[i];\n        return i;\n    }\n\n\n}\n\n\nclass pair  implements Comparable\n{\n\n    int key;\n    int value;\n    public pair(Object key, Object value) {\n\n        this.key = (int)key;\n        this.value=(int)value;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        pair temp =(pair)o;\n        return  key-temp.key;\n    }\n}\nclass Graph {\n\n\n    int n;\n    ArrayList<Integer>[] adjList;\n\n    public Graph(int n) {\n        this.n = n;\n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            adjList[i] = new ArrayList<>();\n    }\n\n}\n\n\n\nclass InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (snumChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void flush() {\n        writer.flush();\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\n\n\nimport sun.reflect.generics.tree.Tree;\n\nimport javax.swing.event.TreeSelectionEvent;\nimport javax.swing.plaf.synth.SynthTextAreaUI;\nimport java.io.*;\nimport java.net.Inet4Address;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.awt.Point;\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.sol();\n            t--;\n        }\n        out.close();\n    }\n           /* static class descend implements Comparator<pair1> {\n                public int compare(pair1 o1, pair1 o2) {\n                    if (o1.pop != o2.pop)\n                        return (int) (o1.pop - o2.pop);\n                    else\n                        return o1.in - o2.in;\n                }\n            }*/\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String sn() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(sn());\n        }\n\n        public String snl() throws IOException {\n            return br.readLine();\n        }\n\n        public long nlo() {\n            return Long.parseLong(sn());\n        }\n\n        public double nd() {\n            return Double.parseDouble(sn());\n        }\n\n        public int[] na(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = sc.ni();\n            return a;\n        }\n\n        public long[] nal(int n) {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = sc.nlo();\n            return a;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o2.b - o1.b;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(int a[]) {\n            for (int i = 0; i < a.length; i++) {\n                int t = (int) Math.random() * a.length;\n                int x = a[t];\n                a[t] = a[i];\n                a[i] = x;\n            }\n        }\n\n        static void shufflel(long a[]) {\n            for (int i = 0; i < a.length; i++) {\n                int t = (int) Math.random() * a.length;\n                long x = a[t];\n                a[t] = a[i];\n                a[i] = x;\n            }\n        }\n\n        static int gcd(int a, int b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c) {\n                // System.out.println(i+\" /// \"+j);\n                return true;\n            } else {\n                //  System.out.println(i+\" //f \"+j);\n                return false;\n            }\n        }\n\n        static void seive() {\n            for (int i = 2; i < 101; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 101; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(LinkedList<Integer> a, long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a.get(mid) == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a.get(mid) > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(long x, long y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(long x, long y, long p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n\n               /* void dijsktra(int s, List<pair> l[], int n) {\n                    PriorityQueue<pair> pq = new PriorityQueue<>(new ascend());\n                    int dist[] = new int[100005];\n                    boolean v[] = new boolean[100005];\n                    for (int i = 1; i <= n; i++)\n                        dist[i] = 1000000000;\n                    dist[s] = 0;\n                    for (int i = 1; i < n; i++) {\n                        if (i == s)\n                            pq.add(new pair(s, 0));\n                        else\n                            pq.add(new pair(i, 1000000000));\n                    }\n                    while (!pq.isEmpty()) {\n                        pair node = pq.remove();\n                        v[node.a] = true;\n                        for (int i = 0; i < l[node.a].size(); i++) {\n                            int v1 = l[node.a].get(i).a;\n                            int w = l[node.a].get(i).b;\n                            if (v[v1])\n                                continue;\n                            if ((dist[node.a] + w) < dist[v1]) {\n                                dist[v1] = dist[node.a] + w;\n                                pq.add(new pair(v1, dist[v1]));\n                            }\n                        }\n                    }\n                }*/\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static int inf = 5000013;\n\n    static class solver {\n        DecimalFormat df = new DecimalFormat(\"0.00000000\");\n        extra e = new extra();\n        long mod = (long) (1000000007);\n\n        void sol() throws IOException {\n            int n = sc.ni();\n            int p[] = new int[n];\n            for (int i = 0; i < n; i++)\n                p[i] = i;\n            List<Integer> cycle = new ArrayList<>();\n            int a[] = new int[n];\n            int dic[] = new int[200005];\n            int size = 0;\n            for (int i = 0; i < n; i++) {\n                int u = sc.ni();\n                a[i] = u;\n                u -= 1;\n                int p1 = find(i, p);\n                int p2 = find(u, p);\n                if (i!=u && p1 == p2) {\n                    p[u] = u;\n                    p[p1] = u;\n                    cycle.add(u);\n                    size++;\n                    dic[u] = 1;\n                } else\n                    union(i, u, p);\n            }\n            for (int i = 0; i < n; i++)\n                find(i, p);\n            //System.out.println(Arrays.toString(p));\n            List<Integer> real = new ArrayList<>();\n            int dic2[] = new int[n];\n            int cnt = 0, ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (dic[p[i]] != 1) {\n                    real.add(p[i]);\n                    cnt++;\n                }\n                if (dic2[p[i]] == 0) {\n                    ans++;\n                    dic2[p[i]] = 1;\n                }\n            }\n            ans -= 1;\n            int prev = -1;\n            if (size > 0) {\n                for (int i = 1; i < size; i++) {\n                    int idx = cycle.get(i);\n                    int idx2 = cycle.get(i - 1);\n                    a[idx2] = idx + 1;\n                }\n                if (cnt == 0) {\n                    int idx = cycle.get(size - 1);\n                    a[idx] = idx + 1;\n                    ans++;\n                } else\n                    prev = cycle.get(size - 1);\n            }\n            if (prev != -1 || cnt > 0) {\n                for (int i = 0; i < cnt; i++) {\n                    if (prev == -1) {\n                        prev = real.get(i);\n                    } else {\n                        int curr = real.get(i);\n                        a[prev] = curr + 1;\n                        prev = curr;\n                    }\n                }\n                a[prev] = prev + 1;\n            }\n            out.println(ans);\n            for (int i = 0; i < n; i++)\n                out.print(a[i] + \" \");\n            out.println();\n        }\n\n        int find(int x, int p[]) {\n            if (p[x] == x)\n                return x;\n            p[x] = find(p[x], p);\n            return p[x];\n        }\n\n        void union(int x, int y, int p[]) {\n            int p1 = find(x, p);\n            int p2 = find(y, p);\n            p[p1] = p2;\n        }\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nconst int mod = 998244353;\nconst int inf = 0x3fffffff;\nint n, p[maxn], father[maxn], b[maxn];\nvoid init() {\n  for (int i = 1; i <= n; i++) father[i] = i;\n}\nint find_father(int x) {\n  int a = x;\n  while (x != father[x]) x = father[x];\n  while (a != father[a]) {\n    int z = a;\n    a = father[a];\n    father[z] = x;\n  }\n  return x;\n}\nvoid Union(int a, int b) {\n  int faA = find_father(a);\n  int faB = find_father(b);\n  if (faA != faB) father[faA] = faB;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  init();\n  int root = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    Union(i, p[i]);\n    if (i == p[i]) root = i;\n  }\n  int k = find_father(root);\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    int t = find_father(i);\n    if (b[t] == 0) {\n      cnt++;\n      if (t != k) p[t] = root;\n    }\n    b[t]++;\n  }\n  bool flag = false;\n  for (int i = 1; i <= n; i++) {\n    if (p[i] == 0) {\n      if (!flag) {\n        p[i] = i;\n        root = i;\n        flag = true;\n      } else\n        p[i] = root;\n    }\n  }\n  if (flag)\n    cout << cnt;\n  else\n    cout << cnt - 1;\n  cout << endl;\n  for (int i = 1; i <= n; i++) cout << p[i] << \" \";\n  return ~~(0 - 0);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tstatic int oo = (int)1e9;\n\tstatic int mod = 1_000_000_007;\n\t\n\tstatic int[] di = {-1, 1, 0, 0};\n\tstatic int[] dj = {0, 0, -1, 1};\n\t\n\tstatic int cnt = 0;\n\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = in.nextInt();\n\t\tint[] par = new int[n+1];\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tpar[i] = in.nextInt();\n\t\t}\n\t\tint root = -1;\n\t\tfor(int i = 1; i <=n; ++i) {\n\t\t\tif(par[i] == i)\n\t\t\t\troot = i;\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tif(par[i] == i && i != root) {\n\t\t\t\tpar[i] = root;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tboolean[] visit = new boolean[n+1];\n\t\tint[] r = new int[n+1];\n\t\tif(root == -1) {\n\t\t\troot = findRoot(par, r, visit, 1, root);\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tif(r[i] == 0) {\n\t\t\t\tfindRoot(par, r, visit, i, root);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tSystem.out.print(par[i] + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int findRoot(int[] par, int[] r, boolean[] visit, int i, int root) {\n\t\tif(par[i] == i)\n\t\t\treturn r[i] = i;\n\t\tif(r[i] != 0)\n\t\t\treturn r[i];\n\t\tif(visit[i]) {\n\t\t\tcnt++;\n\t\t\treturn r[i] = par[i] = (root == -1 ? i : root);\n\t\t}\n\t\tvisit[i] = true;\n\t\treturn r[i] = findRoot(par, r, visit, par[i], root);\n\t}\n\t\n\tstatic class SegmentTree {\n\t\tint n;\n\t\tlong[] a, seg;\n\t\tint DEFAULT_VALUE = 0;\n\t\t\n\t\tpublic SegmentTree(long[] a, int n) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.n = n;\n\t\t\tseg = new long[n * 4 + 1];\n\t\t\tbuild(1, 0, n-1);\n\t\t}\n\t\t\n\t\tprivate long build(int node, int i, int j) {\n\t\t\tif(i == j)\n\t\t\t\treturn seg[node] = a[i];\n\t\t\tlong first = build(node * 2, i, (i+j) / 2);\n\t\t\tlong second = build(node * 2 + 1, (i+j) / 2 + 1, j);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong update(int k, long value) {\n\t\t\treturn update(1, 0, n-1, k, value);\n\t\t}\n\t\t\n\t\tprivate long update(int node, int i, int j, int k, long value) {\n\t\t\tif(k < i || k > j)\n\t\t\t\treturn seg[node];\n\t\t\tif(i == j && j == k) {\n\t\t\t\ta[k] = value;\n\t\t\t\tseg[node] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = update(node * 2, i, m, k, value);\n\t\t\tlong second = update(node * 2 + 1, m + 1, j, k, value);\n\t\t\treturn seg[node] = combine(first, second);\n\t\t}\n\t\t\n\t\tlong query(int l, int r) {\n\t\t\treturn query(1, 0, n-1, l, r);\n\t\t}\n\t\t\n\t\tprivate long query(int node, int i, int j, int l, int r) {\n\t\t\tif(l <= i && j <= r)\n\t\t\t\treturn seg[node];\n\t\t\tif(j < l || i > r)\n\t\t\t\treturn DEFAULT_VALUE;\n\t\t\tint m = (i + j) / 2;\n\t\t\tlong first = query(node * 2, i, m, l, r);\n\t\t\tlong second = query(node * 2 + 1, m+1, j, l, r);\n\t\t\treturn combine(first, second);\n\t\t}\n \n\t\tprivate long combine(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n\t\n\tstatic class DisjointSet {\n\t\tint n;\n\t\tint[] g;\n\t\tint[] h;\n\t\tpublic DisjointSet(int n) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tg = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = i;\n\t\t\t\th[i] = 1;\n\t\t\t}\n\t\t}\n\t\tint find(int x) {\n\t\t\tif(g[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn g[x] = find(g[x]);\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = find(x); y = find(y);\n\t\t\tif(x == y)\n\t\t\t\treturn;\n\t\t\tif(h[x] >= h[y]) {\n\t\t\t\tg[y] = x;\n\t\t\t\tif(h[x] == h[y])\n\t\t\t\t\th[x]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tstatic int[] getPi(char[] a) {\n\t\tint m = a.length;\n\t\tint j = 0;\n\t\tint[] pi = new int[m];\n\t\tfor(int i = 1; i < m; ++i) {\n\t\t\twhile(j > 0 && a[i] != a[j])\n\t\t\t\tj = pi[j-1];\n\t\t\tif(a[i] == a[j]) {\n\t\t\t\tpi[i] = j + 1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn pi;\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n\t\t\n//\t\t@Override\n//\t\tpublic int compareTo(Pair o) {\n//\t\t\treturn this.first != o.first ? o.first - this.first : o.second - this.second;\n//\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct outFloat {\n  int precision;\n  long double value;\n  outFloat(long double v, int p) : precision(p), value(v) {}\n};\ntemplate <typename T>\nstruct debugInfo {\n  string name;\n  T val;\n  debugInfo(const char* n, T v) : name(n), val(v){};\n};\ntemplate <typename T>\ndebugInfo<T> makeDebugInfo(const char* n, T v) {\n  return debugInfo<T>(n, v);\n}\nconst int inf = 123456789;\nconst long long llInf = 123456789012345678LL;\nconst long double pi = 3.14159265358979323846;\nconst int maxN = 2000000;\nint init() {\n  ios_base::sync_with_stdio(0);\n  srand(time(NULL));\n  return 0;\n}\nint initializer = init();\ntemplate <typename T1, typename T2>\nistream& operator>>(istream& is, pair<T1, T2>& p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& p) {\n  for (int i = 0; i < p.size(); i++) is >> p[i];\n  return is;\n}\nclass inputer {\n private:\n  istream* istr;\n\n public:\n  inputer(istream& is) : istr(&is) {}\n  template <typename T>\n  void get(T& n) {\n    (*istr) >> n;\n  }\n  template <typename T, typename... Args>\n  void get(T& n, Args&... args) {\n    get(n);\n    get(args...);\n  }\n  template <typename... Args>\n  void getLn(Args&... args) {\n    get(args...);\n    getLn();\n  }\n  template <typename T>\n  operator T() {\n    T n;\n    get(n);\n    return n;\n  }\n  void getLn() {\n    string s;\n    getline(cin, s);\n  }\n  template <typename T>\n  void getv(vector<T>& v, int size) {\n    v.resize(size);\n    (*istr) >> v;\n  }\n};\nstring delim = \" \";\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& p) {\n  os << p.first << delim << p.second;\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& p) {\n  for (int i = 0; i < p.size(); i++) {\n    if (i != 0) os << delim;\n    os << p[i];\n  }\n  return os;\n}\nostream& operator<<(ostream& os, const outFloat& of) {\n  os << setprecision(of.precision) << of.value;\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const debugInfo<T>& dbg) {\n  os << \"\\\"\" << dbg.name << \"\\\" = \\\"\" << dbg.val << \"\\\"\"\n     << \"\\n\";\n}\nclass outputer {\n private:\n  ostream* ostr;\n\n public:\n  outputer(ostream& os) : ostr(&os) {}\n  template <typename T>\n  void put(const T& n) {\n    (*ostr) << n;\n  }\n  template <typename T, typename... Args>\n  void put(const T& n, const Args&... args) {\n    put(n);\n    put(args...);\n  }\n  template <typename... Args>\n  void putLn(const Args&... args) {\n    put(args...);\n    putLn();\n  }\n  template <typename T>\n  outputer& operator=(const T& n) {\n    putLn(n);\n    return *this;\n  }\n  void putLn() { (*ostr) << \"\\n\"; }\n  template <typename T>\n  void putv(vector<T> v, int size, string delim) {\n    for (int i = 0; i < size; i++) {\n      if (i != 0) (*ostr) << delim;\n      (*ostr) << v[i];\n    }\n  }\n};\ninputer in(cin);\noutputer out(cout);\nchar getChar() {\n  char c = 0;\n  while (c <= ' ') cin >> c;\n  return c;\n}\nbool willItBeAC() {\n  return true;\n  ;\n}\nint getMyRating() { return 2048; }\nbool prime(long long n) {\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nvector<long long> divs(long long n) {\n  vector<long long> v;\n  long long i = 2;\n  while (i * i <= n)\n    if (n % i == 0) {\n      n /= i;\n      v.push_back(i);\n    } else\n      i++;\n  v.push_back(n);\n  return v;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long extGcd(long long a, long long b, long long& x, long long& y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  long long x1, y1, d = extGcd(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return d;\n}\ntemplate <typename T>\nclass fenwick {\n private:\n  vector<T> t;\n  int n;\n\n public:\n  fenwick(int nn) { init(nn); }\n  void init(int nn) {\n    n = nn;\n    t.assign(n, 0);\n  }\n  T sum(int r) {\n    T result = 0;\n    for (; r >= 0; r = (r & (r + 1)) - 1) result += t[r];\n    return result;\n  }\n  void inc(int i, T delta) {\n    for (; i < n; i = (i | (i + 1))) t[i] += delta;\n  }\n  T sum(int l, int r) { return sum(r) - sum(l - 1); }\n  T get(int i) { return sum(i, i); }\n  void put(int i, T v) { inc(i, v - sum(i, i)); }\n  int size() { return n; }\n};\nint n = in;\nint cnt = 0;\nvector<int> q, tQ;\nvector<int> used(n, false);\nvector<vector<int> > g(n);\nvector<int> roots;\nint ses = 1;\nvoid dfs(int v, int sID) {\n  used[v] = sID;\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i];\n    if (used[to] == sID) q[to] = -1;\n    if (used[to]) continue;\n    dfs(to, sID);\n  }\n}\nint main() {\n  in.getv(q, n);\n  tQ = q;\n  for (int i = 0; i < n; i++) q[i]--;\n  for (int i = 0; i < n; i++)\n    if (q[i] == i)\n      roots.push_back(i);\n    else\n      g[q[i]].push_back(i);\n  for (int i : roots) dfs(i, ses++);\n  for (int i = 0; i < n; i++)\n    if (!used[i]) dfs(i, ses++);\n  int fM1 = -1;\n  for (int i = 0; i < n; i++)\n    if (q[i] < 0) fM1 = i;\n  for (int i = 0; i < n; i++)\n    if (q[i] == i) q[i] = -1;\n  if ((int)roots.size() == 0) roots.push_back(fM1);\n  for (int i = 0; i < n; i++)\n    if (q[i] < 0) q[i] = roots[0];\n  for (int i = 0; i < n; i++) q[i]++;\n  for (int i = 0; i < n; i++)\n    if (tQ[i] != q[i]) cnt++;\n  out = cnt;\n  out = q;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p[210000], used[210000], used2[210000], root, ans, good_root = -1;\nvector<int> l[210000];\nvector<int> comp;\nvector<int> roots;\nvoid dfs(int v) {\n  used[v] = 1;\n  comp.push_back(v);\n  int k = l[v].size();\n  for (int i = 0; i < k; i++) {\n    int v2 = l[v][i];\n    if (!used[v2]) dfs(v2);\n  }\n  return;\n}\nvoid cycle_dfs(int v) {\n  used2[v] = 1;\n  while (used2[p[v]] == 0) {\n    v = p[v];\n    used2[v] = 1;\n  }\n  root = p[v];\n  return;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    if (i != p[i]) {\n      l[i].push_back(p[i]);\n      l[p[i]].push_back(i);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!used[i]) {\n      comp.clear();\n      dfs(i);\n      root = -1;\n      int k = comp.size();\n      for (int j = 0; j < k; j++)\n        if (p[comp[j]] == comp[j] || p[p[comp[j]]] == comp[j]) {\n          root = comp[j];\n          break;\n        }\n      if (root == -1) {\n        cycle_dfs(i);\n      }\n      roots.push_back(root);\n    }\n  }\n  int k = roots.size();\n  for (int i = 0; i < k; i++) {\n    if (p[roots[i]] == roots[i]) {\n      good_root = roots[i];\n      break;\n    }\n  }\n  if (good_root == -1) {\n    good_root = roots[0];\n    p[roots[0]] = roots[0];\n    ans++;\n  }\n  for (int i = 0; i < k; i++) {\n    int rt = roots[i];\n    if (rt != good_root) {\n      p[rt] = good_root;\n      ans++;\n    }\n  }\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) cout << p[i] << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nvector<pair<int, int> > adj[MAXN];\nint n;\nbool mark[MAXN];\nint p[MAXN];\nint curv;\nvoid dfs(int v, int ind = -1) {\n  mark[v] = 1;\n  for (int i = 0; i < adj[v].size(); i++) {\n    pair<int, int> u = adj[v][i];\n    if (!mark[u.first]) {\n      dfs(u.first, u.second);\n    } else if (u.second != ind) {\n      curv = u.first;\n    }\n  }\n}\nint main() {\n  cin >> n;\n  int x;\n  int d = -1;\n  for (int i = 1; i <= n; i++) {\n    cin >> x;\n    if (x == i) {\n      d = i;\n    }\n    p[i] = x;\n    adj[i].push_back({x, i});\n    adj[x].push_back({i, i});\n  }\n  int cnt = 0;\n  vector<int> ve;\n  for (int i = 1; i <= n; i++) {\n    if (!mark[i]) {\n      dfs(i);\n      cnt++;\n      ve.push_back(curv);\n    }\n  }\n  if (d != -1) {\n    cout << cnt - 1 << '\\n';\n    for (int i = 0; i < ve.size(); i++) {\n      p[ve[i]] = d;\n    }\n    for (int i = 1; i <= n; i++) {\n      cout << p[i] << ' ';\n    }\n    return 0;\n  }\n  cout << cnt << '\\n';\n  for (int i = 0; i < ve.size(); i++) {\n    p[ve[i]] = ve[0];\n  }\n  for (int i = 1; i <= n; i++) {\n    cout << p[i] << ' ';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int SIZE = 1e6 + 10;\nint a[SIZE], u[SIZE], in[SIZE], tt;\nint main() {\n  int r = 0;\n  int(n);\n  scanf(\"%d\", &n);\n  for (int i = (1); i < (n + 1); ++i) scanf(\"%d\", &(a[i]));\n  vector<int> an;\n  for (int i = (1); i < (n + 1); ++i) {\n    if (!u[i]) {\n      tt++;\n      int x = i;\n      in[x] = tt;\n      u[x] = 1;\n      for (x = a[x]; !u[x]; x = a[x]) u[x] = 1, in[x] = tt;\n      if (in[x] == tt) {\n        if (x == a[x] || !r) r = x;\n        an.push_back(x);\n      }\n    }\n  }\n  int ker = (a[r] == r);\n  for (int i = 0; i < (((int)(an).size())); ++i) a[an[i]] = r;\n  printf(\"%d\\n\", ((int)(an).size()) - ker);\n  for (int i = (1); i < (n + 1); ++i) printf(\"%d \", a[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nlong long fac[1000006];\ninline long long exp(long long x, long long n) {\n  long long r = 1;\n  x = x;\n  while (n) {\n    if (n % 2) r = (r * x) % 1000000007;\n    x = (x * x) % 1000000007;\n    n = n / 2;\n  }\n  return r;\n}\ninline long long mmi(long long a) {\n  return exp(a, 1000000007 - 2) % 1000000007;\n}\ninline long long fact(long long n) {\n  long long res = 1;\n  for (long long i = 1; i < (n + 1); ++i) {\n    res = (res * i) % 1000000007;\n  }\n  return res;\n}\ninline void fact_a() {\n  fac[0] = 1;\n  fac[1] = 1;\n  for (long long i = 1; i < (105); ++i) {\n    fac[i] = (fac[i - 1] * i) % 1000000007;\n  }\n}\ninline long long inv_fact(long long n) {\n  long long par = fac[n];\n  long long res = mmi(par);\n  return res;\n}\ninline long long comb(long long n, long long r) {\n  if (n == r && r == 0) return 1;\n  if (n < r) return 0;\n  return ((fac[n] * inv_fact(r)) % 1000000007 * inv_fact(n - r)) % 1000000007;\n}\nstruct triplet {\n  long long a, b, c;\n};\nbool operator<(const triplet &t1, const triplet &t2) {\n  if (t1.a < t2.a) return true;\n  if (t1.a == t2.a && t1.b < t2.b) return true;\n  if (t1.a == t2.a && t1.b == t2.b && t1.c < t2.c) return true;\n  return false;\n}\npair<long long, pair<long long, long long> > ex_gcd(long long a, long long b) {\n  if (b == 0) {\n    return make_pair(a, make_pair(1, 0));\n  }\n  pair<long long, pair<long long, long long> > p = ex_gcd(b, a % b);\n  long long gcd = p.first;\n  long long x1 = p.second.first;\n  long long y1 = p.second.second;\n  long long x = y1;\n  long long y = x1 - (a / b) * y1;\n  return make_pair(gcd, make_pair(x, y));\n}\nlong long prime[3000006];\nlong long spf_prime[3000006];\nvoid sieve() {\n  prime[1] = 1;\n  for (long long i = 2; i * i <= 3000000; i++)\n    if (prime[i] == 0)\n      for (long long j = i * i; j <= 3000000; j += i) prime[j] = 1;\n}\nvoid spf() {\n  for (long long i = 2; i * i <= 3000000; i++)\n    if (!spf_prime[i])\n      for (long long j = i * i; j <= 3000000; j += i)\n        if (!spf_prime[j]) spf_prime[j] = i;\n  for (long long i = 2; i <= 3000000; i++)\n    if (!spf_prime[i]) spf_prime[i] = i;\n}\nlong long getparent_BIT(long long idx) { return idx - (idx & -idx); }\nlong long getnext_BIT(long long idx) { return idx + (idx & -idx); }\nlong long getsum_BIT(long long idx, long long BIT[], long long n) {\n  long long sum = 0;\n  while (idx > 0) {\n    sum += BIT[idx];\n    idx = getparent_BIT(idx);\n  }\n  return sum;\n}\nvoid update_BIT(long long idx, long long BIT[], long long val, long long n) {\n  while (idx <= n) {\n    BIT[idx] += val;\n    idx = getnext_BIT(idx);\n  }\n}\nvoid build_BIT(long long BIT[], long long a[], long long n) {\n  for (long long i = 0; i < (n); ++i) {\n    update_BIT(i, BIT, a[i], n);\n  }\n}\nvoid comp_lps(string s, long long lps[], long long n) {\n  long long i = 1, j = 0;\n  while (i < n) {\n    if (s[i] == s[j]) {\n      lps[i++] = ++j;\n    } else {\n      if (j != 0)\n        j = lps[j - 1];\n      else\n        lps[i++] = 0;\n    }\n  }\n}\nvoid dfs_l(long long u, vector<vector<long long> > &adj, long long status[]) {\n  if (status[u] == 1) return;\n  status[u] = 1;\n  for (long long i = 0; i < (adj[u].size()); ++i) dfs_l(adj[u][i], adj, status);\n}\nlong long dij(long long u, long long n,\n              vector<vector<pair<long long, long long> > > &adj,\n              long long status[]) {\n  long long dist[n];\n  for (long long i = 0; i < (n); ++i) dist[i] = 1000000000;\n  dist[0] = 0;\n  priority_queue<pair<long long, long long>,\n                 vector<pair<long long, long long> >,\n                 greater<pair<long long, long long> > >\n      q;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<long long, long long> p;\n    p = q.top();\n    q.pop();\n    long long x = p.second;\n    long long w = p.first;\n    if (status[x] == 1) continue;\n    status[x] = 1;\n    for (long long i = 0; i < (adj[x].size()); ++i) {\n      long long ww = adj[x][i].first;\n      long long y = adj[x][i].second;\n      if (dist[x] + ww < dist[y]) {\n        dist[y] = dist[x] + ww;\n        q.push(make_pair(dist[y], y));\n      }\n    }\n  }\n  if (dist[n - 1] >= 1000000000) return -1;\n  return dist[n - 1];\n}\nlong long phi(long long n) {\n  vector<long long> v;\n  long long k = n;\n  ;\n  for (long long i = 2; i * i <= n; i++) {\n    if (k % i == 0) {\n      v.push_back(i);\n      while (k % i == 0) k /= i;\n    }\n  }\n  if (k > 1) v.push_back(k);\n  long long ans = n;\n  for (long long i = 0; i < (v.size()); ++i) ans -= (ans / v[i]);\n  return ans;\n}\nstruct trie {\n  struct trie *left, *right;\n  bool isend;\n};\ntrie *get_trie() {\n  trie *ptr = new trie;\n  ptr->left = NULL;\n  ptr->right = NULL;\n  ptr->isend = false;\n  return ptr;\n}\nbool isempty(trie *root) {\n  if (root->left == NULL && root->right == NULL) return true;\n  return false;\n}\nvoid insert_trie(trie *root, string key) {\n  trie *ptr = root;\n  for (long long i = 0; i < (key.size()); ++i) {\n    if (key[i] == '0') {\n      if (ptr->left == NULL) {\n        ptr->left = get_trie();\n      }\n      ptr = ptr->left;\n    } else {\n      if (ptr->right == NULL) ptr->right = get_trie();\n      ptr = ptr->right;\n    }\n  }\n  ptr->isend = true;\n}\ntrie *remove_trie(trie *root, string key, long long idx = 0) {\n  if (root == NULL) return NULL;\n  if (idx == key.size()) {\n    if (isempty(root)) {\n      delete (root);\n      root = NULL;\n    }\n    return root;\n  }\n  if (key[idx] == '0')\n    root->left = remove_trie(root->left, key, idx + 1);\n  else\n    root->right = remove_trie(root->right, key, idx + 1);\n  if (isempty(root)) {\n    delete (root);\n    root = NULL;\n  }\n  return root;\n}\nlong long search_trie(trie *root, string key) {\n  trie *ptr = root;\n  string s = \"\";\n  for (long long i = 0; i < (key.size()); ++i) {\n    if (key[i] == '0') {\n      if (ptr->right != NULL) {\n        ptr = ptr->right;\n        s += '1';\n      } else {\n        ptr = ptr->left;\n        s += '0';\n      }\n    } else {\n      if (ptr->left != NULL) {\n        ptr = ptr->left;\n        s += '1';\n      } else {\n        ptr = ptr->right;\n        s += '0';\n      }\n    }\n  }\n  long long res = 0;\n  reverse(s.begin(), s.end());\n  for (long long i = s.length() - 1; i >= (0); --i)\n    res = res * 2 + (s[i] - '0');\n  return res;\n}\nstruct Comp {\n  bool operator()(const std::pair<int, int> &a, const std::pair<int, int> &b) {\n    if (a.first != b.first) {\n      return a.first < b.first;\n    }\n    return a.second > b.second;\n  }\n};\nvoid dearr() {\n  long long dar[1005];\n  dar[0] = 1;\n  dar[1] = 0;\n  dar[2] = 1;\n  for (long long i = 3; i < (1002); ++i) {\n    dar[i] = (i - 1) * (dar[i - 1] + dar[i - 2]);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (long long i = 0; i < (n); ++i) cin >> a[i];\n  for (long long i = 0; i < (n); ++i) a[i]--;\n  vector<long long> v;\n  long long status[n];\n  memset(status, 0, sizeof(status));\n  long long last;\n  long long ff = 1;\n  long long qq = 0;\n  long long id = -1;\n  for (long long i = 0; i < (n); ++i) {\n    if (status[i] == 0) {\n      long long k = i;\n      while (status[k] == 0) {\n        status[k] = ff;\n        last = k;\n        k = a[k];\n      }\n      if (status[k] == ff) {\n        if (a[last] != last)\n          qq++;\n        else\n          id = last;\n        a[last] = last;\n        v.push_back(last);\n      }\n      ff++;\n    }\n  }\n  long long ans = v.size() - 1;\n  if (v.size() == qq) ans++;\n  cout << ans << \"\\n\";\n  if (id != -1) {\n    for (long long i = 0; i < (v.size()); ++i) {\n      a[v[i]] = id;\n    }\n  } else {\n    for (long long i = 0; i < (v.size() - 1); ++i) {\n      a[v[i]] = v[v.size() - 1];\n    }\n  }\n  for (long long i = 0; i < (n); ++i) a[i]++;\n  for (auto i : a) cout << i << \" \";\n  cout << \"\\n\";\n  ;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Debabrata\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader scan, OutputWriter out) {\n            int n = scan.nextInt();\n            int noc = 0;\n            int p[] = new int[n];\n            int cycles[] = new int[n];\n            int root = -1;\n            for (int i = 0; i < n; i++) {\n                p[i] = scan.nextInt() - 1;\n                if (p[i] == i) root = i;\n            }\n            int a[] = new int[n];\n            int t = 1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == 0) {\n                    t++;\n                    int j = i;\n                    while (a[j] == 0) {\n                        a[j] = t;\n                        j = p[j];\n                    }\n                    if (a[j] == t) cycles[noc++] = j;\n                }\n            }\n//        out.println(noc);\n            cycles = Arrays.copyOf(cycles, noc);\n            int ans = noc - 1;\n//        out.println(root);\n            if (root < 0) {\n                ans++;\n                p[cycles[0]] = cycles[0];\n                root = cycles[0];\n            }\n            for (int i : cycles) {\n//            out.println(i);\n                if (p[i] == root) continue;\n                p[i] = root;\n            }\n            out.println(ans);\n            for (int i : p) {\n                out.print((i + 1) + \" \");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.io.*;\nimport java.math.*;\nimport java.text.DecimalFormat;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \tpublic InputReader(InputStream st) {\n            this.stream = st;\n\t} \n\tpublic int read() {\n            if (snumChars == -1)\n\t \tthrow new InputMismatchException();\n            if (curChar >= snumChars) {\n\t\tcurChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n\t\t} \n                catch (IOException e) {\n                    throw new InputMismatchException();\n           \t}\n\t\tif (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n\t}\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n               \tc = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n\t\tsgn = -1;\n\t\tc = read();\n            }\n            int res = 0;\n            do {\n\t\tres *= 10;\n\t\tres += c - '0';\n\t\tc = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n\t\ta[i] = ni();\n            }\n            return a;\n\t} \n\tpublic String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n\t\tc = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n\t\tres.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n\t}\n\tpublic String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n\t\tc = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n\tpublic boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n\t} \n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static boolean f,v[];\n    static int p[],root=-1;\n    public static void main(String[] args) throws IOException {   \n        InputReader sc=new InputReader(System.in);\n        int n=sc.ni();\n        \n        p=new int[n+1];\n        \n        int t[]=new int[n+1];\n        v=new boolean[n+1];\n        \n        for(int i=1;i<=n;i++){\n            \n            int a=sc.ni();\n            t[i]=a;\n            p[i]=a;\n            \n        }\n        for(int i=1;i<=n;i++){\n            if(i==p[i]){\n                root=i;\n                //break;\n            }\n        }\n        int c=0;\n        int temp[]=new int[n+1];\n        Arrays.fill(temp,-1);\n        for(int i=1;i<=n;i++){\n           \n                \n                \n                Set<Integer> set=new HashSet<Integer>();\n                int i1=i;\n                \n                while(i1!=p[i1]&&!v[i1]){                  \n                    \n                    set.add(i1);\n                    v[i1]=true;\n                    i1=p[i1];\n                }\n                v[i1]=true;\n                if(set.contains(i1)&&p[i1]!=i1){\n                    if(root==-1){\n                        root=i1;\n                        p[i1]=i1;\n                    }\n                    else{\n                        p[i1]=root;\n                    }\n                    c++;\n                }\n                else if(root!=i1&&p[i1]==i1){\n                    p[i1]=root;\n                    c++;\n                }\n                \n                \n                \n                \n                \n            }\n                \n\n        \n        w.println(c);\n        for(int i=1;i<=n;i++){\n            w.print(p[i]+\" \");\n        }\n        w.println();\n        w.close();\n    }\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 10;\nint a[maxn];\nint f[maxn];\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\nint main() {\n  int n;\n  int cot = 0;\n  int root = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) f[i] = i;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == i) {\n      cot++;\n      root = i;\n    } else {\n      int bossx = find(i);\n      int bossy = find(a[i]);\n      if (bossx == bossy) {\n        cot++;\n        a[i] = i;\n      } else\n        f[bossx] = bossy;\n    }\n  }\n  if (root == 0) {\n    for (int i = 1; i <= n; i++) {\n      if (f[i] == i) {\n        root = i;\n        cot++;\n        break;\n      }\n    }\n  }\n  printf(\"%d\\n\", cot - 1);\n  for (int i = 1; i <= n; i++) {\n    if (f[i] == i) a[i] = root;\n    if (i < n)\n      printf(\"%d \", a[i]);\n    else\n      printf(\"%d\\n\", a[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\ninline int read() {\n  int x = 0;\n  bool f = true;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = false;\n    c = getchar();\n  }\n  while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return f ? x : -x;\n}\nint f[N];\nint get(int x) { return x == f[x] ? x : f[x] = get(f[x]); }\nint n, p[N];\nint ans, root;\nint main() {\n  n = read();\n  for (register int i = 1; i <= n; ++i) f[i] = i;\n  for (register int i = 1; i <= n; ++i) {\n    p[i] = read();\n  }\n  for (register int i = 1; i <= n; ++i) {\n    if (i == p[i]) {\n      root = i;\n      break;\n    }\n  }\n  for (register int i = 1; i <= n; ++i) {\n    if (i == root) continue;\n    int fp = get(p[i]), fi = get(i);\n    if (fp == fi) {\n      if (!root) root = i;\n      fi = root, p[i] = root, ++ans;\n    }\n    f[fi] = fp;\n  }\n  printf(\"%d\\n\", ans);\n  for (register int i = 1; i <= n; ++i) printf(\"%d \", p[i]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt() - 1;\n            }\n            int[] col = new int[n];\n            Arrays.fill(col, -1);\n            int numCols = 0;\n            List<Integer> cycleRepr = new ArrayList<>();\n            List<Integer> cycleLens = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (col[i] >= 0) {\n                    continue;\n                }\n                int j;\n                for (j = i; col[j] < 0; j = p[j]) {\n                    col[j] = numCols;\n                }\n                if (col[j] == numCols) {\n                    // found a new cycle\n                    int len = 1;\n                    for (int k = p[j]; k != j; k = p[k]) {\n                        ++len;\n                    }\n                    cycleRepr.add(j);\n                    cycleLens.add(len);\n                }\n                ++numCols;\n            }\n            int root = cycleRepr.get(0);\n            boolean goodRoot = false;\n            for (int i = 0; i < cycleRepr.size(); i++) {\n                if (cycleLens.get(i) == 1) {\n                    goodRoot = true;\n                    root = cycleRepr.get(i);\n                }\n            }\n            int ans = cycleRepr.size();\n            if (goodRoot) {\n                --ans;\n            }\n            out.println(ans);\n            for (int x : cycleRepr) {\n                p[x] = root;\n            }\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    out.print(\" \");\n                }\n                out.print(p[i] + 1);\n            }\n            out.println();\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 100;\nint fa[maxn];\nint rt;\nint n, vis[maxn];\nvector<int> vec;\nint num;\nvoid dfs(int u) {\n  vec.push_back(u);\n  vis[u] = 2;\n  if (vis[fa[u]] == 1) return;\n  if (vis[fa[u]] == 2) {\n    num++;\n    if (rt == 0) {\n      rt = u;\n      fa[u] = u;\n    } else {\n      fa[u] = rt;\n    }\n  } else {\n    dfs(fa[u]);\n  }\n}\nvoid solve() {\n  int tag = 0;\n  rt = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i == fa[i]) {\n      tag = 1;\n      rt = i;\n      break;\n    }\n  }\n  num = 0;\n  memset(vis, 0, sizeof(vis));\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      vec.clear();\n      dfs(i);\n      for (int j = 0; j < vec.size(); j++) {\n        vis[vec[j]] = 1;\n      }\n    }\n  }\n  printf(\"%d\\n\", num - tag);\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d%c\", fa[i], (i == n ? '\\n' : ' '));\n  }\n}\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &fa[i]);\n    }\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round363;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] f = na(n);\n\t\tfor(int i = 0;i < n;i++)f[i]--;\n\t\tResultCluster res = cluster(f);\n\t\tint loop = -1;\n\t\tfor(int[] cy : res.cycles){\n\t\t\tif(cy.length == 1){\n\t\t\t\tloop = cy[0];\n\t\t\t}\n\t\t}\n\t\tif(loop == -1){\n\t\t\tout.println(res.cycles.length);\n\t\t\tfor(int i = 0;i < res.cycles.length;i++){\n\t\t\t\tf[res.cycles[i][0]] = res.cycles[0][0];\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tout.print((f[i]+1) + \" \");\n\t\t\t}\n\t\t}else{\n\t\t\tout.println(res.cycles.length-1);\n\t\t\tfor(int i = 0;i < res.cycles.length;i++){\n\t\t\t\tf[res.cycles[i][0]] = loop;\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tout.print((f[i]+1) + \" \");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static ResultCluster cluster(int[] f)\n\t{\n\t\tint n = f.length;\n\t\tDJSet ds = new DJSet(n);\n\t\tint[] red = new int[n+1];\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ds.union(i, f[i]))red[p++] = f[i];\n\t\t}\n\t\tint[] clus = new int[n]; Arrays.fill(clus, -1);\n\t\tint cidgen = 0;\n\t\tfor(int i = 0;i < n;i++)if(ds.upper[i] < 0)clus[i] = cidgen++;\n\t\tfor(int i = 0;i < n;i++)clus[i] = clus[ds.root(i)];\n\t\t\n\t\tint[][] cycles = new int[p][];\n\t\tint[] temp = new int[n+1];\n\t\tfor(int i = 0;i < p;i++){\n\t\t\ttemp[0] = red[i];\n\t\t\tint j = 1;\n\t\t\tfor(;;j++){\n\t\t\t\ttemp[j] = f[temp[j-1]];\n\t\t\t\tif(temp[j] == temp[0])break;\n\t\t\t}\n\t\t\tcycles[clus[red[i]]] = Arrays.copyOf(temp, j);\n\t\t}\n\t\tResultCluster rc = new ResultCluster();\n\t\trc.clus = clus;\n\t\trc.cycles = cycles;\n\t\treturn rc;\n\t}\n\t\n\tpublic static class ResultCluster {\n\t\tint[] clus;\n\t\tint[][] cycles;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long s[200005];\nlong long p[200005];\nlong long np[200005];\nlong long n;\nbool cmp(long long a, long long b) { return abs(p[a] - a) < abs(p[b] - b); }\nsigned main() {\n  cin >> n;\n  for (long long i = (0); i < (n); i++) {\n    cin >> p[i];\n    p[i]--;\n    np[i] = p[i];\n  }\n  vector<long long> v;\n  for (long long i = (0); i < (n); i++) {\n    set<long long> u;\n    long long j = i;\n    for (; !s[j]; j = p[j]) {\n      u.insert(j);\n      s[j] = 1;\n    }\n    if (u.count(j)) v.push_back(j);\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (long long i : v) np[i] = v[0];\n  long long ans = 0;\n  for (long long i : v) ans += (p[i] != np[i]);\n  cout << ans << '\\n';\n  for (long long i = (0); i < (n); i++) cout << np[i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n/**\n *\n * @author aziza\n */\npublic class DecreasingSequence {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n            ArrayList<Integer> vs = new ArrayList<>();\n            int[] orig = new int[N + 1];\n            int[] a = new int[N + 1];\n            boolean[] visit = new boolean[N + 1];\n            for (int i = 1; i <= N; i++) {\n                a[i] = in.nextInt();\n                orig[i] = a[i];\n                if (a[i] == i) {\n                    vs.add(i);\n                    visit[i] = true;\n                    continue;\n                }\n            }\n            int root = vs.isEmpty() ? -1 : vs.get(0);\n            for (int i = 1; i <= N; i++) {\n                if (visit[i]) continue;\n                visit[i] = true;\n                if (i == orig[i]) continue;\n                HashSet<Integer> visit2 = new HashSet<>();\n                visit2.add(i);\n                int p = orig[i];\n                while (true) {\n                    if (visit2.contains(p)) {\n                        if (root == -1) {\n                            root = p;\n                        }\n                        a[p] = root;\n                        break;\n                    }\n                    visit2.add(p);\n                    if (visit[p]) break;\n                    visit[p] = true;\n                    p = orig[p];\n                }\n            }\n            for (int i = 1; i < vs.size(); i++) {\n                a[vs.get(i)] = root;\n            }\n            int diff = 0;\n            for (int i = 1; i <= N; i++) {\n                if (orig[i] != a[i]) diff++;\n            }\n            System.out.println(diff);\n            for (int i = 1; i <= N; i++) {\n                if (i > 1) System.out.print(' ');\n                System.out.print(a[i]);\n            }\n            System.out.println();\n        \n        }\n\n    }\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  vector<int> used(n, 0);\n  vector<int> loops;\n  int root = -1;\n  int curUse = 1;\n  int cur, next;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  cur = 0;\n  for (int i = 0; i < n; i++) {\n    if (used[i]) {\n      continue;\n    }\n    cur = i;\n    while (true) {\n      used[cur] = curUse;\n      next = a[cur];\n      if (cur == next) {\n        if (root == -1) {\n          root = cur;\n        } else {\n          loops.push_back(cur);\n        }\n        break;\n      } else if (used[next] == curUse) {\n        loops.push_back(cur);\n        break;\n      } else if (used[next]) {\n        break;\n      }\n      cur = next;\n    }\n    curUse++;\n  }\n  int startIndex = 0;\n  if (root == -1) {\n    root = loops[0];\n    a[root] = root;\n    startIndex++;\n  }\n  for (int i = startIndex; i < loops.size(); i++) {\n    a[loops[i]] = root;\n  }\n  cout << loops.size() << endl;\n  for (int i : a) {\n    cout << i + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# [https://codeforces.com/contest/698/submission/42129034]\n\ninput()\n\nA = list(map(int, input().split(' ')))\n\nroot = -1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << endl;\n  err(++it, args...);\n}\ntemplate <class T, class U>\ninline void checkmin(T &x, U y) {\n  if (y < x) x = y;\n}\ntemplate <class T, class U>\ninline void checkmax(T &x, U y) {\n  if (y > x) x = y;\n}\ntemplate <class T, class U>\ninline bool ifmax(T &x, U y) {\n  if (y > x) return x = y, true;\n  return false;\n}\ntemplate <class T, class U>\ninline bool ifmin(T &x, U y) {\n  if (y < x) return x = y, true;\n  return false;\n}\nlong long fstpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a);\n    a = (a * a);\n    b >>= 1;\n  }\n  return res;\n}\nlong long powm(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return res;\n}\nbool sortinrev(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.first > b.first);\n}\nvoid fukof() {}\nvoid problem() {}\nconst long long mod = 1e9 + 7;\nconst long long N = 200005;\nconst long long inf = 1e9;\nvector<int> adj[N];\nint dsu[N];\nbool vis[N];\nvoid dfs(int src) {\n  if (vis[src])\n    return;\n  else\n    vis[src] = true;\n  if (src != adj[src][0]) dfs(adj[src][0]);\n  dsu[src] = dsu[adj[src][0]];\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  memset(vis, 0, sizeof(vis));\n  vector<int> a(n);\n  for (long long i = 0; i < (n); i++) {\n    cin >> a[i];\n  };\n  for (long long i = (1); i < (1 + n); i++)\n    adj[i].push_back(a[i - 1]), dsu[i] = i;\n  for (long long i = 0; i < (n); i++) dfs(i + 1);\n  vector<int> v;\n  for (long long i = (1); i < (1 + n); i++) {\n    v.push_back(dsu[i]);\n  }\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n  ;\n  if (v.size() == 1) {\n    if (a[v[0] - 1] != v[0]) {\n      cout << 1 << endl;\n      a[v[0] - 1] = v[0];\n      for (long long i = 0; i < (n); i++) {\n        cout << a[i] << \" \";\n      }\n      cout << endl;\n      ;\n      ;\n      return;\n    } else {\n      cout << 0 << endl;\n      for (long long i = 0; i < (n); i++) {\n        cout << a[i] << \" \";\n      }\n      cout << endl;\n      ;\n      ;\n      return;\n    }\n  } else {\n    int par = v[0];\n    int ans = v.size() - 1;\n    for (long long i = 0; i < (v.size()); i++) {\n      if (a[v[i] - 1] == v[i]) par = v[i];\n    }\n    if (a[par - 1] != par) ans++;\n    for (long long i = 0; i < (v.size()); i++) {\n      a[v[i] - 1] = par;\n    }\n    cout << ans << endl;\n    for (long long i = 0; i < (n); i++) {\n      cout << a[i] << \" \";\n    }\n    cout << endl;\n    ;\n    ;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(15);\n  int tc = 1;\n  while (tc--) {\n    problem();\n    fukof();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class CF698B {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputStream inputStream = System.in;\n//\t\tInputStream inputStream = new FileInputStream(new File(\"input\"));\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskA {\n\t\tint n;\n\t\tint [] a;\n\t\tint [] p;\n\n\t\tvoid makeSet(int id) {\n\t\t\tp[id] = id;\n\t\t}\n\n\t\tint find(int id) {\n\t\t\tif (p[id] != id) {\n\t\t\t\tp[id] = find(p[id]);\n\t\t\t}\n\t\t\treturn p[id];\n\t\t}\n\n\t\t// from x to y\n\t\tvoid union(int x, int y) {\n\t\t\tint px = find(x);\n\t\t\tint py = find(y);\n\t\t\tif (px == py)\n\t\t\t\treturn;\n\t\t\tp[px] = py;\n\t\t}\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tn = in.nextInt();\n\t\t\ta = new int[n + 1];\n\t\t\tp = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tmakeSet(i);\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\ta[i] = in.nextInt();\n\t\t\t\tunion(i, a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t\tunion(i, a[i]);\n\n\t\t\tHashSet<Integer> connectedComp = new HashSet<>();\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tconnectedComp.add(p[i]);\n\t\t\t}\n\n\t\t\tint r = connectedComp.size() - 1;\n\t\t\tList<Integer> roots = new ArrayList<>(connectedComp);\n\t\t\tint root = -1;\n\t\t\tfor (int i = 0; i < roots.size(); ++i) {\n\t\t\t\tint curRoot = roots.get(i);\n\t\t\t\tif (curRoot == a[curRoot]) {\n\t\t\t\t\troot = curRoot;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (root == -1) {\n\t\t\t\tr += 1;\n\t\t\t\troot = roots.get(0);\n\t\t\t\ta[root] = root;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < roots.size(); ++i) {\n\t\t\t\tint curRoot = roots.get(i);\n\t\t\t\tif (curRoot != root) {\n\t\t\t\t\ta[curRoot] = root;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(r);\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tout.print(a[i] + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * Hello world!\n *\n */\npublic class App {\n    private static int[] roots;\n    private static int[] parents;\n    public static void main(String[] args) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            String[] line;\n            line = reader.readLine().split(\" \");\n            int n = Integer.parseInt(line[0]);\n            roots = new int[n + 1];\n            parents = new int[n + 1];\n            int[] orgParent = new int[n + 1];\n            line = reader.readLine().split(\" \");\n            int root = -1;\n            for (int i = 0; i < line.length; ++i) {\n                int u = i + 1;\n                int v = Integer.parseInt(line[i]);\n                orgParent[u] = v;\n                if (find(u) != find(v)) {\n                    parents[u] = v;\n                    join(u, v);\n                } else {\n                    parents[u] = u;\n                    if (u == v) {\n                        root = u;\n                    }\n                }\n            }\n            if (root < 0) {\n                root = find(1);\n            }\n            int cnt = 0;\n            for (int i = 1; i <= n; ++i) {\n                if (parents[i] == i) {\n                    parents[i] = root;\n                }\n                if (parents[i] != orgParent[i]) {\n                    ++cnt;\n                }\n            }\n            System.out.println(cnt);\n            for (int i = 1; i <= n; ++i) {\n                System.out.print(parents[i] + \" \");\n            }\n        }\n    }\n\n    private static void join(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            roots[u] = v;\n        }\n    }\n\n    private static int find(int u) {\n        return roots[u] == u || roots[u] == 0 ? u : (roots[u] = find(roots[u]));\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\n// this is not good for reading double values.\npublic class Problem698B {\n\tstatic long m = 100000007;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader r = new Reader();\n\t\tPrintWriter o = new PrintWriter(System.out, false);\n\t\tint n = r.nextInt();\n\t\tint[] p = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tp[i] = r.nextInt();\n\t\tint[] seen = new int[n + 1];\n\t\tint root = -1;\n\t\tint numchanges = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (p[i] == i) {\n\t\t\t\tseen[i] = n + 1;\n\t\t\t\troot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (seen[i] != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen[i] = i;\n\t\t\tint at = i;\n\t\t\twhile (seen[p[at]] == 0) {\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = i;\n\t\t\t}\n\t\t\tif (seen[p[at]] == i) {\n\t\t\t\tnumchanges++;\n\t\t\t\tif (root != -1) {\n\t\t\t\t\tp[at] = root;\n\t\t\t\t} else {\n\t\t\t\t\troot = at;\n\t\t\t\t\tp[at] = at;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(numchanges);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.print(p[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\to.close();\n\t}\n\n\t// pair object x,y\n\tstatic class pair {\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tpair other = (pair) obj;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tint x, y;\n\n\t\tpublic pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t// gcd int no\n\tstatic int gcd(int n, int r) {\n\t\treturn r == 0 ? n : gcd(r, n % r);\n\t}\n\n\tstatic long[][] modPow(long[][] M, long exp) {\n\t\tlong[][] result = new long[][] { { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 1 } };\n\t\tlong[][] pow = M;\n\t\twhile (exp != 0) {\n\t\t\tif ((exp & 1) == 1) {\n\t\t\t\tresult = multiply(result, pow);\n\t\t\t}\n\t\t\texp >>>= 1;\n\t\t\tpow = multiply(pow, pow);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic long[][] multiply(long[][] A, long[][] B) {\n\t\tlong[][] C = new long[4][4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tlong value = 0;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tvalue += A[i][k] * B[k][j];\n\t\t\t\t}\n\t\t\t\tC[i][j] = value % m;\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\t// gcd long numbers\n\tstatic long gcd(long n, long r) {\n\t\treturn r == 0 ? n : gcd(r, n % r);\n\t}\n\n\t// input/output\n\tstatic class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[] readIntArray(int size) throws IOException {\n\t\t\tint[] arr = new int[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] readLongArray(int size) throws IOException {\n\t\t\tlong[] arr = new long[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  long long b = -1;\n  long long ans = -1;\n  for (long long i = (0); i < (n); i++) cin >> a[i], a[i]--;\n  for (long long i = (0); i < (n); i++)\n    if (i == a[i]) a[i] = b, b = i, ans++;\n  for (long long i = (0); i < (n); i++)\n    if (a[i] == -1) a[i] = i, b = i;\n  vector<long long> use(n, -1);\n  for (long long i = (0); i < (n); i++)\n    if (use[i] < 0 && i != b) {\n      long long fl = 0, c = i;\n      while (1) {\n        use[c] = i;\n        c = a[c];\n        if (c == b) break;\n        if (use[c] != i && use[c] >= 0) break;\n        if (use[c] == i) {\n          fl = 1;\n          break;\n        }\n      }\n      if (fl)\n        if (b != -1) a[c] = b, ans++;\n      if (fl)\n        if (b < 0) b = c, a[c] = c, ans = 1;\n    }\n  cout << ans << '\\n';\n  for (long long i = (0); i < (n); i++) cout << (a[i] + 1) << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[200001] = {};\nbool v[200001] = {};\nint find(int x) {\n  memset(v, 0, sizeof(v));\n  int k, j, r;\n  r = x;\n  v[r] = 1;\n  while (r != f[r]) {\n    if (v[f[r]]) {\n      f[r] = r;\n      break;\n    }\n    r = f[r];\n    v[r] = 1;\n  }\n  k = x;\n  while (k != r) {\n    j = f[k];\n    f[k] = r;\n    k = j;\n  }\n  return r;\n}\nint rf[200001] = {};\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    f[i] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> f[i];\n    rf[i] = f[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    find(i);\n  }\n  int count = 0;\n  int orig = 0;\n  bool orig_great = false;\n  for (int i = 1; i <= n; i++) {\n    if (f[i] == i) {\n      if (rf[i] == i) {\n        orig = i, orig_great = true;\n        break;\n      } else {\n        orig = i;\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (f[i] == i) {\n      if (rf[i] != orig) count++;\n      rf[i] = orig;\n    }\n  }\n  cout << count << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << rf[i] << (i < n ? \" \" : \"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint a[maxn], fa[maxn], cnt = 0;\npair<int, int> pa[maxn];\nint find(int x) {\n  if (x != fa[x]) {\n    fa[x] = find(fa[x]);\n  }\n  return fa[x];\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    fa[i] = i;\n  }\n  int pos = -1;\n  for (int i = 1; i <= n; i++) {\n    int x = find(i), y = find(a[i]);\n    if (x != y) {\n      fa[x] = y;\n    } else {\n      if (i == a[i]) {\n        pos = cnt;\n      }\n      pa[cnt++] = make_pair(i, a[i]);\n    }\n  }\n  if (pos == -1) {\n    pos = 0;\n    cnt++;\n    a[pa[0].first] = pa[0].first;\n  }\n  for (int i = 0; i < cnt; i++) {\n    if (i == pos) continue;\n    a[pa[i].first] = pa[pos].first;\n  }\n  printf(\"%d\\n\", cnt - 1);\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", a[i]);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.*;\n\n\n \n \npublic class ck {\n\n\tprivate static InputStream stream;\n\tprivate static PrintWriter pw;\n\t\n\t\n\t\n//\tstatic int a;\n//\tstatic int b;\n//\tstatic int f = 0;\n\tstatic int n;\n\tstatic int m;\n\tstatic int parent[];\n\n\t\n//\tstatic int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\n//\tstatic ArrayList<Integer> ans;\n\n//\tstatic int arr[][];\n//\tstatic int arr[];\n//\tstatic char[][] arr;\n\tstatic int[] visited;\n\t//static int c;\n\tstatic int d[];\n//\tstatic int arr[][];\n\tstatic ArrayList<Integer> arr[];\n\tstatic Stack<Integer> stack;\n\tstatic int c;\n\t\n\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException{\n\t\t//InputReader(System.in);\n\t\t//pw = new PrintWriter(System.out);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tn = in.nextInt();\n\t\tin.nextLine();\n\t\tint arr[] = new int[n];\n\t\t\n\t\tint root = -1;\n\t\tparent  = new int[n];\n\t\t\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tarr[i] = in.nextInt()-1;\n\t\t\tif(arr[i] == i){\n\t\t\t\troot = i;\n\t\t\t}\n\t\t\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tif(find(i) != find(arr[i])){\n\t\t\t\tunion(i,arr[i]);\n\t\t\t}else{\n\t\t\t\tif(root==-1){\n\t\t\t\t\troot = find(i);\n\t\t\t\t//\tSystem.out.println(find(i));\n\t\t\t\t}\n\t\t\t\t\tif(arr[i] != root){\n\t\t\t\t\t\tarr[i] = root;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tSystem.out.print(arr[i]+1 + \" \");\n\t\t}\n\t\t\n\t\t\n\t\t\t\n}\n\t\n\tpublic static void union(int a,int b){\n\t\ta = find(a);\n\t\tb = find(b);\n\t\t\n\t\tparent[a] = b;\n\t\treturn;\n\t}\n\t\n\tpublic static int find(int i){\n\t\tif(i == parent[i]){\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tparent[i] = find(parent[i]);\n\t\treturn parent[i];\n\t}\n\t\n//\tpublic static void dfs(int i){\n//\t\t\n//\t\t\n//\t\tif(visited[i] == 1){\n//\t\t\treturn;\n//\t\t}\n//\t\t\n//\t\tvisited[i] = 1;\n//\t\tcon[c].add(i);\n//\t\t//System.out.print(i + \" \");\n//\t\tfor(int j = 0;j<arr[i].size();j++){\n//\t\t\tdfs(arr[i].get(j));\n//\t\t}\n//\t\t\n//\t}\n//\t\n//\t\n//\tpublic static void dfss(int i){\n//\t\tif(visited[i] == 1){\n//\t\t\treturn;\n//\t\t}\n//\t\t\n//\t\tvisited[i] = 1;\n//\t\t\n//\t\tfor(int j = 0;j<arr[i].size();j++){\n//\t\t\tdfss(arr[i].get(j));\n//\t\t}\n//\t//\tSystem.out.println(i);\n//\t\tstack.push(i);\n//\t}\n//\t\n//\tpublic static void reverse(){\n//\t\tArrayList[] temp = new ArrayList[n];\n//\t\t\n//\t\tfor(int i = 0;i<n;i++){\n//\t\t\ttemp[i] = new ArrayList();\n//\t\t}\n//\t\t\n//\t\tfor(int i = 0;i<n;i++){\n//\t\t\tfor(int j = 0;j<arr[i].size();j++){\n//\t\t\t\ttemp[arr[i].get(j)].add(i);\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t\tarr = temp;\n//\t\t\n//\t}\n//\t\n//\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tpublic static void InputReader(InputStream stream1) {\n\t\tstream = stream1;\n\t}\n\t\n//\tpublic static void bfs(int s){\n//\t\t\n//\t\n//\t\tif(visited[s] == 1){\n//\t\t\treturn;\n//\t\t}\n//\t\tc++;\n//\t\tvisited[s] = 1;\n//\t\tQueue<Integer> q=new LinkedList<Integer>();\n//    \tq.add(s);\n//  \n//    \twhile(!q.isEmpty()){\n//    \t\tint top=q.poll();\n//    \t\tv++;\n//    \t\tIterator<Integer> i= adj[top].listIterator();\n//    \t\twhile(i.hasNext()){\n//    \t\t\tint n=i.next();\n//    \t\t\tif(visited[n] == 0){\n//    \t\t\t\tq.add(n);\n//    \t\t\t\tvisited[n]=1;\n//    \t\t\t\t\n//    \t\t\t}\n//    \t\t}\n//    \t}\n//\t\t\n//\t\t\n//\t}\n//\t\n//\t\n//\t\n//\tpublic static void dfs(int i,int j){\n//\t\tSystem.out.println(i + \" \" + j + \" \" + arr[i][j]);\n//\t\tif(i == x2 && j == y2 && arr[i][j] == 'X'){\n//\t\t\tf = 1;\n//\t\t\treturn;\n//\t\t}else if(i == x2 && j == y2){\n//\t\t\t\n//\t\t\tfor(int p = 0;p<4;p++){\n//\t\t\t\tint t1 = i + dir[p][0];\n//\t\t\t\tint t2 = j + dir[p][1];\n//\t\t\t\t\n//\t\t\t\ti =t1;j =t2;\n//\t\t\t\t\n//\t\t\t\t\n//\t\t\t\tif(i < 0 || i >=n || j < 0 || j >= m){\n//\t\t\t\t\t// fooled you/...\n//\t\t\t\t}else if(arr[t1][t2] == '.'){\n//\t\t\t\t\tSystem.out.println(i + \" \" + j+ \" \" + \" insisis\" + \" \" + arr[i][j]);\t\n//\t\t\t\t\tf = 1;\n//\t\t\t\t\treturn;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t\n//\t\t\treturn;\n//\t\t}else if(arr[i][j] == 'X' && i != x1 && j != y1){\n//\t\t\treturn;\n//\t\t}else if(arr[i][j] == 'X' && i == x1 && j == y1){\n//\t\t\tfor(int p = 0;p<4;p++){\n//\t\t\t\tint t1 = i + dir[p][0];\n//\t\t\t\tint t2 = j + dir[p][1];\n//\t\t\t\ti =t1;j =t2;\n//\t\t\t\tif(i < 0 || i >=n || j < 0 || j >= m){\n//\t\t\t\t\t// fooled you/...\n//\t\t\t\t}else if(arr[t1][t2] == '.'){\n//\t\t\t\t\tdfs(t1,t2);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t\n//\t\t}\n//\t\t\n//\t\tint t1 = i;\n//\t\tint t2 = j;\n////\t\tif(t1 == 3 && t2 == 4){\n////\t\t\tSystem.out.println(i + \" \" + j + \" inside\");\n////\t\t}\n////\t\t\n//\t\tfor(int k = 0;k<4;k++){\n//\t\t\n//\t\t\ti = t1 + dir[k][0];\n//\t\t\tj = t2 + dir[k][1];\n//\t\t\t\n//\t\t\tif(t1 == 0 && t2 == 6){\n//\t\t\t\tSystem.out.println(i + \" \" + j + \" inside\");\n//\t\t\t}\n//\t\t\t\n//\t\t\tif(i < 0 || i >=n || j < 0 || j >= m){\n//\t\t\t\t// fooled you/...\n//\t\t\t}else if(arr[i][j] == '.'){\n//\t\t\t\tarr[t1][t2] = 'X';\n//\t\t\t\tdfs(i,j);\n//\t\t\t}else if(i == x2 & j == y2 && arr[i][j] == 'X'){\n//\t\t\t\tdfs(i,j);\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t\t\n//\t\t\n//\t\t\n//\t}\n\t\n\t\n\t\n\t\n\tpublic static boolean isPrime(int n) {\n\t\t// Corner cases\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n \n\t\t// This is checked so that we can skip \n\t\t// middle five numbers in below loop\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n \n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n \n\t\treturn true;\n\t}\n\t\n\t\n\t\n\tpublic static void Range(int[] numbers, int target) {\n\t    if (numbers == null)\n\t        return;\n\n\t    int low = 0, high = numbers.length - 1;\n\t    // get the start index of target number\n\t    int startIndex = -1;\n\t    while (low <= high) {\n\t        int mid = (high - low) / 2 + low;\n\t        if (numbers[mid] > target) {\n\t            high = mid - 1;\n\t        } else if (numbers[mid] == target) {\n\t            startIndex = mid;\n\t            high = mid - 1;\n\t        } else\n\t            low = mid + 1;\n\t    }\n\n\t    // get the end index of target number\n\t    int endIndex = -1;\n\t    low = 0;\n\t    high = numbers.length - 1;\n\t    while (low <= high) {\n\t        int mid = (high - low) / 2 + low;\n\t        if (numbers[mid] > target) {\n\t            high = mid - 1;\n\t        } else if (numbers[mid] == target) {\n\t            endIndex = mid;\n\t            low = mid + 1;\n\t        } else\n\t            low = mid + 1;\n\t    }\n\n\t    if (startIndex != -1 && endIndex != -1){\n\t        for(int i=0; i+startIndex<=endIndex;i++){\n\t            if(i>0)\n\t                System.out.print(',');\n\t            System.out.print(i+startIndex);\n\t        }\n\t    }\n\t}\n\t\n\t // union code starts\t\n\t\n\t private static void initialize( int Arr[ ],int size[], int N)\n\t    {\n\t        for(int i = 0;i<N;i++)\n\t        {\n\t        \tArr[ i ] = i ;\n\t        \tsize[ i ] = 1;\n\t        }\n\t    }\n\t \n\t private static int root(int Arr[ ],int i)\n\t    {\n\t        while(Arr[ i ] != i)           //chase parent of current element until it reaches root\n\t        {\n\t            Arr[ i ] = Arr[ Arr[ i ] ] ; \n\t            i = Arr[ i ];\n\t        }\n\t        return i;\n\t    }\n\t \n\t private static void union(int Arr[ ],int size[ ],int A,int B)\n\t    {\n\t        int root_A = root(Arr,A);\n\t        int root_B = root(Arr,B);\n\t     \n\t        if(root_A != root_B){\n\t        \t if(size[root_A] < size[root_B ])\n\t \t        {\n\t        \t\t Arr[ root_A ] = Arr[root_B];\n\t        \t\t size[root_B] += size[root_A];\t \t\n\t \t        }\n\t \t        else\n\t \t        {   \t\n\t \t        \tArr[ root_B ] = Arr[root_A];\n\t \t        \tsize[root_A] += size[root_B];\t \t   \n\t \t        }\t\n\t        }\n\t    }\n\t \n\t private static boolean find(int Arr[],int A,int B)\n\t    {\n\t        if( root(Arr,A)==root(Arr,B) )       //if A and B have the same root, it means that they are connected.\n\t        return true;\n\t        else\n\t        return false;\n\t    }\n\t \n\t \n\t // union code ends\n\t\n\t\n\t \n//\t // Segment tree code begins\n//\t \n//\t \n//\t static void build(int node,int start,int end)\n//\t {\n//\t if(start==end)\n//\t tree[node]=a[start];\n//\t else\n//\t {\n//\t int mid=(start+end)/2;\n//\t build(2*node,start,mid);\n//\t build(2*node+1,mid+1,end);\n//\t if(tree[2*node]<tree[2*node+1])\n//\t tree[node]=tree[2*node];\n//\t else\n//\t tree[node]=tree[2*node+1];\n//\t }\n//\t }\n//\t \n//\t \n//\t static void update(int node,int start,int end,int idx,int val)\n//\t {\n//\t if(start==end)\n//\t {\n//\t a[idx]=val;\n//\t tree[node]=val;\n//\t }\n//\t else\n//\t {\n//\t int mid=(start+end)/2;\n//\t if(idx>=start&&idx<=mid)\n//\t update(2*node,start,mid,idx,val);\n//\t else\n//\t update(2*node+1,mid+1,end,idx,val);\n//\t if(tree[2*node]<tree[2*node+1])\n//\t tree[node]=tree[2*node];\n//\t else\n//\t tree[node]=tree[2*node+1];\n//\t }\n//\t }\n//\t \n//\t static int query(int node,int start,int end,int l,int r)\n//\t {\n//\t if(l>end||start>r)\n//\t return 100005;\n//\t if(l<=start&&r>=end)\n//\t return tree[node];\n//\t int p1,p2;\n//\t int mid=(start+end)/2;\n//\t p1=query(2*node,start,mid,l,r);\n//\t p2=query(2*node+1,mid+1,end,l,r);\n//\t if(p1<p2)\n//\t return p1;\n//\t else\n//\t return p2;\n//\t }\n//\t \n//\t \n//\t \n//}\n\n}\n\nclass Node{\n\tint a;\n\tint b;\n}\n\n\nclass MyComp2 implements Comparator<Node>{\n    \n\t@Override\n\tpublic int compare(Node o1, Node o2) {\n\t\tif(o1.b>o2.b){\n\t\t\treturn 1;\n\t\t}else if(o1.b<o2.b){\n\t\t\treturn -1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "/* My Approach :\n    Make a graph :\n     case 1 : if there is only one connected component \n              1) if a node exist such that p[i]=i then do nothing\n              2) else find a vertex which is present in the cycle make it p[i]=i and ans=1\n\n     case 2 : if there are more than one connected component\n              every connectec omponenet has a cycle . it may be of length 1\n             1) if at least one connected component exist such that p[i]=i;\n                then ans=cc-1; and from every connected component pick a vertex v whihc is presnet in cycle and make p[v]=i;\n             2) else ans=cc . becaue we have to change in every connectec comp0nent.\n                pick a vertex from a cc which is present in cycle and make p[i]=i;\n                and for other component pick a cyclic vertex and make p[v]=i; \n*/\nimport java.util.*;\nimport java.io.*;\npublic class c{ \n\nstatic PrintWriter out = new PrintWriter(System.out);\nstatic int flag=0;\nstatic void dfs(LinkedList<Integer> l[],int s,int p,boolean v[],HashSet<Integer> h){\n                       v[s]=true;\n                     for(Integer i: l[s])\n                          if(v[i]==false)\n                             dfs(l,i,s,v,h);\n                          else if(i!=p&&flag==0)\n                            { h.add(i); flag=1;}\n\n}\npublic static void main(String[] args)throws IOException { \n \n\n        int n = ni();\n        int p[] = new int[n];\n        LinkedList<Integer> l[] = new LinkedList[n];\n               for(int i=0;i<n;i++) l[i] = new LinkedList();\n          int f=-1;\n         for(int i=0;i<n;i++) {\n                   p[i] = ni()-1;\n                    if(p[i]==i)f=i;\n                   l[i].add(p[i]);\n                   l[p[i]].add(i);\n          }\n        boolean v[] = new boolean[n];\n        HashSet<Integer> h = new HashSet<Integer>();\n        int cc=0,ans=0;\n           for(int i=0;i<n;i++)\n                if(v[i]==false)\n                  { cc++;flag=0; dfs(l,i,-1,v,h);}\n          if(cc!=1){\n                      if(f==-1){ \n                                  for(Integer i: h){\n                                        if(f==-1){\n                                            f=i;   \n                                            p[i]=i;\n                                         }\n                                        else\n                                          p[i]=f;\n                                   }\n                          ans=cc;\n                      }\n                    else{\n                            for(Integer i: h)\n                                 if(i!=f)\n                                    p[i]=f;   \n                           ans=cc-1;             \n                     }\n          }\n        else if(f==-1){\n                 for(Integer i : h)\n                      p[i]=i;\n                      ans =1;\n          }\n             out.println(ans);\n          for(int i=0;i<n;i++)\n             out.print((p[i]+1)+\" \");\n      out.flush();\n}   \n    static FastReader sc=new FastReader(); \n \n      static int ni(){\n                 int x = sc.nextInt();\n                 return(x);\n        }\n      static long nl(){\n              long x = sc.nextLong();\n              return(x);\n         }\n      static String n(){\n                 String str = sc.next();\n                     return(str);\n       }\n     static String ns(){\n                 String str = sc.nextLine();\n                   return(str);\n      }\n     static double nd(){\n               double d = sc.nextDouble();\n                 return(d);\n       }\n  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 200005;\nint fa[maxn], N, in[maxn], vis[maxn];\nvoid tuopu(int x) {\n  while (!in[x]) {\n    vis[x] = 1;\n    x = fa[x];\n    in[x]--;\n    if (vis[x]) break;\n  }\n}\nint fcir(int x) {\n  while (!vis[x]) {\n    vis[x] = 2;\n    x = fa[x];\n  }\n  return x;\n}\nint main() {\n  int fir = -1, ans = 0;\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &fa[i]);\n    if (i == fa[i]) {\n      if (-1 != fir) {\n        ans++;\n        fa[i] = fir;\n        in[fir]++;\n      } else\n        fir = fa[i];\n    } else\n      in[fa[i]]++;\n  }\n  for (int i = 1; i <= N; i++)\n    if (!in[i] && !vis[i]) tuopu(i);\n  if (-1 != fir) {\n    for (int i = 1; i <= N; i++) {\n      if (!vis[i]) {\n        ans++;\n        int x = fcir(i);\n        fa[x] = fir;\n      }\n    }\n  } else {\n    for (int i = 1; i <= N; i++) {\n      if (!vis[i]) {\n        vis[i] = 2;\n        int x = fa[i];\n        while (!vis[x]) {\n          vis[x] = 2;\n          x = fa[x];\n        }\n        fir = i;\n        fa[i] = i;\n        ans++;\n        break;\n      }\n    }\n    for (int i = 1; i <= N; i++) {\n      if (!vis[i]) {\n        ans++;\n        int x = fcir(i);\n        fa[x] = fir;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= N; i++) printf(\"%d \", fa[i]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Solution\n{\n       public static void main(String []args)\n       {\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int arr[] = new int[n+1];\n              for(int i = 1; i <= n ; i++)\n              {\n                     arr[i] = sc.nextInt();\n              }\n              int pp[] = new int[n+1];\n              boolean parent[] = new boolean[n+1];\n              int p = -1;\n              boolean visited[] = new boolean[n+1];\n              for(int i = 1 ; i <= n ; i++)\n              {\n                   if(!visited[i])\n                   {\n                   \n                          int x = i;\n                          pp[i] = i;\n                          while(!visited[x])\n                          {\n                                 visited[x] = true;\n                                 pp[x] = i;\n                                 if(pp[arr[x]] == i)\n                                 {\n                                        if(p == -1)\n                                        p = x;\n                                       \n                                        parent[x] = true;\n                                        break;\n                                 }\n                                 x = arr[x];\n                          }\n                   }\n              }\n              int cnt = 0;\n              for(int i = 1 ; i<= n ; i++)\n              {\n                     if(arr[i] == i)\n                     {\n                            p = i;\n                            break;\n                     }\n              }\n              for(int i = 1 ; i <= n ; i++)\n              {\n                     if(parent[i]  && arr[i] != p)\n                     {\n                            arr[i] = p;\n                            cnt++;\n                     }\n              }\n              System.out.println(cnt);\n              for(int i = 1 ; i <= n ; i++)\n              {\n                     System.out.print(arr[i] + \" \");\n              }\n              System.out.println();\n              \n       }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tint[] col;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\n\t\tcol = new int[n];\n\n\t\tList<List<Integer>> lst = new ArrayList<>();\n\t\t\n\t\tint root = -1;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (col[i] == 0) {\n\t\t\t\tint v = i;\n\t\t\t\twhile (col[v] == 0) {\n\t\t\t\t\tcol[v] = 1;\n\t\t\t\t\tv = a[v];\n\t\t\t\t}\n\t\t\t\tList<Integer> cycle = new ArrayList<>();\n\t\t\t\tif (col[v] == 1) {\n\t\t\t\t\tcycle.add(v);\n\t\t\t\t\tfor (int u = a[v]; u != v; u = a[u]) {\n\t\t\t\t\t\tcycle.add(u);\n\t\t\t\t\t}\n\t\t\t\t\tlst.add(cycle);\n\t\t\t\t\tif (cycle.size() == 1) {\n\t\t\t\t\t\troot = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tv = i;\n\t\t\t\twhile (col[v] != 2) {\n\t\t\t\t\tcol[v] = 2;\n\t\t\t\t\tv = a[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (root == -1) {\n\t\t\troot = lst.get(0).get(0);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor (List<Integer> cycle : lst) {\n\t\t\tif (a[cycle.get(0)] != root) {\n\t\t\t\tans++;\n\t\t\t\ta[cycle.get(0)] = root;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\tfor (int x : a) {\n\t\t\tout.print((x + 1) + \" \");\n\t\t}\n\t\tout.println();\n\t}\n\n\tB() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, i, a[200001], flag[200001], cnt(0), root(0), j, res(0);\n  cin >> n;\n  for (i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (i == a[i]) root = i;\n  }\n  fill(flag + 1, flag + 200001, 0);\n  for (i = 1; i <= n; i++) {\n    if (flag[i] == 0) {\n      cnt++;\n      j = i;\n      while (flag[j] == 0) {\n        flag[j] = cnt;\n        j = a[j];\n      }\n      if (flag[j] == cnt) {\n        if (root == 0) {\n          root = j;\n          a[j] = j;\n          res++;\n        }\n        if (root != j) {\n          a[j] = root;\n          res++;\n        }\n      }\n    }\n  }\n  cout << res << '\\n';\n  for (i = 1; i <= n; i++) cout << a[i] << \" \";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    static ArrayList<Integer> adj_lst[];\n    static boolean vis[];\n    static int fin_root=-1;\n    static int color[];\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        int n=input.scanInt();\n        int arr[]=new int[n];\n        for(int i=0;i<n;i++) {\n            arr[i]=input.scanInt()-1;\n        }\n        //No of nodes\n        adj_lst=new ArrayList[n];\n        vis=new boolean[n];\n        for(int i=0;i<n;i++) {\n            adj_lst[i]=new ArrayList<Integer>();\n        }\n        //No of edges\n        for(int i=0;i<n;i++) {\n            // input u & v\n            if(arr[i]==i) {\n                continue;\n            }\n            adj_lst[arr[i]].add(i);\n        }\n        color=new int[n];\n        boolean par[]=new boolean[n];\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<adj_lst[i].size();j++) {\n                par[adj_lst[i].get(j)]=true;\n            }\n        }\n        int root=-1,clr=1;\n        for(int i=0;i<n;i++) {\n            if(!par[i]) {\n                root=i;\n                DFS(i,clr);\n                clr++;\n            }\n        }\n        for(int i=0;i<n;i++) {\n            if(!vis[i]) {\n                DFS(i,clr);\n                clr++;\n            }\n        }\n        \n//        for(int i=0;i<adj_lst.length;i++) {\n//            System.out.print((i+1)+\"->\");\n//            for(int j=0;j<adj_lst[i].size();j++) {\n//                System.out.print((adj_lst[i].get(j)+1)+\" \");\n//            }\n//            System.out.println();\n//        }\n        par=new boolean[n];\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<adj_lst[i].size();j++) {\n                par[adj_lst[i].get(j)]=true;\n            }\n        }\n        if(root==-1) {\n            for(int i=0;i<n;i++) {\n                if(!par[i]) {\n                    root=i;\n                    break;\n                }\n            }\n        }\n//        System.out.println(root);\n        for(int i=0;i<n;i++) {\n            if(!par[i] && i!=root) {\n//                System.out.println(first+\" \"+i);\n                adj_lst[root].add(i);\n            }\n        }\n        \n        int ans[]=new int[n];\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<adj_lst[i].size();j++) {\n                ans[adj_lst[i].get(j)]=i;\n            }\n        }\n        ans[root]=root;\n        int cnt=0;\n        for(int i=0;i<n;i++) {\n            if(arr[i]!=ans[i]) {\n                cnt++;\n            }\n        }\n        StringBuilder fin=new StringBuilder(\"\");\n        for(int i=0;i<n;i++) {\n            ans[i]++;\n            fin.append(ans[i]+\" \");\n        }\n        System.out.println(cnt+\"\\n\"+fin);\n    }\n    public static void DFS(int root,int clr) {\n//        System.out.println(root);\n        color[root]=clr;\n        vis[root]=true;\n        for(int i=0;i<adj_lst[root].size();i++) {\n            if(!vis[adj_lst[root].get(i)]) {\n                DFS(adj_lst[root].get(i),clr);\n            }\n            else if(color[adj_lst[root].get(i)]==clr){\n                adj_lst[root].remove(i);\n                i--;\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "# Why do we fall ? So we can learn to pick ourselves up.\n\n\nroot = -1\n\ndef find(i,time):\n    parent[i] = time\n    while not parent[aa[i]]:\n        i = aa[i]\n        parent[i] = time\n        # print(parent,\"in\",i)\n    if parent[aa[i]] == time:\n        global root\n        if root == -1:\n            root = i\n        if aa[i] != root:\n            aa[i] = root\n            global ans\n            ans += 1\n\n\n\n\nn = int(input())\naa = [0]+[int(i) for i in input().split()]\n\nparent = [0]*(n+1)\n\nans = 0\ntime = 0\n\nfor i in range(1,n+1):\n    if aa[i] == i:\n        root = i\n        break\n\nfor i in range(1,n+1):\n    if not parent[i]:\n        # print(i,\"pp\")\n        time += 1\n        find(i,time)\n# print(parent)\nprint(ans)\nprint(*aa[1:])\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[400005];\nint arr[400005];\nint find_par(int n) {\n  if (par[n] == n)\n    return n;\n  else\n    return par[n] = find_par(par[n]);\n}\nint visited[500005];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n  }\n  int root = 0;\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n    int x = find_par(i);\n    int y = find_par(arr[i]);\n    if (arr[i] == i) root = i;\n    if (x != y) par[x] = y;\n    if (x == y) {\n      visited[i] = 1;\n    }\n  }\n  if (!root) {\n    for (int i = 1; i <= n; i++) {\n      int x = find_par(i);\n      int y = find_par(arr[i]);\n      if (x == y) {\n        root = x;\n        break;\n      }\n    }\n  }\n  int index;\n  for (int i = 1; i <= n; i++) {\n    if (visited[i]) {\n      if (arr[i] != root) {\n        cnt++;\n        arr[i] = root;\n      }\n    }\n  }\n  cout << cnt << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << arr[i] << \" \";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "// package codeforces.cf3xx.cf363.div1;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n/**\n * Created by hama_du on 2016/07/19.\n */\npublic class B {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] a = in.nextInts(n);\n        for (int i = 0; i < n ; i++) {\n            a[i]--;\n        }\n\n        List<Integer> heads = new ArrayList<>();\n        boolean[] self = new boolean[n];\n        for (int i = 0; i < n ; i++) {\n            if (a[i] == i) {\n                heads.add(i);\n            }\n        }\n        int initialRoot = heads.size();\n\n        UnionFind uf = new UnionFind(n);\n        for (int i = 0; i < n ; i++) {\n            uf.unite(i, a[i]);\n        }\n        for (int i = 0; i < n ; i++) {\n            uf.find(i);\n        }\n        for (int x : heads) {\n            self[uf.find(x)] = true;\n        }\n\n        for (int i = 0; i < n ; i++) {\n            if (self[uf.find(i)]) {\n                self[i] = true;\n            }\n        }\n\n        for (int i = 0; i < n ; i++) {\n            int id = uf.find(i);\n            if (self[id]) {\n                continue;\n            }\n            int cnt = uf.groupCount(i);\n            int now = i;\n            for (int j = 0; j < 2*cnt ; j++) {\n                now = a[now];\n            }\n            heads.add(now);\n            self[id] = true;\n        }\n\n\n        if (initialRoot >= 1) {\n            int rt = heads.get(0);\n            for (int i = 1 ; i < heads.size() ; i++) {\n                int id = heads.get(i);\n                a[id] = rt;\n            }\n            out.println(heads.size()-1);\n            printLine(out, a);\n        } else {\n            int rt = heads.get(0);\n            for (int i = 0 ; i < heads.size() ; i++) {\n                int id = heads.get(i);\n                a[id] = rt;\n            }\n            out.println(heads.size());\n            printLine(out, a);\n        }\n        out.flush();\n    }\n\n    private static void printLine(PrintWriter out, int[] a) {\n        StringBuilder line = new StringBuilder();\n        for (int i = 0; i < a.length ; i++) {\n            line.append(' ').append(a[i]+1);\n        }\n        out.println(line.substring(1));\n    }\n\n    static class UnionFind {\n        int[] rank;\n        int[] parent;\n        int[] cnt;\n\n        public UnionFind(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            cnt = new int[n];\n            for (int i = 0; i < n ; i++) {\n                parent[i] = i;\n                cnt[i] = 1;\n            }\n        }\n\n        public int find(int a) {\n            if (parent[a] == a) {\n                return a;\n            }\n            parent[a] = find(parent[a]);\n            return parent[a];\n        }\n\n        public void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (rank[a] < rank[b]) {\n                parent[a] = b;\n                cnt[b] += cnt[a];\n                cnt[a] = cnt[b];\n            } else {\n                parent[b] = a;\n                cnt[a] += cnt[b];\n                cnt[b] = cnt[a];\n                if (rank[a] == rank[b]) {\n                    rank[a]++;\n                }\n            }\n        }\n\n        public int groupCount(int a) {\n            return cnt[find(a)];\n        }\n\n        private boolean issame(int a, int b) {\n            return find(a) == find(b);\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class fixTree {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] str = br.readLine().split(\" \");\n        int[] arr = new int[n+1];\n        for(int i=0; i<n; i++){\n            arr[i+1] = Integer.parseInt(str[i]);\n        }\n        int[] pp = new int[n+1];\n        boolean[] parent = new boolean[n+1];\n        boolean[] visited = new boolean[n+1];\n        int p = -1;\n        int x;\n        for(int i=1; i<=n; i++){\n            if(!visited[i]){\n                x = i;\n                pp[i] = i;\n                while(!visited[x]){\n                    visited[x] = true;\n                    pp[x] = i;\n                    if(pp[arr[x]]==i){\n                        if(p==-1) p = x;\n                        parent[x] = true;\n                        break;\n                    }\n                    x = arr[x];\n                }\n            }\n        }\n        int cnt = 0;\n        for(int i=1; i<=n; i++){\n            if(arr[i]==i){\n                p = i;\n                break;\n            }\n        }\n        for(int i=1; i<=n; i++){\n            if(parent[i] && arr[i]!=p){\n                arr[i] = p;\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n        for(int i=1; i<=n; i++){\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.println();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class cf {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = sc.nextIntArray(n);\n\t\tint r = -1;\n\t\tDSU uf = new DSU(n);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p[i] == i + 1) {\n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i + 1;\n\t\t\t\telse {\n\t\t\t\t\tp[i] = r;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!uf.union(i, p[i] - 1) && i != r-1) {\n\t\t\t\tif (r == -1) {\n\t\t\t\t\tr = i + 1;\n\t\t\t\t}\n\t\t\t\tp[i] = r;\n\t\t\t\tuf.union(i, p[i] - 1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (r == -1) {\n\t\t\tp[p[n - 1] - 1] = p[n - 1];\n\t\t\tcount++;\n\t\t}\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.println(count);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tout.print(p[i] + \" \");\n\t\tout.close();\n\n\t}\n\n\tstatic class DSU {\n\t\tint[] p;\n\t\tint[] r;\n\n\t\tpublic DSU(int n) {\n\t\t\tp = new int[n];\n\t\t\tr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i] = i;\n\t\t}\n\n\t\tpublic boolean isSameSet(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tpublic int findSet(int x) {\n\t\t\treturn x == p[x] ? x : (p[x] = findSet(p[x]));\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = findSet(x);\n\t\t\ty = findSet(y);\n\t\t\tif (x == y)\n\t\t\t\treturn false;\n\t\t\tif (r[x] > r[y])\n\t\t\t\tp[y] = x;\n\t\t\telse {\n\t\t\t\tp[x] = y;\n\t\t\t\tif (r[x] == r[y]) {\n\t\t\t\t\tr[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String f) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray1(int n) throws IOException {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] shuffle(int[] a, int n) {\n\t\t\tint[] b = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tb[i] = a[i];\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tint t = b[i];\n\t\t\t\tb[i] = b[j];\n\t\t\t\tb[j] = t;\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\t\t\tint[] a = nextIntArray(n);\n\t\t\ta = shuffle(a, n);\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray1(int n) throws IOException {\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\t\t\tlong[] a = nextLongArray(n);\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tlong t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\narr = list(map(int, input().split(' ')))\nroot=-1\nfor i,a in enumerate(arr) :\n    if i == a-1 :\n        root = i\n        break\nv = [False]*len(arr)\nif root>-1 :\n    v[root]=True\nans = 0\nfor i,a in enumerate(arr) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=arr[a]-1\n    if a in l: #new cycle\n        if root==-1:\n            arr[a]=a+1\n            root=a\n            ans+=1\n        else :\n            arr[a]=root+1\n            ans+=1\nprint(ans)\nprint(' '.join(map(str,arr)))\n\t     \t\t"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.StringReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Denis Nedelyaev\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB(in, out);\n        solver.solve(1);\n        out.close();\n    }\n\n    static class TaskB {\n        private final FastScanner in;\n        private final PrintWriter out;\n\n        public TaskB(FastScanner in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        public void solve(int testNumber) throws IOException {\n            int n = in.nextInt();\n            int[] p = in.nextInts(n);\n            for (int i = 0; i < n; i++) {\n                p[i]--;\n            }\n            int[] ans = realSolve(p);\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                if (ans[i] != p[i]) {\n                    count++;\n                }\n            }\n            out.println(count);\n            for (int i = 0; i < n; i++) {\n                out.print(ans[i] + 1);\n                out.print(' ');\n            }\n            out.println();\n        }\n\n        private int[] realSolve(int[] p) {\n            int n = p.length;\n\n            for (int i = 0; i < n; i++) {\n                if (p[i] == i) {\n                    return realRootSolve(i, p);\n                }\n            }\n\n            return realRootSolve(-1, p);\n        }\n\n        private int[] realRootSolve(int root, int[] p) {\n            int n = p.length;\n            int[] ans = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                ans[i] = p[i];\n            }\n\n            int[] vis = new int[n];\n            Arrays.fill(vis, -1);\n            if (root != -1) {\n                ans[root] = root;\n                vis[root] = root;\n            }\n\n            for (int v = 0; v < n; v++) {\n                int u = v;\n                while (vis[u] == -1) {\n                    vis[u] = v;\n                    if (vis[ans[u]] == v) {\n                        if (root == -1) {\n                            root = u;\n                        }\n                        ans[u] = root;\n                    }\n                    u = ans[u];\n                }\n            }\n\n            return ans;\n        }\n\n    }\n\n    static class FastScanner {\n        private final BufferedReader br;\n        private String line;\n        private int pos;\n\n        public FastScanner(String s) throws IOException {\n            this(new StringReader(s));\n        }\n\n        public FastScanner(InputStream is) throws IOException {\n            this(new InputStreamReader(is, \"UTF-8\"));\n        }\n\n        public FastScanner(Reader reader) throws IOException {\n            this(new BufferedReader(reader));\n        }\n\n        public FastScanner(BufferedReader reader) throws IOException {\n            br = reader;\n            line = br.readLine();\n            pos = 0;\n        }\n\n        public String next() throws IOException {\n            if (!skipWhitespace()) {\n                return null;\n            }\n\n            int start = pos;\n\n            while (pos < line.length()) {\n                char c = line.charAt(pos);\n\n                if (c == ' ' || c == '\\t') {\n                    break;\n                }\n\n                pos++;\n            }\n\n            return line.substring(start, pos);\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextInts(int n) throws IOException {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        private boolean skipWhitespace() throws IOException {\n            while (line != null) {\n                while (pos < line.length()) {\n                    char c = line.charAt(pos);\n\n                    if (c != ' ' && c != '\\t') {\n                        return true;\n                    }\n\n                    pos++;\n                }\n\n                line = br.readLine();\n                pos = 0;\n            }\n\n            return false;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "//package LongChallenges;\nimport java.util.*;\npublic class May {\n\tstatic boolean[] done;\n\tstatic List<Integer> list = new ArrayList<>();\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t int n = sc.nextInt();\n         int[] cycles = new int[n];\n         int cyclePtr = 0;\n         int identity = -1;\n         int[] a = new int[n];\n         for (int i = 0; i < n; ++i) {\n             a[i] = sc.nextInt() - 1;\n             if (a[i] == i) identity = i;\n         }\n         int[] mark = new int[n];\n         int gen = 0;\n         for (int i = 0; i < n; ++i)\n             if (mark[i] == 0) {\n                 ++gen;\n                 int j = i;\n                 while (mark[j] == 0) {\n                     mark[j] = gen;\n                     j = a[j];\n                 }\n                 if (mark[j] == gen) {\n                     cycles[cyclePtr++] = j;\n                 }\n             }\n         cycles = Arrays.copyOf(cycles, cyclePtr);\n         int res = cyclePtr - 1;\n         if (identity < 0) {\n             ++res;\n             a[cycles[0]] = cycles[0];\n             identity = cycles[0];\n         }\n         for (int x : cycles) {\n             if (x != identity) {\n                 a[x] = identity;\n             }\n         }\n         System.out.println(res);\n         for (int i = 0; i < n; ++i) {\n             if (i > 0) System.out.print(\" \");\n             System.out.print(a[i] + 1);\n         }\n         System.out.println();\n     }\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> Set;\nvector<int> v[250001];\nint a[250001], p[250001], n, i, j, ans;\nbool pole[250001], x;\nvoid Merge(int nom1, int nom2) {\n  int i;\n  if (nom1 == p[1]) {\n    for (i = 0; i < v[nom2].size(); i++) Set.erase(v[nom2][i]);\n  }\n  if (nom2 == p[1]) {\n    for (i = 0; i < v[nom1].size(); i++) Set.erase(v[nom1][i]);\n  }\n  if (v[nom1].size() < v[nom2].size()) {\n    for (i = 0; i < v[nom1].size(); i++) {\n      v[nom2].push_back(v[nom1][i]);\n      p[v[nom1][i]] = nom2;\n    }\n    v[nom1].clear();\n  } else {\n    for (i = 0; i < v[nom2].size(); i++) {\n      v[nom1].push_back(v[nom2][i]);\n      p[v[nom2][i]] = nom1;\n    }\n    v[nom2].clear();\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (a[i] == i) x = true;\n  }\n  for (i = 1; i <= n; i++) {\n    v[i].push_back(i);\n    p[i] = i;\n  }\n  for (i = 2; i <= n; i++) Set.insert(i);\n  if (!x) {\n    for (i = 1; i <= n; i++)\n      if (p[i] != p[a[i]]) {\n        pole[i] = true;\n        Merge(p[i], p[a[i]]);\n      }\n    for (i = 1; i <= n; i++)\n      if (!pole[i]) {\n        if (!x) {\n          ans++;\n          x = true;\n          a[i] = i;\n          continue;\n        }\n        ans++;\n        if (p[i] != p[1]) {\n          Merge(p[i], p[1]);\n          a[i] = 1;\n        } else {\n          a[i] = *Set.begin();\n          Merge(p[i], p[*Set.begin()]);\n        }\n      }\n  } else {\n    x = false;\n    for (i = 1; i <= n; i++)\n      if (p[i] != p[a[i]]) {\n        pole[i] = true;\n        Merge(p[i], p[a[i]]);\n      }\n    for (i = 1; i <= n; i++)\n      if (!pole[i]) {\n        if (a[i] == i && !x) {\n          x = true;\n          continue;\n        }\n        ans++;\n        if (p[i] != p[1]) {\n          Merge(p[i], p[1]);\n          a[i] = 1;\n        } else {\n          a[i] = *Set.begin();\n          Merge(p[i], p[*Set.begin()]);\n        }\n      }\n  }\n  cout << ans << '\\n';\n  for (i = 1; i <= n; i++) cout << a[i] << \" \";\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ntree_size = int(input())\n\nparents = [int(x)-1 for x in input().split(' ')]\n\n\nnum_changes = 0\n\nroot = tree_size\nfor node, parent in enumerate(parents):\n\tif parent == node:\n\t\troot = node\n\t\tbreak\n\nvisited = set()\nfinished = set()\n\nvisited.add(root)\nfinished.add(root)\n\nstack = []\nfringe = []\n\nfor node in range(len(parents)):\n\tif node not in visited:\n\t\tfringe.append(node)\n\t\twhile fringe:\n\t\t\tcur = fringe.pop()\n\t\t\tvisited.add(cur)\n\t\t\tstack.append(cur)\n\n\t\t\tif parents[cur] not in finished:\n\t\t\t\tif parents[cur] in visited:\n\t\t\t\t\tparents[cur] = root\n\t\t\t\t\tnum_changes += 1\n\t\t\t\telse:\n\t\t\t\t\tfringe.append(parents[cur])\n\n\t\twhile stack:\n\t\t\tfinished.add(stack.pop())\n\n\n\nif root == tree_size:\n\tnew_root = None\n\tfor node, parent in enumerate(parents):\n\t\tif parent == root:\n\t\t\tif new_root is None:\n\t\t\t\tnew_root = node\n\t\t\tparents[node] = new_root\n\nfor i in range(len(parents)):\n\tparents[i] += 1\n\n\nprint(num_changes)\nprint(*parents)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n = 2 * 1e5 + 1;\nlong long root = 0;\nvector<vector<long long>> adj(n);\nvector<long long> c, vi(n);\nvector<bool> visited(n);\nvoid dfs(long long s, long long anc) {\n  if (visited[s]) return;\n  visited[s] = true;\n  for (auto u : adj[s]) {\n    if (visited[u] == true && u != anc && u != s && vi[s] == 0) {\n      c.push_back(u);\n      vi[u] = 1;\n    }\n    dfs(u, s);\n  }\n}\nint main() {\n  long long m;\n  cin >> m;\n  long long res = -1;\n  vector<long long> a(m);\n  for (long long i = 0; i < m; i++) {\n    cin >> a[i];\n    adj[a[i]].push_back(i + 1);\n    adj[i + 1].push_back(a[i]);\n    if (a[i] == i + 1 && root == 0) root = a[i];\n  }\n  for (long long i = 1; i < m + 1; i++) {\n    if (visited[i] == false) {\n      dfs(i, -1);\n      res++;\n    }\n  }\n  if (res == 0 && root == 0) {\n    res++;\n    a[c[0] - 1] = c[0];\n  } else if (res > 0 && root == 0) {\n    res++;\n    root = c[0];\n    for (long long i = 0; i < c.size(); i++) a[c[i] - 1] = root;\n  } else if (res > 0 && root > 0) {\n    for (long long i = 0; i < m; i++) {\n      if (a[i] == i + 1 && a[i] != root) a[i] = root;\n    }\n    for (long long i = 0; i < c.size(); i++) a[c[i] - 1] = root;\n  }\n  cout << res << endl;\n  for (auto i = a.begin(); i != a.end(); i++) {\n    cout << *i << \" \";\n  }\n  cout << \"\\n\";\n  ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int siz = 2e5 + 5;\nint ans, cnt, root = -1, n, p[siz], vis[siz];\nvoid go(int v) {\n  vis[v] = cnt;\n  if (!vis[p[v]])\n    go(p[v]);\n  else if (vis[p[v]] == cnt) {\n    if (root != -1) {\n      if (root != v) {\n        ans++;\n        p[v] = root;\n      }\n    } else {\n      root = v;\n      p[v] = v;\n      ans++;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    if (i == p[i]) root = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      cnt++;\n      go(i);\n    }\n  }\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) cout << p[i] << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint act, root = -1;\nint to[200010];\nint u[200010];\nvector<int> cycleV;\nvoid dfs(int v) {\n  u[v] = 1;\n  if (to[v] == v) {\n    if (root == -1) {\n      root = v;\n    } else {\n      act++;\n      to[v] = root;\n    }\n  } else if (u[to[v]] == 1) {\n    cycleV.push_back(v);\n  } else if (u[to[v]] == 0) {\n    dfs(to[v]);\n  }\n  u[v] = 2;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> to[i];\n    to[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    if (!u[i]) {\n      dfs(i);\n    }\n  }\n  for (int v : cycleV) {\n    if (root == -1) {\n      act++;\n      to[v] = v;\n      root = v;\n    } else {\n      act++;\n      to[v] = root;\n    }\n  }\n  cout << act << \"\\n\";\n  for (int i = 0; i < n; i++) {\n    cout << to[i] + 1 << \" \";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 222222;\nvector<int> roots, newroots;\nint vis[NMAX];\nint p[NMAX];\nint vcnt;\nvoid query(int x) {\n  while (1) {\n    vis[x] = vcnt;\n    int y = p[x];\n    if (x == y) {\n      roots.push_back(x);\n      return;\n    }\n    if (vis[y] == vcnt) {\n      p[x] = x;\n      newroots.push_back(x);\n      return;\n    }\n    if (vis[y]) return;\n    x = y;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", p + i);\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) {\n      vcnt++;\n      query(i);\n    }\n  if (roots.empty()) {\n    for (int i = 1; i < newroots.size(); i++) p[newroots[i]] = newroots[0];\n    printf(\"%d\\n\", newroots.size());\n    for (int i = 1; i <= n; i++) printf(\"%d \", p[i]);\n  } else {\n    for (int i = 1; i < roots.size(); i++) p[roots[i]] = roots[0];\n    for (int i : newroots) p[i] = roots[0];\n    printf(\"%d\\n\", (int)(roots.size() + newroots.size() - 1));\n    for (int i = 1; i <= n; i++) printf(\"%d \", p[i]);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    static final String FILE = \"\";\n\n    int n;\n    int ans[];\n    int start[];\n    boolean used[];\n    TreeSet<Integer> neig[];\n    ArrayList<Integer> roots = new ArrayList<>();\n    boolean isHaveRoot;\n    int deep;\n    ArrayList<Integer> vertices = new ArrayList<>();\n\n    void dfs(int v, int last) {\n        if (used[v]) {\n            deep = v;\n            return;\n        }\n\n        used[v] = true;\n        vertices.add(v);\n        for (Integer it : neig[v]) {\n            if (it == last) {\n                if (ans[v] == it && ans[it] == v)\n                    deep = v;\n                continue;\n            }\n            dfs(it, v);\n        }\n    }\n\n    public void solve() {\n        n = in.nextInt();\n        ans = new int[n];\n        start = new int[n];\n        used = new boolean[n];\n\n        neig = new TreeSet[n];\n        for (int i = 0; i < n; i++)\n            neig[i] = new TreeSet<>();\n\n        for (int i = 0; i < n; i++) {\n            int tmp = in.nextInt() - 1;\n            ans[i] = tmp;\n            start[i] = tmp;\n            if (tmp == i) {\n                roots.add(tmp);\n            }\n\n            if (i != tmp) {\n                neig[i].add(tmp);\n                neig[tmp].add(i);\n            }\n        }\n\n        int curr = -1, last = -1;\n\n        ArrayList<Integer> noRoots = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (used[i])\n                continue;\n\n            vertices.clear();\n            deep = i;\n            dfs(i, i);\n\n            isHaveRoot = false;\n            for (Integer it : vertices) {\n                if (ans[it] == it) {\n                    isHaveRoot = true;\n                    curr = it;\n                }\n            }\n\n            if (!isHaveRoot) {\n                noRoots.add(deep);\n            } else {\n                if (last == -1)\n                    last = curr;\n                ans[curr] = last;\n            }\n        }\n\n        if (noRoots.size() > 0) {\n            if (last == -1)\n                last = noRoots.get(0);\n\n            for (Integer it : noRoots)\n                ans[it] = last;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (ans[i] != start[i]) {\n                cnt++;\n            }\n        }\n\n        out.println(cnt);\n        for (int i = 0; i < n; i++)\n            out.print((ans[i] + 1) + \" \");\n    }\n\n    public void run() {\n        if (FILE.equals(\"\")) {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                in = new FastScanner(new FileInputStream(FILE +\n                        \".in\"));\n                out = new PrintWriter(new FileOutputStream(FILE +\n                        \".out\"));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        (new Main()).run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n    }\n\n    class Pair<A extends Comparable<A>, B extends Comparable<B>>\n            implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> o) {\n            if (o == null || o.getClass() != getClass())\n                return 1;\n            int cmp = a.compareTo(o.a);\n            if (cmp == 0)\n                return b.compareTo(o.b);\n            return cmp;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (a != null ? !a.equals(pair.a) : pair.a != null) return\n                    false;\n            return !(b != null ? !b.equals(pair.b) : pair.b != null);\n        }\n    }\n\n    class PairInt extends Pair<Integer, Integer> {\n        public PairInt(Integer u, Integer v) {\n            super(u, v);\n        }\n    }\n\n    class PairLong extends Pair<Long, Long> {\n        public PairLong(Long u, Long v) {\n            super(u, v);\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.nio.file.Paths;\nimport java.util.*;\npublic class Main extends PrintWriter {\n    static BufferedReader s = new BufferedReader(new InputStreamReader(System.in));Main () { super(System.out); }public static void main(String[] args) throws IOException{ Main  d1=new Main   ();d1.main();d1.flush(); }\n\n    void main() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n        int t = 1;\n//        t = i(s()[0]);\n       while (t-- > 0) {\n           String[] s1 = s();\n           int n = i(s1[0]);\n           int[] a=new int[n + 1];\n           String[] s2 = s();\n           int root = 0;\n           for(int i = 1; i <= n; i++){\n               a[i] = i(s2[i - 1]);\n               if(i == a[i]) root = a[i];\n           }\n\n           int[] vis = new int[n + 1];\n           HashMap<Integer, Integer> path = new HashMap<>();\n           int ans = 0;\n           for(int i=1;i<=n;i++){\n             if(vis[i] == 0){\n                 vis[i] = 1;\n                 flag = 0;\n                 path = new HashMap<>();\n                 dfs(i, a, path, vis);\n                 if(flag == 0) continue;\n                 if(root == 0) {\n                     root = flag;\n                     if(a[flag] != flag){\n                         ans++; a[flag] = flag;\n                     }\n                 }\n                 else if(flag == root) continue;\n                 else{\n                     a[flag] = root;\n                     ans++;\n                 }\n             }\n           }\n           sb.append(ans + \"\\n\");\n           for(int i=1;i <= n;i++){\n             sb.append(a[i] + \" \");\n           }\n        }\n        System.out.println(sb);\n    }\n    static int flag = 0;\n   static void dfs(int i, int[] a, HashMap<Integer, Integer> path, int[] vis){\n        vis[i] = 1;\n        if(flag != 0) return;\n\n        if(a[i] == i){\n              flag = i; return;\n        }else{\n            if(path.containsKey(a[i])){\n                flag = i;return;\n            }else{\n                if(vis[a[i]] == 1) {\n                    return;\n                }\n                path.put(i, 0);\n                vis[i] = 1;\n                dfs(a[i], a, path, vis);\n            }\n        }\n   }\n    static String[] s() throws IOException { return s.readLine().trim().split(\"\\\\s+\"); }\n    static int i(String ss) {return Integer.parseInt(ss); }\n    static long l(String ss) {return Long.parseLong(ss); }\n    public void arr(long[] a,int n) throws IOException {String[] s2=s();for(int i=0;i<n;i++){ a[i]=l(s2[i]); }}\n    public void arri(int[] a,int n) throws IOException {String[] s2=s();for(int i=0;i<n;i++){ a[i]=i(s2[i]); }}\n}class Pair{\n   int end, subject;\n    public Pair(int s, int e){\n           subject = s; end = e;\n    }\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class FixATree { \n\tstatic int[] arr1 = new int[200005];\n\tstatic int[] arr2 = new int[200005];\n\tstatic int find(int x){\n\t\tif(arr2[x]==x) return x;\n\t\treturn arr2[x]=find(arr2[x]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tint n,m,a,b;\n\t\tint ans=0;\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tm=-1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tarr1[i]=in.nextInt();\n\t\tfor(int i=1;i<=n;i++) \n\t\t\tarr2[i]=i;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta=find(i);\n\t\t\tb=find(arr1[i]);\n\t\t\tif(a!=b) \n\t\t\t\tarr2[a]=b;\n\t\t\tif(m<0&&arr1[i]==i) \n\t\t\t\tm=i;\n\t\t}\n\t\tif(m<0){\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(arr2[i]==i) { \n\t\t\t\t\tm=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(arr2[i]==i&&arr1[i]!=m){\n\t\t\t\tarr1[i]=m;\n\t\t\t \tans++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tSystem.out.print(arr1[i]+\" \");\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "# from debug import debug\nimport sys; input = sys.stdin.readline\nn = int(input())\nlis = [0, *map(int , input().split())]\nv = [0]*(n+1)\ncycles = set()\nroots = set()\nfor i in range(1, n+1):\n\tif v[i] == 0:\n\t\tnode = i\n\t\twhile v[node] == 0:\n\t\t\tv[node] = 1\n\t\t\tnode = lis[node]\n\t\tif v[node] == 2: continue\n\t\tstart = node\n\t\tignore = 0\n\t\tl = 1\n\t\twhile lis[node] != start:\n\t\t\tif v[node] == 2: ignore = 1; break\n\t\t\tv[node] = 2\n\t\t\tnode = lis[node]\n\t\t\tl+=1\n\t\tif ignore: continue\n\t\tv[node] = 2\n\t\tif l == 1: roots.add(node)\n\t\telse: cycles.add(node)\nans = 0\nif roots:\n\tbase = roots.pop()\n\tfor i in roots: lis[i] = base; ans+=1\n\tfor i in cycles: lis[i] = base; ans+=1\nelif cycles:\n\tbase = cycles.pop()\n\tcycles.add(base)\n\tfor i in roots: lis[i] = base; ans+=1\n\tfor i in cycles: lis[i] = base; ans+=1\nprint(ans)\nprint(*lis[1:])\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class CF_698_B_FIX_A_TREE {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\n\t\tboolean[] validEdge = new boolean[n];\n\n\t\tUF uf = new UF(n);\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\tint[] ans = new int[n];\n\t\tfor (int x = 0; x < n; x++) {\n\t\t\tint y = sc.nextInt() - 1;\n\t\t\tans[x] = y;\n\t\t\tvalidEdge[x] = uf.union(x, y);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tset.add(uf.findSet(i));\n\n\t\tint notValid = 0;\n\t\t\n\t\tif (!uf.hasRoot) {\n\t\t\tfor (int x = 0; x < n; x++)\n\t\t\t\tif (!validEdge[x]) {\n\t\t\t\t\tnotValid++;\n\t\t\t\t\tvalidEdge[x] = true;\n\t\t\t\t\tans[x] = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\n\t\tnotValid += uf.sets - 1;\n\n\t\tSystem.out.println(notValid);\n\t\tint x = 0;\n\t\tStringBuilder st = new StringBuilder();\n\t\t\n\t\tfor (; x < n ; x++) {\n\t\t\tif (!validEdge[x] && notValid > 0) {\n\t\t\t\tint i = uf.findSet(x);\n\t\t\t\tint j = set.first() == i ? set.last() : set.first();\n\n\t\t\t\tans[x] = j;\n\t\t\t\tuf.union(i, j);\n\t\t\t\tif (uf.findSet(x) == i)\n\t\t\t\t\tset.remove(j);\n\t\t\t\telse\n\t\t\t\t\tset.remove(i);\n\n\t\t\t\tnotValid--;\n\t\t\t}\n\t\t\t\n\t\t\tst.append(ans[x]+1).append(\" \");\n\n\t\t}\n\t\t\n\t\tSystem.out.println(st);\n\t\t\n\t\t\n\t}\n\n\tstatic class UF {\n\t\tint[] rank;\n\t\tint[] p;\n\t\tint sets;\n\t\tboolean first, hasRoot;\n\n\t\tUF(int n) {\n\t\t\tsets = n;\n\t\t\trank = new int[n];\n\t\t\tp = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i] = i;\n\t\t\thasRoot = !(first = true);\n\n\t\t}\n\n\t\tint findSet(int x) {\n\t\t\treturn p[x] == x ? x : findSet(p[x]);\n\t\t}\n\n\t\tboolean isSameSet(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint i = findSet(x);\n\t\t\tint j = findSet(y);\n\n\t\t\tif (i != j) {\n\t\t\t\tif (rank[i] > rank[j])\n\t\t\t\t\tp[j] = i;\n\t\t\t\telse {\n\t\t\t\t\tp[i] = j;\n\t\t\t\t\tif (rank[i] == rank[j])\n\t\t\t\t\t\trank[j]++;\n\t\t\t\t}\n\t\t\t\tsets--;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (first)\n\t\t\t\treturn hasRoot = x == y && !(first = false);\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class CF698B {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputStream inputStream = System.in;\n//\t\tInputStream inputStream = new FileInputStream(new File(\"input\"));\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskA {\n\t\tint n;\n\t\tint [] a;\n\t\tint [] p;\n\t\tint [] sz;\n\n\t\tvoid makeSet(int id) {\n\t\t\tp[id] = id;\n\t\t\tsz[id] = 1;\n\t\t}\n\n\t\tint find(int id) {\n\t\t\tif (p[id] != id) {\n\t\t\t\tp[id] = find(p[id]);\n\t\t\t}\n\t\t\treturn p[id];\n\t\t}\n\n\t\t// from x to y\n\t\tvoid union(int x, int y) {\n\t\t\tint px = find(x);\n\t\t\tint py = find(y);\n\t\t\tif (px == py)\n\t\t\t\treturn;\n\t\t\tp[px] = py;\n\t\t\tsz[py] += sz[px];\n//\t\t\tif (sz[px] < sz[py]) {\n//\t\t\t\tp[px] = py;\n//\t\t\t\tsz[py] += sz[px];\n//\t\t\t} else {\n//\t\t\t\tp[py] = px;\n//\t\t\t\tsz[px] += sz[py];\n//\t\t\t}\n\t\t}\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tn = in.nextInt();\n\t\t\ta = new int[n + 1];\n\t\t\tp = new int[n + 1];\n\t\t\tsz = new int[n + 1];\n\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tmakeSet(i);\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\ta[i] = in.nextInt();\n\t\t\t\tunion(i, a[i]);\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tunion(i, a[i]);\n\t\t\t}\n\n\t\t\tHashSet<Integer> connectedComp = new HashSet<>();\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tconnectedComp.add(p[i]);\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"ROOTS: \");\n//\t\t\tfor (int i: connectedComp) {\n//\t\t\t\tSystem.out.println(\"ROOT \" + i);\n//\t\t\t}\n\n\t\t\tint r = connectedComp.size() - 1;\n\t\t\tList<Integer> roots = new ArrayList<>(connectedComp);\n\t\t\tint root = -1;\n\t\t\tfor (int i = 0; i < roots.size(); ++i) {\n\t\t\t\tint curRoot = roots.get(i);\n\t\t\t\tif (curRoot == a[curRoot]) {\n\t\t\t\t\troot = curRoot;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x = 0;\n\n\t\t\tif (root == -1) {\n\t\t\t\tr += 1;\n\t\t\t\troot = roots.get(0);\n\t\t\t\ta[root] = root;\n\t\t\t\tx += 1;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < roots.size(); ++i) {\n\t\t\t\tint curRoot = roots.get(i);\n\t\t\t\tif (curRoot != root) {\n\t\t\t\t\ta[curRoot] = root;\n\t\t\t\t\tx += 1;\n\t\t\t\t}\n\t\t\t}\n\n//\t\t\tout.println(x);\n\t\t\tout.println(r);\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tout.print(a[i] + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod1 = 998244353;\nconst long long mod2 = 1000000007;\nint n, p[200005];\nvector<int> cycles;\nvector<int> s[200005];\nint vis[200005];\nvector<int> trees;\nvoid find_tree(int i) {\n  if (vis[i] == 1) {\n    cycles.push_back(i);\n    return;\n  }\n  vis[i] = 1;\n  for (int j = 0; j < (s[i].size()); j++) {\n    if (s[i][j] != i) find_tree(s[i][j]);\n  }\n  vis[i] = 2;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    s[p[i]].push_back(i);\n    if (i == p[i]) trees.push_back(i);\n  }\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) find_tree(i);\n  if (trees.size() != 0) {\n    cout << trees.size() + cycles.size() - 1 << endl;\n    for (int i = 1; i < trees.size(); i++) {\n      p[trees[i]] = trees[0];\n    }\n    for (int i = 0; i < (cycles.size()); i++) {\n      p[cycles[i]] = trees[0];\n    }\n  } else {\n    cout << cycles.size() << endl;\n    for (int i = 0; i < (cycles.size()); i++) {\n      p[cycles[i]] = cycles[0];\n    }\n  }\n  for (int i = 0; i < (n); i++) cout << p[i + 1] << ' ';\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nconst long double INF = 1e9;\nint n;\nint a[N];\nint used[N];\nint answer[N];\nint main() {\n  scanf(\"%d\", &n);\n  int r = -1;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n    answer[i] = a[i];\n    if (i == a[i]) r = i;\n  }\n  int color = 0;\n  for (int i = 0; i < n; i++) {\n    if (used[i] > 0) continue;\n    int j = i;\n    color = color + 1;\n    while (true) {\n      used[j] = color;\n      int nxt = a[j];\n      if (used[nxt] == color) {\n        if (r == -1) {\n          r = j;\n        }\n        answer[j] = r;\n        break;\n      }\n      if (used[nxt] > 0) {\n        break;\n      }\n      j = nxt;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (answer[i] != a[i]) ans++;\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", 1 + answer[i]);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * \n * CREATED BY : NAITIK V\n * \n *     JAI HIND\n * \n */\n\nimport java.util.*;\nimport java.io.*;\npublic class A\t\t\n{ \n\t\t\t static FastReader sc=new FastReader(); \n\t\t\t static long dp[][];\n\t\t\t static int mod=1000000007;\n\t\t     public static void main(String[] args)\n\t\t    {\n\t\t\t  PrintWriter out=new PrintWriter(System.out);\n\t\t\t  StringBuffer sb=new StringBuffer(\"\");\n\t\t\t \n\t\t  int ttt=1;\n\t\t //  ttt =i();\n\t\t    outer :while (ttt-- > 0) \n\t\t\t{\n\t\t    \tint n=i();\n\t\t    \tint B[]=input(n);\n\t\t    \tint C[]=new int[n];\n\t\t    \tfor(int i=0;i<n;i++)\n\t\t    \t\tC[i]=B[i];\n\t\t    \tArrayList<Integer> A[]=new ArrayList[n+1];\n\t        \tfor(int i=0;i<A.length;i++) {\n\t        \t\tA[i]=new ArrayList<Integer>();\n\t        \t}\n\t        \tArrayList<ArrayList<Integer>> l=new ArrayList<>();\n\t        \tArrayList<Integer> cou=new ArrayList<Integer>();\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tA[i+1].add(B[i]);\n\t        \t\tif(B[i]!=(i+1))\n\t        \t\tA[B[i]].add(i+1);\n\t        \t\t\n\t        \t}\n\t        \tboolean v[]=new boolean[n+1];\n\t        \tfor(int i=1;i<=n;i++) {\n\t        \t\tcou.clear();\n\t        \t\tif(v[i])\n\t        \t\t\tcontinue;\n\t        \t\tdfs(A, i, v, cou);\n\t        \t\tArrayList<Integer> ll=new ArrayList<Integer>();\n\t        \t\tfor(int k : cou) {\n\t        \t\t\tll.add(k);\n\t        \t\t}\n\t        \t\tl.add(ll);\n\t        \t}\n\t        \tint par=-1;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(B[i]==(i+1)) {\n\t        \t\t\tpar=B[i];\n\t        \t\t\tbreak;\n\t        \t\t}\n\t        \t}\n\t        \tArrays.fill(v, false);\n\t        \tif(par==-1) {\n\t        \t\tArrayList<Integer> m=l.get(0);\n\t        \t\tfor(int key : m) {\n\t        \t\t\tint a=B[key-1];\n\t        \t\t\tint b=B[a-1];\n\t        \t\t\tif(key==b) {\n\t        \t\t\t\tpar=a;\n\t        \t\t\t\tB[a-1]=a;\n\t        \t\t\t\tbreak;\n\t        \t\t\t}\n\t        \t\t}\n\t        \t\tif(par==-1) {\n\t        \t\t\tint child=cycle(A, m.get(0), v, -1);\n\t        \t\t\tpar=child;\n\t        \t\t\tB[child-1]=child;\n\t\t        \t\t\n\t\t        \t\t\n\t        \t\t}\n\t        \t\tout : for(int i=1;i<l.size();i++) {\n\t\t        \t\t m=l.get(i);\n\t\t        \t\t\n\t\t        \t\tfor(int key : m) {\n\t\t        \t\t\tint a=B[key-1];\n\t\t        \t\t\tint b=B[a-1];\n\t\t        \t\t\tif(key==b) {\n\t\t        \t\t\t\tB[a-1]=par;\n\t\t        \t\t\t\tcontinue out;\n\t\t        \t\t\t}\n\t\t        \t\t}\n\t\t        \t\t\n\t\t        \t\tint child=cycle(A, m.get(0), v, -1);\n\t\t        \t\tB[child-1]=par;\n\t\t        \t\t\n\t\t        \t}\n\t        \t}\n\t        \telse {\n\t        \tout : for(int i=0;i<l.size();i++) {\n\t        \t\tArrayList<Integer> m=l.get(i);\n\t        \t\t\n\t        \t\tfor(int key : m) {\n\t        \t\t\tint a=B[key-1];\n\t        \t\t\tint b=B[a-1];\n\t        \t\t\tif(key==b) {\n\t        \t\t\t\tB[a-1]=par;\n\t        \t\t\t\tcontinue out;\n\t        \t\t\t}\n\t        \t\t}\n\t        \t\t\n\t        \t\tint child=cycle(A, m.get(0), v, -1);\n\t        \t\tB[child-1]=par;\n\t        \t\t\n\t        \t}\n\t        \t}\n\t        \tint ans=0;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(B[i]!=C[i]) {\n\t        \t\t\tans++;\n\t        \t\t}\n\t        \t}\n\t        \tSystem.out.println(ans);\n\t        \tfor(int i : B) {\n\t        \t\tout.print(i+\" \");\n\t        \t}\n\t\t    \t\n\t\t\t}\n\t\t   out.close();\n\t\t  // System.out.println(sb.toString());\n\t\t   \n\t\t   \n\t\t   //CHECK FOR N=1                    //CHECK FOR M=0\n\t\t    //CHECK FOR N=1                    //CHECK FOR M=0\n\t\t   \t//CHECK FOR N=1\n\t\t   \t//CHECK FOR N=1\n\t\t   \t//CHECK FOR N=1\n    }\n\t\t\t  \n\t\t     \n\t\t    \n\n\t\t\t  \n\t\t\t  private static void dfs(ArrayList<Integer>[] A, int i, boolean[] v,ArrayList<Integer> l) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t  v[i]=true;\n\t\t\t\t l.add(i);\n\t\t\t\t  for(int child : A[i]) {\n\t\t\t\t\t  if(!v[child]) {\n\t\t\t\t\t\t  dfs(A, child, v,l);\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t}\n\n\t\t\t  private static int cycle(ArrayList<Integer>[] A, int i, boolean[] v, int par) {\n\t\t\t\t\t\n\t\t\t\t\tv[i]=true;\n\t\t\t\t\t//System.out.println(i);\n\t\t\t\t\tfor(int child : A[i]) {\n\t\t\t\t\t\tif(!v[child]) {\n\t\t\t\t\t\t\tint res=cycle(A, child, v, i);\n\t\t\t\t\t\t\tif(res!=-1)\n\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(child !=par && par!=-1) {\n\t\t\t\t\t\t\t\treturn child;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t  \n\t\t     \n\t\t     \n\t\t     \n\t\t     \n  static class Pair implements Comparable<Pair>\n   {\n\t   int x;\n\t   int y;\n\t  \t Pair(int x,int y){\n\t  \t\t this.x=x;\n\t  \t\t this.y=y;\n\t  \t }\n\t@Override\n//\tpublic int compareTo(Pair o) {\n//\t\tif(this.x>o.x)\n//\t\t\treturn 1;\n//\t\telse if(this.x<o.x)\n//\t\t\treturn -1;\n//\t\telse {\n//\t\t\tif(this.y<o.y)\n//\t\t\t\treturn 1;\n//\t\t\telse if(this.y>o.y)\n//\t\t\t\treturn -1;\n//\t\t\telse\n//\t\t\t\treturn 0;\n//\t\t}\n//\t}\n\t\n\t\n\tpublic int compareTo(Pair o) {\n\t\t\tif (x > o.x) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (x < o.x) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (y > o.y) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (y < o.y) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n }\nstatic int[] input(int n) {\n  \tint A[]=new int[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t   }\n  \t   return A;\n     }\n  static long[] inputL(int n) {\n  \tlong A[]=new long[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.nextLong();\n  \t   }\n  \t   return A;\n     }\n  static String[] inputS(int n) {\n  \tString A[]=new String[n];\n  \t   for(int i=0;i<n;i++) {\n  \t\t   A[i]=sc.next();\n  \t   }\n  \t   return A;\n     }\n  static long sum(int A[]) {\n  \tlong sum=0;\n  \tfor(int i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n  static long sum(long A[]) {\n  \tlong sum=0;\n  \tfor(long i : A) {\n  \t\tsum+=i;\n  \t}\n  \treturn sum;\n  }\n\n  static void input(int A[],int B[]) {\n  \t   for(int i=0;i<A.length;i++) {\n  \t\t   A[i]=sc.nextInt();\n  \t\t   B[i]=sc.nextInt();\n  \t   }\n  }\n  static int[][] input(int n,int m){\n  \tint A[][]=new int[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=i();\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static char[][] charinput(int n,int m){\n  \tchar A[][]=new char[n][m];\n  \tfor(int i=0;i<n;i++) {\n  \t\tString s=s();\n  \t\tfor(int j=0;j<m;j++) {\n  \t\t\tA[i][j]=s.charAt(j);\n  \t\t}\n  \t}\n  \treturn A;\n  }\n  static int max(int A[]) {\n  \tint max=Integer.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static int min(int A[]) {\n  \tint min=Integer.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long max(long A[]) {\n  \tlong max=Long.MIN_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmax=Math.max(max, A[i]);\n  \t}\n  \treturn max;\n  }\n  static long min(long A[]) {\n  \tlong min=Long.MAX_VALUE;\n  \tfor(int i=0;i<A.length;i++) {\n  \t\tmin=Math.min(min, A[i]);\n  \t}\n  \treturn min;\n  }\n  static long mod(long x) {\n  \t int mod=1000000007;\n  \t  return ((x%mod + mod)%mod);\n  }\n  static String reverse(String s) {\n  \tStringBuffer p=new StringBuffer(s);\n  \tp.reverse();\n  \treturn p.toString();\n  }\n\n       static int i() {\n      \t return sc.nextInt();\n       }\n       static String s() {\n      \t return sc.next();\n       }\n       static long l() {\n      \t return sc.nextLong();\n       }  \n       static void sort(int[] A){\n          int n = A.length;\n          Random rnd = new Random();\n          for(int i=0; i<n; ++i){\n              int tmp = A[i];\n              int randomPos = i + rnd.nextInt(n-i);\n              A[i] = A[randomPos];\n              A[randomPos] = tmp;\n          }\n          Arrays.sort(A);\n       }\n       static void sort(long[] A){\n  \t        int n = A.length;\n  \t        Random rnd = new Random();\n  \t        for(int i=0; i<n; ++i){\n  \t            long tmp = A[i];\n  \t            int randomPos = i + rnd.nextInt(n-i);\n  \t            A[i] = A[randomPos];\n  \t            A[randomPos] = tmp;\n  \t        }\n  \t        Arrays.sort(A);\n  \t     }\n    static String sort(String s) {\n   \t Character ch[]=new Character[s.length()];\n   \t for(int i=0;i<s.length();i++) {\n   \t\t ch[i]=s.charAt(i);\n   \t }\n   \t Arrays.sort(ch);\n   \t StringBuffer st=new StringBuffer(\"\");\n for(int i=0;i<s.length();i++) {\n\t st.append(ch[i]);\n }\n return st.toString();\n}\nstatic HashMap<Integer,Integer> hash(int A[]){\n  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic HashMap<Long,Integer> hash(long A[]){\n\t  HashMap<Long,Integer> map=new HashMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\nstatic TreeMap<Integer,Integer> tree(int A[]){\n  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n  for(int i : A) {\n\t  if(map.containsKey(i)) {\n\t\t  map.put(i, map.get(i)+1);\n\t  }\n\t  else {\n\t\t  map.put(i, 1);\n\t  }\n  }\n  return map;\n}\nstatic TreeMap<Long,Integer> tree(long A[]){\n\t  TreeMap<Long,Integer> map=new TreeMap<Long, Integer>();\n\t  for(long i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n\t}\nstatic void primefact(int n) {\n\t  for(int i=2;i*i<=n;i++) {\n\t\t  if(n%i==0) {\n\t\t\t  int cnt=0;\n\t\t\t  while(n%i==0) {\n\t\t\t\t  cnt++;\n\t\t\t\t  n/=i;\n\t\t\t  }\n\t\t\t  System.out.println(i+\"^\"+cnt);\n\t\t\t  \n\t\t  }\n\t  }\n\t  if(n>1) {\n\t\t  System.out.println(n+\"^ 1\");\n\t  }\n}\n   static boolean prime(int n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static boolean prime(long n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n   static long power(long x, long y, long p)\n   {\n\n       long res = 1;\n       x = x % p;\n\n       while (y > 0) {\n\n           if (y % 2 == 1)\n               res = (res * x) % p;\n\n           y = y >> 1; \n           x = (x * x) % p;\n       }\n\n       return res;\n   }\n\n   static long modInverse(long n, long p)\n   {\n       return power(n, p - 2, p);\n   }\n   static int gcd(int a, int b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n   static long gcd(long a, long b) \n   { \n       if (a == 0) \n           return b; \n       return gcd(b % a, a); \n   } \n  \n      \n  static class FastReader \n  { \n      BufferedReader br; \n      StringTokenizer st; \n\n      public FastReader() \n      { \n          br = new BufferedReader(new\n                   InputStreamReader(System.in)); \n      } \n\n      String next() \n      { \n          while (st == null || !st.hasMoreElements()) \n          { \n              try\n              { \n                  st = new StringTokenizer(br.readLine()); \n              } \n              catch (IOException  e) \n              { \n                  e.printStackTrace(); \n              } \n          } \n          return st.nextToken(); \n      } \n\n      int nextInt() \n      { \n          return Integer.parseInt(next()); \n      } \n\n      long nextLong() \n      { \n          return Long.parseLong(next()); \n      } \n\n      double nextDouble() \n      { \n          return Double.parseDouble(next()); \n      } \n\n      String nextLine() \n      { \n          String str = \"\"; \n              try\n              { \n                  str = br.readLine(); \n              } \n              catch (IOException e) \n              { \n                  e.printStackTrace(); \n              } \n              return str; \n          } \n      } \n  } \n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTask task = new Task();\n\t\tint t = 1;\n\t\tfor (int i = 1; i <= t; i++) task.solve(i, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n \t\t\n\t\tpublic void solve(int testNumber, InputReader in, OutputWriter out) throws IOException {\n\t\t\tint n = in.nextInt();\n\t\t\tint[] arr = in.nextIntArray(n + 1, 1);\n\t\t\tboolean[] s = new boolean[n + 1];\n\t\t\tDSU dsu = new DSU(n + 1);\n\t\t\tint[] cpy = Arrays.copyOf(arr, n + 1);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (i == arr[i]) continue;\n\t\t\t\tint c = dsu.cal;\n\t\t\t\tdsu.union(i, arr[i]);\n\t\t\t\tif (c == dsu.cal) {\n\t\t\t\t\tarr[i] = i;\n\t\t\t\t\ts[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = -1;\n\t\t\tfor (int i = 1; i <= n; i++) \n\t\t\t\tif (arr[i] == i) {\n\t\t\t\t\tr = i;\n\t\t\t\t\tif (!s[i]) break;\n\t\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (arr[i] == i) arr[i] = r;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (arr[i] != cpy[i]) cnt++;\n\t\t\tout.println(cnt, \"\\n\");\n\t\t\tout.printIntArray(arr, 1, n + 1);\n \t\t}\n\t}\n\t\n\tstatic class DSU {\n\t\tint[] par, size, rank;\n\t\tboolean[] valid;\n\t\tint n, cal;\n\t\t\n\t\tpublic DSU(int n) {\n\t\t\tthis.n = n;\n\t\t\tinit(n);\n\t\t}\n\t\t\n\t\tpublic void init(int n) {\n\t\t\tpar = new int[n];\n\t\t\tsize = new int[n];\n\t\t\trank = new int[n];\n\t\t\tvalid = new boolean[n];\n\t\t\tcal = n;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean isValid(int x) {\n\t\t\treturn valid[x];\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (par[x] != x) return par[x] = find(par[x]);\n\t\t\treturn par[x];\n\t\t}\n\t\t\n\t\tpublic boolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y) {\n\t\t\t\tvalid[x] = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsize[x] = size[y] = size[x] + size[y];\n\t\t\tvalid[x] = valid[y] = valid[x] | valid[y];\n\t\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\t\telse par[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\tcal--;\n\t\t}\n\t\t\n\t\tpublic int getSize(int x) {\n\t\t\treturn size[find(x)];\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tprivate void tokenize() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\ttokenize();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic char nextChar() {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t\t\n\t\tpublic float nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int size, int a) {\n\t\t\ttokenize();\n\t\t\tint[] arr=new int[size];\n\t\t\tfor(int i = a; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Integer.parseInt(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int size, int a) {\n\t\t\ttokenize();\n\t\t\tlong[] arr=new long[size];\n\t\t\tfor(int i = a; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Long.parseLong(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic float[] nextFloatArray(int size, int a) {\n\t\t\ttokenize();\n\t\t\tfloat[] arr=new float[size];\n\t\t\tfor(int i = a; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Float.parseFloat(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int size, int a) {\n\t\t\ttokenize();\n\t\t\tdouble[] arr=new double[size];\n\t\t\tfor(int i = a; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Double.parseDouble(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic String[] nextStringArray(int size, int a) throws IOException {\n\t\t\tString[] arr=new String[size];\n\t\t\tfor(int i = a; i < size; i++) \n\t\t\t\tarr[i] = reader.readLine();\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic char[] nextCharArray(int size) throws IOException {\n\t\t\treturn reader.readLine().toCharArray();\n\t\t}\n\t}\n\n\tstatic class OutputWriter {\n\t\tpublic PrintWriter pw;\n\n\t\tpublic OutputWriter(OutputStream stream) {\n\t\t\tpw = new PrintWriter(stream);\n\t\t}\n\t\t\n\t\tpublic void println(Object... obj) {\n\t\t\tif (obj.length == 0) pw.println();\n\t\t\telse {\n\t\t\t\tString delimiter = (String) obj[obj.length - 1];\n\t\t\t\tfor (int i = 0 ; i < obj.length - 1; i++) pw.print(obj[i] + delimiter);\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tpw.close();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tpw.flush();\n\t\t}\n\n\t\tpublic void printStringArray(String[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.println(arr[i]);\n\t\t}\n\t\t\n\t\tpublic void printBooleanArray(boolean[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printIntArray(int[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printLongArray(long[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printCharArray(char[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printFloatArray(float[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printDoubleArray(double[] arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\t\t\n\t\tpublic void printIntArrayList(ArrayList<Integer> arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr.get(i) + \" \");\n\t\t}\n\t\t\n\t\tpublic void printLongArrayList(ArrayList<Long> arr, int a, int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr.get(i) + \" \");\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\n\n \nimport java.util.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.io.*;\nimport java.math.*;\nimport java.text.DecimalFormat;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \tpublic InputReader(InputStream st) {\n            this.stream = st;\n\t} \n\tpublic int read() {\n            if (snumChars == -1)\n\t \tthrow new InputMismatchException();\n            if (curChar >= snumChars) {\n\t\tcurChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n\t\t} \n                catch (IOException e) {\n                    throw new InputMismatchException();\n           \t}\n\t\tif (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n\t}\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n               \tc = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n\t\tsgn = -1;\n\t\tc = read();\n            }\n            int res = 0;\n            do {\n\t\tres *= 10;\n\t\tres += c - '0';\n\t\tc = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n\t} \n\tpublic int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n\t\ta[i] = ni();\n            }\n            return a;\n\t} \n\tpublic String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n\t\tc = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n\t\tres.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n\t}\n\tpublic String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n\t\tc = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n\tpublic boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n\t} \n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static boolean f,v[];\n    static int p[],root=-1;\n    public static void main(String[] args) throws IOException {   \n        InputReader sc=new InputReader(System.in);\n        int n=sc.ni();\n        \n        p=new int[n+1];\n        \n        int t[]=new int[n+1];\n        v=new boolean[n+1];\n        \n        for(int i=1;i<=n;i++){\n            \n            int a=sc.ni();\n            t[i]=a;\n            p[i]=a;\n            \n        }\n        for(int i=1;i<=n;i++){\n            if(i==p[i]){\n                root=i;\n                //break;\n            }\n        }\n        int c=0;\n        int temp[]=new int[n+1];\n        Arrays.fill(temp,-1);\n        for(int i=1;i<=n;i++){\n           \n                \n                \n                \n                int i1=i;\n                \n                while(i1!=p[i1]&&temp[i1]==-1){                  \n                    \n                    temp[i1]=i;\n                    i1=p[i1];\n                }\n                if(temp[i1]==i&&p[i1]!=i1){\n                    if(root==-1){\n                        root=i1;\n                        p[i1]=i1;\n                    }\n                    else{\n                        p[i1]=root;\n                    }\n                    c++;\n                }\n                else if(root!=i1&&p[i1]==i1){\n                    p[i1]=root;\n                    c++;\n                }\n                \n                \n                \n                \n                \n            }\n                \n\n        \n        w.println(c);\n        for(int i=1;i<=n;i++){\n            w.print(p[i]+\" \");\n        }\n        w.println();\n        w.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, root;\nint p[200001], cp[200001];\nvector<int> adj[200001];\nint vis[200001], delta = 0;\nvoid dfs(int u) {\n  if (vis[u]) return;\n  if (u == root) return;\n  vis[u] = 1;\n  int& v = p[u];\n  if (v == u) {\n    if (root == -1)\n      root = u;\n    else {\n      v = root;\n      delta++;\n    }\n  } else {\n    dfs(v);\n    if (vis[v] == 1) {\n      if (root == -1) root = u;\n      v = root;\n      delta++;\n    }\n  }\n  vis[u] = 2;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  root = -1;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n    cp[i] = p[i];\n    if (i == p[i]) root = i;\n  }\n  for (int i = 1; i <= n; i++) dfs(i);\n  for (int i = 1; i <= n; i++) {\n    if (p[i] == i && i != root) {\n      p[i] = root;\n      delta++;\n    }\n  }\n  delta = 0;\n  for (int i = 1; i <= n; i++) delta += (cp[i] != p[i]);\n  cout << delta << '\\n';\n  for (int i = 1; i <= n; i++) cout << p[i] << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint vis[222222];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int a[n + 11];\n  int root = -1, ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == i) root = a[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      int j = i;\n      while (!vis[j]) {\n        vis[j] = i;\n        j = a[j];\n      }\n      if (vis[j] != i) continue;\n      if (root == -1) {\n        root = j;\n        a[root] = root;\n        ans++;\n        continue;\n      }\n      if (j != root) {\n        a[j] = root;\n        ans++;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; ++i) printf(\"%d \", a[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, root, a[200010], f[200010];\nint find(int x) {\n  if (f[x] == x) return x;\n  return f[x] = find(f[x]);\n}\nint main() {\n  cin >> n;\n  int num = 0;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 1; i <= n; i++) f[i] = i;\n  for (int i = 1; i <= n; i++)\n    if (a[i] == i) root = i;\n  for (int i = 1; i <= n; i++) {\n    int x = find(i), y = find(a[i]);\n    if (x == y)\n      if (root > 0)\n        a[i] = root, num += (i != root);\n      else\n        root = i, num++, a[i] = i;\n    else\n      f[x] = y;\n  }\n  cout << num << endl;\n  for (int i = 1; i <= n; i++) cout << a[i] << \" \";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), p[] = new int[n+1], i, root = -1, c = 0, seen[] = new int[n+1];\n\t\t\n\t\tfor (i=1; i<n+1; i++)\n\t\t\tp[i] = sc.nextInt();\n\t\t\n\t\tfor(i=1; i<n+1; i++)\n\t\t\tif(p[i] == i){\n\t\t\t\tseen[i] = n+1;\n\t\t\t\troot = i;\n\t\t\t\tbreak;\t\t\t\t\n\t\t\t}\n\t\t\n\t\tfor (i=1; i<n+1; i++){\n\t\t\t\n\t\t\tif(seen[i] != 0) continue;\n\t\t\tseen[i] = i;\n\t\t\tint at = i;\n\t\t\t\n\t\t\twhile(seen[p[at]] == 0){\n\t\t\t\tat = p[at];\n\t\t\t\tseen[at] = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(seen[p[at]] == i){\n\t\t\t\tc++;\n\t\t\t\tif(root != -1)\n\t\t\t\t\tp[at] = root;\n\t\t\t\telse{\n\t\t\t\t\tp[at] = at;\n\t\t\t\t\troot = at;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(c);\n\t\tfor(i =1; i <= n; i++)\n\t\t\tSystem.out.print(p[i] + \" \");\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B implements Runnable {\n\n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    private void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        String fileName = \"\";\n        if (ONLINE_JUDGE && fileName.isEmpty()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                if (fileName.isEmpty()) {\n                    in = new BufferedReader(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(\"output.txt\");\n                } else {\n                    in = new BufferedReader(new FileReader(fileName + \".in\"));\n                    out = new PrintWriter(fileName + \".out\");\n                }\n            } catch (Throwable t) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            }\n        }\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readIntArray(int size) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, new B(), \"\", 256 * (1L << 20)).start();\n        //new B().run();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    @Override\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    class DSU {\n        int[] p;\n        Random random = new Random();\n\n        DSU(int size) {\n            p = new int[size];\n            for (int i = 0; i < size; i++) {\n                p[i] = i;\n            }\n        }\n\n        int find(int x) {\n            return p[x] == x ? x : (p[x] = find(p[x]));\n        }\n\n        void unite(int a, int b) {\n            if (random.nextBoolean()) {\n                p[a] = b;\n            } else {\n                p[b] = a;\n            }\n        }\n    }\n\n    private void solve() {\n        int n = readInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = readInt() - 1;\n        }\n        int root = -1;\n        int changes = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == a[i]) {\n                if (root == -1) {\n                    root = i;\n                } else {\n                    changes++;\n                    a[i] = root;\n                }\n            }\n        }\n\n        DSU dsu = new DSU(n);\n        for (int i = 0; i < n; i++) {\n            if (i == root) continue;\n            int ca = dsu.find(i);\n            int cb = dsu.find(a[i]);\n            if (ca == cb) {\n                if (root == -1) {\n                    root = i;\n                }\n                changes++;\n                a[i] = root;\n            } else {\n                dsu.unite(ca, cb);\n            }\n        }\n\n        out.println(changes);\n        for (int x : a) {\n            out.print(x + 1 + \" \");\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n=int(input())\na=list(map(int,input().split()))\npar=[]\nfor i in range(n):\n\tif a[i]==i+1:\n\t\tpar.append(i)\nv=[False for i in range(n)]\nfor i in par:\n\tv[i]=True\nccl=[]\nfor i in range(n):\n\tif v[i]:continue\n\ts=[i]\n\tv[i]=True\n\tp=set(s)\n\tt=True\n\twhile s and t:\n\t\tx=s.pop()\n\t\tj=a[x]-1\n\t\tif j in p:\n\t\t\tccl.append(j)\n\t\t\tt=False\n\t\telse:\n\t\t\ts.append(j)\n\t\t\tp.add(j)\n\t\tif v[j]:t=False\n\t\telse:v[j]=True\nif len(par)==0:\n\tprint(len(ccl))\n\tc=ccl[0]\n\ta[c]=c+1\n\tfor i in range(1,len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)\nelse:\n\tprint(len(ccl)+len(par)-1)\n\tc=par[0]\n\tfor i in range(1,len(par)):\n\t\ta[par[i]]=c+1\n\tfor i in range(len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class _Fix_A_Tree {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tint[] arr = new int[n + 1];\n\t\tint[] b = new int[n + 1];\n\t\tint root = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tarr[i] = scn.nextInt();\n\t\t\tif (i == arr[i]) {\n\t\t\t\troot = arr[i];\n\t\t\t}\n\t\t}\n\t\tb[root] = 1;\n\t\tint cur = 1;\n\t\tint ind;\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (b[i] == 0) {\n\t\t\t\tind = i;\n\t\t\t\tcur++;\n\n\t\t\t\twhile (b[ind] == 0) {\n\t\t\t\t\tb[ind] = cur;\n\t\t\t\t\tind = arr[ind];\n\t\t\t\t}\n\t\t\t\tif (b[ind] == cur) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tif (root == 0) {\n\t\t\t\t\t\troot = ind;\n\t\t\t\t\t\tarr[root] = root;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarr[ind] = root;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t\tfor (int i = 1; i <=n; i++) {\nSystem.out.print(arr[i]+\" \");\n\t\t}\n\t}\n\n\tstatic boolean b = false;\n\n\tpublic static void dfs(int v, int[] arr, HashSet<Integer> visit, ArrayList<Integer> backedge) {\n\n\t\tif (v == arr[v]) {\n\t\t\tb = true;\n\t\t\treturn;\n\t\t}\n\t\tif (visit.contains(arr[v])) {\n\t\t\tbackedge.add(1);\n\t\t\treturn;\n\t\t}\n\t\tvisit.add(v);\n\t\tdfs(arr[v], arr, visit, backedge);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nstruct debugger {\n  template <typename T>\n  debugger& operator,(const T& v) {\n    cerr << v << \" \";\n    return *this;\n  }\n} dbg;\nvector<int> heads, circs;\nint par[200005], color[200005];\nvoid DFS(int s) {\n  color[s] = 1;\n  if (color[par[s]] == 0)\n    DFS(par[s]);\n  else if (color[par[s]] == 1) {\n    if (par[s] == s)\n      heads.push_back(s);\n    else\n      circs.push_back(s);\n  }\n  color[s] = 2;\n}\nint main() {\n  int n, i, chng, s;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &par[i]);\n    par[i]--;\n    color[i] = 0;\n  }\n  for (i = 0; i < n; i++)\n    if (color[i] == 0) DFS(i);\n  chng = 0;\n  s = 0;\n  if (heads.size() == 0) {\n    par[circs[0]] = circs[0];\n    heads.push_back(circs[0]);\n    chng = s = 1;\n  }\n  for (i = 1; i < heads.size(); i++) {\n    par[heads[i]] = heads[0];\n    chng++;\n  }\n  for (i = s; i < circs.size(); i++) {\n    par[circs[i]] = heads[0];\n    chng++;\n  }\n  printf(\"%d\\n\", chng);\n  for (i = 0; i < n - 1; i++) printf(\"%d \", par[i] + 1);\n  printf(\"%d\\n\", par[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const N = 2e5 + 41;\nint n, p[N], root, ans, was[N];\nvector<int> cyc;\nvoid print() {\n  printf(\"%d\\n\", ans);\n  for (int i = 1; i <= n; ++i) {\n    if (i > 1) {\n      printf(\" \");\n    }\n    printf(\"%d\", p[i]);\n  }\n  exit(0);\n}\nvoid findRoot() {\n  for (int i = 1; i <= n; ++i) {\n    if (p[i] == i) {\n      if (root) {\n        ++ans;\n        p[i] = root;\n      } else {\n        root = i;\n      }\n    }\n  }\n}\nvoid dfs(int u) {\n  was[u] = 1;\n  int to = p[u];\n  if (to == u) {\n    was[u] = 2;\n    return;\n  }\n  if (was[to] == 2) {\n  } else {\n    if (was[to] == 1) {\n      cyc.push_back(u);\n    } else {\n      dfs(to);\n    }\n  }\n  was[u] = 2;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &p[i]);\n  }\n  findRoot();\n  for (int i = 1; i <= n; ++i) {\n    if (!was[i]) {\n      dfs(i);\n    }\n  }\n  if (!root) {\n    root = cyc[0];\n  }\n  for (int i = 0; i < cyc.size(); ++i) {\n    p[cyc[i]] = root;\n    ++ans;\n  }\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class CF698B{ \n  public static int parent[], arr[];\n  public static void main(String[] args)throws Exception {\n    InputReader in = new InputReader(System.in);\n    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n    int n = in.nextInt();\n    Node[] comp = new Node[n+1];\n   \n    parent = new int[n+1];\n    arr = new int[n+1];\n    for(int i = 1; i <= n; i++){\n      arr[i] = in.nextInt();\n      parent[i] = i;\n      comp[i] = new Node();\n    }\n    \n    for(int i = 1; i <= n; i++){\n      int u = find(i), v = find(arr[i]);\n      if(i == arr[i]){\n        comp[u].root = i;\n      }\n      else if(u == v){\n        comp[u].cycle = i;\n      }\n      parent[v] = u;\n    }\n    \n//    int cnt = 0;  \n//    for(int i = 1; i <= n; i++){\n//      if(find(i) == i) cnt++;\n//    }\n    \n    ArrayList<Integer> roots = new ArrayList<Integer>();\n    ArrayList<Node> list = new ArrayList<Node>();\n    for(int i = 1; i <= n; i++){\n      if(comp[i].root != -1 || comp[i].cycle != -1){\n        list.add(comp[i]);\n      }\n      if(comp[i].root != -1){\n        roots.add(comp[i].root);\n      }\n    }\n    \n    \n    int cnt = 0;\n    for(Node cmp : list){\n      if(cmp.cycle != -1){\n        if(roots.size() > 0) arr[cmp.cycle] = roots.get(0);\n        else{\n          arr[cmp.cycle] = cmp.cycle;\n          roots.add(cmp.cycle);\n        }\n        cnt++;\n      }\n      else if(cmp.root != -1){\n        int x = arr[cmp.root];\n        if(roots.size() == 0 || roots.get(0) != x) cnt++;\n        if(roots.size() > 0)arr[cmp.root] = roots.get(0);\n        else{\n          arr[cmp.root] = cmp.root;\n          roots.add(cmp.root);\n        }\n      }\n    }\n    \n    pw.println(cnt);\n    for(int i = 1; i <= n; i++){\n      pw.print(arr[i]+\" \");\n    }\n    pw.println();\n    \n    \n    \n    pw.close();\n  }\n  \n  static int find(int i) {\n    int p = parent[i];\n    if (i == p) return i;\n    return parent[i] = find(p);\n  }\n  \n  static class Node{\n    public int root = -1, cycle = -1;\n    //public ArrayList<Integer> list;\n    public String toString(){\n      return root+\" \"+cycle;\n    }\n  }\n  \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    \n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n    \n    public String next()throws Exception {\n      while (tokenizer == null || !tokenizer.hasMoreTokens())\n        tokenizer = new StringTokenizer(reader.readLine());\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine()throws Exception {\n      String line = null;\n      tokenizer = null;\n      line =  reader.readLine();\n      return line;\n    }\n    \n    public int nextInt()throws Exception {\n      return Integer.parseInt(next());\n    }\n    \n    public double nextDouble() throws Exception{\n      return Double.parseDouble(next());\n    }\n    \n    public long nextLong()throws Exception {\n      return Long.parseLong(next());\n    }\n    \n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, vis1[200007], a[200007], vis[200007], k, r, f, i1 = -1;\nvector<int> v[200007], ans;\nvoid DFS(int x) {\n  cout << x << \" \";\n  vis[x] = 1e7;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (!vis[v[x][i]]) DFS(v[x][i]);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    v[i].push_back(a[i]);\n    v[a[i]].push_back(i);\n  }\n  for (int i = 1; i <= n; i++) {\n    int x = i;\n    while (!vis1[x]) {\n      vis1[x] = i;\n      x = a[x];\n    }\n    if (i != vis1[x]) continue;\n    k++;\n    ans.push_back(x);\n  }\n  for (int i = 0; i < ans.size(); i++) {\n    if (a[ans[i]] == ans[i]) {\n      i1 = i;\n      break;\n    }\n  }\n  if (i1 == -1) {\n    a[ans[0]] = ans[0];\n    i1 = 0;\n    k++;\n  }\n  for (int i = 0; i < ans.size(); i++) {\n    if (i == i1) continue;\n    a[ans[i]] = ans[i1];\n  }\n  cout << k - 1 << endl;\n  for (int i = 1; i <= n; i++) cout << a[i] << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200010;\nint f[maxn];\nint vis[maxn] = {};\nint n;\nint main() {\n  cin >> n;\n  for (int i = (1); i <= (n); i++) {\n    scanf(\"%d\", f + i);\n  }\n  int huan = 0, root = 0;\n  vector<int> hh;\n  hh.clear();\n  for (int i = (1); i <= (n); i++) {\n    if (!vis[i]) {\n      int num = 0;\n      int u = i;\n      do {\n        num++;\n        vis[u] = i;\n        u = f[u];\n      } while (!vis[u]);\n      if (vis[u] == vis[i]) {\n        huan++;\n        if (u == f[u] && !root)\n          root = u;\n        else\n          hh.push_back(u);\n      }\n    }\n  }\n  printf(\"%d\\n\", hh.size());\n  if (!root) {\n    root = hh[hh.size() - 1];\n    hh.pop_back();\n    f[root] = root;\n  }\n  for (int i = (0); i <= (((int)hh.size()) - 1); i++) f[hh[i]] = root;\n  for (int i = (1); i <= (n); i++) printf(\"%d \", f[i]);\n  return 0;\n}\n"
        }
    ]
}