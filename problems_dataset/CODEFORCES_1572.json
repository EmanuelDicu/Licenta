{
    "name": "1572_F. Stations",
    "source": "CODEFORCES",
    "description": "There are n cities in a row numbered from 1 to n.\n\nThe cities will be building broadcasting stations. The station in the i-th city has height h_i and range w_i. It can broadcast information to city j if the following constraints are met: \n\n  * i \u2264 j \u2264 w_i, and \n  * for each k such that i < k \u2264 j, the following condition holds: h_k < h_i. \n\nIn other words, the station in city i can broadcast information to city j if j \u2265 i, j is in the range of i-th station, and i is strictly highest on the range from i to j (including city j).\n\nAt the beginning, for every city i, h_i = 0 and w_i = i.\n\nThen q events will take place. During i-th event one of the following will happen: \n\n  * City c_i will rebuild its station so that its height will be strictly highest among all stations and w_{c_i} will be set to g_i. \n  * Let b_j be the number of stations that can broadcast information to city j. Print the sum of b_j over all j satisfying l_i \u2264 j \u2264 r_i. \n\n\n\nYour task is to react to all events and print answers to all queries.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 2\u22c510^5) \u2014 number of cities and number of events.\n\nThen q lines follow. The i-th line begins with an integer p_i (p_i = 1 or p_i = 2).\n\nIf p_i = 1 a station will be rebuilt. Then two integers c_i and g_i (1 \u2264 c_i \u2264 g_i \u2264 n) follow \u2014 the city in which the station is rebuilt and its new broadcasting range.\n\nIf p_i = 2 you are given a query. Then two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) follow \u2014 the range of cities in the query.\n\nOutput\n\nFor each query, print in a single line the sum of b_j over the given interval.\n\nExamples\n\nInput\n\n\n1 3\n2 1 1\n1 1 1\n2 1 1\n\n\nOutput\n\n\n1\n1\n\n\nInput\n\n\n5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n\n\nOutput\n\n\n4\n10\n5\n4\n5\n\nNote\n\nIn the first test case, only station 1 reaches city 1 before and after it is rebuilt.\n\nIn the second test case, after each rebuild, the array b looks as follows: \n\n  1. [1, 1, 1, 2, 1]; \n  2. [1, 2, 2, 3, 2]; \n  3. [1, 2, 2, 1, 2]; \n  4. [1, 1, 2, 1, 2]; \n  5. [1, 1, 2, 1, 1]. ",
    "difficulty": "F",
    "tags": [
        "data structures"
    ],
    "rating": 3400,
    "public_test": [
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n5\n4\n5\n"
        },
        {
            "input": "1 3\n2 1 1\n1 1 1\n2 1 1\n",
            "output": "1\n1\n"
        }
    ],
    "generated_test": [
        {
            "input": "1 3\n2 1 1\n1 1 1\n1 1 1\n",
            "output": "1\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n7\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n7\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n8\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n7\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 3 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n6\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n8\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n2 2 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n8\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n3\n6\n"
        },
        {
            "input": "1 3\n2 1 1\n2 1 1\n1 1 1\n",
            "output": "1\n1\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n7\n3\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n1 1 5\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 3\n2 2 5\n",
            "output": "4\n8\n7\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 3 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n6\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 7\n2 2 4\n2 3 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n2\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 2\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n2\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n1 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n2 2 3\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n4\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 2 4\n2 1 5\n1 4 7\n2 2 4\n2 3 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n2\n7\n"
        },
        {
            "input": "1 3\n2 1 1\n2 1 1\n2 1 1\n",
            "output": "1\n1\n1\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "5\n8\n8\n4\n6\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n3\n"
        },
        {
            "input": "5 10\n1 3 6\n2 3 5\n1 1 4\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 4\n2 2 5\n",
            "output": "4\n8\n7\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n1 1 5\n1 4 4\n2 4 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n1\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 9\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n9\n5\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n2 3 5\n2 2 5\n",
            "output": "4\n8\n7\n4\n5\n6\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 3\n",
            "output": "5\n8\n8\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n1 1 5\n1 4 4\n1 4 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n1 3 5\n2 2 3\n",
            "output": "5\n8\n4\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 25\n2 1 5\n2 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n5\n9\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n1 3 5\n2 2 4\n",
            "output": "5\n8\n4\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 3\n1 3 5\n2 2 4\n",
            "output": "5\n8\n4\n3\n4\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 3\n2 3 5\n2 2 4\n",
            "output": "5\n8\n4\n3\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "4\n10\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 4 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "3\n7\n8\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n5\n3\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 4\n2 2 4\n2 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n5\n4\n5\n6\n"
        },
        {
            "input": "5 10\n2 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 3 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "2\n3\n7\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 3\n2 2 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n4\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n2 4 5\n2 2 4\n2 2 3\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n4\n7\n4\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 9\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "4\n9\n5\n4\n4\n"
        },
        {
            "input": "5 9\n1 1 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n7\n8\n3\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 4\n2 4 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n1\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "4\n8\n7\n4\n6\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 20\n2 1 4\n1 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n7\n3\n7\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n2 3 5\n2 2 4\n",
            "output": "5\n8\n4\n4\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n1 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "11\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 2\n2 1 5\n1 4 5\n2 2 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n7\n6\n3\n7\n"
        },
        {
            "input": "5 10\n1 4 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 1\n1 3 5\n2 2 5\n",
            "output": "3\n7\n8\n0\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 2\n2 1 5\n1 4 5\n2 2 3\n2 2 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n7\n3\n3\n5\n"
        },
        {
            "input": "5 9\n1 1 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n7\n3\n3\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 10\n2 1 5\n1 4 5\n1 2 5\n1 2 4\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n4\n7\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 4\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n9\n4\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 4\n2 1 5\n1 4 4\n2 4 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "1\n9\n1\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 13\n1 2 4\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n9\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 2 5\n2 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "4\n8\n7\n4\n5\n7\n7\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 3\n1 2 3\n2 2 3\n1 3 1\n2 2 3\n",
            "output": "4\n8\n5\n3\n"
        },
        {
            "input": "5 10\n2 3 4\n1 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "2\n11\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n1 3 5\n1 1 2\n2 1 5\n1 4 5\n2 2 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "8\n6\n3\n7\n"
        },
        {
            "input": "5 10\n1 4 6\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 1\n1 3 5\n2 2 5\n",
            "output": "4\n7\n8\n0\n6\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n4\n4\n5\n"
        },
        {
            "input": "5 6\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 3\n1 2 3\n2 2 3\n1 3 1\n2 2 3\n",
            "output": "4\n8\n5\n"
        },
        {
            "input": "5 9\n1 1 3\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 3\n1 3 5\n1 2 5\n",
            "output": "4\n7\n3\n3\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 4 4\n2 2 4\n1 2 5\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n4\n4\n6\n"
        },
        {
            "input": "5 9\n1 1 3\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 1 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "4\n7\n3\n4\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 2 4\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n6\n4\n7\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n6\n6\n10\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 1 4\n1 5 5\n2 2 5\n",
            "output": "5\n10\n6\n10\n10\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 1\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n6\n3\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 2\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n2\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n9\n7\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 1 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "6\n9\n5\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n2 5 5\n2 2 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n2\n9\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 1 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 2 5\n1 4 7\n2 2 4\n2 3 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n5\n2\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 1\n1 5 5\n2 1 5\n1 2 2\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n1\n9\n2\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n1 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "6\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 2\n1 4 5\n2 2 4\n2 2 3\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n3\n5\n4\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 2 4\n2 1 5\n1 4 7\n2 2 4\n2 3 3\n1 1 5\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n2\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 9\n2 2 4\n1 2 3\n2 1 3\n1 2 5\n2 2 5\n",
            "output": "4\n9\n5\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 4\n1 3 5\n2 2 5\n",
            "output": "4\n8\n7\n5\n7\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 3 5\n",
            "output": "5\n8\n8\n4\n5\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 2\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n2\n"
        },
        {
            "input": "5 5\n1 3 4\n2 3 5\n1 1 10\n2 1 5\n1 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n1 1 5\n1 4 4\n2 4 4\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n1\n4\n6\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 4 3\n2 2 3\n1 3 5\n2 2 3\n",
            "output": "4\n8\n9\n4\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n1 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n1 3 5\n2 2 3\n",
            "output": "5\n4\n4\n2\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 3 5\n2 1 5\n1 2 3\n2 2 3\n1 3 4\n2 2 3\n",
            "output": "4\n8\n8\n3\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 3\n1 2 3\n2 1 3\n1 3 5\n2 2 4\n",
            "output": "5\n8\n0\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 3\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "3\n9\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 2 5\n1 2 3\n2 2 3\n1 4 5\n2 2 5\n",
            "output": "4\n10\n8\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 6\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 1 5\n",
            "output": "4\n8\n7\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 4\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n5\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 5\n1 4 4\n2 2 4\n2 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n10\n5\n4\n5\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 2 5\n1 4 5\n2 2 3\n2 2 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n4\n5\n"
        },
        {
            "input": "6 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 2\n2 2 2\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n1\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n2 4 5\n2 2 4\n2 2 3\n2 3 3\n1 5 5\n2 2 5\n",
            "output": "4\n9\n4\n7\n4\n2\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 10\n2 1 5\n1 4 5\n2 2 5\n1 2 4\n2 1 3\n1 2 5\n2 2 5\n",
            "output": "4\n10\n7\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 13\n2 1 4\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n9\n6\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 3 5\n1 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "4\n8\n5\n4\n6\n6\n"
        },
        {
            "input": "5 3\n1 3 4\n2 3 5\n1 1 20\n2 1 4\n1 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n"
        },
        {
            "input": "5 9\n2 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 2 3\n1 3 1\n2 2 3\n",
            "output": "2\n3\n7\n8\n3\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 1 3\n2 3 5\n2 2 4\n",
            "output": "5\n8\n9\n4\n5\n5\n"
        },
        {
            "input": "5 9\n1 1 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 2\n1 3 5\n2 2 5\n",
            "output": "5\n7\n3\n1\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 4\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "5\n9\n4\n3\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 8\n2 1 4\n1 4 5\n2 2 5\n2 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "6\n8\n7\n4\n5\n7\n7\n"
        },
        {
            "input": "5 6\n1 3 3\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 3\n1 2 3\n2 2 3\n1 3 1\n2 2 3\n",
            "output": "3\n7\n5\n"
        },
        {
            "input": "5 10\n1 4 9\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 1\n1 3 5\n2 2 5\n",
            "output": "4\n7\n3\n0\n6\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 4 4\n2 2 4\n1 2 5\n2 1 5\n1 5 5\n2 2 5\n",
            "output": "5\n10\n4\n8\n6\n"
        },
        {
            "input": "5 9\n1 1 3\n2 1 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "7\n7\n3\n3\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 4 4\n2 2 4\n1 2 4\n2 1 3\n1 5 5\n1 2 5\n",
            "output": "5\n10\n4\n4\n"
        },
        {
            "input": "5 9\n1 1 1\n2 3 5\n1 1 5\n2 1 4\n1 5 8\n2 1 2\n1 1 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "3\n7\n3\n4\n"
        },
        {
            "input": "6 10\n1 3 6\n2 6 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "0\n10\n6\n6\n10\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 1\n2 1 5\n1 3 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n6\n4\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 2\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n10\n2\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 8\n2 3 2\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "0\n10\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 5\n2 1 4\n1 1 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "1\n8\n9\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 2\n1 5 5\n2 1 5\n1 1 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n3\n9\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 2 5\n1 4 7\n2 2 4\n2 3 3\n1 1 3\n1 5 5\n2 2 1\n",
            "output": "4\n8\n5\n2\n0\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 2 4\n2 1 5\n1 3 7\n2 2 4\n2 3 3\n1 1 5\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n1\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 9\n2 2 4\n1 2 3\n2 2 3\n1 2 5\n2 2 5\n",
            "output": "4\n9\n5\n3\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 3 5\n2 2 5\n1 2 3\n2 1 4\n1 3 5\n2 2 5\n",
            "output": "4\n8\n7\n6\n6\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 3\n1 1 5\n2 1 4\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 3 5\n",
            "output": "1\n8\n8\n4\n5\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 2\n2 4 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n9\n0\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 5\n1 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 3\n1 3 5\n2 2 3\n",
            "output": "5\n4\n3\n2\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 4\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 5\n2 3 5\n2 2 4\n",
            "output": "5\n8\n4\n6\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n2 5 5\n2 2 5\n1 2 3\n2 2 3\n1 4 5\n2 2 5\n",
            "output": "4\n10\n2\n9\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 2\n1 1 6\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 1 5\n",
            "output": "0\n8\n7\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 4\n2 1 3\n1 4 5\n2 2 5\n",
            "output": "4\n10\n5\n4\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 2 5\n1 4 5\n2 2 3\n2 1 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n8\n4\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 5\n1 2 3\n2 1 3\n2 5 5\n2 2 4\n",
            "output": "5\n8\n9\n4\n1\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 8\n2 1 4\n2 4 5\n2 2 5\n2 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "6\n8\n5\n9\n4\n5\n9\n9\n"
        },
        {
            "input": "5 9\n1 1 3\n2 1 4\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 2 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "6\n7\n3\n3\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 2\n1 2 8\n2 1 5\n1 4 4\n2 2 4\n1 2 4\n2 1 3\n1 5 5\n1 2 5\n",
            "output": "0\n10\n4\n4\n"
        },
        {
            "input": "6 10\n1 3 6\n2 6 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "0\n10\n6\n5\n10\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 2 2\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n10\n2\n4\n3\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 5\n2 1 4\n1 1 5\n2 2 5\n1 2 3\n2 1 3\n2 3 5\n2 2 5\n",
            "output": "1\n8\n9\n4\n5\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n2 1 5\n1 4 9\n2 2 4\n1 2 3\n2 2 3\n1 2 5\n2 2 5\n",
            "output": "6\n9\n5\n3\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 3 4\n2 2 5\n1 2 3\n2 1 4\n1 3 5\n2 2 5\n",
            "output": "4\n8\n6\n6\n6\n"
        },
        {
            "input": "5 10\n1 4 11\n2 3 5\n1 1 4\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 5\n2 3 5\n2 2 4\n",
            "output": "4\n7\n3\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 2 3\n1 4 5\n2 2 3\n2 1 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "4\n4\n4\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 8\n2 1 4\n2 4 5\n2 2 5\n2 2 3\n2 1 3\n2 3 5\n2 2 5\n",
            "output": "6\n8\n5\n9\n4\n5\n7\n9\n"
        },
        {
            "input": "11 9\n1 1 4\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 1 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "5\n7\n3\n4\n"
        },
        {
            "input": "6 10\n1 3 6\n2 6 5\n1 4 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "0\n6\n3\n4\n7\n"
        },
        {
            "input": "5 10\n1 1 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 2 2\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "5\n9\n2\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 5\n2 1 4\n1 1 5\n2 2 5\n1 2 3\n2 1 3\n2 2 5\n2 2 5\n",
            "output": "1\n8\n9\n4\n6\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n2 1 5\n1 4 9\n2 2 1\n1 2 3\n2 2 3\n1 2 5\n2 2 5\n",
            "output": "6\n9\n0\n3\n8\n"
        },
        {
            "input": "5 4\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 3 4\n2 2 5\n1 2 3\n2 1 4\n1 3 5\n2 2 5\n",
            "output": "4\n8\n"
        },
        {
            "input": "5 10\n1 4 11\n2 3 5\n1 1 4\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 5\n2 3 2\n2 2 4\n",
            "output": "4\n7\n3\n5\n0\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 6\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 6\n2 1 5\n",
            "output": "1\n8\n7\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 4\n2 2 3\n1 4 5\n2 2 3\n2 1 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "5\n4\n4\n5\n5\n"
        },
        {
            "input": "11 9\n1 1 4\n2 3 9\n1 1 5\n2 1 4\n1 5 5\n2 1 2\n1 1 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "9\n7\n3\n4\n"
        },
        {
            "input": "5 10\n1 4 11\n2 3 5\n1 1 4\n2 1 4\n1 5 5\n2 4 5\n2 2 3\n2 2 5\n2 3 2\n2 2 4\n",
            "output": "4\n7\n3\n4\n7\n0\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 3\n1 1 6\n2 1 4\n1 4 5\n2 4 5\n1 2 3\n2 1 3\n1 3 6\n2 1 5\n",
            "output": "1\n8\n3\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 4\n2 2 3\n1 4 5\n2 2 3\n2 1 3\n1 2 6\n1 5 5\n2 2 5\n",
            "output": "5\n4\n4\n5\n6\n"
        },
        {
            "input": "11 9\n1 1 4\n2 3 9\n1 1 2\n2 1 4\n1 5 5\n2 1 2\n1 1 3\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "9\n5\n3\n4\n"
        },
        {
            "input": "11 9\n1 1 4\n2 3 9\n1 1 2\n2 1 4\n1 5 5\n2 1 4\n1 1 6\n2 2 3\n1 3 7\n1 2 5\n",
            "output": "9\n5\n5\n4\n"
        },
        {
            "input": "11 9\n1 1 4\n2 5 9\n1 1 2\n2 1 4\n1 5 5\n2 1 4\n1 1 6\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n5\n5\n4\n"
        },
        {
            "input": "20 9\n1 1 4\n2 5 9\n1 1 2\n2 1 4\n1 5 5\n2 1 4\n2 1 6\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n5\n5\n7\n3\n"
        },
        {
            "input": "20 9\n1 1 3\n2 5 9\n1 1 2\n2 1 4\n1 5 5\n1 1 4\n2 1 6\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n5\n9\n4\n"
        },
        {
            "input": "20 9\n1 1 3\n2 5 9\n1 1 2\n2 1 4\n1 5 5\n1 1 6\n2 1 6\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "5\n5\n11\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n2 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n6\n6\n3\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n1 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "10\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 2 5\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n7\n6\n4\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 3\n1 5 5\n2 3 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n5\n6\n4\n6\n"
        },
        {
            "input": "5 10\n1 2 4\n2 3 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n6\n7\n"
        },
        {
            "input": "5 10\n2 3 4\n2 3 5\n1 1 5\n1 1 5\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "2\n3\n7\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 4 5\n1 1 4\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "3\n9\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n1 4 5\n2 2 5\n1 2 3\n2 1 3\n1 3 3\n2 2 3\n",
            "output": "4\n8\n7\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 6\n2 3 4\n1 1 4\n2 1 5\n1 4 4\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "3\n10\n5\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 3 5\n1 2 3\n2 1 3\n2 3 5\n2 2 5\n",
            "output": "4\n8\n5\n4\n5\n6\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 1 3\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n1 3 5\n2 2 3\n",
            "output": "5\n7\n3\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 25\n2 1 5\n1 4 5\n2 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 2\n",
            "output": "4\n10\n7\n3\n1\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n2 3 5\n2 2 3\n",
            "output": "5\n8\n4\n4\n5\n3\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 25\n2 1 5\n2 4 5\n1 2 5\n1 2 2\n2 1 3\n1 3 5\n2 2 5\n",
            "output": "4\n10\n5\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 1 3\n2 2 3\n1 3 5\n2 2 4\n",
            "output": "5\n8\n4\n4\n5\n"
        },
        {
            "input": "5 10\n1 2 11\n2 3 5\n1 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 2 3\n2 3 5\n2 2 4\n",
            "output": "6\n9\n4\n3\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 1\n1 4 5\n2 2 5\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n1\n7\n3\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 5\n1 5 5\n2 2 5\n1 2 3\n2 1 3\n1 4 5\n2 4 5\n",
            "output": "4\n10\n8\n4\n3\n"
        },
        {
            "input": "5 10\n1 3 8\n2 3 5\n1 1 4\n2 1 5\n2 4 5\n2 2 4\n2 2 3\n2 2 3\n1 5 5\n2 2 5\n",
            "output": "5\n10\n5\n7\n4\n4\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n2 1 5\n1 4 13\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "6\n9\n5\n4\n2\n"
        },
        {
            "input": "5 10\n1 3 11\n2 3 5\n2 1 5\n2 1 4\n1 5 5\n2 4 5\n1 2 3\n2 1 3\n2 3 5\n2 2 4\n",
            "output": "5\n7\n5\n3\n4\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n1 5 5\n1 1 5\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "10\n5\n4\n4\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 10\n2 1 5\n1 4 5\n1 2 5\n1 2 4\n2 1 3\n2 3 5\n2 2 5\n",
            "output": "4\n10\n4\n6\n7\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 4\n2 1 5\n1 4 13\n1 3 4\n1 2 3\n2 1 3\n1 5 5\n2 4 5\n",
            "output": "4\n9\n4\n3\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 2 5\n1 4 4\n2 2 4\n1 2 4\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n9\n4\n4\n6\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n1 1 5\n1 5 4\n2 2 4\n1 2 4\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "5\n9\n4\n7\n"
        },
        {
            "input": "6 10\n1 3 6\n2 3 5\n1 2 8\n2 1 5\n1 5 4\n2 2 4\n1 1 4\n2 1 3\n1 5 5\n2 3 5\n",
            "output": "5\n10\n6\n6\n8\n"
        },
        {
            "input": "5 10\n1 4 4\n2 3 5\n1 1 1\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n2 1 3\n1 5 5\n2 2 5\n",
            "output": "3\n5\n3\n4\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 1 5\n1 1 4\n2 1 5\n1 4 5\n2 2 4\n1 2 3\n1 2 3\n1 5 5\n2 2 5\n",
            "output": "6\n9\n5\n5\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 5\n2 1 4\n2 5 5\n2 2 2\n1 2 3\n2 2 3\n1 3 5\n2 2 5\n",
            "output": "4\n8\n2\n2\n3\n6\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 1\n2 2 5\n1 4 7\n2 2 4\n2 3 3\n1 1 3\n1 5 5\n2 2 5\n",
            "output": "4\n5\n3\n1\n6\n"
        },
        {
            "input": "5 10\n1 3 7\n2 3 5\n1 2 4\n2 1 5\n1 4 7\n2 2 4\n2 3 3\n1 1 5\n1 5 5\n2 2 5\n",
            "output": "5\n9\n4\n2\n8\n"
        },
        {
            "input": "5 10\n1 3 4\n2 3 5\n1 1 8\n2 1 4\n1 4 5\n2 1 5\n1 2 3\n2 1 4\n1 3 5\n2 2 5\n",
            "output": "4\n8\n8\n5\n7\n"
        },
        {
            "input": "5 9\n1 3 4\n2 3 5\n1 2 5\n2 1 4\n1 5 5\n2 1 5\n1 4 3\n2 2 3\n1 3 5\n2 2 3\n",
            "output": "4\n7\n8\n3\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst int MAXN = 200010;\nconst int INF = 0x7fffffff;\nclass SegTree {\n public:\n  SegTree() {}\n  void Build(int t, int l, int r) {\n    if (l == r) {\n      x[t] = sum[t] = ox[l];\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build(t + t, l, mid);\n    Build(t + t + 1, mid + 1, r);\n    sum[t] = sum[t + t] + sum[t + t + 1];\n  }\n  void PushDown(int t, int l, int r) {\n    if (l == r) return;\n    if (x[t] == 0) return;\n    x[t + t] += x[t];\n    x[t + t + 1] += x[t];\n    LL mid = (l + r) >> 1;\n    sum[t + t] += (mid - l + 1) * x[t];\n    sum[t + t + 1] += (r - mid) * x[t];\n    x[t] = 0;\n  }\n  void Insert(int t, int a, int l, int r, int p, int q) {\n    PushDown(t, l, r);\n    if (p <= l && r <= q) {\n      x[t] += a;\n      sum[t] += (r - l + 1LL) * a;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) Insert(t + t, a, l, mid, p, q);\n    if (mid + 1 <= q) Insert(t + t + 1, a, mid + 1, r, p, q);\n    sum[t] = sum[t + t] + sum[t + t + 1];\n  }\n  LL Query(int t, int l, int r, int p, int q) {\n    PushDown(t, l, r);\n    if (p <= l && r <= q) return sum[t];\n    int mid = (l + r) >> 1;\n    LL ans = 0;\n    if (p <= mid) ans += Query(t + t, l, mid, p, q);\n    if (mid + 1 <= q) ans += Query(t + t + 1, mid + 1, r, p, q);\n    return ans;\n  }\n  int ox[MAXN];\n  LL x[MAXN * 4], sum[MAXN * 4];\n} tree;\nstruct Node {\n  int mx, mx2, mn, mn2, cmx, cmn, tmx, tmn, tad;\n  LL sum;\n};\nclass SegmentTreeBeats {\n public:\n  void Merge(int t) {\n    const int lt = t << 1, rt = t << 1 | 1;\n    x[t].sum = x[lt].sum + x[rt].sum;\n    if (x[lt].mx == x[rt].mx) {\n      x[t].mx = x[lt].mx;\n      x[t].cmx = x[lt].cmx + x[rt].cmx;\n      x[t].mx2 = max(x[lt].mx2, x[rt].mx2);\n    } else if (x[lt].mx > x[rt].mx) {\n      x[t].mx = x[lt].mx;\n      x[t].cmx = x[lt].cmx;\n      x[t].mx2 = max(x[lt].mx2, x[rt].mx);\n    } else {\n      x[t].mx = x[rt].mx;\n      x[t].cmx = x[rt].cmx;\n      x[t].mx2 = max(x[lt].mx, x[rt].mx2);\n    }\n    if (x[lt].mn == x[rt].mn) {\n      x[t].mn = x[lt].mn;\n      x[t].cmn = x[lt].cmn + x[rt].cmn;\n      x[t].mn2 = min(x[lt].mn2, x[rt].mn2);\n    } else if (x[lt].mn < x[rt].mn) {\n      x[t].mn = x[lt].mn;\n      x[t].cmn = x[lt].cmn;\n      x[t].mn2 = min(x[lt].mn2, x[rt].mn);\n    } else {\n      x[t].mn = x[rt].mn;\n      x[t].cmn = x[rt].cmn;\n      x[t].mn2 = min(x[lt].mn, x[rt].mn2);\n    }\n  }\n  void PushAdd(int t, int l, int r, int v) {\n    x[t].sum += (r - l + 1LL) * v;\n    x[t].mx += v;\n    x[t].mn += v;\n    if (x[t].mx2 != -INF) x[t].mx2 += v;\n    if (x[t].mn2 != INF) x[t].mn2 += v;\n    if (x[t].tmx != -INF) x[t].tmx += v;\n    if (x[t].tmn != INF) x[t].tmn += v;\n    x[t].tad += v;\n  }\n  void PushMin(int t, int tg) {\n    if (x[t].mx <= tg) return;\n    x[t].sum += (tg * 1LL - x[t].mx) * x[t].cmx;\n    if (x[t].mn2 == x[t].mx) x[t].mn2 = tg;\n    if (x[t].mn == x[t].mx) x[t].mn = tg;\n    if (x[t].tmx > tg) x[t].tmx = tg;\n    x[t].mx = tg;\n    x[t].tmn = tg;\n  }\n  void PushMax(int t, int tg) {\n    if (x[t].mn > tg) return;\n    x[t].sum += (tg * 1LL - x[t].mn) * x[t].cmn;\n    if (x[t].mx2 == x[t].mn) x[t].mx2 = tg;\n    if (x[t].mx == x[t].mn) x[t].mx = tg;\n    if (x[t].tmn < tg) x[t].tmn = tg;\n    x[t].mn = tg;\n    x[t].tmx = tg;\n  }\n  void PushDown(int t, int l, int r) {\n    const int lt = t << 1, rt = t << 1 | 1;\n    const int mid = (l + r) >> 1;\n    if (x[t].tad) {\n      PushAdd(lt, l, mid, x[t].tad);\n      PushAdd(rt, mid + 1, r, x[t].tad);\n    }\n    if (x[t].tmx != -INF) {\n      PushMax(lt, x[t].tmx);\n      PushMax(rt, x[t].tmx);\n    }\n    if (x[t].tmn != INF) {\n      PushMin(lt, x[t].tmn);\n      PushMin(rt, x[t].tmn);\n    }\n    x[t].tad = 0;\n    x[t].tmx = -INF;\n    x[t].tmn = INF;\n  }\n  void Build(int t, int l, int r) {\n    x[t].tmn = INF;\n    x[t].tmx = -INF;\n    if (l == r) {\n      x[t].sum = x[t].mx = x[t].mn = ox[l];\n      x[t].mx2 = -INF;\n      x[t].mn2 = INF;\n      x[t].cmx = x[t].cmn = 1;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build(t << 1, l, mid);\n    Build(t << 1 | 1, mid + 1, r);\n    Merge(t);\n  }\n  void Add(int t, int l, int r, int L, int R, int v) {\n    if (R < l || r < L) return;\n    if (L <= l && r <= R) return PushAdd(t, l, r, v);\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    Add(t << 1, l, mid, L, R, v);\n    Add(t << 1 | 1, mid + 1, r, L, R, v);\n    Merge(t);\n  }\n  void SetMin(int t, int l, int r, int L, int R, int v) {\n    if (R < l || r < L || x[t].mx <= v) return;\n    if (L <= l && r <= R && x[t].mx2 < v) {\n      tree.Insert(1, -x[t].cmx, 1, n, v + 1, x[t].mx);\n      return PushMin(t, v);\n    }\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    SetMin(t << 1, l, mid, L, R, v);\n    SetMin(t << 1 | 1, mid + 1, r, L, R, v);\n    Merge(t);\n  }\n  void SetMax(int t, int l, int r, int L, int R, int v) {\n    if (R < l || r < L || x[t].mn >= v) return;\n    if (L <= l && r <= R && x[t].mn2 > v) return PushMax(t, v);\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    SetMax(t << 1, l, mid, L, R, v);\n    SetMax(t << 1 | 1, mid + 1, r, L, R, v);\n    Merge(t);\n  }\n  LL QuerySum(int t, int l, int r, int L, int R) {\n    if (R < l || r < L) return 0;\n    if (L <= l && r <= R) return x[t].sum;\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    return QuerySum(t << 1, l, mid, L, R) +\n           QuerySum(t << 1 | 1, mid + 1, r, L, R);\n  }\n  LL QueryMax(int t, int l, int r, int L, int R) {\n    if (R < l || r < L) return -INF;\n    if (L <= l && r <= R) return x[t].mx;\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    return max(QueryMax(t << 1, l, mid, L, R),\n               QueryMax(t << 1 | 1, mid + 1, r, L, R));\n  }\n  LL QueryMin(int t, int l, int r, int L, int R) {\n    if (R < l || r < L) return INF;\n    if (L <= l && r <= R) return x[t].mn;\n    int mid = (l + r) >> 1;\n    PushDown(t, l, r);\n    return min(QueryMin(t << 1, l, mid, L, R),\n               QueryMin(t << 1 | 1, mid + 1, r, L, R));\n  }\n  int n;\n  int ox[MAXN];\n  Node x[MAXN * 4];\n} treeb;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  treeb.n = n;\n  for (int i = 1; i <= n; ++i) {\n    tree.ox[i] = 1;\n    treeb.ox[i] = i;\n  }\n  tree.Build(1, 1, n);\n  treeb.Build(1, 1, n);\n  while (q--) {\n    int t, a, b;\n    cin >> t >> a >> b;\n    if (t == 1) {\n      int r = treeb.QueryMax(1, 1, n, a, a);\n      if (r > b) {\n        tree.Insert(1, -1, 1, n, b + 1, r);\n      } else if (r < b) {\n        tree.Insert(1, 1, 1, n, r + 1, b);\n      }\n      if (r != b) {\n        treeb.Add(1, 1, n, a, a, b - r);\n      }\n      if (a == 1) continue;\n      treeb.SetMin(1, 1, n, 1, a - 1, a - 1);\n    } else {\n      cout << tree.Query(1, 1, n, a, b) << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, Q;\nclass ZYK {\n  class BIT {\n    long long b[200020];\n    inline int lowbit(int x) { return x & (-x); }\n\n   public:\n    inline void Add(int x, long long d) {\n      while (x <= n) b[x] += d, x += lowbit(x);\n    }\n    inline long long Ask(int x) {\n      long long ans = 0;\n      while (x) ans += b[x], x -= lowbit(x);\n      return ans;\n    }\n  } B1, B2;\n\n public:\n  void Change(int l, int r, int d) {\n    B1.Add(l, d), B1.Add(r + 1, -d);\n    B2.Add(l, 1LL * l * d), B2.Add(r + 1, -1LL * (r + 1) * d);\n  }\n  long long Query(int l, int r) {\n    return (1LL * (r + 1) * B1.Ask(r) - B2.Ask(r)) -\n           (1LL * l * B1.Ask(l - 1) - B2.Ask(l - 1));\n  }\n} B;\nclass Seg {\n  struct node {\n    int mx, se, add, cnt;\n    inline void Add(int d) { add += d, mx += d; }\n    friend node operator+(const node &a, const node &b) {\n      node c;\n      c.mx = max(a.mx, b.mx);\n      c.cnt = 0;\n      if (c.mx == a.mx) c.cnt += a.cnt;\n      if (c.mx == b.mx) c.cnt += b.cnt;\n      c.se = max(c.mx == a.mx ? a.se : a.mx, c.mx == b.mx ? b.se : b.mx);\n      return c;\n    }\n  } t[200020 << 2];\n  inline void pushdown(int u) {\n    if (t[u].add) {\n      if (t[u << 1].mx + t[u].add == t[u].mx) t[u << 1].Add(t[u].add);\n      if (t[u << 1 | 1].mx + t[u].add == t[u].mx) t[u << 1 | 1].Add(t[u].add);\n      t[u].add = 0;\n    }\n  }\n\n public:\n  void build(int u, int L, int R) {\n    if (L == R) {\n      t[u].mx = L;\n      t[u].se = 0;\n      B.Change(L, L, 1);\n      t[u].cnt = 1;\n      return;\n    }\n    int mid = (L + R) >> 1;\n    build(u << 1, L, mid), build(u << 1 | 1, mid + 1, R);\n  }\n  void Min(int u, int L, int R, int l, int r, int d) {\n    if (d >= t[u].mx) return;\n    if (L >= l && R <= r && d > t[u].se) {\n      B.Change(d + 1, t[u].mx, -t[u].cnt);\n      t[u].Add(d - t[u].mx);\n      return;\n    }\n    pushdown(u);\n    int mid = (L + R) >> 1;\n    if (l <= mid) Min(u << 1, L, mid, l, r, d);\n    if (r > mid) Min(u << 1 | 1, mid + 1, R, l, r, d);\n    t[u] = t[u << 1] + t[u << 1 | 1];\n  }\n  int Find(int u, int L, int R, int p) {\n    if (L == R) return t[u].mx;\n    pushdown(u);\n    int mid = (L + R) >> 1;\n    return p <= mid ? Find(u << 1, L, mid, p) : Find(u << 1 | 1, mid + 1, R, p);\n  }\n  void Change(int u, int L, int R, int p, int d) {\n    if (L == R) {\n      t[u].mx = d;\n      return;\n    }\n    int mid = (L + R) >> 1;\n    pushdown(u);\n    p <= mid ? Change(u << 1, L, mid, p, d)\n             : Change(u << 1 | 1, mid + 1, R, p, d);\n    t[u] = t[u << 1] + t[u << 1 | 1];\n  }\n} T;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> Q;\n  T.build(1, 1, n);\n  while (Q--) {\n    int opt, x, y;\n    cin >> opt >> x >> y;\n    if (opt == 1) {\n      if (x > 1) T.Min(1, 1, n, 1, x - 1, x - 1);\n      int z = T.Find(1, 1, n, x);\n      B.Change(x, z, -1);\n      T.Change(1, 1, n, x, y);\n      B.Change(x, y, 1);\n    } else {\n      cout << B.Query(x, y) << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::max;\nusing std::min;\nconst int N = 200005;\nint n, q;\nint sum[N];\nlong long sum1[N];\ninline void add(int p, int v) {\n  while (p <= n) sum[p] += v, p += p & (-p);\n}\ninline int ask(int p) {\n  int ret = 0;\n  while (p) ret += sum[p], p -= p & (-p);\n  return ret;\n}\ninline void add1(int p, int v) {\n  while (p <= n) sum1[p] += v, p += p & (-p);\n}\ninline long long ask1(int p) {\n  long long ret = 0;\n  while (p) ret += sum1[p], p -= p & (-p);\n  return ret;\n}\ninline void radd(int l, int r, int v) {\n  add(l, v), add1(l, 1ll * l * v);\n  add(r + 1, -v), add1(r + 1, -1ll * (r + 1) * v);\n}\ninline long long rask(int p) { return 1ll * (p + 1) * ask(p) - ask1(p); }\nnamespace SGT {\nint mx[N << 2], mx1[N << 2], cnt[N << 2], tag[N << 2];\ninline void pushdown(int id) {\n  mx[(id << 1)] = min(mx[(id << 1)], tag[id]);\n  tag[(id << 1)] = min(tag[(id << 1)], tag[id]);\n  mx[(id << 1 | 1)] = min(mx[(id << 1 | 1)], tag[id]);\n  tag[(id << 1 | 1)] = min(tag[(id << 1 | 1)], tag[id]);\n  tag[id] = 0x3f3f3f3f;\n}\ninline void upt(int id) {\n  mx1[id] = 0;\n  mx[id] = max(mx[(id << 1)], mx[(id << 1 | 1)]);\n  cnt[id] = (mx[(id << 1)] == mx[id] ? cnt[(id << 1)] : 0) +\n            (mx[(id << 1 | 1)] == mx[id] ? cnt[(id << 1 | 1)] : 0);\n  mx1[id] = max(\n      (mx[(id << 1)] == mx[id] ? mx1[(id << 1)] : mx[(id << 1)]),\n      (mx[(id << 1 | 1)] == mx[id] ? mx1[(id << 1 | 1)] : mx[(id << 1 | 1)]));\n}\nvoid build(int id, int l, int r) {\n  tag[id] = 0x3f3f3f3f;\n  if (l == r) {\n    mx[id] = l;\n    cnt[id] = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((id << 1), l, mid), build((id << 1 | 1), mid + 1, r);\n  upt(id);\n}\nvoid addp(int id, int l, int r, int p, int v) {\n  if (l == r) {\n    radd(l + 1, mx[id], -1);\n    mx[id] = v;\n    radd(l + 1, v, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(id);\n  if (p <= mid)\n    addp((id << 1), l, mid, p, v);\n  else\n    addp((id << 1 | 1), mid + 1, r, p, v);\n  upt(id);\n}\nvoid add(int id, int l, int r, int p) {\n  if (mx[id] <= p) return;\n  if (r <= p) {\n    if (mx1[id] < p) {\n      radd(p + 1, mx[id], -cnt[id]);\n      tag[id] = p;\n      mx[id] = p;\n      return;\n    }\n  }\n  pushdown(id);\n  int mid = (l + r) >> 1;\n  add((id << 1), l, mid, p);\n  if (p > mid) add((id << 1 | 1), mid + 1, r, p);\n  upt(id);\n}\n}  // namespace SGT\nusing namespace SGT;\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  build(1, 1, n);\n  for (int i = 1, tp, x, y; i <= q; ++i) {\n    scanf(\"%d%d%d\", &tp, &x, &y);\n    if (tp == 1) {\n      if (x - 1) add(1, 1, n, x - 1);\n      addp(1, 1, n, x, y);\n    } else\n      printf(\"%lld\\n\", rask(y) - rask(x - 1) + y - x + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2e5 + 14;\nint n, q;\nstruct SegmentLazy {\n  int lazy[MAX_N << 2];\n  long long s[MAX_N << 2];\n  void build(int id = 1, int l = 0, int r = n) {\n    if (r - l < 2) {\n      s[id] = 1;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(id << 1, l, mid);\n    build(id << 1 | 1, mid, r);\n    s[id] = s[id << 1] + s[id << 1 | 1];\n  }\n  void up(int id, int l, int r, int x) {\n    lazy[id] += x;\n    s[id] += long long(r - l) * x;\n  }\n  void shift(int id, int l, int r) {\n    int mid = (l + r) >> 1;\n    up(id << 1, l, mid, lazy[id]);\n    up(id << 1 | 1, mid, r, lazy[id]);\n    lazy[id] = 0;\n  }\n  void add(int st, int en, int v, int id = 1, int l = 0, int r = n) {\n    if (en <= l || r <= st) return;\n    if (st <= l && r <= en) {\n      up(id, l, r, v);\n      return;\n    }\n    shift(id, l, r);\n    int mid = (l + r) >> 1;\n    add(st, en, v, id << 1, l, mid);\n    add(st, en, v, id << 1 | 1, mid, r);\n    s[id] = s[id << 1] + s[id << 1 | 1];\n  }\n  long long sum(int st, int en, int id = 1, int l = 0, int r = n) {\n    if (en <= l || r <= st) return 0;\n    if (st <= l && r <= en) return s[id];\n    shift(id, l, r);\n    int mid = (l + r) >> 1;\n    return sum(st, en, id << 1, l, mid) + sum(st, en, id << 1 | 1, mid, r);\n  }\n} segment_lazy;\nstruct SegmentBeats {\n  struct Node {\n    int m, c, s;\n    Node operator+(const Node &o) const {\n      if (m > o.m) return {m, c, max(s, o.m)};\n      if (m < o.m) return {o.m, o.c, max(o.s, m)};\n      return {m, c + o.c, max(s, o.s)};\n    }\n  } seg[MAX_N * 4];\n  int lazy[MAX_N * 4];\n  SegmentBeats() { memset(lazy, -1, sizeof lazy); }\n  void build(int l = 0, int r = n, int id = 1) {\n    if (l + 1 == r) {\n      seg[id] = {r, 1, -1};\n      return;\n    }\n    int mid = (l + r) / 2;\n    build(l, mid, id * 2);\n    build(mid, r, id * 2 + 1);\n    seg[id] = seg[id * 2] + seg[id * 2 + 1];\n  }\n  void up(int id, int x) {\n    if (seg[id].m <= x) return;\n    lazy[id] = seg[id].m = x;\n  }\n  void shift(int id) {\n    if (lazy[id] == -1) return;\n    up(id * 2, lazy[id]);\n    up(id * 2 + 1, lazy[id]);\n    lazy[id] = -1;\n  }\n  int get(int p, int l = 0, int r = n, int id = 1) {\n    if (l + 1 == r) return seg[id].m;\n    shift(id);\n    int mid = (l + r) / 2;\n    return (p < mid ? get(p, l, mid, id * 2) : get(p, mid, r, id * 2 + 1));\n  }\n  void modify(int p, int x, int l = 0, int r = n, int id = 1) {\n    if (l + 1 == r) {\n      seg[id].m = x;\n      return;\n    }\n    shift(id);\n    int mid = (l + r) / 2;\n    if (p < mid)\n      modify(p, x, l, mid, id * 2);\n    else\n      modify(p, x, mid, r, id * 2 + 1);\n    seg[id] = seg[id * 2] + seg[id * 2 + 1];\n  }\n  void upd(int s, int e, int x, int l = 0, int r = n, int id = 1) {\n    if (e <= l || r <= s || seg[id].m <= x) return;\n    if (s <= l && r <= e && seg[id].s < x) {\n      segment_lazy.add(x, seg[id].m, -seg[id].c);\n      up(id, x);\n      return;\n    }\n    shift(id);\n    int mid = (l + r) / 2;\n    upd(s, e, x, l, mid, id * 2);\n    upd(s, e, x, mid, r, id * 2 + 1);\n    seg[id] = seg[id * 2] + seg[id * 2 + 1];\n  }\n} segment_beats;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> q;\n  segment_lazy.build();\n  segment_beats.build();\n  while (q--) {\n    int t;\n    cin >> t;\n    if (t == 1) {\n      int c, g;\n      cin >> c >> g;\n      --c;\n      int pw = segment_beats.get(c);\n      segment_lazy.add(c, pw, -1);\n      segment_lazy.add(c, g, +1);\n      segment_beats.upd(0, c, c);\n      segment_beats.modify(c, g);\n    } else {\n      int l, r;\n      cin >> l >> r;\n      cout << segment_lazy.sum(--l, r) << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\ntemplate <typename T>\ninline void read(T &WOW) {\n  T x = 0, flag = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') flag = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  WOW = flag * x;\n}\nint n, q;\nstruct BIT {\n  long long t1[MAXN], t2[MAXN];\n  inline void add(int x, int v) {\n    long long tmp = x * v;\n    for (int i = x; i <= n; i += (i & (-i))) {\n      t1[i] += v;\n      t2[i] += tmp;\n    }\n  }\n  inline long long sum(int x) {\n    long long r1 = 0, r2 = 0;\n    for (int i = x; i; i -= (i & (-i))) {\n      r1 += t1[i];\n      r2 += t2[i];\n    }\n    return r1 * (x + 1) - r2;\n  }\n  inline void upd(int l, int r, int v) {\n    add(l, v);\n    if (r < n) add(r + 1, -v);\n  }\n  inline long long qry(int l, int r) { return sum(r) - sum(l - 1); }\n} seg1;\nstruct SegmentTreeBeats {\n  int mx[MAXN << 2], mx2[MAXN << 2], cnt[MAXN << 2], tag[MAXN << 2];\n  inline void puttag(int rt, int tg) { mx[rt] = tag[rt] = tg; }\n  inline void pushdown(int rt) {\n    if (tag[rt]) {\n      int tmp = max(mx[(rt << 1)], mx[(rt << 1) | 1]);\n      if (mx[(rt << 1)] == tmp) {\n        puttag((rt << 1), tag[rt]);\n      }\n      if (mx[(rt << 1) | 1] == tmp) {\n        puttag((rt << 1) | 1, tag[rt]);\n      }\n      tag[rt] = 0;\n    }\n  }\n  inline void pushup(int rt) {\n    if (mx[(rt << 1)] == mx[(rt << 1) | 1]) {\n      mx[rt] = mx[(rt << 1)];\n      mx2[rt] = max(mx2[(rt << 1)], mx2[(rt << 1) | 1]);\n      cnt[rt] = cnt[(rt << 1)] + cnt[(rt << 1) | 1];\n    } else if (mx[(rt << 1)] > mx[(rt << 1) | 1]) {\n      mx[rt] = mx[(rt << 1)];\n      mx2[rt] = max(mx2[(rt << 1)], mx[(rt << 1) | 1]);\n      cnt[rt] = cnt[(rt << 1)];\n    } else {\n      mx[rt] = mx[(rt << 1) | 1];\n      mx2[rt] = max(mx[(rt << 1)], mx2[(rt << 1) | 1]);\n      cnt[rt] = cnt[(rt << 1) | 1];\n    }\n  }\n  void Build(int rt, int b, int e) {\n    if (b == e) {\n      mx[rt] = b;\n      mx2[rt] = 0;\n      cnt[rt] = 1;\n      return;\n    }\n    int mid = (b + e) >> 1;\n    Build((rt << 1), b, mid);\n    Build((rt << 1) | 1, mid + 1, e);\n    pushup(rt);\n  }\n  void Insert(int rt, int b, int e, int p, int v) {\n    if (b == e) {\n      seg1.upd(b, mx[rt], -1);\n      mx[rt] = v;\n      seg1.upd(b, mx[rt], 1);\n      return;\n    }\n    int mid = (b + e) >> 1;\n    pushdown(rt);\n    if (p <= mid)\n      Insert((rt << 1), b, mid, p, v);\n    else\n      Insert((rt << 1) | 1, mid + 1, e, p, v);\n    pushup(rt);\n  }\n  void UpdateMin(int rt, int b, int e, int l, int r, int v) {\n    if (mx[rt] <= v) return;\n    if (l <= b && e <= r && v > mx2[rt]) {\n      seg1.upd(v + 1, mx[rt], -cnt[rt]);\n      puttag(rt, v);\n      return;\n    }\n    int mid = (b + e) >> 1;\n    pushdown(rt);\n    if (l <= mid) UpdateMin((rt << 1), b, mid, l, r, v);\n    if (r > mid) UpdateMin((rt << 1) | 1, mid + 1, e, l, r, v);\n    pushup(rt);\n  }\n} seg2;\nvoid solve() {\n  read(n);\n  read(q);\n  seg1.upd(1, n, 1);\n  seg2.Build(1, 1, n);\n  int type, l, r;\n  while (q--) {\n    read(type);\n    read(l);\n    read(r);\n    if (type == 1) {\n      seg2.Insert(1, 1, n, l, r);\n      if (l > 1) seg2.UpdateMin(1, 1, n, 1, l - 1, l - 1);\n    } else {\n      printf(\"%lld\\n\", seg1.qry(l, r));\n    }\n  }\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long readint() {\n  long long x = 0;\n  bool f = 0;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') {\n    f = 1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return f ? -x : x;\n}\nint n, q;\nstruct node1 {\n  int l, r;\n  node1* ch[2];\n  long long sum, add = 0;\n  void pushup() { sum = ch[0]->sum + ch[1]->sum; }\n  node1(int l, int r) : l(l), r(r), sum(r - l + 1) {\n    if (l == r) return;\n    int mid = l + (r - l) / 2;\n    ch[0] = new node1(l, mid);\n    ch[1] = new node1(mid + 1, r);\n  }\n  void pushtag(long long k) {\n    sum += k * (r - l + 1);\n    add += k;\n  }\n  void pushdown() {\n    ch[0]->pushtag(add);\n    ch[1]->pushtag(add);\n    add = 0;\n  }\n  void modify(int ql, int qr, long long k) {\n    if (ql <= l && qr >= r) {\n      pushtag(k);\n      return;\n    }\n    pushdown();\n    if (ql <= ch[0]->r) ch[0]->modify(ql, qr, k);\n    if (qr >= ch[1]->l) ch[1]->modify(ql, qr, k);\n    pushup();\n  }\n  long long query(int ql, int qr) {\n    if (ql <= l && qr >= r) return sum;\n    pushdown();\n    long long ans = 0;\n    if (ql <= ch[0]->r) ans += ch[0]->query(ql, qr);\n    if (qr >= ch[1]->l) ans += ch[1]->query(ql, qr);\n    return ans;\n  }\n} * rt1;\nstruct node2 {\n  int l, r;\n  node2* ch[2];\n  int mx, mx2, cnt = 1, add = 0;\n  void pushup() {\n    if (ch[0]->mx > ch[1]->mx) {\n      mx = ch[0]->mx;\n      mx2 = max(ch[0]->mx2, ch[1]->mx);\n      cnt = ch[0]->cnt;\n    } else if (ch[0]->mx < ch[1]->mx) {\n      mx = ch[1]->mx;\n      mx2 = max(ch[1]->mx2, ch[0]->mx);\n      cnt = ch[1]->cnt;\n    } else {\n      mx = ch[0]->mx;\n      mx2 = max(ch[0]->mx2, ch[1]->mx2);\n      cnt = ch[0]->cnt + ch[1]->cnt;\n    }\n  }\n  node2(int l, int r) : l(l), r(r), mx(r), mx2(l == r ? 0 : r - 1) {\n    if (l == r) return;\n    int mid = l + (r - l) / 2;\n    ch[0] = new node2(l, mid);\n    ch[1] = new node2(mid + 1, r);\n  }\n  void pushtag(int k) {\n    mx += k;\n    add += k;\n  }\n  void pushdown() {\n    if (ch[0]->mx > ch[1]->mx)\n      ch[0]->pushtag(add);\n    else if (ch[0]->mx < ch[1]->mx)\n      ch[1]->pushtag(add);\n    else {\n      ch[0]->pushtag(add);\n      ch[1]->pushtag(add);\n    }\n    add = 0;\n  }\n  void modify1(int x, int k) {\n    if (l == r) {\n      rt1->modify(x, mx, -1);\n      rt1->modify(x, mx = k, 1);\n      return;\n    }\n    pushdown();\n    if (x <= ch[0]->r)\n      ch[0]->modify1(x, k);\n    else\n      ch[1]->modify1(x, k);\n    pushup();\n  }\n  void modify2(int ql, int qr, int k) {\n    if (k >= mx) return;\n    if (ql <= l && qr >= r && k >= mx2) {\n      rt1->modify(k + 1, mx, -cnt);\n      pushtag(k - mx);\n      return;\n    }\n    pushdown();\n    if (ql <= ch[0]->r) ch[0]->modify2(ql, qr, k);\n    if (qr >= ch[1]->l) ch[1]->modify2(ql, qr, k);\n    pushup();\n  }\n} * rt2;\nint main() {\n  n = readint();\n  q = readint();\n  rt1 = new node1(1, n);\n  rt2 = new node2(1, n);\n  while (q--) {\n    int p = readint();\n    if (p == 1) {\n      int c, g;\n      c = readint();\n      g = readint();\n      rt2->modify1(c, g);\n      if (c > 1) rt2->modify2(1, c - 1, c - 1);\n    } else {\n      int l, r;\n      l = readint();\n      r = readint();\n      printf(\"%lld\\n\", rt1->query(l, r));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T>\nvoid ckmn(T& a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmx(T& a, T b) {\n  a = max(a, b);\n}\nvoid rd(int& x) { scanf(\"%i\", &x); }\nvoid rd(long long& x) { scanf(\"%lld\", &x); }\nvoid rd(char* x) { scanf(\"%s\", x); }\nvoid rd(double& x) { scanf(\"%lf\", &x); }\nvoid rd(string& x) { scanf(\"%s\", &x); }\ntemplate <typename T1, typename T2>\nvoid rd(pair<T1, T2>& x) {\n  rd(x.first);\n  rd(x.second);\n}\ntemplate <typename T>\nvoid rd(vector<T>& x) {\n  for (T& i : x) rd(i);\n}\ntemplate <typename T, typename... A>\nvoid rd(T& x, A&... args) {\n  rd(x);\n  rd(args...);\n}\ntemplate <typename T>\nvoid rd() {\n  T x;\n  rd(x);\n  return x;\n}\nint ri() {\n  int x;\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvector<T> rv(int n) {\n  vector<T> x(n);\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvoid ra(T a[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]);\n}\ntemplate <typename T1, typename T2>\nvoid ra(T1 a[], T2 b[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]);\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid ra(T1 a[], T2 b[], T3 c[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]), rd(c[st + i]);\n}\nvoid re(vector<int> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    rd(u, v);\n    E[u].push_back(v);\n    if (!dir) E[v].push_back(u);\n  }\n}\ntemplate <typename T>\nvoid re(vector<pair<int, T>> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    T w;\n    rd(u, v, w);\n    E[u].push_back({v, w});\n    if (!dir) E[v].push_back({u, w});\n  }\n}\nconst int N = 200050;\nconst int M = 2 * N;\nnamespace SegLazy {\nint ls[M], rs[M], tsz, root;\nlong long sum[M], lzy[M];\nvoid Build(int& c, int ss, int se) {\n  c = ++tsz;\n  sum[c] = se - ss + 1;\n  lzy[c] = 0;\n  if (ss == se) return;\n  int mid = ss + se >> 1;\n  Build(ls[c], ss, mid);\n  Build(rs[c], mid + 1, se);\n}\nvoid upd(int c, int ss, int se, long long x) {\n  sum[c] += x * (se - ss + 1);\n  lzy[c] += x;\n}\nvoid push(int c, int ss, int se) {\n  if (!lzy[c]) return;\n  int mid = ss + se >> 1;\n  upd(ls[c], ss, mid, lzy[c]);\n  upd(rs[c], mid + 1, se, lzy[c]);\n  lzy[c] = 0;\n}\nvoid Add(int c, int ss, int se, int qs, int qe, long long x) {\n  if (qs > qe || qs > se || ss > qe) return;\n  if (qs <= ss && qe >= se) {\n    upd(c, ss, se, x);\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c, ss, se);\n  Add(ls[c], ss, mid, qs, qe, x);\n  Add(rs[c], mid + 1, se, qs, qe, x);\n  sum[c] = sum[ls[c]] + sum[rs[c]];\n}\nlong long Get(int c, int ss, int se, int qs, int qe) {\n  if (qs > qe || qs > se || ss > qe) return 0;\n  if (qs <= ss && qe >= se) return sum[c];\n  int mid = ss + se >> 1;\n  push(c, ss, se);\n  return Get(ls[c], ss, mid, qs, qe) + Get(rs[c], mid + 1, se, qs, qe);\n}\n}  // namespace SegLazy\nint n, q;\nint ls[M], rs[M], tsz, root, mx[M], smx[M], cnt[M], lzy[M];\nvoid Build(int& c, int ss, int se) {\n  c = ++tsz;\n  mx[c] = se;\n  smx[c] = se - 1;\n  cnt[c] = 1;\n  lzy[c] = n + 1;\n  if (ss == se) {\n    smx[c] = 0;\n    return;\n  }\n  int mid = ss + se >> 1;\n  Build(ls[c], ss, mid);\n  Build(rs[c], mid + 1, se);\n}\nvoid upd(int c, int x) {\n  if (mx[c] > x) {\n    mx[c] = x;\n    lzy[c] = x;\n  }\n}\nvoid push(int c) {\n  if (lzy[c] != n + 1) {\n    upd(ls[c], lzy[c]);\n    upd(rs[c], lzy[c]);\n    lzy[c] = n + 1;\n  }\n}\nvoid pull(int c) {\n  if (mx[ls[c]] > mx[rs[c]]) {\n    mx[c] = mx[ls[c]];\n    smx[c] = max(smx[ls[c]], mx[rs[c]]);\n    cnt[c] = cnt[ls[c]];\n  } else if (mx[rs[c]] > mx[ls[c]]) {\n    mx[c] = mx[rs[c]];\n    smx[c] = max(mx[ls[c]], smx[rs[c]]);\n    cnt[c] = cnt[rs[c]];\n  } else {\n    mx[c] = mx[ls[c]];\n    smx[c] = max(smx[ls[c]], smx[rs[c]]);\n    cnt[c] = cnt[ls[c]] + cnt[rs[c]];\n  }\n}\nvoid Set(int c, int ss, int se, int qi, int x) {\n  if (ss == se) {\n    SegLazy::Add(SegLazy::root, 1, n, qi, mx[c], -1);\n    SegLazy::Add(SegLazy::root, 1, n, qi, x, 1);\n    mx[c] = x;\n    smx[c] = 0;\n    cnt[c] = 1;\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c);\n  if (qi <= mid)\n    Set(ls[c], ss, mid, qi, x);\n  else\n    Set(rs[c], mid + 1, se, qi, x);\n  pull(c);\n}\nvoid Min(int c, int ss, int se, int qs, int qe, int x) {\n  if (qs > qe || qs > se || ss > qe || mx[c] <= x) return;\n  if (qs <= ss & qe >= se && smx[c] < x) {\n    SegLazy::Add(SegLazy::root, 1, n, x + 1, mx[c], -cnt[c]);\n    upd(c, x);\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c);\n  Min(ls[c], ss, mid, qs, qe, x);\n  Min(rs[c], mid + 1, se, qs, qe, x);\n  pull(c);\n}\nint main() {\n  scanf(\"%i %i\", &n, &q);\n  SegLazy::Build(SegLazy::root, 1, n);\n  Build(root, 1, n);\n  while (q--) {\n    int t, a, b;\n    scanf(\"%i %i %i\", &t, &a, &b);\n    if (t == 1) {\n      Set(root, 1, n, a, b);\n      Min(root, 1, n, 1, a - 1, a - 1);\n    } else {\n      printf(\"%lld\\n\", SegLazy::Get(SegLazy::root, 1, n, a, b));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid sc(int &x) { scanf(\"%d\", &x); }\nvoid sc(int &x, int &y) { scanf(\"%d%d\", &x, &y); }\nvoid sc(int &x, int &y, int &z) { scanf(\"%d%d%d\", &x, &y, &z); }\nvoid sc(long long &x) { scanf(\"%lld\", &x); }\nvoid sc(long long &x, long long &y) { scanf(\"%lld%lld\", &x, &y); }\nvoid sc(long long &x, long long &y, long long &z) {\n  scanf(\"%lld%lld%lld\", &x, &y, &z);\n}\nvoid sc(char *x) { scanf(\"%s\", x); }\nvoid sc(char *x, char *y) { scanf(\"%s%s\", x, y); }\nvoid sc(char *x, char *y, char *z) { scanf(\"%s%s%s\", x, y, z); }\nvoid out(int x) { printf(\"%d\\n\", x); }\nvoid out(long long x) { printf(\"%lld\\n\", x); }\nvoid out(int x, int y) { printf(\"%d %d\\n\", x, y); }\nvoid out(long long x, long long y) { printf(\"%lld %lld\\n\", x, y); }\nvoid out(int x, int y, int z) { printf(\"%d %d %d\\n\", x, y, z); }\nvoid out(long long x, long long y, long long z) {\n  printf(\"%lld %lld %lld\\n\", x, y, z);\n}\nvoid ast(long long x, long long l, long long r) { assert(x >= l && x <= r); }\nusing namespace std;\nconst int N = 3e5 + 5, mod = 998244353;\nint n, q;\nlong long b[N << 2], lz[N << 2];\nvoid up(int l, int r, int k) {\n  b[k] += 1ll * lz[k] * (r - l + 1);\n  if (l != r) lz[k << 1] += lz[k], lz[k << 1 | 1] += lz[k];\n  lz[k] = 0;\n}\nvoid ins(int l, int r, int k, int x, int y, int v) {\n  if (lz[k]) up(l, r, k);\n  if (r < x || l > y) return;\n  if (l >= x && r <= y) {\n    lz[k] += v;\n    up(l, r, k);\n    return;\n  }\n  int m = (l + r) >> 1;\n  ins(l, m, k << 1, x, y, v);\n  ins(m + 1, r, k << 1 | 1, x, y, v);\n  b[k] = b[k << 1] + b[k << 1 | 1];\n}\nlong long query(int l, int r, int k, int x, int y) {\n  if (lz[k]) up(l, r, k);\n  if (r < x || l > y) return 0;\n  if (l >= x && r <= y) return b[k];\n  int m = (l + r) >> 1;\n  return query(l, m, k << 1, x, y) + query(m + 1, r, k << 1 | 1, x, y);\n}\nstruct node {\n  int mx, se, mxnum, lz;\n  node operator+(const node &o) const {\n    node ans;\n    ans.se = max(se, o.se);\n    if (mx == o.mx)\n      ans.mx = mx, ans.mxnum = mxnum + o.mxnum;\n    else if (mx > o.mx)\n      ans.mx = mx, ans.mxnum = mxnum, ans.se = max(ans.se, o.mx);\n    else\n      ans.mx = o.mx, ans.mxnum = o.mxnum, ans.se = max(ans.se, mx);\n    ans.lz = mod;\n    return ans;\n  }\n} t[N << 2];\nbool debug = false;\nvoid build(int l, int r, int k) {\n  if (l == r) {\n    t[k].mx = l;\n    t[k].mxnum = 1;\n    t[k].se = -1;\n    t[k].lz = mod;\n    return;\n  }\n  int m = (l + r) >> 1;\n  build(l, m, k << 1);\n  build(m + 1, r, k << 1 | 1);\n  t[k] = t[k << 1] + t[k << 1 | 1];\n}\nvoid update(int l, int r, int k) {\n  if (t[k].lz >= t[k].mx) {\n    t[k].lz = mod;\n    return;\n  }\n  t[k].mx = t[k].lz;\n  if (l != r)\n    t[k << 1].lz = min(t[k << 1].lz, t[k].lz),\n           t[k << 1 | 1].lz = min(t[k << 1 | 1].lz, t[k].lz);\n  t[k].lz = mod;\n}\nvoid setv(int l, int r, int k, int x, int v) {\n  if (t[k].lz != mod) update(l, r, k);\n  if (l == r) {\n    if (v > t[k].mx) {\n      if (debug) cout << \"ins: \" << t[k].mx + 1 << ' ' << v << ' ' << 1 << '\\n';\n      ins(1, n, 1, t[k].mx + 1, v, 1);\n    } else if (v < t[k].mx) {\n      if (debug)\n        cout << \"ins: \" << v + 1 << ' ' << t[k].mx << ' ' << -1 << '\\n';\n      ins(1, n, 1, v + 1, t[k].mx, -1);\n    }\n    t[k].mx = v;\n    return;\n  }\n  int m = (l + r) >> 1;\n  if (x <= m)\n    setv(l, m, k << 1, x, v), update(m + 1, r, k << 1 | 1);\n  else\n    setv(m + 1, r, k << 1 | 1, x, v), update(l, m, k << 1);\n  t[k] = t[k << 1] + t[k << 1 | 1];\n}\nvoid setmn(int l, int r, int k, int x, int y, int v) {\n  if (t[k].lz != mod) update(l, r, k);\n  if (r < x || l > y) return;\n  if (l >= x && r <= y && v > t[k].se) {\n    if (debug) cout << \"ok \" << l << ' ' << r << ' ' << t[k].mx << '\\n';\n    if (v < t[k].mx) {\n      if (debug)\n        cout << \"ins: \" << v + 1 << ' ' << t[k].mx << ' ' << -t[k].mxnum\n             << '\\n';\n      ins(1, n, 1, v + 1, t[k].mx, -t[k].mxnum);\n    }\n    t[k].lz = v;\n    update(l, r, k);\n    return;\n  }\n  int m = (l + r) >> 1;\n  setmn(l, m, k << 1, x, y, v);\n  setmn(m + 1, r, k << 1 | 1, x, y, v);\n  t[k] = t[k << 1] + t[k << 1 | 1];\n}\nvoid sol(int cas) {\n  sc(n, q);\n  build(1, n, 1);\n  while (q--) {\n    int op, x, y;\n    sc(op, x, y);\n    if (op == 2)\n      printf(\"%lld\\n\", query(1, n, 1, x, y) + y - x + 1);\n    else {\n      setv(1, n, 1, x, y);\n      if (x > 1) setmn(1, n, 1, 1, x - 1, x - 1);\n    }\n  }\n}\nint main() {\n  srand(time(0));\n  int t = 1, cas = 0;\n  while (t--) {\n    sol(++cas);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2, 3, \"Ofast\")\n#pragma GCC target(\"avx\", \"avx2\")\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid ckmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid ckmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N = 200005;\nconst int inf = 1e9;\nint n, q;\nstruct SMT1 {\n  long long sum[N << 2], tag[N << 2];\n  void pushup(int u) { sum[u] = sum[(u << 1)] + sum[(u << 1 | 1)]; }\n  void pushtag(int u, int tg, int l, int r) {\n    tag[u] += tg, sum[u] += 1ll * tg * (r - l + 1);\n  }\n  void pushdown(int u, int l, int r) {\n    if (tag[u]) {\n      int mid = l + r >> 1;\n      pushtag((u << 1), tag[u], l, mid),\n          pushtag((u << 1 | 1), tag[u], mid + 1, r);\n      tag[u] = 0;\n    }\n  }\n  void build(int u, int l, int r) {\n    if (l == r) {\n      sum[u] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build((u << 1), l, mid), build((u << 1 | 1), mid + 1, r);\n    pushup(u);\n  }\n  void update(int u, int l, int r, int ql, int qr, int x) {\n    if (ql > qr) return;\n    if (ql <= l && r <= qr) {\n      pushtag(u, x, l, r);\n      return;\n    }\n    pushdown(u, l, r);\n    int mid = l + r >> 1;\n    if (ql <= mid) update((u << 1), l, mid, ql, qr, x);\n    if (qr > mid) update((u << 1 | 1), mid + 1, r, ql, qr, x);\n    pushup(u);\n  }\n  long long query(int u, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr) return sum[u];\n    int mid = l + r >> 1;\n    pushdown(u, l, r);\n    long long ret = 0;\n    if (ql <= mid) ret += query((u << 1), l, mid, ql, qr);\n    if (qr > mid) ret += query((u << 1 | 1), mid + 1, r, ql, qr);\n    return ret;\n  }\n} smt1;\nstruct SMT2 {\n  int mx[N << 2], mx2[N << 2], cnt[N << 2];\n  int tag[N << 2];\n  void pushup(int u) {\n    if (mx[(u << 1)] == mx[(u << 1 | 1)])\n      mx[u] = mx[(u << 1)], mx2[u] = max(mx2[(u << 1)], mx2[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1)] + cnt[(u << 1 | 1)];\n    else if (mx[(u << 1)] > mx[(u << 1 | 1)])\n      mx[u] = mx[(u << 1)], mx2[u] = max(mx2[(u << 1)], mx[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1)];\n    else\n      mx[u] = mx[(u << 1 | 1)], mx2[u] = max(mx[(u << 1)], mx2[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1 | 1)];\n  }\n  void pushtag(int u, int t) {\n    if (mx[u] > t) mx[u] = t, tag[u] = t;\n  }\n  void pushdown(int u) {\n    if (tag[u] != inf)\n      pushtag((u << 1), tag[u]), pushtag((u << 1 | 1), tag[u]), tag[u] = inf;\n  }\n  void build(int u, int l, int r) {\n    tag[u] = inf;\n    if (l == r) {\n      mx[u] = l, mx2[u] = 0, cnt[u] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build((u << 1), l, mid), build((u << 1 | 1), mid + 1, r);\n    pushup(u);\n  }\n  void beat(int u, int l, int r, int ql, int qr, int x) {\n    if (ql > qr || mx[u] <= x) return;\n    if (ql <= l && r <= qr && mx2[u] < x) {\n      smt1.update(1, 1, n, x + 1, mx[u], -cnt[u]);\n      pushtag(u, x);\n      return;\n    }\n    pushdown(u);\n    int mid = l + r >> 1;\n    if (ql <= mid) beat((u << 1), l, mid, ql, qr, x);\n    if (qr > mid) beat((u << 1 | 1), mid + 1, r, ql, qr, x);\n    pushup(u);\n  }\n  void update(int u, int l, int r, int pos, int x) {\n    if (l == r) {\n      if (x > mx[u])\n        smt1.update(1, 1, n, mx[u] + 1, x, 1);\n      else\n        smt1.update(1, 1, n, x + 1, mx[u], -1);\n      mx[u] = x, mx2[u] = 0, cnt[u] = 1;\n      return;\n    }\n    pushdown(u);\n    int mid = l + r >> 1;\n    if (pos <= mid)\n      update((u << 1), l, mid, pos, x);\n    else\n      update((u << 1 | 1), mid + 1, r, pos, x);\n    pushup(u);\n  }\n} smt2;\nint main() {\n  n = read(), q = read();\n  smt1.build(1, 1, n);\n  smt2.build(1, 1, n);\n  while (q--) {\n    int opt = read(), x = read(), y = read();\n    if (opt == 1) {\n      smt2.beat(1, 1, n, 1, x - 1, x - 1);\n      smt2.update(1, 1, n, x, y);\n    } else {\n      print(smt1.query(1, 1, n, x, y), '\\n');\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T>\nvoid ckmn(T& a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmx(T& a, T b) {\n  a = max(a, b);\n}\nvoid rd(int& x) { scanf(\"%i\", &x); }\nvoid rd(long long& x) { scanf(\"%lld\", &x); }\nvoid rd(char* x) { scanf(\"%s\", x); }\nvoid rd(double& x) { scanf(\"%lf\", &x); }\nvoid rd(string& x) { scanf(\"%s\", &x); }\ntemplate <typename T1, typename T2>\nvoid rd(pair<T1, T2>& x) {\n  rd(x.first);\n  rd(x.second);\n}\ntemplate <typename T>\nvoid rd(vector<T>& x) {\n  for (T& i : x) rd(i);\n}\ntemplate <typename T, typename... A>\nvoid rd(T& x, A&... args) {\n  rd(x);\n  rd(args...);\n}\ntemplate <typename T>\nvoid rd() {\n  T x;\n  rd(x);\n  return x;\n}\nint ri() {\n  int x;\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvector<T> rv(int n) {\n  vector<T> x(n);\n  rd(x);\n  return x;\n}\ntemplate <typename T>\nvoid ra(T a[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]);\n}\ntemplate <typename T1, typename T2>\nvoid ra(T1 a[], T2 b[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]);\n}\ntemplate <typename T1, typename T2, typename T3>\nvoid ra(T1 a[], T2 b[], T3 c[], int n, int st = 1) {\n  for (int i = 0; i < n; ++i) rd(a[st + i]), rd(b[st + i]), rd(c[st + i]);\n}\nvoid re(vector<int> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    rd(u, v);\n    E[u].push_back(v);\n    if (!dir) E[v].push_back(u);\n  }\n}\ntemplate <typename T>\nvoid re(vector<pair<int, T>> E[], int m, bool dir = 0) {\n  for (int i = 0, u, v; i < m; ++i) {\n    T w;\n    rd(u, v, w);\n    E[u].push_back({v, w});\n    if (!dir) E[v].push_back({u, w});\n  }\n}\nconst int N = 200050;\nconst int M = 2 * N;\nnamespace SegLazy {\nint ls[M], rs[M], tsz, root;\nlong long sum[M], lzy[M];\nvoid Build(int& c, int ss, int se) {\n  c = ++tsz;\n  sum[c] = se - ss + 1;\n  lzy[c] = 0;\n  if (ss == se) return;\n  int mid = ss + se >> 1;\n  Build(ls[c], ss, mid);\n  Build(rs[c], mid + 1, se);\n}\nvoid upd(int c, int ss, int se, long long x) {\n  sum[c] += x * (se - ss + 1);\n  lzy[c] += x;\n}\nvoid push(int c, int ss, int se) {\n  if (!lzy[c]) return;\n  int mid = ss + se >> 1;\n  upd(ls[c], ss, mid, lzy[c]);\n  upd(rs[c], mid + 1, se, lzy[c]);\n  lzy[c] = 0;\n}\nvoid Add(int c, int ss, int se, int qs, int qe, long long x) {\n  if (qs > qe || qs > se || ss > qe) return;\n  if (qs <= ss && qe >= se) {\n    upd(c, ss, se, x);\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c, ss, se);\n  Add(ls[c], ss, mid, qs, qe, x);\n  Add(rs[c], mid + 1, se, qs, qe, x);\n  sum[c] = sum[ls[c]] + sum[rs[c]];\n}\nlong long Get(int c, int ss, int se, int qs, int qe) {\n  if (qs > qe || qs > se || ss > qe) return 0;\n  if (qs <= ss && qe >= se) return sum[c];\n  int mid = ss + se >> 1;\n  push(c, ss, se);\n  return Get(ls[c], ss, mid, qs, qe) + Get(rs[c], mid + 1, se, qs, qe);\n}\n}  // namespace SegLazy\nint n, q;\nint ls[M], rs[M], tsz, root, mx[M], smx[M], cnt[M], lzy[M];\nvoid Build(int& c, int ss, int se) {\n  c = ++tsz;\n  mx[c] = se;\n  smx[c] = se - 1;\n  cnt[c] = 1;\n  lzy[c] = n + 1;\n  if (ss == se) {\n    smx[c] = 0;\n    return;\n  }\n  int mid = ss + se >> 1;\n  Build(ls[c], ss, mid);\n  Build(rs[c], mid + 1, se);\n}\nvoid upd(int c, int x) {\n  if (mx[c] > x) {\n    mx[c] = x;\n    lzy[c] = x;\n  }\n}\nvoid push(int c) {\n  if (lzy[c] != n + 1) {\n    upd(ls[c], lzy[c]);\n    upd(rs[c], lzy[c]);\n    lzy[c] = n + 1;\n  }\n}\nvoid pull(int c) {\n  if (mx[ls[c]] > mx[rs[c]]) {\n    mx[c] = mx[ls[c]];\n    smx[c] = max(smx[ls[c]], mx[rs[c]]);\n    cnt[c] = cnt[ls[c]];\n  } else if (mx[rs[c]] > mx[ls[c]]) {\n    mx[c] = mx[rs[c]];\n    smx[c] = max(mx[ls[c]], smx[rs[c]]);\n    cnt[c] = cnt[rs[c]];\n  } else {\n    mx[c] = mx[ls[c]];\n    smx[c] = max(smx[ls[c]], smx[rs[c]]);\n    cnt[c] = cnt[ls[c]] + cnt[rs[c]];\n  }\n}\nvoid Set(int c, int ss, int se, int qi, int x) {\n  if (ss == se) {\n    SegLazy::Add(SegLazy::root, 1, n, qi, mx[c], -1);\n    SegLazy::Add(SegLazy::root, 1, n, qi, x, 1);\n    mx[c] = x;\n    smx[c] = 0;\n    cnt[c] = 1;\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c);\n  if (qi <= mid)\n    Set(ls[c], ss, mid, qi, x);\n  else\n    Set(rs[c], mid + 1, se, qi, x);\n  pull(c);\n}\nvoid Min(int c, int ss, int se, int qs, int qe, int x) {\n  if (qs > qe || qs > se || ss > qe || mx[c] <= x) return;\n  if (qs <= ss & qe >= se && smx[c] < x) {\n    SegLazy::Add(SegLazy::root, 1, n, x + 1, mx[c], -cnt[c]);\n    upd(c, x);\n    return;\n  }\n  int mid = ss + se >> 1;\n  push(c);\n  Min(ls[c], ss, mid, qs, qe, x);\n  Min(rs[c], mid + 1, se, qs, qe, x);\n  pull(c);\n}\nint main() {\n  scanf(\"%i %i\", &n, &q);\n  SegLazy::Build(SegLazy::root, 1, n);\n  Build(root, 1, n);\n  while (q--) {\n    int t, a, b;\n    scanf(\"%i %i %i\", &t, &a, &b);\n    if (t == 1) {\n      Set(root, 1, n, a, b);\n      Min(root, 1, n, 1, a - 1, a - 1);\n    } else {\n      printf(\"%lld\\n\", SegLazy::Get(SegLazy::root, 1, n, a, b));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid rd(T& x) {\n  int f = 0, c;\n  while (!isdigit(c = getchar())) f ^= !(c ^ 45);\n  x = (c & 15);\n  while (isdigit(c = getchar())) x = x * 10 + (c & 15);\n  if (f) x = -x;\n}\ntemplate <typename T>\nvoid pt(T x, int c = -1) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) pt(x / 10);\n  putchar(x % 10 + 48);\n  if (c != -1) putchar(c);\n}\nconst int N = 200005, INF = 0X3F3F3F3F;\nint n, Q;\nstruct seg2 {\n  long long t[N * 4], tg[N * 4];\n  int length[N * 4];\n  void pst(int k1, long long k2) {\n    tg[k1] += k2;\n    t[k1] += k2 * length[k1];\n  }\n  void psd(int k1) {\n    if (tg[k1]) {\n      pst(k1 * 2, tg[k1]);\n      pst(k1 * 2 + 1, tg[k1]);\n      tg[k1] = 0;\n    }\n  }\n  void upd(int k1) { t[k1] = t[k1 * 2] + t[k1 * 2 + 1]; }\n  void bud(int k1, int k2, int k3) {\n    length[k1] = k3 - k2 + 1;\n    if (k2 == k3) {\n      t[k1] = 1;\n      return;\n    }\n    int mid = (k2 + k3) >> 1;\n    bud(k1 * 2, k2, mid), bud(k1 * 2 + 1, mid + 1, k3);\n    upd(k1);\n  }\n  void add(int k1, int k2, int k3, int k4, int k5, int k6) {\n    if (k2 > k5 || k3 < k4) return;\n    if (k4 <= k2 && k3 <= k5) {\n      pst(k1, k6);\n      return;\n    }\n    psd(k1);\n    int mid = (k2 + k3) >> 1;\n    add(k1 * 2, k2, mid, k4, k5, k6), add(k1 * 2 + 1, mid + 1, k3, k4, k5, k6);\n    upd(k1);\n  }\n  long long res;\n  void ask(int k1, int k2, int k3, int k4, int k5) {\n    if (k2 > k5 || k3 < k4) return;\n    if (k4 <= k2 && k3 <= k5) {\n      res += t[k1];\n      return;\n    }\n    psd(k1);\n    int mid = (k2 + k3) >> 1;\n    ask(k1 * 2, k2, mid, k4, k5), ask(k1 * 2 + 1, mid + 1, k3, k4, k5);\n  }\n  long long ask(int l, int r) {\n    res = 0;\n    ask(1, 1, n, l, r);\n    return res;\n  }\n  void out(int k1, int k2, int k3) {\n    if (k2 == k3) {\n      ((void)0);\n      return;\n    }\n    psd(k1);\n    int mid = (k2 + k3) >> 1;\n    out(k1 * 2, k2, mid), out(k1 * 2 + 1, mid + 1, k3);\n  }\n  void out() {\n    ((void)0);\n    out(1, 1, n), ((void)0);\n  }\n} T;\nint mx[N * 4], cnt[N * 4], mx_[N * 4];\nvoid upd(int k1) {\n  if (mx[k1 * 2] == mx[k1 * 2 + 1]) {\n    mx[k1] = mx[k1 * 2];\n    cnt[k1] = cnt[k1 * 2] + cnt[k1 * 2 + 1];\n    mx_[k1] = max(mx_[k1 * 2], mx_[k1 * 2 + 1]);\n  } else if (mx[k1 * 2] > mx[k1 * 2 + 1]) {\n    mx[k1] = mx[k1 * 2];\n    cnt[k1] = cnt[k1 * 2];\n    mx_[k1] = max(mx_[k1 * 2], mx[k1 * 2 + 1]);\n  } else {\n    mx[k1] = mx[k1 * 2 + 1];\n    cnt[k1] = cnt[k1 * 2 + 1];\n    mx_[k1] = max(mx_[k1 * 2 + 1], mx[k1 * 2]);\n  }\n}\nvoid bud(int k1, int k2, int k3) {\n  if (k2 == k3) {\n    mx[k1] = k2, mx_[k1] = ~INF;\n    cnt[k1] = 1;\n    return;\n  }\n  int mid = (k2 + k3) >> 1;\n  bud(k1 * 2, k2, mid), bud(k1 * 2 + 1, mid + 1, k3);\n  upd(k1);\n}\nvoid mdf(int k1, int k2, int k3, int k4, int k5, int k6) {\n  if (k2 > k5 || k3 < k4 || mx[k1] <= k6) return;\n  if (k4 <= k2 && k3 <= k5) {\n    if (mx_[k1] < k6) {\n      T.add(1, 1, n, k6 + 1, mx[k1], -cnt[k1]);\n      mx[k1] = k6;\n      return;\n    }\n  }\n  mx[k1 * 2] = min(mx[k1 * 2], mx[k1]);\n  mx[k1 * 2 + 1] = min(mx[k1 * 2 + 1], mx[k1]);\n  int mid = (k2 + k3) >> 1;\n  mdf(k1 * 2, k2, mid, k4, k5, k6), mdf(k1 * 2 + 1, mid + 1, k3, k4, k5, k6);\n  upd(k1);\n}\nvoid chg(int k1, int k2, int k3, int k4, int k5) {\n  if (k2 == k3) {\n    if (k2 < mx[k1]) {\n      T.add(1, 1, n, k2 + 1, mx[k1], -1);\n    }\n    mx[k1] = k5;\n    if (k2 < mx[k1]) {\n      T.add(1, 1, n, k2 + 1, mx[k1], 1);\n    }\n    return;\n  }\n  mx[k1 * 2] = min(mx[k1 * 2], mx[k1]);\n  mx[k1 * 2 + 1] = min(mx[k1 * 2 + 1], mx[k1]);\n  int mid = (k2 + k3) >> 1;\n  if (k4 <= mid)\n    chg(k1 * 2, k2, mid, k4, k5);\n  else\n    chg(k1 * 2 + 1, mid + 1, k3, k4, k5);\n  upd(k1);\n}\nvoid out(int k1, int k2, int k3) {\n  if (k2 == k3) {\n    ((void)0);\n    return;\n  }\n  mx[k1 * 2] = min(mx[k1 * 2], mx[k1]);\n  mx[k1 * 2 + 1] = min(mx[k1 * 2 + 1], mx[k1]);\n  int mid = (k2 + k3) >> 1;\n  out(k1 * 2, k2, mid), out(k1 * 2 + 1, mid + 1, k3);\n  upd(k1);\n}\nint main() {\n  rd(n), rd(Q);\n  T.bud(1, 1, n);\n  bud(1, 1, n);\n  for (int i = (1); i <= (Q); ++i) {\n    int tp;\n    rd(tp);\n    if (tp == 1) {\n      int c, g;\n      rd(c), rd(g);\n      if (1 <= c - 1) mdf(1, 1, n, 1, c - 1, c - 1);\n      chg(1, 1, n, c, g);\n    } else {\n      int l, r;\n      rd(l), rd(r);\n      printf(\"%lld\\n\", T.ask(l, r));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int N = 200005, inf = 0x3f3f3f3f;\nstruct BIT {\n  long long c[N];\n  void add(int x, long long C) {\n    for (; x < N; x += ((x) & (-(x)))) c[x] += C;\n  }\n  long long ask(int x) {\n    long long ans = 0;\n    for (; x; x -= ((x) & (-(x)))) ans += c[x];\n    return ans;\n  }\n} tr1, tr2;\nstruct DS {\n  BIT a, b;\n  inline void upd(int l, int r, int C) {\n    tr1.add(l, C), tr1.add(r + 1, -C), tr2.add(l, 1LL * l * C),\n        tr2.add(r + 1, -1LL * (r + 1) * C);\n  }\n  inline long long ask(int r) {\n    return 1LL * (r + 1) * tr1.ask(r) - tr2.ask(r);\n  }\n  inline long long ask(int l, int r) { return ask(r) - ask(l - 1); }\n} tr;\nint mx1[N << 2], mx2[N << 2], cnt[N << 2], tag[N << 2];\ninline void pushup(int u) {\n  int x = ((u) << 1), y = ((u) << 1 | 1);\n  if (mx1[x] == mx1[y])\n    mx1[u] = mx1[x], cnt[u] = cnt[x] + cnt[y],\n    mx2[u] = std::max(mx2[x], mx2[y]);\n  else if (mx1[x] > mx1[y])\n    mx1[u] = mx1[x], cnt[u] = cnt[x], mx2[u] = std::max(mx2[x], mx1[y]);\n  else\n    mx1[u] = mx1[y], cnt[u] = cnt[y], mx2[u] = std::max(mx1[x], mx2[y]);\n}\ninline void upd(int u, int C) {\n  if (C < mx1[u]) mx1[u] = C, tag[u] = C;\n}\ninline void pushdown(int u) {\n  if (tag[u] < inf)\n    upd(((u) << 1), tag[u]), upd(((u) << 1 | 1), tag[u]), tag[u] = inf;\n}\nvoid build(int l, int r, int u) {\n  tag[u] = inf;\n  if (l == r) return mx1[u] = l, cnt[u] = 1, void();\n  int mid = (l + r) >> 1;\n  build(l, mid, ((u) << 1)), build(mid + 1, r, ((u) << 1 | 1)), pushup(u);\n}\nvoid Update(int L, int R, int C, int l, int r, int u) {\n  if (C >= mx1[u]) return;\n  if (L <= l && r <= R && C > mx2[u])\n    return tr.upd(C + 1, mx1[u], -cnt[u]), upd(u, C);\n  int mid = (l + r) >> 1;\n  pushdown(u);\n  if (L <= mid) Update(L, R, C, l, mid, ((u) << 1));\n  if (R > mid) Update(L, R, C, mid + 1, r, ((u) << 1 | 1));\n  pushup(u);\n}\nvoid Modify(int pos, int C, int l, int r, int u) {\n  if (l == r) {\n    tr.upd(pos, mx1[u], -1), tr.upd(pos, C, 1);\n    return mx1[u] = C, void();\n  }\n  int mid = (l + r) >> 1;\n  pushdown(u);\n  pos <= mid ? Modify(pos, C, l, mid, ((u) << 1))\n             : Modify(pos, C, mid + 1, r, ((u) << 1 | 1));\n  pushup(u);\n}\nint main() {\n  int n, q, opt, x, y;\n  read(n, q);\n  for (int i = 1; i <= n; ++i) tr.upd(i, i, 1);\n  build(1, n, 1);\n  while (q--) {\n    read(opt, x, y);\n    if (opt == 1) {\n      Modify(x, y, 1, n, 1);\n      if (x > 1) Update(1, x - 1, x - 1, 1, n, 1);\n    } else\n      printf(\"%lld\\n\", tr.ask(x, y));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nstruct BIT {\n  long long t1[200005], t2[200005];\n  void mdf(int p, int v) {\n    for (long long x = 1ll * p * v; p <= n; p += (p & -p))\n      t1[p] += v, t2[p] += x;\n  }\n  void mdf(int l, int r, int v) { mdf(l, v), mdf(r + 1, -v); }\n  long long _q(int x, long long r1 = 0, long long r2 = 0) {\n    for (int p = x; p; p -= (p & -p)) r1 += t1[p], r2 += t2[p];\n    return r1 * (x + 1) - r2;\n  }\n  long long qry(int l, int r) { return _q(r) - _q(l - 1); }\n} B;\nint mx[200005 << 2], sc[200005 << 2], cnt[200005 << 2], tg[200005 << 2];\nvoid cov(int k, int v) {\n  if (v > mx[k]) return;\n  mx[k] = tg[k] = v;\n}\nvoid pud(int k) {\n  if (~tg[k]) cov(k << 1, tg[k]), cov(k << 1 | 1, tg[k]), tg[k] = -1;\n}\nvoid upd(int k) {\n  int ls = k << 1, rs = k << 1 | 1;\n  mx[k] = max(mx[ls], mx[rs]);\n  cnt[k] = 0;\n  sc[k] = -1;\n  if (mx[k] == mx[ls])\n    cnt[k] += cnt[ls], sc[k] = max(sc[k], sc[ls]);\n  else\n    sc[k] = max(sc[k], mx[ls]);\n  if (mx[k] == mx[rs])\n    cnt[k] += cnt[rs], sc[k] = max(sc[k], sc[rs]);\n  else\n    sc[k] = max(sc[k], mx[rs]);\n}\nvoid build(int k, int l, int r) {\n  tg[k] = -1;\n  if (l == r) {\n    mx[k] = l, sc[k] = -1, cnt[k] = 1, B.mdf(l, l, 1);\n    return;\n  }\n  int mid = l + r >> 1;\n  build(k << 1, l, mid), build(k << 1 | 1, mid + 1, r);\n  upd(k);\n}\nvoid Min(int k, int l, int r, int x, int y, int v) {\n  if (v >= mx[k]) return;\n  if (x <= l && r <= y && v > sc[k])\n    return B.mdf(v + 1, mx[k], -cnt[k]), cov(k, v);\n  pud(k);\n  int mid = l + r >> 1;\n  if (x <= mid) Min(k << 1, l, mid, x, y, v);\n  if (y > mid) Min(k << 1 | 1, mid + 1, r, x, y, v);\n  upd(k);\n}\nvoid mdf(int k, int l, int r, int x, int v) {\n  if (l == r) {\n    B.mdf(l, mx[k], -1), mx[k] = v, tg[k] = -1, B.mdf(l, v, 1);\n    return;\n  }\n  pud(k);\n  int mid = l + r >> 1;\n  (x <= mid) ? mdf(k << 1, l, mid, x, v) : mdf(k << 1 | 1, mid + 1, r, x, v);\n  upd(k);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  build(1, 1, n);\n  for (int opt, x, y; m--;) {\n    scanf(\"%d%d%d\", &opt, &x, &y);\n    if (opt == 1) {\n      if (x > 1) Min(1, 1, n, 1, x - 1, x - 1);\n      mdf(1, 1, n, x, y);\n    } else\n      printf(\"%lld\\n\", B.qry(x, y));\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  char ch = getchar();\n  long long nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  long long ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nvoid print(vector<long long> x) {\n  for (long long i = 0; i < (long long)x.size(); i++)\n    printf(\"%lld%c\", x[i], \" \\n\"[i == (long long)x.size() - 1]);\n}\nlong long n, Q;\nstruct SMT {\n  long long t[200005 * 4], tag[200005 * 4];\n  void upd(long long u, long long l, long long r, long long v) {\n    tag[u] += v, t[u] += v * (r - l + 1);\n  }\n  void pushdown(long long u, long long l, long long r) {\n    upd((u << 1), l, ((l + r) / 2), tag[u]),\n        upd((u << 1 | 1), ((l + r) / 2) + 1, r, tag[u]), tag[u] = 0;\n  }\n  void update(long long u, long long l, long long r, long long L, long long R,\n              long long v) {\n    if (L > R) return;\n    if (L <= l && r <= R) return upd(u, l, r, v);\n    pushdown(u, l, r);\n    if (((l + r) / 2) >= L) update((u << 1), l, ((l + r) / 2), L, R, v);\n    if (((l + r) / 2) < R) update((u << 1 | 1), ((l + r) / 2) + 1, r, L, R, v);\n    t[u] = t[(u << 1)] + t[(u << 1 | 1)];\n  }\n  long long query(long long u, long long l, long long r, long long L,\n                  long long R) {\n    if (L <= l && r <= R) return t[u];\n    pushdown(u, l, r);\n    long long ans = 0;\n    if (((l + r) / 2) >= L) ans += query((u << 1), l, ((l + r) / 2), L, R);\n    if (((l + r) / 2) < R)\n      ans += query((u << 1 | 1), ((l + r) / 2) + 1, r, L, R);\n    return ans;\n  }\n} smt;\nstruct Driver {\n  long long mx[200005 * 4], second[200005 * 4], cnt[200005 * 4],\n      tag[200005 * 4];\n  void pushup(long long u) {\n    if (mx[(u << 1)] == mx[(u << 1 | 1)]) {\n      mx[u] = mx[(u << 1)],\n      second[u] = max(second[(u << 1)], second[(u << 1 | 1)]);\n      cnt[u] = cnt[(u << 1)] + cnt[(u << 1 | 1)];\n    } else if (mx[(u << 1)] > mx[(u << 1 | 1)]) {\n      mx[u] = mx[(u << 1)], second[u] = max(mx[(u << 1 | 1)], second[(u << 1)]);\n      cnt[u] = cnt[(u << 1)];\n    } else {\n      mx[u] = mx[(u << 1 | 1)],\n      second[u] = max(mx[(u << 1)], second[(u << 1 | 1)]);\n      cnt[u] = cnt[(u << 1 | 1)];\n    }\n  }\n  void upd(long long u, long long v) {\n    if (v < mx[u]) mx[u] = v, tag[u] = v;\n  }\n  void pushdown(long long u) {\n    if (tag[u] == 0x3f3f3f3f) return;\n    upd((u << 1), tag[u]), upd((u << 1 | 1), tag[u]);\n    tag[u] = 0x3f3f3f3f;\n  }\n  void build(long long u, long long l, long long r) {\n    tag[u] = 0x3f3f3f3f;\n    if (l == r) {\n      mx[u] = l, cnt[u] = 1;\n      return;\n    }\n    build((u << 1), l, ((l + r) / 2)),\n        build((u << 1 | 1), ((l + r) / 2) + 1, r);\n    pushup(u);\n  }\n  void update(long long u, long long l, long long r, long long L, long long R,\n              long long v) {\n    if (L > R || v >= mx[u]) return;\n    if (L <= l && r <= R && v > second[u]) {\n      smt.update(1, 1, n, v + 1, mx[u], -cnt[u]);\n      upd(u, v);\n      return;\n    }\n    pushdown(u);\n    if (((l + r) / 2) >= L) update((u << 1), l, ((l + r) / 2), L, R, v);\n    if (((l + r) / 2) < R) update((u << 1 | 1), ((l + r) / 2) + 1, r, L, R, v);\n    pushup(u);\n  }\n  void fix(long long u, long long l, long long r, long long pos, long long v) {\n    if (l == r) {\n      if (v > mx[u])\n        smt.update(1, 1, n, mx[u] + 1, v, 1);\n      else\n        smt.update(1, 1, n, v + 1, mx[u], -1);\n      mx[u] = v;\n      return;\n    }\n    pushdown(u);\n    if (pos <= ((l + r) / 2))\n      fix((u << 1), l, ((l + r) / 2), pos, v);\n    else\n      fix((u << 1 | 1), ((l + r) / 2) + 1, r, pos, v);\n    pushup(u);\n  }\n} smt2;\nsigned main() {\n  cin >> n >> Q;\n  smt2.build(1, 1, n);\n  smt.update(1, 1, n, 1, n, 1);\n  while (Q--) {\n    long long op = read();\n    if (op == 1) {\n      long long p = read(), v = read();\n      smt2.fix(1, 1, n, p, v);\n      smt2.update(1, 1, n, 1, p - 1, p - 1);\n    } else {\n      long long l = read(), r = read();\n      printf(\"%lld\\n\", smt.query(1, 1, n, l, r));\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 200200;\nstruct seg_tree {\n  ll sum[maxn * 4], lazy[maxn * 4];\n  void build(int l, int r, int rt) {\n    sum[rt] = r - l + 1;\n    if (l == r) return;\n    int mid = (l + r) / 2;\n    build(l, mid, rt << 1);\n    build(mid + 1, r, rt << 1 | 1);\n  }\n  void push_down(int l, int r, int rt) {\n    if (lazy[rt]) {\n      int mid = (l + r) / 2;\n      sum[rt << 1] += (mid - l + 1) * lazy[rt];\n      sum[rt << 1 | 1] += (r - mid) * lazy[rt];\n      lazy[rt << 1] += lazy[rt];\n      lazy[rt << 1 | 1] += lazy[rt];\n      lazy[rt] = 0;\n    }\n  }\n  void add(int L, int R, int v, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n      sum[rt] += v * (ll)(r - l + 1);\n      lazy[rt] += v;\n      return;\n    }\n    push_down(l, r, rt);\n    int mid = (l + r) / 2;\n    if (L <= mid) add(L, R, v, l, mid, rt << 1);\n    if (mid < R) add(L, R, v, mid + 1, r, rt << 1 | 1);\n    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];\n  }\n  ll ask(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) return sum[rt];\n    push_down(l, r, rt);\n    int mid = (l + r) / 2;\n    ll ans = 0;\n    if (L <= mid) ans += ask(L, R, l, mid, rt << 1);\n    if (mid < R) ans += ask(L, R, mid + 1, r, rt << 1 | 1);\n    return ans;\n  }\n} S;\nstruct seg_tree2 {\n  int n;\n  struct node {\n    int mx, mx2, num_mx, tag;\n  } tr[maxn * 4];\n  void build(int l, int r, int rt) {\n    if (l == r) {\n      tr[rt].mx = l;\n      tr[rt].mx2 = 0;\n      tr[rt].num_mx = 1;\n      return;\n    }\n    int mid = (l + r) / 2;\n    build(l, mid, rt << 1);\n    build(mid + 1, r, rt << 1 | 1);\n    tr[rt].mx = r;\n    tr[rt].mx2 = r - 1;\n    tr[rt].num_mx = 1;\n  }\n  void push_up(int rt) {\n    if (tr[rt << 1].mx > tr[rt << 1 | 1].mx) {\n      tr[rt].mx = tr[rt << 1].mx;\n      tr[rt].mx2 = max(tr[rt << 1].mx2, tr[rt << 1 | 1].mx);\n      tr[rt].num_mx = tr[rt << 1].num_mx;\n    } else if (tr[rt << 1].mx < tr[rt << 1 | 1].mx) {\n      tr[rt].mx = tr[rt << 1 | 1].mx;\n      tr[rt].mx2 = max(tr[rt << 1].mx, tr[rt << 1 | 1].mx2);\n      tr[rt].num_mx = tr[rt << 1 | 1].num_mx;\n    } else {\n      tr[rt].mx = tr[rt << 1].mx;\n      tr[rt].mx2 = max(tr[rt << 1].mx2, tr[rt << 1 | 1].mx2);\n      tr[rt].num_mx = tr[rt << 1].num_mx + tr[rt << 1 | 1].num_mx;\n    }\n  }\n  void push_down(int rt) {\n    if (tr[rt].tag) {\n      if (tr[rt << 1].mx > tr[rt].tag) {\n        tr[rt << 1].mx = tr[rt].tag;\n        tr[rt << 1].tag = tr[rt].tag;\n      }\n      if (tr[rt << 1 | 1].mx > tr[rt].tag) {\n        tr[rt << 1 | 1].mx = tr[rt].tag;\n        tr[rt << 1 | 1].tag = tr[rt].tag;\n      }\n      tr[rt].tag = 0;\n    }\n  }\n  void upd_min(int L, int R, int v, int l, int r, int rt) {\n    if (l > R || r < L || tr[rt].mx <= v) return;\n    if (L <= l && r <= R && tr[rt].mx2 < v) {\n      S.add(v + 1, tr[rt].mx, -tr[rt].num_mx, 1, n, 1);\n      tr[rt].mx = v;\n      tr[rt].tag = v;\n      return;\n    }\n    push_down(rt);\n    int mid = (l + r) / 2;\n    upd_min(L, R, v, l, mid, rt << 1);\n    upd_min(L, R, v, mid + 1, r, rt << 1 | 1);\n    push_up(rt);\n  }\n  void upd(int p, int v, int l, int r, int rt) {\n    if (l == r) {\n      if (tr[rt].mx > v) {\n        S.add(v + 1, tr[rt].mx, -1, 1, n, 1);\n      } else if (tr[rt].mx < v) {\n        S.add(tr[rt].mx + 1, v, 1, 1, n, 1);\n      }\n      tr[rt].mx = v;\n      return;\n    }\n    push_down(rt);\n    int mid = (l + r) / 2;\n    if (p <= mid)\n      upd(p, v, l, mid, rt << 1);\n    else\n      upd(p, v, mid + 1, r, rt << 1 | 1);\n    push_up(rt);\n  }\n} T;\nint main(void) {\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  S.build(1, n, 1);\n  T.n = n;\n  T.build(1, n, 1);\n  for (int i = 0; i < q; i++) {\n    int op, x, y;\n    scanf(\"%d%d%d\", &op, &x, &y);\n    if (op == 1) {\n      T.upd(x, y, 1, n, 1);\n      if (x > 1) T.upd_min(1, x - 1, x - 1, 1, n, 1);\n    } else {\n      ll ans = S.ask(x, y, 1, n, 1);\n      printf(\"%lld\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::max;\nusing std::min;\nconst int N = 200005;\nint n, q;\nint sum[N];\nlong long sum1[N];\ninline void add(int p, int v) {\n  while (p <= n) sum[p] += v, p += p & (-p);\n}\ninline int ask(int p) {\n  int ret = 0;\n  while (p) ret += sum[p], p -= p & (-p);\n  return ret;\n}\ninline void add1(int p, int v) {\n  while (p <= n) sum1[p] += v, p += p & (-p);\n}\ninline long long ask1(int p) {\n  long long ret = 0;\n  while (p) ret += sum1[p], p -= p & (-p);\n  return ret;\n}\ninline void radd(int l, int r, int v) {\n  add(l, v), add1(l, 1ll * l * v);\n  add(r + 1, -v), add1(r + 1, -1ll * (r + 1) * v);\n}\ninline long long rask(int p) { return 1ll * (p + 1) * ask(p) - ask1(p); }\nnamespace SGT {\nint mx[N << 2], mx1[N << 2], cnt[N << 2], tag[N << 2];\ninline void pushdown(int id) {\n  mx[(id << 1)] = min(mx[(id << 1)], tag[id]);\n  tag[(id << 1)] = min(tag[(id << 1)], tag[id]);\n  mx[(id << 1 | 1)] = min(mx[(id << 1 | 1)], tag[id]);\n  tag[(id << 1 | 1)] = min(tag[(id << 1 | 1)], tag[id]);\n  tag[id] = 0x3f3f3f3f;\n}\ninline void upt(int id) {\n  mx1[id] = 0;\n  mx[id] = max(mx[(id << 1)], mx[(id << 1 | 1)]);\n  cnt[id] = (mx[(id << 1)] == mx[id] ? cnt[(id << 1)] : 0) +\n            (mx[(id << 1 | 1)] == mx[id] ? cnt[(id << 1 | 1)] : 0);\n  mx1[id] = max(\n      (mx[(id << 1)] == mx[id] ? mx1[(id << 1)] : mx[(id << 1)]),\n      (mx[(id << 1 | 1)] == mx[id] ? mx1[(id << 1 | 1)] : mx[(id << 1 | 1)]));\n}\nvoid build(int id, int l, int r) {\n  tag[id] = 0x3f3f3f3f;\n  if (l == r) {\n    mx[id] = l;\n    cnt[id] = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((id << 1), l, mid), build((id << 1 | 1), mid + 1, r);\n  upt(id);\n}\nvoid addp(int id, int l, int r, int p, int v) {\n  if (l == r) {\n    radd(l + 1, mx[id], -1);\n    mx[id] = v;\n    radd(l + 1, v, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(id);\n  if (p <= mid)\n    addp((id << 1), l, mid, p, v);\n  else\n    addp((id << 1 | 1), mid + 1, r, p, v);\n  upt(id);\n}\nvoid add(int id, int l, int r, int p) {\n  if (mx[id] <= p) return;\n  if (r <= p) {\n    if (mx1[id] < p) {\n      radd(p + 1, mx[id], -cnt[id]);\n      tag[id] = p;\n      mx[id] = p;\n      return;\n    }\n  }\n  pushdown(id);\n  int mid = (l + r) >> 1;\n  add((id << 1), l, mid, p);\n  if (p > mid) add((id << 1 | 1), mid + 1, r, p);\n  upt(id);\n}\n}  // namespace SGT\nusing namespace SGT;\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  build(1, 1, n);\n  for (int i = 1, tp, x, y; i <= q; ++i) {\n    scanf(\"%d%d%d\", &tp, &x, &y);\n    if (tp == 1) {\n      if (x - 1) add(1, 1, n, x - 1);\n      addp(1, 1, n, x, y);\n    } else\n      printf(\"%lld\\n\", rask(y) - rask(x - 1) + y - x + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2, 3, \"Ofast\")\n#pragma GCC target(\"avx\", \"avx2\")\nusing namespace std;\ntemplate <typename T1, typename T2>\nvoid ckmin(T1 &a, T2 b) {\n  if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid ckmax(T1 &a, T2 b) {\n  if (a < b) a = b;\n}\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N = 200005;\nconst int inf = 1e9;\nint n, q;\nstruct SMT1 {\n  long long sum[N << 2], tag[N << 2];\n  void pushup(int u) { sum[u] = sum[(u << 1)] + sum[(u << 1 | 1)]; }\n  void pushtag(int u, int tg, int l, int r) {\n    tag[u] += tg, sum[u] += 1ll * tg * (r - l + 1);\n  }\n  void pushdown(int u, int l, int r) {\n    if (tag[u]) {\n      int mid = l + r >> 1;\n      pushtag((u << 1), tag[u], l, mid),\n          pushtag((u << 1 | 1), tag[u], mid + 1, r);\n      tag[u] = 0;\n    }\n  }\n  void build(int u, int l, int r) {\n    if (l == r) {\n      sum[u] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build((u << 1), l, mid), build((u << 1 | 1), mid + 1, r);\n    pushup(u);\n  }\n  void update(int u, int l, int r, int ql, int qr, int x) {\n    if (ql > qr) return;\n    if (ql <= l && r <= qr) {\n      pushtag(u, x, l, r);\n      return;\n    }\n    pushdown(u, l, r);\n    int mid = l + r >> 1;\n    if (ql <= mid) update((u << 1), l, mid, ql, qr, x);\n    if (qr > mid) update((u << 1 | 1), mid + 1, r, ql, qr, x);\n    pushup(u);\n  }\n  long long query(int u, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr) return sum[u];\n    int mid = l + r >> 1;\n    pushdown(u, l, r);\n    long long ret = 0;\n    if (ql <= mid) ret += query((u << 1), l, mid, ql, qr);\n    if (qr > mid) ret += query((u << 1 | 1), mid + 1, r, ql, qr);\n    return ret;\n  }\n} smt1;\nstruct SMT2 {\n  int mx[N << 2], mx2[N << 2], cnt[N << 2];\n  int tag[N << 2];\n  void pushup(int u) {\n    if (mx[(u << 1)] == mx[(u << 1 | 1)])\n      mx[u] = mx[(u << 1)], mx2[u] = max(mx2[(u << 1)], mx2[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1)] + cnt[(u << 1 | 1)];\n    else if (mx[(u << 1)] > mx[(u << 1 | 1)])\n      mx[u] = mx[(u << 1)], mx2[u] = max(mx2[(u << 1)], mx[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1)];\n    else\n      mx[u] = mx[(u << 1 | 1)], mx2[u] = max(mx[(u << 1)], mx2[(u << 1 | 1)]),\n      cnt[u] = cnt[(u << 1 | 1)];\n  }\n  void pushtag(int u, int t) {\n    if (mx[u] > t) mx[u] = t, tag[u] = t;\n  }\n  void pushdown(int u) {\n    if (tag[u] != inf)\n      pushtag((u << 1), tag[u]), pushtag((u << 1 | 1), tag[u]), tag[u] = inf;\n  }\n  void build(int u, int l, int r) {\n    tag[u] = inf;\n    if (l == r) {\n      mx[u] = l, mx2[u] = 0, cnt[u] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build((u << 1), l, mid), build((u << 1 | 1), mid + 1, r);\n    pushup(u);\n  }\n  void beat(int u, int l, int r, int ql, int qr, int x) {\n    if (ql > qr || mx[u] <= x) return;\n    if (ql <= l && r <= qr && mx2[u] <= x) {\n      smt1.update(1, 1, n, x + 1, mx[u], -cnt[u]);\n      pushtag(u, x);\n      return;\n    }\n    pushdown(u);\n    int mid = l + r >> 1;\n    if (ql <= mid) beat((u << 1), l, mid, ql, qr, x);\n    if (qr > mid) beat((u << 1 | 1), mid + 1, r, ql, qr, x);\n    pushup(u);\n  }\n  void update(int u, int l, int r, int pos, int x) {\n    if (l == r) {\n      if (x > mx[u])\n        smt1.update(1, 1, n, mx[u] + 1, x, 1);\n      else\n        smt1.update(1, 1, n, x + 1, mx[u], -1);\n      mx[u] = x, mx2[u] = 0, cnt[u] = 1;\n      return;\n    }\n    pushdown(u);\n    int mid = l + r >> 1;\n    if (pos <= mid)\n      update((u << 1), l, mid, pos, x);\n    else\n      update((u << 1 | 1), mid + 1, r, pos, x);\n    pushup(u);\n  }\n} smt2;\nint main() {\n  n = read(), q = read();\n  smt1.build(1, 1, n);\n  smt2.build(1, 1, n);\n  while (q--) {\n    int opt = read(), x = read(), y = read();\n    if (opt == 1) {\n      smt2.beat(1, 1, n, 1, x - 1, x - 1);\n      smt2.update(1, 1, n, x, y);\n    } else {\n      print(smt1.query(1, 1, n, x, y), '\\n');\n    }\n  }\n  return 0;\n}\n"
        }
    ]
}