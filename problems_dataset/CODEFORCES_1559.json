{
    "name": "1559_E. Mocha and Stars",
    "source": "CODEFORCES",
    "description": "Mocha wants to be an astrologer. There are n stars which can be seen in Zhijiang, and the brightness of the i-th star is a_i. \n\nMocha considers that these n stars form a constellation, and she uses (a_1,a_2,\u2026,a_n) to show its state. A state is called mathematical if all of the following three conditions are satisfied:\n\n  * For all i (1\u2264 i\u2264 n), a_i is an integer in the range [l_i, r_i].\n  * \u2211  _{i=1} ^ n a_i \u2264 m.\n  * \\gcd(a_1,a_2,\u2026,a_n)=1.\n\n\n\nHere, \\gcd(a_1,a_2,\u2026,a_n) denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers a_1,a_2,\u2026,a_n.\n\nMocha is wondering how many different mathematical states of this constellation exist. Because the answer may be large, you must find it modulo 998 244 353.\n\nTwo states (a_1,a_2,\u2026,a_n) and (b_1,b_2,\u2026,b_n) are considered different if there exists i (1\u2264 i\u2264 n) such that a_i \u2260 b_i.\n\nInput\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 50, 1 \u2264 m \u2264 10^5) \u2014 the number of stars and the upper bound of the sum of the brightness of stars.\n\nEach of the next n lines contains two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 m) \u2014 the range of the brightness of the i-th star.\n\nOutput\n\nPrint a single integer \u2014 the number of different mathematical states of this constellation, modulo 998 244 353.\n\nExamples\n\nInput\n\n\n2 4\n1 3\n1 2\n\n\nOutput\n\n\n4\n\nInput\n\n\n5 10\n1 10\n1 10\n1 10\n1 10\n1 10\n\n\nOutput\n\n\n251\n\nInput\n\n\n5 100\n1 94\n1 96\n1 91\n4 96\n6 97\n\n\nOutput\n\n\n47464146\n\nNote\n\nIn the first example, there are 4 different mathematical states of this constellation:\n\n  * a_1=1, a_2=1.\n  * a_1=1, a_2=2.\n  * a_1=2, a_2=1.\n  * a_1=3, a_2=1.",
    "difficulty": "E",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math",
        "number theory"
    ],
    "rating": 2200,
    "public_test": [
        {
            "input": "5 10\n1 10\n1 10\n1 10\n1 10\n1 10\n",
            "output": "251\n"
        },
        {
            "input": "2 4\n1 3\n1 2\n",
            "output": "4\n"
        },
        {
            "input": "5 100\n1 94\n1 96\n1 91\n4 96\n6 97\n",
            "output": "47464146\n"
        }
    ],
    "generated_test": [
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 9992\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 9997\n3 9993\n7 9999\n",
            "output": "334201732\n"
        },
        {
            "input": "50 100000\n4 99994\n1 99991\n9 100000\n9 100000\n3 99997\n1 99995\n9 100000\n3 99998\n8 100000\n7 99998\n1 99997\n8 100000\n4 100000\n7 53660\n7 99997\n5 99995\n10 100000\n5 100000\n1 100000\n9 100000\n5 99998\n9 100000\n6 100000\n2 99997\n2 99994\n3 99998\n10 100000\n5 99995\n2 99996\n10 100000\n7 99999\n5 99995\n3 99997\n10 100000\n2 99993\n3 99996\n1 99998\n9 100000\n6 99998\n6 99996\n3 100000\n1 100000\n6 99997\n10 100000\n6 99998\n2 99993\n5 99995\n10 100000\n9 100000\n5 100000\n",
            "output": "641593442\n"
        },
        {
            "input": "2 82949\n3069 17191\n63122 107987\n",
            "output": "83266625\n"
        },
        {
            "input": "50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n",
            "output": "228090460\n"
        },
        {
            "input": "50 100\n8 98\n10 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 97\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n8 100\n7 98\n6 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 9999\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n4 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "517149743\n"
        },
        {
            "input": "25 1000\n5 995\n9 406\n10 1000\n6 999\n7 998\n9 1000\n5 1000\n6 1000\n10 1000\n3 994\n5 996\n2 1000\n4 999\n6 996\n8 998\n9 999\n2 994\n9 1000\n3 994\n2 999\n1 991\n1 992\n2 1000\n3 994\n2 998\n",
            "output": "709483295\n"
        },
        {
            "input": "5 1000\n3 997\n3 998\n6 996\n1 1000\n8 875\n",
            "output": "271227350\n"
        },
        {
            "input": "5 10000\n7 9997\n7 10000\n4 9835\n7 9998\n8 10000\n",
            "output": "118762852\n"
        },
        {
            "input": "25 100000\n6 99999\n7 99997\n2 100000\n1 99996\n9 100000\n2 99996\n9 99999\n3 99995\n8 100000\n9 99999\n7 99997\n4 100000\n7 99998\n2 100000\n9 99999\n9 100000\n7 100000\n5 99999\n7 99998\n2 99997\n9 99999\n7 91478\n2 99996\n10 100000\n3 99993\n",
            "output": "695965995\n"
        },
        {
            "input": "3 10\n1 10\n1 10\n1 10\n1 10\n1 10\n",
            "output": "109\n"
        },
        {
            "input": "2 8\n1 3\n1 2\n",
            "output": "5\n"
        },
        {
            "input": "2 100\n1 94\n1 96\n1 91\n4 96\n6 97\n",
            "output": "3028\n"
        },
        {
            "input": "2 82949\n3069 17191\n63122 78434\n",
            "output": "82630425\n"
        },
        {
            "input": "5 1000\n3 997\n3 998\n6 996\n1 1000\n4 875\n",
            "output": "374201532\n"
        },
        {
            "input": "25 100000\n6 99999\n7 99997\n2 100000\n1 99996\n9 100000\n2 99996\n9 99999\n4 99995\n8 100000\n9 99999\n7 99997\n4 100000\n7 99998\n2 100000\n9 99999\n9 100000\n7 100000\n5 99999\n7 99998\n2 99997\n9 99999\n7 91478\n2 99996\n10 100000\n3 99993\n",
            "output": "271415936\n"
        },
        {
            "input": "2 8\n1 5\n1 2\n",
            "output": "8\n"
        },
        {
            "input": "2 100\n1 94\n1 40\n1 91\n4 96\n6 97\n",
            "output": "1942\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 8207\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "684128869\n"
        },
        {
            "input": "2 66196\n3069 17191\n63122 78434\n",
            "output": "10\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "330619093\n"
        },
        {
            "input": "5 1000\n3 997\n3 998\n6 996\n2 1000\n4 875\n",
            "output": "10689569\n"
        },
        {
            "input": "1 1\n1 1\n1 1\n4 1\n",
            "output": "1\n"
        },
        {
            "input": "25 100000\n6 99999\n7 99997\n2 100000\n1 99996\n9 100000\n2 99996\n9 99999\n4 99995\n8 100000\n9 99999\n7 99997\n4 100000\n7 99998\n2 100000\n9 99999\n9 100000\n7 100000\n10 99999\n7 99998\n2 99997\n9 99999\n7 91478\n2 99996\n10 100000\n3 99993\n",
            "output": "618622119\n"
        },
        {
            "input": "2 100\n1 94\n1 57\n1 91\n4 96\n6 97\n",
            "output": "2478\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "962156906\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "666721437\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "193784383\n"
        },
        {
            "input": "2 100\n1 94\n1 102\n1 122\n4 118\n6 97\n",
            "output": "3033\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "590916881\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n5 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "24178763\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "584217217\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 10739\n10 10000\n4 9994\n5 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "707366471\n"
        },
        {
            "input": "15 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 13\n",
            "output": "3875\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "3758316\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "438834239\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "626022166\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "652972390\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "247853022\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "101493000\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "162847687\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "768926378\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "437214019\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "286592971\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "778011245\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "616694809\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "789615302\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "313843754\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "783475793\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n8 10000\n14 388\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 11000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "102783445\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n8 10000\n14 388\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 00010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 11000\n11 9999\n6 10001\n2 19773\n3 5451\n11 9999\n",
            "output": "298034571\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 9992\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 5018\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n10 10000\n6 9999\n6 10000\n2 9997\n3 9993\n7 9999\n",
            "output": "556871970\n"
        },
        {
            "input": "50 100000\n4 99994\n1 99991\n9 100000\n9 100000\n3 99997\n1 99995\n9 100000\n3 99998\n8 100000\n7 99998\n1 99997\n8 100000\n8 100000\n7 99998\n7 99997\n5 99995\n10 100000\n5 100000\n1 100000\n9 100000\n5 99998\n9 100000\n6 100000\n2 99997\n2 99994\n3 99998\n10 100000\n5 99995\n2 99996\n10 100000\n7 99999\n5 99995\n3 99997\n10 100000\n2 99993\n3 99996\n1 99998\n9 100000\n6 99998\n6 99996\n3 100000\n1 100000\n6 99997\n10 100000\n6 99998\n2 99993\n5 99995\n10 100000\n9 100000\n5 100000\n",
            "output": "656361110\n"
        },
        {
            "input": "50 1000\n2 993\n10 1000\n4 996\n5 997\n2 1000\n2 992\n4 994\n5 1000\n10 1000\n3 996\n7 999\n4 999\n4 995\n8 1000\n1 993\n5 995\n3 996\n1 994\n7 1020\n2 994\n8 1000\n3 999\n4 995\n5 1000\n5 997\n8 1000\n6 998\n2 999\n4 997\n2 1000\n2 992\n4 998\n1 997\n2 1000\n8 999\n6 999\n8 1000\n1 992\n1 999\n1 991\n3 993\n6 998\n6 996\n3 998\n10 1000\n1 998\n6 997\n8 1000\n7 1000\n2 999\n",
            "output": "485490839\n"
        },
        {
            "input": "25 1000\n5 995\n9 999\n10 1000\n6 999\n7 998\n9 1000\n5 1000\n6 1000\n10 1000\n3 994\n5 996\n2 1000\n4 999\n6 996\n8 998\n9 999\n2 994\n1 1000\n3 994\n2 999\n1 991\n1 992\n2 1000\n3 994\n2 998\n",
            "output": "273195392\n"
        },
        {
            "input": "5 1000\n1 997\n3 998\n6 996\n1 1000\n8 998\n",
            "output": "935439703\n"
        },
        {
            "input": "5 10000\n7 9997\n7 10000\n4 9999\n7 9998\n3 10000\n",
            "output": "108615123\n"
        },
        {
            "input": "25 100000\n6 99999\n7 99997\n2 100000\n1 99996\n9 100000\n2 99996\n9 99999\n3 99995\n8 100000\n9 99999\n7 99997\n4 100000\n7 99998\n2 100000\n9 99999\n9 100000\n7 100000\n5 99999\n7 99998\n2 99997\n9 99999\n7 99997\n4 99996\n10 100000\n3 99993\n",
            "output": "375423198\n"
        },
        {
            "input": "5 10\n1 10\n1 10\n1 10\n1 10\n2 10\n",
            "output": "125\n"
        },
        {
            "input": "2 4\n2 3\n1 2\n",
            "output": "2\n"
        },
        {
            "input": "5 110\n1 94\n1 96\n1 91\n4 96\n6 97\n",
            "output": "80398988\n"
        },
        {
            "input": "50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n2 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n",
            "output": "327253093\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 9999\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n4 9998\n3 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "493183265\n"
        },
        {
            "input": "25 1000\n5 995\n9 406\n10 1000\n6 999\n7 998\n9 1000\n5 1000\n6 1000\n10 1000\n3 994\n5 996\n2 1000\n4 999\n6 996\n8 579\n9 999\n2 994\n9 1000\n3 994\n2 999\n1 991\n1 992\n2 1000\n3 994\n2 998\n",
            "output": "88993519\n"
        },
        {
            "input": "5 1010\n3 997\n3 998\n6 996\n1 1000\n8 875\n",
            "output": "372175284\n"
        },
        {
            "input": "3 18\n1 10\n1 10\n1 10\n1 10\n1 10\n",
            "output": "559\n"
        },
        {
            "input": "2 8\n1 3\n1 3\n",
            "output": "7\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n4 9998\n4 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "277476644\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 8207\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 5807\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "728756827\n"
        },
        {
            "input": "2 66196\n3069 17191\n53717 78434\n",
            "output": "26924495\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n5 9996\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "897158140\n"
        },
        {
            "input": "5 1000\n3 997\n3 998\n11 996\n2 1000\n4 875\n",
            "output": "885390120\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 8207\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 6252\n",
            "output": "612979127\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n3 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "723132564\n"
        },
        {
            "input": "2 110\n1 94\n1 57\n1 122\n4 96\n6 97\n",
            "output": "2776\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n4 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "445666875\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 7061\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "588457157\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 10342\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "931831190\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 3400\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "89189303\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n5 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10010\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "545011089\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n4 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "448583972\n"
        },
        {
            "input": "4 11000\n4 9998\n4 9999\n4 10739\n10 10000\n4 9994\n5 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "548847417\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n1 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "194175678\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n4 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "5910818\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n5 9993\n7 9999\n",
            "output": "97265267\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 2683\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "396640847\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n12 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "450720396\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 11517\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "949020\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n17 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "272976655\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n10 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "63232625\n"
        },
        {
            "input": "50 10000\n12 9997\n7 4858\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "964257498\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 1959\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "178437323\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 3001\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "44939398\n"
        },
        {
            "input": "50 10000\n2 9997\n7 9999\n8 15775\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "986391239\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 4534\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "314719506\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 7107\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "641303724\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9287\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "159499492\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n4 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "555548881\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 1958\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "931606448\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 6265\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "774939333\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 9320\n1 14169\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 11000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "807171956\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n8 10000\n14 388\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 01000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "213217942\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n8 10000\n14 388\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 655\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 11000\n11 9999\n6 10001\n2 19773\n3 5451\n11 9999\n",
            "output": "288292363\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n12 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 14169\n4 10000\n10 10000\n14 388\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 00010\n5 9999\n5 7511\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 11000\n11 9999\n6 10001\n2 19773\n3 5451\n11 9999\n",
            "output": "550034557\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 9992\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 5018\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 8004\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n10 10000\n6 9999\n6 10000\n2 9997\n3 9993\n7 9999\n",
            "output": "856432445\n"
        },
        {
            "input": "50 100000\n4 99994\n1 99991\n9 100000\n9 100000\n3 99997\n1 99995\n9 100000\n3 99998\n8 100000\n7 99998\n1 99997\n8 100000\n8 100000\n7 99998\n7 99997\n5 99995\n10 100000\n5 100000\n1 100000\n9 100000\n5 99998\n9 100000\n6 100000\n2 99997\n2 99994\n3 99998\n10 100000\n5 99995\n2 99996\n10 100000\n7 99999\n5 99995\n3 99997\n10 100000\n2 99993\n3 99996\n1 99998\n9 100000\n6 99998\n4 99996\n3 100000\n1 100000\n6 99997\n10 100000\n6 99998\n2 99993\n5 99995\n10 100000\n9 100000\n5 100000\n",
            "output": "292168689\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 13893\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10000\n8 9999\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n3 10000\n4 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "451758561\n"
        },
        {
            "input": "25 1000\n5 995\n9 999\n10 1000\n6 999\n7 703\n9 1000\n5 1000\n6 1000\n10 1000\n3 994\n5 996\n2 1000\n4 999\n6 996\n8 998\n9 999\n2 994\n1 1000\n3 994\n2 999\n1 991\n1 992\n2 1000\n3 994\n2 998\n",
            "output": "416202625\n"
        },
        {
            "input": "25 100000\n6 98667\n7 99997\n2 100000\n1 99996\n9 100000\n2 99996\n9 99999\n3 99995\n8 100000\n9 99999\n7 99997\n4 100000\n7 99998\n2 100000\n9 99999\n9 100000\n7 100000\n5 99999\n7 99998\n2 99997\n9 99999\n7 99997\n4 99996\n10 100000\n3 99993\n",
            "output": "115340488\n"
        },
        {
            "input": "50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n2 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n2 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n",
            "output": "496863857\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 9999\n10 10000\n9 5243\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n4 9998\n3 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "158061085\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n10 9998\n2 10000\n7 9999\n10 10000\n1 9992\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 11000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "513117741\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n15 9999\n8 9999\n7 10000\n4 9998\n4 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "689163817\n"
        },
        {
            "input": "5 1100\n3 997\n3 998\n6 996\n2 1000\n4 875\n",
            "output": "680197156\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 8207\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 7350\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 5807\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "868599078\n"
        },
        {
            "input": "5 1000\n6 997\n3 998\n11 996\n2 1000\n4 875\n",
            "output": "40788613\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n7 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10010\n2 19773\n3 9993\n7 9999\n",
            "output": "687318925\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n4 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n4 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "673306436\n"
        },
        {
            "input": "25 11000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n11 10000\n9 9999\n10 10000\n3 10342\n8 9999\n8 9999\n7 10000\n6 15194\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "883761166\n"
        },
        {
            "input": "50 10000\n6 9997\n11 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 3400\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "851759684\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n4 10000\n2 9998\n2 9996\n10 10010\n5 8276\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "252783172\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 8367\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n1 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "830755735\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 8753\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10001\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "53953354\n"
        },
        {
            "input": "50 10000\n6 9997\n7 1588\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 14076\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "674064672\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n1 9995\n12 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "137410357\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n11 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 3001\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "284529083\n"
        },
        {
            "input": "50 10000\n2 9997\n7 9999\n8 15775\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 605\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "817132877\n"
        },
        {
            "input": "25 100\n6 96\n3 94\n8 99\n6 99\n5 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 99\n2 99\n4 98\n7 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "3 1\n1 1\n1 1\n2 1\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 9992\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10000\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "334201732\n"
        },
        {
            "input": "50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 000000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n",
            "output": "0\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 97\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n8 100\n7 98\n6 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 94\n8 99\n6 99\n5 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 99\n2 99\n4 98\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 9996\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n4 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "517149743\n"
        },
        {
            "input": "3 1\n1 1\n1 1\n4 1\n",
            "output": "0\n"
        },
        {
            "input": "50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 000000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 101000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n",
            "output": "0\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 97\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 100\n7 98\n6 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n5 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 99\n2 99\n4 98\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 8207\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "684128869\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 97\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 100\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n5 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 99\n2 99\n4 179\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "25 10000\n4 9998\n4 9999\n4 9998\n10 10000\n4 9994\n4 9997\n3 9994\n1 9994\n5 10000\n3 13534\n10 10100\n8 14433\n10 10000\n9 9999\n10 10000\n3 9998\n8 9999\n8 9999\n7 10000\n6 9998\n2 9995\n6 9996\n5 9995\n7 9997\n10 10000\n",
            "output": "330619093\n"
        },
        {
            "input": "1 1\n1 1\n1 1\n4 2\n",
            "output": "1\n"
        },
        {
            "input": "2 100\n1 94\n1 57\n1 122\n4 96\n6 97\n",
            "output": "2478\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10000\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n3 9997\n1 9994\n4 10000\n8 10000\n7 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n4 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "334201732\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 97\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n5 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "1 1\n1 1\n2 1\n4 2\n",
            "output": "1\n"
        },
        {
            "input": "2 100\n1 94\n1 57\n1 122\n4 118\n6 97\n",
            "output": "2478\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 100\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n3 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 99\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 100\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n6 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n3 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 9994\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "584217217\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n6 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 99\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n2 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "584217217\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 98\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "25 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 13\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 9995\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "590916881\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 94\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n6 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 10100\n9 9999\n2 9998\n3 10000\n7 9999\n4 9998\n4 9997\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 9998\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n6 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "590916881\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 100\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "21 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 99\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 13\n",
            "output": "0\n"
        },
        {
            "input": "50 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "21 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 124\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n5 100\n6 97\n4 13\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n8 98\n15 100\n4 94\n6 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "21 100\n6 96\n4 166\n8 99\n6 99\n7 95\n2 97\n8 124\n7 99\n4 99\n10 100\n9 99\n10 101\n5 96\n8 98\n2 100\n4 95\n9 102\n2 99\n4 179\n13 97\n8 100\n9 110\n10 100\n6 97\n4 13\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n8 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 168\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 96\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 9996\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "247853022\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 175\n1 97\n8 98\n9 100\n8 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 9997\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "247853022\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n8 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 9998\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n10 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "247853022\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 96\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 23\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 99\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10000\n7 9999\n10 10000\n1 12363\n7 9998\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n10 10010\n5 9999\n5 9995\n9 10000\n8 9999\n7 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n7 9999\n",
            "output": "101493000\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 23\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 97\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 23\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n8 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 23\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 99\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 23\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 24\n6 99\n1 95\n1 91\n3 95\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 15775\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n4 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "286592971\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 99\n4 96\n7 100\n5 24\n6 99\n1 95\n1 91\n3 94\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 91\n3 94\n3 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 9999\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "778011245\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 91\n3 94\n5 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 69\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10000\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 9998\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "778011245\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 91\n3 94\n5 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 143\n3 94\n5 95\n9 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 10001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 9993\n11 9999\n",
            "output": "616694809\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 143\n3 94\n5 95\n2 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n2 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 143\n3 94\n5 95\n2 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n1 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n8 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "50 10000\n12 9997\n7 9999\n8 13579\n2 11001\n7 9999\n10 10010\n1 12363\n7 8169\n2 9992\n7 11100\n9 5559\n2 9998\n3 10000\n7 15904\n6 9998\n4 7373\n1 9994\n4 10000\n8 10000\n14 331\n5 9995\n9 9999\n2 5944\n5 10000\n2 9998\n2 9996\n2 10010\n5 9999\n5 9995\n9 10000\n8 9999\n12 9997\n2 13603\n5 9999\n1 9991\n8 9998\n4 15555\n6 10000\n3 13883\n7 10000\n4 9997\n20 10000\n1 15458\n7 10000\n2 10000\n11 9999\n6 10000\n2 19773\n3 5451\n11 9999\n",
            "output": "789615302\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 143\n3 94\n5 95\n2 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n1 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n7 98\n7 98\n4 96\n9 99\n6 97\n9 96\n7 118\n6 96\n",
            "output": "0\n"
        },
        {
            "input": "23 100\n10 98\n15 100\n4 94\n9 30\n4 96\n7 100\n5 24\n6 99\n1 95\n1 143\n3 94\n5 95\n2 101\n4 311\n1 97\n8 98\n9 100\n14 100\n6 86\n5 102\n1 97\n8 98\n12 101\n7 98\n10 99\n8 10\n10 100\n1 66\n1 96\n8 110\n1 93\n6 96\n9 100\n4 57\n7 133\n6 99\n11 99\n10 100\n9 100\n3 100\n9 99\n9 100\n1 98\n7 98\n4 96\n9 99\n6 97\n9 96\n7 118\n6 96\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, mod = 998244353;\nlong long f[55][N], l[N], r[N], sum[N], prim[N], nump, vis[N], mu[N];\nvoid init() {\n  mu[1] = 1;\n  for (int i = 2; i < N; i++) {\n    if (!vis[i]) {\n      prim[++nump] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= nump && i * prim[j] < N; j++) {\n      vis[i * prim[j]] = 1;\n      if (i % prim[j] == 0)\n        break;\n      else\n        mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nint main() {\n  long long n, m;\n  scanf(\"%lld%lld\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld%lld\", l + i, r + i);\n  long long ans = 0;\n  init();\n  for (int d = 1; d <= m; d++) {\n    f[0][0] = 1;\n    long long cnt = 0;\n    if (mu[d]) {\n      for (int i = 1; i <= n; i++) {\n        sum[0] = f[i - 1][0];\n        for (int j = 1; j <= m / d; j++)\n          sum[j] = (sum[j - 1] + f[i - 1][j]) % mod;\n        for (int j = (l[i] + d - 1) / d; j <= m / d; j++) {\n          if (j >= r[i] / d)\n            f[i][j] = sum[j - (l[i] + d - 1) / d] - sum[j - r[i] / d - 1];\n          else\n            f[i][j] = sum[j - (l[i] + d - 1) / d];\n          f[i][j] = f[i][j] % mod;\n        }\n      }\n      for (int j = 1; j <= m / d; j++) cnt = (cnt + f[n][j]) % mod;\n      ans += mu[d] * cnt;\n      ans = ans % mod;\n      ans += mod;\n      ans = ans % mod;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long sum[55][100005], f[55][100005], t[100005];\nint l[55], r[55];\nint add(int p, int x, int y) {\n  if (x < 0) return 0;\n  if (y < 0) return sum[p][x];\n  return sum[p][x] - sum[p][y];\n}\nlong long solve1(int n, int m) {\n  long long ans = 0;\n  for (int i = l[1]; i <= r[1]; i++) f[1][i] = 1;\n  for (int i = 1; i <= m; i++) sum[1][i] = (sum[1][i - 1] + f[1][i]) % mod;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      f[i][j] = add(i - 1, j - l[i], j - r[i] - 1);\n      sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod;\n    }\n  }\n  for (int i = 1; i <= m; i++) ans = (ans + f[n][i]) % mod;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) f[i][j] = sum[i][j] = 0;\n  return ans;\n}\nlong long solve2(int n, int m, int d) {\n  long long ans = 0;\n  for (int i = d; i <= m; i += d)\n    if (i >= l[1] && i <= r[1]) f[1][i] = 1;\n  for (int i = d; i <= m; i += d) sum[1][i] = f[1][i] + sum[1][i - d];\n  for (int i = 2; i <= n; i++) {\n    for (int j = d; j <= m; j += d) {\n      int R = j - l[i] - ((j - l[i]) % d + d) % d;\n      int L = j - r[i] - ((j - r[i]) % d + d) % d;\n      if ((j - r[i]) % d == 0) L -= d;\n      f[i][j] = add(i - 1, R, L);\n      sum[i][j] = (sum[i][j - d] + f[i][j]) % mod;\n    }\n  }\n  for (int i = d; i <= m; i += d) ans = (ans + f[n][i]) % mod;\n  for (int i = 1; i <= n; i++)\n    for (int j = d; j <= m; j += d) f[i][j] = sum[i][j] = 0;\n  return ans;\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &l[i], &r[i]);\n  long long ans = solve1(n, m);\n  for (int d = 2; d <= m / n; d++) {\n    ans = ((ans - (1 - t[d]) * solve2(n, m, d)) % mod + mod) % mod;\n    for (int j = 2; j * d <= m; j++) t[j * d] += 1 - t[d];\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace modular {\ntemplate <typename>\nstruct is_modular : std::false_type {};\ntemplate <int M>\nstruct static_mint {\n  static_assert(0 < M, \"Module must be positive\");\n  using mint = static_mint;\n  int val;\n  static_mint() : val() {}\n  static_mint(long long x) : val(x % M) {\n    if (val < 0) val += M;\n  }\n  mint pow(long long n) const {\n    mint ans = 1, x(*this);\n    while (n) {\n      if (n & 1) ans *= x;\n      x *= x;\n      n /= 2;\n    }\n    return ans;\n  }\n  mint inv() const { return pow(M - 2); }\n  friend mint pow(const mint& m, long long n) { return m.pow(n); }\n  friend mint inv(const mint& m) { return m.inv(); }\n  mint operator+() const {\n    mint m;\n    m.val = val;\n    return m;\n  }\n  mint operator-() const {\n    mint m;\n    m.val = M - val;\n    return m;\n  }\n  mint& operator+=(const mint& m) {\n    if ((val += m.val) >= M) val -= M;\n    return *this;\n  }\n  mint& operator-=(const mint& m) {\n    if ((val -= m.val) < 0) val += M;\n    return *this;\n  }\n  mint& operator*=(const mint& m) {\n    val = (long long)val * m.val % M;\n    return *this;\n  }\n  mint& operator/=(const mint& m) {\n    val = (long long)val * m.inv().val % M;\n    return *this;\n  }\n  friend mint operator+(const mint& lhs, const mint& rhs) {\n    return mint(lhs) += rhs;\n  }\n  friend mint operator-(const mint& lhs, const mint& rhs) {\n    return mint(lhs) -= rhs;\n  }\n  friend mint operator*(const mint& lhs, const mint& rhs) {\n    return mint(lhs) *= rhs;\n  }\n  friend mint operator/(const mint& lhs, const mint& rhs) {\n    return mint(lhs) /= rhs;\n  }\n  friend bool operator==(const mint& lhs, const mint& rhs) {\n    return lhs.val == rhs.val;\n  }\n  friend bool operator!=(const mint& lhs, const mint& rhs) {\n    return lhs.val != rhs.val;\n  }\n  mint& operator++() { return *this += 1; }\n  mint& operator--() { return *this -= 1; }\n  mint operator++(int) {\n    mint result(*this);\n    *this += 1;\n    return result;\n  }\n  mint operator--(int) {\n    mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  template <typename T>\n  explicit operator T() const {\n    return T(val);\n  }\n  friend std::ostream& operator<<(std::ostream& os, const mint& m) {\n    return os << m.val;\n  }\n  friend std::istream& operator>>(std::istream& is, mint& m) {\n    long long x;\n    is >> x;\n    m = x;\n    return is;\n  }\n};\ntemplate <int M>\nstruct is_modular<static_mint<M>> : std::true_type {};\ntemplate <int& _M>\nstruct dynamic_mint {\n  static constexpr int& M = _M;\n  using mint = dynamic_mint;\n  int val;\n  dynamic_mint() : val() {}\n  dynamic_mint(long long x) : val(x % M) {\n    if (val < 0) {\n      val += M;\n    }\n  }\n  mint pow(long long n) const {\n    mint ans = 1, x(*this);\n    while (n) {\n      if (n & 1) ans *= x;\n      x *= x;\n      n /= 2;\n    }\n    return ans;\n  }\n  mint inv() const { return pow(M - 2); }\n  friend mint pow(const mint& m, long long n) { return m.pow(n); }\n  friend mint inv(const mint& m) { return m.inv(); }\n  mint operator+() const {\n    mint m;\n    m.val = val;\n    return m;\n  }\n  mint operator-() const {\n    mint m;\n    m.val = M - val;\n    return m;\n  }\n  mint& operator+=(const mint& m) {\n    if ((val += m.val) >= M) val -= M;\n    return *this;\n  }\n  mint& operator-=(const mint& m) {\n    if ((val -= m.val) < 0) val += M;\n    return *this;\n  }\n  mint& operator*=(const mint& m) {\n    val = (long long)val * m.val % M;\n    return *this;\n  }\n  mint& operator/=(const mint& m) {\n    val = (long long)val * m.inv().val % M;\n    return *this;\n  }\n  friend mint operator+(const mint& lhs, const mint& rhs) {\n    return mint(lhs) += rhs;\n  }\n  friend mint operator-(const mint& lhs, const mint& rhs) {\n    return mint(lhs) -= rhs;\n  }\n  friend mint operator*(const mint& lhs, const mint& rhs) {\n    return mint(lhs) *= rhs;\n  }\n  friend mint operator/(const mint& lhs, const mint& rhs) {\n    return mint(lhs) /= rhs;\n  }\n  friend bool operator==(const mint& lhs, const mint& rhs) {\n    return lhs.val == rhs.val;\n  }\n  friend bool operator!=(const mint& lhs, const mint& rhs) {\n    return lhs.val != rhs.val;\n  }\n  mint& operator++() { return *this += 1; }\n  mint& operator--() { return *this -= 1; }\n  mint operator++(int) {\n    mint result(*this);\n    *this += 1;\n    return result;\n  }\n  mint operator--(int) {\n    mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  template <typename T>\n  explicit operator T() const {\n    return T(val);\n  }\n  friend std::ostream& operator<<(std::ostream& os, const mint& m) {\n    return os << m.val;\n  }\n  friend std::istream& operator>>(std::istream& is, mint& m) {\n    long long x;\n    is >> x;\n    m = x;\n    return is;\n  }\n};\n}  // namespace modular\nusing im = modular::static_mint<998244353>;\nim p[2][100001];\nim get(int i, int l, int r) {\n  if (r < 0) return im(0);\n  l = max(l, 0);\n  return p[i][r] - (l == 0 ? 0 : p[i][l - 1]);\n}\nvoid solution() {\n  int n, m;\n  cin >> n >> m;\n  vector<im> f(m + 1);\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  for (int d = 1; d <= m; d++) {\n    vector<int> L(n), R(n);\n    bool glitch = false;\n    for (int i = 0; i < n; i++) {\n      L[i] = (l[i] + d - 1) / d;\n      R[i] = r[i] / d;\n      if (R[i] < L[i]) glitch = true;\n    }\n    if (glitch) continue;\n    int bound = m / d;\n    for (int i = 0; i <= 1; i++)\n      for (int j = 0; j <= bound; j++) p[i][j] = 0;\n    p[0][0] = 1;\n    for (int i = 1; i <= bound; i++) p[0][i] = 1;\n    int cur = 0, nxt = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= bound; j++)\n        p[nxt][j] += get(cur, j - R[i], j - L[i]);\n      for (int j = 1; j <= bound; j++) p[nxt][j] += p[nxt][j - 1];\n      for (int j = 0; j <= bound; j++) p[cur][j] = 0;\n      swap(cur, nxt);\n    }\n    f[d] = p[cur][bound];\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) f[i] -= f[j];\n  }\n  cout << f[1];\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tc = 1;\n  while (tc--) {\n    solution();\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 3) + (x << 1) + (c ^ '0'), c = getchar();\n  return x * f;\n}\nconst long long mod = 998244353, N = 1e5 + 5;\nlong long p[N], chk[N], tot, mu[N];\nvoid init(long long n) {\n  mu[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    if (!chk[i]) p[++tot] = i, mu[i] = -1;\n    for (long long j = 1; j <= tot && p[j] * i <= n; j++) {\n      chk[i * p[j]] = 1;\n      if (!(i % p[j])) break;\n      mu[i * p[j]] = -mu[i];\n    }\n  }\n}\nlong long ans;\nlong long l[N], r[N], f[N], s[N];\nlong long n, m;\nsigned main() {\n  init(N - 5);\n  n = read(), m = read();\n  for (long long i = 1; i <= n; i++) l[i] = read(), r[i] = read();\n  for (long long d = 1; d <= m; d++) {\n    long long lim = m / d;\n    for (long long i = 1; i <= lim; i++) f[i] = 0;\n    f[0] = s[0] = 1;\n    for (long long j = 1; j <= lim; j++) s[j] = (s[j - 1] + f[j]) % mod;\n    for (long long i = 1; i <= n; i++) {\n      long long L = (l[i] - 1) / d + 1, R = r[i] / d;\n      for (long long j = 1; j <= lim; j++)\n        f[j] = ((j - L < 0ll ? 0ll : s[max(j - L, 0ll)]) -\n                (j - R - 1 < 0ll ? 0ll : s[max(j - R - 1, 0ll)])) %\n               mod;\n      f[0] = s[0] = 0;\n      for (long long j = 1; j <= lim; j++) s[j] = (s[j - 1] + f[j]) % mod;\n    }\n    ans += mu[d] * s[lim];\n    ans %= mod;\n  }\n  printf(\"%lld\\n\", (ans + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 1e3 + 7, P = 998244353;\nlong long n, m;\nlong long f[51][N], g[N], l[51], r[51];\nlong long get(long long i, long long j) { return j < 0 ? 0 : f[i][j]; }\nsigned main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld%lld\", &l[i], &r[i]);\n  for (long long d = m; d >= 1; d--) {\n    long long t = m / d;\n    for (long long j = 0; j <= t; j++) f[0][j] = 1;\n    for (long long j = 1; j <= n; j++) {\n      long long L = (l[j] + d - 1) / d, R = r[j] / d;\n      for (long long k = 0; k <= t; k++)\n        f[j][k] =\n            (f[j][k - 1] + get(j - 1, k - L) - get(j - 1, k - R - 1) + P) % P;\n    }\n    g[d] = f[n][t];\n    for (long long j = 2; j <= t; j++) g[d] = (g[d] - g[j * d] + P) % P;\n  }\n  printf(\"%lld\\n\", g[1]);\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\nfrom collections import Counter\n\ndef main():\n    \n    n,m=readIntArr()\n    l=[]\n    r=[]\n    for _ in range(n):\n        ll,rr=readIntArr()\n        l.append(ll)\n        r.append(rr)\n    \n    def countWays(mult): # count the number of ways that gcd is a multiple of mult\n        # compress everything by mult\n        m2=m//mult\n        cnts=[0]*(m2+1) # counts\n        cnts[0]=1\n        p=cnts.copy() # prefix sum\n        for i in range(1,m2+1):\n            p[i]+=p[i-1]\n        # print('m2:{} cnts:{} p:{}'.format(m2,cnts,p))\n        for i in range(n):\n            lower=(l[i]+mult-1)//mult\n            upper=r[i]//mult\n            if lower>upper: # cnts will be all 0\n                return 0\n            cnts2=[0]*(m2+1)\n            for summ in range(m2+1):\n                prevUpper=min(summ-lower,m2+1)\n                prevLower=max(0,summ-upper)\n                # print('summ:{} prevU:{} prevL:{}'.format(summ,prevUpper,prevLower))\n                if prevLower<=prevUpper:\n                    if prevLower==0:\n                        cnts2[summ]=p[prevUpper]\n                    else:\n                        cnts2[summ]=p[prevUpper]-p[prevLower-1]\n                    if cnts2[summ]<0:\n                        cnts2[summ]+=MOD # smart mod\n                    # cnts2[summ]=(cnts2[summ]+MOD)%MOD\n            p2=cnts2.copy()\n            for j in range(1,m2+1):\n                p2[j]+=p2[j-1]\n                if p2[j]>=MOD:\n                    p2[j]-=MOD # smart mod\n                # p2[j]%=MOD\n            cnts=cnts2\n            p=p2\n            # print('i:{} lower:{} upper:{} cnts:{} p:{}'.format(i,lower,upper,cnts,p))\n        return p2[m2]\n                    \n        \n    cnts=[-1]*(m+1) # cnts[gcd] = counts with gcd being gcd\n    for mult in range(m,0,-1):\n        nWays=countWays(mult)\n        for mult2 in range(mult*2,m+1,mult):\n            nWays-=cnts[mult2]\n            if nWays<0:\n                nWays+=MOD\n            # nWays=(nWays+MOD)%MOD\n        cnts[mult]=nWays\n    print(cnts[1])\n    \n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long inv(long long i) {\n  if (i == 1) return 1;\n  return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;\n}\nlong long mod_mul(long long a, long long b) {\n  a = a % mod;\n  b = b % mod;\n  return (((a * b) % mod) + mod) % mod;\n}\nlong long mod_add(long long a, long long b) {\n  a = a % mod;\n  b = b % mod;\n  return (((a + b) % mod) + mod) % mod;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long ceil_div(long long a, long long b) {\n  return a % b == 0 ? a / b : a / b + 1;\n}\nlong long pwr(long long a, long long b) {\n  a %= mod;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nlong long mx = 100000;\nvector<long long> mobius(1 + mx, 0);\nvector<bool> isprime(1 + mx, true);\nlong long n, m;\nvector<long long> l, r;\nvoid sieve() {\n  isprime[1] = false;\n  mobius[1] = 1;\n  vector<long long> primes;\n  long long i, j;\n  for (i = 2; i <= mx; i++) {\n    if (isprime[i]) {\n      primes.push_back(i);\n      mobius[i] = -1;\n    }\n    for (j = 0; j < primes.size() and i * primes[j] <= mx; j++) {\n      isprime[i * primes[j]] = false;\n      if (i % primes[j] == 0) {\n        mobius[i * primes[j]] = 0;\n        break;\n      } else {\n        mobius[i * primes[j]] = mobius[i] * mobius[primes[j]];\n      }\n    }\n  }\n}\nlong long solve(long long d) {\n  long long M;\n  M = m / d;\n  vector<long long> dp(M + 1, 0);\n  long long i, j;\n  vector<long long> psum(M + 1, 0);\n  dp[0] = 1;\n  for (i = 0; i <= M; i++) psum[i] = 1;\n  for (i = 1; i <= n; i++) {\n    long long left, right;\n    left = ceil_div(l[i], d);\n    right = r[i] / d;\n    if (left > right) return 0LL;\n    for (j = 0; j <= M; j++) {\n      dp[j] = ((j - left >= 0 ? psum[j - left] : 0LL) + mod -\n               (j - right > 0 ? psum[j - right - 1] : 0LL)) %\n              mod;\n    }\n    for (j = 0; j <= M; j++) {\n      psum[j] = (j == 0 ? dp[0] : mod_add(dp[j], psum[j - 1]));\n    }\n  }\n  long long ans = 0;\n  for (i = 1; i <= M; i++) {\n    ans = mod_add(ans, dp[i]);\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t, i, j, ans, temp, sum;\n  string sans;\n  t = 1;\n  sieve();\n  while (t--) {\n    sans = \"NO\";\n    ans = temp = sum = 0;\n    cin >> n >> m;\n    l.resize(n + 1);\n    r.resize(n + 1);\n    for (i = 1; i <= n; i++) {\n      cin >> l[i] >> r[i];\n    }\n    for (i = 1; i <= m; i++) {\n      ans = mod_add(ans, mobius[i] * solve(i));\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing int32 = int;\nusing int64 = long long;\nusing i3 = int32;\nusing i4 = int64;\nusing pi33 = std::pair<i3, i3>;\nusing pi34 = std::pair<i3, i4>;\nusing pi43 = std::pair<i4, i3>;\nusing pi44 = std::pair<i4, i4>;\nconst int B = 2;\nconst int N = 1000005;\nconst int P = 998244353;\nint n, m, d, x, y, z, D, M, c;\nint l[N], r[N], p[N], vis[N], e[N];\nint64 ans, sum;\nint64 dp[N][B];\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0), std::cout.tie(0);\n  std::cin >> n >> m;\n  for (int i = 2; i <= m; i++) {\n    if (!vis[i]) p[++p[0]] = i;\n    for (int j = 1; j <= p[0] && i * p[j] <= m; j++) {\n      vis[i * p[j]] = p[j];\n      if (i % p[j] == 0) break;\n    }\n  }\n  for (int i = 1; i <= n; ++i) std::cin >> l[i] >> r[i];\n  e[1] = 1;\n  for (int i = 1; i <= m; ++i) {\n    if (!vis[i]) {\n      e[i] = i == 1 ? 1 : -1;\n    } else {\n      if (!e[i / vis[i]] || i / vis[i] % vis[i] == 0) continue;\n      e[i] = -e[i / vis[i]];\n    }\n    M = m / i, x = i;\n    for (int i = 1; i <= n; ++i) M -= (l[i] - 1) / x;\n    for (int i = 0; i <= M; ++i) dp[i][c] = 0;\n    dp[0][c] = 1;\n    for (int i = 1; i <= n; ++i) {\n      D = r[i] / x - (l[i] - 1) / x;\n      for (int k = 1; k <= M; ++k) {\n        dp[k][c] = (dp[k - 1][c] + dp[k][c]) % P;\n      }\n      for (int k = 0; k <= M; ++k) {\n        dp[k][!c] = dp[k - 1][c];\n        if (k > D) dp[k][!c] -= dp[k - D - 1][c];\n      }\n      c ^= 1;\n    }\n    sum = 0;\n    for (int i = 0; i <= M; ++i) sum += dp[i][c];\n    ans += (sum * e[i] % P + P) % P;\n  }\n  std::cout << ans % P << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dy[] = {1, -1, 0, 0, -1, 1, 1, -1};\nint dx[] = {0, 0, 1, -1, 1, -1, 1, -1};\nvoid file() {}\nvoid fast() {\n  std::ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n}\nint main() {\n  file();\n  fast();\n  int n, m, mod = 998244353;\n  cin >> n >> m;\n  vector<pair<int, int> > v1(n);\n  for (auto& it : v1) cin >> it.first >> it.second;\n  auto get_div = [&](pair<int, int> p, int num) {\n    return p.second / num - ((p.first - 1) / num);\n  };\n  auto solve = [&](int g, int sum) -> int {\n    vector<pair<int, int> > tmp;\n    for (auto& it : v1) {\n      if (!get_div(it, g)) return 0;\n      pair<int, int> x;\n      x.first = (it.first - 1) / g + 1;\n      x.second = x.first + get_div(it, g) - 1;\n      tmp.push_back(x);\n    }\n    if (tmp.empty()) return 0;\n    vector<int> dp(sum + 1, 1);\n    for (auto& it : tmp) {\n      vector<int> cur(sum + 1);\n      for (int i = 1; i <= sum; i++) {\n        int r = max(-1, i - it.first);\n        int l = max(-1, i - it.second);\n        cur[i] = (r < 0 ? 0 : dp[r]) - (l <= 0 ? 0 : dp[l - 1]);\n        cur[i] = (cur[i] + mod) % mod;\n      }\n      for (int i = 1; i <= sum; i++) cur[i] = (cur[i] + cur[i - 1]) % mod;\n      dp = cur;\n    }\n    return dp[sum];\n  };\n  vector<int> arr(m + 1, 1);\n  for (int i = 1; i <= m; i++) arr[i] = solve(i, m / i);\n  for (int i = m; i >= 1; i--)\n    for (int j = i + i; j <= m; j += i) arr[i] = (arr[i] - arr[j] + mod) % mod;\n  cout << arr[1] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long INF = 0x3f3f3f3f;\nconst long long M = 1e5 + 5;\nconst long long mod = 998244353;\nlong long n, m, cnt, ans;\nlong long vis[M], prime[M], mu[M];\nlong long lc[M], rc[M], l[M], r[M], f[M], sum[M];\ninline void Init() {\n  mu[1] = 1;\n  for (long long i = 2; i < M; ++i) {\n    if (!vis[i]) prime[++cnt] = i, mu[i] = -1;\n    for (long long j = 1; j <= cnt && prime[j] * i < M; ++j) {\n      vis[prime[j] * i] = 1;\n      if (i % prime[j] == 0) {\n        mu[prime[j] * i] = 0;\n        break;\n      }\n      mu[prime[j] * i] = -mu[i];\n    }\n  }\n}\ninline long long Solve(long long m) {\n  for (long long i = 0; i <= m; ++i) f[i] = sum[i] = 0;\n  for (long long i = 1; i <= n; ++i) {\n    if (i == 1) {\n      for (long long j = lc[i]; j <= rc[i]; ++j) f[j] = 1;\n      for (long long j = 1; j <= m; ++j) sum[j] = sum[j - 1] + f[j];\n    } else {\n      for (long long j = 1; j <= m; ++j)\n        f[j] = (sum[std ::max(j - lc[i], 0ll)] -\n                sum[std ::max(j - rc[i] - 1, 0ll)] + mod) %\n               mod;\n      for (long long j = 1; j <= m; ++j) sum[j] = (sum[j - 1] + f[j]) % mod;\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= m; ++i) ans = (ans + f[i]) % mod;\n  return ans;\n}\ninline long long read() {\n  long long f = 1, s = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) (ch == '-') && (f = -1), ch = getchar();\n  while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n  return f * s;\n}\nsigned main() {\n  n = read(), m = read();\n  Init();\n  for (long long i = 1; i <= n; ++i) l[i] = read(), r[i] = read();\n  for (long long d = 1; d <= m; ++d) {\n    if (!mu[d]) continue;\n    long long mark = 0;\n    for (long long j = 1; j <= n; ++j)\n      lc[j] = std ::max((l[j] + d - 1) / d, 1ll), rc[j] = r[j] / d;\n    for (long long j = 1; j <= n; ++j)\n      if (lc[j] > rc[j]) {\n        mark = 1;\n        break;\n      }\n    if (mark) continue;\n    ans = (ans + mu[d] * Solve(m / d) % mod + mod) % mod;\n  }\n  std ::cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int N = 1e5;\nconst int M = 50;\nint num[N + 5];\nint mob[N + 5];\nvoid pre() {\n  mob[1] = 1;\n  for (int i = 2; i <= N; i++) {\n    if (num[i] == 0) {\n      for (int j = i; j <= N; j += i) {\n        mob[j]++;\n        num[j] = j;\n      }\n      long long x = i;\n      x = x * i;\n      for (long long j = x; j <= N; j += x) mob[j] = -N;\n    }\n    if (mob[i] < 0)\n      mob[i] = 0;\n    else if (mob[i] % 2)\n      mob[i] = -1;\n    else\n      mob[i] = 1;\n  }\n}\nlong long dp[M + 1][N + 1];\nlong long ssum[N + 5];\nint l[M + 1], r[M + 1];\nint nr[M + 1];\ninline long long get(int l, int r) {\n  if (l < 0) l = 0;\n  return (ssum[l] - ssum[r + 1] + MOD) % MOD;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  pre();\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  long long res = 0;\n  for (int i = 1; i <= m; i++) {\n    int sisa = m / i;\n    bool bisa = true;\n    for (int j = 1; j <= n; j++) {\n      int nl = l[j] / i;\n      if (nl * i < l[j]) nl++;\n      nr[j] = r[j] / i;\n      if (nr[j] * i < l[j] || nl * i > r[j] || nl > nr[j]) bisa = false;\n      sisa -= nl;\n      nr[j] -= nl;\n    }\n    if (mob[i] == 0 || !bisa || sisa < 0) continue;\n    for (int j = 0; j <= max(sisa, nr[j]) + 1; j++) ssum[j] = 0;\n    for (int j = min(sisa, nr[1]); j >= 0; j--) {\n      dp[1][j] = 1;\n      ssum[j] = (ssum[j + 1] + dp[1][j]) % MOD;\n    }\n    for (int j = 2; j <= n; j++) {\n      for (int k = sisa; k >= 0; k--) {\n        dp[j][k] = get(k - nr[j], k);\n      }\n      for (int k = sisa; k >= 0; k--) {\n        ssum[k] = (ssum[k + 1] + dp[j][k]) % MOD;\n      }\n    }\n    res = (res + MOD + mob[i] * ssum[0]) % MOD;\n  }\n  cout << res << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int mod = 998244353;\ninline int add(int x, int y) { return (x + y >= mod ? x + y - mod : x + y); }\ninline int sub(int x, int y) { return (x - y < 0 ? x - y + mod : x - y); }\ninline int gun(int x, int y) { return ((x * 1ll * y) % mod); }\nint n, m;\npair<int, int> a[55];\nint g[N];\nint dp[N][55];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  for (int now = 1; now <= m; now++) {\n    int sum = m / now;\n    for (int idx = n; idx >= 0; idx--) {\n      int l = (a[idx].first + now - 1) / now;\n      int r = a[idx].second / now;\n      for (int cur = 0; cur <= sum; cur++) {\n        if (idx == n) {\n          dp[cur][idx] = 1;\n          continue;\n        }\n        int ans = 0;\n        if (l <= r && cur + l <= sum) {\n          int ses = min(cur + r, sum);\n          ans = dp[ses][idx + 1];\n          if (cur + l - 1 >= 0) ans = sub(ans, dp[cur + l - 1][idx + 1]);\n        }\n        dp[cur][idx] = ans;\n      }\n      for (int cur = 1; cur <= sum; cur++) {\n        dp[cur][idx] = add(dp[cur][idx], dp[cur - 1][idx]);\n      }\n    }\n    g[now] = dp[0][0];\n    ;\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = 1; j * j <= i; j++) {\n      if (i % j == 0) {\n        if (j != i) g[j] = sub(g[j], g[i]);\n        int arek = i / j;\n        if (arek != i && arek != j) g[arek] = sub(g[arek], g[i]);\n      }\n    }\n  }\n  cout << g[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tFastScanner f= new FastScanner(); \n\t\tint ttt=1;\n//\t\tttt=f.nextInt();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tfor(int tt=0;tt<ttt;tt++) {\n\t        int N = f.nextInt();\n\t        int M = f.nextInt();\n\t        int MOD=998244353;\n\t        int[] left = new int[N];\n\t        int[] right = new int[N];\n\t        for(int i=0; i < N; i++)\n\t        {\n\t            left[i] = f.nextInt();\n\t            right[i] =f.nextInt();\n\t        }\n\t        long[] ways = new long[M+1];\n\t        outer:for(int v=1; v <= M; v++)\n\t        {\n\t            int CAP = M/v;\n\t            long[] dp = new long[CAP+1];\n\t            dp[0] = 1L;\n\t            for(int t=0; t < N; t++)\n\t            {\n\t                int min = Integer.MAX_VALUE;\n\t                int max = 0;\n\t                for(int i=v; i <= right[t]; i+=v)\n\t                    if(i >= left[t])\n\t                    {\n\t                        min = Math.min(min, i/v);\n\t                        max = i/v;\n\t                    }\n\t                if(min == Integer.MAX_VALUE)\n\t                    continue outer;\n\t                long[] psums = new long[CAP+1];\n\t                psums[0] = dp[0];\n\t                for(int i=1; i <= CAP; i++)\n\t                {\n\t                    psums[i] = psums[i-1]+dp[i];\n\t                    if(psums[i] >= MOD)\n\t                        psums[i] -= MOD;\n\t                }\n\t                long[] next = new long[CAP+1];\n\t                for(int i=min; i <= CAP; i++)\n\t                {\n\t                    int r = i-min;\n\t                    int l = Math.max(0, i-max);\n\t                    next[i] = psums[r];\n\t                    if(l > 0)\n\t                        next[i] -= psums[l-1];\n\t                    if(next[i] < 0)\n\t                        next[i] += MOD;\n\t                }\n\t                dp = next;\n\t            }\n\t            for(long x: dp)\n\t            {\n\t                ways[v] += x;\n\t                if(ways[v] >= MOD)\n\t                    ways[v] -= MOD;\n\t            }\n\t        }\n\t        for(int d=M; d >= 1; d--)\n\t            for(int v=d+d; v <= M; v+=d)\n\t            {\n\t                ways[d] -= ways[v];\n\t                if(ways[d] < 0)\n\t                    ways[d] += MOD;\n\t            }\n\t        System.out.println(ways[1]%MOD);\n\t\t}\n\t\tout.close();\n\t} \n\t\n\tstatic void sort(int[] p) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: p) q.add( i);\n        Collections.sort(q);\n        for (int i = 0; i < p.length; i++) p[i] = q.get(i);\n    }\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tlong[] readLongArray(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint l[55], r[55];\nlong long pie[100100];\nlong long dp[55][100100];\nbool prime[100100];\nlong long mobius[100100], nummults[100100];\nvector<long long> factors[100100];\nvoid comp() {\n  for (int i = 1; i < 100100; i++) nummults[i] = 0, mobius[i] = 6969;\n  for (int i = 1; i < 100100; i++)\n    for (int j = i; j < 100100; j += i) factors[j].push_back(i);\n  memset(prime, true, sizeof(prime));\n  for (int i = 2; i < 100100; i++) {\n    if (!prime[i]) continue;\n    for (int j = i * 2; j < 100100; j += i) prime[j] = false;\n  }\n  mobius[1] = 1;\n  mobius[2] = -1;\n  for (int i = 3; i < 100100; i++) {\n    if (prime[i]) {\n      mobius[i] = -1;\n      continue;\n    }\n    for (int j : factors[i]) {\n      if (j == 1 || j == i) continue;\n      if (!prime[j]) continue;\n      int c = i / j;\n      if (c % j == 0)\n        mobius[i] = 0;\n      else\n        mobius[i] = mobius[c] * mobius[j];\n      break;\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &l[i], &r[i]);\n  for (int p = 1; p <= m; p++) {\n    int bound = (m / p);\n    for (int i = 0; i <= bound; i++) {\n      long long cv = i * p;\n      if (cv >= l[0] && cv <= r[0])\n        dp[0][i] = 1;\n      else\n        dp[0][i] = 0;\n    }\n    for (int j = 1; j < n; j++) {\n      long long slide = 0;\n      long long lv = l[j] / p;\n      if (l[j] % p) lv++;\n      int rv = r[j] / p;\n      for (int i = 0; i <= bound; i++) {\n        if (i - lv >= 0) slide += dp[j - 1][i - lv];\n        if (i - rv > 0) slide -= dp[j - 1][i - rv - 1];\n        slide += 998244353;\n        slide %= 998244353;\n        dp[j][i] = slide;\n      }\n    }\n    pie[p] = 0;\n    for (int i = 0; i <= bound; i++) pie[p] += dp[n - 1][i];\n    pie[p] %= 998244353;\n  }\n  comp();\n  long long ans = 0;\n  for (int i = 1; i <= m; i++) {\n    ans += mobius[i] * pie[i];\n    ans += 998244353;\n    ans %= 998244353;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7, mod = 998244353;\nint n, m, mx, mn, l[N], r[N], f[N], g[N], a[N], i, j, k;\nint main() {\n  for (scanf(\"%d%d\", &n, &m), i = 1; i <= n; ++i) scanf(\"%d%d\", l + i, r + i);\n  for (k = 1; k <= m; ++k) {\n    for (mx = m / k, f[0] = 1, i = 0; i <= mx; ++i) g[i] = 1;\n    for (i = 1; i <= n; ++i) {\n      for (j = mn = (l[i] - 1) / k + 1; j <= mx; ++j) {\n        f[j] = g[j - mn];\n        if (j >= r[i] / k + 1)\n          f[j] = ((f[j] - g[j - r[i] / k - 1]) % mod + mod) % mod;\n      }\n      for (j = 0; j < mn; ++j) g[j] = 0;\n      for (j = mn; j <= mx; ++j) g[j] = (g[j - 1] + f[j]) % mod;\n    }\n    a[k] = g[mx];\n  }\n  for (i = m; i; --i)\n    for (j = i * 2; j <= m; j += i) a[i] = ((a[i] - a[j]) % mod + mod) % mod;\n  return 0 * printf(\"%d\\n\", a[1]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 998244353;\nstruct modint {\n  int val;\n  inline void check() {\n    val >= mod ? val %= mod : true;\n    val < 0 ? (val %= mod) += mod : true;\n    return;\n  }\n  modint(int v = 0) : val(v) { check(); }\n  inline modint &operator=(int v) { return val = v, *this; }\n  inline modint &operator+=(modint rhs) {\n    return val = val + rhs.val > mod ? val + rhs.val - mod : val + rhs.val,\n           *this;\n  }\n  inline modint &operator-=(modint rhs) {\n    return val = val - rhs.val < 0 ? val - rhs.val + mod : val - rhs.val, *this;\n  }\n  inline modint &operator*=(modint rhs) {\n    return val = 1ll * val * rhs.val % mod, *this;\n  }\n  inline friend modint operator+(const modint &lhs, const modint &rhs) {\n    return modint(lhs) += rhs;\n  }\n  inline friend modint operator-(const modint &lhs, const modint &rhs) {\n    return modint(lhs) -= rhs;\n  }\n  inline friend modint operator*(const modint &lhs, const modint &rhs) {\n    return modint(lhs) *= rhs;\n  }\n  inline friend bool operator==(const modint &lhs, const modint &rhs) {\n    return lhs.val == rhs.val;\n  }\n  inline friend bool operator!=(const modint &lhs, const modint &rhs) {\n    return lhs.val != rhs.val;\n  }\n  inline friend bool operator>(const modint &lhs, const modint &rhs) {\n    return lhs.val > rhs.val;\n  }\n  inline friend bool operator<(const modint &lhs, const modint &rhs) {\n    return lhs.val < rhs.val;\n  }\n  inline friend bool operator>=(const modint &lhs, const modint &rhs) {\n    return lhs.val >= rhs.val;\n  }\n  inline friend bool operator<=(const modint &lhs, const modint &rhs) {\n    return lhs.val <= rhs.val;\n  }\n  inline modint &operator++() {\n    ++val;\n    if (val == mod) val = 0;\n    return *this;\n  }\n  inline modint &operator--() {\n    if (val == 0) val = mod;\n    --val;\n    return *this;\n  }\n  inline modint operator++(int) {\n    modint ret = *this;\n    ++*this;\n    return ret;\n  }\n  inline modint operator--(int) {\n    modint ret = *this;\n    --*this;\n    return ret;\n  }\n  inline modint operator+() const { return *this; }\n  inline modint operator-() const { return modint() - *this; }\n};\nnamespace fastIO {\nconst int maxc = 1 << 23;\nchar ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;\ninline char getchar() {\n  return __p1 == __p2 && (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin),\n                          __p1 == __p2)\n             ? EOF\n             : *__p1++;\n}\ntemplate <typename T>\nvoid read(T &n) {\n  int x = 0;\n  n = 0;\n  char c = getchar();\n  while (!isdigit(c)) x |= (c == '-'), c = getchar();\n  while (isdigit(c)) n = n * 10 + c - '0', c = getchar();\n  n = x ? -n : n;\n}\nchar obuf[maxc], *__pO = obuf;\ninline void putchar(char c) { *__pO++ = c; }\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0)\n    putchar('-'), print(-x);\n  else {\n    if (x > 9) print(x / 10);\n    putchar(x % 10 + '0');\n  }\n  return;\n}\nvoid print(modint x) { print(x.val); }\nvoid output() { fwrite(obuf, __pO - obuf, 1, stdout); }\n}  // namespace fastIO\nusing namespace fastIO;\nconst int maxn = 55, maxm = 1e5 + 5;\nint n, m, L[maxn], R[maxn], l[maxn], r[maxn];\nint p[maxm], vis[maxm], mu[maxm], cntp;\nmodint f[maxm], sum[maxm];\nvoid init() {\n  static const int N = 1e5;\n  mu[1] = 1;\n  for (int i = (2); i <= (N); ++i) {\n    if (!vis[i]) p[++cntp] = i, mu[i] = -1;\n    for (int j = 1; j <= cntp && i * p[j] <= N; ++j) {\n      vis[i * p[j]] = 1;\n      if (i % p[j] == 0) {\n        mu[i * p[j]] = 0;\n        break;\n      }\n      mu[i * p[j]] = -mu[i];\n    }\n  }\n  return;\n}\nint main() {\n  init();\n  read(n), read(m);\n  for (int i = (1); i <= (n); ++i) read(L[i]), read(R[i]);\n  modint ans = 0;\n  for (int d = (1); d <= (m); ++d) {\n    if (mu[d] == 0) continue;\n    for (int j = (0); j <= (m / d); ++j) sum[j] = 1;\n    for (int i = (1); i <= (n); ++i) {\n      l[i] = (L[i] + d - 1) / d, r[i] = R[i] / d;\n      for (int j = (1); j <= (m / d); ++j) f[j] = 0;\n      for (int j = (l[i]); j <= (m / d); ++j) {\n        f[j] = sum[j - l[i]];\n        if (j - r[i] - 1 >= 0) f[j] -= sum[j - r[i] - 1];\n      }\n      sum[0] = 0;\n      for (int j = (1); j <= (m / d); ++j) sum[j] = f[j] + sum[j - 1];\n    }\n    ans += sum[m / d] * mu[d];\n  }\n  print(ans);\n  return output(), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e1 + 10, MOD = 998244353;\nconst int MAXM = 1e5 + 10;\ntemplate <int MOD_>\nstruct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\n private:\n  using long long = long long;\n  int v;\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - long long(minv(m, a)) * long long(m) / a);\n  }\n\n public:\n  modnum() : v(0) {}\n  modnum(long long v_) : v(int(v_ % MOD)) {\n    if (v < 0) v += MOD;\n  }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator<<(std::ostream& out, const modnum& n) {\n    return out << int(n);\n  }\n  friend std::istream& operator>>(std::istream& in, modnum& n) {\n    long long v_;\n    in >> v_;\n    n = modnum(v_);\n    return in;\n  }\n  friend bool operator==(const modnum& a, const modnum& b) {\n    return a.v == b.v;\n  }\n  friend bool operator!=(const modnum& a, const modnum& b) {\n    return a.v != b.v;\n  }\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD - v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator-() const { return neg(); }\n  modnum operator+() const { return modnum(*this); }\n  modnum& operator++() {\n    v++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator--() {\n    if (v == 0) v = MOD;\n    v--;\n    return *this;\n  }\n  modnum& operator+=(const modnum& o) {\n    v -= MOD - o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator*=(const modnum& o) {\n    v = int(long long(v) * long long(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator/=(const modnum& o) { return *this *= o.inv(); }\n  friend modnum operator++(modnum& a, int) {\n    modnum r = a;\n    ++a;\n    return r;\n  }\n  friend modnum operator--(modnum& a, int) {\n    modnum r = a;\n    --a;\n    return r;\n  }\n  friend modnum operator+(const modnum& a, const modnum& b) {\n    return modnum(a) += b;\n  }\n  friend modnum operator-(const modnum& a, const modnum& b) {\n    return modnum(a) -= b;\n  }\n  friend modnum operator*(const modnum& a, const modnum& b) {\n    return modnum(a) *= b;\n  }\n  friend modnum operator/(const modnum& a, const modnum& b) {\n    return modnum(a) /= b;\n  }\n};\nusing num = modnum<MOD>;\nconst int MAXV = 2e6 + 10;\nint pf[MAXV];\nvoid prep() {\n  memset(pf, -1, sizeof(pf));\n  for (int i = 2; i < MAXV; i++)\n    if (pf[i] == -1) {\n      for (int j = i; j < MAXV; j += i) pf[j] = i;\n    }\n}\nint get_mul(int c) {\n  int ans = 0;\n  while (c > 1) {\n    int p = pf[c];\n    c /= p;\n    if (c % p == 0) return 0;\n    ans ^= 1;\n  }\n  return (ans == 0 ? 1 : -1);\n}\nint n, m;\narray<int, 2> a[MAXN], b[MAXN];\nnum get(int d) {\n  int bound = m / d;\n  for (int i = 0; i < n; i++) {\n    b[i][0] = (a[i][0] + d - 1) / d;\n    b[i][1] = a[i][1] / d;\n  }\n  vector<num> pre(bound + 1, 1), cur(bound + 1);\n  for (int rep = 0; rep < n; rep++) {\n    int l = b[rep][0], r = b[rep][1];\n    auto get = [&](int i) -> num { return i >= 0 ? pre[i] : 0; };\n    for (int i = 0; i <= bound; i++) {\n      cur[i] = get(i - l) - get(i - r - 1);\n    }\n    for (int i = 0; i <= bound; i++) {\n      pre[i] = cur[i], cur[i] = 0;\n      if (i) pre[i] += pre[i - 1];\n    }\n  }\n  return pre[bound];\n}\nvoid solve() {\n  prep();\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> a[i][0] >> a[i][1];\n  num ans = 0;\n  for (int d = 1; d <= m; d++) {\n    int mul = get_mul(d);\n    ans += get(d) * mul;\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\nfrom collections import Counter\n\ndef main():\n    \n    n,m=readIntArr()\n    l=[]\n    r=[]\n    for _ in range(n):\n        ll,rr=readIntArr()\n        l.append(ll)\n        r.append(rr)\n    \n    def countWays(mult): # count the number of ways that gcd is a multiple of mult\n        # compress everything by mult\n        m2=m//mult\n        cnts=[0]*(m2+1) # counts\n        cnts[0]=1\n        p=cnts.copy() # prefix sum\n        for i in range(1,m2+1):\n            p[i]+=p[i-1]\n        # print('m2:{} cnts:{} p:{}'.format(m2,cnts,p))\n        for i in range(n):\n            lower=(l[i]+mult-1)//mult\n            upper=r[i]//mult\n            if lower>upper: # cnts will be all 0\n                return 0\n            cnts2=[0]*(m2+1)\n            for summ in range(m2+1):\n                prevUpper=min(summ-lower,m2+1)\n                prevLower=max(0,summ-upper)\n                # print('summ:{} prevU:{} prevL:{}'.format(summ,prevUpper,prevLower))\n                if prevLower<=prevUpper:\n                    if prevLower==0:\n                        cnts2[summ]=p[prevUpper]\n                    else:\n                        cnts2[summ]=p[prevUpper]-p[prevLower-1]\n                    cnts2[summ]=(cnts2[summ]+MOD)%MOD\n            p2=cnts2.copy()\n            for j in range(1,m2+1):\n                p2[j]+=p2[j-1]\n                p2[j]%=MOD\n            cnts=cnts2\n            p=p2\n            # print('i:{} lower:{} upper:{} cnts:{} p:{}'.format(i,lower,upper,cnts,p))\n        return p2[m2]\n                    \n        \n    cnts=[-1]*(m+1) # cnts[gcd] = counts with gcd being gcd\n    for mult in range(m,0,-1):\n        nWays=countWays(mult)\n        for mult2 in range(mult*2,m+1,mult):\n            nWays-=cnts[mult2]\n            nWays=(nWays+MOD)%MOD\n        cnts[mult]=nWays\n    print(cnts[1])\n    \n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\nMOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 3,
            "solution": "# O(n*m*log(m))\nimport sys\ninput = sys.stdin.buffer.readline\n\nmod = 998244353\n\nn,m = map(int,input().split())\n\n# sieve\nprimes = [0]*(m+1)\nprime = [1]*(m+1)\n\nfor i in range(2,m+1):\n    if prime[i]:\n        for j in range(2*i,m+1,i):\n            prime[j] = 0\n            primes[j] += 1\n\nfor i in range(2,m+1):\n    if prime[i]:\n        for j in range(i*i,m+1,i*i):\n            primes[j] = -1\n\nranges = [list(map(int,input().split())) for i in range(n)]\nways_gcd = [0]*(m+1)\n\nfor gcd in range(1,m+1):\n    converted_ranges = [[(ranges[i][0]+gcd-1)//gcd,ranges[i][1]//gcd] for i in range(n)]\n    dp1 = [0]*(m//gcd + 1)\n    dp1[0] = 1\n    dp2 = [0]*(m//gcd + 1)\n\n    for i in range(n):\n        if converted_ranges[i][0] > converted_ranges[i][1]:\n            dp1,dp2 = dp2,dp1\n            break\n\n        l,r = converted_ranges[i]\n        for j in range(len(dp2)-l):\n            dp2[j+l] = (dp2[j+l] + dp1[j]) % mod\n            if j+r+1 < len(dp2):\n                dp2[j+r+1] = (dp2[j+r+1] - dp1[j] + mod) % mod\n\n        for i in range(1,len(dp2)):\n            dp2[i] = (dp2[i] + dp2[i-1]) % mod\n\n        dp1,dp2 = dp2,dp1\n        dp2 = [0]*len(dp2)\n\n    ways_gcd[gcd] = sum(dp1) % mod\n\n\nans = ways_gcd[1]\n\nfor i in range(2,m+1):\n    if primes[i] >= 2 or prime[i]:\n        if prime[i] or primes[i]&1:\n            ans = (ans - ways_gcd[i] + mod) % mod\n        else:\n            ans = (ans + ways_gcd[i]) % mod\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long M = 998244353;\nvector<int> mu((int)1e5 + 1, 0);\nvector<int> primes;\nvector<int> isprime((int)1e5 + 1, 1);\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  mu[1] = 1;\n  for (int i = 2; i < mu.size(); i++) {\n    if (isprime[i]) {\n      mu[i] = -1;\n      primes.push_back(i);\n    }\n    for (auto j : primes) {\n      if (j * i >= mu.size()) break;\n      isprime[i * j] = 0;\n      if (i % j != 0)\n        mu[i * j] = mu[i] * mu[j];\n      else {\n        mu[i * j] = 0;\n        break;\n      }\n    }\n  }\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<int, int>> v(n + 1);\n  long long cmax = 1e9;\n  for (int i = 1; i < n + 1; i++) {\n    cin >> v[i].first >> v[i].second;\n    cmax = min(cmax, (long long)v[i].second);\n  }\n  long long ans = 0;\n  for (int d = 1; d < cmax + 1; d++) {\n    long long mm = m / d;\n    long long dp[n + 1][mm + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int j = 1; j < mm + 1; j++) dp[0][j] = 1;\n    for (int i = 1; i < n + 1; i++) {\n      long long l = (v[i].first + d - 1) / d;\n      long long r = (v[i].second) / d;\n      for (int j = 1; j < mm + 1; j++) {\n        if (j - r - 1 >= 0) dp[i][j] -= dp[i - 1][j - r - 1];\n        if (j - l >= 0) dp[i][j] += dp[i - 1][j - l];\n        if (j > 1) dp[i][j] += dp[i][j - 1];\n        if (dp[i][j] < 0) {\n          dp[i][j] += M;\n          assert(dp[i][j] > 0);\n        }\n        dp[i][j] %= M;\n      }\n    }\n    ans += ((long long)mu[d] * dp[n][mm]) % M;\n    ans %= M;\n  }\n  if (ans < 0) ans += M;\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "//make sure to make new file!\nimport java.io.*;\nimport java.util.*;\n\npublic class E738{\n\n   public static long MOD = 998244353L;\n   \n   public static void main(String[] args)throws IOException{\n      BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter out = new PrintWriter(System.out);\n      \n      StringTokenizer st = new StringTokenizer(f.readLine());\n      \n      int n = Integer.parseInt(st.nextToken());\n      int m = Integer.parseInt(st.nextToken());\n      \n      int[] l = new int[n];\n      int[] r = new int[n];\n      \n      for(int k = 0; k < n; k++){\n         st = new StringTokenizer(f.readLine());\n      \n         int a = Integer.parseInt(st.nextToken());\n         int b = Integer.parseInt(st.nextToken());\n         \n         l[k] = a;\n         r[k] = b;\n      }\n      \n      //sieve\n      boolean[] isprime = new boolean[m+1];\n      Arrays.fill(isprime,true);\n      for(int k = 2; k <= m; k++){\n         if(!isprime[k]) \n            continue;\n         for(int j = 2*k; j <= m; j += k){\n            isprime[j] = false;\n         }\n      }\n      \n      ArrayList<Integer> primes = new ArrayList<Integer>();\n      for(int k = 2; k <= m; k++){\n         if(isprime[k]) primes.add(k);\n      }\n      \n      int[] primepar = new int[m+1];\n      for(int k = 2; k <= m; k++){\n         if(isprime[k]){\n            primepar[k] = 1;\n            if(k < 1000){                                         //prevent int overflow\n               for(int j = k*k; j <= m; j+=(k*k)){\n                  primepar[j] = -1;\n               }\n            }\n            for(int j = k*2; j <= m; j+=k){\n               if(primepar[j] != -1) primepar[j]++;\n            }\n         }\n      }\n      \n      long answer = 0L;\n      for(int k = 1; k <= m; k++){\n         if(primepar[k] == -1) \n            continue;\n         \n         int[] curl = new int[n];\n         int[] curr = new int[n];\n         \n         //divide everything\n         int curm = m/k;                  //m is floor\n         \n         for(int j = 0; j < n; j++){\n            curl[j] = (l[j]+k-1)/k;       //left is ceiling\n            curr[j] = r[j]/k;             //right is floor\n         }\n      \n         //dp\n         long[][] dp = new long[n][curm+1];            //dp[k][j] = # of ways to get the sum of j with first k stars\n         \n         long[] psums = new long[curm+2];\n         \n         //do n = 1\n         for(int j = curl[0]; j <= curr[0]; j++){\n            dp[0][j] = 1L;\n         }\n         for(int j = 1; j <= curm+1; j++){\n            psums[j] = psums[j-1] + dp[0][j-1];\n         }\n         \n         for(int j = 1; j < n; j++){\n            for(int h = 1; h <= curm; h++){\n               dp[j][h] = (psums[Math.max(0,h-curl[j] +1)] - psums[Math.max(0,h-curr[j])] + MOD)%MOD;\n            }\n            \n            //update prefix sums\n            for(int h = 1; h <= curm+1; h++){\n               psums[h] = (psums[h-1] + dp[j][h-1] + MOD)%MOD;\n            }\n         }\n         \n         long cursum = 0L;\n         for(int j = 1; j <= curm; j++){\n            cursum = (cursum + dp[n-1][j] + MOD)%MOD;\n         }\n         \n         if(primepar[k] % 2 == 0){\n            answer = (answer + cursum + MOD)%MOD;\n         } else {\n            answer = (answer - cursum + MOD)%MOD;\n         }\n         \n      }\n      \n      out.println(answer);\n      \n      \n      \n      \n      \n      out.close();\n   }\n   \n      \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long l[55], r[55];\nlong long ans[100005];\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  for (long long x = m / n; x >= 1; x--) {\n    long long sz = m / x;\n    vector<long long> dp(sz + 1);\n    dp[0] = 1;\n    for (long long i = 1; i <= n; i++) {\n      vector<long long> ndp(sz + 1);\n      long long mini = 1e9, maxi = 0;\n      for (long long num = 1; num * x <= r[i]; num++) {\n        if (num * x < l[i]) continue;\n        mini = min(mini, num);\n        maxi = max(maxi, num);\n      }\n      for (long long j = 1; j <= sz; j++) {\n        dp[j] = (dp[j] + dp[j - 1]) % mod;\n      }\n      for (long long j = 0; j <= sz; j++) {\n        long long lower = j - maxi, upper = j - mini;\n        if (upper < 0) continue;\n        if (lower <= 0) {\n          ndp[j] = (dp[upper]) % mod;\n          continue;\n        }\n        ndp[j] = (dp[upper] - dp[lower - 1] + mod) % mod;\n      }\n      dp = ndp;\n    }\n    for (auto u : dp) ans[x] = (ans[x] + u);\n    for (long long num = 2 * x; num <= m; num += x) {\n      ans[x] = (ans[x] - ans[num] + mod) % mod;\n    }\n  }\n  cout << ans[1];\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT mod_inv_in_range(T a, T m) {\n  T x = a, y = m;\n  T vx = 1, vy = 0;\n  while (x) {\n    T k = y / x;\n    y %= x;\n    vy -= k * vx;\n    std::swap(x, y);\n    std::swap(vx, vy);\n  }\n  assert(y == 1);\n  return vy < 0 ? m + vy : vy;\n}\ntemplate <typename T>\nT mod_inv(T a, T m) {\n  a %= m;\n  a = a < 0 ? a + m : a;\n  return mod_inv_in_range(a, m);\n}\ntemplate <int MOD_>\nstruct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\n private:\n  using ll = long long;\n  int v;\n\n public:\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) {\n    if (v < 0) v += MOD;\n  }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator<<(std::ostream& out, const modnum& n) {\n    return out << int(n);\n  }\n  friend std::istream& operator>>(std::istream& in, modnum& n) {\n    ll v_;\n    in >> v_;\n    n = modnum(v_);\n    return in;\n  }\n  friend bool operator==(const modnum& a, const modnum& b) {\n    return a.v == b.v;\n  }\n  friend bool operator!=(const modnum& a, const modnum& b) {\n    return a.v != b.v;\n  }\n  modnum inv() const {\n    modnum res;\n    res.v = mod_inv_in_range(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD - v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator-() const { return neg(); }\n  modnum operator+() const { return modnum(*this); }\n  modnum& operator++() {\n    v++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator--() {\n    if (v == 0) v = MOD;\n    v--;\n    return *this;\n  }\n  modnum& operator+=(const modnum& o) {\n    v -= MOD - o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    v = (v < 0) ? v + MOD : v;\n    return *this;\n  }\n  modnum& operator*=(const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator/=(const modnum& o) { return *this *= o.inv(); }\n  friend modnum operator++(modnum& a, int) {\n    modnum r = a;\n    ++a;\n    return r;\n  }\n  friend modnum operator--(modnum& a, int) {\n    modnum r = a;\n    --a;\n    return r;\n  }\n  friend modnum operator+(const modnum& a, const modnum& b) {\n    return modnum(a) += b;\n  }\n  friend modnum operator-(const modnum& a, const modnum& b) {\n    return modnum(a) -= b;\n  }\n  friend modnum operator*(const modnum& a, const modnum& b) {\n    return modnum(a) *= b;\n  }\n  friend modnum operator/(const modnum& a, const modnum& b) {\n    return modnum(a) /= b;\n  }\n};\ntemplate <typename T>\nT pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1;\n  while (b) {\n    if (b & 1) r *= a;\n    b >>= 1;\n    a *= a;\n  }\n  return r;\n}\nconst int MOD = 998244353;\nusing mint = modnum<MOD>;\nconst int N = 1e5 + 5;\nint n, m, l[N], r[N];\nmint f[N], dp[N], pre[N];\nint main() {\n  cin.tie(0)->sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n  for (int g = m; g >= 1; --g) {\n    int T = m / g;\n    for (int i = 0; i <= T; ++i) dp[i] = 0;\n    dp[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      pre[0] = dp[0];\n      for (int j = 1; j <= T; ++j) {\n        pre[j] = (pre[j - 1] + dp[j]);\n      }\n      for (int i = 0; i <= T; ++i) dp[i] = 0;\n      int lef = (l[i] + g - 1) / g;\n      int rig = r[i] / g;\n      if (lef <= rig) {\n        for (int j = 1; j <= T; ++j) {\n          int y = j - lef, x = max(j - rig, 0);\n          if (x <= y) {\n            dp[j] = pre[y] - (x == 0 ? 0 : pre[x - 1]);\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= T; ++i) {\n      f[g] = (f[g] + dp[i]);\n    }\n    for (int k = g * 2; k <= m; k += g) {\n      f[g] = f[g] - f[k];\n    }\n  }\n  cout << f[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[55], r[55], cnt;\nint g[100500], f[100500][55], pre[100500][55];\nint su(int a, int b) {\n  a += b;\n  return (a >= 998244353) ? a - 998244353 : a;\n}\nvoid get(int x) {\n  int i, j, k, res = 0, l1, r1;\n  for (i = x; i <= m; i += x) {\n    memset(f[i], 0, sizeof(f[i]));\n    memset(pre[i], 0, sizeof(pre[i]));\n  }\n  for (i = 1; i <= n; i++) {\n    r1 = (r[i] / x) * x;\n    l1 = ((l[i] + x - 1) / x) * x;\n    if (l1 > r1) {\n      return;\n    }\n    if (i == 1) {\n      for (j = l1; j <= r1; j += x) {\n        f[j][i] = 1;\n      }\n    } else {\n      for (j = x; j <= m; j += x) {\n        cnt++;\n        if (j <= l1) {\n          continue;\n        }\n        if (j <= r1 + x) {\n          f[j][i] = pre[j - l1][i - 1];\n        } else {\n          f[j][i] = su(pre[j - l1][i - 1], 998244353 - pre[j - r1 - x][i - 1]);\n        }\n      }\n    }\n    for (j = x; j <= m; j += x) {\n      pre[j][i] = su(pre[j - x][i], f[j][i]);\n    }\n  }\n  for (i = x; i <= m; i += x) {\n    res = su(res, f[i][n]);\n  }\n  g[x] = res;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &l[i], &r[i]);\n  }\n  for (i = 1; i <= m; i++) {\n    get(i);\n  }\n  for (i = m; i >= 1; i--) {\n    for (j = i + i; j <= m; j += i) {\n      g[i] = su(g[i], 998244353 - g[j]);\n    }\n  }\n  printf(\"%d\", g[1]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <const int &MOD>\nstruct _m_int {\n  int val;\n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n  _m_int &operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  _m_int &operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n    return unsigned(x % m);\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\" : \"=a\"(quot), \"=d\"(rem) : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n    return rem;\n  }\n  _m_int &operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n  _m_int &operator/=(const _m_int &other) { return *this *= other.inv(); }\n  friend _m_int operator+(const _m_int &a, const _m_int &b) {\n    return _m_int(a) += b;\n  }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) {\n    return _m_int(a) -= b;\n  }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) {\n    return _m_int(a) *= b;\n  }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) {\n    return _m_int(a) /= b;\n  }\n  _m_int &operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n  _m_int &operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n  _m_int operator++(int) {\n    _m_int before = *this;\n    ++*this;\n    return before;\n  }\n  _m_int operator--(int) {\n    _m_int before = *this;\n    --*this;\n    return before;\n  }\n  _m_int operator-() const { return val == 0 ? 0 : MOD - val; }\n  friend bool operator==(const _m_int &a, const _m_int &b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const _m_int &a, const _m_int &b) {\n    return a.val != b.val;\n  }\n  friend bool operator<(const _m_int &a, const _m_int &b) {\n    return a.val < b.val;\n  }\n  friend bool operator>(const _m_int &a, const _m_int &b) {\n    return a.val > b.val;\n  }\n  friend bool operator<=(const _m_int &a, const _m_int &b) {\n    return a.val <= b.val;\n  }\n  friend bool operator>=(const _m_int &a, const _m_int &b) {\n    return a.val >= b.val;\n  }\n  static const int SAVE_INV = int(1e6) + 5;\n  static _m_int save_inv[SAVE_INV];\n  static void prepare_inv() {\n    for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1) assert(MOD % p != 0);\n    save_inv[0] = 0;\n    save_inv[1] = 1;\n    for (int i = 2; i < SAVE_INV; i++)\n      save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);\n  }\n  _m_int inv() const {\n    if (save_inv[1] == 0) prepare_inv();\n    if (val < SAVE_INV) return save_inv[val];\n    _m_int product = 1;\n    int v = val;\n    while (v >= SAVE_INV) {\n      product *= MOD - MOD / v;\n      v = MOD % v;\n    }\n    return product * save_inv[v];\n  }\n  _m_int pow(int64_t p) const {\n    if (p < 0) return inv().pow(-p);\n    _m_int a = *this, result = 1;\n    while (p > 0) {\n      if (p & 1) result *= a;\n      p >>= 1;\n      if (p > 0) a *= a;\n    }\n    return result;\n  }\n  friend ostream &operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\ntemplate <const int &MOD>\n_m_int<MOD> _m_int<MOD>::save_inv[_m_int<MOD>::SAVE_INV];\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> last_prime(m + 1, -1);\n  for (int i = 2; i <= m; i++) {\n    if (last_prime[i] != -1) {\n      continue;\n    }\n    for (int j = i; j <= m; j += i) {\n      last_prime[j] = i;\n    }\n  }\n  vector<int> mobius(m + 1);\n  mobius[1] = 1;\n  for (int i = 2; i <= m; i++) {\n    int x = i;\n    bool flag = false;\n    int cnt = 0;\n    while (x > 1) {\n      int pr = last_prime[x];\n      int cur = 0;\n      while (x % pr == 0) {\n        x /= pr;\n        cur++;\n      }\n      if (cur > 1) {\n        flag = true;\n        break;\n      }\n      cnt++;\n    }\n    if (flag) {\n      continue;\n    }\n    mobius[i] = (cnt % 2 == 1 ? -1 : 1);\n  }\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  mod_int ans = 0;\n  for (int g = 1; g <= m; g++) {\n    if (mobius[g] == 0) {\n      continue;\n    }\n    int s = m / g + 1;\n    vector<mod_int> dp(s, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n      int nl = (l[i] + g - 1) / g;\n      int nr = r[i] / g;\n      vector<mod_int> psum(s + 1, 0);\n      for (int x = 0; x < s; x++) {\n        psum[x + 1] = psum[x] + dp[x];\n      }\n      vector<mod_int> ndp(s, 0);\n      if (nl <= nr) {\n        for (int x = 0; x < s; x++) {\n          ndp[x] = psum[max(x - nl + 1, 0)] - psum[max(x - nr, 0)];\n        }\n      }\n      ndp.swap(dp);\n    }\n    mod_int res = 0;\n    for (int x = 0; x < s; x++) {\n      res += dp[x];\n    }\n    ans += res * mobius[g];\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long int abss(long long int a) {\n  if (a < 0) return -a;\n  return a;\n}\nlong long int ones(long long int a) {\n  long long int cnt = 0;\n  while (a > 0) {\n    if (a & 1) cnt++;\n    a >>= 1;\n  }\n  return cnt;\n}\nlong long int fast_pow(long long int b, long long int e,\n                       long long int width = 998244353) {\n  if (e == 0) {\n    return 1;\n  } else if (e == 1) {\n    return b % width;\n  }\n  b = b % width;\n  long long int ans = 1;\n  while (e > 0) {\n    if ((e & 1) == 1) {\n      ans = (ans * b) % width;\n    }\n    e >>= 1;\n    b = (b * b) % width;\n  }\n  return ans;\n}\nlong long int mod_inv(long long int a, long long int width = 998244353) {\n  return fast_pow(a, width - 2, width);\n}\ntemplate <typename Number, Number width>\nclass ModularArithmetic {\n private:\n  Number n;\n\n public:\n  friend ostream &operator<<(ostream &os, ModularArithmetic const &num) {\n    return os << num.n;\n  }\n  friend istream &operator>>(istream &is, ModularArithmetic &num) {\n    is >> num.n;\n    return is;\n  }\n  ModularArithmetic() : n(0) {}\n  ModularArithmetic(Number n) : n(n % width) {\n    if (this->n < 0) this->n += width;\n  }\n  Number get() const { return n; }\n  ModularArithmetic operator+(const ModularArithmetic &b) {\n    Number t = (n + b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator-(const ModularArithmetic &b) {\n    Number t = (n - b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator*(const ModularArithmetic &b) {\n    Number t = (n * b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator/(const ModularArithmetic &b) {\n    assert(b.get() != 0);\n    Number ans = n * mod_inv(b.get(), width);\n    if ((ans) < 0) return ModularArithmetic(width + (ans) % width);\n    return ModularArithmetic(ans % width);\n  }\n  ModularArithmetic &operator+=(const ModularArithmetic &b) {\n    n = (n + b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator-=(const ModularArithmetic &b) {\n    n = (n - b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator*=(const ModularArithmetic &b) {\n    n = (n * b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator/=(const ModularArithmetic &b) {\n    assert(b.get() != 0);\n    n = (n * mod_inv(b.get(), width)) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n};\ntemplate <class T, size_t N>\nostream &operator<<(ostream &os, const array<T, N> &p) {\n  os << \"<\";\n  for (auto &it : p) os << it << \" \";\n  return os << \">\";\n}\ntemplate <class S, class T>\nostream &operator<<(ostream &os, const pair<S, T> &p) {\n  return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class S, class T>\nistream &operator>>(istream &is, pair<S, T> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class T, typename Cmp>\nostream &operator<<(ostream &os, const set<T, Cmp> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const multiset<T> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class S, class T, typename Cmp>\nostream &operator<<(ostream &os, const map<S, T, Cmp> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class S, class T>\nistream &operator>>(istream &is, const pair<S, T> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &p) {\n  for (auto &itr : p) is >> itr;\n  return is;\n}\ntemplate <class T>\nvoid dbs(string str, T t) {\n  cerr << str << \":\" << t << \"\\n\";\n}\ntemplate <class T, class... S>\nvoid dbs(string str, T t, S... second) {\n  long long int idx = str.find(',');\n  cerr << str.substr(0, idx) << \":\" << t << \",\";\n  dbs(str.substr(idx + 1), second...);\n}\nbool isComposite(long long int a, long long int d, long long int n) {\n  long long int res = fast_pow(a, d, n);\n  if (res == 1 || res == n - 1) return false;\n  while (d != (n - 1)) {\n    res = (res * res) % n;\n    if (res == n - 1) {\n      return false;\n    }\n  }\n  return true;\n}\nbool MillerRabinDet(long long int n) {\n  if (n < 4) return n == 2 || n == 3;\n  long long int d = n - 1;\n  while (d & 1 == 0) {\n    d >>= 1;\n  }\n  for (long long int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n    if (a == n) return true;\n    if (isComposite(a, d, n)) {\n      return false;\n    }\n  }\n  return true;\n}\nbool MillerRabinNonDet(long long int n, long long int k = 1000) {\n  if (n < 4) return n == 2 || n == 3;\n  long long int d = n - 1;\n  long long int second = 0;\n  while (d & 1 == 0) {\n    d >>= 1;\n    second++;\n  }\n  long long int a;\n  for (long long int i = 0; i < k; i++) {\n    a = 2 + rand() % (n - 3);\n    if (isComposite(a, d, n)) {\n      return false;\n    }\n  }\n  return true;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (a % b == 0) return b;\n  return gcd(b, a % b);\n}\nlong long int n, m;\nvector<pair<long long int, long long int>> arr;\nvector<ModularArithmetic<long long int, 998244353>> F, S;\nconst long long int sz = 100005;\nModularArithmetic<long long int, 998244353> compute(long long int d) {\n  long long int dm = m / d;\n  vector<ModularArithmetic<long long int, 998244353>> dp1(dm + 1, 0),\n      dp2(dm + 1, 0);\n  dp1[0] = 1;\n  for (long long int i = 0; i < n; i++) {\n    long long int lf = (arr[i].first + d - 1) / d;\n    long long int rt = (arr[i].second) / d;\n    if (lf > rt) return 0;\n    dp2[0] = dp1[0];\n    for (long long int j = 1; j <= dm; j++) dp2[j] = dp1[j] + dp2[j - 1];\n    {};\n    for (long long int j = 0; j <= dm; j++) {\n      dp1[j] =\n          ((j - lf >= 0) ? dp2[j - lf]\n                         : ModularArithmetic<long long int, 998244353>(0)) -\n          (((j - (rt + 1)) >= 0)\n               ? dp2[j - (rt + 1)]\n               : ModularArithmetic<long long int, 998244353>(0));\n    }\n  }\n  ModularArithmetic<long long int, 998244353> ans = 0;\n  for (auto itr : dp1) ans += itr;\n  ans -= dp1[0];\n  return ans;\n}\nvoid solve() {\n  cin >> n >> m;\n  vector<pair<long long int, long long int>>(n).swap(arr);\n  for (long long int i = 0; i < n; ++i) cin >> arr[i].first >> arr[i].second;\n  vector<ModularArithmetic<long long int, 998244353>>(m + 1, 0).swap(F);\n  vector<ModularArithmetic<long long int, 998244353>>(m + 1, 0).swap(S);\n  for (long long int i = m; i > 0; i--) F[i] = compute(i);\n  for (long long int i = m; i > 0; i--) {\n    S[i] = F[i];\n    for (long long int j = i * 2; j <= m; j += i) S[i] -= S[j];\n  }\n  cout << S[1] << \"\\n\";\n}\nint main() {\n  freopen(\"err.txt\", \"w\", stderr);\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint add(int x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\nint p[2][100001];\nint get(int i, int l, int r) {\n  if (r < 0) return 0;\n  l = max(l, 0);\n  return add(p[i][r], mod - (l == 0 ? 0 : p[i][l - 1]));\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> f(m + 1);\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) cin >> l[i] >> r[i];\n  for (int d = 1; d <= m; d++) {\n    vector<int> L(n), R(n);\n    bool fail = false;\n    for (int i = 0; i < n; i++) {\n      L[i] = (l[i] + d - 1) / d;\n      R[i] = r[i] / d;\n      if (R[i] < L[i]) fail = true;\n    }\n    if (fail) continue;\n    int bound = m / d;\n    for (int i = 0; i <= 1; i++)\n      for (int j = 0; j <= bound; j++) p[i][j] = 0;\n    p[0][0] = 1;\n    for (int i = 1; i <= bound; i++) p[0][i] = 1;\n    int cur = 0, nxt = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= bound; j++)\n        p[nxt][j] = add(p[nxt][j], get(cur, j - R[i], j - L[i]));\n      for (int j = 1; j <= bound; j++)\n        p[nxt][j] = add(p[nxt][j], p[nxt][j - 1]);\n      for (int j = 0; j <= bound; j++) p[cur][j] = 0;\n      swap(cur, nxt);\n    }\n    f[d] = p[cur][bound];\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) f[i] = add(f[i], mod - f[j]);\n  }\n  cout << f[1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int modInverse(long long int a, long long int m) {\n  long long int m0 = m;\n  long long int y = 0, x = 1;\n  if (m == 1) return 0;\n  while (a > 1) {\n    long long int q = a / m;\n    long long int t = m;\n    m = a % m, a = t;\n    t = y;\n    y = x - q * y;\n    x = t;\n  }\n  if (x < 0) x += m0;\n  return x;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  long long int mod = 998244353;\n  long long int dp[m + 1], pp[m + 1];\n  for (int j = 0; j <= m; j++) {\n    dp[j] = 0;\n  }\n  dp[0] = 1;\n  long long int A[n], B[n];\n  for (long long int i = 0; i < n; i++) {\n    long long int l, r;\n    cin >> l >> r;\n    A[i] = l;\n    B[i] = r;\n    for (int j = 0; j <= m; j++) {\n      pp[j] = 0;\n    }\n    long long int sum = 0;\n    for (int j = l; j <= m; j++) {\n      sum += dp[j - l];\n      sum %= mod;\n      if (j - r - 1 >= 0) {\n        sum -= dp[j - r - 1];\n      }\n      sum %= mod;\n      sum += mod;\n      sum %= mod;\n      pp[j] = sum;\n    }\n    for (int j = 0; j <= m; j++) {\n      dp[j] = pp[j];\n    }\n  }\n  for (int j = 2; j <= m; j++) {\n    long long int flag = 1, val = 0;\n    long long int k = j;\n    for (int l = 2; l * l <= k; l++) {\n      int gg = 0;\n      while (k % l == 0) {\n        k /= l;\n        gg++;\n        if (gg > 1) {\n          flag = 0;\n          break;\n        }\n      }\n      val += gg;\n      if (flag == 0) {\n        break;\n      }\n    }\n    if (k > 1) {\n      val++;\n    }\n    if (flag == 0) {\n      continue;\n    }\n    long long int m1 = m / j, l1, r1;\n    long long int dp1[m1];\n    long long int pp1[m1];\n    for (int i = 0; i <= m1; i++) {\n      dp1[i] = 0;\n    }\n    dp1[0] = 1;\n    for (int y = 0; y < n; y++) {\n      l1 = A[y];\n      l1 = (l1 + j - 1) / j;\n      r1 = B[y];\n      r1 /= j;\n      for (int i = 0; i <= m1; i++) {\n        pp1[i] = 0;\n      }\n      long long int sum = 0;\n      for (int i = l1; i <= m1; i++) {\n        sum += dp1[i - l1];\n        sum %= mod;\n        if (i - r1 - 1 >= 0) {\n          sum -= dp1[i - r1 - 1];\n        }\n        sum %= mod;\n        sum += mod;\n        sum %= mod;\n        pp1[i] = sum;\n      }\n      for (int i = 0; i <= m1; i++) {\n        dp1[i] = pp1[i];\n        if (y == n - 1) {\n          if (val % 2 == 1) {\n            dp[i] -= dp1[i];\n            dp[i] %= mod;\n            dp[i] += mod;\n            dp[i] %= mod;\n          } else {\n            dp[i] += dp1[i];\n            dp[i] %= mod;\n          }\n        }\n      }\n    }\n  }\n  long long int ans = 0;\n  for (int i = 1; i <= m; i++) {\n    ans += dp[i];\n    ans %= mod;\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 1e5 + 5;\nint cnt = 0, vis[maxn], prime[maxn], mu[maxn];\nint f[55][maxn], l[55], r[55], l1[55], r1[55];\nvoid init(int n) {\n  vis[1] = mu[1] = 1;\n  for (int i = (2); i <= (n); i++) {\n    if (!vis[i]) prime[++cnt] = i, mu[i] = -1;\n    for (int j = (1); j <= (cnt); j++) {\n      if (i * prime[j] > n) break;\n      vis[i * prime[j]] = 1;\n      if (i % prime[j] == 0) {\n        mu[i * prime[j]] = 0;\n        break;\n      }\n      mu[i * prime[j]] = -mu[i];\n    }\n  }\n}\nint n, m;\nint calc(int x) {\n  long long sum = 0;\n  for (int i = (1); i <= (n); i++) {\n    l[i] = (l1[i] - 1) / x + 1;\n    r[i] = r1[i] / x;\n    sum += l[i];\n    if (i == 1)\n      for (int j = (l[i]); j <= (r[i]); j++) f[1][j] = 1;\n    else {\n      for (int j = (sum); j <= (m / x); j++) {\n        int L = max(1, j - r[i]), R = j - l[i];\n        f[i][j] = ((f[i - 1][R] - f[i - 1][L - 1]) % mod + mod) % mod;\n      }\n    }\n    for (int j = (1); j <= (m / x); j++) (f[i][j] += f[i][j - 1]) %= mod;\n  }\n  return f[n][m / x];\n}\nint main() {\n  init(1e5);\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  int mnr = 1e9;\n  for (int i = (1); i <= (n); i++) {\n    scanf(\"%d\", &l1[i]), scanf(\"%d\", &r1[i]);\n    mnr = min(mnr, r1[i]);\n  }\n  long long ans = 0;\n  for (int x = (1); x <= (mnr); x++) {\n    ans = ((ans + calc(x) * mu[x]) % mod + mod) % mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1559e {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), m = ni(), l[] = new int[n], r[] = new int[n], div[] = sieve(m), cnt[] = new int[m + 1];\n        cnt[1] = 0;\n        for (int i = 2; i <= m; ++i) {\n            Set<Integer> pfact = new HashSet<>();\n            int j = i;\n            while (j != 1) {\n                if (pfact.contains(div[j])) {\n                    cnt[i] = -1;\n                    break;\n                } else {\n                    cnt[i] ^= 1;\n                    pfact.add(div[j]);\n                    j /= div[j];\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            l[i] = rni();\n            r[i] = ni();\n        }\n        int ans = 0;\n        for (int i = 1; i <= m; ++i) {\n            if (cnt[i] != -1) {\n                int dp[] = new int[m / i + 1];\n                dp[0] = 1;\n                for (int j = 0; j < n; ++j) {\n                    int lb = (l[j] + i - 1) / i, rb = r[j] / i, sum[] = new int[m / i + 2];\n                    for (int k = 0; k <= m / i; ++k) {\n                        sum[k + 1] = madd(sum[k], dp[k]);\n                    }\n                    for (int k = 0; k <= m / i; ++k) {\n                        dp[k] = msub(sum[max(0, k - lb + 1)], sum[max(0, k - rb)]);\n                    }\n                }\n                int sum = 0;\n                for (int j = 0; j <= m / i; ++j) {\n                    sum = madd(sum, dp[j]);\n                }\n                // prln(-(cnt[i] * 2 - 1) * sum);\n                if (cnt[i] == 0) {\n                    ans = madd(ans, sum);\n                } else {\n                    ans = msub(ans, sum);\n                }\n            }\n        }\n        prln(ans);\n        close();\n    }\n\n    @FunctionalInterface\n    interface IntOperator {\n        int merge(int a, int b);\n    }\n\n    @FunctionalInterface\n    interface IntAction {\n        void apply(int x);\n    }\n\n    static class sgt {\n        IntOperator upd_op, qry_op;\n        int n, sgt[], lazy[], id;\n\n        sgt(int sz, IntOperator operator, int identity) {\n            n = sz;\n            sgt = new int[4 * n + 5];\n            lazy = new int[4 * n + 5];\n            upd_op = qry_op = operator;\n            id = identity;\n            int a[] = new int[n];\n            fill(a, id);\n            build(1, a, 0, n - 1);\n        }\n\n        sgt(int sz, IntOperator update_operator, IntOperator query_operator, int identity) {\n            n = sz;\n            sgt = new int[4 * n + 5];\n            lazy = new int[4 * n + 5];\n            upd_op = update_operator;\n            qry_op = query_operator;\n            id = identity;\n            int a[] = new int[n];\n            fill(a, id);\n            build(1, a, 0, n - 1);\n        }\n\n        sgt(int[] a, IntOperator operator, int identity) {\n            n = a.length;\n            sgt = new int[4 * n + 5];\n            lazy = new int[4 * n + 5];\n            upd_op = qry_op = operator;\n            id = identity;\n            build(1, a, 0, n - 1);\n        }\n\n        sgt(int[] a, IntOperator update_operator, IntOperator query_operator, int identity) {\n            n = a.length;\n            sgt = new int[4 * n + 5];\n            lazy = new int[4 * n + 5];\n            upd_op = update_operator;\n            qry_op = query_operator;\n            id = identity;\n            build(1, a, 0, n - 1);\n        }\n\n        void set(int i, int x) {\n            set(1, i, x, 0, n - 1);\n        }\n\n        void upd(int i, int j, int x) {\n            upd(1, i, j, x, 0, n - 1);\n        }\n\n        void upd(int i, int x) {\n            upd(1, i, x, 0, n - 1);\n        }\n\n        int qry(int l, int r) {\n            return qry(1, l, r, 0, n - 1);\n        }\n\n        int qry(int i) {\n            return qry(1, i, i, 0, n - 1);\n        }\n\n        void set(int node, int i, int x, int l, int r) {\n            push(node, l, r);\n            if (l == r) {\n                sgt[node] = x;\n            } else {\n                int m = l + (r - l) / 2;\n                if (i <= m) {\n                    set(node << 1, i, x, l, m);\n                } else {\n                    set(node << 1 | 1, i, x, m + 1, r);\n                }\n                pull(node);\n            }\n        }\n\n        void upd(int node, int i, int x, int l, int r) {\n            push(node, l, r);\n            if (l == r) {\n                sgt[node] = upd_op.merge(sgt[node], x);\n            } else {\n                int m = l + (r - l) / 2;\n                if (i <= m) {\n                    upd(node << 1, i, x, l, m);\n                } else {\n                    upd(node << 1 | 1, i, x, m + 1, r);\n                }\n                pull(node);\n            }\n        }\n\n        void upd(int node, int i, int j, int x, int l, int r) {\n            push(node, l, r);\n            if (r < i || j < l) {\n                return;\n            } else if (i <= l && r <= j) {\n                lazy[node] = x;\n                push(node, l, r);\n            } else {\n                int m = l + (r - l) / 2;\n                upd(node << 1, i, j, x, l, m);\n                upd(node << 1 | 1, i, j, x, m + 1, r);\n                pull(node);\n            }\n        }\n\n        int qry(int node, int i, int j, int l, int r) {\n            push(node, l, r);\n            if (r < i || j < l) {\n                return id;\n            } else if (i <= l && r <= j) {\n                return sgt[node];\n            } else {\n                int m = l + (r - l) / 2;\n                return qry_op.merge(qry(node << 1, i, j, l, m), qry(node << 1 | 1, i, j, m + 1, r));\n            }\n        }\n\n        void build(int node, int[] a, int l, int r) {\n            if (l == r) {\n                sgt[node] = a[l];\n            } else {\n                int m = l + (r - l) / 2;\n                build(node << 1, a, l, m);\n                build(node << 1 | 1, a, m + 1, r);\n                pull(node);\n            }\n        }\n\n        void pull(int node) {\n            sgt[node] = qry_op.merge(sgt[node << 1], sgt[node << 1 | 1]);\n        }\n\n        void push(int node, int l, int r) {\n            sgt[node] += mmul(lazy[node], r - l + 1);\n            if (l != r) {\n                lazy[node << 1] = madd(lazy[node << 1], lazy[node]);\n                lazy[node << 1 | 1] = madd(lazy[node << 1 | 1], lazy[node]);\n            }\n            lazy[node] = 0;\n        }\n\n        void traverse(IntAction a) {\n            traverse(a, 1, 0, n - 1);\n        }\n\n        void traverse(IntAction a, int node, int l, int r) {\n            push(node, l, r);\n            if (l == r) {\n                a.apply(sgt[node]);\n            } else {\n                int m = l + (r - l) / 2;\n                traverse(a, node << 1, l, m);\n                traverse(a, node << 1 | 1, m + 1, r);\n            }\n        }\n    }\n\n    static int mmod = 998244353;\n\n    static int madd(int a, int b) {\n        return (a + b) % mmod;\n    }\n\n    static int madd(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = madd(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int msub(int a, int b) {\n        return (a - b + mmod) % mmod;\n    }\n\n    static int mmul(int a, int b) {\n        return (int) ((long) a * b % mmod);\n    }\n\n    static int mmul(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = mmul(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int minv(int x) {\n        // return mpow(x, mmod - 2);\n        return (exgcd(x, mmod)[0] % mmod + mmod) % mmod;\n    }\n\n    static int mpow(int a, long b) {\n        if (a == 0) {\n            return 0;\n        }\n        int ans = 1;\n        while (b > 0) {\n            if ((b & 1) > 0) {\n                ans = mmul(ans, a);\n            }\n            a = mmul(a, a);\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    static int[] sieve(int n) {\n        int[] div = new int[n + 1];\n        for (int i = 2; i <= n; ++i) {\n            if (div[i] == 0) {\n                div[i] = i;\n                if ((long) i * i <= n) {\n                    int j = i * i;\n                    while (j <= n) {\n                        div[j] = i;\n                        j += i;\n                    }\n                }\n            }\n        }\n        return div;\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) *\n                                     rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) {\n    return v;\n  }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int)fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int)fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\nvector<int> smallest_factor;\nvector<int8_t> smallest_power;\nvector<int8_t> mobius;\nvector<bool> prime;\nvector<int> primes;\nvoid sieve(int maximum) {\n  maximum = max(maximum, 1);\n  smallest_factor.assign(maximum + 1, 0);\n  smallest_power.assign(maximum + 1, 0);\n  mobius.assign(maximum + 1, 0);\n  prime.assign(maximum + 1, true);\n  mobius[1] = 1;\n  prime[0] = prime[1] = false;\n  primes = {};\n  for (int i = 2; i <= maximum; i++) {\n    if (prime[i]) {\n      smallest_factor[i] = i;\n      smallest_power[i] = 1;\n      mobius[i] = -1;\n      primes.push_back(i);\n    }\n    for (int p : primes) {\n      if (p > smallest_factor[i] || i * p > maximum) break;\n      prime[i * p] = false;\n      smallest_factor[i * p] = p;\n      smallest_power[i * p] =\n          smallest_factor[i] == p ? int8_t(smallest_power[i] + 1) : 1;\n      mobius[i * p] = smallest_factor[i] == p ? 0 : int8_t(-mobius[i]);\n    }\n  }\n}\nMint cal(vector<int> l, vector<int> r, int m) {\n  Mint ans = 0;\n  int n = r.size();\n  for (long long i = 0; i < n; i++) {\n    r[i] -= l[i];\n    m -= l[i];\n  }\n  if (m < 0) return 0;\n  vector<Mint> sum(m + 1);\n  sum[0] = 1;\n  for (int ri : r) {\n    vector<Mint> sssum(m + 1);\n    Mint summ = 0;\n    for (int i = 0; i <= m; i++) {\n      summ += sum[i];\n      summ -= i > ri ? sum[i - ri - 1] : 0;\n      sssum[i] = summ;\n    }\n    sum.swap(sssum);\n  }\n  for (int i = 0; i <= m; i++) ans += sum[i];\n  return ans;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(n), r(n);\n  for (long long i = 0; i < n; i++) cin >> l[i] >> r[i];\n  sieve(100001);\n  Mint ans = 0;\n  for (int i = 1; i <= m; i++) {\n    vector<int> long long(n), rr(n);\n    for (int j = 0; j < n; j++) {\n      long long[j] = (l[j] + i - 1) / i;\n      rr[j] = r[j] / i;\n    }\n    ans += (Mint)mobius[i] * cal(long long, rr, m / i);\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int qq = 1;\n  for (int i = 1; i <= qq; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\nusing namespace std;\nconstexpr int N = 3e5 + 7;\nconstexpr int M = 998244353;\nlong long mu[N], flg[N], p[N], tot;\nvoid getMu() {\n  mu[1] = 1;\n  for (long long i = 2; i < N; ++i) {\n    if (!flg[i]) p[++tot] = i, mu[i] = -1;\n    for (long long j = 1; j <= tot && i * p[j] < N; ++j) {\n      flg[i * p[j]] = 1;\n      if (i % p[j] == 0) {\n        mu[i * p[j]] = 0;\n        break;\n      }\n      mu[i * p[j]] = -mu[i];\n    }\n  }\n}\nlong long dp[2][N];\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  getMu();\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long> > a(n + 1);\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  long long ans = 0;\n  for (long long d = 1; d <= m; d++) {\n    fill(dp[0], dp[0] + m / d + 1, 1);\n    long long x = 0;\n    auto sum = [&](long long l, long long r) {\n      return ((r >= 0 ? dp[x ^ 1][r] : 0ll) -\n              (l - 1 >= 0 ? dp[x ^ 1][l - 1] : 0ll) + M) %\n             M;\n    };\n    for (long long i = 1; i <= n; i++) {\n      x ^= 1;\n      fill(dp[x], dp[x] + m / d + 1, 0);\n      long long l = a[i].first / d + (a[i].first % d != 0);\n      long long r = a[i].second / d;\n      for (long long j = 0; j <= m / d; j++) {\n        dp[x][j] = sum(j - r, j - l);\n        if (j - 1 >= 0) dp[x][j] = (dp[x][j] + dp[x][j - 1]) % M;\n      }\n    }\n    ans = (ans + dp[x][m / d] * mu[d] % M + M) % M;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int N = 2e5 + 5;\nlong long prime[N + 5], mu[N + 5], tot = 0;\nbool vis[N + 5];\nlong long n, m;\nlong long l[55], r[55];\nlong long f[N], g[N];\nlong long ans = 0;\nvoid init() {\n  mu[1] = 1;\n  for (long long i = 2; i <= N; i++) {\n    if (!vis[i]) {\n      prime[tot] = i;\n      tot++;\n      mu[i] = -1;\n    }\n    for (long long j = 0; j < tot && prime[j] * i <= N; j++) {\n      vis[prime[j] * i] = 1;\n      if (i % prime[j] == 0) {\n        mu[prime[j] * i] = 0;\n        break;\n      }\n      mu[prime[j] * i] = -mu[i];\n    }\n  }\n}\nint main() {\n  init();\n  scanf(\"%lld%lld\", &n, &m);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld%lld\", l + i, r + i);\n  for (long long i = 1; i <= m; i++) {\n    f[0] = g[0] = 1;\n    for (long long j = 1; j <= m / i; j++) f[j] = 0, g[j] = 1;\n    for (long long j = 1; j <= n; j++) {\n      long long ql = (l[j] - 1) / i + 1, qr = r[j] / i;\n      if (ql > qr) {\n        g[m / i] = 0;\n        break;\n      }\n      for (int k = 0; k < ql; k++) f[k] = 0;\n      for (int k = ql; k <= m / i; k++)\n        f[k] = g[k - ql] - (k >= qr + 1 ? g[k - qr - 1] : 0);\n      g[0] = f[0];\n      for (int k = 1; k <= m / i; k++) g[k] = (g[k - 1] + f[k]) % mod;\n    }\n    ans += mu[i] * g[m / i] % mod;\n    ans %= mod;\n  }\n  printf(\"%lld\\n\", (ans % mod + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 998244353;\nconst int MAXN = 52;\nconst int MAXM = 100002;\nint n, m;\nint l[MAXN], r[MAXN];\nint L[MAXN], R[MAXN];\nint mu[MAXM];\nint f[MAXN][MAXM];\nvoid Sieve() {\n  static bool pri[MAXM];\n  static std::vector<int> pml;\n  mu[1] = 1;\n  for (int i = 2; i < MAXM; ++i) {\n    if (!pri[i]) {\n      pml.push_back(i);\n      mu[i] = -1;\n    }\n    for (auto &p : pml) {\n      if (p * i >= MAXM) break;\n      pri[p * i] = true;\n      if (i % p == 0) {\n        mu[p * i] = 0;\n        break;\n      }\n      mu[p * i] = -mu[i];\n    }\n  }\n}\nint Work(int d) {\n  for (int i = 1; i <= n; ++i) {\n    L[i] = (l[i] + d - 1) / d;\n    R[i] = r[i] / d;\n    if (L[i] > R[i]) return 0;\n  }\n  f[0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= m / d; ++j) f[i][j] = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j + L[i] <= m / d; ++j) {\n      int st = j + L[i], ed = std::min(j + R[i] + 1, m / d + 1);\n      f[i][st] = (f[i][st] + f[i - 1][j]) % MOD;\n      f[i][ed] = (f[i][ed] - f[i - 1][j]) % MOD;\n    }\n    for (int j = 1; j <= m / d; ++j) f[i][j] = (f[i][j] + f[i][j - 1]) % MOD;\n  }\n  int ret = 0;\n  for (int i = 0; i <= m / d; ++i) ret = (ret + f[n][i]) % MOD;\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &l[i], &r[i]);\n  Sieve();\n  int ans = 0;\n  for (int d = 1; d <= m; ++d) ans = (ans + mu[d] * Work(d)) % MOD;\n  printf(\"%d\\n\", ans < 0 ? ans + MOD : ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint inf = 1e9;\nint mod = 998244353;\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += mod;\n}\ninline int mul(int a, int b) { return (int)((long long)a * b % mod); }\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\ninline int inv(int a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  int b = mod, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += mod;\n  return u;\n}\nvector<int> dp[2][N];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int l[n + 1], r[n + 1];\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  for (int i = 0; i < 2; i++) {\n    for (int j = 1; j <= m; j++) {\n      dp[i][j].resize(m / j + 1, 0);\n    }\n  }\n  for (int D = m; D >= 1; D--) {\n    int last = 0;\n    dp[0][D][0] = 1;\n    for (int i = 1; i <= m / D; i++) add(dp[0][D][i], dp[0][D][i - 1]);\n    for (int i = 1; i <= n; i++) {\n      last ^= 1;\n      int y = (l[i] + D - 1) / D;\n      int z = r[i] / D;\n      if (y > z) {\n        for (int j = 0; j <= m / D; j++) {\n          dp[last ^ 1][D][j] = 0;\n        }\n        continue;\n      }\n      for (int j = 0; j <= m / D; j++) {\n        if (j - y >= 0) add(dp[last][D][j], dp[last ^ 1][D][j - y]);\n        if (j - z > 0) sub(dp[last][D][j], dp[last ^ 1][D][j - z - 1]);\n      }\n      for (int j = 0; j <= m / D; j++) {\n        if (j) add(dp[last][D][j], dp[last][D][j - 1]);\n        dp[last ^ 1][D][j] = 0;\n      }\n    }\n  }\n  vector<int> ans(m + 1);\n  for (int i = 1; i <= m; i++) ans[i] = dp[n & 1][i][m / i];\n  for (int i = m; i > 0; i--) {\n    for (int j = i + i; j <= m; j += i) {\n      sub(ans[i], ans[j]);\n    }\n  }\n  cout << ans[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF_LL = 1e18;\nconst int INF = 1e9 + 100;\nconst int MOD = 998244353;\nconst long double EPS = 1e-10;\nconst int BLOCK = 550;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nvoid open_file() {}\nconst int maxN = 6e5 + 100;\nvoid sol() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> L(n), R(n);\n  for (int i = 0; i < n; i++) cin >> L[i] >> R[i];\n  auto calc = [&](int x) {\n    for (int i = 0; i < n; i++) {\n      int a = (L[i] + x - 1) / x;\n      int b = R[i] / x;\n      if (a > b || b == 0) return 0;\n    }\n    int nm = m / x;\n    vector<int> dp(nm + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n      int a = (L[i] + x - 1) / x;\n      int b = R[i] / x;\n      if (a > b) return 0;\n      vector<int> n_dp(nm + 1, 0);\n      for (int j = 0; j + a <= nm; j++) {\n        int na = j + a;\n        int nb = j + b;\n        n_dp[na] = (n_dp[na] + dp[j]) % MOD;\n        if (nb < nm) n_dp[nb + 1] = (n_dp[nb + 1] - dp[j] + MOD) % MOD;\n      }\n      swap(n_dp, dp);\n      for (int i = 1; i <= nm; i++) dp[i] = (dp[i - 1] + dp[i]) % MOD;\n      if (*max_element(dp.begin(), dp.end()) == 0) return 0;\n    }\n    int ans = 0;\n    for (int i = 0; i <= nm; i++) ans = (ans + dp[i]) % MOD;\n    return ans;\n  };\n  vector<int> F(m + 1);\n  for (int i = 1; i <= m; i++) F[i] = calc(i);\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) F[i] = (F[i] - F[j] + MOD) % MOD;\n  }\n  cout << F[1];\n}\nvoid solve() {\n  int T = 1;\n  int TestCase = 0;\n  while (T--) {\n    TestCase += 1;\n    sol();\n  }\n}\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  open_file();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF_MAX = 1 << 30;\nconst double INF_MIN = 1e-6;\nconst int MAX_N = 50 + 5;\nconst int MAX_M = 100000 + 5;\nconst long long int MOD = 998244353;\nconst double PI = acos(-1.0);\nconst double E = exp(1.0);\nlong long int n, m;\nlong long int l[MAX_N];\nlong long int r[MAX_N];\nlong long int vis[MAX_M];\nlong long int prime[MAX_M];\nlong long int mu[MAX_M];\nlong long int dp[MAX_N][MAX_M];\nlong long int dSum[MAX_N][MAX_M];\nvoid prepare() {\n  memset(vis, 0, sizeof(vis));\n  mu[1] = 1;\n  int cnt = 0;\n  for (int i = 2; i < MAX_M; i++) {\n    if (!vis[i]) {\n      prime[cnt++] = i;\n      mu[i] = -1;\n    }\n    for (int j = 0; j < cnt && i * prime[j] < MAX_M; j++) {\n      vis[i * prime[j]] = 1;\n      if (i % prime[j]) {\n        mu[i * prime[j]] = -mu[i];\n      } else {\n        mu[i * prime[j]] = 0;\n        break;\n      }\n    }\n  }\n}\nvoid init() {}\nvoid input() {\n  scanf(\"%lld%lld\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &l[i], &r[i]);\n  }\n}\nlong long int calDp(int d) {\n  for (int j = 0; j <= m / d; j++) {\n    dSum[0][j] = j + 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    long long int li = (l[i] % d == 0) ? l[i] / d : l[i] / d + 1, ri = r[i] / d;\n    dSum[i][0] = (li == 0);\n    for (int j = 1; j <= m / d; j++) {\n      if (li > ri) {\n        dp[i][j] = 0;\n      } else {\n        int s = j - ri, e = j - li;\n        dp[i][j] = ((e >= 0) ? dSum[i - 1][e] : 0) -\n                   ((s - 1 >= 0) ? dSum[i - 1][s - 1] : 0);\n        dp[i][j] = (dp[i][j] + MOD) % MOD;\n      }\n      dSum[i][j] = (dSum[i][j - 1] + dp[i][j]) % MOD;\n    }\n  }\n  return dp[n][m / d];\n}\nvoid solve() {\n  long long int ans = 0;\n  for (int d = 1; d <= m; d++) {\n    long long int fd = calDp(d);\n    ans = (ans + mu[d] * fd + MOD) % MOD;\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  prepare();\n  int t;\n  t = 1;\n  while (t--) {\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid setIO(string name = \"\") {\n  cin.tie(0)->sync_with_stdio(0);\n  if ((int)name.size()) {\n    freopen((name + \".in\").c_str(), \"r\", stdin);\n    freopen((name + \".out\").c_str(), \"w\", stdout);\n  }\n}\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(const T &t, const V &...v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long N = 1e5 + 10;\nconst long long mod = 998244353;\nlong long n, m;\nlong long dp[55][N];\nlong long f[N];\nlong long l[55], r[55];\nlong long l1[55], r1[55];\nlong long construct_f(long long m) {\n  for (long long i = 0; i < (n + 1); ++i) {\n    for (long long j = 0; j < (m + 1); ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (ll i = 0; i < n; i++) {\n    ll r = 0;\n    for (ll j = 0; j <= m; j++) {\n      if (j >= l1[i]) {\n        r += dp[i][j - l1[i]];\n        if (r >= mod) r -= mod;\n      }\n      dp[i + 1][j] = r;\n      if (j >= r1[i]) {\n        r -= dp[i][j - r1[i]];\n        if (r < 0) r += mod;\n      }\n    }\n  }\n  long long res = 0;\n  for (long long j = 0; j <= m; ++j) {\n    res += dp[n][j];\n  }\n  return res % mod;\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 0; i < (n); ++i) {\n    cin >> l[i] >> r[i];\n  }\n  for (long long i = 1; i < (m + 1); ++i) {\n    long long max_l = -1;\n    for (long long j = 0; j < (n); ++j) {\n      l1[j] = 1e9, r1[j] = -1;\n      for (long long k = i; k <= m; k += i) {\n        if (l[j] <= k && k <= r[j]) {\n          l1[j] = min(l1[j], k);\n          r1[j] = k;\n        }\n      }\n      max_l = max(max_l, l1[j]);\n    }\n    if (max_l > 1e8) {\n      f[i] = 0;\n    } else {\n      for (long long j = 0; j < (n); ++j) {\n        l1[j] /= i, r1[j] /= i;\n      }\n      f[i] = construct_f(m / i);\n    }\n  }\n  for (long long i = m; i > 0; i--) {\n    for (long long j = 2 * i; j <= m; j += i) {\n      f[i] -= f[j];\n      if (f[i] < 0) {\n        f[i] += mod;\n      }\n    }\n  }\n  cout << f[1] << \"\\n\";\n}\nsigned main() {\n  setIO();\n  long long t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\n\nfor _ in range(int(input()) if not True else 1):\n    # n = int(input())\n    n, m = map(int, input().split())\n    # a, b = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    # s = input()\n    intervals = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        intervals += [[x, y]]\n    mod = 998244353\n    ways = [0] * 100001\n    for i in range(100000, 0, -1):\n        # number of ways to pick numbers so that gcd is i\n        bound = m // i\n        if not bound: continue\n        dp = [0] * (bound + 1)\n        pre = [1] * (bound + 2)\n        pre[0] = 0\n        dp[0] = 1\n        t = 0\n        for x, y in intervals:\n            left, right = (x + i - 1) // i, (y + i) // i\n            for v in range(bound, -1, -1):\n                dp[v] = 0\n                l, r = v - (right - 1), v - left\n                if left == right or r < 0: continue\n                dp[v] = (pre[r + 1] - pre[max(0, l)]) % mod\n            for j in range(1, bound + 2):\n                pre[j] = (pre[j - 1] + dp[j - 1]) % mod\n        ways[i] = pre[-1]\n        for j in range(2 * i, 100001, i):\n            ways[i] -= ways[j]\n        ways[i] %= mod\n    print(ways[1] % mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nconst int maxm = 1e5 + 5;\nconst int mod = 998244353;\nint l[maxn], r[maxn], prim[maxm], tot, flag[maxm], mu[maxm], n;\nint dp[maxn][maxm], sum[maxn];\nvoid init(int n) {\n  mu[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!flag[i]) prim[tot++] = i, mu[i] = -1;\n    for (int j = 0; j < tot && prim[j] * i <= n; ++j) {\n      flag[i * prim[j]] = 1;\n      if (i % prim[j] == 0) {\n        mu[i * prim[j]] = 0;\n        break;\n      }\n      mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nint f(int d, int m) {\n  dp[0][0] = 1;\n  for (int i = 0; i <= m; ++i) sum[i] = 1;\n  for (int i = 1; i <= n; ++i) {\n    int ls = (l[i] + d - 1) / d, rs = r[i] / d;\n    for (int j = 0; j < ls; ++j) dp[i][j] = 0;\n    for (int j = ls; j <= m; ++j) {\n      int L = j - rs, R = j - ls;\n      L = max(0, L);\n      if (!L)\n        dp[i][j] = sum[R];\n      else\n        dp[i][j] = (sum[R] - sum[L - 1]) % mod;\n    }\n    sum[0] = dp[i][0];\n    for (int j = 1; j <= m; ++j) {\n      sum[j] = (sum[j - 1] + dp[i][j]) % mod;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= m; ++i) {\n    ans = (ans + dp[n][i]) % mod;\n  }\n  return ans;\n}\nint main() {\n  int m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &l[i], &r[i]);\n  }\n  init(m);\n  int ans = 0;\n  for (int i = 1; i <= m; ++i) {\n    ans = (ans + 1ll * mu[i] * f(i, m / i) % mod) % mod;\n  }\n  ans = (ans + mod) % mod;\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.Map.Entry;\n\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic final long mod = 998244353;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tInputReader in = new InputReader(System.in);\n\t\t// Scanner in = new Scanner(System.in);\n\t\t// Scanner in = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// InputReader in = new InputReader(new\n\t\t// File(\"ethan_traverses_a_tree.txt\"));\n\t\t// PrintWriter out = new PrintWriter(new\n\t\t// File(\"ethan_traverses_a_tree-output.txt\"));\n\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[][] a = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i][0] = in.nextInt();\n\t\t\ta[i][1] = in.nextInt();\n\t\t}\n\n\t\tlong[] dp = new long[m + 1];\n\t\tlong countgt1 = 0;\n\t\tfor (int i = m / n; i >= 2; i--) {\n\t\t\tlong nowcount = getcount(a, n, m, i);\n\t\t\tfor (int j = 2; j * i <= m / n; j++) {\n\t\t\t\tnowcount = (nowcount - dp[j * i] + mod) % mod;\n\t\t\t}\n\n\t\t\tdp[i] = nowcount;\n\t\t\tcountgt1 = (countgt1 + nowcount) % mod;\n\t\t}\n\n\t\tlong ans = (getcount(a, n, m, 1) - countgt1 + mod) % mod;\n\t\tout.printf(\"%d\\n\", ans);\n\n\t\tout.close();\n\t}\n\n\tpublic static long getcount(int[][] tmpa, int n, int m, int divisor) {\n\t\tint[][] a = new int[n][2];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (tmpa[i][0] % divisor == 0) {\n\t\t\t\ta[i][0] = tmpa[i][0] / divisor;\n\t\t\t} else {\n\t\t\t\ta[i][0] = tmpa[i][0] / divisor + 1;\n\t\t\t}\n\n\t\t\ta[i][1] = tmpa[i][1] / divisor;\n\t\t\tif (a[i][1] < a[i][0]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tint m2 = m / divisor;\n\t\tlong[][] dp = new long[n][m2 + 1];\n\t\tlong[][] sum = new long[n][m2 + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= m2; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tif (j >= a[i][0] && j <= a[i][1]) {\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint prestart = j - a[i][1];\n\t\t\t\t\tint preend = j - a[i][0];\n\n\t\t\t\t\tif (preend < 0) {\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (prestart <= 0) {\n\t\t\t\t\t\t\tdp[i][j] = sum[i - 1][preend];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdp[i][j] = (sum[i - 1][preend] - sum[i - 1][prestart - 1] + mod) % mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tsum[i][j] = dp[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tsum[i][j] = (sum[i][j - 1] + dp[i][j]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sum[n - 1][m2];\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic InputReader(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_m = 1e5 + 5;\nbool mark_p[max_m];\nint mu[max_m];\nconst int max_cnt = 9592 + 5;\nint prime[max_cnt], cnt;\nconst int max_n = 50 + 5;\nint l[max_n], r[max_n], L[max_n], R[max_n], dp[max_n][max_m], pre[max_n][max_m];\nconst int mod = 998244353;\ninline void add(int &a, int b) { a = a + b - (a + b >= mod ? mod : 0); }\ninline void sub(int &a, int b) { a = a - b + (a < b ? mod : 0); }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 2; i <= m; ++i) mark_p[i] = true;\n  mu[1] = 1;\n  for (int i = 2; i <= m; ++i) {\n    if (mark_p[i]) {\n      prime[++cnt] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= cnt && 1ll * i * prime[j] <= m; ++j) {\n      mark_p[i * prime[j]] = false;\n      if (i % prime[j] == 0) {\n        mu[i * prime[j]] = 0;\n        break;\n      }\n      mu[i * prime[j]] = -mu[i];\n    }\n  }\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", l + i, r + i);\n  int ans = 0;\n  for (int d = 1; d <= m; ++d) {\n    if (!mu[d]) continue;\n    bool flag_break = false;\n    int sL = 0;\n    for (int i = 1; i <= n; ++i) {\n      L[i] = (l[i] + d - 1) / d;\n      R[i] = r[i] / d;\n      if (L[i] > R[i]) {\n        flag_break = true;\n        break;\n      }\n      sL += L[i];\n    }\n    if (flag_break) continue;\n    int M = m / d;\n    if (M < sL) continue;\n    dp[0][0] = 1;\n    for (int i = 0; i <= M; ++i) pre[0][i] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= M; ++j) {\n        int l = j - R[i], r = j - L[i];\n        if (r >= 0) dp[i][j] = pre[i - 1][r];\n        if (l >= 1) sub(dp[i][j], pre[i - 1][l - 1]);\n        pre[i][j] = pre[i][j - 1];\n        add(pre[i][j], dp[i][j]);\n      }\n    int res = pre[n][M];\n    if (mu[d] == 1)\n      add(ans, res);\n    else\n      sub(ans, res);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\n# sys.setrecursionlimit(1000000)\n\n# _INPUT = \"\"\"2 4\n# 1 3\n# 1 2\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\nINF = 10**10\n\nMOD = 998244353\n\n\ndef solve(d):\n    M1 = M//d\n\n    dp = [0] * (M1+1)\n    dp[0] = 1\n    for i in range(N):\n        s = [0]\n        for v in dp:\n            s.append((s[-1] + v) % MOD)\n        l, r = T[i]\n        l1, r1 = math.ceil(l/d), r//d\n        for m in range(M1+1):\n            l2 = max(m-r1, 0)\n            r2 = max(m-l1+1, 0)\n            dp[m] = (s[r2] - s[l2]) % MOD\n\n    return sum(dp[1:]) % MOD\n\n\ndef Mobius(n):\n    s = set()\n    while n > 1:\n        if D[n] in s:\n            return 0\n        s.add(D[n])\n        n //= D[n]\n    if len(s) % 2 == 0:\n        return 1\n    else:\n        return -1\n\nN, M = map(int, input().split())\nT = []\nfor _ in range(N):\n    l, r = map(int, input().split())\n    T.append((l, r))\n\nA_MAX = M\nD = [0] * (A_MAX + 1)\nfor i in range(2, A_MAX + 1):\n    if D[i] == 0:\n        D[i] = i\n        n = i * i\n        while n <= A_MAX:\n            D[n] = i\n            n += i\n\nTable = [0] * (M+1)\nans = 0\nfor d in range(1, M//N+1):\n    mo = Mobius(d)\n    if mo == 0:\n        continue\n    v = solve(d)\n    ans = (ans + mo * v) % MOD\n    # print(d, v, n)\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint l[maxn], r[maxn];\nint mu[maxn];\nint vis[maxn];\nint prim[maxn];\nint cnt = 0;\nlong long mod = 998244353;\nvoid get_mu(int n) {\n  mu[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (!vis[i]) {\n      prim[++cnt] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= cnt && prim[j] * i <= n; j++) {\n      vis[prim[j] * i] = 1;\n      if (i % prim[j] == 0)\n        break;\n      else\n        mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nlong long dp[55][maxn];\nlong long sum[maxn];\nint main() {\n  int n, m;\n  get_mu(maxn - 1);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &l[i], &r[i]);\n  long long ans = 0;\n  for (int d = 1; d <= m; d++) {\n    dp[0][0] = 1;\n    long long cnt = 0;\n    for (int i = 1; i <= n; i++) {\n      sum[0] = dp[i - 1][0];\n      for (int j = 1; j <= m / d; j++) {\n        sum[j] = sum[j - 1] + dp[i - 1][j];\n      }\n      for (int j = ((l[i] + d - 1) / d); j <= m / d; j++) {\n        if (j - r[i] / d - 1 < 0)\n          dp[i][j] = sum[j - ((l[i] + d - 1) / d)];\n        else\n          dp[i][j] = sum[j - ((l[i] + d - 1) / d)] - sum[j - r[i] / d - 1];\n        dp[i][j] %= mod;\n      }\n    }\n    for (int j = 1; j <= m / d; j++) {\n      cnt += dp[n][j];\n    }\n    ans += mu[d] * cnt;\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 55, M = 100005, P = 998244353;\nlong long n, m, l[N], r[N], f[N][M], ans[M];\nsigned main() {\n  std::cin >> n >> m;\n  for (long long i = 1; i <= n; i++) std::cin >> l[i] >> r[i];\n  for (long long g = m / n; g >= 1; g--) {\n    for (long long i = 0; i <= n; i++)\n      for (long long j = 0; j <= m / g + 1; j++) f[i][j] = 0;\n    for (long long j = 0; j <= m / g + 1; j++) f[0][j] = j + 1;\n    for (long long i = 1; i <= n; i++) {\n      long long L = (l[i] + g - 1) / g, R = r[i] / g;\n      for (long long a = 0; a <= m / g + 1; a++) {\n        long long cl = a + L, cr = std::min(a + R, m / g);\n        if (cl > cr)\n          f[i][a] = 0;\n        else\n          f[i][a] = (f[i - 1][cr] - (cl ? f[i - 1][cl - 1] : 0) + P) % P;\n        if (a > 0) f[i][a] = (f[i][a] + f[i][a - 1]) % P;\n      }\n    }\n    ans[g] = f[n][0];\n    for (long long i = 2 * g; i <= m; i += g)\n      ans[g] = (ans[g] - ans[i] + P) % P;\n  }\n  std::cout << ans[1];\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\nfrom math import ceil\n\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\ndef write(w):\n    sys.stdout.write(w)\n    sys.stdout.write(\"\\n\")\n\ndef solve():\n    \n    ways = [0] * (M+1)\n    \n    for d in range(M,0,-1): \n        m = M//d\n        dp = [0 for j in range(m+1)]\n        dp[0] = 1\n        pref = [0 for _ in range(m+1)]\n        f = True\n        \n        for i in range(1,N+1):\n            l = D[i-1][0]\n            r = D[i-1][1]\n            l = (l+d-1) // d\n            r //= d\n            \n            if l>r:\n                f = False\n                break\n            \n            pref[0] = dp[0]\n            for j in range(1,m+1):\n                pref[j] = (pref[j-1] + dp[j]) % MOD\n            \n            for j in range(1,m+1):\n                a = b = 0\n                if j >= l:\n                    a = pref[j-l]\n                if j >= r+1:\n                    b = pref[j-r-1]\n                dp[j] = a - b\n                dp[j] %= MOD\n            dp[0] = 0\n        \n        v = sum(dp[j] for j in range(1,m+1))\n        if f:\n            ways[d] = v\n            for j in range(2*d,M+1,d):\n                ways[d] -= ways[j]\n                ways[d] %= MOD\n    \n    return str(ways[1]%MOD)\n\nMOD = 998244353\nT = 1\nfor test in range(1,T+1):\n    N,M = map(int,line())\n    D = []\n    for _ in range(N):\n        l,r = map(int,line())\n        D.append((l,r))\n    \n    write(solve())\n    \nf.close()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rng(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long cdiv(long long a, long long b) {\n  return a / b + ((a ^ b) > 0 && a % b);\n}\nlong long fdiv(long long a, long long b) {\n  return a / b - ((a ^ b) < 0 && a % b);\n}\nlong long gcd(long long a, long long b) {\n  return (b == 0LL ? a : gcd(b, a % b));\n}\nlong long exp(long long b, long long e, long long m) {\n  b %= m;\n  long long ans = 1;\n  for (; e; b = b * b % m, e /= 2)\n    if (e & 1) ans = ans * b % m;\n  return ans;\n}\nvoid dbg_out() { cerr << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nconst int N = 100100;\nint l[N], r[N];\nlong long dp[N], pre[N];\nconst int M = 998244353;\nlong long tot[N];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i < (n + 1); ++i) cin >> l[i] >> r[i];\n  for (int V = 1; V < (m + 1); ++V) {\n    int mx = m / V;\n    for (int i = 0; i < (mx + 1); ++i) pre[i] = dp[i] = 0;\n    dp[0] = 1;\n    for (int i = 0; i < (mx + 1); ++i) pre[i] = 1;\n    int bad = 0;\n    for (int k = 1; k < (n + 1); ++k) {\n      int L = (l[k] + V - 1) / V;\n      int R = r[k] / V;\n      if (R == 0 || L > R) {\n        bad = 1;\n        break;\n      }\n      for (int i = 0; i < (mx + 1); ++i) {\n        if (i - L >= 0)\n          dp[i] = (M + pre[i - L] - (i - R - 1 >= 0 ? pre[i - R - 1] : 0)) % M;\n        else\n          dp[i] = 0;\n      }\n      for (int i = 0; i < (mx + 1); ++i) {\n        pre[i] = dp[i] % M;\n        if (i) pre[i] = (pre[i] + pre[i - 1]) % M;\n      }\n    }\n    tot[V] = (bad ? 0 : pre[mx]);\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i * 2; j <= m; j += i) {\n      tot[i] -= tot[j];\n      tot[i] %= M;\n      if (tot[i] < 0) tot[i] += M;\n    }\n  }\n  cout << tot[1] << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid _R(T &x) {\n  cin >> x;\n}\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(long long &x) { scanf(\"%lld\", &x); }\nvoid _R(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate <class T, class... U>\nvoid R(T &head, U &...tail) {\n  _R(head);\n  R(tail...);\n}\ntemplate <class T>\nvoid _W(const T &x) {\n  cout << x;\n}\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const long long &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate <class T, class U>\nvoid _W(const pair<T, U> &x) {\n  _W(x.first);\n  putchar(' ');\n  _W(x.second);\n}\ntemplate <class T>\nvoid _W(const vector<T> &x) {\n  for (auto i = x.begin(); i != x.end(); _W(*i++))\n    if (i != x.cbegin()) putchar(' ');\n}\nvoid W() {}\ntemplate <class T, class... U>\nvoid W(const T &head, const U &...tail) {\n  _W(head);\n  putchar(sizeof...(tail) ? ' ' : '\\n');\n  W(tail...);\n}\nconst int MOD = 998244353, mod = 998244353;\nlong long qpow(long long a, long long b) {\n  long long res = 1;\n  a %= MOD;\n  assert(b >= 0);\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % MOD;\n    a = a * a % MOD;\n  }\n  return res;\n}\nconst int MAXN = 4e5 + 10, MAXM = 2e6 + 10;\nconst int INF = INT_MAX, SINF = 0x3f3f3f3f;\nconst long long llINF = LLONG_MAX, SLINF = 0x3f3f3f3f3f3f3f3f;\nconst int inv2 = (MOD + 1) / 2;\nconst int Lim = 1 << 20;\nbool ispri[MAXM];\nint p[MAXN], mu[MAXM], phi[MAXM], pcnt;\nvoid get_pri(int n) {\n  ispri[1] = mu[1] = phi[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (!ispri[i]) p[++pcnt] = i, mu[i] = -1, phi[i] = i - 1;\n    for (int j = 1; j <= pcnt && i * p[j] <= n; j++) {\n      ispri[i * p[j]] = 1;\n      if (i % p[j] == 0) {\n        phi[i * p[j]] = p[j] * phi[i];\n        break;\n      }\n      mu[i * p[j]] = -mu[i];\n      phi[i * p[j]] = phi[i] * (p[j] - 1);\n    }\n  }\n}\nint n, m;\nint l[MAXN], r[MAXN];\ntemplate <int _P>\nstruct Modint {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  Modint() : v(0) {}\n  Modint(long long _v) {\n    v = _v % P;\n    if (v < 0) v += P;\n  }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  explicit operator bool() const { return v > 0; }\n  bool operator==(const Modint &o) const { return v == o.v; }\n  bool operator!=(const Modint &o) const { return v != o.v; }\n  Modint operator-() const { return Modint(v ? P - v : 0); }\n  Modint operator+() const { return *this; }\n  Modint &operator++() {\n    v++;\n    if (v == P) v = 0;\n    return *this;\n  }\n  Modint &operator--() {\n    if (v == 0) v = P;\n    v--;\n    return *this;\n  }\n  Modint operator++(int) {\n    Modint r = *this;\n    ++*this;\n    return r;\n  }\n  Modint operator--(int) {\n    Modint r = *this;\n    --*this;\n    return r;\n  }\n  Modint &operator+=(const Modint &o) {\n    v += o.v;\n    if (v >= P) v -= P;\n    return *this;\n  }\n  Modint operator+(const Modint &o) const { return Modint(*this) += o; }\n  Modint &operator-=(const Modint &o) {\n    v -= o.v;\n    if (v < 0) v += P;\n    return *this;\n  }\n  Modint operator-(const Modint &o) const { return Modint(*this) -= o; }\n  Modint &operator*=(const Modint &o) {\n    v = (int)(((long long)v) * o.v % P);\n    return *this;\n  }\n  Modint operator*(const Modint &o) const { return Modint(*this) *= o; }\n  Modint &operator/=(const Modint &o) { return (*this) *= o.Inv(); }\n  Modint operator/(const Modint &o) const { return Modint(*this) /= o; }\n  Modint operator+(const long long &o) const { return (*this) + (Modint)o; }\n  Modint operator-(const long long &o) const { return (*this) - (Modint)o; }\n  Modint operator*(const long long &o) const { return (*this) * (Modint)o; }\n  Modint operator^(long long o) const {\n    Modint r = 1, t = v;\n    while (o) {\n      if (o & 1) r *= t;\n      t *= t;\n      o >>= 1;\n    }\n    return r;\n  }\n  Modint operator~() { return (*this) ^ (P - 2); }\n  Modint Inv() const { return (*this) ^ (P - 2); }\n};\nusing mi = Modint<MOD>;\ntemplate <int P>\nvoid _W(Modint<P> x) {\n  printf(\"%d\", (int)x);\n}\ntemplate <int P>\nvoid _R(Modint<P> &x) {\n  long long t;\n  scanf(\"%lld\", &t);\n  x = t;\n}\nmi dp[MAXN], sum[MAXN], ans;\nvoid solve() {\n  R(n, m);\n  for (int i = 1; i <= n; i++) R(l[i], r[i]);\n  for (int d = 1; d <= m; d++) {\n    int M = m / d;\n    for (int i = 0; i <= M; i++) dp[i] = 0, sum[i] = 1;\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      int L = (l[i] + d - 1) / d, R = r[i] / d;\n      for (int j = 0; j <= M; j++) dp[j] = 0;\n      for (int j = 0; j <= M; j++) {\n        int tl = j - R - 1, tr = j - L;\n        if (tr >= 0) dp[j] += sum[tr];\n        if (tl >= 0) dp[j] -= sum[tl];\n      }\n      for (int j = 0; j <= M; j++) {\n        sum[j] = dp[j];\n        if (j) sum[j] += sum[j - 1];\n      }\n    }\n    ans += ((mi)mu[d]) * sum[M];\n  }\n  W(ans);\n}\nint main() {\n  get_pri(200000);\n  int T = 1;\n  for (int kase = 1; kase <= T; kase++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 10, mod = 998244353;\nlong long prim[N], nump, mu[N], vis[N], l[N], r[N];\nlong long f[55][N], sum[N];\nint n, m;\nvoid init() {\n  mu[1] = 1;\n  for (int i = 2; i <= N - 1; i++) {\n    if (!vis[i]) {\n      prim[++nump] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= nump && i * prim[j] <= N - 1; j++) {\n      vis[i * prim[j]] = 1;\n      if (i % prim[j] == 0)\n        break;\n      else\n        mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  init();\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", l + i, r + i);\n  long long ans = 0;\n  for (int d = 1; d <= m; d++) {\n    f[0][0] = 1;\n    long long cnt = 0;\n    for (int i = 1; i <= n; i++) {\n      sum[0] = f[i - 1][0];\n      for (int j = 1; j <= m / d; j++) sum[j] = sum[j - 1] + f[i - 1][j];\n      for (int j = (l[i] + d - 1) / d; j <= m / d; j++) {\n        if (j - r[i] / d - 1 < 0)\n          f[i][j] = sum[j - (l[i] + d - 1) / d];\n        else\n          f[i][j] = sum[j - (l[i] + d - 1) / d] - sum[j - r[i] / d - 1];\n        f[i][j] %= mod;\n      }\n    }\n    for (int j = 1; j <= m / d; j++) cnt += f[n][j];\n    ans += cnt * mu[d];\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 5e5 + 5;\nconst long double PI = 3.14159265358979323846;\nconst long double eps = 1e-11;\nconst long long INF = 1.5e18;\nconst long long inf = 1e9;\nconst long long M = 998244353;\nconst string IO[2]{\"NO\\n\", \"YES\\n\"};\nconst string Io[2]{\"No\\n\", \"Yes\\n\"};\nconst string io[2]{\"no\\n\", \"yes\\n\"};\nconst string bads = \"-1\\n\";\ntemplate <class T1, class T2>\nistream& operator>>(istream& in, pair<T1, T2>& a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2>& a) {\n  out << a.first << ' ' << a.second;\n  return out;\n}\ntemplate <class T>\nistream& operator>>(istream& in, vector<T>& a) {\n  for (auto& el : a) {\n    in >> el;\n  }\n  return in;\n}\ntemplate <class T>\nostream& operator<<(ostream& out, vector<T>& a) {\n  for (auto& el : a) {\n    out << el << ' ';\n  }\n  return out;\n}\nlong long cnt[100005];\nvoid solve() {\n  long long n, qm;\n  cin >> n >> qm;\n  vector<long long> ql(n), qr(n);\n  for (long long i = 0; i < n; ++i) {\n    cin >> ql[i] >> qr[i];\n  }\n  for (long long v = 1; v <= qm; ++v) {\n    bool can = 1;\n    vector<long long> l(n), r(n);\n    for (long long i = 0; i < n; ++i) {\n      r[i] = qr[i] / v;\n      l[i] = (ql[i] + v - 1) / v;\n      if (l[i] > r[i]) {\n        can = 0;\n        break;\n      }\n    }\n    if (!can) continue;\n    long long m = qm / v;\n    vector<vector<long long> > dp(n + 1, vector<long long>(m + 1, 0));\n    vector<vector<long long> > sum(n + 1, vector<long long>(m + 1, 0));\n    dp[0][0] = 1;\n    for (long long i = 0; i <= m; ++i) {\n      sum[0][i] = 1;\n    }\n    for (long long i = 1; i <= n; ++i) {\n      for (long long j = 1; j <= m; ++j) {\n        if (j - l[i - 1] < 0)\n          dp[i][j] = 0;\n        else {\n          dp[i][j] = sum[i - 1][j - l[i - 1]];\n          if (j - r[i - 1] > 0) dp[i][j] -= sum[i - 1][j - r[i - 1] - 1];\n          sum[i][j] = (sum[i][j - 1] + dp[i][j]) % M;\n        }\n      }\n    }\n    for (long long i = 0; i <= m; ++i) {\n      cnt[v] += dp[n][i];\n      cnt[v] %= M;\n    }\n  }\n  long long ans = cnt[1];\n  vector<long long> use(qm + 1, 0);\n  for (long long i = 2; i <= qm; ++i) {\n    long long now = M + 1 - use[i];\n    now %= M;\n    ans += M - (now * cnt[i]) % M;\n    ans %= M;\n    for (long long j = 0; j <= qm; j += i) {\n      use[j] += now;\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 7, M = 50 + 7, mod = 998244353;\nint prime[N], mu[N], l[M], r[M], r_[M], sum_[N], sum[N], dp[M][N];\nbool p[N];\ninline void init(int n) {\n  int cnt = 0;\n  p[0] = p[1] = true;\n  mu[1] = 1;\n  for (register int i = 2; i <= n; i++) {\n    if (!p[i]) {\n      prime[++cnt] = i;\n      mu[i] = -1;\n    }\n    for (register int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n      int t = i * prime[j];\n      p[t] = true;\n      if (i % prime[j] == 0) {\n        mu[t] = 0;\n        break;\n      }\n      mu[t] = -mu[i];\n    }\n  }\n}\ninline int min(int a, int b) { return a < b ? a : b; }\ninline int do_dp(int n, int m) {\n  int ans = 0;\n  for (register int i = 0; i <= m; i++) {\n    sum_[i] = 1;\n  }\n  for (register int i = 1; i <= n; i++) {\n    for (register int j = 0; j <= m; j++) {\n      int t = min(r_[i], j);\n      if (i == n) ans = (ans + sum_[t]) % mod;\n      sum[j] = sum_[t];\n      if (j > 0) sum[j] = (sum[j] + sum[j - 1]) % mod;\n    }\n    for (register int j = 0; j <= m; j++) {\n      sum_[j] = sum[j];\n    }\n  }\n  return ans;\n}\nint main() {\n  int n, m, mi, ans = 0;\n  scanf(\"%d %d\", &n, &m);\n  mi = m + 1;\n  init(m);\n  for (register int i = 1; i <= n; i++) {\n    scanf(\"%d %d\", &l[i], &r[i]);\n  }\n  for (register int i = 1; i <= m; i++) {\n    int sum = 0, tm = m / i;\n    for (register int k = 1; k <= n; k++) {\n      int tl = (l[k] - 1) / i + 1;\n      r_[k] = r[k] / i - tl;\n      sum = min(sum + tl, mi);\n    }\n    if (tm >= sum) ans = ((ans + mu[i] * do_dp(n, tm - sum)) % mod + mod) % mod;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import deque,Counter\nfrom sys import stdin\n\n#sys.setrecursionlimit(10**7)\nint1=lambda x: int(x)-1\n\ninp=lambda :int(input())\nmi=lambda :map(int,input().split())\nli=lambda :list(mi())\nmi1=lambda :map(int1,input().split())\nli1=lambda :list(mi1())\nmis=lambda :map(str,input().split())\nlis=lambda :list(mis())\n\nstinput=lambda :stdin.readline()[:-1]\nstinp=lambda :int(stinput())\nstmi=lambda :map(int, stdin.readline().split())\nstli=lambda :list(stmi())\nstmi1=lambda :map(int1, stdin.readline().split())\nstli1=lambda :list(stmi1())\nstmis=lambda :stdin.readline()[:-1]\n\npr=print\n\nfrom collections import defaultdict\n\"\"\"\n#\u521d\u671f\u5024 0\nd=defaultdict(int)\n\n#\u521d\u671f\u5024 1\nd=defaultdict(lambda:1)\n\"\"\"\n\nmod=10**9+7\nMod=998244353\nINF=10**18\nans=0\n\nn,m=mi()\nx=[]\nfor i in range(n):\n  a,b=mi()\n  x.append((a,b))\n\ndef f(k):\n  dp=[0]*(m//k+1)\n  t=m//k+1\n  dp[0]=1\n  for a,b in x:\n    dp2=[0]*t\n    c=(a+k-1)//k\n    d=b//k\n    cnt=0\n    for i in range(c,t):\n      cnt+=dp[i-c]\n      if i>d:\n        cnt-=dp[i-d-1]\n      cnt%=Mod\n      dp2[i]=cnt\n    dp=dp2.copy()\n  #print(m,dp)\n  return sum(dp)%Mod\n\ntmp=[0]*(m+1)\nfor i in range(m,0,-1):\n  t=f(i)\n  j=2*i\n  while j<=m:\n    t-=tmp[j]\n    j+=i\n  tmp[i]=t%Mod\nprint(tmp[1]%Mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 110000;\nconst long long modi = 998244353;\nlong long f[maxn], fact[maxn], dp[50][maxn], pre[50][maxn];\nint l[maxn], r[maxn], l2[maxn], r2[maxn], mu[maxn];\nbool prime[maxn];\nvector<int> p;\nlong long quickpow(long long base, long long times) {\n  long long ans = 1;\n  while (times) {\n    if (times & 1) ans = ans * base % modi;\n    base = base * base % modi;\n    times >>= 1;\n  }\n  return ans;\n}\nlong long inv(long long x) { return quickpow(x, modi - 2); }\nint upper_div(int x, int d) {\n  if (x % d == 0) return x / d;\n  return x / d + 1;\n}\ninline long long get_pre(int i, int l, int r) {\n  if (l > 0) return ((pre[i][r] - pre[i][l - 1]) % modi + modi) % modi;\n  return pre[i][r];\n}\nlong long tot(int n, int m) {\n  for (int i = 0; i <= m; i++) {\n    for (int j = 0; j <= n; j++) {\n      dp[j][i] = pre[j][i] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i <= m; i++) {\n    pre[0][i] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      dp[i][j] = get_pre(i - 1, j - r2[i], j);\n    }\n    pre[i][0] = dp[i][0];\n    for (int j = 1; j <= m; j++) {\n      pre[i][j] = (pre[i][j - 1] + dp[i][j]) % modi;\n    }\n  }\n  return pre[n][m];\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  fact[0] = 1;\n  for (int i = 1; i <= n + m; i++) {\n    fact[i] = fact[i - 1] * i % modi;\n  }\n  mu[1] = 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  for (int i = 2; i <= m; i++) {\n    if (prime[i] == false) {\n      mu[i] = -1;\n      p.push_back(i);\n    }\n    for (auto v : p) {\n      if (i * v > m) break;\n      mu[i * v] = mu[i] * (-1);\n      prime[i * v] = true;\n      if (i % v == 0) {\n        mu[i * v] = 0;\n        break;\n      }\n    }\n  }\n  long long ret = 0;\n  for (int d = 1; d <= m; d++) {\n    int m2 = m / d;\n    bool tf = true;\n    for (int i = 1; i <= n; i++) {\n      l2[i] = upper_div(l[i], d);\n      m2 -= l2[i];\n      r2[i] = r[i] / d;\n      if (l2[i] > r2[i]) {\n        tf = false;\n        break;\n      }\n      r2[i] -= l2[i];\n    }\n    if (tf && m2 >= 0) {\n      ret = (ret + mu[d] * tot(n, m2)) % modi;\n      ret = (ret + modi) % modi;\n    }\n  }\n  cout << ret << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\nbool ckmin(T &a, const U &b) {\n  return b < a ? a = b, true : false;\n}\ntemplate <typename T, typename U>\nbool ckmax(T &a, const U &b) {\n  return b > a ? a = b, true : false;\n}\nconst int N = 1e5 + 5;\nconst long long MOD = 998244353;\nint n, m;\nvector<int> mobius, lpf;\nvector<array<int, 2>> ranges;\nvoid least_prime_factor() {\n  for (int i = 2; i < N; i++)\n    if (!lpf[i])\n      for (int j = i; j < N; j += i)\n        if (!lpf[j]) lpf[j] = i;\n}\nvoid Mobius() {\n  for (int i = 1; i < N; i++) {\n    if (i == 1)\n      mobius[i] = 1;\n    else {\n      if (lpf[i / lpf[i]] == lpf[i])\n        mobius[i] = 0;\n      else\n        mobius[i] = -1 * mobius[i / lpf[i]];\n    }\n  }\n}\nlong long solve(vector<array<int, 2>> &v, int sum) {\n  vector<long long> cur(sum + 1, 0), nxt(sum + 1, 0);\n  for (int i = v[0][0]; i <= v[0][1]; ++i) cur[i] = 1;\n  for (int j = 1; j < n; ++j) {\n    vector<long long> pc(sum + 2, 0);\n    for (int i = 0; i < sum + 1; ++i) {\n      pc[i + 1] = pc[i] + cur[i];\n      pc[i + 1] %= MOD;\n    }\n    auto first = [&](int l, int r) -> long long {\n      ckmax(l, 0);\n      ckmax(r, 0);\n      ckmin(l, sum);\n      ckmin(r, sum);\n      return pc[r + 1] - pc[l] + (pc[l] > pc[r + 1]) * MOD;\n    };\n    for (int i = 0; i <= sum; ++i) {\n      int l = i - v[j][1], r = i - v[j][0];\n      nxt[i] = first(l, r);\n    }\n    cur.swap(nxt);\n    nxt.clear();\n    pc.clear();\n    nxt.assign(sum + 1, 0);\n  }\n  long long res = 0;\n  for (auto i : cur) res += i;\n  return res % MOD;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  ranges.assign(n, array<int, 2>());\n  for (int i = 0; i < n; ++i) {\n    cin >> ranges[i][0] >> ranges[i][1];\n  }\n  long long res = 0;\n  lpf.assign(N, 0);\n  least_prime_factor();\n  mobius.assign(N, 0);\n  Mobius();\n  for (int g = 1; g <= m / n; ++g) {\n    int cur_m = m / g;\n    vector<array<int, 2>> cur_ranges = ranges;\n    for (auto &i : cur_ranges) {\n      i[0] = (i[0] - 1) / g + 1;\n      i[1] /= g;\n      if (i[1] < i[0]) goto nxt;\n    }\n    res += mobius[g] * solve(cur_ranges, cur_m);\n    res %= MOD;\n  nxt:;\n  }\n  cout << ((res % MOD) + MOD) % MOD;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(51);\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b) { return (a * b % MOD); }\nlong long sub(long long a, long long b) {\n  a -= b;\n  if (a < 0) a += MOD;\n  return a;\n}\nlong long add(long long a, long long b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n  return a;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long>> v(n);\n  vector<long long> ans(m + 1);\n  for (long long i = 0; i < n; i++) {\n    cin >> v[i].first >> v[i].second;\n  }\n  for (long long i = m; i >= 1; --i) {\n    long long val = (m / i + 1);\n    vector<long long> dp(val);\n    dp[0] = 1;\n    for (long long j = 0; j < n; ++j) {\n      long long first = ((v[j].first + i - 1) / i), brk = v[j].second / i;\n      vector<long long> dpp(val);\n      for (long long k = 1; k < val; k++) {\n        dp[k] = add(dp[k], dp[k - 1]);\n      }\n      for (long long f = 0; f < val; f++) {\n        if (f >= first) {\n          dpp[f] = dp[f - first];\n        }\n        if (f - brk - 1 >= 0) {\n          dpp[f] = sub(dpp[f], dp[f - brk - 1]);\n        }\n      }\n      dp = dpp;\n    }\n    for (long long f = i; f <= m; f += i) {\n      ans[i] = sub(ans[i], ans[f]);\n    }\n    for (long long j = 0; j < val; j++) {\n      ans[i] = add(ans[i], dp[j]);\n    }\n  }\n  cout << ans[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * check out my youtube channel sh0rkyboy\n * https://tinyurl.com/zdxe2y4z\n * I do screencasts, solutions, and other fun stuff in the future\n */\n\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\npublic class EdC {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[1];\n\t\n\tstatic int[] mu;\n\t\n\tstatic int[] isPrime;\n\t\n\t\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n\tpublic static void main(String[] largewang) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tint n = sc.nextInt();\n \t\t\n \t\tint m = sc.nextInt();\n \t\t\n \t\tint[][] intervals = new int[n][2];\n \t\t\n \t\tfor(int j =0 ;j<n;j++){\n \t\t\tintervals[j][0] = sc.nextInt();\n \t\t\tintervals[j][1] = sc.nextInt();\n \t\t\t\n \t\t}\n \t\t\n \t\tmobiusAndPrime(100000);\n \t\tlong ans = 0;\n \t\tfor (int j = 1;j<=100000;j++){\n \t\t\tboolean found = false;\n \t\t\tint[][] newOne = new int[n][2];\n \t\t\tint sum = 0;\n \t\t\tfor(int k = 0;k<n;k++){\n \t\t\t\tnewOne[k][0] = (intervals[k][0] - 1)/j + 1;\n \t\t\t\tsum += newOne[k][0];\n \t\t\t\t\n \t\t\t\tnewOne[k][1] = (intervals[k][1])/j;\n \t\t\t\t\n \t\t\t\tif (newOne[k][1] < newOne[k][0]){\n \t\t\t\t\tfound = true;\t\t\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (found)\n \t\t\t\tcontinue;\n \t\t\tans += mu[j]*ans(m/j, newOne, sum);\n \t\t\tans %= mod;\n \t\t\tans += mod;\n \t\t\tans %= mod;\n \t\t}\n \t\t\n \t\tout.println(ans);\n \t\tout.close();\n \t\t\n \t}\n\t\n\tpublic static long ans(int max, int[][] intervals, int sum) {\n\t\tif (sum > max)\n\t\t\treturn 0;\n\t\tlong[] num = new long[max-sum+1];\n\t\tnum[0] = 1;\n\t\tfor (int j = 0;j<intervals.length;j++){\n//\t\t\tfor(int k = max;k>=0;k--){\n//\t\t\t\t long val = ls.querySum(k,  k);\n//\t\t\t\t if (val != 0){\n//\t\t\t\t\t ls.update(k+intervals[j][0], min(k+intervals[j][1], max), val); \n//\t\t\t\t\t ls.update(k,  k, mod-val);\n//\t\t\t\t }\n//\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint val = intervals[j][1] - intervals[j][0];\n\t\t\tlong cumSum = 0;\n\t\t\tfor (int k = max-sum;k >= max(0, max-sum-val);k--)\n\t\t\t\tcumSum += num[k];\n\t\t\tfor (int k = max-sum;k>=0;k--){\n\t\t\t\t\n\t\t\t\tlong prev = num[k];\n\t\t\t\tnum[k] = cumSum%mod;\n\t\t\t\tcumSum -= prev;\n\t\t\t\tif (k >= val+1)\n\t\t\t\t\tcumSum += num[k-val-1];\n\t\t\t\tcumSum%=mod;\n\t\t\t\tcumSum+=mod;\n\t\t\t\tcumSum%=mod;\n\t\t\t}\n\t\t}\n\t\tlong finalSum = 0;\n\t\tfor(int j = 0;j<=max-sum;j++){\n\t\t\tfinalSum+=num[j];\n\t\t\tfinalSum%=mod;\n\t\t}\n\t\treturn finalSum;\n\t}\n\tpublic static void mobiusAndPrime(int n){\n\t\tisPrime = new int[n+1];\n\t\tArrays.fill(isPrime, 1);\n\t\tmu = new int[n+1];\n\t\tArrays.fill(mu,  1);\n\t\tfor(long i = 2;i<=n;i++){\n\t\t\tif (isPrime[(int)i] == 1){\n\t\t\t\tfor(long j = i;j<=n;j+=i){\n\t\t\t\t\tif (j > i)\n\t\t\t\t\t\tisPrime[(int)j] = 0;\n\t\t\t\t\tif (j%(i*i) == 0)\n\t\t\t\t\t\tmu[(int)j] = 0;\n\t\t\t\t\tmu[(int)j] = -mu[(int)j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n    \n\n    \tstatic class LazySegmentTree {\n    \t\tint size;\n    \t\tprivate long[] sum;\n    \t\tprivate long[] lazy;\n    \t\tpublic LazySegmentTree(long[] array){\n    \t\t\tsize = array.length;\n    \t\t\tsum=new long[array.length*4];\n    \t\t\tlazy=new long[array.length*4];\n    \t\t\tbuildTree(array,1,0,size-1);\n    \t\t}\n\n    \t\tprivate void buildTree(long[] array, int position, int front, int end){\n    \t\t\t//Basis case for returning the elements itself\n    \t\t\tif(front==end){\n    \t\t\t\tsum[position]=array[front];\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t\t//Building trees by dividing into two subtrees\n    \t\t\tbuildTree(array, position*2,front,(front+end)/2);\n    \t\t\tbuildTree(array, position*2+1,(front+end)/2+1,end);\n\n    \t\t\trecalc(position,front,end);\n    \t\t}\n\n    \t\tprivate void recalc(int position, int front, int end) {\n    \t\t\tsum[position]=(getSum(position*2,front,(front+end)/2)+getSum(position*2+1,(front+end)/2+1,end));\n    \t\t\t\n    \t\t\tif (sum[position] >= mod)\n    \t\t\t\tsum[position] -= mod;\n    \t\t}\n\n\n    \t\tprivate long getSum(int position,int front,int end){\n    \t\t\treturn (sum[position]+lazy[position]*(long)(end-front+1))%mod;\n    \t\t}\n\n    \t\tpublic long querySum(int queryFront, int queryEnd) {\n    \t\t\treturn querySum(1,0,size-1,queryFront,queryEnd);\n    \t\t}\n\n    \t\tprivate long querySum(int position,int front,int end, int queryFront, int queryEnd){\n    \t\t\t//Case for entirely inclusive\n    \t\t\tif(front>=queryFront&&queryEnd>=end){\n    \t\t\t\treturn getSum(position,front,end);\n    \t\t\t}\n    \t\t\t//Case for entirely exclusive\n    \t\t\tif(end<queryFront||queryEnd<front){\n    \t\t\t\treturn 0;\n    \t\t\t}\n    \t\t\tpropagate(position,front,end);\n    \t\t\tlong leftAns=querySum(position*2,front,(front+end)/2,queryFront,queryEnd);\n    \t\t\tlong rightAns=querySum(position*2+1,(front+end)/2+1,end,queryFront,queryEnd);\n    \t\t\tif (leftAns+rightAns >= mod)\n    \t\t\t\t\n    \t\t\t\treturn leftAns+rightAns-mod;\n    \t\t\treturn leftAns+rightAns;\n    \t\t}\n\n\n    \t\tprivate void propagate(int position,int front, int end){\n    \t\t\tlazy[position*2]+=lazy[position];\n    \t\t\t\n    \t\t\tif (lazy[position*2] >= mod)\n    \t\t\t\tlazy[position*2] -= mod;\n    \t\t\tlazy[position*2+1]+=lazy[position];\n    \t\t\t\n    \t\t\tif (lazy[position*2+1] >= mod)\n    \t\t\t\tlazy[position*2+1] -= mod;\n    \t\t\tsum[position]=getSum(position,front,end);\n    \t\t\tlazy[position]=0;\n    \t\t\t//Set the propagation to 0 so that it will not propagate the value again and again\n    \t\t}\n\n    \t\tpublic void update(int updateFront, int updateEnd, long value){\n    \t\t\tupdate(1,0,size-1,updateFront,updateEnd,value);\n    \t\t}\n\n    \t\tprivate void update(int position, int front, int end, int updateFront,int updateEnd,long value){\n    \t\t\t//Case for entirely inclusive\n    \t\t\tif(front>=updateFront&&updateEnd>=end){\n    \t\t\t\tlazy[position]+=value;\n    \t\t\t\tif (lazy[position] >= mod)\n        \t\t\t\tlazy[position] -= mod;\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t\t//Case for entirely exclusive\n    \t\t\tif(end<updateFront||updateEnd<front){\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t\tpropagate(position,front,end);\n    \t\t\tupdate(position*2,front,(front+end)/2,updateFront,updateEnd,value);\n    \t\t\tupdate(position*2+1,(front+end)/2+1,end,updateFront,updateEnd,value);\n    \t\t\trecalc(position,front,end);\n    \t\t}\n    \t}\n    \n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <long long mod>\nstruct modular {\n  long long value;\n  modular(long long x = 0) {\n    value = x % mod;\n    if (value < 0) value += mod;\n  }\n  modular& operator+=(const modular& other) {\n    if ((value += other.value) >= mod) value -= mod;\n    return *this;\n  }\n  modular& operator-=(const modular& other) {\n    if ((value -= other.value) < 0) value += mod;\n    return *this;\n  }\n  modular& operator*=(const modular& other) {\n    value = value * other.value % mod;\n    return *this;\n  }\n  modular& operator/=(const modular& other) {\n    long long a = 0, b = 1, c = other.value, m = mod;\n    while (c != 0) {\n      long long t = m / c;\n      m -= t * c;\n      swap(c, m);\n      a -= t * b;\n      swap(a, b);\n    }\n    a %= mod;\n    if (a < 0) a += mod;\n    value = value * a % mod;\n    return *this;\n  }\n  modular operator+(const modular& rhs) const { return modular(*this) += rhs; }\n  modular operator-(const modular& rhs) const { return modular(*this) -= rhs; }\n  modular operator*(const modular& rhs) const { return modular(*this) *= rhs; }\n  modular operator/(const modular& rhs) const { return modular(*this) /= rhs; }\n  modular& operator++() { return *this += 1; }\n  modular& operator--() { return *this -= 1; }\n  modular operator++(int) {\n    modular res(*this);\n    *this += 1;\n    return res;\n  }\n  modular operator--(int) {\n    modular res(*this);\n    *this -= 1;\n    return res;\n  }\n  modular operator-() const { return modular(-value); }\n  bool operator==(const modular& rhs) const { return value == rhs.value; }\n  bool operator!=(const modular& rhs) const { return value != rhs.value; }\n  bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n  return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n  return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n  stream >> x.value;\n  x.value %= mod;\n  if (x.value < 0) x.value += mod;\n  return stream;\n}\nconstexpr long long mod = 998244353LL;\nusing mint = modular<mod>;\nmint power(mint a, long long n) {\n  mint res = 1;\n  while (n > 0) {\n    if (n & 1) {\n      res *= a;\n    }\n    a *= a;\n    n >>= 1;\n  }\n  return res;\n}\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\nmint C(int n, int k) {\n  if (n < k || k < 0) {\n    return mint(0);\n  }\n  while ((int)fact.size() < n + 1) {\n    fact.emplace_back(fact.back() * (int)fact.size());\n    finv.emplace_back(mint(1) / fact.back());\n  }\n  return fact[n] * finv[k] * finv[n - k];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int MAX = 100001;\n  vector<int> primes;\n  vector<int> spf(MAX);\n  vector<bool> is_prime(MAX, true);\n  is_prime[0] = is_prime[1] = false;\n  spf[0] = spf[1] = 1;\n  for (int i = 2; i < MAX; i++) {\n    if (!is_prime[i]) {\n      continue;\n    }\n    primes.emplace_back(i);\n    spf[i] = i;\n    if (1LL * i * i >= MAX) {\n      continue;\n    }\n    for (int j = i * i; j < MAX; j += i) {\n      if (is_prime[j]) {\n        is_prime[j] = false;\n        spf[j] = i;\n      }\n    }\n  }\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  vector<mint> a(m + 1);\n  vector<vector<mint>> dp(m + 1);\n  for (int i = 1; i <= m; i++) {\n    dp[i] = vector<mint>(m / i + 1);\n    dp[i][0] = 1;\n  }\n  for (int k = 0; k < n; k++) {\n    for (int i = 1; i <= m; i++) {\n      int x = (l[k] + i - 1) / i;\n      int y = r[k] / i;\n      vector<mint> new_dp(m / i + 1);\n      for (int j = 0; j <= m / i; j++) {\n        if (j != 0) {\n          new_dp[j] = new_dp[j - 1];\n        }\n        if (j >= x) {\n          new_dp[j] += dp[i][j - x];\n        }\n        if (j >= y + 1) {\n          new_dp[j] -= dp[i][j - y - 1];\n        }\n      }\n      swap(dp[i], new_dp);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    a[i] = accumulate(dp[i].begin(), dp[i].end(), mint(0));\n  }\n  for (int i = m; i > 1; i--) {\n    if (!is_prime[i]) {\n      continue;\n    }\n    for (int j = 1; i * j <= m; j++) {\n      a[j] -= a[i * j];\n    }\n  }\n  cout << a[1] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint add(int x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\nint p[2][100001];\nint get(int i, int l, int r) {\n  if (r < 0) return 0;\n  l = max(l, 0);\n  return add(p[i][r], mod - (l == 0 ? 0 : p[i][l - 1]));\n}\nvoid solution() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> f(m + 1);\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) cin >> l[i] >> r[i];\n  for (int d = 1; d <= m; d++) {\n    vector<int> L(n), R(n);\n    bool fail = false;\n    for (int i = 0; i < n; i++) {\n      L[i] = (l[i] + d - 1) / d;\n      R[i] = r[i] / d;\n      if (R[i] < L[i]) fail = true;\n    }\n    if (fail) continue;\n    int bound = m / d;\n    for (int i = 0; i <= 1; i++)\n      for (int j = 0; j <= bound; j++) p[i][j] = 0;\n    p[0][0] = 1;\n    for (int i = 1; i <= bound; i++) p[0][i] = 1;\n    int cur = 0, nxt = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= bound; j++)\n        p[nxt][j] = add(p[nxt][j], get(cur, j - R[i], j - L[i]));\n      for (int j = 1; j <= bound; j++)\n        p[nxt][j] = add(p[nxt][j], p[nxt][j - 1]);\n      for (int j = 0; j <= bound; j++) p[cur][j] = 0;\n      swap(cur, nxt);\n    }\n    f[d] = p[cur][bound];\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) f[i] = add(f[i], mod - f[j]);\n  }\n  cout << f[1];\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tc = 1;\n  while (tc--) {\n    solution();\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(n);\n  vector<int> r(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  vector<long long> ans(m + 1);\n  for (int d = 1; d <= m; ++d) {\n    vector<vector<long long>> dp(n + 1, vector<long long>(m / d + 1));\n    vector<long long> pre(m / d + 1);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n      int nl = (l[i] + d - 1) / d;\n      int nr = r[i] / d;\n      assert(nl > 0);\n      if (nl > nr) {\n        continue;\n      }\n      pre[0] = dp[i][0];\n      for (int j = 1; j <= m / d; ++j) {\n        pre[j] = (pre[j - 1] + dp[i][j]) % mod;\n      }\n      for (int j = nl; j <= m / d; ++j) {\n        dp[i + 1][j] += pre[j - nl];\n        dp[i + 1][j] += mod - (j - nr - 1 >= 0 ? pre[j - nr - 1] : 0);\n        dp[i + 1][j] %= mod;\n      }\n    }\n    ans[d] = accumulate(dp[n].begin(), dp[n].end(), 0ll) % mod;\n  }\n  for (int i = m; i >= 1; --i) {\n    for (int j = i + i; j <= m; j += i) {\n      ans[i] += mod - ans[j];\n      ans[i] %= mod;\n    }\n  }\n  cout << ans[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int N = 20000;\nconst int LG = 32 - __builtin_clz(N);\nconst int INF = 1e9;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int> > ran(n);\n  for (int i = 0; i < n; i++) {\n    int l, r;\n    cin >> l >> r;\n    ran[i] = {l, r};\n  }\n  int gcd = m / n;\n  vector<long long> ans(gcd + 1, 0);\n  for (int div = 1; div <= gcd; div++) {\n    int nm = m / div;\n    vector<long long> dp(nm + 1, 1);\n    vector<long long> sp(nm + 2, 0);\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = 0; j <= nm; j++) {\n        sp[j + 1] = (dp[j] + sp[j]) % MOD;\n      }\n      int l = (ran[i].first + div - 1) / div;\n      int r = ran[i].second / div;\n      if (l > r) continue;\n      for (int amo = 0; amo < l; amo++) dp[amo] = 0;\n      for (int amo = l; amo <= nm; amo++) {\n        int top = amo - l;\n        int bot = max(0, amo - r);\n        dp[amo] = (sp[top + 1] - sp[bot] + MOD) % MOD;\n      }\n    }\n    ans[div] = dp[nm];\n  }\n  for (int i = gcd; i > 0; i--) {\n    for (int j = 2 * i; j <= gcd; j += i) {\n      ans[i] = (ans[i] - ans[j] + MOD) % MOD;\n    }\n  }\n  if (gcd == 0)\n    cout << 0 << '\\n';\n  else\n    cout << ans[1] << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  int tt = 1;\n  while (tt--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\npair<int, int> a[55];\nlong long dp[55][100005], res[100005] = {0}, s[100005];\ninline void solve(int x) {\n  int g = m / x;\n  pair<int, int> b[55];\n  for (int i = 1; i <= n; i++) {\n    if (a[i].first % x == 0)\n      b[i].first = a[i].first / x;\n    else\n      b[i].first = a[i].first / x + 1;\n    b[i].second = a[i].second / x;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= g; j++) dp[i][j] = 0;\n  }\n  for (int i = 1; i <= g; i++) s[i] = 0;\n  for (int i = b[1].first; i <= b[1].second; i++) dp[1][i] = 1;\n  for (int i = 1; i <= n; i++) {\n    s[0] = 0;\n    for (int k = 1; k <= g; k++) {\n      int r = min(b[i].second, k), l = b[i].first;\n      if (r < l) continue;\n      dp[i][k] = (dp[i][k] + s[k - l] - s[k - r - 1]) % (long long)(998244353);\n    }\n    for (int k = 1; k <= g; k++) {\n      s[k] = (s[k - 1] + dp[i][k]) % (long long)(998244353);\n    }\n  }\n  res[x] = s[g];\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int l, r;\n    cin >> l >> r;\n    a[i] = {l, r};\n  }\n  for (int i = 1; i <= m; i++) {\n    solve(i);\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = 2 * i; j <= m; j += i) {\n      res[i] -= res[j];\n      res[i] = (res[i] + (long long)(998244353)) % (long long)(998244353);\n    }\n  }\n  cout << res[1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1e5 + 5;\nconst int mod = 998244353;\nint cnt, prime[maxn], mu[maxn], n, m;\nint l[maxn], r[maxn];\nll dp[maxn], sum[maxn], ans;\nbitset<maxn> vis;\nll solve(int d) {\n  int M = m / d, L, R;\n  for (int i = 1; i <= M; i++) dp[i] = 0;\n  dp[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    L = (l[i] + d - 1) / d, R = r[i] / d;\n    if (L > R) return 0;\n    sum[0] = dp[0];\n    for (int j = 1; j <= M; j++) sum[j] = sum[j - 1] + dp[j];\n    for (int j = 0; j <= M; j++)\n      dp[j] = ((j - L >= 0 ? sum[j - L] : 0) + mod -\n               (j - R - 1 >= 0 ? sum[j - R - 1] : 0)) %\n              mod;\n  }\n  ll ret = 0;\n  for (int i = 1; i <= M; i++) ret = (ret + dp[i]) % mod;\n  return ((ret % mod) + mod) % mod;\n}\nint main() {\n  int N = 1e5;\n  mu[1] = 1;\n  for (int i = 2; i <= N; i++) {\n    if (!vis[i]) prime[++cnt] = i, mu[i] = -1;\n    for (int j = 1; j <= cnt && i * prime[j] <= N; j++) {\n      vis[i * prime[j]] = 1;\n      if (i % prime[j] == 0) break;\n      mu[i * prime[j]] = -mu[i];\n    }\n  }\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d %d\", &l[i], &r[i]);\n  for (int i = 1; i <= m; i++) ans = (ans + 1ll * solve(i) * mu[i]) % mod;\n  printf(\"%lld\\n\", ((ans % mod) + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\n\nmax_n=10**5+1\nspf=[i for i in range(max_n)]\nprime=[True for i in range(max_n)]\nmobius=[0 for i in range(max_n)]\nprime[0]=prime[1]=False\nmobius[1]=1\nprimes=[]\nfor i in range(2,max_n):\n    if(prime[i]):\n        spf[i]=i\n        mobius[i]=-1\n        primes.append(i)\n    for j in primes:\n        prod=j*i\n        if(j>spf[i] or prod>=max_n):\n            break\n        spf[prod]=j\n        prime[prod]=False\n        if(spf[i]==j):\n            mobius[prod]=0\n        else:\n            mobius[prod]=-mobius[i]\n\nmod=998244353\nn,m=map(int,input().split())\nlower=[]\nupper=[]\nfor i in range(n):\n    l,r=map(int,input().split())\n    lower.append(l)\n    upper.append(r)\n    \ndef calc(low,high,n,m):\n    if(n>m):\n        return(0)\n    dp=[[0 for j in range(m+1)] for i in range(n+1)]\n    dp_pref=[[0 for j in range(m+1)] for i in range(n+1)]\n    for j in range(low[0],m+1):\n        if(j<=high[0]):\n            dp[1][j]=1\n        dp_pref[1][j]=dp[1][j]+dp_pref[1][j-1]\n    for i in range(2,n+1):\n        for j in range(1,m+1):\n            dp[i][j]=(dp_pref[i-1][max(j-low[i-1],0)]-dp_pref[i-1][max(j-high[i-1]-1,0)])%mod\n            dp_pref[i][j]=(dp[i][j]+dp_pref[i][j-1])%mod\n    return(sum(dp[n])%mod)\n\nans=calc(lower,upper,n,m)\nfor i in range(2,m):\n    low=[]\n    high=[]\n    for k in range(n):\n        low.append((lower[k]+i-1)//i)\n        high.append(upper[k]//i)\n    val=calc(low,high,n,m//i)\n    ans=(ans+mobius[i]*val)%mod\nprint(ans)\n        \n        \n        \n\n    \n    \n\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MAXM = 1e5 + 228;\nconstexpr int MOD = 998244353;\nint lp[MAXM];\narray<int, MAXM> dplast;\narray<int, MAXM> dp;\nint n;\nint f(int m, vector<pair<int, int>>& lr) {\n  for (int i = 0; i <= m; ++i) {\n    dplast[i] = 1;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < min(lr[i].first, m + 1); ++j) dp[j] = 0;\n    for (int j = lr[i].first; j <= m; ++j) {\n      dp[j] = dplast[j - lr[i].first];\n      if (j - lr[i].second - 1 >= 0) {\n        dp[j] -= dplast[j - lr[i].second - 1];\n      }\n      if (dp[j] < 0) dp[j] += MOD;\n    }\n    dplast[0] = dp[0];\n    for (int j = 1; j <= m; ++j) {\n      dplast[j] = dplast[j - 1] + dp[j];\n      if (dplast[j] >= MOD) dplast[j] -= MOD;\n    }\n  }\n  return dplast[m];\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> sim;\n  for (int i = 2; i <= MAXM; ++i) {\n    if (lp[i] == 0) {\n      lp[i] = i;\n      sim.push_back(i);\n    }\n    for (int j = 0; j < sim.size() && sim[j] <= lp[i] && i * sim[j] <= MAXM;\n         ++j) {\n      lp[sim[j] * i] = sim[j];\n    }\n  }\n  int m;\n  cin >> n >> m;\n  vector<pair<int, int>> lr(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> lr[i].first >> lr[i].second;\n  }\n  int ans = 0;\n  vector<pair<int, int>> lr2(n);\n  for (int d = 1; d <= m; ++d) {\n    int last = -1;\n    int cnt = 0;\n    int c = d;\n    while (c > 1) {\n      if (lp[c] == last) {\n        cnt = -1;\n        break;\n      }\n      last = lp[c];\n      c /= last;\n      ++cnt;\n    }\n    if (cnt == -1) continue;\n    for (int i = 0; i < n; ++i) {\n      lr2[i] = make_pair((lr[i].first + d - 1) / d, lr[i].second / d);\n    }\n    int add = f(m / d, lr2);\n    if (cnt & 1) {\n      ans -= add;\n      if (ans < 0) ans += MOD;\n    } else {\n      ans += add;\n      if (ans >= MOD) ans -= MOD;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid setIO(string name = \"\") {\n  cin.tie(0)->sync_with_stdio(0);\n  if ((int)name.size()) {\n    freopen((name + \".in\").c_str(), \"r\", stdin);\n    freopen((name + \".out\").c_str(), \"w\", stdout);\n  }\n}\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(const T &t, const V &...v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long N = 1e5 + 10;\nconst long long mod = 998244353;\nlong long n, m;\nlong long dp[55][N];\nlong long f[N];\nlong long l[55], r[55];\nlong long l1[55], r1[55];\nlong long construct_f(long long m) {\n  for (long long i = 0; i < (n + 1); ++i) {\n    for (long long j = 0; j < (m + 1); ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  for (ll i = 0; i < n; i++) {\n    ll r = 0;\n    for (ll j = 0; j <= m; j++) {\n      if (j >= l1[i]) {\n        r += dp[i][j - l1[i]];\n        if (r >= mod) r -= mod;\n      }\n      dp[i + 1][j] = r;\n      if (j >= r1[i]) {\n        r -= dp[i][j - r1[i]];\n        if (r < 0) r += mod;\n      }\n    }\n  }\n  long long res = 0;\n  for (long long j = 0; j <= m; ++j) {\n    res += dp[n][j];\n  }\n  return res % mod;\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 0; i < (n); ++i) {\n    cin >> l[i] >> r[i];\n  }\n  for (long long i = 1; i < (m + 1); ++i) {\n    long long max_l = -1;\n    for (long long j = 0; j < (n); ++j) {\n      l1[j] = 1e9, r1[j] = -1;\n      for (long long k = i; k <= m; k += i) {\n        if (l[j] <= k && k <= r[j]) {\n          l1[j] = min(l1[j], k);\n          r1[j] = k;\n        }\n      }\n      max_l = max(max_l, l1[j]);\n    }\n    if (max_l == 1e9) {\n      f[i] = 0;\n    } else {\n      for (long long j = 0; j < (n); ++j) {\n        l1[j] /= i, r1[j] /= i;\n      }\n      f[i] = construct_f(m / i);\n    }\n  }\n  for (long long i = m; i > 0; i--) {\n    for (long long j = 2 * i; j <= m; j += i) {\n      f[i] -= f[j];\n      if (f[i] < 0) {\n        f[i] += mod;\n      }\n    }\n  }\n  cout << f[1] << \"\\n\";\n}\nsigned main() {\n  setIO();\n  long long t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, mod = 998244353;\nlong long f[55][N], l[N], r[N], sum[N], prim[N], nump, vis[N], mu[N];\nvoid init() {\n  mu[1] = 1;\n  for (int i = 2; i < N; i++) {\n    if (!vis[i]) {\n      prim[++nump] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= nump && i * prim[j] < N; j++) {\n      vis[i * prim[j]] = 1;\n      if (i % prim[j] == 0)\n        break;\n      else\n        mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nint main() {\n  long long n, m;\n  scanf(\"%lld%lld\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%lld%lld\", l + i, r + i);\n  long long ans = 0;\n  init();\n  for (int d = 1; d <= m; d++) {\n    f[0][0] = 1;\n    long long cnt = 0;\n    for (int i = 1; i <= n; i++) {\n      sum[0] = f[i - 1][0];\n      for (int j = 1; j <= m / d; j++)\n        sum[j] = (sum[j - 1] + f[i - 1][j]) % mod;\n      for (int j = (l[i] + d - 1) / d; j <= m / d; j++) {\n        if (j >= r[i] / d)\n          f[i][j] = sum[j - (l[i] + d - 1) / d] - sum[j - r[i] / d - 1];\n        else\n          f[i][j] = sum[j - (l[i] + d - 1) / d];\n        f[i][j] = f[i][j] % mod;\n      }\n    }\n    for (int j = 1; j <= m / d; j++) cnt = (cnt + f[n][j]) % mod;\n    ans += mu[d] * cnt;\n    ans = ans % mod;\n    ans += mod;\n    ans = ans % mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> l(n), r(n);\n  for (long long i = 0; i < n; i++) cin >> l[i] >> r[i];\n  vector<long long> result(m + 1);\n  for (long long g = 1; g <= m; g++) {\n    long long to = m / g;\n    vector<long long> dp(to + 1, 1);\n    for (long long i = 0; i < n; i++) {\n      long long mn = (l[i] + g - 1) / g;\n      long long mx = r[i] / g;\n      if (mx < mn) {\n        dp[to] = 0;\n        break;\n      }\n      vector<long long> ndp(to + 1);\n      for (long long s = mn; s <= to; s++) {\n        ndp[s] =\n            (ndp[s - 1] + dp[s - mn] - (s - mx - 1 >= 0 ? dp[s - mx - 1] : 0)) %\n            MOD;\n        if (ndp[s] < 0) ndp[s] += MOD;\n      }\n      dp = ndp;\n    }\n    result[g] = dp[to];\n  }\n  for (long long g = m; g; g--) {\n    for (long long i = 2 * g; i <= m; i += g) {\n      result[g] -= result[i];\n      if (result[g] < 0) result[g] += MOD;\n    }\n  }\n  cout << result[1];\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst long long mod = 998244353;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - 48;\n    ch = getchar();\n  }\n  return x * f;\n}\nint mu[100007], ck[100007], prime[100007], tot;\ninline void init() {\n  mu[1] = 1;\n  for (int i = 2; i < 100007; i++) {\n    if (!ck[i]) prime[++tot] = i, mu[i] = -1;\n    for (int j = 1; j <= tot && i * prime[j] < 100007; j++) {\n      int now = i * prime[j];\n      ck[now] = 1;\n      if (i % prime[j])\n        mu[now] = -mu[i];\n      else {\n        mu[now] = 0;\n        break;\n      }\n    }\n  }\n}\nint t, n, m;\nstruct node {\n  int l, r;\n} a[57], aa[57];\nlong long sum[100007], dp[55][100007];\nlong long DP(int d) {\n  int mm = m / d;\n  for (int i = 1; i <= n; i++) {\n    aa[i].l = (a[i].l - 1) / d + 1;\n    aa[i].r = a[i].r / d;\n  }\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (aa[i].l > aa[i].r) return 0;\n    for (int j = 1; j <= mm; j++) {\n      if (i == 1 && j >= aa[i].l && j <= aa[i].r)\n        dp[i][j] = 1;\n      else if (i == 1)\n        dp[i][j] = 0;\n      else {\n        int le = max(0, j - aa[i].r - 1), ri = max(0, j - aa[i].l);\n        dp[i][j] = (sum[ri] - sum[le] + mod) % mod;\n      }\n    }\n    for (int j = 1; j <= mm; j++) sum[j] = (sum[j - 1] + dp[i][j]) % mod;\n  }\n  return sum[mm];\n}\nint main() {\n  t = 1;\n  while (t--) {\n    scanf(\"%d%d\", &n, &m);\n    init();\n    for (int i = 1; i <= n; i++) {\n      a[i].l = read(), a[i].r = read();\n    }\n    long long ans = 0;\n    for (int d = 1; d <= m; d++) {\n      if (!mu[d]) continue;\n      ans = (ans + DP(d) * mu[d] + mod) % mod;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (998244353);\nconst long long MAX_VALEURS = (200 * 1000);\nconst long long MAX_ETOILES = (50);\nlong long Ans[MAX_VALEURS];\nlong long DP[MAX_VALEURS];\npair<long long, long long> Bornes[MAX_ETOILES];\nlong long nbEtoiles, borneSup;\nlong long FindDP(long long d) {\n  long long borne = borneSup / d;\n  fill_n(DP + 1, borne, 0LL);\n  DP[0] = 1;\n  for (long long i = 0; i < nbEtoiles; i++) {\n    long long sum = 0;\n    long long inf = (Bornes[i].first + d - 1) / d, sup = Bornes[i].second / d;\n    for (long long j = inf; j <= sup; j++) {\n      sum += DP[borne - j];\n    }\n    sum %= MOD;\n    for (long long j = borne; j >= 0; j--) {\n      DP[j] = sum;\n      if (j >= inf) sum -= DP[j - inf];\n      if (j > sup) sum += DP[j - sup - 1];\n      sum %= MOD;\n      if (sum < 0) sum += MOD;\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= borne; i++) {\n    ans += DP[i];\n  }\n  return ans % MOD;\n}\nvoid Solve() {\n  scanf(\"%lld %lld\", &nbEtoiles, &borneSup);\n  for (long long i = 0; i < nbEtoiles; i++) {\n    scanf(\"%lld %lld\", &Bornes[i].first, &Bornes[i].second);\n  }\n  for (long long i = 1; i <= borneSup; i++) {\n    Ans[i] = FindDP(i);\n  }\n  for (long long i = borneSup; i > 0; i--) {\n    for (long long j = 2 * i; j <= borneSup; j += i) {\n      Ans[i] -= Ans[j];\n    }\n    Ans[i] %= MOD;\n    if (Ans[i] < 0) Ans[i] += MOD;\n  }\n  printf(\"%lld\\n\", Ans[1]);\n  return;\n}\nsigned main() {\n  long long nbTests = 1;\n  while (nbTests--) {\n    Solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, A[71], B[71], L[71], R[71], C[71], mm, s, DPF[100071],\n    DP[71][100071];\nvoid solve(long long t) {\n  long long m = mm / t;\n  s = 0;\n  for (long long i = 1; i <= n; ++i) {\n    L[i] = (A[i] - 1) / t + 1;\n    R[i] = B[i] / t;\n    s += L[i];\n    C[i] = R[i] - L[i];\n  }\n  m -= s;\n  if (m < 0) return;\n  for (long long j = 0; j <= m; ++j) DP[0][j] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    for (long long j = 0; j <= m; ++j) {\n      if (j - C[i] - 1 >= 0)\n        DP[i][j] = (DP[i - 1][j] - DP[i - 1][j - C[i] - 1]) % 998244353;\n      else\n        DP[i][j] = DP[i - 1][j];\n      if (j) DP[i][j] = (DP[i][j] + DP[i][j - 1]) % 998244353;\n    }\n  }\n  if (!DP[n][m]) {\n    DPF[t] = 0;\n    return;\n  }\n  DPF[t] = (DP[n][m] + 998244353) % 998244353;\n}\nsigned main() {\n  cin >> n >> mm;\n  for (long long i = 1; i <= n; ++i) cin >> A[i] >> B[i];\n  for (long long i = 1; i <= mm; ++i) solve(i);\n  for (long long i = mm; i >= 1; --i) {\n    for (long long j = 2 * i; j <= mm; j += i)\n      DPF[i] = (DPF[i] - DPF[j] + 998244353) % 998244353;\n  }\n  cout << DPF[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nconst long long N = 1e5 + 5;\nconst double eps = 1e-8;\nconst double PI = acos(-1);\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nlong long re() {\n  long long x;\n  scanf(\"%lld\", &x);\n  return x;\n}\nlong long qk(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % mod;\n    a = a * a % mod;\n    b /= 2;\n  }\n  return ans;\n}\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1}, dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint n, m;\nint l[100010], r[100010], f[100010], g[100010], a[100010];\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", l + i, r + i);\n  for (int k = 1; k <= m; k++) {\n    int mx = m / k;\n    f[0] = 1;\n    for (int i = 0; i <= mx; i++) g[i] = 1;\n    for (int i = 1; i <= n; i++) {\n      int mn = (l[i] - 1) / k + 1;\n      for (int j = mn; j <= mx; j++) {\n        f[j] = g[j - mn];\n        if (j >= r[i] / k + 1)\n          f[j] = ((f[j] - g[j - r[i] / k - 1]) % mod + mod) % mod;\n      }\n      for (int j = 0; j < mn; j++) g[j] = 0;\n      for (int j = mn; j <= mx; j++) g[j] = (g[j - 1] + f[j]) % mod;\n    }\n    a[k] = g[mx];\n  }\n  for (int i = m; i; i--)\n    for (int j = i * 2; j <= m; j += i)\n      a[i] = ((a[i] - a[j]) % mod + mod) % mod;\n  printf(\"%d\\n\", a[1]);\n}\nint main() {\n  int T = 1;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  os << '{';\n  string sep;\n  for (const auto &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\ntemplate <typename T, size_t size>\nostream &operator<<(ostream &os, const array<T, size> &arr) {\n  os << '{';\n  string sep;\n  for (const auto &x : arr) os << sep << x, sep = \", \";\n  return os << '}';\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\nvoid dbg_out() { cout << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cout << ' ' << H;\n  dbg_out(T...);\n}\nconst int N = 55, mod = 998244353, bit = 61;\nconst int M = 1e5 + 5;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint getRand(int l, int r) {\n  uniform_int_distribution<int> uid(l, r);\n  return uid(rng);\n}\ntemplate <const int &MOD>\nstruct _m_int {\n  int val;\n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = v;\n  }\n  static int mod_inv(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n    while (r != 0) {\n      int q = g / r;\n      g %= r;\n      swap(g, r);\n      x -= q * y;\n      swap(x, y);\n    }\n    return x < 0 ? x + m : x;\n  }\n  explicit operator int() const { return val; }\n  explicit operator int64_t() const { return val; }\n  _m_int &operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  _m_int &operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n    return x % m;\n    unsigned x_high = x >> 32, x_low = (unsigned)x;\n    unsigned quot, rem;\n    asm(\"divl %4\\n\" : \"=a\"(quot), \"=d\"(rem) : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n    return rem;\n  }\n  _m_int &operator*=(const _m_int &other) {\n    val = fast_mod((uint64_t)val * other.val);\n    return *this;\n  }\n  _m_int &operator/=(const _m_int &other) { return *this *= other.inv(); }\n  friend _m_int operator+(const _m_int &a, const _m_int &b) {\n    return _m_int(a) += b;\n  }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) {\n    return _m_int(a) -= b;\n  }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) {\n    return _m_int(a) *= b;\n  }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) {\n    return _m_int(a) /= b;\n  }\n  _m_int &operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n  _m_int &operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n  _m_int operator++(int) {\n    _m_int before = *this;\n    ++*this;\n    return before;\n  }\n  _m_int operator--(int) {\n    _m_int before = *this;\n    --*this;\n    return before;\n  }\n  _m_int operator-() const { return val == 0 ? 0 : MOD - val; }\n  bool operator==(const _m_int &other) const { return val == other.val; }\n  bool operator!=(const _m_int &other) const { return val != other.val; }\n  bool operator<(const _m_int &other) const { return val < other.val; }\n  bool operator<=(const _m_int &other) const { return val <= other.val; }\n  bool operator>(const _m_int &other) const { return val > other.val; }\n  bool operator>=(const _m_int &other) const { return val >= other.val; }\n  _m_int inv() const { return mod_inv(val); }\n  _m_int pow(int64_t p) const {\n    if (p < 0) return inv().pow(-p);\n    _m_int a = *this, result = 1;\n    while (p > 0) {\n      if (p & 1) {\n        result *= a;\n      }\n      a *= a;\n      p >>= 1;\n    }\n    return result;\n  }\n  friend ostream &operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\nint n, m;\nint l[N], r[N];\nmod_int dp[M];\nmod_int sum[N][M], prefSum[N][M];\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  int t = 1;\n  for (long long tc = 1; tc <= t; tc++) {\n    cin >> n >> m;\n    for (long long i = 1; i <= n; i++) {\n      cin >> l[i] >> r[i];\n    }\n    sum[0][0] = 1;\n    for (long long i = 0; i <= M - 1; i++) {\n      prefSum[0][i] = 1;\n    }\n    for (long long g = M - 1; g >= 1; g--) {\n      int maxSum = m / g;\n      for (long long i = 1; i <= n; i++) {\n        for (long long j = 0; j <= maxSum; j++) {\n          sum[i][j] = 0;\n        }\n        int currL = (l[i] + g - 1) / g;\n        int currR = (r[i]) / g;\n        for (long long j = currL; j <= currR; j++) {\n          int oldMax = j - currL;\n          sum[i][j] = prefSum[i - 1][oldMax];\n        }\n        for (long long j = 1 + currR; j <= maxSum; j++) {\n          int oldMax = j - currL;\n          int oldMin = j - currR;\n          sum[i][j] = prefSum[i - 1][oldMax] - prefSum[i - 1][oldMin - 1];\n        }\n        prefSum[i][0] = sum[i][0];\n        for (long long j = 1; j <= maxSum; j++) {\n          prefSum[i][j] = sum[i][j] + prefSum[i][j - 1];\n        }\n      }\n      dp[g] = prefSum[n][maxSum];\n      for (int i = 2 * g; i < M; i += g) {\n        dp[g] -= dp[i];\n      }\n    }\n    cout << dp[1] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing int64 = long long;\nconst int N = 100005;\nconst int Q = 998244353;\nint n, m, l[N], r[N];\nint f[2][N];\ninline void add(int &A, int B) {\n  A += B;\n  if (A >= Q) {\n    A -= Q;\n  }\n}\nbool v[N];\nint prime[N], tot;\nint mu[N];\nvoid init(int n) {\n  int i, j, x;\n  mu[1] = 1;\n  for (i = 2; i <= n; ++i) {\n    if (!v[i]) {\n      prime[tot++] = i;\n      mu[i] = -1;\n    }\n    for (j = 0; j < tot; ++j) {\n      x = i * prime[j];\n      if (x > n) break;\n      v[x] = 1;\n      if (i % prime[j] == 0) {\n        mu[x] = 0;\n        break;\n      } else {\n        mu[x] = -mu[i];\n      }\n    }\n  }\n}\nvoid work() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", l + i, r + i);\n  }\n  init(m);\n  int res = 0;\n  for (int d = 1; d <= m; ++d) {\n    if (mu[d] == 0) {\n      continue;\n    }\n    int K = m / d;\n    int cur = 0, nxt = 1;\n    memset(f[cur], 0, sizeof(int) * (K + 1));\n    f[cur][0] = 1;\n    for (int i = 0; i < n; ++i) {\n      memset(f[nxt], 0, sizeof(int) * (K + 1));\n      int L = (l[i] + d - 1) / d;\n      int R = r[i] / d;\n      for (int j = 0; j <= K; ++j) {\n        if (j + L <= K) {\n          add(f[nxt][j + L], f[cur][j]);\n        }\n        if (j + R + 1 <= K) {\n          add(f[nxt][j + R + 1], Q - f[cur][j]);\n        }\n      }\n      for (int j = 1; j <= K; ++j) {\n        add(f[nxt][j], f[nxt][j - 1]);\n      }\n      std::swap(cur, nxt);\n    }\n    int sum = 0;\n    for (int i = 0; i <= K; ++i) {\n      add(sum, f[cur][i]);\n    }\n    if (mu[d] > 0) {\n      add(res, sum);\n    } else {\n      add(res, Q - sum);\n    }\n  }\n  printf(\"%d\\n\", res);\n}\nint main() {\n  int T = 1;\n  while (T--) {\n    work();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunsigned long long MOD = 998244353;\nint main() {\n  int N, M, gmax = -1;\n  cin >> N >> M;\n  vector<pair<int, int>> l(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> l[i].first >> l[i].second;\n    gmax = max(gmax, l[i].second);\n  }\n  vector<bool> is_prime(gmax + 1, true);\n  is_prime[1] = false;\n  vector<int> mu(gmax + 1, 1);\n  vector<int> prime;\n  for (int i = 2; i <= gmax; ++i) {\n    if (is_prime[i]) {\n      prime.push_back(i);\n      mu[i] = -1;\n    }\n    for (auto p : prime) {\n      if (i * p > gmax) break;\n      is_prime[i * p] = false;\n      if (i % p == 0) {\n        mu[i * p] = 0;\n        break;\n      } else {\n        mu[i * p] = -mu[i];\n      }\n    }\n  }\n  unsigned long long ans = 0;\n  for (int i = 1; i <= gmax; ++i) {\n    if (mu[i] == 0) continue;\n    vector<pair<int, int>> rl(N);\n    bool flag = true;\n    for (int j = 0; j < N; ++j) {\n      rl[j] = {(l[j].first + i - 1) / i, l[j].second / i};\n      if (rl[j].first > rl[j].second) {\n        flag = false;\n        break;\n      }\n    }\n    if (!flag) continue;\n    int rM = M / i;\n    vector<unsigned long long> ps(rM + 1, 1);\n    for (int j = 0; j < N; ++j) {\n      vector<unsigned long long> ps2(rM + 1, 0);\n      for (int k = rl[j].first; k <= rM; ++k) {\n        unsigned long long t =\n            (ps[k - rl[j].first] + MOD -\n             (k - rl[j].second > 0 ? ps[k - rl[j].second - 1] : 0)) %\n            MOD;\n        ps2[k] = (ps2[k - 1] + t) % MOD;\n      }\n      swap(ps, ps2);\n    }\n    if (mu[i] == 1) {\n      (ans += ps[rM]) %= MOD;\n    } else {\n      (ans += MOD - ps[rM]) %= MOD;\n    }\n  }\n  printf(\"%llu\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst char nl = '\\n';\nconst ll mod = 998244353;\nconst int max_n = 50;\nconst int max_m = 1e5;\nconst int max_sum = max_n * max_m;\nint l[max_n + 1], r[max_n + 1];\nll f[max_m + 1];\nll cnt[max_m + 2][max_n + 1];\nll cnt_pref[max_m + 2][max_n + 1];\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  int l_sum = 0;\n  for (int i = 1; i <= n; i++) l_sum += l[i];\n  if (l_sum > m) {\n    cout << 0 << nl;\n    return;\n  }\n  for (int d = m / n; d >= 1; d--) {\n    int ms = m / d;\n    bool can = true;\n    for (int i = 1; i <= n; i++) {\n      can &= (l[i] + d - 1) / d * d <= r[i];\n    }\n    if (!can) continue;\n    for (int i = 0; i <= n; i++) {\n      for (int s = 0; s <= ms; s++) {\n        cnt[s][i] = cnt_pref[s][i] = 0;\n      }\n    }\n    cnt[0][0] = 1;\n    for (int s = 0; s <= ms; s++) cnt_pref[s][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int s = 0; s <= ms; s++) {\n        int left = max(0, s - r[i] / d), right = s - (l[i] + d - 1) / d;\n        if (left > right) continue;\n        ll range_sum = cnt_pref[right][i - 1];\n        if (left > 0) {\n          range_sum -= cnt_pref[left - 1][i - 1];\n          range_sum += mod;\n          range_sum %= mod;\n        }\n        cnt[s][i] = range_sum;\n        cnt_pref[s][i] = cnt[s][i];\n        if (s > 0) {\n          cnt_pref[s][i] += cnt_pref[s - 1][i];\n          cnt_pref[s][i] %= mod;\n        }\n      }\n    }\n    f[d] = cnt_pref[ms][n];\n    for (int d2 = 2 * d; d2 <= m; d2 += d) {\n      f[d] -= f[d2];\n      f[d] += mod;\n      f[d] %= mod;\n    }\n  }\n  cout << f[1] << nl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing PP = pair<ll, P>;\nconst ll n_ = 1e5 + 100, inf = 1e18, mod = 998244353, sqrtN = 333, p = 27,\n         m_ = 55;\nll dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\nll n, m, k, tc = 1, a, b, c, d, sum, x, y, z, w, base, ans;\nll gcd(ll x, ll y) {\n  if (!y) return x;\n  return gcd(y, x % y);\n}\nll mo[n_], L[n_], R[n_], dp[n_], pre[n_];\nvoid init_mobius() {\n  fill(mo, mo + n_, 1);\n  mo[1] = 1;\n  for (ll i = 2; i * i < n_; i++) {\n    if (mo[i] != 1) continue;\n    for (ll j = i; j < n_; j += i) mo[j] *= -i;\n    for (ll j = i * i; j < n_; j += i * i) mo[j] = 0;\n  }\n  for (ll i = 2; i < n_; i++) {\n    if (mo[i] == i)\n      mo[i] = 1;\n    else if (mo[i] == -i)\n      mo[i] = -1;\n    else if (mo[i] < 0)\n      mo[i] = 1;\n    else if (mo[i] > 0)\n      mo[i] = -1;\n  }\n}\nll f(ll x) {\n  ll M = m / x;\n  dp[0] = 1;\n  for (int i = 1; i <= M; i++) dp[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    int l = (L[i] + x - 1) / x, r = R[i] / x;\n    if (l > r) return 0;\n    pre[0] = dp[0];\n    for (int j = 1; j <= M; j++) pre[j] = pre[j - 1] + dp[j], pre[j] %= mod;\n    for (int j = 0; j <= M; j++) {\n      if (j - l >= 0)\n        dp[j] = pre[j - l];\n      else\n        dp[j] = 0;\n      if (j - r - 1 >= 0) dp[j] -= pre[j - r - 1];\n      dp[j] += mod;\n      dp[j] %= mod;\n    }\n  }\n  ll ret = 0;\n  for (int i = 1; i <= M; i++) ret += dp[i], ret %= mod;\n  return ret;\n}\nvoid solve() {\n  ans = 0;\n  init_mobius();\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> L[i] >> R[i];\n  for (int i = 1; i <= m; i++) ans += mo[i] * f(i), ans %= mod;\n  cout << (ans + mod) % mod;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  while (tc--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long calc(vector<pair<long long, long long>> a, long long sum) {\n  long long n = a.size();\n  long long dp[n + 1][sum + 1];\n  for (long long i = 0; i < n + 1; ++i) {\n    for (long long j = 0; j < sum + 1; ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  long long pref[n + 1][sum + 2];\n  for (long long k = 0; k < n + 1; ++k) {\n    for (long long i = 0; i < sum + 2; ++i) {\n      pref[k][i] = 0;\n    }\n  }\n  dp[0][0] = 1;\n  pref[0][0] = 0;\n  for (long long l = 1; l < sum + 2; ++l) {\n    pref[0][l] = (pref[0][l - 1] + dp[0][l - 1]) % mod;\n  }\n  for (long long i = 1; i <= n; ++i) {\n    for (long long s = 0; s <= sum; ++s) {\n      dp[i][s] += pref[i - 1][max(0ll, s - a[i - 1].first + 1)] -\n                  pref[i - 1][max(0ll, s - a[i - 1].second)];\n      dp[i][s] %= mod;\n    }\n    pref[i][0] = 0;\n    for (long long l = 1; l < sum + 2; ++l) {\n      pref[i][l] = pref[i][l - 1] + dp[i][l - 1];\n      pref[i][l] %= mod;\n    }\n  }\n  long long ans = 0;\n  for (long long m = 0; m <= sum; ++m) {\n    ans += dp[n][m];\n    ans %= mod;\n  }\n  return ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  cout.tie();\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long>> a;\n  for (long long i = 0; i < n; ++i) {\n    long long l, r;\n    cin >> l >> r;\n    a.push_back({l, r});\n  }\n  long long ans[m + 1];\n  for (long long g = 1; g <= m; ++g) {\n    vector<pair<long long, long long>> b;\n    for (long long i = 0; i < n; ++i) {\n      b.push_back({(a[i].first + g - 1) / g, a[i].second / g});\n    }\n    ans[g] = calc(b, m / g);\n  }\n  long long real_ans[m + 1];\n  for (long long j = m; j >= 1; --j) {\n    real_ans[j] = ans[j];\n    for (long long i = j * 2; i <= m; i += j) {\n      real_ans[j] -= real_ans[i];\n      real_ans[j] %= mod;\n    }\n  }\n  cout << (real_ans[1] + mod) % mod;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int M = 3e3 + 10;\nconst int N = 1e5 + 10;\nint l[N], r[N];\nlong long dp[60][N];\nlong long cnt[N];\nlong long sum[N];\ntemplate <class T>\ninline void rd(T& x) {\n  char c = getchar();\n  long long res = 0, f = 1;\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    res = (res << 1) + (res << 3) + (c ^ 48);\n    c = getchar();\n  }\n  x = res * f;\n}\nvoid run() {\n  int n, m;\n  rd(n), rd(m);\n  for (int i = 1; i <= n; i++) {\n    rd(l[i]), rd(r[i]);\n  }\n  for (int k = 1; k <= m; k++) {\n    int top = m / k;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      int tl = (l[i] + k - 1) / k;\n      int tr = r[i] / k;\n      sum[0] = dp[i - 1][0];\n      for (int j = 1; j <= top; j++) {\n        sum[j] = sum[j - 1] + dp[i - 1][j];\n        sum[j] %= mod;\n        dp[i - 1][j] = 0;\n      }\n      for (int j = tl; j <= top; j++) {\n        dp[i][j] += sum[j - tl] - ((j - tr - 1 < 0) ? 0 : sum[j - tr - 1]);\n        dp[i][j] %= mod;\n      }\n    }\n    for (int i = 1; i <= top; i++) {\n      cnt[k] += dp[n][i];\n      dp[n][i] = 0;\n      cnt[k] %= mod;\n    }\n  }\n  for (int i = m; i > 0; i--) {\n    for (int j = 2; j * i <= m; j++) {\n      cnt[i] -= cnt[i * j];\n      cnt[i] += mod;\n      cnt[i] %= mod;\n    }\n  }\n  printf(\"%lld\\n\", cnt[1]);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 2e9;\ninline int Max(const int &a, const int &b) { return a > b ? a : b; }\ninline int Min(const int &a, const int &b) { return a > b ? b : a; }\ninline int read() {\n  int f = 1, x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int N = 55;\nconst int M = 1e5 + 7;\nconst int mod = 998244353;\nint n, m;\nint l[N], r[N];\nint mu[M];\nint prime[M], ntp[M], cnt;\nvoid xxs(int n) {\n  mu[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!ntp[i]) {\n      prime[++cnt] = i;\n      mu[i] = -1;\n    }\n    for (int j = 1; j <= cnt; ++j) {\n      if (i * prime[j] > n) break;\n      ntp[i * prime[j]] = 1;\n      if (i % prime[j] == 0) {\n        mu[i * prime[j]] = 0;\n        break;\n      }\n      mu[i * prime[j]] = -mu[i];\n    }\n  }\n}\nlong long dp[M], s[M], ans;\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; ++i) l[i] = read(), r[i] = read();\n  xxs(m);\n  for (int i = 1; i <= m; ++i) {\n    if (mu[i] == 0) continue;\n    int lim = m / i;\n    for (int j = 1; j <= lim; ++j) dp[j] = 0;\n    dp[0] = 1;\n    for (int j = 1; j <= n; ++j) {\n      int L = (l[j] + i - 1) / i, R = r[j] / i;\n      for (int k = 0; k <= lim; ++k) {\n        s[k] = (k > 0 ? s[k - 1] : 0);\n        s[k] = (s[k] + dp[k]) % mod;\n      }\n      for (int k = 0; k <= lim; ++k) {\n        dp[k] = (k - L >= 0 ? s[k - L] : 0);\n        dp[k] = (dp[k] - (k - R - 1 >= 0 ? s[k - R - 1] : 0) + mod) % mod;\n      }\n    }\n    long long res = 0;\n    for (int k = 0; k <= lim; ++k) res = (res + dp[k]) % mod;\n    ans = (ans + res * mu[i] + mod) % mod;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nconst int M = 1e5 + 5;\nconst int mod = 998244353;\nstd::vector<std::pair<int, int> > lr;\nint mobius[M];\nint cnt[M];\nint is_composite[M];\nstd::vector<int> primes;\nint solve(std::vector<int> &L, std::vector<int> &R, int m) {\n  int n = L.size();\n  for (int i = 0; i < n; i++) {\n    m -= L[i];\n    R[i] -= L[i];\n  }\n  if (m < 0) {\n    return 0;\n  }\n  std::vector<ll> dp(m + 2, 0);\n  dp[0] = 1;\n  for (int r : R) {\n    std::vector<ll> nways(m + 2, 0);\n    for (int i = 0; i <= m; i++) {\n      nways[i] += dp[i];\n      int e = std::min(m + 1, i + r);\n      nways[e] -= dp[i];\n    }\n    for (int i = 1; i <= m + 1; i++) {\n      nways[i] = (nways[i] % mod + nways[i - 1] % mod) % mod;\n    }\n    std::swap(dp, nways);\n  }\n  int ans = 0;\n  for (int i = 0; i <= m; i++) {\n    ans = (ans + dp[i]) % mod;\n  }\n  return ans;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int n, m;\n  std::cin >> n >> m;\n  lr.resize(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> lr[i].first >> lr[i].second;\n    lr[i].second++;\n  }\n  std::fill(is_composite, is_composite + m + 1, false);\n  std::fill(cnt, cnt + m + 1, 0);\n  is_composite[0] = true;\n  is_composite[1] = true;\n  mobius[0] = 1;\n  mobius[1] = 1;\n  for (int i = 2; i <= m; i++) {\n    if (!is_composite[i]) {\n      mobius[i] = -1;\n      primes.push_back(i);\n      cnt[i] = 1;\n    }\n    for (int j = 0; j < primes.size() && i * primes[j] <= m; j++) {\n      is_composite[i * primes[j]] = true;\n      cnt[i * primes[j]] += cnt[i];\n      mobius[i * primes[j]] = mobius[primes[j]] * mobius[i];\n      if (i % primes[j] == 0) {\n        int powp = pow(primes[j], cnt[i]);\n        mobius[i * primes[j]] = 0;\n        break;\n      }\n    }\n  }\n  std::vector<int> L(n);\n  std::vector<int> R(n);\n  int ans = 0;\n  for (int i = 1; i <= m; i++) {\n    if (mobius[i] != 0) {\n      for (int j = 0; j < n; j++) {\n        L[j] = (lr[j].first + i - 1) / i;\n        R[j] = (lr[j].second + i - 1) / i;\n      }\n      int tmp = solve(L, R, m / i);\n      int tmp2 = mobius[i] * tmp;\n      ans = (ans + tmp2) % mod;\n      if (ans < 0) {\n        ans += mod;\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nimport os\nfrom io import BytesIO\n\nif sys.version_info[0] < 3:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n\nf = sys.stdin\nif os.environ.get('USER') == \"loic\":\n    f = open(\"data.in\")\n\nline = lambda: f.readline().strip('\\r\\n').split()\n\ndef write(w):\n    sys.stdout.write(w)\n    sys.stdout.write(\"\\n\")\n\ndef solve():\n    ways = [0] * (M+1)\n    \n    for d in range(M,0,-1): \n        m = M//d\n        dp = [0 for j in range(m+1)]\n        dp[0] = 1\n        pref = [0 for _ in range(m+1)]\n        f = True\n        \n        for i in range(1,N+1):\n            l = D[i-1][0]\n            r = D[i-1][1]\n            l = (l+d-1) // d\n            r //= d\n            \n            if l>r:\n                f = False\n                break\n            \n            pref[0] = dp[0]\n            for j in range(1,m+1):\n                pref[j] = (pref[j-1] + dp[j]) % MOD\n            \n            for j in range(1,m+1):\n                a = b = 0\n                if j >= l:\n                    a = pref[j-l]\n                if j >= r+1:\n                    b = pref[j-r-1]\n                dp[j] = a - b\n                dp[j] %= MOD\n            dp[0] = 0\n        \n        v = sum(dp[j] for j in range(1,m+1))\n        if f:\n            ways[d] = v\n            for j in range(2*d,M+1,d):\n                ways[d] -= ways[j]\n                ways[d] %= MOD\n    \n    return str(ways[1]%MOD)\n\nMOD = 998244353\nT = 1\nfor test in range(1,T+1):\n    N,M = map(int,line())\n    D = []\n    for _ in range(N):\n        l,r = map(int,line())\n        D.append((l,r))\n    \n    write(solve())\n    \nf.close()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int N = 50;\nconst int MX = 1e5;\nconst int MOD = 998244353;\nint n, m;\nint L[N + 5], R[N + 5];\nint up[N + 5], low[N + 5];\nint f[MX + 5];\ninline void add(int& a, int b) { a = (a + b) % MOD; }\ninline int sub(int a, int b) {\n  a = (a - b) % MOD;\n  if (a < 0) a += MOD;\n  return a;\n}\nint calc(int k) {\n  vector<vector<int>> dp(n, vector<int>(m / k + 5));\n  vector<int> pre(m / k + 5);\n  int bat = m / k;\n  for (int i = 0; i < n; i++) {\n    low[i] = ((L[i] + k - 1) / k);\n    bat -= (low[i]);\n    up[i] = ((R[i]) / k);\n  }\n  if (bat < 0) return 0;\n  for (int i = 0; i <= up[0] - low[0]; i++) {\n    dp[0][i] = 1;\n  }\n  pre[0] = 1;\n  for (int i = 1; i <= bat; i++) {\n    pre[i] = (pre[i - 1] + dp[0][i]) % MOD;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j <= bat; j++) {\n      int lul;\n      if (j > (up[i] - low[i]))\n        lul = pre[j - (up[i] - low[i]) - 1];\n      else\n        lul = 0;\n      dp[i][j] = (dp[i][j] + sub(pre[j], lul)) % MOD;\n    }\n    pre[0] = dp[i][0];\n    for (int j = 1; j <= bat; j++) {\n      pre[j] = (pre[j - 1] + dp[i][j]) % MOD;\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i <= bat; i++) {\n    ret = (ret + dp[n - 1][i]) % MOD;\n  }\n  return ret;\n}\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> L[i] >> R[i];\n  }\n  for (int i = 1; i <= m / n; i++) {\n    f[i] = calc(i);\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) {\n      f[i] = (f[i] - f[j] + MOD) % MOD;\n    }\n  }\n  int ans = f[1] % MOD;\n  if (ans < 0) ans += MOD;\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int TC = 1;\n  for (int i = 1; i <= TC; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 51;\nint n, m;\nint l[MAXN], r[MAXN];\nconst int MAXM = 1e5 + 1;\nint mu[MAXM];\nconst int MOD = 998244353;\nvoid add(int& A, int B) {\n  A += B;\n  if (A >= MOD) A -= MOD;\n}\nint dp[MAXN][100000 + 1];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &l[i], &r[i]);\n  int ans = 0;\n  for (int i = 1; i <= 1e5; ++i) {\n    int now = i;\n    mu[i] = 1;\n    for (int j = 2; j * j <= now; j++) {\n      if (now % j == 0) {\n        if (now % (j * j) == 0) {\n          mu[i] = 0;\n          break;\n        }\n        mu[i] *= -1;\n        now /= j;\n      }\n    }\n    if (now != 1) mu[i] *= -1;\n    mu[i] = (mu[i] + MOD) % MOD;\n  }\n  dp[0][0] = 1;\n  for (int x = 1; x <= m; ++x) {\n    if (mu[x]) {\n      int M = m / x;\n      for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= M; ++j) dp[i][j] = 0;\n      for (int i = 1; i <= n; ++i) {\n        int l_, r_;\n        l_ = (l[i] + x - 1) / x;\n        r_ = (r[i]) / x;\n        if (l_ <= r_) {\n          int sum = 0;\n          for (int j = l_; j <= M; ++j) {\n            add(sum, dp[i - 1][j - l_]);\n            dp[i][j] = sum;\n            if (j >= r_) add(sum, MOD - dp[i - 1][j - r_]);\n          }\n        }\n      }\n      int sum = 0;\n      for (int j = 1; j <= M; ++j) add(sum, dp[n][j]);\n      add(ans, 1ll * sum * mu[x] % MOD);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long sum[55][100005], f[55][100005], t[100005];\nint l[55], r[55];\nint add(int p, int x, int y) {\n  if (x < 0) return 0;\n  if (y < 0) return sum[p][x];\n  return sum[p][x] - sum[p][y];\n}\nlong long solve1(int n, int m) {\n  long long ans = 0;\n  for (int i = l[1]; i <= r[1]; i++) f[1][i] = 1;\n  for (int i = 1; i <= m; i++) sum[1][i] = (sum[1][i - 1] + f[1][i]) % mod;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      f[i][j] = add(i - 1, j - l[i], j - r[i] - 1);\n      sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod;\n    }\n  }\n  for (int i = 1; i <= m; i++) ans = (ans + f[n][i]) % mod;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) f[i][j] = sum[i][j] = 0;\n  return ans;\n}\nlong long solve2(int n, int m, int d) {\n  long long ans = 0;\n  for (int i = d; i <= m; i += d)\n    if (i >= l[1] && i <= r[1]) f[1][i] = 1;\n  for (int i = d; i <= m; i += d) sum[1][i] = f[1][i] + sum[1][i - d];\n  for (int i = 2; i <= n; i++) {\n    for (int j = d; j <= m; j += d) {\n      int R = j - l[i] - ((j - l[i]) % d + d) % d;\n      int L = j - r[i] - ((j - r[i]) % d + d) % d;\n      if ((j - r[i]) % d == 0) L -= d;\n      f[i][j] = add(i - 1, R, L);\n      sum[i][j] = (sum[i][j - d] + f[i][j]) % mod;\n    }\n  }\n  for (int i = d; i <= m; i += d) ans = (ans + f[n][i]) % mod;\n  for (int i = 1; i <= n; i++)\n    for (int j = d; j <= m; j += d) f[i][j] = sum[i][j] = 0;\n  return ans;\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &l[i], &r[i]);\n  long long ans = solve1(n, m);\n  for (int d = 2; d <= m / n; d++) {\n    ans = ((ans - (1 - t[d]) * solve2(n, m, d)) % mod + mod) % mod;\n    for (int j = 2; j * d <= m / n; j++) t[j * d] += 1 - t[d];\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst long long mod = 998244353;\nint cnt;\nint mo[N];\nbool vis[N];\nint prime[N];\nstruct Node {\n  int l, r;\n} q[N];\nint n, m;\nvoid initPrime(const int& n) {\n  mo[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (!vis[i]) {\n      mo[i] = -1;\n      prime[++cnt] = i;\n    }\n    for (int j = 1; i <= n / prime[j]; j++) {\n      vis[i * prime[j]] = true;\n      if (i % prime[j] == 0) {\n        mo[i * prime[j]] = 0;\n        break;\n      }\n      mo[i * prime[j]] = -mo[i];\n    }\n  }\n}\nint d[N];\nint pre[N];\nlong long get(long long g) {\n  vector<Node> vt;\n  for (int i = 1; i <= n; i++) {\n    int l = (q[i].l + g - 1) / g;\n    int r = q[i].r / g;\n    if (l > r) return 0;\n    vt.push_back({l, r});\n  }\n  int k = m / g;\n  for (int i = vt[0].l; i <= vt[0].r; i++) {\n    int l = i + vt[1].l;\n    int r = min(k, i + vt[1].r);\n    if (l > k) break;\n    d[l] += 1, d[r + 1] -= 1;\n  }\n  for (int i = 1; i <= k; i++) {\n    pre[i] = pre[i - 1] + d[i];\n    d[i] = 0;\n  }\n  d[k + 1] = 0;\n  for (int i = 2; i <= n - 1; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (pre[j]) {\n        int l = j + vt[i].l;\n        int r = min(k, j + vt[i].r);\n        if (l > k) break;\n        d[l] = (d[l] + pre[j]) % mod;\n        d[r + 1] = (d[r + 1] - pre[j] + mod) % mod;\n      }\n    }\n    for (int j = 1; j <= k; j++) {\n      pre[j] = (pre[j - 1] + d[j]) % mod;\n      d[j] = 0;\n    }\n    d[k + 1] = 0;\n  }\n  int res = 0;\n  for (int i = 1; i <= k; i++) {\n    res = (res + pre[i]) % mod;\n  }\n  return res;\n}\nint main() {\n  initPrime(1e5);\n  int mi = 1e5;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    cin >> q[i].l >> q[i].r;\n    mi = min(mi, q[i].r);\n  }\n  if (n == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  for (long long i = 1; i <= mi; i++) {\n    if (mo[i] == 0) continue;\n    ans = (ans + mo[i] * get(i) + mod) % mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1e18;\nconst long long mod = 998244353;\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> l(n), r(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  auto modfix = [&](long long &x) {\n    if (x >= mod)\n      x -= mod;\n    else if (x < 0)\n      x += mod;\n  };\n  vector<long long> res(m + 1, 0);\n  for (long long g = 1; g <= m; g++) {\n    long long mm = m / g;\n    vector<vector<long long>> pd(n + 1, vector<long long>(mm + 1, 1));\n    for (long long i = n - 1; i >= 0; i--) {\n      for (long long second = 1; second <= mm; second++) {\n        pd[i + 1][second] += pd[i + 1][second - 1];\n        modfix(pd[i + 1][second]);\n      }\n      for (long long second = 0; second <= mm; second++) {\n        pd[i][second] = 0;\n        long long a = second + ceil(1.0 * l[i] / g), b = second + r[i] / g;\n        b = min(b, mm);\n        if (a > b) continue;\n        pd[i][second] = pd[i + 1][b] - pd[i + 1][a - 1];\n        modfix(pd[i][second]);\n      }\n    }\n    res[g] = pd[0][0];\n  }\n  for (long long g = m; g >= 1; g--) {\n    for (long long mult = g + g; mult <= m; mult += g) {\n      res[g] -= res[mult];\n      modfix(res[g]);\n    }\n  }\n  cout << res[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int N = 1e5 + 5;\nint n, m;\nint f[51][N];\nunsigned long long sum[N];\nint l[N], r[N];\nunsigned long long g[N];\nvoid add(unsigned long long &a, unsigned long long b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = (1); i < (n + 1); i++) scanf(\"%d%d\", &l[i], &r[i]);\n  for (int gc = (1); gc < (m + 1); gc++) {\n    int tot = m / gc;\n    for (int i = (1); i < (tot + 1); i++) f[1][i] = 0, sum[i] = 0;\n    for (int i = ((l[1] + gc - 1) / gc); i < (r[1] / gc + 1); i++) f[1][i] = 1;\n    for (int i = (1); i < (tot + 1); i++) sum[i] = (sum[i - 1] + f[1][i]) % mod;\n    for (int i = (2); i < (n + 1); i++) {\n      int mi = (l[i] + gc - 1) / gc, mx = r[i] / gc;\n      if (mi > mx) {\n        sum[tot] = 0;\n        break;\n      }\n      for (int j = (mi); j < (tot + 1); j++) {\n        if (j <= mx)\n          f[i][j] = sum[j - mi];\n        else\n          f[i][j] = (sum[j - mi] - sum[j - mx - 1] + mod) % mod;\n      }\n      sum[0] = 0;\n      for (int j = (1); j < (tot + 1); j++)\n        sum[j] = (sum[j - 1] + f[i][j]) % mod;\n    }\n    g[gc] = sum[tot];\n  }\n  for (int i = (m + 1) - 1; i >= (1); i--) {\n    for (int j = i + i; j <= m; j += i) g[i] = (g[i] - g[j] + mod) % mod;\n  }\n  printf(\"%lld\\n\", g[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rng(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long cdiv(long long a, long long b) {\n  return a / b + ((a ^ b) > 0 && a % b);\n}\nlong long fdiv(long long a, long long b) {\n  return a / b - ((a ^ b) < 0 && a % b);\n}\nlong long gcd(long long a, long long b) {\n  return (b == 0LL ? a : gcd(b, a % b));\n}\nlong long exp(long long b, long long e, long long m) {\n  b %= m;\n  long long ans = 1;\n  for (; e; b = b * b % m, e /= 2)\n    if (e & 1) ans = ans * b % m;\n  return ans;\n}\nvoid dbg_out() { cerr << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nconst int N = 100100;\nvector<int> pr;\nint mu[N];\nint mark[N];\nvoid crivo() {\n  for (int i = 1; i < (N); ++i) {\n    mu[i] = 1;\n    mark[i] = 0;\n  }\n  for (int i = 2; i < (N); ++i) {\n    if (!mark[i]) {\n      pr.push_back(i);\n      mu[i] = -1;\n    }\n    for (auto p : pr) {\n      if (1ll * p * i >= N) break;\n      mark[i * p] = 1;\n      if (i % p == 0) {\n        mu[i * p] = 0;\n        break;\n      } else\n        mu[i * p] = -mu[i];\n    }\n  }\n}\nint l[N], r[N];\nlong long dp[N], pre[N];\nconst int M = 998244353;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  crivo();\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i < (n + 1); ++i) cin >> l[i] >> r[i];\n  long long res = 0;\n  for (int V = 1; V < (m + 1); ++V)\n    if (mu[V] != 0) {\n      int mx = m / V;\n      for (int i = 0; i < (mx + 1); ++i) pre[i] = dp[i] = 0;\n      dp[0] = 1;\n      for (int i = 0; i < (mx + 1); ++i) pre[i] = 1;\n      int bad = 0;\n      for (int k = 1; k < (n + 1); ++k) {\n        int L = (l[k] + V - 1) / V;\n        int R = r[k] / V;\n        if (R == 0 || L > R) {\n          bad = 1;\n          break;\n        }\n        for (int i = 0; i < (mx + 1); ++i) {\n          if (i - L >= 0)\n            dp[i] =\n                (M + pre[i - L] - (i - R - 1 >= 0 ? pre[i - R - 1] : 0)) % M;\n          else\n            dp[i] = 0;\n        }\n        for (int i = 0; i < (mx + 1); ++i) {\n          pre[i] = dp[i] % M;\n          if (i) pre[i] = (pre[i] + pre[i - 1]) % M;\n        }\n      }\n      if (!bad) res += mu[V] * pre[mx] % M;\n      res %= M;\n      if (res < 0) res += M;\n    }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\np=998244353\nn,m=map(int,input().split())\nc=[]\nfor i in range(n):\n    b=list(map(int,input().split()))\n    c.append(b)\n\nval=[0 for i in range(m+1)]\nfor i in range(m,0,-1):\n    s=m//i\n    ans=0\n    dp=[0 for j in range(s+1)]\n    pre=[1 for i in range(s+1)]\n    pre[0]=1\n\n    fl=1\n    for pos in range(n):\n        l,r=math.ceil(c[pos][0]/i),c[pos][1]//i\n        if l>r:\n            fl=0\n            break\n        for j in range(l,s+1):\n            le=j-r\n            re=j-l\n\n            if le<1:\n                dp[j]=(dp[j]+pre[re])%p\n            else:\n\n                dp[j] = (dp[j] + pre[re] - pre[le - 1]) % p\n\n\n\n\n        pre[0]=0\n        dp[0]=0\n        for j in range(1,s+1):\n            pre[j] = (dp[j] + pre[j-1]) % p\n            dp[j]=0\n\n    if fl:\n        curr=pre[s]\n        tot=0\n        for j in range(2*i,m+1,i):\n            tot=(tot+val[j])%p\n        val[i]=(curr-tot)%p\n\n\n    else:\n        val[i]=0\n\n\nprint(val[1]%p)\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 55, M = 100005, P = 998244353;\nlong long n, m, l[N], r[N], f[N][M], ans[M];\nsigned main() {\n  std::cin >> n >> m;\n  for (long long i = 1; i <= n; i++) std::cin >> l[i] >> r[i];\n  for (long long g = m / n; g >= 1; g--) {\n    for (long long i = 0; i <= n; i++)\n      for (long long j = 0; j <= m / g + 1; j++) f[i][j] = 0;\n    for (long long j = 0; j <= m / g + 1; j++) f[0][j] = 1;\n    for (long long i = 1; i <= n; i++) {\n      long long L = (l[i] + g - 1) / g, R = r[i] / g;\n      for (long long a = L; a <= m / g + 1; a++) {\n        long long cl = std::max(a - R, 0ll), cr = a - L;\n        if (cl > cr)\n          f[i][a] = 0;\n        else\n          f[i][a] = (f[i - 1][cr] - (cl ? f[i - 1][cl - 1] : 0) + P) % P;\n        if (a > 0) f[i][a] = (f[i][a] + f[i][a - 1]) % P;\n      }\n    }\n    ans[g] = f[n][m / g];\n    for (long long i = 2 * g; i <= m; i += g)\n      ans[g] = (ans[g] - ans[i] + P) % P;\n  }\n  std::cout << ans[1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nconst int MOD = 998244353;\nconst ll INF = 1e18;\ninline void fastio() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nmt19937 rng(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nint rand(int l, int r) {\n  uniform_int_distribution<int> uid(l, r);\n  return uid(rng);\n}\nll mod_neg(ll x) {\n  assert(x <= 0);\n  while (x < 0) {\n    x += MOD;\n  }\n  return x % MOD;\n}\nvoid solve() {\n  ll n, m;\n  cin >> n >> m;\n  vector<pair<ll, ll>> arr(n);\n  for (ll i = 0; i < n; i++) {\n    cin >> arr[i].first >> arr[i].second;\n  }\n  auto ask = [&](vector<pair<ll, ll>> &v, ll m2) -> ll {\n    vector<ll> ways(m2 + 1, 0);\n    ways[0] = 1;\n    for (ll i = 0; i < n; i++) {\n      ll l = v[i].first, r = v[i].second;\n      vector<ll> ways_by_pref(m2 + 1, 0);\n      for (ll j = 0; j <= m2; j++) {\n        if (j + l <= m2) {\n          ways_by_pref[j + l] = (ways_by_pref[j + l] + ways[j]) % MOD;\n          if (j + r + 1 <= m2) {\n            ways_by_pref[j + r + 1] =\n                (ways_by_pref[j + r + 1] + mod_neg(-ways[j])) % MOD;\n          }\n        }\n      }\n      ways[0] = ways_by_pref[0];\n      for (ll i = 1; i <= m2; i++) {\n        ways[i] = (ways[i - 1] + ways_by_pref[i]) % MOD;\n      }\n    }\n    ll ans{};\n    for (ll i = 0; i <= m2; i++) {\n      ans = (ans + ways[i]) % MOD;\n    }\n    return ans;\n  };\n  vector<ll> f(m + 1);\n  for (ll i = 1; i <= m; i++) {\n    vector<pair<ll, ll>> v(n);\n    for (ll j = 0; j < n; j++) {\n      v[j].first = (arr[j].first + i - 1) / i;\n      v[j].second = arr[j].second / i;\n    }\n    ll m2 = m / i;\n    f[i] = ask(v, m2);\n  }\n  for (ll i = m; i >= 1; i--) {\n    for (ll j = 2 * i; j <= m; j += i) {\n      f[i] = (f[i] - f[j] + MOD) % MOD;\n    }\n  }\n  cout << f[1] << '\\n';\n}\nint main() {\n  fastio();\n  cout << setprecision(15) << fixed;\n  int tc = 1;\n  while (tc--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50 + 5;\nconst long long M = 1e5 + 5;\nconst long long mod = 998244353;\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double PI = acos(-1.0);\nconst pair<int, int> NIL = {0, 0};\nint n, m;\nlong long l[N], r[N], dp[M], sum[M], f[M];\nlong long deal(long long d) {\n  long long lim = m / d;\n  f[0] = 1;\n  for (long long i = 1; i <= lim; ++i) f[i] = 0;\n  for (long long i = 1; i <= n; ++i) {\n    long long L = (l[i] + d - 1) / d, R = r[i] / d;\n    if (L > R) return 0;\n    sum[0] = f[0];\n    for (long long j = 1; j <= lim; ++j) sum[j] = (f[j] + sum[j - 1]) % mod;\n    for (long long j = 0; j <= lim; ++j) {\n      if (j > R)\n        f[j] = (sum[j - L] - sum[j - R - 1] + mod) % mod;\n      else if (j >= L)\n        f[j] = sum[j - L];\n      else\n        f[j] = 0;\n    }\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= lim; ++i) ans = (ans + f[i]) % mod;\n  return ans;\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n  for (long long d = M; d >= 1; --d) {\n    dp[d] = deal(d);\n    for (int i = d + d; i <= M; i += d) dp[d] = (dp[d] - dp[i] + mod) % mod;\n  }\n  cout << dp[1] << \"\\n\";\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 55, N = 1e5, mod = 998244353;\nint n, m, l[maxn], r[maxn], vis[N + 5], pr[N + 5], mu[N + 5], prcnt;\nvoid Sieve(int N) {\n  mu[1] = 1;\n  for (int i = 2; i <= N; ++i) {\n    if (!vis[i]) pr[++prcnt] = i, mu[i] = -1;\n    for (int j = 1; j <= prcnt && i * pr[j] <= N; ++j) {\n      vis[i * pr[j]] = 1;\n      if (i % pr[j] == 0) {\n        mu[i * pr[j]] = 0;\n        break;\n      }\n      mu[i * pr[j]] = -mu[i];\n    }\n  }\n}\nint f[N + 5], s[N + 5];\nint Solve(int d) {\n  f[0] = s[0] = 1;\n  for (int i = 1; i <= m / d; ++i) f[i] = 0, s[i] = 1;\n  for (int i = 1; i <= n; ++i) {\n    int L = (l[i] - 1) / d + 1, R = r[i] / d;\n    if (L > R) return 0;\n    for (int j = 0; j < L; ++j) f[j] = 0;\n    for (int j = L; j <= R; ++j) f[j] = s[j - L];\n    for (int j = R + 1; j <= m / d; ++j)\n      f[j] = (s[j - L] - s[j - R - 1] + mod) % mod;\n    s[0] = f[0];\n    for (int j = 1; j <= m / d; ++j) s[j] = (s[j - 1] + f[j]) % mod;\n  }\n  return s[m / d];\n}\nint main() {\n  scanf(\"%d %d\", &n, &m), Sieve(m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d %d\", &l[i], &r[i]);\n  int ans = 0;\n  for (int i = 1; i <= m; ++i)\n    mu[i] == 1 ? ans = (ans + Solve(i)) % mod\n               : (mu[i] == -1 ? ans = (ans - Solve(i) + mod) % mod : 0);\n  return printf(\"%d\", ans), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <int MOD_>\nstruct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\n private:\n  using ll = long long;\n  int v;\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\n public:\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) {\n    if (v < 0) v += MOD;\n  }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator<<(std::ostream& out, const modnum& n) {\n    return out << int(n);\n  }\n  friend std::istream& operator>>(std::istream& in, modnum& n) {\n    ll v_;\n    in >> v_;\n    n = modnum(v_);\n    return in;\n  }\n  friend bool operator==(const modnum& a, const modnum& b) {\n    return a.v == b.v;\n  }\n  friend bool operator!=(const modnum& a, const modnum& b) {\n    return a.v != b.v;\n  }\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD - v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator-() const { return neg(); }\n  modnum operator+() const { return modnum(*this); }\n  modnum& operator++() {\n    v++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator--() {\n    if (v == 0) v = MOD;\n    v--;\n    return *this;\n  }\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator*=(const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator/=(const modnum& o) { return *this *= o.inv(); }\n  friend modnum operator++(modnum& a, int) {\n    modnum r = a;\n    ++a;\n    return r;\n  }\n  friend modnum operator--(modnum& a, int) {\n    modnum r = a;\n    --a;\n    return r;\n  }\n  friend modnum operator+(const modnum& a, const modnum& b) {\n    return modnum(a) += b;\n  }\n  friend modnum operator-(const modnum& a, const modnum& b) {\n    return modnum(a) -= b;\n  }\n  friend modnum operator*(const modnum& a, const modnum& b) {\n    return modnum(a) *= b;\n  }\n  friend modnum operator/(const modnum& a, const modnum& b) {\n    return modnum(a) /= b;\n  }\n};\ntemplate <typename T>\nT pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1;\n  while (b) {\n    if (b & 1) r *= a;\n    b >>= 1;\n    a *= a;\n  }\n  return r;\n}\nusing num = modnum<998244353>;\nconst int X = 2.1e5;\nbitset<X> is_prime;\nvector<int> pr;\nvector<int> mu(X, 0);\nvoid init() {\n  is_prime.flip();\n  is_prime[0] = is_prime[1] = false;\n  mu[1] = 1;\n  for (int i = 2; i < X; i++) {\n    if (is_prime[i]) {\n      pr.push_back(i);\n      mu[i] = -1;\n    }\n    for (int p : pr) {\n      if (i * p >= X) break;\n      is_prime[i * p] = false;\n      if (i % p == 0) {\n        mu[i * p] = 0;\n      } else {\n        mu[i * p] = -mu[i];\n      }\n      if (i % p == 0) break;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr);\n  init();\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(n), r(n);\n  int maxr = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n    maxr = max(maxr, r[i]);\n  }\n  num total = 0;\n  for (int g = 1; g <= maxr; g++) {\n    if (mu[g] == 0) continue;\n    int S = m / g + 1;\n    vector<num> dp(S, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n      int newl = (l[i] + g - 1) / g;\n      int newr = r[i] / g;\n      vector<num> psum(S + 1, 0);\n      for (int x = 0; x < S; x++) psum[x + 1] = psum[x] + dp[x];\n      vector<num> ndp(S, 0);\n      if (newl <= newr) {\n        for (int x = 0; x < S; x++) {\n          ndp[x] = psum[max(x - newl + 1, 0)] - psum[max(x - newr, 0)];\n        }\n      }\n      dp = ndp;\n    }\n    num ans = 0;\n    for (num v : dp) ans += v;\n    total += ans * mu[g];\n  }\n  cout << total << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long n, m, l[60], r[60], memo[200010], L[60], R[60];\nlong long dp(long long k) {\n  if (memo[k] != -1) return memo[k];\n  long long ans = 0;\n  for (long long i = 2; i * k <= m; i++) {\n    ans = (ans - dp(i * k) + mod) % mod;\n  }\n  long long M = m / k, esq = 0;\n  for (long long i = 1; i <= n; i++) {\n    L[i] = l[i] / k;\n    if (l[i] % k) L[i]++;\n    R[i] = r[i] / k;\n    esq += L[i];\n    if (R[i] < L[i]) return memo[k] = 0;\n    R[i] -= L[i];\n  }\n  if (M < esq) return memo[k] = 0;\n  M -= esq;\n  vector<long long> soma(M + 10);\n  for (long long i = 0; i <= min(R[1], M); i++) soma[i] = 1;\n  for (long long obj = 2; obj <= n; obj++) {\n    vector<long long> pref(M + 10), aux(M + 10);\n    for (long long i = 0; i <= M; i++) {\n      if (i != 0) pref[i] = pref[i - 1];\n      aux[i] = soma[i];\n      pref[i] = (pref[i] + soma[i]) % mod;\n    }\n    for (long long num = 0; num <= M; num++) {\n      long long left = max(0ll, num - R[obj]);\n      soma[num] = pref[num];\n      if (left > 0) soma[num] = (soma[num] - pref[left - 1] + mod) % mod;\n      ;\n    }\n  }\n  for (long long i = 0; i <= M; i++) ans = (ans + soma[i]) % mod;\n  return memo[k] = ans;\n}\nvoid solve() {\n  memset(memo, -1, sizeof(memo));\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  cout << dp(1) << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 50 + 5;\nint l[max_n], r[max_n], L[max_n], R[max_n];\nconst int max_m = 1e5 + 5;\nint dp[max_n][max_m], pre[max_n][max_m], f[max_m];\nconst int mod = 998244353;\ninline void add(int &a, int b) { a = a + b - (a + b >= mod ? mod : 0); }\ninline void sub(int &a, int b) { a = a - b + (a < b ? mod : 0); }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", l + i, r + i);\n  for (int d = 1; d <= m; ++d) {\n    bool flag_break = false;\n    int sL = 0;\n    for (int i = 1; i <= n; ++i) {\n      L[i] = (l[i] + d - 1) / d;\n      R[i] = r[i] / d;\n      if (L[i] > R[i]) {\n        flag_break = true;\n        break;\n      }\n      sL += L[i];\n    }\n    if (flag_break) continue;\n    int M = m / d;\n    if (M < sL) continue;\n    dp[0][0] = 1;\n    for (int i = 0; i <= M; ++i) pre[0][i] = 1;\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= M; ++j) {\n        int l = j - R[i], r = j - L[i];\n        if (r >= 0) dp[i][j] = pre[i - 1][r];\n        if (l >= 1) sub(dp[i][j], pre[i - 1][l - 1]);\n        pre[i][j] = pre[i][j - 1];\n        add(pre[i][j], dp[i][j]);\n      }\n    f[d] = pre[n][M];\n  }\n  for (int i = m; i >= 1; --i)\n    for (int j = i << 1; j <= m; j += i) sub(f[i], f[j]);\n  printf(\"%d\\n\", f[1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long MOD = 998244353;\nusing pii = std::pair<long long, long long>;\nusing namespace std;\nconst long long maxn = 55, maxrange = 1e5 + 5;\nlong long n, m, l[maxn], r[maxn], dp[2][maxrange], ways[maxrange];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) cin >> l[i] >> r[i];\n  long long maxgcd = m / n;\n  for (long long gcd = maxgcd; gcd >= 1; gcd--) {\n    long long compressed_till = m / gcd;\n    for (long long j = 0; j <= compressed_till; j++) dp[0][j] = 0;\n    dp[0][0] = 1;\n    for (long long i = 0; i < n; i++) {\n      long long cur = i & 1;\n      long long ne = cur ^ 1;\n      for (long long j = 0; j <= compressed_till; j++) dp[ne][j] = 0;\n      for (long long j = 0; j < compressed_till; j++) {\n        if (j > 0) {\n          dp[cur][j] += dp[cur][j - 1];\n          dp[cur][j] %= MOD;\n        }\n        long long from = j + (l[i] + gcd - 1) / gcd;\n        long long to = min(j + r[i] / gcd, compressed_till);\n        if (from > to) continue;\n        dp[ne][from] += dp[cur][j];\n        dp[ne][from] %= MOD;\n        dp[ne][to + 1] += (MOD - dp[cur][j]);\n        dp[ne][to + 1] %= MOD;\n      }\n    }\n    for (long long j = 0; j <= compressed_till; j++) {\n      ways[gcd] += dp[n & 1][j];\n      ways[gcd] %= MOD;\n    }\n    for (long long mult = 2; gcd * mult <= m; mult++) {\n      ways[gcd] += (MOD - ways[gcd * mult]);\n      ways[gcd] %= MOD;\n    }\n  }\n  cout << ways[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint xm[4] = {-1, 1, 0, 0};\nint ym[4] = {0, 0, -1, 1};\nconst int MOD = 998244353;\nconst int MAXN = 1e5 + 5;\nconst long long POW = 9973;\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  long long l[n], r[n];\n  for (int i = 0; i < n; i++) cin >> l[i] >> r[i];\n  vector<long long> dp(m + 1, 0);\n  for (int i = m; i >= 1; i--) {\n    long long mn = 0;\n    long long ar[n];\n    long long ava;\n    vector<vector<long long>> tdp;\n    for (int j = 0; j < n; j++) {\n      long long tmp;\n      if (l[j] % i == 0) {\n        tmp = l[j];\n        mn += l[j];\n      } else {\n        tmp = l[j] - (l[j] % i);\n        tmp += i;\n        if (tmp > r[j]) goto skip;\n        mn += tmp;\n      }\n      ar[j] = (r[j] - tmp) / i;\n    }\n    ava = (m - mn) / i;\n    if (mn > m) goto skip;\n    tdp = vector<vector<long long>>(n, vector<long long>(ava + 1, 0));\n    for (int j = 0; j < n; j++) {\n      if (j == 0) {\n        for (int l = 0; l <= ar[j]; l++) {\n          if (l > ava) break;\n          tdp[0][l] = 1;\n        }\n        continue;\n      }\n      vector<long long> pref(ava + 1, 0);\n      for (int l = 0; l <= ava; l++) {\n        pref[l] += tdp[j - 1][l];\n        pref[l] %= MOD;\n        if (l + ar[j] + 1 <= ava) {\n          pref[l + ar[j] + 1] =\n              (pref[l + ar[j] + 1] + MOD - tdp[j - 1][l]) % MOD;\n        }\n      }\n      long long tot = 0;\n      for (int l = 0; l <= ava; l++) {\n        tot += pref[l];\n        tot %= MOD;\n        tdp[j][l] = tot;\n      }\n    }\n    for (int l = 0; l <= ava; l++) {\n      dp[i] += tdp[n - 1][l];\n      dp[i] %= MOD;\n    }\n    for (int j = i * 2; j <= m; j += i) dp[i] = (dp[i] + MOD - dp[j]) % MOD;\n  skip:;\n  }\n  cout << dp[1] << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nstream Butter!\neggyHide eggyVengeance\nI need U\nxiao rerun when\n */\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1559E2\n{\n    static final long MOD = 998244353L;\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int[] left = new int[N];\n        int[] right = new int[N];\n        for(int i=0; i < N; i++)\n        {\n            st = new StringTokenizer(infile.readLine());\n            left[i] = Integer.parseInt(st.nextToken());\n            right[i] = Integer.parseInt(st.nextToken());\n        }\n        long[] ways = new long[M+1];\n        outer:for(int v=1; v <= M; v++)\n        {\n            int CAP = M/v;\n            long[] dp = new long[CAP+1];\n            dp[0] = 1L;\n            for(int t=0; t < N; t++)\n            {\n                int min = Integer.MAX_VALUE;\n                int max = 0;\n                for(int i=v; i <= right[t]; i+=v)\n                    if(i >= left[t])\n                    {\n                        min = min(min, i/v);\n                        max = i/v;\n                    }\n                if(min == Integer.MAX_VALUE)\n                    continue outer;\n                long[] psums = new long[CAP+1];\n                psums[0] = dp[0];\n                for(int i=1; i <= CAP; i++)\n                {\n                    psums[i] = psums[i-1]+dp[i];\n                    if(psums[i] >= MOD)\n                        psums[i] -= MOD;\n                }\n                long[] next = new long[CAP+1];\n                for(int i=min; i <= CAP; i++)\n                {\n                    int r = i-min;\n                    int l = max(0, i-max);\n                    next[i] = psums[r];\n                    if(l > 0)\n                        next[i] -= psums[l-1];\n                    if(next[i] < 0)\n                        next[i] += MOD;\n                }\n                dp = next;\n            }\n            for(long x: dp)\n            {\n                ways[v] += x;\n                if(ways[v] >= MOD)\n                    ways[v] -= MOD;\n            }\n        }\n        for(int d=M; d >= 1; d--)\n            for(int v=d+d; v <= M; v+=d)\n            {\n                ways[d] -= ways[v];\n                if(ways[d] < 0)\n                    ways[d] += MOD;\n            }\n        System.out.println(ways[1]%MOD);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}\n/*\ndp_g[m] = # of ways to choose N stars such that sum = m and gcd is divisible by g\n */"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10, mod = 998244353;\nint mu[maxn], n, m, l[51], r[51], prime[maxn], cnt;\nbool is_composite[maxn];\nint dp[maxn], pre[maxn];\nint cal(int d) {\n  int M = m / d;\n  for (int i = 1; i <= M; i++) dp[i] = 0;\n  dp[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    int L = (l[i] + d - 1) / d, R = r[i] / d;\n    if (L > R) return 0;\n    pre[0] = dp[0];\n    for (int j = 1; j <= M; j++) pre[j] = (pre[j - 1] + dp[j]) % mod;\n    for (int j = 0; j <= M; j++) {\n      dp[j] = (((j - L >= 0) ? pre[j - L] : 0) -\n               ((j - R - 1 >= 0) ? pre[j - R - 1] : 0)) %\n              mod;\n    }\n  }\n  pre[0] = dp[0];\n  for (int j = 0; j <= M; j++) pre[j] = (pre[j - 1] + dp[j]) % mod;\n  return pre[M];\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &l[i], &r[i]);\n  mu[1] = 1;\n  for (int i = 2; i <= m; i++) {\n    if (!is_composite[i]) {\n      prime[++cnt] = i;\n      mu[i] = mod - 1;\n    }\n    for (int j = 1; j <= cnt && i * prime[j] <= m; j++) {\n      is_composite[i * prime[j]] = true;\n      if (i % prime[j])\n        mu[i * prime[j]] = (mod - mu[i]) % mod;\n      else\n        break;\n    }\n  }\n  int ans = 0;\n  for (int d = 1; d <= m; d++) {\n    ans = (ans + 1LL * cal(d) * mu[d]) % mod;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main extends PrintWriter {\n    \n    long M = 998244353L;\n    \n    void solve() {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] l = new int[n];\n        int[] r = new int[n];\n        for(int i = 0; i < n; i++) {\n            l[i] = sc.nextInt();\n            r[i] = sc.nextInt();\n        }\n        long[] ans = new long[m+1];\n        for(int d = m; d >= 1; d--) {\n            int t = m / d;\n            long[] dp = new long[t+1];\n            long[] pre = new long[t+1];\n            dp[0] = 1L;\n            Arrays.fill(pre, 1L);\n            for(int j = 0; j < n; j++) {\n                int ll = (l[j]+d-1)/d;\n                int rr = r[j]/d;\n                for(int k = 0; k <= t; k++) {\n                    dp[k] = (k-ll<0?0L:pre[k-ll]) - (k-rr-1<0?0L:pre[k-rr-1]);\n                    if(dp[k] < 0) dp[k] += M;\n                }\n                long sum = 0L;\n                for(int k = 0; k <= t; k++) {\n                    sum += dp[k];\n                    if(sum >= M) sum -= M;\n                    pre[k] = sum;\n                }\n            }\n            ans[d] = pre[t]; \n            for(int j = 2*d; j <= m; j += d) {\n                ans[d] -= ans[j];\n                if(ans[d] < 0) ans[d] += M;\n            }\n        }\n        println(ans[1]);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(\"output.txt\")); }\n//  InputReader sc = new InputReader(new FileInputStream(\"test_input.txt\"));\n  Main() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\\n' || c == '\\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Main solution = new Main(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, \"1\", 1 << 27).start();\n \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nlong long inv(long long i) {\n  if (i == 1) return 1;\n  return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;\n}\nlong long mod_mul(long long a, long long b) {\n  a = a % mod;\n  b = b % mod;\n  return (((a * b) % mod) + mod) % mod;\n}\nlong long mod_add(long long a, long long b) {\n  a = a % mod;\n  b = b % mod;\n  return (((a + b) % mod) + mod) % mod;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long ceil_div(long long a, long long b) {\n  return a % b == 0 ? a / b : a / b + 1;\n}\nlong long pwr(long long a, long long b) {\n  a %= mod;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nlong long mx = 100000;\nvector<long long> mobius(1 + mx, 0);\nvector<bool> isprime(1 + mx, true);\nlong long n, m;\nvector<long long> l, r;\nvoid sieve() {\n  isprime[1] = false;\n  mobius[1] = 1;\n  vector<long long> primes;\n  long long i, j;\n  for (i = 2; i <= mx; i++) {\n    if (isprime[i]) {\n      primes.push_back(i);\n      mobius[i] = -1;\n    }\n    for (j = 0; j < primes.size() and i * primes[j] <= mx; j++) {\n      isprime[i * primes[j]] = false;\n      if (i % primes[j] == 0) {\n        mobius[i * primes[j]] = 0;\n        break;\n      } else {\n        mobius[i * primes[j]] = mobius[i] * mobius[primes[j]];\n      }\n    }\n  }\n}\nlong long solve(long long d) {\n  long long M;\n  M = m / d;\n  vector<long long> dp(M + 1, 0);\n  long long i, j;\n  vector<long long> psum(M + 1, 0);\n  dp[0] = 1;\n  for (i = 0; i <= M; i++) psum[i] = 1;\n  for (i = 1; i <= n; i++) {\n    long long left, right;\n    left = ceil_div(l[i], d);\n    right = r[i] / d;\n    if (left > right) return 0LL;\n    for (j = 0; j <= M; j++) {\n      dp[j] = ((j - left >= 0 ? psum[j - left] : 0LL) + mod -\n               (j - right > 0 ? psum[j - right - 1] : 0LL)) %\n              mod;\n    }\n    for (j = 0; j <= M; j++) {\n      psum[j] = (j == 0 ? dp[0] : mod_add(dp[j], psum[j - 1]));\n    }\n  }\n  long long ans = 0;\n  for (i = 1; i <= M; i++) {\n    ans = mod_add(ans, dp[i]);\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t, i, j, ans, temp, sum;\n  string sans;\n  t = 1;\n  while (t--) {\n    sans = \"NO\";\n    ans = temp = sum = 0;\n    cin >> n >> m;\n    l.resize(n + 1);\n    r.resize(n + 1);\n    for (i = 1; i <= n; i++) {\n      cin >> l[i] >> r[i];\n    }\n    vector<long long> f(m + 1), g(m + 1);\n    for (i = 1; i <= m; i++) {\n      g[i] = solve(i);\n    }\n    for (i = m; i >= 1; i--) {\n      f[i] = g[i] % mod;\n      for (j = 2 * i; j <= m; j += i) {\n        f[i] = (f[i] - f[j] + mod) % mod;\n      }\n    }\n    ans = f[1];\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50, M = 1e5 + 1, MOD = 998244353;\nint l[N], r[N];\nlong long f[M];\nlong long g[N + 1][M];\nint main() {\n  cin.tie(0), cout.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> l[i] >> r[i];\n  for (int i = 1; i <= m; i++) {\n    int res = m;\n    vector<int> cnt;\n    for (int j = 0; j < n; j++) {\n      int dt = (l[j] + i - 1) / i;\n      res -= dt * i;\n      if (dt * i > r[j])\n        res = -1;\n      else\n        cnt.push_back((r[j] - dt * i) / i + 1);\n    }\n    if (res < 0)\n      f[i] = 0;\n    else {\n      int left = res / i;\n      for (int j = 0; j <= left; j++) g[0][j] = 1;\n      for (int k = 0; k < n; k++) {\n        g[k + 1][0] = g[k][0];\n        for (int j = 0; j <= left; j++) {\n          g[k + 1][j] = g[k + 1][j - 1] + g[k][j];\n          if (j - cnt[k] >= 0) g[k + 1][j] -= g[k][j - cnt[k]];\n          g[k + 1][j] %= MOD;\n        }\n      }\n      f[i] = g[n][left];\n    }\n  }\n  for (int i = m; i >= 1; i--)\n    for (int j = i + i; j <= m; j += i) f[i] = (f[i] - f[j]) % MOD;\n  cout << (f[1] + MOD) % MOD << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import deque,Counter\nfrom sys import stdin\n\n#sys.setrecursionlimit(10**7)\nint1=lambda x: int(x)-1\n\ninp=lambda :int(input())\nmi=lambda :map(int,input().split())\nli=lambda :list(mi())\nmi1=lambda :map(int1,input().split())\nli1=lambda :list(mi1())\nmis=lambda :map(str,input().split())\nlis=lambda :list(mis())\n\nstinput=lambda :stdin.readline()[:-1]\nstinp=lambda :int(stinput())\nstmi=lambda :map(int, stdin.readline().split())\nstli=lambda :list(stmi())\nstmi1=lambda :map(int1, stdin.readline().split())\nstli1=lambda :list(stmi1())\nstmis=lambda :stdin.readline()[:-1]\n\npr=print\n\nfrom collections import defaultdict\n\"\"\"\n#\u521d\u671f\u5024 0\nd=defaultdict(int)\n\n#\u521d\u671f\u5024 1\nd=defaultdict(lambda:1)\n\"\"\"\n\nmod=10**9+7\nMod=998244353\nINF=10**18\nans=0\n\nn,m=mi()\nx=[]\nfor i in range(n):\n  a,b=mi()\n  x.append((a,b))\n\ndef f(k):\n  dp=[0]*(m//k+1)\n  t=m//k+1\n  if t<n:\n    return 0\n  dp[0]=1\n  for a,b in x:\n    dp2=[0]*t\n    c=(a+k-1)//k\n    d=b//k\n    cnt=0\n    if c>d:\n      return 0\n    for i in range(c,t):\n      cnt+=dp[i-c]\n      if i>d:\n        cnt-=dp[i-d-1]\n      cnt%=Mod\n      dp2[i]=cnt\n    dp=dp2.copy()\n  #print(m,dp)\n  return sum(dp)%Mod\n\ntmp=[0]*(m+1)\nfor i in range(m,0,-1):\n  t=f(i)\n  j=2*i\n  while j<=m:\n    t-=tmp[j]\n    j+=i\n  tmp[i]=t%Mod\nprint(tmp[1]%Mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 1e5 + 10;\nconst long long mod2 = 998244353;\nlong long n, m, sum[N], ans, cnt;\nlong long l[N], r[N], dp[55][N];\nlong long mu[N], prime[N], prime_tot;\nbool prime_tag[N];\nvoid init(long long lim) {\n  prime_tot = 0;\n  mu[1] = 1;\n  for (long long i = (2); i <= (lim); i++) {\n    if (!prime_tag[i]) {\n      prime[++prime_tot] = i;\n      mu[i] = -1;\n    }\n    for (long long j = (1); j <= (prime_tot); j++) {\n      if (i * prime[j] > lim) break;\n      prime_tag[i * prime[j]] = true;\n      if (i % prime[j] == 0) {\n        mu[i * prime[j]] = 0;\n        break;\n      } else\n        mu[i * prime[j]] = -mu[i];\n    }\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr), std::cout.tie(nullptr);\n  std::cin >> n >> m;\n  init(m);\n  for (long long i = (1); i <= (n); i++) std::cin >> l[i] >> r[i];\n  for (long long d = (1); d <= (m); d++) {\n    dp[0][0] = 1;\n    cnt = 0;\n    for (long long i = (1); i <= (n); i++) {\n      sum[0] = dp[i - 1][0];\n      for (long long j = (1); j <= (m / d); j++)\n        sum[j] = sum[j - 1] + dp[i - 1][j];\n      for (long long j = ((l[i] + d - 1) / d); j <= (m / d); j++) {\n        if (j - r[i] / d - 1 < 0)\n          dp[i][j] = sum[j - ((l[i] + d - 1) / d)];\n        else\n          dp[i][j] = sum[j - ((l[i] + d - 1) / d)] - sum[j - r[i] / d - 1];\n        dp[i][j] %= mod2;\n      }\n    }\n    for (long long i = (1); i <= (m / d); i++) cnt += dp[n][i];\n    ans = ((ans + mu[d] * cnt) % mod2 + mod2) % mod2;\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.net.Inet4Address;\nimport java.util.*;\nimport java.io.*;\n\npublic class B {\n    static int fact, n, m, mod = 998244353;\n    static int memo[][], a[][];\n\n    static int memo2[][];\n\n    static int dp(int idx, int rem) {\n        if (rem < 0)\n            return 0;\n        if (idx == n)\n            return rem >= 0 ? 1 : 0;\n\n        if (memo2[idx][rem] != -1)\n            return memo2[idx][rem];\n        int ans = 0;\n        for (int take = Math.max(fact, ((a[idx][0] + fact - 1) / fact) * fact); take <= a[idx][1]; take += fact) {\n            ans += dp(idx + 1, rem - take);\n            if (ans >= mod)\n                ans -= mod;\n        }\n        return memo2[idx][rem] = ans;\n    }\n\n    static int dp(int fact) {\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= m / fact; j++) {\n                memo[i][j] = i < n ? 0 : 1;\n            }\n\n        int[] pre = new int[m / fact + 1];\n\n        for (int j = 0; j <= m / fact; j++) {\n            pre[j] = memo[n][j];\n            if (j > 0)\n                pre[j] = (pre[j] + pre[j - 1]) % mod;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int cur = 1; cur <= m / fact; cur++) {\n                int end = cur - Math.max(1, (a[i][0] + fact - 1) / fact);\n                int start = cur - (Math.min(a[i][1] / fact, cur));\n\n                if (end < start)\n                    continue;\n                memo[i][cur] += pre[end];\n                if (start - 1 >= 0)\n                    memo[i][cur] -= pre[start - 1];\n                memo[i][cur] += mod;\n                memo[i][cur] %= mod;\n            }\n            for (int j = 0; j <= m / fact; j++) {\n                pre[j] = memo[i][j];\n                if (j > 0)\n                    pre[j] = (pre[j] + pre[j - 1]) % mod;\n            }\n        }\n//        if (dp(0, m) != memo[0][m / fact])\n//            System.err.println(fact);\n        return memo[0][m / fact];\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = sc.nextInt();\n        m = sc.nextInt();\n\n        a = new int[n][2];\n        for (int i = 0; i < n; i++)\n            a[i] = sc.nextIntArr(2);\n\n        memo = new int[n + 1][m + 1];\n\n        memo2 = new int[n + 1][m + 1];\n\n        int[] ans = new int[m + 1];\n\n        for (int i = m; i >= 1; i--) {\n            fact = i;\n//            for (int[] x : memo2)\n//                Arrays.fill(x, -1);\n            ans[i] = dp(i);\n//            ans[i] = dp(0, m);\n\n            for (int k = i + i; k <= m; k += i) {\n                ans[i] -= ans[k];\n                ans[i] += mod;\n                ans[i] %= mod;\n            }\n        }\n//        System.err.println(Arrays.toString(ans));\n        pw.println(ans[1]);\n\n        pw.flush();\n    }\n\n\n    static long gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in=  998244353;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n       \n       int n = readInt();\n       int m = readInt();\n       int l[]=new int[n+1];\n       int r[]=new int[n+1];\n       for(int i =1;i<=n;i++)\n       {\n          l[i]=readInt();\n          r[i]= readInt();\n       }\n      long dp[][]=new long[n+1][m+1];\n\n      int ul[]=new int[n+1];\n      int pl[]=new int[n+1];\n\n      ArrayList<Integer> div = new ArrayList<Integer>();\n\n\n      for(int i=1;i<=m;i++)\n      {\n        if(m%i==0)\n        {\n            div.add(i);\n        }\n      }\n      long val[]=new long[m+1];\n\n      for(int i= 0;i<m;i++)\n      {\n        int g = i+1;\n        int  sum = m/g;\n        boolean check = true;\n\n        for(int j=1;j<=n;j++)\n        {\n            ul[j]= l[j]/g;\n            if((l[j]%g)!=0)\n                ul[j]++;\n            pl[j]= r[j]/g;\n            if(ul[j]>pl[j])\n            {\n                check=false;\n                break;\n            }\n        }\n       // out.println(check);\n        if(!check)\n        {\n            val[i+1]=0;\n\n        }\n        else\n            val[i+1]= val(dp,n,sum,ul,pl);\n      }\n      /*for(int i =0;i<3;i++)\n        out.print(val[i]+\" \");\n      out.println();*/\n      for(int i=m;i>=1;i--)\n      {\n        for(int j=2*i;j<=m;j=j+i)\n        {\n            val[i]= (val[i]-val[j]+in)%in;\n        }\n      }\n\n\n\n\n      out.println(val[1]);\n\n\n\n\n\n            \n       \n\n    }\n\n    public long val (long dp[][] , int n , int sum , int l[] , int r[] )\n    {\n        for(int i=1;i<=sum;i++)\n       if(i>=l[1]&&i<=r[1])\n         dp[1][i]=1;\n       else\n         dp[1][i]=0;\n       long scum[]=new long[sum+1];\n        dp[1][0]=0;\n    //   out.println(l[1]+\" \"+r[1]);\n       for(int i=2;i<=n;i++)\n       {\n        scum[0]=0;\n        for(int j=1;j<=sum;j++)\n         scum[j]= (scum[j-1]+dp[i-1][j])%in;\n         for(int j=1;j<=sum;j++)\n         {\n           int kal = Math.max(j-r[i]-1,0);\n           int pal = Math.max(j-l[i],0);\n         /*  if(sum==2){\n            out.println(kal+\" \"+pal);\n            out.println(l[i]+\"lklkl \"+r[i]);\n           }*/\n           dp[i][j]= ((scum[pal])-(scum[kal])+in)%in;\n         }\n       }\n       scum[0]=0;\n       for(int j=1;j<=sum;j++)\n         scum[j]= (scum[j-1]+dp[n][j])%in;\n     \n      return scum[sum];\n\n    }\n    \n   \n    public long query(long seg[] , int left, int right , int index, int l , int r)\n    {   \n         long inf = 100000000;\n         inf = inf*inf;\n        if(left>=l&&right<=r)\n        {\n            return seg[index];\n        }\n        if(l>right||left>r)\n            return inf;\n        int mid = left+(right-left)/2;\n        return Math.min(query(seg,left,mid,2*index+1,l,r),query(seg,mid+1,right,2*index+2,l,r));\n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int  u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 7, M = 50 + 7, mod = 998244353;\nint prime[N], mu[N], l[M], r[M], r_[M], sum_[N], sum[N], dp[M][N];\nbool p[N];\ninline void init(int n) {\n  int cnt = 0;\n  p[0] = p[1] = true;\n  mu[1] = 1;\n  for (register int i = 2; i <= n; i++) {\n    if (!p[i]) {\n      prime[++cnt] = i;\n      mu[i] = -1;\n    }\n    for (register int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n      int t = i * prime[j];\n      p[t] = true;\n      if (i % prime[j] == 0) {\n        mu[t] = 0;\n        break;\n      }\n      mu[t] = -mu[i];\n    }\n  }\n}\ninline int min(int a, int b) { return a < b ? a : b; }\ninline int do_dp(int n, int m) {\n  if (m < 0) return 0;\n  for (register int i = 1; i <= n; i++) {\n    if (r_[i] < 0) return 0;\n  }\n  int ans = 0;\n  for (register int i = 0; i <= m; i++) {\n    sum_[i] = 1;\n  }\n  for (register int i = 1; i <= n; i++) {\n    for (register int j = 0; j <= m; j++) {\n      int t = min(r_[i], j);\n      if (i == n) ans = (ans + sum_[t]) % mod;\n      sum[j] = sum_[t];\n      if (j > 0) sum[j] = (sum[j] + sum[j - 1]) % mod;\n    }\n    for (register int j = 0; j <= m; j++) {\n      sum_[j] = sum[j];\n    }\n  }\n  return ans;\n}\nint main() {\n  int n, m, mi, ans = 0;\n  scanf(\"%d %d\", &n, &m);\n  mi = m + 1;\n  init(m);\n  for (register int i = 1; i <= n; i++) {\n    scanf(\"%d %d\", &l[i], &r[i]);\n  }\n  for (register int i = 1; i <= m; i++) {\n    int sum = 0;\n    for (register int k = 1; k <= n; k++) {\n      int tl = (l[k] - 1) / i + 1;\n      r_[k] = r[k] / i - tl;\n      sum = min(sum + tl, mi);\n    }\n    ans = ((ans + mu[i] * do_dp(n, m / i - sum)) % mod + mod) % mod;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100002, M = 998244353;\nint n, m, t, i, j, L[N], R[N], l, r, o[N], f[N], Ans[N];\nvoid Add(int &x, int y) {\n  x += y;\n  x = x >= M ? x - M : x;\n}\nint Q(int p) {\n  int i, j, k;\n  t = m / p;\n  for (i = 1; i <= n; i++) {\n    r = R[i] / p;\n    l = (L[i] + p - 1) / p;\n    t -= l;\n    o[i] = r - l + 1;\n  }\n  if (t < 0) return 0;\n  for (i = 0; i <= t; i++) f[i] = 0;\n  f[0] = 1;\n  for (i = 1; i <= n; i++) {\n    k = o[i];\n    for (j = t; j >= k; j--) Add(f[j], -f[j - k] + M);\n  }\n  for (i = 0; i <= n; i++)\n    for (j = 1; j <= t; j++) Add(f[j], f[j - 1]);\n  return f[t];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) scanf(\"%d%d\", L + i, R + i);\n  for (i = 1; i <= m; i++) Ans[i] = Q(i);\n  for (i = m; i; i--)\n    for (j = i * 2; j <= m; j += i) Add(Ans[i], M - Ans[j]);\n  printf(\"%d\\n\", Ans[1]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 12;\nconst int M = 1e5 + 12;\nconst long long Mod = 998244353;\nconst long long oo = 1e18;\nmt19937 rd(chrono::steady_clock::now().time_since_epoch().count());\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\nint n, m;\nlong long ans = 0;\nlong long dp[N], mu[N], f[51][N], Sum[51][N], cnt[N];\npair<int, int> a[N], b[N];\nvoid Init() {\n  mu[1] = 1;\n  for (int _ = 1, __ = M, i = _; i <= __; i++)\n    for (int j = 2 * i; j <= M; j += i) mu[j] -= mu[i];\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int _ = 1, __ = n, i = _; i <= __; i++) cin >> a[i].first >> a[i].second;\n  Init();\n  for (int _ = m, __ = 1, x = _; x >= __; x--) {\n    int s = m / x;\n    long long temp = 0;\n    for (int _ = 1, __ = n, i = _; i <= __; i++) {\n      if (temp == -1) break;\n      b[i] = {(a[i].first / x) + 1, a[i].second / x};\n      if (a[i].first % x == 0) b[i].first--;\n      if (b[i].first > b[i].second) temp = -1;\n    }\n    if (temp == -1)\n      cnt[x] = 0;\n    else {\n      for (int _ = 1, __ = s, i = _; i <= __; i++) {\n        if (i >= b[1].first && i <= b[1].second)\n          f[1][i] = 1;\n        else\n          f[1][i] = 0;\n        Sum[1][i] = Sum[1][i - 1] + f[1][i];\n      }\n      for (int _ = 2, __ = n, i = _; i <= __; i++) {\n        for (int _ = 1, __ = s, k = _; k <= __; k++) {\n          int l = max(k - b[i].second, 1), r = k - b[i].first;\n          if (l > r)\n            f[i][k] = 0;\n          else\n            f[i][k] = (Sum[i - 1][r] - Sum[i - 1][l - 1] + Mod) % Mod;\n          Sum[i][k] = (Sum[i][k - 1] + f[i][k]) % Mod;\n        }\n      }\n      cnt[x] = Sum[n][s] % Mod;\n    }\n    ans = (ans + cnt[x] * mu[x] + Mod * 2) % Mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 57, M = 1e5 + 7, MOD = 998244353;\nint f[N][M], s[M];\nint _L[N], _R[N], L[N], R[N];\nint primes[M], cnt, mob[M];\nbool st[M];\nvoid init() {\n  mob[1] = 1;\n  for (int i = 2; i <= M - 1; ++i) {\n    if (!st[i]) primes[cnt++] = i, mob[i] = -1;\n    for (int j = 0; j < cnt && 1ll * primes[j] * i < M; ++j) {\n      st[primes[j] * i] = 1;\n      if (i % primes[j] == 0) break;\n      mob[i * primes[j]] = -mob[i];\n    }\n  }\n}\nint dp(int n, int m) {\n  f[0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= m; ++j)\n      s[j] = ((j > 0 ? s[j - 1] : 0) + f[i - 1][j]) % MOD;\n    for (int j = L[i]; j <= m; ++j)\n      f[i][j] = (s[j - L[i]] - (j - R[i] <= 0 ? 0 : s[j - R[i] - 1])) % MOD;\n  }\n  int res = 0;\n  for (int j = 0; j <= m; ++j) res = (res + f[n][j]) % MOD;\n  return res;\n}\nint main() {\n  init();\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &_L[i], &_R[i]);\n  int res = 0;\n  for (int d = 1; d <= m; ++d) {\n    for (int i = 1; i <= n; ++i) L[i] = (_L[i] + d - 1) / d, R[i] = _R[i] / d;\n    res = (res + 1ll * mob[d] * dp(n, m / d) % MOD) % MOD;\n    res = (res % MOD + MOD) % MOD;\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50 + 13, M = 1e5 + 13, mod = 998244353;\nint n, m, prm[M], cnt, mu[M], L[N], R[N], l[N], r[N], f[M], g[M];\nbool b[M];\ninline void init() {\n  mu[1] = 1;\n  for (int i = 2; i <= m; ++i) {\n    if (!b[i]) prm[++cnt] = i, mu[i] = -1;\n    for (int j = 1; j <= cnt && i * prm[j] <= m; ++j) {\n      b[i * prm[j]] = 1;\n      if (i % prm[j] == 0) break;\n      mu[i * prm[j]] = -mu[i];\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &L[i], &R[i]);\n  init();\n  int ans = 0;\n  for (int d = 1; d <= m; ++d) {\n    if (!mu[d]) continue;\n    for (int i = 1; i <= n; ++i) l[i] = (L[i] - 1) / d + 1, r[i] = R[i] / d;\n    int tmp = m / d;\n    for (int i = 1; i <= tmp; ++i) f[i] = 0;\n    for (int i = l[1]; i <= r[1]; ++i) f[i] = 1;\n    for (int i = 1; i <= tmp; ++i) g[i] = (g[i - 1] + f[i]) % mod;\n    for (int i = 2; i <= n; ++i) {\n      for (int j = 1; j < l[i]; ++j) f[j] = 0;\n      for (int j = l[i]; j <= tmp; ++j) {\n        f[j] = g[j - l[i]];\n        if (j - r[i] - 1 >= 1)\n          f[j] -= g[j - r[i] - 1], f[j] = (f[j] % mod + mod) % mod;\n      }\n      g[0] = 0;\n      for (int j = 1; j <= tmp; ++j) g[j] = (g[j - 1] + f[j]) % mod;\n    }\n    ans += mu[d] * g[tmp] % mod, ans = (ans % mod + mod) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m;\nint L[55], R[55], x[55], y[55];\nlong long f[100005], g[100005];\nlong long dp[100005], pre[100005];\nlong long solve(int d) {\n  for (int i = 1; i <= n; i++) {\n    x[i] = (L[i] - 1) / d + 1;\n    y[i] = R[i] / d;\n  }\n  for (int j = 0; j <= m / d; j++) pre[j] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < x[i]; j++) dp[j] = 0;\n    for (int j = x[i]; j <= m / d; j++) {\n      dp[j] = pre[j - x[i]];\n      if (j > y[i]) dp[j] -= pre[j - y[i] - 1];\n      dp[j] %= 998244353;\n    }\n    pre[0] = dp[0];\n    for (int j = 1; j <= m / d; j++) pre[j] = (pre[j - 1] + dp[j]) % 998244353;\n  }\n  return pre[m / d];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &L[i], &R[i]);\n  for (int i = 1; i <= m; i++) f[i] = solve(i);\n  for (int i = m; i >= 1; i--) {\n    g[i] = f[i];\n    for (int j = 2 * i; j <= m; j += i) g[i] -= g[j];\n    g[i] %= 998244353;\n  }\n  printf(\"%lld\\n\", (g[1] + 998244353) % 998244353);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, P = 998244353;\nint n, m, a[N], L[N], R[N], mu[N], f[N], g[N];\nint main() {\n  mu[1] = 1;\n  for (int i = 1; i < N; ++i)\n    for (int j = 2 * i; j < N; j += i) mu[j] -= mu[i];\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n  }\n  int ans = 0;\n  for (int i = 1; i < N; ++i) {\n    if (mu[i]) {\n      f[0] = 1;\n      int mx = m / i;\n      for (int z = 1; z <= mx; ++z) f[z] = 0;\n      for (int k = 1; k <= n; ++k) {\n        int l = (L[k] + i - 1) / i, r = R[k] / i;\n        for (int z = 0; z <= mx; ++z) g[z] = 0;\n        for (int z = 0; z <= mx; ++z) {\n          if (l + z <= mx) g[l + z] = (g[l + z] + f[z]) % P;\n          if (r + z <= mx) g[r + z + 1] = (g[r + z + 1] - f[z]) % P;\n        }\n        f[0] = g[0];\n        for (int z = 1; z <= mx; ++z) f[z] = (f[z - 1] + g[z]) % P;\n      }\n      for (int z = 0; z <= mx; ++z) ans = (ans + mu[i] * f[z]) % P;\n    }\n  }\n  if (ans < 0) ans += P;\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "//Utilities\nimport java.io.*;\nimport java.util.*;\n\npublic class A {\n\tstatic int n, m;\n\tstatic int[] l, r;\n\tstatic final int MOD = 998244353;\n\tstatic long res, tmp;\n\tstatic long[][] dp;\n\tstatic long[] psa;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tn = in.iscan(); m = in.iscan();\n\t\tl = new int[n+1]; r = new int[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tl[i] = in.iscan(); r[i] = in.iscan();\n\t\t}\n\t\tcalcMobius(m);\n\t\tdp = new long[m+1][2];\n\t\tres = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (mobius[i] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mx = m/i;\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tint ll = (l[j] + i - 1) / i, rr = r[j] / i;\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tfor (int r = ll; r <= Math.min(mx, rr); r++) {\n\t\t\t\t\t\tdp[r][j%2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpsa = new long[mx+1];\n\t\t\t\tfor (int r = 0; r <= mx; r++) {\n\t\t\t\t\tdp[r][j%2] = 0;\n\t\t\t\t\tpsa[r] = dp[r][(j+1)%2];\n\t\t\t\t\tif (r > 0) {\n\t\t\t\t\t\tpsa[r] = (psa[r] + psa[r-1]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int r = 0; r <= mx; r++) {\n\t\t\t\t\tif (r - ll >= 0) {\n\t\t\t\t\t\tdp[r][j%2] = r - rr > 0 ? ((psa[r-ll] - psa[r-rr-1]) % MOD + MOD) % MOD : psa[r-ll];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[r][j%2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = 0;\n\t\t\tfor (int j = 1; j <= mx; j++) {\n\t\t\t\ttmp = (tmp + dp[j][n%2]) % MOD;\n\t\t\t\tdp[j][(n+1)%2] = dp[j][n%2] = 0;\n\t\t\t}\n//\t\t\tout.println(i + \" \" + mobius[i] + \" \" +  tmp);\n\t\t\tres = (res + mobius[i] * tmp % MOD) % MOD;\n\t\t}\n\t\tres = (res + MOD) % MOD;\n\t\tout.println(res);\n\t\tout.close();\n\t} \n\t\n\tstatic int[] mobius, lpf;\n\tstatic void calcMobius(int n) {\n\t\tmobius = new int[n+1]; // mobius function for 1, 2, ..., n-1, n\n\t\tlpf = new int[n+1]; // least prime factor\n\t\tboolean[] vis = new boolean[n+1];\n\t\t// set up lpf\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tfor (int j = i; j <= n; j += i) {\n\t\t\t\t\tif (!vis[j]) {\n\t\t\t\t\t\tvis[j] = true;\n\t\t\t\t\t\tlpf[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}   \n\t\t}\n\t\t// set up mobius\n\t\tmobius[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (lpf[i / lpf[i]] == lpf[i]) {\n\t\t\t\tmobius[i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmobius[i] = -1 * mobius[i / lpf[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic INPUT in = new INPUT(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\t\t\t\n\t\t\tif (numChars == -1)\n\t\t\t\treturn numChars;\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\t\t\t\t\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\t\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\t\t\n\t\tpublic static void sort(int[] a, boolean increasing) {\n\t\t\tArrayList<Integer> arr = new ArrayList<Integer>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(long[] a, boolean increasing) {\n\t\t\tArrayList<Long> arr = new ArrayList<Long>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void sort(double[] a, boolean increasing) {\n\t\t\tArrayList<Double> arr = new ArrayList<Double>();\n\t\t\tint n = a.length;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr.add(a[i]);\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (increasing) {\n\t\t\t\t\ta[i] = arr.get(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] = arr.get(n-1-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static long gcd (long a, long b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static long lcm (long a, long b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static long fast_pow_mod (long b, long x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t\t\n\t\t// start of permutation and lower/upper bound template\n\t\tpublic static void nextPermutation(int[] nums) {\n\t\t    //find first decreasing digit\n\t\t    int mark = -1;\n\t\t    for (int i = nums.length - 1; i > 0; i--) {\n\t\t        if (nums[i] > nums[i - 1]) {\n\t\t            mark = i - 1;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    if (mark == -1) {\n\t\t        reverse(nums, 0, nums.length - 1);\n\t\t        return;\n\t\t    }\n\t\t \n\t\t    int idx = nums.length-1;\n\t\t    for (int i = nums.length-1; i >= mark+1; i--) {\n\t\t        if (nums[i] > nums[mark]) {\n\t\t            idx = i;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t \n\t\t    swap(nums, mark, idx);\n\t\t \n\t\t    reverse(nums, mark + 1, nums.length - 1);\n\t\t}\n\t\t \n\t\tpublic static void swap(int[] nums, int i, int j) {\n\t\t    int t = nums[i];\n\t\t    nums[i] = nums[j];\n\t\t    nums[j] = t;\n\t\t}\n\t\t \n\t\tpublic static void reverse(int[] nums, int i, int j) {\n\t\t    while (i < j) {\n\t\t        swap(nums, i, j);\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t}\n\t\t\n\t\tstatic int lower_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] >= cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t \n\t\tstatic int upper_bound (int[] arr, int hi, int cmp) {\n\t\t\tint low = 0, high = hi, mid = -1;\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\t\t\t\tif (arr[mid] > cmp) high = mid;\n\t\t\t\telse low = mid + 1;\n\t\t\t}\n\t\t\treturn low;\n\t\t}\n\t\t// end of permutation and lower/upper bound template\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nconst long long mod = 998244353;\nint l[maxn];\nint r[maxn];\nlong long dp[60][maxn];\nlong long cnt[maxn];\nlong long sum[maxn];\nint main() {\n  ios::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  for (int k = 1; k <= m; k++) {\n    int top = m / k;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      int tl = (l[i] + k - 1) / k;\n      int tr = r[i] / k;\n      sum[0] = dp[i - 1][0];\n      for (int j = 1; j <= top; j++) {\n        sum[j] = sum[j - 1] + dp[i - 1][j];\n        sum[j] %= mod;\n        dp[i - 1][j] = 0;\n      }\n      for (int j = tl; j <= top; j++) {\n        dp[i][j] += sum[j - tl] - ((j - tr - 1 < 0) ? 0 : sum[j - tr - 1]);\n        dp[i][j] %= mod;\n      }\n    }\n    for (int i = 1; i <= top; i++) {\n      cnt[k] += dp[n][i];\n      dp[n][i] = 0;\n      cnt[k] %= mod;\n    }\n  }\n  for (int i = m; i > 0; i--) {\n    for (int j = 2; i * j <= m; j++) {\n      cnt[i] -= cnt[i * j];\n      cnt[i] += mod;\n      cnt[i] %= mod;\n    }\n  }\n  cout << cnt[1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50 + 5;\nconst long long M = 1e5 + 5;\nconst long long mod = 998244353;\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double PI = acos(-1.0);\nconst pair<int, int> NIL = {0, 0};\nint n, m;\nlong long l[N], r[N], mu[M], sum[M], f[M];\nlong long deal(long long d) {\n  long long lim = m / d;\n  f[0] = 1;\n  for (long long i = 1; i <= lim; ++i) f[i] = 0;\n  for (long long i = 1; i <= n; ++i) {\n    long long L = (l[i] + d - 1) / d, R = r[i] / d;\n    if (L > R) return 0;\n    sum[0] = f[0];\n    for (long long j = 1; j <= lim; ++j) sum[j] = (f[j] + sum[j - 1]) % mod;\n    for (long long j = 0; j <= lim; ++j) {\n      if (j > R)\n        f[j] = (sum[j - L] - sum[j - R - 1] + mod) % mod;\n      else if (j >= L)\n        f[j] = sum[j - L];\n      else\n        f[j] = 0;\n    }\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= lim; ++i) ans = (ans + f[i]) % mod;\n  return ans;\n}\nvoid solve() {\n  mu[1] = 1;\n  cin >> n >> m;\n  for (long long i = 1; i <= m; ++i)\n    for (int j = i + i; j <= m; j += i) mu[j] = (mu[j] + mod - mu[i]) % mod;\n  for (long long i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n  long long ans = 0;\n  for (long long i = 1; i <= m; ++i) {\n    ans = (mu[i] * deal(i) + ans + mod) % mod;\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong long MOD = 998244353;\ndouble eps = 1e-12;\nconst int N = 3e5 + 7;\nint n, m;\nint mnrr[57], mxrr[57];\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> mnrr[i] >> mxrr[i];\n  vector<long long> ans(m + 1, 0);\n  for (int g = 1; g <= m; g++) {\n    long long limit = m / g;\n    vector<long long> dp(limit + 1, 1);\n    for (int i = 1; i <= n; i++) {\n      long long rngmn = (mnrr[i] + g - 1) / g;\n      long long rngmx = mxrr[i] / g;\n      if (rngmn > rngmx) {\n        dp[limit] = 0;\n        break;\n      }\n      vector<long long> ndp(limit + 1, 0);\n      for (int sum = rngmn; sum <= limit; sum++) {\n        ndp[sum] = dp[sum - rngmn];\n        if (sum > rngmx) {\n          ndp[sum] = (ndp[sum] - dp[sum - rngmx - 1]) % MOD;\n        }\n        ndp[sum] = (ndp[sum - 1] + ndp[sum]) % MOD;\n      }\n      dp = ndp;\n    }\n    ans[g] = dp[limit];\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) {\n      ans[i] = (ans[i] - ans[j] + MOD) % MOD;\n    }\n  }\n  cout << ans[1] << \"\\n\";\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  for (int it = 1; it <= t; it++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nlong long n, m, prim[200050], mu[200050], cnt, tt, vis[200500];\nlong long dp[55][100500], l[500500], r[505000], ll[500500], rr[500500], ans,\n    tot[500500];\nvoid prime(long long n) {\n  mu[1] = 1;\n  for (register int i = 2; i <= 100000; i++) {\n    if (!vis[i]) prim[++cnt] = i, mu[i] = -1;\n    for (int j = 1; j <= cnt && prim[j] * i <= n; j++) {\n      vis[i * prim[j]] = 1;\n      if (i % prim[j] == 0)\n        break;\n      else\n        mu[i * prim[j]] = -mu[i];\n    }\n  }\n}\nvoid work(int k) {\n  if (mu[k] == 0) return;\n  for (int i = 1; i <= n; i++) {\n    ll[i] = (l[i] - 1) / k + 1;\n    rr[i] = r[i] / k;\n    if (ll[i] > rr[i]) return;\n  }\n  int tt = m / k;\n  for (int j = 0; j <= m / k; j++) tot[j] = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= m / k; j++) dp[i][j] = 0;\n  }\n  for (int i = ll[1]; i <= rr[1]; i++) {\n    dp[1][i] = 1;\n  }\n  tot[0] = 0;\n  for (int j = 1; j <= m / k; j++) tot[j] = tot[j - 1] + dp[1][j];\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= tt; j++) {\n      dp[i][j] =\n          (tot[max(j - ll[i], 0ll)] - tot[max(j - rr[i] - 1, 0ll)] + mod) % mod;\n    }\n    tot[0] = 0;\n    for (int j = 1; j <= m / k; j++) tot[j] = (tot[j - 1] + dp[i][j]) % mod;\n  }\n  for (int i = 1; i <= tt; i++) {\n    ans = (ans + 1ll * mu[k] * dp[n][i] + mod) % mod;\n  }\n}\nint main() {\n  prime(200000);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &l[i], &r[i]);\n  }\n  for (int i = 1; i <= m; i++) {\n    work(i);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int mod = 998244353;\ninline int add(int x, int y) { return (x + y >= mod ? x + y - mod : x + y); }\ninline int sub(int x, int y) { return (x - y < 0 ? x - y + mod : x - y); }\ninline int gun(int x, int y) { return ((x * 1ll * y) % mod); }\nint n, m;\npair<int, int> a[55];\nint g[N];\nint dp[N][55];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  for (int now = 1; now <= m; now++) {\n    int sum = m / now;\n    for (int idx = n; idx >= 0; idx--) {\n      int l = (a[idx].first + now - 1) / now;\n      int r = a[idx].second / now;\n      for (int cur = 0; cur <= sum; cur++) {\n        if (idx == n) {\n          dp[cur][idx] = 1;\n          continue;\n        }\n        int ans = 0;\n        if (l <= r && cur + l <= sum) {\n          int ses = min(cur + r, sum);\n          ans = dp[ses][idx + 1];\n          if (cur + l - 1 >= 0) ans = sub(ans, dp[cur + l - 1][idx + 1]);\n        }\n        dp[cur][idx] = ans;\n      }\n      for (int cur = 1; cur <= sum; cur++) {\n        dp[cur][idx] = add(dp[cur][idx], dp[cur - 1][idx]);\n      }\n    }\n    g[now] = dp[0][0];\n    ;\n  }\n  for (int i = m; i >= 1; i--) {\n    for (int j = i + i; j <= m; j += i) {\n      g[i] = sub(g[i], g[j]);\n    }\n  }\n  cout << g[1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lli = long long int;\nusing ulli = unsigned long long int;\nusing Ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<lli, lli>;\nusing pld = pair<Ld, Ld>;\nint pi[100001];\nconst lli MOD = 998244353;\npii p[51];\nlli dp[51][100001];\nlli GetRes(int n, int m, int g) {\n  for (int i = (0); i <= (m); i++) dp[0][i] = 1;\n  for (int k = (0); k < (n); k++) {\n    lli l = (p[k].first + g - 1) / g, r = p[k].second / g;\n    if (l > r) return 0;\n    for (int i = (1); i <= (m); i++) {\n      lli s = 0;\n      if (i - l >= 0) s = dp[k][i - l];\n      lli mi = 0;\n      if (i - r - 1 >= 0) mi = dp[k][i - r - 1];\n      dp[k + 1][i] = s - mi;\n      dp[k + 1][i] = (dp[k + 1][i] + MOD) % MOD;\n    }\n    dp[k + 1][0] = 0;\n    for (int i = (1); i <= (m); i++) {\n      dp[k + 1][i] += dp[k + 1][i - 1];\n      dp[k + 1][i] %= MOD;\n    }\n  }\n  return dp[n][m];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = (0); i < (n); i++) cin >> p[i].first >> p[i].second;\n  pi[1] = 1;\n  lli res = 0;\n  for (int i = (1); i <= (m / n + 1); i++) {\n    if (pi[i] == 0) continue;\n    res += pi[i] * GetRes(n, m / i, i);\n    res = (res + MOD) % MOD;\n    for (int j = i + i; j <= m / n + 1; j += i) pi[j] -= pi[i];\n  }\n  cout << res;\n  cout.flush();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nmod = 998244353\nlr = [list(map(int, input().split())) for _ in range(n)]\nans = 0\ns = [0] * (m + 1)\ns[1] = 1\nfor j in range(1, m + 1):\n    m0 = m // j\n    dpsum = [1] * (m0 + 2)\n    dpsum[0] = 0\n    dp = [0] * (m0 + 1)\n    ok = 1\n    s0 = 0\n    for l, r in lr:\n        l0, r0 = int(math.ceil(l / j)), r // j\n        if l0 > r0:\n            ok = 0\n            break\n        l0 -= 1\n        for i in range(m0 + 1):\n            dp[i] = dpsum[max(0, i - l0)] - dpsum[max(0, i - r0)]\n            dp[i] %= mod\n        for i in range(m0 + 1):\n            dpsum[i + 1] = dp[i] + dpsum[i]\n            dpsum[i + 1] %= mod\n    if ok:\n        sj = s[j]\n        ss = 0\n        for i in range(m0 + 1):\n            ss += dp[i]\n            ss %= mod\n        ans += sj * ss % mod\n        ans %= mod\n        for k in range(2 * j, m + 1, j):\n            s[k] -= sj\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, N = 2e5 + 5;\nint l[N], r[N], mu[N], vis[N];\nint cnt, prime[N];\nint a[N], b[N];\nvoid init(int n) {\n  mu[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!vis[i]) vis[i] = 1, mu[i] = mod - 1, prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] > n / i) break;\n      vis[i * prime[j]] = 1;\n      if (i % prime[j])\n        mu[i * prime[j]] = mod - mu[i];\n      else\n        break;\n    }\n  }\n}\nint f[55][100005];\nint calc(int x, int n, int m) {\n  int lim = m / x;\n  for (int i = 1; i <= n; ++i)\n    a[i] = l[i] / x, b[i] = r[i] / x - l[i] / x, lim -= a[i];\n  for (int i = 1; i <= n; ++i)\n    if (b[i] <= 0) return 0;\n  if (lim <= 0) return 0;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= lim; ++j) f[i][j] = 0;\n  for (int j = 1; j <= min(b[1], lim); ++j) f[1][j] = 1;\n  for (int j = 1; j <= lim; ++j) f[1][j] += f[1][j - 1];\n  for (int i = 2; i <= n; ++i)\n    for (int j = 1; j <= lim; ++j) {\n      f[i][j] = (f[i - 1][j - 1] + f[i][j - 1]) % mod;\n      if (j - b[i] - 1 >= 0)\n        f[i][j] = (f[i][j] + mod - f[i - 1][j - b[i] - 1]) % mod;\n    }\n  return f[n][lim];\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  init(n + m);\n  for (int i = 1; i <= n; ++i) cin >> l[i] >> r[i], l[i]--;\n  int ans = 0;\n  for (int i = 1; i <= m; ++i)\n    if (mu[i]) ans = (ans + 1ll * mu[i] * calc(i, n, m)) % mod;\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class MochaAndStars {\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int mod = 998244353;\n        int N = in.nextInt(), K = in.nextInt();\n        int[] left = new int[N], right = new int[N];\n        for (int i = 0; i < N; i++) {\n            left[i] = in.nextInt();\n            right[i] = in.nextInt();\n        }\n        \n        int[] dp2 = new int[K + 1];\n        for (int k = 1; k <= K; k++) {\n            int M = K / k + 1;\n            int[][] dp = new int[N][M];\n            for (int i = 0; i < N; i++) {\n                int l = (int)Math.ceil(left[i] / (double)k), r = right[i] / k;\n                if (l > r) {\n                    continue;\n                }\n                int current = 0;\n                for (int j = 1; j < M; j++) {\n                    if (j - l >= 0) {\n                        current += i == 0 ? (j - l == 0 ? 1 : 0) : dp[i - 1][j - l];\n                        current %= mod;\n                    }\n                    if (j - r - 1 >= 0) {\n                        current += mod - (i == 0 ? (j - r - 1 == 0 ? 1 : 0) : dp[i - 1][j - r - 1]);\n                        current %= mod;\n                    }\n                    dp[i][j] = current;\n                }\n            }\n            int sum = 0;\n            for (int i : dp[N - 1]) {\n                sum += i;\n                sum %= mod;\n            }\n            dp2[k] = sum;\n        }\n        \n        for (int i = K; i > 0; i--) {\n            for (int j = i * 2; j <= K; j += i) {\n                dp2[i] += mod - dp2[j];\n                dp2[i] %= mod;\n            }\n        }\n        out.println(dp2[1]);\n        \n        out.close();\n    }\n    public static int group(int[] group, int i) {\n        if (group[i] == i) {\n            return i;\n        }\n        group[i] = group(group, group[i]);\n        return group[i];\n    }\n    static class Reader {\n        BufferedReader in;\n        StringTokenizer st;\n        public Reader() {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        public String nextLine() throws IOException {\n            st = new StringTokenizer(\"\");\n            return in.readLine();\n        }\n        public String next() throws IOException {\n            while (!st.hasMoreTokens()) {\n                st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n    public static void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) {\n            list.add(i);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = list.get(i);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n/*\n50 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n1 100000\n */\npublic class E {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n//\t\tint T=fs.nextInt();\n\t\tint T=1;\n\t\tbuildMobius();\n\t\tlong time=System.currentTimeMillis();\n\t\tfor (int tt=0; tt<T; tt++) {\n\t\t\t//dp[sumLeft][\n\t\t\t//suppose I know the number of ways for the GCD to be a multiple of x\n\t\t\t//+1 -2, -3, -5 +6 => that one math thing with the u symbol\n\t\t\t\n\t\t\tint nStars=fs.nextInt();\n\t\t\tint maxSum=fs.nextInt();\n\t\t\tint[] ls=new int[nStars], rs=new int[nStars];\n\t\t\tfor (int i=0; i<nStars; i++) {\n\t\t\t\tls[i]=fs.nextInt();\n\t\t\t\trs[i]=fs.nextInt();\n\t\t\t}\n//\t\t\tSystem.out.println(\"Read input\");\n\t\t\t\n\t\t\tlong finalAns=0;\n\t\t\tfor (int gcd=1; gcd<=maxSum; gcd++) {\n//\t\t\t\tif (gcd%10==0) {\n//\t\t\t\t\tSystem.out.println(\"Gcd: \"+gcd);\n//\t\t\t\t}\n\t\t\t\tint[] newLs=new int[nStars], newRs=new int[nStars];\n\t\t\t\tfor (int i=0; i<nStars; i++) {\n\t\t\t\t\tnewLs[i]=(ls[i]+gcd-1)/gcd;\n\t\t\t\t\tnewRs[i]=rs[i]/gcd;\n\t\t\t\t}\n\t\t\t\tint newMaxSum=maxSum/gcd;\n\t\t\t\tint ans=solve(newMaxSum, newLs, newRs, nStars);\n\t\t\t\tfinalAns+=ans*mobius[gcd];\n\t\t\t}\n\t\t\tfinalAns=(finalAns%mod+mod)%mod;\n\t\t\tSystem.out.println(finalAns);\n\t\t}\n\t\tSystem.err.println(System.currentTimeMillis()-time);\n\t}\n\t\n\tstatic int mod=998244353;\n\t\n\tstatic int solve(int maxSum, int[] ls, int[] rs, int nStars) {\n\t\tdp=new int[nStars+1][maxSum+1];\n//\t\tfor (int i=0; i<dp.length; i++)\n//\t\t\tArrays.fill(dp[i], -1);\n\t\tlong[] cs;\n\t\tfor (int sum=0; sum<=maxSum; sum++) dp[nStars][sum]=1;\n\t\tcs=new long[maxSum+2];\n\t\tfor (int i=1; i<cs.length; i++) cs[i]=cs[i-1]+dp[nStars][i-1];\n\t\tfor (int i=nStars-1; i>=0; i--) {\n\t\t\tfor (int sumLeft=ls[i]; sumLeft<=maxSum; sumLeft++) {\n\t\t\t\tlong ways=0;\n//\t\t\t\tfor (int toPlace=ls[i]; toPlace<=Math.min(sumLeft, rs[i]); toPlace++) {\n//\t\t\t\t\tways+=dp[i+1][sumLeft-toPlace];\n//\t\t\t\t}\n\t\t\t\tways=cs[sumLeft-ls[i]+1]-cs[Math.max(0, sumLeft-rs[i])];\n\t\t\t\tways%=mod;\n\t\t\t\tdp[i][sumLeft]=(int)ways;\n\t\t\t}\n\t\t\tArrays.fill(cs, 0);\n\t\t\tfor (int j=1; j<cs.length; j++) cs[j]=cs[j-1]+dp[i][j-1];\n\t\t}\n\t\t\n\t\treturn dp[0][maxSum];\n\t}\n\t\n\tstatic int[][] dp;\n\t\n//\tstatic int go(int i, int sumLeft, int[] ls, int[] rs, int nStars) {\n//\t\tif (sumLeft<0) return 0;\n//\t\tif (i==nStars) return 1;\n//\t\tif (dp[i][sumLeft]!=-1) return dp[i][sumLeft];\n//\t\tlong ways=0;\n//\t\tfor (int toPlace=ls[i]; toPlace<=rs[i] && sumLeft>=toPlace; toPlace++) {\n//\t\t\tways+=go(i+1, sumLeft-toPlace, ls, rs, nStars);\n//\t\t}\n//\t\tways%=mod;\n//\t\treturn dp[i][sumLeft]=(int)ways;\n//\t}\n\n\tstatic final Random random=new Random();\n\tstatic int MAX=1_000_000;\n\tstatic int[] mobius = new int[1_000_000];\n\t\n\tstatic void buildMobius() {\n\t\tint ptr = 0;\n\t\tint[] primes = new int[MAX];\n\t\tboolean[] comp = new boolean[MAX];\n\t\tmobius[1] = 1;\n\t\t\n\t\tfor(int i = 2; i < MAX; i++) {\n\t\t\tif(!comp[i]) {\n\t\t\t\tprimes[ptr++] = i;\n\t\t\t\tmobius[i] = -1;\n\t\t\t}\n\t\t\tfor(int j = 0; j < ptr && i * primes[j] < MAX; j++) {\n\t\t\t\tint val = primes[j] * i;\n\t\t\t\tcomp[val] = true;\n\t\t\t\tif(i % primes[j] == 0) {\n\t\t\t\t\tmobius[val] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmobius[val] = mobius[i] * mobius[primes[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long int abss(long long int a) {\n  if (a < 0) return -a;\n  return a;\n}\nlong long int ones(long long int a) {\n  long long int cnt = 0;\n  while (a > 0) {\n    if (a & 1) cnt++;\n    a >>= 1;\n  }\n  return cnt;\n}\nlong long int fast_pow(long long int b, long long int e,\n                       long long int width = 998244353) {\n  if (e == 0) {\n    return 1;\n  } else if (e == 1) {\n    return b % width;\n  }\n  b = b % width;\n  long long int ans = 1;\n  while (e > 0) {\n    if ((e & 1) == 1) {\n      ans = (ans * b) % width;\n    }\n    e >>= 1;\n    b = (b * b) % width;\n  }\n  return ans;\n}\nlong long int mod_inv(long long int a, long long int width = 998244353) {\n  return fast_pow(a, width - 2, width);\n}\ntemplate <typename Number, Number width>\nclass ModularArithmetic {\n private:\n  Number n;\n\n public:\n  friend ostream &operator<<(ostream &os, ModularArithmetic const &num) {\n    return os << num.n;\n  }\n  friend istream &operator>>(istream &is, ModularArithmetic &num) {\n    is >> num.n;\n    return is;\n  }\n  ModularArithmetic() : n(0) {}\n  ModularArithmetic(Number n) : n(n % width) {\n    if (this->n < 0) this->n += width;\n  }\n  Number get() const { return n; }\n  ModularArithmetic operator+(const ModularArithmetic &b) {\n    Number t = (n + b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator-(const ModularArithmetic &b) {\n    Number t = (n - b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator*(const ModularArithmetic &b) {\n    Number t = (n * b.get()) % width;\n    if (t < 0) return ModularArithmetic(width + t);\n    return ModularArithmetic(t);\n  }\n  ModularArithmetic operator/(const ModularArithmetic &b) {\n    assert(b.get() != 0);\n    Number ans = n * mod_inv(b.get(), width);\n    if ((ans) < 0) return ModularArithmetic(width + (ans) % width);\n    return ModularArithmetic(ans % width);\n  }\n  ModularArithmetic &operator+=(const ModularArithmetic &b) {\n    n = (n + b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator-=(const ModularArithmetic &b) {\n    n = (n - b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator*=(const ModularArithmetic &b) {\n    n = (n * b.get()) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n  ModularArithmetic &operator/=(const ModularArithmetic &b) {\n    assert(b.get() != 0);\n    n = (n * mod_inv(b.get(), width)) % width;\n    if (n < 0) n = n + width;\n    return *this;\n  }\n};\ntemplate <class T, size_t N>\nostream &operator<<(ostream &os, const array<T, N> &p) {\n  os << \"<\";\n  for (auto &it : p) os << it << \" \";\n  return os << \">\";\n}\ntemplate <class S, class T>\nostream &operator<<(ostream &os, const pair<S, T> &p) {\n  return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class S, class T>\nistream &operator>>(istream &is, pair<S, T> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class T, typename Cmp>\nostream &operator<<(ostream &os, const set<T, Cmp> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const multiset<T> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class S, class T, typename Cmp>\nostream &operator<<(ostream &os, const map<S, T, Cmp> &p) {\n  os << \"[\";\n  for (auto &it : p) os << it << \" \";\n  return os << \"]\";\n}\ntemplate <class S, class T>\nistream &operator>>(istream &is, const pair<S, T> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &p) {\n  for (auto &itr : p) is >> itr;\n  return is;\n}\ntemplate <class T>\nvoid dbs(string str, T t) {\n  cerr << str << \":\" << t << \"\\n\";\n}\ntemplate <class T, class... S>\nvoid dbs(string str, T t, S... second) {\n  long long int idx = str.find(',');\n  cerr << str.substr(0, idx) << \":\" << t << \",\";\n  dbs(str.substr(idx + 1), second...);\n}\nbool isComposite(long long int a, long long int d, long long int n) {\n  long long int res = fast_pow(a, d, n);\n  if (res == 1 || res == n - 1) return false;\n  while (d != (n - 1)) {\n    res = (res * res) % n;\n    if (res == n - 1) {\n      return false;\n    }\n  }\n  return true;\n}\nbool MillerRabinDet(long long int n) {\n  if (n < 4) return n == 2 || n == 3;\n  long long int d = n - 1;\n  while (d & 1 == 0) {\n    d >>= 1;\n  }\n  for (long long int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n    if (a == n) return true;\n    if (isComposite(a, d, n)) {\n      return false;\n    }\n  }\n  return true;\n}\nbool MillerRabinNonDet(long long int n, long long int k = 1000) {\n  if (n < 4) return n == 2 || n == 3;\n  long long int d = n - 1;\n  long long int second = 0;\n  while (d & 1 == 0) {\n    d >>= 1;\n    second++;\n  }\n  long long int a;\n  for (long long int i = 0; i < k; i++) {\n    a = 2 + rand() % (n - 3);\n    if (isComposite(a, d, n)) {\n      return false;\n    }\n  }\n  return true;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (a % b == 0) return b;\n  return gcd(b, a % b);\n}\nlong long int n, m;\nvector<pair<long long int, long long int>> arr;\nvector<long long int> sieve;\nvector<long long int> prime;\nvector<long long int> mu;\nconst long long int sz = 100005;\nModularArithmetic<long long int, 998244353> compute(long long int d) {\n  long long int dm = m / d;\n  vector<ModularArithmetic<long long int, 998244353>> dp1(dm + 1, 0),\n      dp2(dm + 1, 0);\n  dp1[0] = 1;\n  for (long long int i = 0; i < n; i++) {\n    long long int lf = (arr[i].first + d - 1) / d;\n    long long int rt = (arr[i].second) / d;\n    if (lf > rt) return 0;\n    dp2[0] = dp1[0];\n    for (long long int j = 1; j <= dm; j++) dp2[j] = dp1[j] + dp2[j - 1];\n    {};\n    for (long long int j = 0; j <= dm; j++) {\n      dp1[j] =\n          ((j - lf >= 0) ? dp2[j - lf]\n                         : ModularArithmetic<long long int, 998244353>(0)) -\n          (((j - (rt + 1)) >= 0)\n               ? dp2[j - (rt + 1)]\n               : ModularArithmetic<long long int, 998244353>(0));\n    }\n  }\n  ModularArithmetic<long long int, 998244353> ans = 0;\n  for (auto itr : dp1) ans += itr;\n  ans -= dp1[0];\n  return ans;\n}\nModularArithmetic<long long int, 998244353> cal(int d) {\n  int dm = m / d;\n  vector<ModularArithmetic<long long int, 998244353>> dp1(dm + 1, 0);\n  dp1[0] = 1;\n  vector<ModularArithmetic<long long int, 998244353>> dp2(dm + 1, 0);\n  for (int i = 1; i <= dm; i++) dp1[i] = 0;\n  for (int i = 0; i < n; i++) {\n    int L = (arr[i].first + d - 1) / d, R = arr[i].second / d;\n    if (L > R) return ModularArithmetic<long long int, 998244353>(0);\n    for (int j = 0; j <= dm; j++)\n      dp2[j] = (dp1[j] + (j ? dp2[j - 1]\n                            : ModularArithmetic<long long int, 998244353>(0)));\n    for (int j = 0; j <= dm; j++) {\n      dp1[j] = ((j - L >= 0 ? dp2[j - L]\n                            : ModularArithmetic<long long int, 998244353>(0)) -\n                (j - R - 1 >= 0 ? dp2[j - R - 1] : 0));\n    }\n  }\n  ModularArithmetic<long long int, 998244353> ans = 0;\n  for (int i = 1; i <= dm; i++) ans = (ans + dp1[i]);\n  return ans;\n}\nvoid solve() {\n  sieve.assign(sz + 1, 1);\n  mu.assign(sz + 1, 0);\n  mu[1] = 1;\n  prime.clear();\n  sieve[0] = sieve[1] = 0;\n  for (long long int i = 2; i <= sz; i++) {\n    if (sieve[i]) {\n      prime.push_back(i);\n      mu[i] = -1;\n    }\n    for (long long int j = 0; j < prime.size() && i * prime[j] <= sz; j++) {\n      sieve[i * prime[j]] = 0;\n      if (i % prime[j] == 0) {\n        mu[i * prime[j]] = 0;\n        break;\n      } else {\n        mu[i * prime[j]] = mu[i] * mu[prime[j]];\n      }\n    }\n  }\n  cin >> n >> m;\n  vector<pair<long long int, long long int>>(n).swap(arr);\n  for (long long int i = 0; i < n; ++i) cin >> arr[i].first >> arr[i].second;\n  ModularArithmetic<long long int, 998244353> ans = 0;\n  for (long long int i = 1; i <= m; i++) {\n    ans += (ModularArithmetic<long long int, 998244353>(mu[i]) * compute(i));\n    {};\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  freopen(\"err.txt\", \"w\", stderr);\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n# sys.setrecursionlimit(200005)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline().rstrip()\ninf = 10**16\n# md = 10**9+7\nmd = 998244353\n\nn, M = LI()\nlr = LLI(n)\n\ndef doDP(g):\n    m = M//g\n    dp = [0]*(m+3)\n    dp[0] = 1\n    for i, (l, r) in enumerate(lr):\n        l, r = (l+g-1)//g, r//g\n        ndp = [0]*(m+3)\n        for j in range(m):\n            pre = dp[j]\n            if pre == 0: continue\n            nl = j+l\n            if nl > m: break\n            nr = min(j+r+1, m+1)\n            ndp[nl] = (ndp[nl]+pre)%md\n            ndp[nr] = (ndp[nr]-pre)%md\n        for j in range(m):\n            ndp[j+1] = (ndp[j+1]+ndp[j])%md\n        dp = ndp\n    res = 0\n    for v in dp[1:m+1]: res = (res+v)%md\n    return res\n\nans = [0]\nfor g in range(1, M+1):\n    ans.append(doDP(g))\n\nfor i in range(M-1, 0, -1):\n    for j in range(i+i, M+1, i):\n        ans[i] -= ans[j]\n    ans[i] %= md\n\nprint(ans[1])\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nconst int mod = 998244353;\nint f[60][100010], g[100010], sum[60][100010];\nint x[60], y[60], l[60], r[60], n, m;\nint sol(int gcd) {\n  for (int i = 1; i <= n; i++) r[i] = y[i] / gcd, l[i] = (x[i] - 1) / gcd + 1;\n  for (int i = 1; i <= n; i++)\n    if (l[i] > r[i]) return 0;\n  for (int i = 0; i <= m / gcd; i++) sum[0][i] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m / gcd; j++) sum[i][j] = 0;\n    for (int j = l[i]; j <= m / gcd; j++) {\n      int x = j - r[i] - 1 < 0 ? 0 : sum[i - 1][j - r[i] - 1];\n      f[i][j] = (sum[i - 1][j - l[i]] - x + mod) % mod;\n      sum[i][j] = sum[i][j - 1] + f[i][j];\n      sum[i][j] %= mod;\n    }\n  }\n  return sum[n][m / gcd];\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) x[i] = read(), y[i] = read();\n  for (int i = 1; i <= m; i++) {\n    g[i] = sol(i);\n  }\n  for (int i = m; i; i--) {\n    for (int j = 2; j * i <= m; j++) g[i] = (g[i] - g[i * j] + mod) % mod;\n  }\n  printf(\"%d\", g[1]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nint mul(long long x, int y) { return x * y % MOD; }\nvoid selfmul(int &x, int y) { x = mul(x, y); }\nint add(int x, int y) {\n  if ((x += y) >= MOD) x -= MOD;\n  return x;\n}\nvoid selfadd(int &x, int y) { x = add(x, y); }\nint sub(int x, int y) {\n  if ((x -= y) < 0) x += MOD;\n  return x;\n}\nint mod(int x) {\n  x %= MOD;\n  if (x < 0) x += MOD;\n  return x;\n}\nconst int N = 55;\nconst int MAX = 1e5 + 1;\nvector<int> prime;\nbool isPrime[MAX];\nint mobius[MAX];\nint n, m, lef[N], rig[N];\nint f[N][MAX], res;\nvoid sieve() {\n  memset(isPrime, true, sizeof isPrime);\n  isPrime[0] = isPrime[1] = false;\n  mobius[1] = 1;\n  for (int i = 2; i < MAX; ++i) {\n    if (isPrime[i]) {\n      prime.push_back(i);\n      mobius[i] = -1;\n    }\n    for (int j = 0; i * prime[j] < MAX; ++j) {\n      isPrime[i * prime[j]] = false;\n      if (i % prime[j]) {\n        mobius[i * prime[j]] = mobius[i] * mobius[prime[j]];\n      } else\n        break;\n    }\n  }\n}\nint func(const vector<int> &lef, const vector<int> &rig, int lim) {\n  int n = lef.size();\n  for (int i = 0; i < n; ++i) {\n    if (lef[i] > rig[i]) return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    memset(f[i], 0, (lim + 1) * sizeof(int));\n  }\n  for (int i = lef[0]; i <= lim; ++i) {\n    f[0][i] = min(i, rig[0]) - lef[0] + 1;\n    selfadd(f[0][i], f[0][i - 1]);\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = lef[i] + 1; j <= lim; ++j) {\n      f[i][j] = sub(f[i - 1][j - lef[i]], f[i - 1][j - min(j - 1, rig[i]) - 1]);\n      selfadd(f[i][j], f[i][j - 1]);\n    }\n  }\n  return f[n - 1][lim] - f[n - 1][lim - 1];\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  sieve();\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> lef[i] >> rig[i];\n  }\n  for (int d = 1; d <= m; ++d) {\n    auto ceildiv = [&](int a, int b) { return a / b + bool(a % b); };\n    vector<int> l, r;\n    for (int i = 1; i <= n; ++i) {\n      l.push_back(ceildiv(lef[i], d));\n      r.push_back(rig[i] / d);\n    }\n    selfadd(res, mod(mobius[d] * func(l, r, m / d)));\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nconst long double pi = 3.141592653589793238;\nconst long long MOD = 998244353;\nconst long long N = 2e5 + 10;\nlong long n, m;\npair<long long, long long> a[51];\nlong long dp[51][N];\nlong long ans[N] = {0};\nlong long pre[N];\nlong long sum(long long l, long long r) {\n  if (r < 0) return 0;\n  if (l > r) return 0;\n  return pre[r] - (l - 1 >= 0 ? pre[l - 1] : 0);\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) cin >> a[i].first >> a[i].second;\n  for (long long g = m; g >= 1; g--) {\n    long long mx = m / g;\n    for (long long i = 0; i <= n; i++) {\n      for (long long j = 0; j <= mx; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = 1;\n    for (long long i = 1; i <= n; i++) {\n      long long l = (a[i - 1].first + g - 1) / g, r = a[i - 1].second / g;\n      pre[0] = dp[i - 1][0];\n      for (long long j = 1; j <= mx; j++)\n        pre[j] = dp[i - 1][j] + pre[j - 1], pre[j] %= MOD;\n      for (long long j = 0; j <= mx; j++) {\n        long long nl = j - r;\n        long long nr = j - l;\n        dp[i][j] = sum(nl, nr);\n        dp[i][j] %= MOD;\n        dp[i][j] += MOD;\n        dp[i][j] %= MOD;\n      }\n    }\n    for (long long j = 1; j <= mx; j++) ans[g] += dp[n][j], ans[g] %= MOD;\n    for (long long k = 2; k * g <= m; k++) {\n      ans[g] -= ans[k * g];\n      ans[g] %= MOD;\n      ans[g] += MOD;\n      ans[g] %= MOD;\n    }\n  }\n  cout << ans[1];\n}\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import deque,Counter\nfrom sys import stdin\n\n#sys.setrecursionlimit(10**7)\nint1=lambda x: int(x)-1\n\ninp=lambda :int(input())\nmi=lambda :map(int,input().split())\nli=lambda :list(mi())\nmi1=lambda :map(int1,input().split())\nli1=lambda :list(mi1())\nmis=lambda :map(str,input().split())\nlis=lambda :list(mis())\n\nstinput=lambda :stdin.readline()[:-1]\nstinp=lambda :int(stinput())\nstmi=lambda :map(int, stdin.readline().split())\nstli=lambda :list(stmi())\nstmi1=lambda :map(int1, stdin.readline().split())\nstli1=lambda :list(stmi1())\nstmis=lambda :stdin.readline()[:-1]\n\npr=print\n\nfrom collections import defaultdict\n\"\"\"\n#\u521d\u671f\u5024 0\nd=defaultdict(int)\n\n#\u521d\u671f\u5024 1\nd=defaultdict(lambda:1)\n\"\"\"\n\nmod=10**9+7\nMod=998244353\nINF=10**18\nans=0\n\nn,m=mi()\nx=[]\nfor i in range(n):\n  a,b=mi()\n  x.append((a,b))\n\ndef f(k):\n  dp=[0]*(m//k+1)\n  t=m//k+1\n  if t<n:\n    return 0\n  dp[0]=1\n  for a,b in x:\n    dp2=[0]*t\n    c=(a+k-1)//k\n    d=b//k\n    cnt=0\n    if c>d:\n      return 0\n    for i in range(c,t):\n      cnt+=dp[i-c]\n      if i>d:\n        cnt-=dp[i-d-1]\n      cnt%=Mod\n      dp2[i]=cnt\n    dp=dp2.copy()\n  #print(m,dp)\n  return sum(dp)%Mod\n#\u8907\u6570\u56de\u7d20\u56e0\u6570\u5206\u89e3\u3084\u7d04\u6570\u5217\u6319\u3092\u3059\u308b\u5834\u5408(n<=10^6)\n\n#\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\nd=[-1]*(m+1)\nfor i in range(2,m+1):\n  if d[i]==-1:\n    d[i]=i\n    j=2\n    while i*j<=m:\n      d[i*j]=i\n      j+=1\n#n \u306e\u7d20\u56e0\u6570\u5206\u89e3\nimport collections\ndef fact(n):\n  c=[]\n  while n!=1:\n    k=d[n]\n    c.append(k)\n    n//=k\n  #return c\n  return collections.Counter(c)\n#n \u306e\u7d04\u6570\u5217\u6319\ndef div(n):\n  s=set([1])\n  while n!=1:\n    x=d[n]\n    t=s.copy()\n    for i in s:\n      t.add(i*x)\n    n//=x\n    s=t.copy()\n  return s\n\ntmp=[0]*(m+1)\nfor i in range(m,0,-1):\n  t=f(i)\n  s=tmp[i]+t\n  tmp[i]=s\n  for j in div(i):\n    if j!=i:\n      tmp[j]-=s\nprint(tmp[1]%Mod)"
        }
    ]
}