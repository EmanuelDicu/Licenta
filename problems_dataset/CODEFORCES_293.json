{
    "name": "293_D. Ksusha and Square",
    "source": "CODEFORCES",
    "description": "Ksusha is a vigorous mathematician. She is keen on absolutely incredible mathematical riddles. \n\nToday Ksusha came across a convex polygon of non-zero area. She is now wondering: if she chooses a pair of distinct points uniformly among all integer points (points with integer coordinates) inside or on the border of the polygon and then draws a square with two opposite vertices lying in the chosen points, what will the expectation of this square's area be?\n\nA pair of distinct points is chosen uniformly among all pairs of distinct points, located inside or on the border of the polygon. Pairs of points p, q (p \u2260 q) and q, p are considered the same.\n\nHelp Ksusha! Count the required expectation.\n\nInput\n\nThe first line contains integer n (3 \u2264 n \u2264 105) \u2014 the number of vertices of Ksusha's convex polygon. Next n lines contain the coordinates of the polygon vertices in clockwise or counterclockwise order. The i-th line contains integers xi, yi (|xi|, |yi| \u2264 106) \u2014 the coordinates of the vertex that goes i-th in that order.\n\nOutput\n\nPrint a single real number \u2014 the required expected area. \n\nThe answer will be considered correct if its absolute and relative error doesn't exceed 10 - 6.\n\nExamples\n\nInput\n\n3\n0 0\n5 5\n5 0\n\n\nOutput\n\n4.6666666667\n\n\nInput\n\n4\n-1 3\n4 5\n6 2\n3 -5\n\n\nOutput\n\n8.1583333333\n\n\nInput\n\n3\n17 136\n859 937\n16 641\n\n\nOutput\n\n66811.3704155169",
    "difficulty": "D",
    "tags": [
        "geometry",
        "math",
        "probabilities",
        "two pointers"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "3\n17 136\n859 937\n16 641\n",
            "output": "66811.370415516887746\n"
        },
        {
            "input": "4\n-1 3\n4 5\n6 2\n3 -5\n",
            "output": "8.1583333333333333329\n"
        },
        {
            "input": "3\n0 0\n5 5\n5 0\n",
            "output": "4.666666666666666667\n"
        }
    ],
    "generated_test": [
        {
            "input": "3\n217949 72327\n20730 141135\n667478 663894\n",
            "output": "35756046110.2309945226"
        },
        {
            "input": "5\n-30 3\n-27 27\n25 19\n22 11\n-9 -28\n",
            "output": "308.2801311282"
        },
        {
            "input": "26\n-999979 -518088\n-999921 118990\n-999886 336599\n-999749 894870\n-999613 971778\n-997505 993563\n-988075 999871\n-724057 999931\n338004 999963\n939763 999692\n979017 999536\n997778 999063\n999010 994592\n999549 991252\n999866 130647\n999941 -152592\n999901 -975591\n998258 -992117\n992764 -999373\n845158 -999949\n592531 -999958\n-810995 -999934\n-988512 -999694\n-995382 -992825\n-997701 -979912\n-999550 -923898\n",
            "output": "666358831414.6079000831"
        },
        {
            "input": "5\n-4 -21\n25 12\n2 28\n-25 24\n-26 -16\n",
            "output": "289.0516046264"
        },
        {
            "input": "4\n1000 1000\n-1000 1100\n-1000 -1000\n1000 -1000\n",
            "output": "684405.4678022212"
        },
        {
            "input": "4\n-4 -20\n10 6\n-10 23\n-27 -17\n",
            "output": "162.6840779955"
        },
        {
            "input": "4\n-13 -21\n22 -6\n19 -2\n-20 27\n",
            "output": "191.1056861190"
        },
        {
            "input": "28\n-999950 -887483\n-999941 -898020\n-999541 -954162\n-998380 -979624\n-996809 -989471\n-974206 -998846\n-814103 -999939\n-562253 -999986\n39584 -999954\n949101 -999859\n967558 -998977\n974753 -998193\n980440 -995185\n995399 -975723\n999674 -949939\n999839 -915815\n999975 -114127\n999981 971763\n999561 997999\n989473 999261\n917401 999944\n-468594 999853\n-693444 999675\n-914976 999234\n-997478 996529\n-999955 951845\n-999982 144675\n-999992 -224003\n",
            "output": "666225628494.0333230495"
        },
        {
            "input": "4\n0000 1000\n-1000 1000\n-1000 -1000\n1000 -1000\n",
            "output": "549932.3816872411"
        },
        {
            "input": "7\n-29 5\n-20 13\n-4 22\n8 20\n21 9\n16 -29\n-20 -30\n",
            "output": "331.0099259507"
        },
        {
            "input": "4\n-1000000 -1000000\n-1000000 1000010\n1000000 1000000\n1000000 -1000000\n",
            "output": "666668833340.3902065754"
        },
        {
            "input": "3\n217949 72327\n20730 141135\n667478 31198\n",
            "output": "18826858661.6411153264"
        },
        {
            "input": "9\n-30 -17\n-30 -12\n-28 24\n-21 29\n8 29\n36 14\n26 -11\n9 -29\n-25 -30\n",
            "output": "511.7550960338"
        },
        {
            "input": "8\n-18 -20\n16 -28\n29 -22\n29 25\n15 27\n-19 30\n-28 18\n-30 -16\n",
            "output": "485.4708957418"
        },
        {
            "input": "7\n-16 -30\n18 -12\n23 -1\n-3 5\n-20 7\n-22 1\n-23 -27\n",
            "output": "207.9144001321"
        },
        {
            "input": "21\n-999896 -977584\n-981090 -998920\n-955737 -999433\n-836670 -999598\n-131267 -999903\n203740 -999850\n988083 -997441\n997685 -976930\n998079 -967700\n999138 -906399\n999967 -779494\n999875 608972\n998802 997105\n997089 999540\n891311 999873\n46007 999962\n-991551 999757\n-999301 968587\n-999579 875737\n-999730 549856\n-999960 51168\n",
            "output": "665955557792.9263055325"
        },
        {
            "input": "3\n17 69\n859 937\n16 641\n",
            "output": "71931.7258136343"
        },
        {
            "input": "4\n-1 3\n4 5\n6 2\n0 -5\n",
            "output": "8.7833333333"
        },
        {
            "input": "3\n1 0\n5 5\n5 0\n",
            "output": "4.0625000000"
        },
        {
            "input": "3\n280683 72327\n20730 141135\n667478 663894\n",
            "output": "35095331479.8769511469"
        },
        {
            "input": "5\n-30 3\n-27 27\n25 19\n20 11\n-9 -28\n",
            "output": "301.1828482196"
        },
        {
            "input": "5\n0 -21\n25 12\n2 28\n-25 24\n-26 -16\n",
            "output": "293.8347891422"
        },
        {
            "input": "4\n1000 1000\n-1000 1100\n-1000 -1000\n1000 -1786\n",
            "output": "854913.4674257650"
        },
        {
            "input": "4\n-4 -39\n10 6\n-10 23\n-27 -17\n",
            "output": "243.1268260748"
        },
        {
            "input": "4\n-13 -21\n22 -6\n19 -2\n-24 27\n",
            "output": "203.4203887524"
        },
        {
            "input": "4\n0000 1000\n-1000 1000\n-1000 -379\n1000 -1000\n",
            "output": "472397.3291107740"
        },
        {
            "input": "3\n217949 72327\n6264 141135\n667478 31198\n",
            "output": "19516752617.6137520019"
        },
        {
            "input": "9\n-30 -17\n-30 -12\n-28 24\n-27 29\n8 29\n36 14\n26 -11\n9 -29\n-25 -30\n",
            "output": "516.2709172523"
        },
        {
            "input": "8\n-18 -20\n10 -28\n29 -22\n29 25\n15 27\n-19 30\n-28 18\n-30 -16\n",
            "output": "484.3927618292"
        },
        {
            "input": "3\n17 12\n859 937\n16 641\n",
            "output": "76677.1311187669"
        },
        {
            "input": "4\n-1 3\n4 5\n6 1\n0 -5\n",
            "output": "9.0868686869"
        },
        {
            "input": "3\n1 0\n5 5\n5 1\n",
            "output": "3.8712121212"
        },
        {
            "input": "3\n280683 29080\n20730 141135\n667478 663894\n",
            "output": "36785861667.2475881986"
        },
        {
            "input": "5\n-30 3\n-27 27\n25 30\n20 11\n-9 -28\n",
            "output": "348.2144744701"
        },
        {
            "input": "5\n0 -21\n25 12\n2 28\n-25 24\n-26 -1\n",
            "output": "261.8747461929"
        },
        {
            "input": "4\n1000 1000\n-1000 1100\n-1728 -1000\n1000 -1786\n",
            "output": "1004446.2298619596"
        },
        {
            "input": "4\n-4 -39\n10 6\n-10 20\n-27 -17\n",
            "output": "228.4563133619"
        },
        {
            "input": "4\n-13 -21\n22 -6\n19 -2\n-24 52\n",
            "output": "345.6132469222"
        },
        {
            "input": "4\n0000 1000\n-1000 1000\n-1000 -379\n1001 -1000\n",
            "output": "472479.1130488308"
        },
        {
            "input": "3\n217949 72327\n6264 78064\n667478 31198\n",
            "output": "19111437385.6797773242"
        },
        {
            "input": "9\n-30 -17\n-30 -12\n-28 24\n-27 29\n8 29\n36 14\n36 -11\n9 -29\n-25 -30\n",
            "output": "554.8901201943"
        },
        {
            "input": "8\n-18 -20\n10 -28\n29 -33\n29 25\n15 27\n-19 30\n-28 18\n-30 -16\n",
            "output": "514.7589784068"
        },
        {
            "input": "3\n17 12\n859 937\n16 1057\n",
            "output": "93991.3658479677"
        },
        {
            "input": "4\n-1 5\n4 5\n6 1\n0 -5\n",
            "output": "10.3560784314"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n  int x, y;\n  Point() {}\n  Point(int x, int y) {\n    this->x = x;\n    this->y = y;\n  }\n  Point operator+(Point rhs) { return Point(x + rhs.x, y + rhs.y); }\n  Point operator-(Point rhs) { return Point(x - rhs.x, y - rhs.y); }\n  long long Dot(Point rhs) { return 1LL * x * rhs.x + 1LL * y * rhs.y; }\n  long long Crs(Point rhs) { return 1LL * x * rhs.y - 1LL * y * rhs.x; }\n};\nbool operator<(Point lhs, Point rhs) {\n  return (lhs.x == rhs.x) ? (lhs.y < rhs.y) : (lhs.x < rhs.x);\n}\nconst int MAXN = 100010;\nint N;\nPoint p[MAXN];\nvector<Point> H[2];\nint pcx[2333333], pcy[2333333];\nint *cx = pcx + 1233333, *cy = pcy + 1233333;\nlong long cip;\ndouble Stat(int* e, int Min, int Max) {\n  double ret = 0;\n  double Count = 0, sumPlain = 0, sumSquare = 0;\n  int i;\n  for (i = Min; i <= Max; i++) {\n    ret += e[i] * (Count * i * i + sumSquare - 2.0 * i * sumPlain);\n    Count += e[i];\n    sumPlain += e[i] * 1.0 * i;\n    sumSquare += e[i] * 1.0 * i * i;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &N);\n  int i;\n  for (i = 1; i <= N; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    p[i] = Point(x, y);\n  }\n  sort(p + 1, p + N + 1);\n  int ml = 1;\n  while ((ml < N) && (p[ml + 1].x == p[1].x)) ml++;\n  H[0].clear();\n  H[1].clear();\n  H[0].push_back(p[1]);\n  H[1].push_back(p[ml]);\n  for (i = ml + 1; i <= N; i++) {\n    while ((H[0].size() > 1) &&\n           ((H[0].back() - H[0][H[0].size() - 2]).Crs(p[i] - H[0].back()) <= 0))\n      H[0].pop_back();\n    while ((H[1].size() > 1) &&\n           ((H[1].back() - H[1][H[1].size() - 2]).Crs(p[i] - H[1].back()) >= 0))\n      H[1].pop_back();\n    H[0].push_back(p[i]);\n    H[1].push_back(p[i]);\n  }\n  while ((H[0].size() > 1) && (H[0].back().x == H[0][H[0].size() - 2].x))\n    H[0].pop_back();\n  vector<Point>::iterator lit = H[0].begin(), rit = H[1].begin();\n  int minX = p[1].x, maxX = p[N].x, minY = p[1].y, maxY = p[1].y;\n  for (i = 2; i <= N; i++) {\n    minY = min(minY, p[i].y);\n    maxY = max(maxY, p[i].y);\n  }\n  for (i = minY; i <= maxY; i++) cy[i] = 0;\n  cx[maxX] = H[1].back().y - H[0].back().y + 1;\n  cy[H[1].back().y + 1]--;\n  cy[H[0].back().y]++;\n  for (i = minX; i <= maxX - 1; i++) {\n    if ((lit + 1)->x <= i) lit++;\n    if ((rit + 1)->x <= i) rit++;\n    int ly = ceil(double((lit + 1)->y - lit->y) / ((lit + 1)->x - lit->x) *\n                      (i - lit->x) +\n                  lit->y - 1e-9);\n    int ry = floor(double((rit + 1)->y - rit->y) / ((rit + 1)->x - rit->x) *\n                       (i - rit->x) +\n                   rit->y + 1e-9);\n    cx[i] = ry - ly + 1;\n    cy[ry + 1]--;\n    cy[ly]++;\n  }\n  for (i = minY + 1; i <= maxY; i++) cy[i] += cy[i - 1];\n  cip = 0;\n  for (i = minX; i <= maxX; i++) cip += cx[i];\n  double ans = Stat(cx, minX, maxX) + Stat(cy, minY, maxY);\n  ans /= cip;\n  ans /= cip - 1;\n  printf(\"%.10f\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return floor(Y1 + (1e-8));\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return ceil(Y1 - (1e-8));\n}\nlong double F[10000005];\nlong double Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    for (; A[k + 1].first < i;) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long double Cnt = 0;\n  long double SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    for (; A[k + 1].first > i;) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  for (int i = Q; i >= P; i--)\n    Ans += F[i] * (i - 1000005) * (i - 1000005) / (Cnt - 1);\n  Ans -= SumX * SumX / ((Cnt - 1) * Cnt);\n}\nvoid Work() {\n  double S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += (double)A[k].first * (double)A[k + 1].second -\n         (double)A[k].second * (double)A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) std::swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline T1 max(T1 a, T2 b) {\n  return a < b ? b : a;\n}\ntemplate <typename T1, typename T2>\ninline T1 min(T1 a, T2 b) {\n  return a < b ? a : b;\n}\ntemplate <typename T1, typename T2>\ninline T1 gmax(T1 &a, T2 b) {\n  return a = a < b ? b : a;\n}\ntemplate <typename T1, typename T2>\ninline T1 gmin(T1 &a, T2 b) {\n  return a = a < b ? a : b;\n}\nconst char lf = '\\n';\nnamespace ae86 {\nconst int bufl = 1 << 15;\nchar buf[bufl], *s = buf, *t = buf;\ninline int fetch() {\n  if (s == t) {\n    t = (s = buf) + fread(buf, 1, bufl, stdin);\n    if (s == t) return EOF;\n  }\n  return *s++;\n}\ninline int ty() {\n  int a = 0;\n  int b = 1, c = fetch();\n  while (!isdigit(c)) b ^= c == '-', c = fetch();\n  while (isdigit(c)) a = a * 10 + c - 48, c = fetch();\n  return b ? a : -a;\n}\n}  // namespace ae86\nusing ae86::ty;\nconst int _ = 100007, X = 1000000, inf = 0x3f3f3f3f;\nstruct points {\n  long long x, y;\n  points(long long x_ = 0, long long y_ = 0) { x = x_, y = y_; }\n  void takein() { x = ty(), y = ty(); }\n  void rever() { swap(x, y); }\n  friend points operator+(points a, points b) {\n    return points(a.x + b.x, a.y + b.y);\n  }\n  friend points operator-(points a, points b) {\n    return points(a.x - b.x, a.y - b.y);\n  }\n};\ninline long long dox(points a, points b) { return a.x * b.x + a.y * b.y; }\ninline long long cox(points a, points b) { return a.x * b.y - a.y * b.x; }\ninline long long length2(points a) { return dox(a, a); }\ninline long long distan2(points a, points b) { return length2(b - a); }\nint n;\npoints p[_];\nint xlBuf[X + X + 7], xrBuf[X + X + 7], *xl = xlBuf + X + 3,\n                                        *xr = xrBuf + X + 3;\ndouble make() {\n  for (int i = -X; i <= X; i++) xl[i] = inf, xr[i] = -inf;\n  for (int i = 1; i <= n; i++) {\n    if (p[i].x == p[i + 1].x)\n      gmin(xl[p[i].x], p[i].y), gmax(xr[p[i].x], p[i].y);\n    else {\n      points a = p[i], b = p[i + 1];\n      if (a.x > b.x) swap(a, b);\n      double k = 1.00 / (b.x - a.x);\n      for (int j = a.x; j <= b.x; j++) {\n        double loc = ((j - a.x) * b.y + (b.x - j) * a.y) * k;\n        gmin(xl[j], ceil(loc)), gmax(xr[j], floor(loc));\n      }\n    }\n  }\n  double s = 0, si = 0, si2 = 0;\n  for (int i = -X; i <= X; i++) {\n    if (xr[i] < xl[i]) continue;\n    long long dlt = xr[i] - xl[i] + 1;\n    s += dlt, si += dlt * i, si2 += dlt * i * i;\n  }\n  return (s * si2 - si * si) / s / (s - 1);\n}\nint main() {\n  ios::sync_with_stdio(0), cout.tie(nullptr);\n  n = ty();\n  for (int i = 1; i <= n; i++) p[i].takein();\n  p[0] = p[n], p[n + 1] = p[1];\n  double ans = make();\n  for (int i = 0; i <= n + 1; i++) p[i].rever();\n  ans += make();\n  cout << setprecision(11) << fixed << ans << lf;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n;\nstruct data {\n  int x, y;\n} d[maxn];\ndouble U[2000005], D[2000005], ans;\nvoid Max(double &x, double y) {\n  if (x < y) x = y;\n}\nvoid Min(double &x, double y) {\n  if (x > y) x = y;\n}\nvoid work() {\n  int i, j, mx = 0;\n  d[n] = d[0];\n  for (i = 0; i < n; i++)\n    if (mx < d[i].x) mx = d[i].x;\n  for (i = 0; i <= mx; i++) D[i] = 2000005., U[i] = -1.;\n  for (i = 0; i < n; i++) {\n    if (d[i].x == d[i + 1].x) {\n      Max(U[d[i].x], d[i].y);\n      Max(U[d[i].x], d[i + 1].y);\n      Min(D[d[i].x], d[i].y);\n      Min(D[d[i].x], d[i + 1].y);\n    } else {\n      int l, r;\n      double k = 1. * (d[i + 1].y - d[i].y) / (d[i + 1].x - d[i].x), b;\n      if (d[i].x < d[i + 1].x)\n        l = d[i].x, r = d[i + 1].x, b = d[i].y;\n      else\n        l = d[i + 1].x, r = d[i].x, b = d[i + 1].y;\n      for (j = l; j <= r; j++) {\n        Max(U[j], b + (j - l) * k);\n        Min(D[j], b + (j - l) * k);\n      }\n    }\n  }\n  double sum, sum2, cnt, res;\n  sum = sum2 = cnt = res = 0.;\n  for (i = 0; i <= mx; i++) {\n    double c = floor(U[i]) - ceil(D[i]) + 1.;\n    res += (cnt * i * i - 2. * sum * i + sum2) * c;\n    sum += c * i;\n    sum2 += c * i * i;\n    cnt += c;\n  }\n  ans += res / (cnt * (cnt - 1));\n}\nint main() {\n  scanf(\"%d\", &n);\n  int i, mx, my;\n  mx = my = 0x7fffffff;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d%d\", &d[i].x, &d[i].y);\n    if (d[i].x < mx) mx = d[i].x;\n    if (d[i].y < my) my = d[i].y;\n  }\n  for (i = 0; i < n; i++) {\n    d[i].x -= mx;\n    d[i].y -= my;\n  }\n  work();\n  for (i = 0; i < n; i++) swap(d[i].x, d[i].y);\n  work();\n  printf(\"%f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  static int r, sign;\n  static char c;\n  r = 0, c = getchar(), sign = 1;\n  while ((c < '0' || c > '9') && c != '-') c = getchar();\n  if (c == '-') sign = -1, c = getchar();\n  while (c >= '0' && c <= '9') r = r * 10 + (c - '0'), c = getchar();\n  return r * sign;\n}\ntemplate <typename T>\ninline void print(T *a, int n) {\n  for (int i = 1; i < n; ++i) cout << a[i] << \" \";\n  cout << a[n] << endl;\n}\nstruct point {\n  int x, y;\n  inline void read() { scanf(\"%d%d\", &x, &y); }\n} p, q, t;\nint n, u[2000010 + 1], d[2000010 + 1], l[2000010 + 1], r[2000010 + 1], U, R, L,\n    D;\ninline void process(const point &p, const point &q) {\n  if (p.x == q.x) {\n    u[p.x + 1000000] = max(u[p.x + 1000000], max(p.y, q.y));\n    d[p.x + 1000000] = min(d[p.x + 1000000], min(p.y, q.y));\n  } else {\n    double ma = max(p.x, q.x), mi = min(p.x, q.x), s = p.x < q.x ? p.y : q.y;\n    for (int i = mi; i <= ma; ++i) {\n      double y = s + (double)(i - mi) * (q.y - p.y) / (q.x - p.x);\n      u[i + 1000000] = max(u[i + 1000000], (int)floor(y));\n      d[i + 1000000] = min(d[i + 1000000], (int)ceil(y));\n    }\n  }\n  if (p.y == q.y) {\n    r[p.y + 1000000] = max(r[p.y + 1000000], max(p.x, q.x));\n    l[p.y + 1000000] = min(l[p.y + 1000000], min(p.x, q.x));\n  } else {\n    double ma = max(p.y, q.y), mi = min(p.y, q.y), s = p.y < q.y ? p.x : q.x;\n    for (int i = mi; i <= ma; ++i) {\n      double x = s + (double)(i - mi) * (q.x - p.x) / (q.y - p.y);\n      r[i + 1000000] = max(r[i + 1000000], (int)floor(x));\n      l[i + 1000000] = min(l[i + 1000000], (int)ceil(x));\n    }\n  }\n}\ninline void process(const point &p) {\n  U = max(U, p.y), D = min(D, p.y);\n  R = max(R, p.x), L = min(L, p.x);\n}\ndouble s[4][2000010 + 1];\ndouble solve(int n) {\n  for (int i = 0; i < 4; ++i) s[i][n + 1] = 0;\n  for (int i = n; i > 0; --i) s[1][i] = s[1][i + 1] + s[0][i];\n  if (s[1][1] <= 1) return 0.0;\n  for (int i = n; i > 0; --i) s[2][i] = s[2][i + 1] + 2 * s[1][i] - s[0][i];\n  double tot = s[1][1] * (s[1][1] - 1);\n  for (int i = n; i > 0; --i) s[2][i] /= tot;\n  for (int i = n; i > 0; --i) s[3][i] = s[3][i + 1] + s[2][i];\n  double ret = 0.0;\n  for (int i = n - 1; i > 0; --i) ret += s[0][i] * s[3][i + 1];\n  return ret;\n}\nint main(int argc, char *argv[]) {\n  for (int i = 0; i <= 2000010; ++i)\n    u[i] = r[i] = INT_MIN, d[i] = l[i] = INT_MAX;\n  U = R = INT_MIN, D = L = INT_MAX;\n  scanf(\"%d\", &n);\n  p.read(), t = p, process(t);\n  for (int i = 2; i <= n; ++i) {\n    q.read(), process(q);\n    process(p, q);\n    p = q;\n  }\n  process(q, t);\n  double ans = 0.0;\n  int cnt = 0;\n  for (int i = L; i <= R; ++i)\n    s[0][++cnt] = (double)(u[i + 1000000] - d[i + 1000000] + 1);\n  ans += solve(cnt);\n  cnt = 0;\n  for (int i = D; i <= U; ++i)\n    s[0][++cnt] = (double)(r[i + 1000000] - l[i + 1000000] + 1);\n  ans += solve(cnt);\n  printf(\"%.10lf\\n\", ans);\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x[100007], y[100007];\ndouble p[2000007], sum[2000007], a[2000007], b[2000007], ans = 0;\nvoid solve() {\n  int up = 0, dw = 2e6 + 1, id = 0;\n  int l = 0, r = 0;\n  for (int i = 0; i < n; i++) {\n    up = max(up, x[i]);\n    if (dw > x[i]) {\n      dw = x[i];\n      id = i;\n    }\n  }\n  l = r = id;\n  memset(p, 0, sizeof(p));\n  memset(sum, 0, sizeof(sum));\n  memset(a, 0, sizeof(a));\n  memset(b, 0, sizeof(b));\n  double total = 0, ret = 0;\n  for (int i = dw; i <= up; i++) {\n    while (x[(l - 1 + n) % n] < i) l = (l - 1 + n) % n;\n    while (x[(r + 1) % n] < i) r = (r + 1) % n;\n    int lef = 0, rig = 2e6;\n    vector<double> pt;\n    if (x[(l - 1 + n) % n] == x[l]) {\n      pt.push_back(y[l]), pt.push_back(y[(l - 1 + n) % n]);\n    } else {\n      int pv = (l - 1 + n) % n;\n      pt.push_back(1.0 * (y[pv] - y[l]) / (x[pv] - x[l]) * (i - x[l]) +\n                   1.0 * y[l]);\n    }\n    if (x[r] == x[(r + 1) % n]) {\n      pt.push_back(y[r]), pt.push_back(y[(r + 1) % n]);\n    } else {\n      int pv = (r + 1) % n;\n      pt.push_back(1.0 * (y[pv] - y[r]) / (x[pv] - x[r]) * (i - x[r]) +\n                   1.0 * y[r]);\n    }\n    sort(pt.begin(), pt.end());\n    lef = (int)ceil(pt[0]);\n    rig = (int)pt[(int)pt.size() - 1];\n    p[i] = max(0, rig - lef + 1);\n    total += p[i];\n  }\n  total = total * (total - 1) / 2LL;\n  for (int i = dw; i <= up; i++) {\n    p[i] /= total;\n    sum[i] = sum[i - 1] + 2.0 * p[i];\n  }\n  for (int i = dw + 1; i <= up; i++) {\n    a[i] = a[i - 1] + p[i - 1] + b[i - 1] + sum[i - 2];\n    b[i] = b[i - 1] + p[i - 1] + sum[i - 2];\n    ret = ret + p[i] * total * a[i];\n  }\n  ans += ret;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += 1e6 + 1;\n    y[i] += 1e6 + 1;\n  }\n  solve();\n  for (int i = 0; i < n; i++) swap(x[i], y[i]);\n  solve();\n  cout << (fixed) << setprecision(15) << ans / 2.0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5, M = 2e6;\nstruct CPOINT {\n  int x, y;\n  int& operator[](int id) { return id == 1 ? x : y; }\n  bool operator<(const CPOINT& Cb) const& {\n    if (x == Cb.x) return y < Cb.y;\n    return x < Cb.x;\n  }\n} pnt[N + 3];\ndouble Tex(CPOINT Ca, CPOINT Cb) {\n  return Ca.x == Cb.x ? (Ca.y > Cb.y ? -1e9 : 1e9)\n                      : double(Ca.y - Cb.y) / (Ca.x - Cb.x);\n}\nstruct SSTACK {\n  int stk[N + 3], top;\n  void Push(int Vv) { stk[++top] = Vv; }\n  int Size() { return top; }\n  void Pop() { stk[top--] = 0; }\n  int Fir() { return stk[top]; }\n  int Sec() { return stk[top - 1]; }\n  int& operator[](int id) { return stk[id]; }\n};\nSSTACK Sup, Slow;\nint n;\nint Cn[M + 3];\nlong long Rcnt;\nint GetLowY(CPOINT Ca, CPOINT Cb, int x) {\n  if (x == Ca.x) {\n    if (Cb.x == Ca.x) return max(Cb.y, Ca.y);\n    return Ca.y;\n  }\n  int Rl = -1, Rr = 2e6 + 1;\n  while (Rl + 1 < Rr) {\n    int Rm = (Rl + Rr) >> 1;\n    if (1ll * (Rm - Ca.y) * (Cb.x - Ca.x) <= 1ll * (Cb.y - Ca.y) * (x - Ca.x))\n      Rl = Rm;\n    else\n      Rr = Rm;\n  }\n  return Rl;\n}\nint GetHigY(CPOINT Ca, CPOINT Cb, int x) {\n  if (x == Ca.x) {\n    if (Cb.x == Ca.x) return min(Cb.y, Ca.y);\n    return Ca.y;\n  }\n  int Rl = -1, Rr = 2e6 + 1;\n  while (Rl + 1 < Rr) {\n    int Rm = (Rl + Rr) >> 1;\n    if (1ll * (Rm - Ca.y) * (Cb.x - Ca.x) >= 1ll * (Cb.y - Ca.y) * (x - Ca.x))\n      Rr = Rm;\n    else\n      Rl = Rm;\n  }\n  return Rr;\n}\nlong double Solve() {\n  sort(pnt + 1, pnt + 1 + n);\n  while (Sup.Size()) Sup.Pop();\n  while (Slow.Size()) Slow.Pop();\n  Sup.Push(1);\n  Sup.Push(2);\n  Slow.Push(1);\n  Slow.Push(2);\n  for (int i = 3; i <= n; i++) {\n    while (Sup.Size() >= 2 &&\n           Tex(pnt[Sup.Sec()], pnt[Sup.Fir()]) <= Tex(pnt[Sup.Fir()], pnt[i]))\n      Sup.Pop();\n    Sup.Push(i);\n    while (Slow.Size() >= 2 && Tex(pnt[Slow.Sec()], pnt[Slow.Fir()]) >=\n                                   Tex(pnt[Slow.Fir()], pnt[i]))\n      Slow.Pop();\n    Slow.Push(i);\n  }\n  int Lef = pnt[Sup[1]][1], Rig = pnt[Sup.Fir()][1];\n  memset(Cn, 0, sizeof Cn);\n  long double totCn = 0, Rs = 0, totCni = 0, totCni2 = 0;\n  int Vup = 2, Vlow = 2;\n  Rcnt = 0;\n  for (int i = Lef; i <= Rig; i++) {\n    while (i > pnt[Sup[Vup]][1]) Vup++;\n    while (i > pnt[Slow[Vlow]][1]) Vlow++;\n    Cn[i] = GetLowY(pnt[Sup[Vup - 1]], pnt[Sup[Vup]], i) -\n            GetHigY(pnt[Slow[Vlow - 1]], pnt[Slow[Vlow]], i) + 1;\n    Rcnt += Cn[i];\n    totCn += (long double)Cn[i];\n    totCni += (long double)i * Cn[i];\n    totCni2 += (long double)i * i * Cn[i];\n  }\n  Rs = (totCn * totCni2 - totCni * totCni);\n  return Rs;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &pnt[i][1], &pnt[i][2]);\n    pnt[i][1] += (int)1e6;\n    pnt[i][2] += (int)1e6;\n  }\n  long double Vans = Solve();\n  for (int i = 1; i <= n; i++) swap(pnt[i][1], pnt[i][2]);\n  Vans += Solve();\n  printf(\"%.10f\\n\", double(Vans / Rcnt / (Rcnt - 1)));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct point {\n  int x, y;\n  point(int x0, int y0) {\n    x = x0;\n    y = y0;\n  }\n} PT;\nclass Line {\n public:\n  double A, B, C;\n  Line(double x1, double y1, double x2, double y2) {\n    A = y2 - y1;\n    B = x1 - x2;\n    C = A * x1 + B * y1;\n  }\n  double getY(double x) { return (C - A * x) / B; }\n  double getX(double y) { return (C - B * y) / C; }\n};\ndouble horizontal[2000005][2], result;\nint integralHorizontalPoints[2000005];\nvector<PT> polygon;\ndouble totalArea, totalIntegreal;\nvoid preprocess(int n) {\n  int i, j, l, r, k, x, y, minX = 2000005, maxX = -2000005;\n  double difference = 0.0, doubleDiff = 0.0, oldArea = 0.0;\n  for (i = 0; i < 2000005; i++) {\n    horizontal[i][0] = 1.0 * 2000005;\n    horizontal[i][1] = -1.0 * 2000005;\n  }\n  for (i = 0; i < n; i++) {\n    minX = min(minX, polygon[i].x);\n    maxX = max(maxX, polygon[i].x);\n    j = i + 1;\n    if (j == n) j = 0;\n    Line L(1.0 * polygon[i].x, 1.0 * polygon[i].y, 1.0 * polygon[j].x,\n           1.0 * polygon[j].y);\n    l = min(polygon[i].x, polygon[j].x);\n    r = max(polygon[i].x, polygon[j].x);\n    if (l == r) {\n      if (polygon[i].y < polygon[j].y) {\n        x = polygon[i].y;\n        y = polygon[j].y;\n      } else {\n        x = polygon[j].y;\n        y = polygon[i].y;\n      }\n      horizontal[l][0] = min(horizontal[l][0], 1.0 * x);\n      horizontal[l][1] = max(horizontal[l][1], 1.0 * y);\n    } else {\n      for (k = l; k <= r; k++) {\n        horizontal[k][0] = min(horizontal[k][0], L.getY(k));\n        horizontal[k][1] = max(horizontal[k][1], L.getY(k));\n      }\n    }\n  }\n  for (i = minX; i <= maxX; i++) {\n    integralHorizontalPoints[i] =\n        floor(horizontal[i][1]) - ceil(horizontal[i][0]) + 1;\n    totalIntegreal += 1.0 * integralHorizontalPoints[i];\n  }\n  oldArea = 1.0 * integralHorizontalPoints[minX];\n  totalArea += 1.0 * oldArea * integralHorizontalPoints[minX + 1];\n  difference = integralHorizontalPoints[minX];\n  for (i = minX + 2; i <= maxX; i++) {\n    doubleDiff += 2.0 * integralHorizontalPoints[i - 2];\n    difference += doubleDiff + 1.0 * integralHorizontalPoints[i - 1];\n    oldArea += difference;\n    totalArea += 1.0 * oldArea * integralHorizontalPoints[i];\n  }\n  return;\n}\ndouble nc2(double n) { return n * (n - 1.0); }\nint main() {\n  int i, j, t, n, m, k, l, r, temp, mini, maxi, flag, cnt, x, y;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d%d\", &l, &r);\n    l += 1000000;\n    r += 1000000;\n    PT foo(l, r);\n    polygon.push_back(foo);\n  }\n  preprocess(n);\n  for (i = 0; i < n; i++) swap(polygon[i].x, polygon[i].y);\n  preprocess(n);\n  totalIntegreal /= 2.0;\n  result = totalArea / nc2(totalIntegreal);\n  printf(\"%.8lf\\n\", result);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace my_useful_tools {\nconst int INF = 0x3f3f3f3f;\ninline void pc(char c) { putchar(c); }\ntemplate <class T>\ninline T gcd(T a, T b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\ntemplate <class T>\ninline void W(T p) {\n  if (p < 0) pc('-'), p = -p;\n  if (p / 10 != 0) W(p / 10);\n  pc('0' + p % 10);\n}\ntemplate <class T>\ninline void Wn(T p) {\n  W(p), puts(\"\");\n}\ntemplate <class T>\ninline void W(T a, T b) {\n  W(a), pc(' '), W(b);\n}\ntemplate <class T>\ninline void Wn(T a, T b) {\n  W(a), pc(' '), Wn(b);\n}\ntemplate <class T>\ninline void W(T a, T b, T c) {\n  W(a), pc(' '), W(b), pc(' '), W(c);\n}\ninline char gchar() {\n  char ret = getchar();\n  for (; ret == '\\n' || ret == '\\r' || ret == ' '; ret = getchar())\n    ;\n  return ret;\n}\ntemplate <class T>\ninline void fr(T& ret) {\n  char c = ' ';\n  int flag = 1;\n  for (c = getchar(); c != '-' && !('0' <= c && c <= '9'); c = getchar())\n    ;\n  if (c == '-')\n    flag = -1, ret = 0;\n  else\n    ret = c - '0';\n  for (c = getchar(); '0' <= c && c <= '9'; c = getchar())\n    ret = ret * 10 + c - '0';\n  ret = ret * flag;\n}\ninline int fr() {\n  int x;\n  fr(x);\n  return x;\n}\ntemplate <class T>\ninline void fr(T& a, T& b) {\n  fr(a), fr(b);\n}\ntemplate <class T>\ninline void fr(T& a, T& b, T& c) {\n  fr(a), fr(b), fr(c);\n}\ntemplate <class T>\ninline T fast_pow(T base, T index, T mod = 2147483647, T ret = 1) {\n  for (; index; index >>= 1, base = base * base % mod)\n    if (index & 1) ret = ret * base % mod;\n  return ret;\n}\nconst int maxv = 100, maxe = 100;\nstruct Edge {\n  int edge, head[maxv], to[maxe], next[maxe];\n  Edge() {\n    edge = 0;\n    memset(head, -1, sizeof head);\n  }\n  void addedge(int u, int v) {\n    to[edge] = v, next[edge] = head[u];\n    head[u] = edge++;\n  }\n};\n};  // namespace my_useful_tools\nusing namespace my_useful_tools;\nconst int maxn = 1e5 + 100;\nconst int maxc = 1e6 + 10;\nconst int maxr = 2e6 + 100;\nint x[maxn], y[maxn];\ndouble x1[maxr], x2[maxr];\nint n, cnt[maxr];\ndouble ans;\nvoid calc() {\n  int mi = INF, mx = -INF;\n  for (int i = 0; i < maxr; ++i) {\n    x1[i] = mx, x2[i] = mi;\n  }\n  for (int i = 1; i <= n; ++i) {\n    int ux = x[i], uy = y[i], vx = x[i + 1 > n ? 1 : i + 1],\n        vy = y[i + 1 > n ? 1 : i + 1];\n    mi = min(mi, ux), mx = max(mx, ux);\n    if (ux == vx) {\n      x1[ux] = max(1. * max(uy, vy), x1[ux]);\n      x2[ux] = min(1. * min(uy, vy), x2[ux]);\n    } else {\n      if (vx < ux) {\n        swap(ux, vx), swap(uy, vy);\n      }\n      for (int r = ux; r <= vx; ++r) {\n        double t = 1. * (uy - vy) / (ux - vx) * (r - ux) + uy;\n        x1[r] = max(x1[r], t);\n        x2[r] = min(x2[r], t);\n      }\n    }\n  }\n  long long tot = 0;\n  for (int i = mi; i <= mx; ++i) {\n    int dn = (int)(x2[i] - 1e-5) + 1, up = (int)(x1[i]);\n    tot += (cnt[i - mi] = up - dn + 1);\n  }\n  double sum = 0, s1 = 0, s2 = 0, s3 = 0;\n  for (int i = 0; i <= mx - mi; ++i) {\n    sum += 1. * cnt[i] * (1. * i * i * s1 - 2. * i * s2 + s3);\n    s1 += cnt[i];\n    s2 += 1. * i * cnt[i];\n    s3 += 1. * i * i * cnt[i];\n  }\n  sum /= (1. * tot * (tot - 1) / 2);\n  ans += sum;\n}\nint main() {\n  fr(n);\n  for (int i = 1; i <= n; ++i) {\n    fr(x[i], y[i]);\n    x[i] += 1000000, y[i] += 1000000;\n  }\n  calc();\n  for (int i = 1; i <= n; ++i) {\n    swap(x[i], y[i]);\n  }\n  calc();\n  printf(\"%.10lf\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, V = 1000000, MV = 1001000, Inf = 1 << 30;\nconst double eps(1e-8);\nint n, x[N] = {}, y[N] = {};\ndouble ul[MV + MV] = {}, ur[MV + MV] = {}, *l = ul + MV, *r = ur + MV;\ndouble ans = 0;\nvoid init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n  x[n + 1] = x[1], y[n + 1] = y[1];\n}\nlong long sqrsum(long long l, long long r) {\n  if (l == 1)\n    return r * (r + 1) * (r + r + 1) / 6;\n  else if (l > 1)\n    return sqrsum(1, r) - sqrsum(1, l - 1);\n  else\n    return sqrsum(1, -l) + sqrsum(1, r);\n}\nvoid work() {\n  double s0 = 0, s1 = 0, s2 = 0;\n  for (int i = -V; i <= V; ++i) l[i] = Inf, r[i] = -Inf;\n  int lx = V, rx = -V;\n  for (int i = 1; i <= n; ++i) {\n    lx = min(lx, x[i]), rx = max(rx, x[i]);\n    if (x[i] == x[i + 1])\n      l[x[i]] = min(y[i], y[i + 1]), r[x[i]] = max(y[i], y[i + 1]);\n    else {\n      bool flag = false;\n      if (x[i] > x[i + 1]) flag = true;\n      if (flag) swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n      double t = 1.0 / (x[i + 1] - x[i]);\n      for (int j = x[i]; j <= x[i + 1]; ++j) {\n        double c = ((long long)(j - x[i]) * y[i + 1] +\n                    (long long)(x[i + 1] - j) * y[i]) *\n                   t;\n        l[j] = min(l[j], c);\n        r[j] = max(r[j], c);\n      }\n      if (flag) swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n    }\n  }\n  for (int i = lx; i <= rx; ++i) {\n    long long tl = (int)ceil(l[i]), tr = (int)floor(r[i]);\n    s0 += tr - tl + 1;\n    s1 += (tr + tl) * (tr - tl + 1) / 2;\n    s2 += sqrsum(tl, tr);\n  }\n  ans += (s0 * s2 - s1 * s1) / s0 / (s0 - 1);\n}\nvoid swapxy() {\n  for (int i = 1; i <= n + 1; ++i) swap(x[i], y[i]);\n}\nint main() {\n  init();\n  work();\n  swapxy();\n  work();\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-9;\nconst int N = 110000, M = 2100000, Zero = 1000000;\nstruct Point {\n  int x, y;\n} P[N];\nint i, j, k, l, m, n, o, p, X[M], Y[M], Lx, Rx, Ly, Ry;\ninline int sn(double x) { return x < -eps ? -1 : x > eps ? 1 : 0; }\ninline void Init() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) scanf(\"%d%d\", &P[i].x, &P[i].y);\n}\ninline double gety(double x, int A, int B) {\n  return P[A].y + (x - P[A].x) / (P[B].x - P[A].x) * (P[B].y - P[A].y);\n}\ninline void SolveX() {\n  int x, s, t, U, D, lU, lD;\n  s = t = 1;\n  double x1, x2, w;\n  for (i = 1; i <= n; i++) {\n    if (P[i].x < P[s].x) s = i;\n    if (P[i].x > P[t].x) t = i;\n  }\n  U = s + 1;\n  if (U > n) U = 1;\n  D = s - 1;\n  if (!D) D = n;\n  lU = lD = s;\n  if (P[lU].x == P[U].x) {\n    lU = U;\n    U++;\n    if (U > n) U = 1;\n  }\n  if (P[lD].x == P[D].x) {\n    lD = D;\n    D--;\n    if (D < 1) D = n;\n  }\n  for (x = P[s].x; x <= P[t].x; x++) {\n    while (P[U].x < x) {\n      lU = U;\n      U++;\n      if (U > n) U = 1;\n    }\n    while (P[D].x < x) {\n      lD = D;\n      D--;\n      if (D < 1) D = n;\n    }\n    x1 = gety((double)x, lU, U);\n    x2 = gety((double)x, lD, D);\n    if (sn(x1 - x2) > 0) {\n      w = x1;\n      x1 = x2;\n      x2 = w;\n    }\n    x1 = ceil(x1);\n    x2 = floor(x2);\n    X[x + Zero] = (int)(x2) - (int)(x1) + 1;\n  }\n  Lx = P[s].x;\n  Rx = P[t].x;\n}\ninline double getx(double y, int A, int B) {\n  return P[A].x + (y - P[A].y) / (P[B].y - P[A].y) * (P[B].x - P[A].x);\n}\ninline void SolveY() {\n  int y, s, t, L, R, lL, lR;\n  s = t = 1;\n  double y1, y2, w;\n  for (i = 1; i <= n; i++) {\n    if (P[i].y < P[s].y) s = i;\n    if (P[i].y > P[t].y) t = i;\n  }\n  L = s + 1;\n  if (L > n) L = 1;\n  R = s - 1;\n  if (!R) R = n;\n  lL = lR = s;\n  if (P[lL].y == P[L].y) {\n    lL = L;\n    L++;\n    if (L > n) L = 1;\n  }\n  if (P[lR].y == P[R].y) {\n    lR = R;\n    R--;\n    if (R < 1) R = n;\n  }\n  for (y = P[s].y; y <= P[t].y; y++) {\n    while (P[L].y < y) {\n      lL = L;\n      L++;\n      if (L > n) L = 1;\n    }\n    while (P[R].y < y) {\n      lR = R;\n      R--;\n      if (R < 1) R = n;\n    }\n    y1 = getx((double)y, lL, L);\n    y2 = getx((double)y, lR, R);\n    if (sn(y1 - y2) > 0) {\n      w = y1;\n      y1 = y2;\n      y2 = w;\n    }\n    y1 = ceil(y1);\n    y2 = floor(y2);\n    Y[y + Zero] = (int)(y2) - (int)(y1) + 1;\n  }\n  Ly = P[s].y;\n  Ry = P[t].y;\n}\ninline double Solve() {\n  double ans = 0.0, s0, s1, s2, p, g, x, cul, y;\n  s0 = 0.0;\n  s1 = 0.0;\n  s2 = 0.0;\n  for (i = Lx; i <= Rx; i++) {\n    g = (double)X[i + Zero];\n    x = (double)i;\n    cul = x * x * s0 + s2 - 2.0 * x * s1;\n    ans += cul * g;\n    s0 += g;\n    s2 += g * x * x;\n    s1 += g * x;\n  }\n  s0 = 0.0;\n  s1 = 0.0;\n  s2 = 0.0;\n  for (i = Ly; i <= Ry; i++) {\n    g = (double)Y[i + Zero];\n    y = (double)i;\n    cul = y * y * s0 + s2 - 2.0 * y * s1;\n    ans += cul * g;\n    s0 += g;\n    s2 += g * y * y;\n    s1 += g * y;\n  }\n  p = s0 * (s0 - 1.0);\n  return ans / p;\n}\nint main() {\n  Init();\n  SolveX();\n  SolveY();\n  printf(\"%.8lf\\n\", Solve());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author ogiekako\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyScanner in = new MyScanner(inputStream);\n\t\tMyPrintWriter out = new MyPrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    int T = (int) (1e6 + 10);\n\n    public void solve(int testNumber, MyScanner in, MyPrintWriter out) {\n        int n = in.nextInt();\n        P[] ps = new P[n];\n        P[] rev = new P[n];\n        for (int i = 0; i < n; i++) {\n            ps[i] = P.of(in.nextInt() + T, in.nextInt() + T);\n            rev[i] = P.of(ps[i].y, ps[i].x);\n        }\n        double a = solve(ps);\n        double b = solve(rev);\n        out.println((a + b) / 2);\n    }\n\n    int n;\n\n    private double solve(P[] ps) {\n        n = ps.length;\n        for (int i = 0; i < n; i++) {\n            long det = ps[next(i)].sub(ps[i]).det(ps[next(next(i))].sub(ps[i]));\n            if (det < 0){\n                ArrayUtils.reverse(ps);\n                break;\n            }\n        }\n        int lower = 0;\n        for (int i = 0; i < n; i++) if (ps[i].compareTo(ps[lower]) < 0) lower = i;\n        long[] count = new long[T * 2];\n        int upper = lower;\n        if (ps[prev(lower)].x == ps[lower].x) {\n            upper = prev(lower);\n        }\n        while (ps[upper].x < ps[prev(upper)].x) {\n            long x1 = ps[upper].x;\n            long y1 = ps[upper].y;\n            long x2 = ps[prev(upper)].x;\n            long y2 = ps[prev(upper)].y;\n            for (long x = x1; x < x2; x++) {\n                count[((int) x)] += ((x2 - x) * y1 + (x - x1) * y2) / (x2 - x1);\n            }\n            upper = prev(upper);\n        }\n        while (ps[lower].x < ps[next(lower)].x) {\n            long x1 = ps[lower].x;\n            long y1 = ps[lower].y;\n            long x2 = ps[next(lower)].x;\n            long y2 = ps[next(lower)].y;\n            for (long x = x1; x < x2; x++) {\n                count[((int) x)] -= ((x2 - x) * y1 + (x - x1) * y2 - 1) / (x2 - x1);\n            }\n            lower = next(lower);\n        }\n\n        count[((int) ps[upper].x)] += ps[upper].y;\n        count[((int) ps[lower].x)] -= ps[lower].y - 1;\n\n        for (int x = 0; x < count.length; x++)\n            if (count[x] > 0) {\n                debug(\"A\", x, count[x]);\n            }\n\n        double S = 0;\n        double S2 = 0;\n        double N = 0;\n        for (int x = 0; x < count.length; x++) {\n            N += count[x];\n            S += x * count[x];\n            S2 += (double) x * x * count[x];\n        }\n        debug(S);\n        debug(S2);\n        double sum = 2 * N * S2 - 2 * S * S;\n        debug(\"sum\", sum);\n        return sum / ((double) N * (N - 1));\n    }\n\n    static void debug(Object... os) {\n//        System.err.println(Arrays.deepToString(os));\n    }\n\n    private int prev(int p) {\n        p--;\n        if (p < 0) p += n;\n        return p;\n    }\n\n    private int next(int p) {\n        p++;\n        if (p >= n) p -= n;\n        return p;\n    }\n}\n\nclass P implements Comparable<P> {\n    final long x, y;\n\n    public P(long x, long y) {\n        this.x = x; this.y = y;\n    }\n\n    static P of(long x, long y) {\n        return new P(x, y);\n    }\n\n    public P sub(P p) {\n        return of(x - p.x, y - p.y);\n    }\n\n    public long det(P p) {\n        return x * p.y - y * p.x;\n    }\n\n    public int compareTo(P o) {\n        return x == o.x ? compare(y, o.y) : compare(x, o.x);\n    }\n\n    private int compare(long a, long b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\nclass MyScanner {\n    private final InputStream in;\n\n    public MyScanner(InputStream in) {\n        this.in = in;\n    }\n\n    int bufLen;\n    int bufPtr;\n    byte[] buf = new byte[1024];\n\n    public int read() {\n        if (bufLen == -1)\n            throw new InputMismatchException();\n        if (bufPtr >= bufLen) {\n            bufPtr = 0;\n            try {\n                bufLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (bufLen <= 0)\n                return -1;\n        }\n        return buf[bufPtr++];\n    }\n\n    public int nextInt() {\n        int c = read();\n        if (c == -1) throw new NoSuchElementException();\n        while (c != '-' && (c < '0' || '9' < c)) {\n            c = read();\n            if (c == -1) throw new NoSuchElementException();\n        }\n        if (c == '-') return -nextInt();\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while ('0' <= c && c <= '9');\n        return res;\n    }\n\n\n    }\n\nclass MyPrintWriter {\n    PrintWriter out;\n\n    public MyPrintWriter(OutputStream outputStream) {\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public MyPrintWriter(Writer writer) {\n        out = new PrintWriter(writer);\n    }\n\n    public void println(Object... os) {\n        for (int i = 0; i < os.length - 1; i++) {\n            out.print(os[i]);\n            out.print(' ');\n        }\n        out.println(os[os.length - 1]);\n    }\n\n    public void close() {\n        out.close();\n    }\n\n    }\n\nclass ArrayUtils {\n\n\n    public static<T> void reverse(T[] is) {\n        int n = is.length;\n        for (int i = 0; i * 2 < n; i++) {\n            T tmp = is[i]; is[i] = is[n - 1 - i]; is[n - 1 - i] = tmp;\n        }\n    }\n\n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000000;\nstruct pt {\n  int x, y;\n  pt() {}\n  pt(int x, int y) : x(x), y(y) {}\n  friend bool operator<(const pt &a, const pt &b) {\n    if (a.y == b.y) return a.x < b.x;\n    return a.y < b.y;\n  }\n};\nstruct seg {\n  pt a, b;\n  long long A, B, C;\n  seg() {}\n  seg(pt a, pt b) : a(a), b(b) {\n    A = a.y - b.y;\n    B = b.x - a.x;\n    C = A * a.x + B * a.y;\n  }\n  int cut_r(int y) {\n    int x = (C - B * y) / A;\n    if (A * x + B * y < C) ++x;\n    return x;\n  }\n  int cut_l(int y) {\n    int x = (C - B * y) / A;\n    if (A * x + B * y > C) --x;\n    return x;\n  }\n};\nint n, x, y;\nvector<pt> p;\nvector<seg> L;\nvector<seg> R;\ndouble tot;\ndouble sum_range(int l, int r) {\n  if (l > r) return 0;\n  double len = r - l + 1;\n  return len * l + len * (len - 1) * 0.5;\n}\ndouble _sum_squares(int n) {\n  double ret = (double)(n + 1) * n * (n - 1) / 3;\n  ret += (double)n * (n + 1) / 2;\n  return ret;\n}\ndouble sum_squares(int l, int r) {\n  if (l > r) return 0;\n  if (l <= 0 && r >= 0) return _sum_squares(abs(l)) + _sum_squares(abs(r));\n  l = abs(l);\n  r = abs(r);\n  if (l > r) swap(l, r);\n  double ret = _sum_squares(r);\n  if (l) ret -= _sum_squares(l - 1);\n  return ret;\n}\ndouble solve() {\n  int miny = +inf;\n  int maxy = -inf;\n  long long area = 0;\n  for (int i = (0); i < (n); ++i) {\n    miny = min(miny, p[i].y);\n    maxy = max(maxy, p[i].y);\n    int j = (i + 1) % n;\n    area += (long long)p[i].x * p[j].y - (long long)p[i].y * p[j].x;\n  }\n  if (area < 0) reverse(p.begin(), p.end());\n  L.clear();\n  R.clear();\n  rotate(p.begin(), max_element(p.begin(), p.end()), p.end());\n  for (int i = ((p[0].y == p[1].y)); i < (n); ++i) {\n    if (p[i].y == miny) break;\n    L.push_back(seg(p[i], p[i + 1]));\n  }\n  R.push_back(seg(p[0], p.back()));\n  for (int i = (0); i < (n); ++i) {\n    if (p[n - i - 1].y == miny) break;\n    R.push_back(seg(p[n - i - 1], p[n - i - 2]));\n  }\n  tot = 0.0;\n  double sum = 0.0;\n  double sum_sq = 0.0;\n  int li = 0, ri = 0;\n  for (int y = maxy; y >= miny; --y) {\n    if (y < L[li].b.y) ++li;\n    if (y < R[ri].b.y) ++ri;\n    int l = L[li].cut_r(y);\n    int r = R[ri].cut_l(y);\n    tot += r - l + 1;\n    sum += sum_range(l, r);\n    sum_sq += sum_squares(l, r);\n  }\n  return 2.0 * sum_sq - 2.0 * (sum / tot) * sum;\n}\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = (0); i < (n); ++i) {\n    scanf(\"%d%d\", &x, &y);\n    p.push_back(pt(x, y));\n  }\n  double sol = 0.0;\n  sol += solve();\n  for (int i = (0); i < (n); ++i) swap(p[i].x, p[i].y);\n  sol += solve();\n  sol /= (tot - 1.0);\n  sol *= 0.5;\n  printf(\"%.8lf\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n  long long x, y;\n  Point() {}\n  Point(long long x0, long long y0) : x(x0), y(y0) {}\n  void in() { scanf(\"%I64d %I64d\", &x, &y); }\n  long long operator*(Point pt) { return x * pt.y - y * pt.x; }\n  Point operator-(Point pt) { return Point(x - pt.x, y - pt.y); }\n} p[100010];\nlong long judge1(long long y, Point a, Point b) {\n  if (a.y == b.y) return min(a.x, b.x);\n  long long left = -2000000;\n  long long right = 2000000;\n  long long ans;\n  while (right >= left) {\n    long long mid = (left + right) / 2;\n    Point o = Point(mid, y);\n    if ((b - a) * (o - a) > 0)\n      left = mid + 1;\n    else {\n      ans = mid;\n      right = mid - 1;\n    }\n  }\n  return ans;\n}\nlong long judge2(long long y, Point a, Point b) {\n  if (a.y == b.y) return max(a.x, b.x);\n  long long left = -2000000;\n  long long right = 2000000;\n  long long ans;\n  while (right >= left) {\n    long long mid = (left + right) / 2;\n    Point o = Point(mid, y);\n    if ((b - a) * (o - a) >= 0) {\n      ans = mid;\n      left = mid + 1;\n    } else\n      right = mid - 1;\n  }\n  return ans;\n}\nlong long x[2000010];\nint n;\ndouble solve() {\n  p[n] = p[0];\n  p[n + 1] = p[1];\n  bool need = false;\n  for (int i = 0; i < n; i++) {\n    if ((p[i + 1] - p[i]) * (p[i + 2] - p[i]) == 0) continue;\n    if ((p[i + 1] - p[i]) * (p[i + 2] - p[i]) < 0) {\n      need = true;\n      break;\n    }\n  }\n  if (need) reverse(p, p + n);\n  p[n] = p[0];\n  p[n + 1] = p[1];\n  long long left = (1LL) << 60;\n  long long right = -(1LL) << 60;\n  int begin = 0;\n  for (int i = 0; i < n; i++) {\n    if (p[i].y < left) {\n      left = p[i].y;\n      begin = i;\n    }\n    if (p[i].y > right) right = p[i].y;\n  }\n  int l, r, ll, rr;\n  l = r = begin;\n  for (long long t = left; t <= right; t++) {\n    while (1) {\n      ll = (l - 1 + n) % n;\n      if (p[ll].y > t || p[ll].y == right) break;\n      l = ll;\n    }\n    while (1) {\n      rr = (r + 1) % n;\n      if (p[rr].y > t || p[rr].y == right) break;\n      r = rr;\n    }\n    long long a = judge1(t, p[l], p[ll]);\n    long long b = judge2(t, p[r], p[rr]);\n    x[t - left] = b - a + 1;\n  }\n  double T = 0;\n  for (int i = left; i <= right; i++) T += x[i - left];\n  double ans = 0;\n  double a0 = 0;\n  double a1 = 0;\n  double a2 = 0;\n  for (int t = left; t < right; t++) {\n    a1 += a0 + x[t - left];\n    a2 += a1;\n    a0 += x[t - left] * 2;\n    ans += a2 * x[t - left + 1];\n  }\n  ans /= T;\n  ans /= T - 1.0;\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) p[i].in();\n  double ans = 0;\n  ans += solve();\n  for (int i = 0; i < n; i++) swap(p[i].x, p[i].y);\n  ans += solve();\n  printf(\"%.12f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  long long x, y;\n};\nint N;\npoint P[100010];\nlong long area(point &P, point &Q) { return P.x * Q.y - P.y * Q.x; }\nbool smaller(point &P, point &Q) {\n  if (P.x < Q.x) return true;\n  if (P.x == Q.x && P.y < Q.y) return true;\n  return false;\n}\nlong long low[2000010], high[2000010];\nvoid lower(point P, point Q) {\n  if (P.x == Q.x) return;\n  for (int i = P.x; i <= Q.x; i++) {\n    double y = P.y + (double)(Q.y - P.y) / (Q.x - P.x) * (i - P.x);\n    low[i] = max(low[i], (long long)(y - 1.0E-7) + 1);\n  }\n}\nvoid upper(point P, point Q) {\n  if (P.x == Q.x) return;\n  for (int i = P.x; i <= Q.x; i++) {\n    double y = P.y + (double)(Q.y - P.y) / (Q.x - P.x) * (i - P.x);\n    high[i] = min(high[i], (long long)(y + 1.0E-7));\n  }\n}\ndouble func(void) {\n  int i;\n  long long s = 0;\n  for ((i) = 0; (i) < (int)(N); (i)++) s += area(P[i], P[(i + 1) % N]);\n  if (s < 0) reverse(P, P + N);\n  int L = 0, R = 0;\n  for ((i) = 0; (i) < (int)(N); (i)++) {\n    if (smaller(P[i], P[L])) L = i;\n    if (smaller(P[R], P[i])) R = i;\n  }\n  int X1 = P[L].x;\n  int X2 = P[R].x;\n  for (i = X1; i <= X2; i++) low[i] = -(1 << 29);\n  for (i = X1; i <= X2; i++) high[i] = (1 << 29);\n  for (i = 0;; i++) {\n    int a = (L + i) % N, b = (L + i + 1) % N;\n    lower(P[a], P[b]);\n    if (b == R) break;\n  }\n  for (i = 0;; i++) {\n    int a = (R + i + 1) % N, b = (R + i) % N;\n    upper(P[a], P[b]);\n    if (a == L) break;\n  }\n  double cnt = 0.0;\n  double xsum = 0.0;\n  double x2sum = 0.0;\n  int sy = X2 - X1;\n  for (i = 0; i <= sy; i++) {\n    double tmp = high[i + X1] - low[i + X1] + 1;\n    cnt += tmp;\n    xsum += tmp * (double)i;\n    x2sum += tmp * (double)i * (double)i;\n  }\n  double ans = 2.0 * cnt * x2sum - 2.0 * xsum * xsum;\n  return ans / cnt / (cnt - 1.0);\n}\nint main(void) {\n  int i;\n  cin >> N;\n  for ((i) = 0; (i) < (int)(N); (i)++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    P[i].x = x + 1000000;\n    P[i].y = y + 1000000;\n  }\n  double ans1 = func();\n  for ((i) = 0; (i) < (int)(N); (i)++) swap(P[i].x, P[i].y);\n  double ans2 = func();\n  printf(\"%.9f\\n\", (ans1 + ans2) / 2.0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, V = 1000000, MV = 1001000, Inf = 1 << 30;\nconst double eps(1e-8);\nint n, x[N] = {}, y[N] = {}, ul[MV + MV] = {}, ur[MV + MV] = {}, *l = ul + MV,\n       *r = ur + MV;\ndouble ans = 0;\nvoid init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n  x[n + 1] = x[1], y[n + 1] = y[1];\n}\nvoid work() {\n  double s0 = 0, s1 = 0, s2 = 0;\n  for (int i = -V; i <= V; ++i) l[i] = Inf, r[i] = -Inf;\n  int lx = V, rx = -V;\n  for (int i = 1; i <= n; ++i) {\n    lx = min(lx, x[i]), rx = max(rx, x[i]);\n    if (x[i] == x[i + 1])\n      l[x[i]] = min(y[i], y[i + 1]), r[x[i]] = max(y[i], y[i + 1]);\n    else {\n      bool flag = false;\n      if (x[i] > x[i + 1]) flag = true;\n      if (flag) swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n      double t = 1.0 / (x[i + 1] - x[i]);\n      for (int j = x[i]; j <= x[i + 1]; ++j) {\n        double c = ((long long)(j - x[i]) * y[i + 1] +\n                    (long long)(x[i + 1] - j) * y[i]) *\n                   t;\n        l[j] = min(l[j], (int)ceil(c));\n        r[j] = max(r[j], (int)floor(c));\n      }\n      if (flag) swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n    }\n  }\n  for (int i = lx; i <= rx; ++i) {\n    long long d = r[i] - l[i] + 1;\n    s0 += d, s1 += d * i, s2 += d * i * i;\n  }\n  ans += (s0 * s2 - s1 * s1) / s0 / (s0 - 1);\n}\nvoid swapxy() {\n  for (int i = 1; i <= n + 1; ++i) swap(x[i], y[i]);\n}\nint main() {\n  init();\n  work();\n  swapxy();\n  work();\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing Point = complex<long long>;\nlong long det(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  return (conj(b) * c).imag();\n}\nvoid Trim(vector<Point>& p) {\n  while (p[0].real() == p[1].real()) p.erase(p.begin());\n  while (p.end()[-1].real() == p.end()[-2].real()) p.pop_back();\n}\nlong double Solve(vector<Point> p) {\n  int n = p.size();\n  double area = 0;\n  for (int i = 0, j = n - 1; i < n; j = i++) area += det(0, p[j], p[i]);\n  if (area < 0) reverse(p.begin(), p.end());\n  tuple<long long, long long, int> fst = {+2000000, -1, -1};\n  for (int i = 0; i < n; ++i)\n    fst = min(fst, make_tuple(p[i].real(), p[i].imag(), i));\n  rotate(p.begin(), p.begin() + get<2>(fst), p.end());\n  p.push_back(p[0]);\n  tuple<long long, long long, int> snd = {-2000000, -1, -1};\n  for (int i = 0; i < n; ++i)\n    snd = max(snd, make_tuple(p[i].real(), p[i].imag(), i));\n  vector<Point> lo(p.begin(), p.begin() + get<2>(snd) + 1);\n  vector<Point> hi(p.begin() + get<2>(snd), p.end());\n  reverse(hi.begin(), hi.end());\n  Trim(lo);\n  Trim(hi);\n  long long minx = get<0>(fst), maxx = get<0>(snd);\n  vector<int> cnt(maxx - minx + 1);\n  long long miny = 0, maxy = 0;\n  int i = 0, j = 0;\n  for (long long x = minx; x <= maxx; ++x) {\n    while (det(lo[i], lo[i + 1], Point{x, miny}) < 0) ++miny;\n    while (det(lo[i], lo[i + 1], Point{x, miny - 1}) >= 0) --miny;\n    while (det(hi[j], hi[j + 1], Point{x, maxy}) > 0) --maxy;\n    while (det(hi[j], hi[j + 1], Point{x, maxy + 1}) <= 0) ++maxy;\n    cnt[x - minx] = maxy - miny + 1;\n    if (x == lo[i + 1].real()) ++i;\n    if (x == hi[j + 1].real()) ++j;\n  }\n  long long total = 0;\n  for (int x = 0; x <= maxx - minx; ++x) total += cnt[x];\n  long double exp = 0, expsq = 0;\n  for (int x = 0; x <= maxx - minx; ++x) {\n    exp += 1.0L * x * cnt[x] / total;\n    expsq += 1.0L * x * x / total * cnt[x];\n  }\n  long double ans = 0;\n  for (int x = 0; x <= maxx - minx; ++x) {\n    long double add = 1.0L * x * x + expsq - 2.0L * x * exp;\n    ans += add / (total - 1) * cnt[x];\n  }\n  return ans;\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<Point> p(n);\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    p[i] = Point{x, y};\n  }\n  long double ans = 0;\n  for (int it = 0; it < 2; ++it) {\n    ans += Solve(p);\n    for (int i = 0; i < n; ++i) {\n      long long x = p[i].real(), y = p[i].imag();\n      p[i] = Point{y, x};\n    }\n  }\n  cout << fixed << setprecision(20) << 0.5L * ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n  int x, y;\n  void init() {\n    scanf(\"%d%d\", &x, &y);\n    x += 1000000;\n    y += 1000000;\n  }\n  void swap() {\n    x ^= y;\n    y ^= x;\n    x ^= y;\n  }\n};\nconst int MAXN = 100000;\nint n;\nPoint points[MAXN];\nint fix(int x) { return x < 0 ? x + n : x >= n ? x - n : x; }\nint getLower(int x, const Point &u, const Point &v) {\n  if (u.x == v.x) return min(u.y, v.y);\n  return (v.y * (long long)(v.x - u.x) - (v.x - x) * (long long)(v.y - u.y) +\n          v.x - u.x - 1) /\n         (v.x - u.x);\n}\nint getUpper(int x, const Point &u, const Point &v) {\n  if (u.x == v.x) return max(u.y, v.y);\n  return (v.y * (long long)(v.x - u.x) - (v.x - x) * (long long)(v.y - u.y)) /\n         (v.x - u.x);\n}\nlong double squareSum(long double l, long double u) {\n  long double res = (u - l + 1) / 6;\n  res += (u - l + 1) * (u + l - 1) / 2;\n  res += (u - l + 1) * (u * u + u * (l - 1) + (l - 1) * (l - 1)) / 3;\n  return res;\n}\nlong double calc() {\n  int p1 = 0, d1, p2, d2, minx = points[0].x, maxx = points[0].x;\n  for (int i = (1); i < (n); i++) {\n    if (points[p1].x > points[i].x) p1 = i;\n    minx = min(minx, points[i].x);\n    maxx = max(maxx, points[i].x);\n  }\n  p2 = p1;\n  d1 = 1;\n  d2 = -1;\n  if (points[fix(p1 + d1)].y > points[fix(p2 + d2)].y) swap(d1, d2);\n  long double sum = 0, sum2 = 0, m = 0;\n  for (int x = (minx); x < (maxx + 1); x++) {\n    int nxtp1 = fix(p1 + d1), nxtp2 = fix(p2 + d2);\n    int lower = getLower(x, points[p1], points[nxtp1]);\n    int upper = getUpper(x, points[p2], points[nxtp2]);\n    if (points[nxtp1].x == x) p1 = nxtp1;\n    if (points[nxtp2].x == x) p2 = nxtp2;\n    m += upper - lower + 1;\n    sum += (lower + upper) * (upper - lower + 1.0) / 2;\n    sum2 += squareSum(lower, upper);\n  }\n  return sum2 / (m - 1) - sum / m / (m - 1) * sum;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (0); i < (n); i++) points[i].init();\n  long double res = calc();\n  for (int i = (0); i < (n); i++) points[i].swap();\n  res += calc();\n  printf(\"%.16lf\\n\", (double)res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n  }\n  int mx = *min_element(x.begin(), x.end());\n  int my = *min_element(y.begin(), y.end());\n  for (int i = 0; i < n; ++i) {\n    x[i] -= mx;\n    y[i] -= my;\n  }\n  double res = 0;\n  bool isY = false;\nmakeY:\ntrap:\n  int MX = *max_element(x.begin(), x.end());\n  vector<int> count(MX + 1);\n  for (int i = 0; i < n; ++i) {\n    int x1 = x[i];\n    int x2 = x[(i + 1) % n];\n    int y1 = y[i];\n    int y2 = y[(i + 1) % n];\n    if (x1 == x2) {\n      continue;\n    }\n    if (x1 < x2) {\n      if (x2 == MX) count[x2] += y2;\n      for (int X = 0; X + x1 < x2; ++X) {\n        count[x1 + X] += y1;\n        if (y1 <= y2) {\n          count[x1 + X] += 1LL * (y2 - y1) * X / (x2 - x1);\n        } else {\n          count[x1 + X] -= (1LL * (y1 - y2) * X + (x2 - x1) - 1) / (x2 - x1);\n        }\n      }\n    } else {\n      if (x2 == 0) count[0] -= y2 - 1;\n      for (int X = 1; X + x2 <= x1; ++X) {\n        count[x2 + X] -= y2;\n        if (y1 >= y2) {\n          count[x2 + X] -= (1LL * (y1 - y2) * X) / (x1 - x2);\n          if ((1LL * (y1 - y2) * X) % (x1 - x2) == 0) count[x2 + X]++;\n        } else {\n          count[x2 + X] += 1LL * (y2 - y1) * X / (x1 - x2) + 1;\n        }\n      }\n    }\n  }\n  if (*min_element(count.begin(), count.end()) < 0) {\n    reverse(x.begin(), x.end());\n    reverse(y.begin(), y.end());\n    goto trap;\n  }\n  double sumX = 0;\n  double sumXS = 0;\n  double cnt = 0;\n  for (int i = 0; i <= MX; ++i) {\n    res += count[i] * (sumXS - sumX * 2 * i + 1.0 * i * i * cnt);\n    sumXS += 1.0 * count[i] * i * i;\n    sumX += 1.0 * count[i] * i;\n    cnt += count[i];\n  }\n  if (isY == false) {\n    isY = true;\n    for (int i = 0; i < n; ++i) swap(x[i], y[i]);\n    goto makeY;\n  }\n  res /= cnt * (cnt - 1) / 2;\n  printf(\"%.10lf\\n\", res / 2);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tGeometryUtils.epsilon = 5e-6;\n\t\tint count = in.readInt();\n\t\tint[] x = new int[count];\n\t\tint[] y = new int[count];\n\t\tIOUtils.readIntArrays(in, x, y);\n\t\tdouble answer = calculate(x, y, count) + calculate(y, x, count);\n\t\tout.printLine(answer);\n    }\n\n\tprivate double calculate(int[] x, int[] y, int count) {\n\t\tx = Arrays.copyOf(x, count + 1);\n\t\ty = Arrays.copyOf(y, count + 1);\n\t\tx[count] = x[0];\n\t\ty[count] = y[0];\n\t\tint minX = Integer.MAX_VALUE;\n\t\tint at = -1;\n\t\tint maxX = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tif (x[i] < minX) {\n\t\t\t\tminX = x[i];\n\t\t\t\tat = i;\n\t\t\t}\n\t\t\tmaxX = Math.max(maxX, x[i]);\n\t\t}\n\t\tlong[] qty = new long[maxX - minX + 1];\n\t\tint side = at;\n\t\tint otherSide = at - 1;\n\t\tif (otherSide < 0)\n\t\t\totherSide += count;\n\t\tfor (int i = minX; i < maxX; i++) {\n\t\t\twhile (x[side] <= i && x[side + 1] <= i) {\n\t\t\t\tside++;\n\t\t\t\tif (side == count)\n\t\t\t\t\tside = 0;\n\t\t\t}\n\t\t\twhile (x[otherSide] <= i && x[otherSide + 1] <= i) {\n\t\t\t\totherSide--;\n\t\t\t\tif (otherSide == -1)\n\t\t\t\t\totherSide = count - 1;\n\t\t\t}\n\t\t\tdouble y0 = getY(x, y, side, i);\n\t\t\tdouble y1 = getY(x, y, otherSide, i);\n\t\t\tif (y0 < y1)\n\t\t\t\tqty[i - minX] = delta(y0, y1);\n\t\t\telse\n\t\t\t\tqty[i - minX] = delta(y1, y0);\n\t\t}\n\t\tint minY = Integer.MAX_VALUE;\n\t\tint maxY = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tif (x[i] == maxX) {\n\t\t\t\tmaxY = Math.max(maxY, y[i]);\n\t\t\t\tminY = Math.min(minY, y[i]);\n\t\t\t}\n\t\t}\n\t\tqty[maxX - minX] = maxY - minY + 1;\n\t\tdouble sum = 0;\n\t\tlong total = 0;\n\t\tdouble result = 0;\n\t\tfor (long i = 0; i < qty.length; i++) {\n\t\t\tlong q = qty[((int) i)];\n\t\t\tsum += i * q;\n\t\t\tresult += i * i * q;\n\t\t\ttotal += q;\n\t\t}\n\t\tresult *= total;\n\t\tfor (int i = 0; i < qty.length; i++)\n\t\t\tresult -= sum * i * qty[i];\n\t\tresult /= total;\n\t\tresult /= total - 1;\n//\t\tresult *= 2;\n\t\treturn result;\n\t}\n\n\tprivate int delta(double y0, double y1) {\n\t\treturn (int) (Math.round(Math.floor(y1 + GeometryUtils.epsilon)) - Math.round(Math.ceil(y0 - GeometryUtils.epsilon)) + 1);\n\t}\n\n\tprivate double getY(int[] x, int[] y, int side, int i) {\n\t\treturn ((double)y[side] * Math.abs(x[side + 1] - i) + (double)y[side + 1] * Math.abs(x[side] - i)) / Math.abs(x[side] - x[side + 1]);\n\t}\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n    public void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\t}\n\nclass GeometryUtils {\n\tpublic static double epsilon = 1e-8;\n\n\t}\n\nclass IOUtils {\n\n\tpublic static void readIntArrays(InputReader in, int[]... arrays) {\n\t\tfor (int i = 0; i < arrays[0].length; i++) {\n\t\t\tfor (int j = 0; j < arrays.length; j++)\n\t\t\t\tarrays[j][i] = in.readInt();\n\t\t}\n\t}\n\n\t}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1 << 17, MIL = 1 << 21;\nint n;\npair<int, int> p[MAX];\nint br[MIL];\nint Norm(int x) { return (x + n) % n; }\nlong long Ccw(pair<int, int> a, pair<int, int> b, pair<int, int> c) {\n  return (long long)a.first * (b.second - c.second) +\n         (long long)b.first * (c.second - a.second) +\n         (long long)c.first * (a.second - b.second);\n}\ninline long long SumBr(int x) { return (long long)x * (x + 1) / 2; }\ninline long double SumKvad(int x) {\n  return (long double)x * (x + 1) * (2 * x + 1) / 6;\n}\ninline long long Sq(long long x) { return x * x; }\nlong double Rijesi() {\n  memset(br, 0, sizeof br);\n  int najvisa = 0, najniza = 0;\n  int lduz = 0, rduz = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].second > p[najvisa].second) {\n      najvisa = i;\n      lduz = rduz = najvisa;\n    } else if (p[i].second == p[najvisa].second) {\n      if (p[i].first < p[lduz].first) lduz = i;\n      if (p[i].first > p[rduz].first) rduz = i;\n    }\n    if (p[i].second < p[najniza].second) najniza = i;\n  }\n  int ltoc = 0, rtoc = MIL - 5;\n  long long brtoc = 0;\n  for (int vis = p[najvisa].second; vis >= p[najniza].second; vis--) {\n    for (; vis < p[Norm(lduz + 1)].second; lduz = Norm(lduz + 1))\n      ;\n    for (; vis < p[Norm(rduz - 1)].second; rduz = Norm(rduz - 1))\n      ;\n    int pr = lduz, dr = Norm(lduz + 1);\n    for (; ltoc - 1 >= min(p[pr].first, p[dr].first) &&\n           Ccw(p[pr], p[dr], pair<int, int>(ltoc - 1, vis)) >= 0;\n         ltoc--)\n      ;\n    for (; ltoc < min(p[pr].first, p[dr].first) ||\n           Ccw(p[pr], p[dr], pair<int, int>(ltoc, vis)) < 0;\n         ltoc++)\n      ;\n    pr = Norm(rduz - 1), dr = rduz;\n    for (; rtoc + 1 <= max(p[pr].first, p[dr].first) &&\n           Ccw(p[pr], p[dr], pair<int, int>(rtoc + 1, vis)) >= 0;\n         rtoc++)\n      ;\n    for (; rtoc > max(p[pr].first, p[dr].first) ||\n           Ccw(p[pr], p[dr], pair<int, int>(rtoc, vis)) < 0;\n         rtoc--)\n      ;\n    br[vis] = max(0, rtoc - ltoc + 1);\n    brtoc += br[vis];\n  }\n  long double koef = (long double)1 / ((long double)brtoc * (brtoc - 1) / 2);\n  long double ret = 0;\n  long double sumkvad = 0, sumlin = 0;\n  long double broj = 0;\n  for (int i = 0; i < MIL; i++) {\n    ret += koef * br[i] * (Sq(i) * broj + sumkvad - 2 * sumlin * i);\n    broj += br[i];\n    sumlin += (long double)i * br[i];\n    sumkvad += (long double)Sq(i) * br[i];\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &p[i].first, &p[i].second);\n    p[i].first += MIL / 2;\n    p[i].second += MIL / 2;\n  }\n  int rev = 0;\n  for (int i = 0; i < n; i++)\n    if (Ccw(p[i], p[Norm(i + 1)], p[Norm(i + 2)]) < 0) rev = 1;\n  if (rev) reverse(p, p + n);\n  long double rje = Rijesi();\n  for (int i = 0; i < n; i++) swap(p[i].first, p[i].second);\n  rev = 0;\n  for (int i = 0; i < n; i++)\n    if (Ccw(p[i], p[Norm(i + 1)], p[Norm(i + 2)]) < 0) rev = 1;\n  if (rev) reverse(p, p + n);\n  rje += Rijesi();\n  printf(\"%.10lf\\n\", (double)rje / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-9;\nstruct point {\n  int x, y;\n};\nint n;\npoint p[100020];\ndouble totcnt;\ndouble sdsq() {\n  int mxx = p[0].x;\n  int bi = 0;\n  for (int i = 1; i < n; ++i) {\n    if (p[i].x < p[bi].x) bi = i;\n    mxx = max(mxx, p[i].x);\n  }\n  int lo, hi;\n  lo = hi = bi;\n  int lpr = lo - 1;\n  if (lpr < 0) lpr += n;\n  int hne = hi + 1;\n  if (hne >= n) hne -= n;\n  while (p[lpr].x == p[lo].x) {\n    lo = lpr;\n    --lpr;\n    if (lpr < 0) lpr += n;\n  }\n  while (p[hne].x == p[hi].x) {\n    hi = hne;\n    ++hne;\n    if (hne >= n) hne -= n;\n  }\n  double ymi = min(p[hi].y, p[lo].y);\n  double ymx = max(p[hi].y, p[lo].y);\n  double ans = 0.0;\n  double spr = 0;\n  double tot = 0;\n  double cx = p[hi].x;\n  while (cx <= mxx) {\n    double yx, yi;\n    if (cx == p[hne].x) {\n      hi = hne;\n      ++hne;\n      if (hne >= n) hne -= n;\n      while (p[hne].x == p[hi].x) {\n        hi = hne;\n        ++hne;\n        if (hne >= n) hne -= n;\n      }\n    }\n    if (cx == p[lpr].x) {\n      lo = lpr;\n      --lpr;\n      if (lpr < 0) lpr += n;\n      while (p[lpr].x == p[lo].x) {\n        lo = lpr;\n        --lpr;\n        if (lpr < 0) lpr += n;\n      }\n    }\n    double a, b, c;\n    a = p[hi].y - p[hne].y;\n    b = p[hne].x - p[hi].x;\n    c = -a * p[hi].x - b * p[hi].y;\n    yx = (-c - a * cx) / b;\n    a = p[lo].y - p[lpr].y;\n    b = p[lpr].x - p[lo].x;\n    c = -a * p[lo].x - b * p[lo].y;\n    yi = (-c - a * cx) / b;\n    ymi = (int)ceil(min(yx, yi));\n    ymx = (int)floor(max(yx, yi));\n    double cnt = ymx - ymi + 1;\n    ans += (double)(totcnt - cnt) * cnt * cx * cx;\n    ans -= 2.0 * (double)spr * cnt * cx;\n    tot += cnt;\n    spr += cnt * cx;\n    ++cx;\n  }\n  totcnt = tot;\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &p[i].x, &p[i].y);\n  }\n  sdsq();\n  double sm = sdsq();\n  for (int i = 0; i < n; i++) {\n    swap(p[i].x, p[i].y);\n  }\n  sm += sdsq();\n  printf(\"%.10lf\\n\", sm / ((double)totcnt) / ((double)totcnt - 1.0));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x[100010], y[100010], n;\nint CEIL(long long a, long long b) {\n  if (b < 0) a = -a, b = -b;\n  if (a < 0) return -((-a) / b);\n  return a / b + (a % b != 0);\n}\nint FLOOR(long long a, long long b) {\n  if (b < 0) a = -a, b = -b;\n  if (a > 0) return a / b;\n  a = -a;\n  int ans = a / b;\n  if (a % b) ans++;\n  return -ans;\n}\nint CEIL(int p1, int p2, int Y) {\n  if (y[p1] == y[p2]) return min(x[p1], x[p2]);\n  return x[p1] + CEIL(1LL * (Y - y[p1]) * (x[p2] - x[p1]), y[p2] - y[p1]);\n}\nint FLOOR(int p1, int p2, int Y) {\n  if (y[p1] == y[p2]) return max(x[p1], x[p2]);\n  return x[p1] + FLOOR(1LL * (Y - y[p1]) * (x[p2] - x[p1]), y[p2] - y[p1]);\n}\nint num[2000010];\ndouble cal() {\n  long long s = 0;\n  for (int i = 0; i < n; i++)\n    s += 1LL * x[i] * y[(i + 1) % n] - 1LL * y[i] * x[(i + 1) % n];\n  if (s < 0) reverse(x, x + n), reverse(y, y + n);\n  int p1 = 0, p2 = 0;\n  for (int i = 1; i < n; i++)\n    if (y[i] > y[p1]) p1 = i, p2 = i;\n  int mi = (int)1e8;\n  for (int i = 0; i < n; i++) mi = min(mi, y[i]);\n  memset(num, 0, sizeof(num));\n  for (int i = y[p1]; i >= mi; i--) {\n    int L = CEIL(p1, (p1 + 1) % n, i);\n    int R = FLOOR(p2, (p2 - 1 + n) % n, i);\n    num[i] = R - L + 1;\n    if (num[i] < 0) puts(\"fuck\");\n    if (i == y[(p1 + 1) % n]) p1 = (p1 + 1) % n;\n    if (i == y[(p2 - 1 + n) % n]) p2 = (p2 - 1 + n) % n;\n  }\n  long long cnt = 0;\n  for (int i = 0; i < 2000000; i++) cnt += num[i];\n  s = 0;\n  for (int i = 0; i < 2000000; i++) s += 1LL * i * num[i];\n  double ans = 0;\n  for (int i = 0; i < 2000000; i++)\n    if (num[i]) ans += 1.0 * i * num[i] / (cnt - 1) * (i - 1.0 * s / cnt);\n  return ans;\n}\nint main() {\n  while (~scanf(\"%d\", &n)) {\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n    for (int i = 0; i < n; i++) x[i] += 1000000, y[i] += 1000000;\n    double ans = cal();\n    for (int i = 0; i < n; i++) swap(x[i], y[i]);\n    ans += cal();\n    printf(\"%.10f\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x[100005], y[100005];\nint up[2000005], down[2000005];\nint A = 1000000;\nbool on(int i, int j, int nx, int ny) {\n  return 1LL * (x[j] - x[i]) * (ny - y[i]) -\n             1LL * (y[j] - y[i]) * (nx - x[i]) ==\n         0;\n}\nbool cw(int i, int j, int nx, int ny) {\n  return 1LL * (x[j] - x[i]) * (ny - y[i]) -\n             1LL * (y[j] - y[i]) * (nx - x[i]) >=\n         0;\n}\nbool ccw(int i, int j, int nx, int ny) {\n  return 1LL * (x[j] - x[i]) * (ny - y[i]) -\n             1LL * (y[j] - y[i]) * (nx - x[i]) <=\n         0;\n}\ndouble solveX(int n) {\n  for (int i = -A; i <= A; ++i) {\n    up[i + A] = -2 * A;\n    down[i + A] = 2 * A;\n  }\n  bool ok1 = false, ok2 = false;\n  for (int i = 2; i < n; ++i)\n    if (!on(i - 2, i - 1, x[i], y[i])) {\n      ok1 = cw(i - 2, i - 1, x[i], y[i]);\n      ok2 = ccw(i - 2, i - 1, x[i], y[i]);\n      break;\n    }\n  for (int i = 0; i < n; ++i) {\n    int lx = min(x[i], x[i + 1]), rx = max(x[i], x[i + 1]);\n    if (lx == rx) {\n      up[lx + A] = max(up[lx + A], max(y[i], y[i + 1]));\n      down[lx + A] = min(down[lx + A], min(y[i], y[i + 1]));\n    } else\n      for (int j = lx; j <= rx; ++j) {\n        long double ny =\n            (1.0 * (y[i + 1] - y[i]) * (j - x[i]) / (x[i + 1] - x[i]));\n        int u = ny + y[i] - 2;\n        if (ok1) {\n          if (!cw(i, i + 1, j, u)) {\n            ++u;\n            while (!cw(i, i + 1, j, u)) {\n              ++u;\n            }\n            down[j + A] = u;\n          } else {\n            while (cw(i, i + 1, j, u + 1)) ++u;\n            up[j + A] = u;\n          }\n        }\n        if (ok2) {\n          if (!ccw(i, i + 1, j, u)) {\n            ++u;\n            while (!ccw(i, i + 1, j, u)) {\n              ++u;\n            }\n            down[j + A] = u;\n          } else {\n            while (ccw(i, i + 1, j, u + 1)) ++u;\n            up[j + A] = u;\n          }\n        }\n      }\n  }\n  long double ret = 0;\n  long long sum = 0, total = 0;\n  for (int i = -A; i <= A; ++i) {\n    if (up[i + A] >= down[i + A]) {\n      total += (up[i + A] - down[i + A] + 1);\n      ret += 1LL * i * i * (up[i + A] - down[i + A] + 1);\n      sum += 1LL * i * (up[i + A] - down[i + A] + 1);\n    }\n  }\n  for (int i = -A; i <= A; ++i) {\n    if (up[i + A] >= down[i + A]) {\n      ret -= 1.0 * i * (up[i + A] - down[i + A] + 1) / total * sum;\n    }\n  }\n  return ret / (total - 1);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d%d\", &x[i], &y[i]);\n  x[n] = x[0];\n  y[n] = y[0];\n  double ans = solveX(n);\n  for (int i = 0; i <= n; ++i) swap(x[i], y[i]);\n  memset(up, 0, sizeof(up));\n  memset(down, 0, sizeof(down));\n  ans += solveX(n);\n  printf(\"%.7lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010000;\nint x[110000], y[110000];\nint n;\nlong double sumx2, sumx, sum;\nlong double sumy2, sumy;\nlong double l[N + 5], r[N + 5];\nconst long double dw = 1.;\ninline void cover(int x1, int y1, int x2, int y2) {\n  if (x1 > x2) {\n    swap(x1, x2);\n    swap(y1, y2);\n  }\n  if (x1 == x2) {\n    l[x1] = min(l[x1], dw * min(y2, y1));\n    r[x1] = max(r[x1], dw * max(y2, y1));\n  } else {\n    for (int k = (x1); k <= (int)x2; k++) {\n      long double jiao = (y2 - y1) * ((k - x1) * dw / (x2 - x1)) + y1;\n      r[k] = max(r[k], jiao);\n      l[k] = min(l[k], jiao);\n    }\n  }\n}\ninline void Do() {\n  for (int i = (0); i <= (int)N; i++) l[i] = N, r[i] = 0;\n  for (int i = (1); i <= (int)n; i++) cover(x[i], y[i], x[i + 1], y[i + 1]);\n  for (int i = (0); i <= (int)N; i++)\n    if (l[i] < N - 2) {\n      int a1 = ceil(l[i]);\n      int a2 = (int)r[i];\n      long double ll = a1 * 1.;\n      long double rr = a2 * 1.;\n      sum += rr - ll + 1;\n      sumx += (rr - ll + 1) * i;\n      sumx2 += (rr - ll + 1) * 1. * i * i;\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (int)n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    x[i] += N / 2;\n    y[i] += N / 2;\n  }\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  Do();\n  for (int i = (1); i <= (int)n + 1; i++) swap(x[i], y[i]);\n  sumy2 = sumx2;\n  sumy = sumx;\n  sumx2 = sumx = sum = 0;\n  Do();\n  long double ans = sum * sumx2 - sumx * sumx + sum * sumy2 - sumy * sumy;\n  ans /= sum;\n  ans /= (sum - 1);\n  printf(\"%.10lf\\n\", (double)ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar ch;\ninline void read(int &x) {\n  x = 0;\n  ch = getchar();\n  while (ch <= 32) ch = getchar();\n  int f = 1;\n  if (ch == '-') f = -1, ch = getchar();\n  while (ch > 32) x = x * 10 + ch - 48, ch = getchar();\n  x *= f;\n}\ntemplate <class T>\ninline void swap(T &a, T &b) {\n  T t = a;\n  a = b;\n  b = t;\n}\ntemplate <class T>\ninline T max(T a, T b) {\n  return a > b ? a : b;\n}\ntemplate <class T>\ninline T min(T a, T b) {\n  return a < b ? a : b;\n}\nint n;\nint X[100005], Y[100005];\nint L[2000010], U[2000010];\ninline int floordiv(long long a, int b) {\n  return a / b - (a < 0 && a % b != 0);\n}\ninline void add(int x1, int y1, int x2, int y2) {\n  if (x1 > x2) swap(x1, x2), swap(y1, y2);\n  if (x1 == x2) {\n    L[x1] = min(L[x1], min(y1, y2));\n    U[x1] = max(U[x1], max(y1, y2));\n    return;\n  }\n  int i;\n  for (i = x1; i <= x2; i++) {\n    int yU = floordiv(1LL * (i - x1) * (y2 - y1), (x2 - x1)) + y1;\n    int yL = yU + (1LL * (i - x1) * (y2 - y1) % (x2 - x1) != 0);\n    L[i] = min(L[i], yL);\n    U[i] = max(U[i], yU);\n  }\n}\ninline double calc() {\n  int i;\n  long long cnt = 0;\n  double sx = 0;\n  double sx2 = 0;\n  double ret = 0;\n  for (i = 1; i <= 2000005; i++) {\n    if (L[i] > U[i]) continue;\n    int k = U[i] - L[i] + 1;\n    ret += k * ((double)i * i * cnt + sx2 - 2.0 * i * sx);\n    sx += 1LL * k * i;\n    sx2 += 1LL * k * i * i;\n    cnt += k;\n  }\n  return ret / ((double)cnt * (cnt - 1));\n}\ninline double solvex() {\n  int i;\n  for (i = 1; i <= 2000005; i++) {\n    L[i] = 0x3f3f3f3f, U[i] = -0x3f3f3f3f;\n  }\n  for (i = 1; i <= n; i++) {\n    add(X[i], Y[i], X[i - 1], Y[i - 1]);\n  }\n  return calc();\n}\ninline double solvey() {\n  int i;\n  for (i = 1; i <= 2000005; i++) {\n    L[i] = 0x3f3f3f3f, U[i] = -0x3f3f3f3f;\n  }\n  for (i = 1; i <= n; i++) {\n    add(Y[i], X[i], Y[i - 1], X[i - 1]);\n  }\n  return calc();\n}\nint main() {\n  read(n);\n  int i;\n  for (i = 1; i <= n; i++) {\n    read(X[i]);\n    read(Y[i]);\n    X[i] += 1000003;\n    Y[i] += 1000003;\n  }\n  X[0] = X[n];\n  Y[0] = Y[n];\n  printf(\"%.10lf\\n\", solvex() + solvey());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, j, k, x1, x2;\nint x[100005], y[100005];\nint l[3000005], r[3000005];\nlong long S[3000005], A, B, K;\ndouble ans, sum, sum2, sum3;\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i)\n    scanf(\"%d%d\", &x[i], &y[i]), x[i] += 1000001, y[i] += 1000001;\n  for (i = 1; i <= 2000005; ++i) l[i] = 3000000, r[i] = -3000000;\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  for (i = 1; i <= n; ++i)\n    if (x[i] == x[i + 1]) {\n      if (y[i] > r[x[i]]) r[x[i]] = y[i];\n      if (y[i] - 1 < l[x[i]]) l[x[i]] = y[i] - 1;\n      if (y[i + 1] > r[x[i]]) r[x[i]] = y[i + 1];\n      if (y[i + 1] - 1 < l[x[i]]) l[x[i]] = y[i + 1] - 1;\n    } else {\n      if (x[i] < x[i + 1])\n        B = x[i + 1] - x[i], A = y[i] * B, K = y[i + 1] - y[i];\n      else\n        B = x[i] - x[i + 1], A = y[i + 1] * B, K = y[i] - y[i + 1];\n      x1 = x[i];\n      x2 = x[i + 1];\n      if (x1 > x2) swap(x1, x2);\n      for (j = x1; j <= x2; ++j) {\n        if (A / B > r[j]) r[j] = A / B;\n        if (A / B - (A % B == 0) < l[j]) l[j] = A / B - (A % B == 0);\n        A += K;\n      }\n    }\n  for (i = 1; i <= 2000005; ++i)\n    if (l[i] <= r[i]) ++S[l[i] + 1], --S[r[i] + 1];\n  for (i = 1; i <= 2000005; ++i) S[i] += S[i - 1];\n  sum = sum2 = sum3 = 0;\n  for (i = 1; i <= 2000005; ++i) {\n    ans += S[i] * (sum3 * i * i - sum2 * i * 2 + sum);\n    sum += (double)i * i * S[i];\n    sum2 += (double)i * S[i];\n    sum3 += S[i];\n  }\n  for (i = 1; i <= 2000005; ++i)\n    if (l[i] <= r[i])\n      S[i] = r[i] - l[i];\n    else\n      S[i] = 0;\n  sum = sum2 = sum3 = 0;\n  for (i = 1; i <= 2000005; ++i) {\n    ans += S[i] * (sum3 * i * i - sum2 * i * 2 + sum);\n    sum += (double)i * i * S[i];\n    sum2 += (double)i * S[i];\n    sum3 += S[i];\n  }\n  printf(\"%.20lf\\n\", ans / (sum3 * (sum3 - 1)));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\ndouble ans;\nint n, m = 1000000;\nint d[2000005], u[2000005];\nint x[100005], y[100005];\nvoid solve() {\n  for (int i = -m; i <= m; i++) d[i + m] = 1000000000, u[i + m] = -1000000000;\n  int lm = m, rm = -m;\n  for (int i = 1; i <= n; i++) lm = min(lm, x[i]), rm = max(rm, x[i]);\n  for (int i = 1; i <= n; i++) {\n    if (x[i] == x[i + 1]) {\n      u[x[i] + m] = max(u[x[i] + m], y[i]);\n      d[x[i] + m] = min(d[x[i] + m], y[i]);\n      continue;\n    }\n    bool flag = 0;\n    if (x[i] > x[i + 1]) {\n      swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n      flag = 1;\n    }\n    for (int j = x[i]; j <= x[i + 1]; j++) {\n      double now =\n          (double)(j - x[i]) / (x[i + 1] - x[i]) * (y[i + 1] - y[i]) + y[i];\n      d[j + m] = min((int)ceil(now), d[j + m]);\n      u[j + m] = max((int)floor(now), u[j + m]);\n    }\n    if (flag) swap(x[i], x[i + 1]), swap(y[i], y[i + 1]);\n  }\n  double s0 = 0, s1 = 0, s2 = 0;\n  for (long long i = lm; i <= rm; i++) {\n    long long t = u[i + m] - d[i + m] + 1;\n    s0 += t;\n    s1 += t * i;\n    s2 += t * i * i;\n  }\n  ans += (double)(s0 * s2 - s1 * s1) / s0 / (s0 - 1);\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) x[i] = read(), y[i] = read();\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  solve();\n  for (int i = 1; i <= n + 1; i++) swap(x[i], y[i]);\n  solve();\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct ppp {\n  int x, y;\n} p[370000];\nlong long num, res;\ndouble ans;\nint i, j, k, D[1000001 * 2 + 10], n, l, r, maxx;\nvoid workx() {\n  num = 0;\n  res = 0;\n  k = n + 1;\n  maxx = p[1].x;\n  for (i = n + 2; i <= n + n; ++i) {\n    if (p[i].x < p[k].x) k = i;\n    maxx = max(maxx, p[i].x);\n  }\n  l = r = k;\n  for (i = p[k].x; i <= maxx; ++i) {\n    while (l - 1 >= 1 && p[l - 1].x >= p[l].x && p[l - 1].x <= i) --l;\n    while (r + 1 <= n * 3 && p[r + 1].x >= p[r].x && p[r + 1].x <= i) ++r;\n    double u =\n        double(p[l - 1].y - p[l].y) / (p[l - 1].x - p[l].x) * (i - p[l].x) +\n        p[l].y;\n    double d =\n        double(p[r + 1].y - p[r].y) / (p[r + 1].x - p[r].x) * (i - p[r].x) +\n        p[r].y;\n    if (u < d) swap(u, d);\n    D[i + 1000001] = int(floor(u) - ceil(d)) + 1;\n    num += D[i + 1000001];\n    res += (long long)i * D[i + 1000001];\n  }\n  for (j = p[k].x; j <= maxx; ++j) {\n    ans += double(num - 1) * j * j * D[j + 1000001];\n    ans -= double(res - j) * j * D[j + 1000001];\n  }\n}\nvoid worky() {\n  num = 0;\n  res = 0;\n  k = n + 1;\n  maxx = p[1].y;\n  for (i = n + 2; i <= n + n; ++i) {\n    if (p[i].y < p[k].y) k = i;\n    maxx = max(maxx, p[i].y);\n  }\n  l = r = k;\n  for (i = p[k].y; i <= maxx; ++i) {\n    while (l - 1 >= 1 && p[l - 1].y >= p[l].y && p[l - 1].y <= i) --l;\n    while (r + 1 <= n * 3 && p[r + 1].y >= p[r].y && p[r + 1].y <= i) ++r;\n    double u =\n        double(p[l - 1].x - p[l].x) / (p[l - 1].y - p[l].y) * (i - p[l].y) +\n        p[l].x;\n    double d =\n        double(p[r + 1].x - p[r].x) / (p[r + 1].y - p[r].y) * (i - p[r].y) +\n        p[r].x;\n    if (u < d) swap(u, d);\n    D[i + 1000001] = int(floor(u) - ceil(d)) + 1;\n    num += D[i + 1000001];\n    res += (long long)i * D[i + 1000001];\n  }\n  for (j = p[k].y; j <= maxx; ++j) {\n    ans += double(num - 1) * j * j * D[j + 1000001];\n    ans -= double(res - j) * j * D[j + 1000001];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &p[i].x, &p[i].y);\n    p[i + n] = p[i + n + n] = p[i];\n  }\n  p[0] = p[n];\n  p[n + n + n + 1] = p[1];\n  workx();\n  worky();\n  printf(\"%.10lf\\n\", ans / num / (num - 1));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x[100000], y[100000];\ndouble solve(int* x, int* y, int n) {\n  long long area = 0;\n  for (int i = 0; i < n; i++) {\n    long long ax = x[i], bx = x[(i + 1) % n];\n    long long ay = y[i], by = y[(i + 1) % n];\n    area += ax * by - ay * bx;\n  }\n  if (area > 0) {\n    reverse(x, x + n);\n    reverse(y, y + n);\n  }\n  vector<long long> count(2e6 + 10, 0);\n  long long maxx = -1e9;\n  for (int i = 0; i < n; i++) {\n    long long ax = x[i], bx = x[(i + 1) % n];\n    long long ay = y[i], by = y[(i + 1) % n];\n    for (int j = ax; j < bx; j++) {\n      count[j] += (ay * (bx - ax) + (by - ay) * (j - ax)) / (bx - ax);\n    }\n    for (int j = bx; j < ax; j++) {\n      count[j] -= (by * (ax - bx) + (ay - by) * (j - bx) - 1) / (ax - bx);\n    }\n    if (ax == bx && by < ay) {\n      count[ax] += ay - by;\n    }\n    maxx = max(maxx, ax);\n  }\n  count[maxx]++;\n  long double sum = 0, sum2 = 0, tot = 0;\n  for (int i = 0; i < count.size(); i++) {\n    tot += count[i];\n    sum += (long double)count[i] * i;\n  }\n  assert(tot > 1);\n  sum /= tot;\n  for (int i = 0; i < count.size(); i++) {\n    sum2 += count[i] * (i - sum) * (i - sum);\n  }\n  return 2 * sum2 / (tot - 1);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += 1e6 + 1;\n    y[i] += 1e6 + 1;\n  }\n  double ans = 0;\n  ans += solve(x, y, n);\n  ans += solve(y, x, n);\n  cout << setprecision(20) << ans / 2 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\npair<int, int> a[100005];\nint crossProd(pair<int, int> o, pair<int, int> a, pair<int, int> b) {\n  long long res = 1ll * (a.first - o.first) * (b.second - o.second) -\n                  1ll * (a.second - o.second) * (b.first - o.first);\n  if (res > 0) return 1;\n  if (res == 0) return 0;\n  return -1;\n}\nstruct hull {\n  set<pair<int, int> > s;\n  bool checkUnder(const pair<int, int>& p) {\n    if (s.empty()) return 0;\n    if (p.first < (*s.begin()).first || (*s.rbegin()).first < p.first) return 0;\n    set<pair<int, int> >::iterator it =\n        s.lower_bound(pair<int, int>(p.first, -(int)1e9));\n    if ((*it).first == p.first) return (*it).second >= p.second;\n    return crossProd(*prev(it), *it, p) <= 0;\n  };\n  void insert(const pair<int, int>& p) {\n    set<pair<int, int> >::iterator it =\n        s.lower_bound(pair<int, int>(p.first, -(int)1e9));\n    if (it != s.end() && (*it).first == p.first) {\n      if ((*it).second >= p.second)\n        return;\n      else\n        s.erase(it);\n    }\n    s.insert(p);\n    set<pair<int, int> >::iterator ppos = s.find(p);\n    if (ppos != s.begin() && next(ppos) != s.end()) {\n      pair<int, int> bef = *(prev(ppos));\n      pair<int, int> aft = *(next(ppos));\n      if (crossProd(bef, p, aft) >= 0) {\n        s.erase(ppos);\n        return;\n      }\n    }\n    while (next(ppos) != s.end() && next(next(ppos)) != s.end() &&\n           crossProd(p, *next(ppos), *next(next(ppos))) >= 0) {\n      s.erase(next(ppos));\n    }\n    while (ppos != s.begin() && prev(ppos) != s.begin() &&\n           crossProd(*prev(prev(ppos)), *prev(ppos), p) >= 0) {\n      s.erase(prev(ppos));\n    }\n  };\n};\nlong long total = 0;\nhull up, down;\nint cnt[2000005];\nlong double solve() {\n  up.s.clear();\n  down.s.clear();\n  int minx = (int)1e6, maxx = (int)-1e6;\n  for (int i = 0; i < n; i++) {\n    minx = min(minx, a[i].first);\n    maxx = max(maxx, a[i].first);\n    up.insert(pair<int, int>(a[i].first, a[i].second));\n    down.insert(pair<int, int>(a[i].first, -a[i].second));\n  }\n  int pivotup = (int)1e6;\n  int pivotdown = (int)1e6;\n  for (int i = minx; i <= maxx; i++) {\n    while (!up.checkUnder(pair<int, int>(i, pivotup))) pivotup--;\n    while (up.checkUnder(pair<int, int>(i, pivotup + 1))) pivotup++;\n    while (!down.checkUnder(pair<int, int>(i, pivotdown))) pivotdown--;\n    while (down.checkUnder(pair<int, int>(i, pivotdown + 1))) pivotdown++;\n    cnt[i + (int)1e6] = max(0, pivotup - (-pivotdown) + 1);\n    total += cnt[i + (int)1e6];\n  }\n  long double res = 0;\n  long double sumaj = 0, sumajj = 0, sumajjj = 0;\n  for (int i = minx; i <= maxx; i++) {\n    res += 1.0 * cnt[i + (int)1e6] *\n           (1.0 * sumaj * i * i + sumajjj - 2.0 * i * sumajj);\n    sumaj += 1.0 * cnt[i + (int)1e6];\n    sumajj += 1.0 * cnt[i + (int)1e6] * i;\n    sumajjj += 1.0 * cnt[i + (int)1e6] * i * i;\n  }\n  return res;\n}\nint main() {\n  iostream::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n  }\n  long double ans = solve();\n  for (int i = 0; i < n; i++) swap(a[i].first, a[i].second);\n  ans += solve();\n  total /= 2;\n  cout << fixed << setprecision(10)\n       << ans / 2 / (1.0 * total * (total - 1) / 2);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\npair<int, int> p[100010], up[100010], down[100010];\ndouble ans;\nvoid read(int &x) {\n  char ch = getchar();\n  int mark = 1;\n  for (; ch != '-' && (ch < '0' || ch > '9'); ch = getchar())\n    ;\n  if (ch == '-') mark = -1, ch = getchar();\n  for (x = 0; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - 48;\n  x *= mark;\n}\nlong long cp(pair<int, int> A, pair<int, int> B, pair<int, int> C) {\n  return (long long)(B.first - A.first) * (C.second - A.second) -\n         (long long)(C.first - A.first) * (B.second - A.second);\n}\nint GetU(pair<int, int> *a, int tot, int x) {\n  int t = upper_bound(a + 1, a + tot + 1, make_pair(x, 1000000)) - a - 1;\n  if (a[t].first == x) return a[t].second;\n  int tmp = (double)(a[t + 1].second - a[t].second) /\n                (a[t + 1].first - a[t].first) * (x - a[t].first) +\n            a[t].second;\n  for (int i = tmp + 1;; i--)\n    if (cp(a[t], make_pair(x, i), a[t + 1]) >= 0) return i;\n}\nint GetD(pair<int, int> *a, int tot, int x) {\n  int t = upper_bound(a + 1, a + tot + 1, make_pair(x, 1000000)) - a - 1;\n  if (a[t].first == x) return a[t].second;\n  int tmp = (double)(a[t + 1].second - a[t].second) /\n                (a[t + 1].first - a[t].first) * (x - a[t].first) +\n            a[t].second;\n  for (int i = tmp - 1;; i++)\n    if (cp(a[t], make_pair(x, i), a[t + 1]) <= 0) return i;\n}\ndouble Solve() {\n  double X1 = 0, X2 = 0, Y = 0;\n  int st = 0, en = 0, utot = 0, dtot = 0;\n  for (int i = 1; i <= n; i++) {\n    if (st == 0 || p[st].first > p[i].first ||\n        (p[st].first == p[i].first && p[st].second < p[i].second))\n      st = i;\n    if (en == 0 || p[en].first < p[i].first ||\n        (p[en].first == p[i].first && p[en].second < p[i].second))\n      en = i;\n  }\n  if (cp(p[st], p[((st == n) ? 1 : st + 1)], p[((st == 1) ? n : st - 1)]) < 0)\n    for (int i = st; i != en; i = ((i == n) ? 1 : i + 1)) up[++utot] = p[i];\n  else\n    for (int i = st; i != en; i = ((i == 1) ? n : i - 1)) up[++utot] = p[i];\n  up[++utot] = p[en];\n  st = en = 0;\n  for (int i = 1; i <= n; i++) {\n    if (st == 0 || p[st].first > p[i].first ||\n        (p[st].first == p[i].first && p[st].second > p[i].second))\n      st = i;\n    if (en == 0 || p[en].first < p[i].first ||\n        (p[en].first == p[i].first && p[en].second > p[i].second))\n      en = i;\n  }\n  if (cp(p[st], p[((st == n) ? 1 : st + 1)], p[((st == 1) ? n : st - 1)]) > 0)\n    for (int i = st; i != en; i = ((i == n) ? 1 : i + 1)) down[++dtot] = p[i];\n  else\n    for (int i = st; i != en; i = ((i == 1) ? n : i - 1)) down[++dtot] = p[i];\n  down[++dtot] = p[en];\n  for (int i = p[st].first; i <= p[en].first; i++) {\n    int U = GetU(up, utot, i), D = GetD(down, dtot, i);\n    Y += U - D + 1;\n    X2 += (long long)(U - D + 1) * i;\n    X1 += (long long)(U - D + 1) * i * i;\n  }\n  return (2 * X1 * (Y - 1) - 2 * (X2 * X2 - X1)) / Y / (Y - 1) / 2;\n}\nint main() {\n  read(n);\n  for (int i = 1; i <= n; i++) read(p[i].first), read(p[i].second);\n  ans = Solve();\n  for (int i = 1; i <= n; i++) swap(p[i].first, p[i].second);\n  ans += Solve();\n  printf(\"%.9lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010, MAXV = 1000010;\nconst double eps = 1e-8, PI = atan2(0, -1);\nvector<double> x[MAXV * 2], y[MAXV * 2];\nint cx[MAXV * 2], cy[MAXV * 2];\ninline double sqr(double x) { return x * x; }\ninline bool zero(double x) { return (x > 0 ? x : -x) < eps; }\ninline int sgn(double x) { return (x > eps ? 1 : (x + eps < 0 ? -1 : 0)); }\nstruct point {\n  double x, y;\n  point(double x, double y) : x(x), y(y) {}\n  point() {}\n  bool operator==(const point& a) const {\n    return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\n  }\n  bool operator!=(const point& a) const {\n    return sgn(x - a.x) != 0 || sgn(y - a.y) != 0;\n  }\n  bool operator<(const point& a) const {\n    return sgn(x - a.x) < 0 || sgn(x - a.x) == 0 && sgn(y - a.y) < 0;\n  }\n  point operator+(const point& a) const { return point(x + a.x, y + a.y); }\n  point operator-(const point& a) const { return point(x - a.x, y - a.y); }\n  point operator*(const double& a) const { return point(x * a, y * a); }\n  point operator/(const double& a) const { return point(x / a, y / a); }\n  double operator*(const point& a) const { return x * a.y - y * a.x; }\n  double operator^(const point& a) const { return x * a.x + y * a.y; }\n} p[MAXN], tp[3];\ninline bool dotsInline(const point& p1, const point& p2, const point& p3) {\n  return zero((p1 - p3) * (p2 - p3));\n}\ninline bool parallel(const point& u1, const point& u2, const point& v1,\n                     const point& v2) {\n  return zero((u1 - u2) * (v1 - v2));\n}\ninline point intersection(const point& u1, const point& u2, const point& v1,\n                          const point& v2) {\n  return u1 + (u2 - u1) * (((u1 - v1) * (v1 - v2)) / ((u1 - u2) * (v1 - v2)));\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    p[i].x += MAXV;\n    p[i].y += MAXV;\n  }\n  p[n] = p[0];\n  for (int i = 0; i < n; i++) {\n    if (p[i].x < p[i + 1].x) {\n      for (int j = p[i].x; j <= p[i + 1].x; j++) {\n        tp[0] = point(j, 0);\n        tp[1] = point(j, 1);\n        if (!parallel(tp[0], tp[1], p[i], p[i + 1])) {\n          x[j].push_back(intersection(tp[0], tp[1], p[i], p[i + 1]).y);\n        }\n      }\n    } else if (p[i].x > p[i + 1].x) {\n      for (int j = p[i + 1].x; j <= p[i].x; j++) {\n        tp[0] = point(j, 0);\n        tp[1] = point(j, 1);\n        if (!parallel(tp[0], tp[1], p[i], p[i + 1])) {\n          x[j].push_back(intersection(tp[0], tp[1], p[i], p[i + 1]).y);\n        }\n      }\n    } else {\n      x[int(p[i].x + .2)].push_back(p[i].y);\n      x[int(p[i].x + .2)].push_back(p[i + 1].y);\n    }\n    if (p[i].y < p[i + 1].y) {\n      for (int j = p[i].y; j <= p[i + 1].y; j++) {\n        tp[0] = point(0, j);\n        tp[1] = point(1, j);\n        if (!parallel(tp[0], tp[1], p[i], p[i + 1])) {\n          y[j].push_back(intersection(tp[0], tp[1], p[i], p[i + 1]).x);\n        }\n      }\n    } else if (p[i].y > p[i + 1].y) {\n      for (int j = p[i + 1].y; j <= p[i].y; j++) {\n        tp[0] = point(0, j);\n        tp[1] = point(1, j);\n        if (!parallel(tp[0], tp[1], p[i], p[i + 1])) {\n          y[j].push_back(intersection(tp[0], tp[1], p[i], p[i + 1]).x);\n        }\n      }\n    } else {\n      y[int(p[i].y + .2)].push_back(p[i].x);\n      y[int(p[i].y + .2)].push_back(p[i + 1].x);\n    }\n  }\n  int lowx = MAXV * 2 - 1, highx = 0;\n  long long tot = 0;\n  for (int i = 0; i < MAXV * 2; i++) {\n    if (x[i].size() == 0) continue;\n    lowx = min(lowx, i);\n    highx = max(highx, i);\n    double l = x[i][0], r = x[i][0];\n    for (int j = 0; j < (int)x[i].size(); j++) {\n      l = min(x[i][j], l);\n      r = max(x[i][j], r);\n    }\n    int L = (int)l - 2, R = (int)r + 2;\n    while (sgn(L - l) < 0) L++;\n    while (sgn(r - R) < 0) R--;\n    cx[i] = R - L + 1;\n    tot += cx[i];\n  }\n  double mul = (2.0 / tot) / (tot - 1);\n  int lowy = MAXV * 2 - 1, highy = 0;\n  for (int i = 0; i < MAXV * 2; i++) {\n    if (y[i].size() == 0) continue;\n    lowy = min(lowy, i);\n    highy = max(highy, i);\n    double l = y[i][0], r = y[i][0];\n    for (int j = 0; j < (int)y[i].size(); j++) {\n      l = min(y[i][j], l);\n      r = max(y[i][j], r);\n    }\n    int L = (int)l - 2, R = (int)r + 2;\n    while (sgn(L - l) < 0) L++;\n    while (sgn(r - R) < 0) R--;\n    cy[i] = R - L + 1;\n  }\n  double A = cx[highx], B = cx[highx], C = 0;\n  double ans = A * (cx[highx - 1] * mul);\n  for (int i = highx - 1; i > lowx; i--) {\n    C += 2 * cx[i + 1];\n    B += C + cx[i];\n    A += B;\n    ans += A * (cx[i - 1] * mul);\n  }\n  A = cy[highy];\n  B = cy[highy];\n  C = 0;\n  ans += A * (cy[highy - 1] * mul);\n  for (int i = highy - 1; i > lowy; i--) {\n    C += 2 * cy[i + 1];\n    B += C + cy[i];\n    A += B;\n    ans += A * (cy[i - 1] * mul);\n  }\n  printf(\"%.20lf\\n\", ans * .5);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\nint x[100010], y[100010], n, cnt[1000010 << 1];\ndouble ans;\ndouble solve() {\n  double area = 0;\n  x[n] = x[0], y[n] = y[0];\n  memset(cnt, 0, sizeof cnt);\n  for (int i = 0; i < n; ++i)\n    area += (1. * x[i] * y[i + 1]) - (1. * y[i] * x[i + 1]);\n  if (area < 0) {\n    reverse(x, x + n), reverse(y, y + n);\n  }\n  x[n] = x[0], x[n + 1] = x[1];\n  y[n] = y[0], y[n + 1] = y[1];\n  for (int i = 0; i < n; ++i) {\n    if (x[i] < x[i + 1]) {\n      double k = 1. * (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n      for (int j = x[i]; j < x[i + 1]; ++j)\n        cnt[j] -= floor(y[i] + k * (j - x[i]) - 1e-8);\n      if (x[i + 1] >= x[i + 2]) cnt[x[i + 1]] -= y[i + 1] - 1;\n    }\n    if (x[i] > x[i + 1]) {\n      double k = 1. * (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n      for (int j = x[i]; j > x[i + 1]; --j)\n        cnt[j] += floor(y[i] + k * (j - x[i]) + 1e-8);\n      if (x[i + 1] <= x[i + 2]) cnt[x[i + 1]] += y[i + 1];\n    }\n  }\n  double s1 = 0, s2 = 0, s0 = 0;\n  for (int i = 0; i < (1000010 << 1); ++i) {\n    s0 += 1. * cnt[i];\n    s1 += 1. * cnt[i] * i;\n    s2 += 1. * cnt[i] * i * i;\n  }\n  return (2.0 * s0 * s2 - 2.0 * s1 * s1) / s0 / (s0 - 1);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    x[i] += 1000010, y[i] += 1000010;\n  }\n  ans = 0;\n  ans += solve();\n  for (int i = 0; i < n; ++i) swap(x[i], y[i]);\n  ans += solve();\n  printf(\"%.9f\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, x[100020], y[100020], c[2000010], low, high, kol[2000010], j;\ndouble a1, b1, c1, a2, b2, c2, nx2, all, all2, ans, a[2000010][6];\nvoid buildLine(double x1, double y1, double x2, double y2, double& a, double& b,\n               double& c) {\n  a = y2 - y1;\n  b = x1 - x2;\n  c = -a * x1 - b * y1;\n}\nvoid Solve() {\n  for (i = 1; i <= n; i++) {\n    buildLine(x[i], y[i], x[i + 1], y[i + 1], a1, b1, c1);\n    if (x[i] != x[i + 1])\n      for (j = min(x[i], x[i + 1]); j <= max(x[i], x[i + 1]); j++) {\n        buildLine(j, 0, j, 1, a2, b2, c2);\n        nx2 = -(1.0 * a1 * 1.0 * c2 - 1.0 * a2 * c1 * 1.0) /\n              (1.0 * a1 * 1.0 * b2 - 1.0 * a2 * 1.0 * b1);\n        a[j][++c[j]] = nx2;\n      }\n  }\n  for (i = 0; i <= 2000000; i++)\n    if (c[i]) {\n      sort(a[i] + 1, a[i] + c[i] + 1);\n      low = ceil(a[i][1] - 1e-9);\n      high = floor(a[i][c[i]] + 1e-9);\n      kol[i] = high - low + 1;\n      all += kol[i];\n      all2 += kol[i] * 1.0 * i;\n    }\n  for (i = 0; i <= 2000000; i++)\n    if (c[i]) {\n      ans += 1.0 * kol[i] * 1.0 * i * 1.0 * i * (1.0 * all - 1.0 * kol[i]);\n      ans -= 1.0 * kol[i] * 1.0 * i * (all2 - kol[i] * 1.0 * i);\n    }\n}\nint main(int argc, char* const argv[]) {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    x[i] += 1000000;\n    y[i] += 1000000;\n  }\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  Solve();\n  for (i = 1; i <= n + 1; i++) swap(x[i], y[i]);\n  all = all2 = 0;\n  for (i = 0; i <= 2000000; i++) c[i] = kol[i] = 0;\n  Solve();\n  printf(\"%.10lf\\n\", ans / (1.0 * all * (all - 1)));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SIZEN = 200010;\nconst long long INF = 1e10;\nclass Point {\n public:\n  long long x, y;\n};\nvoid print(const Point &p) { cout << \"(\" << p.x << \" \" << p.y << \")\"; }\nlong long cross(const Point &a, const Point &b) {\n  return a.x * b.y - b.x * a.y;\n}\nint N;\nPoint P[SIZEN];\ndouble calc_cut(const Point &a, const Point &b, long long x) {\n  return a.y + (b.y - a.y) * (x - a.x + 0.0) / (b.x - a.x);\n}\ndouble solve(void) {\n  long long L = INF, R = -INF;\n  for (int i = 1; i <= N; i++) {\n    L = min(L, P[i].x);\n    R = max(R, P[i].x);\n  }\n  double S0 = 0, S1 = 0, S2 = 0;\n  int ld = 1;\n  for (int i = 2; i <= N; i++)\n    if (P[i].x < P[ld].x || (P[i].x == P[ld].x && P[i].y < P[ld].y)) ld = i;\n  for (long long x = L; x <= R; x++) {\n    while (P[ld].x < x) ld++;\n    double y;\n    if (P[ld].x == x)\n      y = P[ld].y - 1;\n    else\n      y = ceil(calc_cut(P[ld - 1], P[ld], x)) - 1;\n    S0 -= y;\n    S1 -= y * x;\n    S2 -= y * x * x;\n  }\n  int lu = 1;\n  for (int i = 2; i <= N; i++)\n    if (P[i].x < P[lu].x || (P[i].x == P[lu].x && P[i].y > P[lu].y)) lu = i;\n  lu += N;\n  for (long long x = L; x <= R; x++) {\n    while (P[lu].x < x) lu--;\n    double y;\n    if (P[lu].x == x)\n      y = P[lu].y;\n    else\n      y = floor(calc_cut(P[lu + 1], P[lu], x));\n    S0 += y;\n    S1 += y * x;\n    S2 += y * x * x;\n  }\n  return (S2 * S0 - S1 * S1) / S0 / (S0 - 1);\n}\nvoid init(void) {\n  scanf(\"%d\", &N);\n  long long area = 0;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%I64d%I64d\", &P[i].x, &P[i].y);\n    P[i + N] = P[i];\n  }\n  for (int i = 1; i <= N; i++) area += cross(P[i], P[i + 1]);\n  if (area < 0) reverse(P + 1, P + 1 + 2 * N);\n}\nint main() {\n  init();\n  double ans = 0;\n  ans += solve();\n  for (int i = 1; i <= 2 * N; i++) swap(P[i].x, P[i].y);\n  reverse(P + 1, P + 1 + 2 * N);\n  ans += solve();\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class D {\n\t\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\t\n\tstatic void solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint x[] = new int[n];\n\t\tint y[] = new int[n];\n\t\tlong sumX = 0, sumY = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nextInt();\n\t\t\ty[i] = nextInt();\n\t\t\tsumX += x[i];\n\t\t\tsumY += y[i];\n\t\t}\n\t\tint avgX = (int) (sumX / n);\n\t\tint avgY = (int) (sumY / n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] -= avgX;\n\t\t\ty[i] -= avgY;\n\t\t}\n\t\tdouble ansX = solve(x, y);\n\t\tdouble ansY = solve(y, x);\n\t\tout.printf(Locale.US, \"%.9f\", ansX + ansY);\n\t}\n\t\n\tstatic double solve(int x[], int y[]) {\n//\t\tSystem.err.println(\"SCAN\");\n//\t\tSystem.err.println(\"x = \" + Arrays.toString(x));\n//\t\tSystem.err.println(\"y = \" + Arrays.toString(y));\n\t\tint n = x.length;\n\t\tint minX = Integer.MAX_VALUE;\n\t\tint minXminY = Integer.MAX_VALUE;\n\t\tint minXmaxY = Integer.MIN_VALUE;\n\t\tint maxX = Integer.MIN_VALUE;\n\t\tint maxXminY = Integer.MAX_VALUE;\n\t\tint maxXmaxY = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xi = x[i];\n\t\t\tint yi = y[i];\n\t\t\tif (xi < minX) {\n\t\t\t\tminX = xi;\n\t\t\t\tminXminY = Integer.MAX_VALUE;\n\t\t\t\tminXmaxY = Integer.MIN_VALUE;\n\t\t\t}\n\t\t\tif (xi == minX) {\n\t\t\t\tminXminY = min(minXminY, yi);\n\t\t\t\tminXmaxY = max(minXmaxY, yi);\n\t\t\t}\n\t\t\tif (xi > maxX) {\n\t\t\t\tmaxX = xi;\n\t\t\t\tmaxXminY = Integer.MAX_VALUE;\n\t\t\t\tmaxXmaxY = Integer.MIN_VALUE;\n\t\t\t}\n\t\t\tif (xi == maxX) {\n\t\t\t\tmaxXminY = min(maxXminY, yi);\n\t\t\t\tmaxXmaxY = max(maxXmaxY, yi);\n\t\t\t}\n\t\t}\n//\t\tSystem.err.println(\"Minimum x: \" + minX + \" (\" + minXminY + \" .. \" + minXmaxY + \")\");\n//\t\tSystem.err.println(\"Maximum x: \" + maxX + \" (\" + maxXminY + \" .. \" + maxXmaxY + \")\");\n\t\tint pLeft = -1, pRight = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (x[i] != minX && x[(i + 1) % n] == minX) {\n\t\t\t\tpLeft = i;\n\t\t\t}\n\t\t\tif (x[i] == minX && x[(i + 1) % n] != minX) {\n\t\t\t\tpRight = (i + 1) % n;\n\t\t\t}\n\t\t}\n\t\tif (pLeft < 0 || pRight < 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tboolean orient;\n\t\tif (minXminY == minXmaxY) {\n\t\t\torient = (long) (y[pLeft] - minXminY) * (x[pRight] - minX) <\n\t\t\t\t(long) (y[pRight] - minXminY) * (x[pLeft] - minX);\n\t\t} else {\n\t\t\torient = y[(pLeft + 1) % n] != minXmaxY;\n\t\t}\n\t\tdouble sum1 = 0;\n\t\tdouble sumX = 0;\n\t\tdouble sumX2 = 0;\n\t\tfor (int curX = minX; curX <= maxX; curX++) {\n\t\t\tint minLeft, minRight, maxLeft, maxRight;\n\t\t\tif (orient) {\n\t\t\t\tminLeft = (pLeft + 1) % n;\n\t\t\t\tminRight = pLeft;\n\t\t\t\tmaxLeft = (pRight + n - 1) % n;\n\t\t\t\tmaxRight = pRight;\n\t\t\t} else {\n\t\t\t\tminLeft = (pRight + n - 1) % n;\n\t\t\t\tminRight = pRight;\n\t\t\t\tmaxLeft = (pLeft + 1) % n;\n\t\t\t\tmaxRight = pLeft;\n\t\t\t}\n\t\t\tint minY = pointUp(x[minLeft], y[minLeft], x[minRight], y[minRight], curX);\n\t\t\tint maxY = pointDown(x[maxLeft], y[maxLeft], x[maxRight], y[maxRight], curX);\n//\t\t\tSystem.err.println(\"At x = \" + curX + \": \" + minY + \" .. \" + maxY);\n\t\t\tint cnt = maxY - minY + 1;\n\t\t\tsum1 += cnt;\n\t\t\tsumX += (double) cnt * curX;\n\t\t\tsumX2 += (double) cnt * curX * curX;\n\t\t\twhile (x[pLeft] == curX) {\n\t\t\t\tpLeft = (pLeft + n - 1) % n;\n\t\t\t}\n\t\t\twhile (x[pRight] == curX) {\n\t\t\t\tpRight = (pRight + 1) % n;\n\t\t\t}\n\t\t}\n//\t\tSystem.err.println(\"Total points: \" + sum1);\n//\t\tSystem.err.println(\"Sum X: \" + sumX);\n//\t\tSystem.err.println(\"Sum X^2: \" + sumX2);\n\t\treturn (sumX2 - sumX * sumX / sum1) / (sum1 - 1);\n\t}\n\t\n\tstatic int pointUp(int x1, int y1, int x2, int y2, int x) {\n\t\treturn y1 + divUp((long) (y2 - y1) * (x - x1), x2 - x1);\n\t}\n\t\n\tstatic int divUp(long a, long b) {\n\t\treturn (int) ((a < 0 ? a : a + b - 1) / b);\n\t}\n\n\tstatic int pointDown(int x1, int y1, int x2, int y2, int x) {\n\t\treturn y1 + divDown((long) (y2 - y1) * (x - x1), x2 - x1);\n\t}\n\t\n\tstatic int divDown(long a, long b) {\n\t\treturn (int) ((a < 0 ? a - b + 1 : a) / b);\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn parseInt(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn parseLong(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn parseDouble(next());\n\t}\n\n\tstatic String next() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SIZEN = 200010;\nconst long long INF = 1e10;\nclass Point {\n public:\n  long long x, y;\n};\nvoid print(const Point &p) { cout << \"(\" << p.x << \" \" << p.y << \")\"; }\nlong long cross(const Point &a, const Point &b) {\n  return a.x * b.y - b.x * a.y;\n}\nint N;\nPoint P[SIZEN];\ndouble calc_cut(const Point &a, const Point &b, long long x) {\n  return a.y + (b.y - a.y) * (x - a.x + 0.0) / (b.x - a.x);\n}\ndouble solve(void) {\n  long long L = INF, R = -INF;\n  for (int i = 1; i <= N; i++) {\n    L = min(L, P[i].x);\n    R = max(R, P[i].x);\n  }\n  double S0 = 0, S1 = 0, S2 = 0;\n  int ld = 1;\n  for (int i = 2; i <= N; i++)\n    if (P[i].x < P[ld].x || (P[i].x == P[ld].x && P[i].y < P[ld].y)) ld = i;\n  for (long long x = L; x <= R; x++) {\n    while (P[ld].x < x) ld++;\n    double y;\n    if (P[ld].x == x)\n      y = P[ld].y - 1;\n    else\n      y = ceil(calc_cut(P[ld - 1], P[ld], x)) - 1;\n    S0 -= y;\n    S1 -= y * x;\n    S2 -= y * x * x;\n  }\n  int lu = 1;\n  for (int i = 2; i <= N; i++)\n    if (P[i].x < P[lu].x || (P[i].x == P[lu].x && P[i].y > P[lu].y)) lu = i;\n  lu += N;\n  for (long long x = L; x <= R; x++) {\n    while (P[lu].x < x) lu--;\n    double y;\n    if (P[lu].x == x)\n      y = P[lu].y;\n    else\n      y = floor(calc_cut(P[lu + 1], P[lu], x));\n    S0 += y;\n    S1 += y * x;\n    S2 += y * x * x;\n  }\n  return (S2 * S0 - S1 * S1) / S0 / (S0 - 1);\n}\nvoid init(void) {\n  scanf(\"%d\", &N);\n  long long area = 0;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%I64d%I64d\", &P[i].x, &P[i].y);\n    P[i + N] = P[i];\n  }\n  for (int i = 1; i <= N; i++) area += cross(P[i], P[i + 1]);\n  if (area < 0) reverse(P + 1, P + 1 + 2 * N);\n}\nint main() {\n  init();\n  double ans = 0;\n  ans += solve();\n  for (int i = 1; i <= 2 * N; i++) swap(P[i].x, P[i].y);\n  reverse(P + 1, P + 1 + 2 * N);\n  ans += solve();\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline int add(int a, int b) {\n  if ((a += b) >= mod) a -= mod;\n  return a;\n}\ninline int dec(int a, int b) {\n  if ((a -= b) < 0) a += mod;\n  return a;\n}\ninline int mult(int a, int b) {\n  long long t = 1ll * a * b;\n  if (t >= mod) t %= mod;\n  return t;\n}\ninline int power(int a, int b) {\n  int out = 1;\n  while (b) {\n    if (b & 1) out = mult(out, a);\n    a = mult(a, a);\n    b >>= 1;\n  }\n  return out;\n}\nconst double eps = 1e-8;\nclass Point {\n public:\n  int x, y;\n} d[200005];\nlong double ans, s2, s1, s0;\nint n;\ninline void work() {\n  int t = 1, l = 1, r = n + 1;\n  s2 = s1 = s0 = 0;\n  for (int i = 1; i <= n; i++)\n    if (d[i].x < d[t].x) t = i;\n  for (int i = 1; i < t; i++) d[i + n] = d[i];\n  for (int i = 1; i <= n; i++) d[i] = d[i + t - 1];\n  while (d[l + 1].x == d[1].x) l++;\n  while (d[r - 1].x == d[1].x) r--;\n  l++;\n  r--;\n  d[n + 1] = d[1];\n  for (int x = d[1].x;; x++) {\n    while (d[l].x < x && l <= r) l++;\n    if (l > r) break;\n    while (d[r].x < x) r--;\n    double ly = ((double)d[l].y - d[l - 1].y) / (d[l].x - d[l - 1].x) *\n                    (x - d[l - 1].x) +\n                d[l - 1].y;\n    double ry = ((double)d[r].y - d[r + 1].y) / (d[r].x - d[r + 1].x) *\n                    (x - d[r + 1].x) +\n                d[r + 1].y;\n    if (ly > ry) swap(ly, ry);\n    ans += s2 * (floor(ry + eps) - ceil(ly - eps) + 1);\n    s0 += floor(ry + eps) - ceil(ly - eps) + 1;\n    s1 += s0;\n    s2 += s1 * 2 - s0;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &d[i].x, &d[i].y);\n  work();\n  for (int i = 1; i <= n; i++) d[i].x = -d[i].x;\n  work();\n  for (int i = 1; i <= n; i++) swap(d[i].x, d[i].y);\n  work();\n  for (int i = 1; i <= n; i++) d[i].x = -d[i].x;\n  work();\n  printf(\"%.15Lf\\n\", (ans * 0.5 / (s0 * s0 - s0)));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tFastScanner in;\n\tPrintWriter out;\n\tfinal String fileName = \"D\".toLowerCase();\n\n\tclass Point {\n\t\tint x, y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Point(Point a, Point b) {\n\t\t\tthis.x = b.x - a.x;\n\t\t\tthis.y = b.y - a.y;\n\t\t}\n\n\t\tpublic void transpose() {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\n\t}\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tPoint[] a = new Point[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Point(in.nextInt() + 3000000, in.nextInt() + 3000000);\n\t\t}\n\n\t\tcheckOrder(a);\n\t\tint[] xs = getMinMax(a);\n\t\tint[] getCountX = getCount(xs, a);\n\t\tfor (Point p : a) {\n\t\t\tp.transpose();\n\t\t}\n\t\t\n\t\tcheckOrder(a);\n\t\tint[] ys = getMinMax(a);\n\t\tint[] getCountY = getCount(ys, a);\n\t\t\n\t\t double ans = getAns(getCountX);\n\t\t ans += getAns(getCountY);\n\n\t\t out.println(ans / 2);\n\t}\n\n\tprivate double getAns(int[] a) {\n\t\tdouble all = 0;\n\t\tfor (int i : a) {\n\t\t\tall += i;\n\t\t}\n\t\tdouble weightedSum = 0;\n\t\tdouble sqSum = 0;\n\t\t\n\t\tdouble sq2 = 0;\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tweightedSum += (double) a[i] * i;\n\t\t\tsqSum += (double) i * i * a[i];\n\t\t\tsq2 += (double) i * i * a[i];\n\t\t}\n\t\t\n\t\tdouble ans1 = 0;\n\t\tdouble ans2 = 0;\n\t\t\n\t\tans2 = sqSum / all;\n\t\tans1 = (weightedSum * weightedSum - sq2);\n\t\t\n\t\tdouble ans = 2 * ans2 - ans1 / all / (all - 1) * 2.0;\n\t\treturn ans;\n\t}\n\n\tprivate void checkOrder(Point[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint b = a[i];\n\t\t\tPoint c = a[(i + 1) % n];\n\t\t\tPoint d = a[(i + 2) % n];\n\t\t\tlong v = vectMul(b, c, d);\n\t\t\tif (v == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (v > 0) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treverse(a);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate long vectMul(Point b, Point c, Point d) {\n\t\treturn ((long) c.x - b.x) * ((long) d.y - c.y) - ((long) c.y - b.y)\n\t\t\t\t* ((long) d.x - c.x);\n\t}\n\n\tprivate void reverse(Point[] a) {\n\t\tfor (int i = 0, j = a.length - 1; i < j; i++, j--) {\n\t\t\tPoint tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t}\n\n\t}\n\n\tprivate int[] getCount(int[] xs, Point[] p) {\n\t\tint min = xs[0], max = xs[1];\n\t\tint[] result = new int[max - min + 1];\n\t\tboolean[] wasUp = new boolean[max - min + 1], wasDown = new boolean[max - min + 1];\n\t\tint n = p.length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint a = p[i];\n\t\t\tPoint b = p[(i + 1) % n];\n\t\t\tif (a.x == b.x) {\n\t\t\t\tif (a.y < b.y) {\n\t\t\t\t\tif (!wasDown[a.x - min]) {\n\t\t\t\t\t\tresult[a.x - min] -= a.y - 1;\n\t\t\t\t\t\twasDown[a.x - min] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!wasUp[a.x - min]) {\n\t\t\t\t\t\tresult[a.x - min] += a.y;\n\t\t\t\t\t\twasUp[a.x - min] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (a.x < b.x) {\n\t\t\t\tfor (int j = a.x; j <= b.x; j++) {\n\t\t\t\t\tint y = getDownY(a, b, j);\n\t\t\t\t\tif (!wasDown[j - min]) {\n\t\t\t\t\t\tresult[j - min] -= y;\n\t\t\t\t\t\twasDown[j - min] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (int j = a.x; j >= b.x; j--) {\n\t\t\t\t\tint y = getUpY(a, b, j);\n\t\t\t\t\tif (!wasUp[j - min]) {\n\t\t\t\t\t\tresult[j - min] += y;\n\t\t\t\t\t\twasUp[j - min] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate int getUpY(Point a, Point b, int j) {\n\t\tdouble y = a.y + (j - (double) a.x) * ((double) b.y - a.y)\n\t\t\t\t/ ((double) b.x - a.x);\n\t\tint t = (int) Math.floor(y);\n\t\treturn t;\n\t}\n\n\tprivate int getDownY(Point a, Point b, int j) {\n\t\tdouble y = a.y + (j - (double) a.x) * ((double) b.y - a.y)\n\t\t\t\t/ ((double) b.x - a.x);\n\t\tint t = (int) Math.floor(y);\n\t\tif (Math.abs(t - y) < 1e-10) {\n\t\t\tt--;\n\t\t}\n\t\treturn t;\n\t}\n\n\tprivate int[] getMinMax(Point[] a) {\n\t\tint minX = Integer.MAX_VALUE;\n\t\tint maxX = Integer.MIN_VALUE;\n\n\t\tfor (Point p : a) {\n\t\t\tminX = Math.min(minX, p.x);\n\t\t\tmaxX = Math.max(maxX, p.x);\n\t\t}\n\n\t\treturn new int[] { minX, maxX };\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D().run();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x[2100000], y[2100000], n, Min[2100000], Max[2100000];\nlong long s[2100000];\ndouble ans = 0, p[2100000], sum1[2100000], sum2[2100000];\nvoid solved() {\n  int m = 0;\n  for (int i = 1; i <= n; i++) m = max(m, x[i]);\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  for (int i = 1; i <= m; i++) Min[i] = 1000000000, Max[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    int t1 = x[i], t2 = x[i + 1], t3 = y[i], t4 = y[i + 1];\n    if (t1 > t2) swap(t1, t2), swap(t3, t4);\n    if (t1 == t2) {\n      Min[t1] = min(Min[t1], t3);\n      Max[t1] = max(Max[t1], t3);\n      Min[t1] = min(Min[t1], t4);\n      Max[t1] = max(Max[t1], t4);\n      continue;\n    }\n    for (int j = t1; j <= t2; j++) {\n      double y =\n          (double)(t2 - j) * t3 / (t2 - t1) + (double)(j - t1) * t4 / (t2 - t1);\n      Max[j] = max(Max[j], (int)floor(y + 1e-9));\n      Min[j] = min(Min[j], (int)ceil(y - 1e-9));\n    }\n  }\n  for (int i = 1; i <= m; i++) s[i] = Max[i] - Min[i] + 1 + s[i - 1];\n  for (int i = 1; i <= m; i++) {\n    p[i] = (double)(s[i] - s[i - 1]) / (s[m] - 1);\n    sum1[i] = p[i] * i;\n    sum2[i] = p[i] * i * i;\n    sum1[i] += sum1[i - 1];\n    sum2[i] += sum2[i - 1];\n    p[i] += p[i - 1];\n  }\n  for (int i = 1; i <= m; i++) {\n    double pp = (double)(s[i] - s[i - 1]) / s[m];\n    ans += pp * i * i * (p[i - 1] + p[m] - p[i]) +\n           (sum2[m] - sum2[i] + sum2[i - 1]) * pp -\n           2 * (sum1[m] - sum1[i] + sum1[i - 1]) * i * pp;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  int minx = 1000000000, miny = 1000000000;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    minx = min(minx, x[i]);\n    miny = min(miny, y[i]);\n  }\n  minx--;\n  miny--;\n  for (int i = 1; i <= n; i++) x[i] -= minx, y[i] -= miny;\n  solved();\n  for (int i = 1; i <= n; i++) swap(x[i], y[i]);\n  solved();\n  printf(\"%.8lf\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\npair<int, int> p[300000];\nint freq[2][10 * 300000];\nlong long num = 0;\nvector<int> mx, my;\nvoid update(int p1) {\n  if (mx.empty()) {\n    mx.push_back(p1);\n    my.push_back(p1);\n    return;\n  }\n  if (p[mx[0]].first == p[p1].first) {\n    mx.push_back(p1);\n  } else if (p[mx[0]].first < p[p1].first) {\n    mx.clear();\n    mx.push_back(p1);\n  }\n  if (p[my[0]].second == p[p1].second)\n    my.push_back(p1);\n  else if (p[my[0]].second < p[p1].second) {\n    my.clear();\n    my.push_back(p1);\n  }\n}\ndouble get_y(int first, pair<int, int> p1, pair<int, int> p2) {\n  if (p1.first == p2.first) return p1.second;\n  return 1.0 * (first - p2.first) / (p1.first - p2.first) *\n             (p1.second - p2.second) +\n         p2.second;\n}\ndouble get_x(int second, pair<int, int> p1, pair<int, int> p2) {\n  if (p1.second == p2.second) return p1.first;\n  return 1.0 * (second - p2.second) / (p1.second - p2.second) *\n             (p1.first - p2.first) +\n         p2.first;\n}\nvoid walk_x() {\n  int lo, hi;\n  if (mx.size() == 1) {\n    lo = mx[0];\n    hi = mx[0];\n  } else {\n    lo = mx[0];\n    hi = mx[1];\n    if (lo == 0 && hi == n - 1) swap(lo, hi);\n  }\n  for (int first = p[lo].first;; first--) {\n    if (first < p[lo].first) lo = (lo + n - 1) % n;\n    if (first < p[lo].first) break;\n    if (first < p[hi].first) hi = (hi + 1) % n;\n    if (first < p[hi].first) break;\n    double y1 = get_y(first, p[lo], p[(lo + 1) % n]);\n    double y2 = get_y(first, p[hi], p[(hi + n - 1) % n]);\n    if (y2 < y1) swap(y1, y2);\n    int yy1 = ceil(y1 - 1e-9);\n    int yy2 = floor(y2 + 1e-9);\n    freq[0][first + 1000000] = yy2 - yy1 + 1;\n  }\n}\nvoid walk_y() {\n  int lo, hi;\n  if (my.size() == 1) {\n    lo = my[0];\n    hi = my[0];\n  } else {\n    lo = my[0];\n    hi = my[1];\n    if (lo == 0 && hi == n - 1) swap(lo, hi);\n  }\n  for (int second = p[lo].second;; second--) {\n    if (second < p[lo].second) lo = (lo + n - 1) % n;\n    if (second < p[lo].second) break;\n    if (second < p[hi].second) hi = (hi + 1) % n;\n    if (second < p[hi].second) break;\n    double x1 = get_x(second, p[lo], p[(lo + 1) % n]);\n    double x2 = get_x(second, p[hi], p[(hi + n - 1) % n]);\n    if (x2 < x1) swap(x1, x2);\n    int xx1 = ceil(x1 - 1e-9);\n    int xx2 = floor(x2 + 1e-9);\n    freq[1][second + 1000000] = xx2 - xx1 + 1;\n  }\n}\ndouble get_ans() {\n  double tot = 0;\n  double sum[2] = {0, 0};\n  for (int i = -1000000; i <= 1000000; i++) {\n    num += freq[0][i + 1000000];\n  }\n  for (int i = -1000000; i <= 1000000; i++) {\n    for (int j = 0; j < 2; j++) {\n      tot += 1.0 * freq[j][i + 1000000] * i * i * num;\n      sum[j] += 1.0 * i * freq[j][i + 1000000];\n    }\n  }\n  tot -= sum[0] * sum[0] + sum[1] * sum[1];\n  tot /= num;\n  tot /= num - 1;\n  return tot;\n}\nint main() {\n  memset(freq, 0, sizeof(freq));\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &p[i].first, &p[i].second);\n    update(i);\n  }\n  walk_x();\n  walk_y();\n  printf(\"%.10f\\n\", get_ans());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n  long double x, y;\n  inline Point(long double xx = 0, long double yy = 0) : x(xx), y(yy) {}\n  inline void read() {\n    double x0 = 0, y0 = 0;\n    scanf(\"%lf%lf\", &x0, &y0);\n    x = x0 + 1000000;\n    y = y0 + 1000000;\n  }\n  inline long double operator*(const Point &A) const {\n    return x * A.y - y * A.x;\n  }\n  inline Point operator+(const Point &A) const {\n    return Point(x + A.x, y + A.y);\n  }\n  inline Point operator-(const Point &A) const {\n    return Point(x - A.x, y - A.y);\n  }\n  inline int operator<(const Point &A) const {\n    if (x != A.x) return x < A.x;\n    return y < A.y;\n  }\n} P[100005];\nint dA, dB, A, B, c, vis[100005], n;\nlong double sy, sy2, sx, sx2, num, ans;\ninline int next(int x) {\n  x++;\n  if (x > n) x = 1;\n  return x;\n}\ninline int prev(int x) {\n  --x;\n  if (x < 1) x = n;\n  return x;\n}\ninline long double ask(int A, int B, int x) {\n  if (P[B].x == P[A].x) return P[B].y;\n  long double lamda = (x - P[A].x) / (P[B].x - P[A].x);\n  return lamda * (P[B].y - P[A].y) + P[A].y;\n}\ninline long double ask(long double x) {\n  if (x <= 0) return 0;\n  return x * (x + 1) * (2 * x + 1) / 6.0;\n}\nint Max;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (n); i++) P[i].read();\n  c = 1;\n  for (int i = (2); i <= (n); i++)\n    if (P[i] < P[c]) c = i;\n  for (int i = (1); i <= (n); i++)\n    if (P[i].x > Max) Max = P[i].x;\n  A = next(c);\n  B = prev(c);\n  dA = dB = c;\n  vis[dA] = 1;\n  for (long double Nowx = P[c].x; Nowx <= Max; Nowx++) {\n    long double uy = ask(dA, A, Nowx), dy = ask(dB, B, Nowx);\n    if (uy < dy) swap(uy, dy);\n    long double Uy = floor(uy), Dy = ceil(dy);\n    num += Uy - Dy + 1;\n    sx += Nowx * (Uy - Dy + 1);\n    sx2 += Nowx * Nowx * (Uy - Dy + 1);\n    sy += (Dy + Uy) * (Uy - Dy + 1) / 2.0;\n    sy2 += ask(Uy) - ask(Dy - 1);\n    if (Nowx == P[A].x) {\n      dA = A;\n      vis[dA] = 1;\n      int cho1 = prev(dA), cho2 = next(dA);\n      if (vis[cho1])\n        A = cho2;\n      else\n        A = cho1;\n    }\n    if (Nowx == P[B].x) {\n      dB = B;\n      vis[dB] = 1;\n      int cho1 = prev(dB), cho2 = next(dB);\n      if (vis[cho1])\n        B = cho2;\n      else\n        B = cho1;\n    }\n  }\n  ans += (num)*sx2 - sx * sx;\n  ans += (num)*sy2 - sy * sy;\n  ans /= num;\n  ans /= (num - 1);\n  printf(\"%.12lf\\n\", double(ans));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return floor(Y1 + (1e-8));\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return ceil(Y1 - (1e-8));\n}\nlong double F[10000005];\nlong double Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    for (; A[k + 1].first < i;) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long double Cnt = 0;\n  long double SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    for (; A[k + 1].first > i;) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  for (int i = Q; i >= P; i--)\n    Ans += F[i] * (i - 1000005) * (i - 1000005) / (Cnt - 1);\n  Ans -= SumX * SumX / ((Cnt - 1) * Cnt);\n}\nvoid Work() {\n  long long S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += A[k].first * A[k + 1].second - A[k].second * A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) std::swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong long x[100000];\nlong long y[100000];\nint cntx[3000000];\nlong long sm0[3000000];\ndouble sm1[3000000];\ndouble sm2[3000000];\ndouble ans;\nlong long tot;\nvoid addTop(int i, int i2, bool skipStart) {\n  for (long long cx = x[i] + skipStart; cx <= x[i2]; cx++) {\n    long long cy = (y[i] * (x[i2] - cx) + y[i2] * (cx - x[i])) / (x[i2] - x[i]);\n    cntx[cx] += cy;\n    tot += cy;\n  }\n}\nvoid removeBottom(int i, int i2, bool skipStart) {\n  for (long long cx = x[i] + skipStart; cx <= x[i2]; cx++) {\n    long long cy = (y[i] * (x[i2] - cx) + y[i2] * (cx - x[i])) / (x[i2] - x[i]);\n    if (cy * (x[i2] - x[i]) == (y[i] * (x[i2] - cx) + y[i2] * (cx - x[i])))\n      cy--;\n    cntx[cx] -= cy;\n    tot -= cy;\n  }\n}\nvoid run() {\n  for (int i = 0; i <= 2000005; i++) cntx[i] = 0;\n  tot = 0;\n  int j = 0;\n  while (1) {\n    if (x[(j + 1) % N] < x[j])\n      j = (j + 1) % N;\n    else if (x[(j + N - 1) % N] < x[j])\n      j = (j + N - 1) % N;\n    else\n      break;\n  }\n  if (y[(j + 1) % N] > y[(j + N - 1) % N]) {\n    bool skip = 0;\n    for (int i = j; x[(i + 1) % N] >= x[i]; i = (i + 1) % N)\n      if (x[(i + 1) % N] > x[i]) {\n        addTop(i, (i + 1) % N, skip);\n        skip = 1;\n      }\n    skip = 0;\n    for (int i = j; x[(i + N - 1) % N] >= x[i]; i = (i + N - 1) % N)\n      if (x[(i + N - 1) % N] > x[i]) {\n        removeBottom(i, (i + N - 1) % N, skip);\n        skip = 1;\n      }\n  } else {\n    bool skip = 0;\n    for (int i = j; x[(i + 1) % N] >= x[i]; i = (i + 1) % N)\n      if (x[(i + 1) % N] > x[i]) {\n        removeBottom(i, (i + 1) % N, skip);\n        skip = 1;\n      }\n    skip = 0;\n    for (int i = j; x[(i + N - 1) % N] >= x[i]; i = (i + N - 1) % N)\n      if (x[(i + N - 1) % N] > x[i]) {\n        addTop(i, (i + N - 1) % N, skip);\n        skip = 1;\n      }\n  }\n  for (int i = 1; i <= 2000005; i++) {\n    sm0[i] = sm0[i - 1] + cntx[i];\n    double csm0 = sm0[i - 1] + cntx[i] / 2.0;\n    csm0 /= tot;\n    csm0 /= (tot - 1);\n    sm1[i] = sm1[i - 1] + csm0;\n    sm2[i] = sm2[i - 1] + sm1[i];\n    ans += cntx[i] * sm2[i - 1];\n  }\n}\nint main() {\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += 1000001, y[i] += 1000001;\n  }\n  run();\n  for (int i = 0; i < N; i++) swap(x[i], y[i]);\n  run();\n  cout << setprecision(20) << 2.0 * ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return floor(Y1 + (1e-8));\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return ceil(Y1 - (1e-8));\n}\nlong long F[10000005];\ndouble Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    for (; A[k + 1].first < i;) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long long Cnt = 0;\n  long long SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    for (; A[k + 1].first > i;) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  for (int i = Q; i >= P; i--)\n    Ans += F[i] * (i - 1000005) * (i - 1000005) / ((double)Cnt - 1);\n  Ans -= (double)SumX * SumX / ((double)(Cnt - 1) * Cnt);\n}\nvoid Work() {\n  long long S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += A[k].first * A[k + 1].second - A[k].second * A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) std::swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100000 + 10;\nint n;\nstruct point {\n  int first, second;\n  point(int a, int b) : first(a), second(b) {}\n  point() {}\n} d[MAX];\nlong long chaji(const point& s, const point& a, const point& b) {\n  return (long long)(a.first - s.first) * (b.second - s.second) -\n         (long long)(a.second - s.second) * (b.first - s.first);\n}\nconst int INF = 100000000;\nconst int MAXL = 2000000 + 10;\nconst int DELTA = 1000000;\nint up[MAXL], down[MAXL];\nlong double get(point a, point b, long double s) {\n  long double r = (s - a.first) / (b.first - a.first);\n  return r * (b.second - a.second) + a.second;\n}\nlong double calc() {\n  int i;\n  long double S = 0;\n  for ((i) = (0); (i) != (n); ++(i))\n    S += chaji(point(0, 0), d[i], d[(i + 1) % n]);\n  if (S < 0) reverse(d, d + n);\n  for ((i) = (-DELTA); (i) <= (DELTA); ++(i)) {\n    up[i + DELTA] = -INF;\n    down[i + DELTA] = INF;\n  }\n  for ((i) = (0); (i) != (n); ++(i)) {\n    int j = (i + 1) % n;\n    int k;\n    if (d[i].first < d[j].first)\n      for ((k) = (d[i].first); (k) <= (d[j].first); ++(k)) {\n        int second = ceil(get(d[i], d[j], k));\n        while (chaji(d[i], d[j], point(k, second - 1)) >= 0) --second;\n        down[k + DELTA] = second;\n      }\n    else if (d[i].first > d[j].first)\n      for (k = d[i].first; k >= d[j].first; --k) {\n        int second = floor(get(d[i], d[j], k));\n        while (chaji(d[i], d[j], point(k, second + 1)) >= 0) ++second;\n        up[k + DELTA] = second;\n      }\n    else {\n      int l = d[i].second, r = d[j].second;\n      if (l > r) swap(l, r);\n      up[d[i].first + DELTA] = max(r, up[d[i].first + DELTA]);\n      down[d[i].first + DELTA] = min(l, down[d[i].first + DELTA]);\n    }\n  }\n  long double tot = 0, tot2 = 0, all = 0;\n  for ((i) = (-DELTA); (i) <= (DELTA); ++(i))\n    if (up[i + DELTA] >= down[i + DELTA]) {\n      long double num = up[i + DELTA] - down[i + DELTA] + 1;\n      tot += num * i;\n      tot2 += num * i * i;\n      all += num;\n    }\n  long double ans = 0;\n  long double div = all * (all - 1);\n  for ((i) = (-DELTA); (i) <= (DELTA); ++(i))\n    if (up[i + DELTA] >= down[i + DELTA]) {\n      long double num = up[i + DELTA] - down[i + DELTA] + 1;\n      ans += num * i * i / div * all;\n      ans -= num * 2 * i / div * tot;\n      ans += num / div * tot2;\n    }\n  return ans;\n}\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for ((i) = (0); (i) != (n); ++(i)) scanf(\"%d%d\", &d[i].first, &d[i].second);\n  long double ans = 0;\n  ans = calc();\n  for ((i) = (0); (i) != (n); ++(i)) swap(d[i].first, d[i].second);\n  ans += calc();\n  printf(\"%.15lf\", (double)ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Solution {\n    InputReader reader;\n    PrintWriter writer;\n\n    Solution() {\n        reader = new InputReader();\n        writer = new PrintWriter(System.out);\n    }\n\n    public static void main(String[] args) {\n        new Solution().run();\n    }\n\n    class Point implements Comparable <Point> {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        Point flip() {\n            return new Point(y, x);\n        }\n\n        public int compareTo(Point o) {\n            if (x != o.x) {\n                return x - o.x;\n            }\n            return y - o.y;\n        }\n\n        Point subtract(Point o) {\n            return new Point(x - o.x, y - o.y);\n        }\n    }\n\n    long det(Point a, Point b) {\n        return (long)a.x * b.y - (long)a.y * b.x;\n    }\n\n    final static int OFFSET = 1; //(int)1e6;\n\n    boolean isConvex(Point a, Point b, Point c) {\n        return det(b.subtract(a), c.subtract(b)) >= 0;\n    }\n\n    Point[] getConvex(Point[] points) {\n        ArrayList <Point> hull = new ArrayList <Point>();\n        for (Point p : points) {\n            while (hull.size() >= 2 && !isConvex(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p)) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        while (hull.size() >= 2 && hull.get(hull.size() - 1).x == hull.get(hull.size() - 2).x) {\n            hull.remove(hull.size() - 1);\n        }\n        return hull.toArray(new Point[0]);\n    }\n\n    Point[] reverse(Point[] points) {\n        int n = points.length;\n        Point[] ret = new Point[n];\n        for (int i = 0; i < n; ++ i) {\n            ret[i] = points[n - 1 - i];\n        }\n        return ret;\n    }\n\n    double solve(Point[] points) {\n        int n = points.length;\n        Arrays.sort(points);\n        Point[] down = getConvex(points);\n        Point[] up = reverse(getConvex(reverse(points)));\n        int xMin = down[0].x;\n        int xMax = down[down.length - 1].x;\n        long total = 0;\n        double sum = 0.0;\n        double squareSum = 0.0;\n        for (int x = xMin, i = 0, j = 0; x <= xMax; ++ x) {\n            while (i + 1 < down.length && down[i + 1].x < x) {\n                i ++;\n            }\n            while (j + 1 < up.length && up[j + 1].x < x) {\n                j ++;\n            }\n            int yMin = (int)Math.ceil((double)(x - down[i].x) / (down[i + 1].x - down[i].x) * (down[i + 1].y - down[i].y)) + down[i].y;\n            int yMax = (int)Math.floor((double)(x - up[j].x) / (up[j + 1].x - up[j].x) * (up[j + 1].y - up[j].y)) + up[j].y;\n            int count = yMax - yMin + 1;\n            total += count;\n            sum += (double)count * x;\n            squareSum += (double)count * x * x;\n        }\n        return (total * squareSum - sum * sum) / ((double)total * (total - 1));\n    }\n\n    public void run() {\n        try {\n            int n = reader.nextInt();\n            Point[] points = new Point[n];\n            for (int i = 0; i < n; ++ i) {\n                int x = reader.nextInt();\n                int y = reader.nextInt();\n                points[i] = new Point(x + OFFSET, y + OFFSET);\n            }\n            double answer = solve(points);\n            for (int i = 0; i < n; ++ i) {\n                points[i] = points[i].flip();\n            }\n            answer += solve(points);\n            writer.println(String.format(\"%.8f\", answer));\n        } catch (IOException ex) {\n        }\n        writer.close();\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    InputReader() {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    Integer nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble calc(vector<int> &v) {\n  int n = (int((v).size()));\n  long double ret = 0.0;\n  long double a = 0;\n  long double b = 0;\n  long double c = 0;\n  c = v[0];\n  for (int i = (int)(1), _n = (int)(n); i < _n; i++) {\n    b += 2 * c - v[i - 1];\n    a += b;\n    ret += v[i] * (long double)a;\n    c += v[i];\n  }\n  return 2 * ret / (c * (long double)(c - 1));\n}\ndouble solve(vector<pair<int, int> > p) {\n  rotate(p.begin(), min_element((p).begin(), (p).end()), p.end());\n  p.push_back(p[0]);\n  int maxind = max_element((p).begin(), (p).end()) - p.begin(), cur = 0;\n  int minx = p[0].first, maxx = p[maxind].first;\n  vector<int> v(maxx - minx + 1);\n  for (int x = minx, i = 0; x <= maxx; x++, i++) {\n    if (p[cur + 1].first > p[cur].first && x == p[cur + 1].first) cur++;\n    if (x == p[cur].first)\n      v[i] = -p[cur].second;\n    else {\n      int ydiff = (p[cur + 1].second - p[cur].second) *\n                  (long long)(x - p[cur].first) /\n                  (p[cur + 1].first - p[cur].first);\n      if ((p[cur + 1].first - p[cur].first) * (long long)ydiff <\n          (p[cur + 1].second - p[cur].second) * (long long)(x - p[cur].first))\n        ydiff++;\n      v[i] = -(p[cur].second + ydiff);\n    }\n  }\n  cur = maxind;\n  for (int x = maxx, i = maxx - minx; x >= minx; x--, i--) {\n    if (p[cur + 1].first < p[cur].first && x == p[cur + 1].first) cur++;\n    if (x == p[cur].first)\n      v[i] += p[cur].second + 1;\n    else {\n      int ydiff = (p[cur + 1].second - p[cur].second) *\n                  (long long)(p[cur].first - x) /\n                  (p[cur].first - p[cur + 1].first);\n      if ((p[cur].first - p[cur + 1].first) * (long long)ydiff >\n          (p[cur + 1].second - p[cur].second) * (long long)(p[cur].first - x))\n        ydiff--;\n      v[i] += p[cur].second + ydiff + 1;\n    }\n  }\n  return calc(v);\n}\ninline long long cross(pair<int, int> p, pair<int, int> q1, pair<int, int> q2) {\n  return (q1.first - p.first) * (long long)(q2.second - p.second) -\n         (q1.second - p.second) * (long long)(q2.first - p.first);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  bool cc = false;\n  cin >> n;\n  vector<pair<int, int> > p(n);\n  for (int i = 0, _n = (int)(n); i < _n; i++) {\n    cin >> p[i].first >> p[i].second;\n    if (i >= 2)\n      if (cross(p[i - 2], p[i - 1], p[i]) < 0) cc = true;\n  }\n  if (cc) reverse((p).begin(), (p).end());\n  double ans1 = solve(p);\n  for (int i = 0, _n = (int)(n); i < _n; i++) swap(p[i].first, p[i].second);\n  reverse((p).begin(), (p).end());\n  double ans2 = solve(p);\n  cout << fixed << setprecision(9) << (ans1 + ans2) / 2 << endl;\n  {\n    int _;\n    cin >> _;\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  int x, y;\n  void scan() { scanf(\"%d%d\", &x, &y); }\n} x[110000];\nint n, L, R, U, D;\nlong double num[2100000];\nlong double *A;\nlong double get(point k1, point k2, int k3) {\n  if (k1.x == k2.x) return k2.y;\n  return (long double)(k3 - k1.x) / (long double)(k2.x - k1.x) * (k2.y - k1.y) +\n         k1.y;\n}\nint pre(int k) { return (k - 2 + n) % n + 1; }\nint next(int k) { return k % n + 1; }\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) x[i].scan();\n  A = num + 1005000;\n  L = 1e7;\n  R = -1e7;\n  for (int i = 1; i <= n; i++) {\n    L = min(L, x[i].x);\n    R = max(R, x[i].x);\n  }\n  int l, r;\n  for (int i = 1; i <= n; i++)\n    if (x[i].x == L) {\n      l = i;\n      r = i;\n      break;\n    }\n  for (int i = L; i <= R; i++) {\n    while (x[l].x <= i && x[l].x != R) l = pre(l);\n    while (x[r].x <= i && x[r].x != R) r = next(r);\n    long double k3 = get(x[l], x[next(l)], i), k4 = get(x[r], x[pre(r)], i);\n    if (k3 > k4) swap(k3, k4);\n    int k1 = floor(k3 - 1e-7) + 1, k2 = floor(k4 + 1e-7);\n    A[i] = k2 - k1 + 1;\n  }\n  long double ans = 0, tot = 0, sum = 0;\n  for (int i = L; i <= R; i++) {\n    tot += A[i];\n    sum += A[i] * i;\n  }\n  for (int i = L; i <= R; i++) {\n    ans += -sum * 2 * A[i] * i + A[i] * (A[i] + 1) * (long double)i * i +\n           (long double)i * i * A[i] * (tot - 1);\n    sum -= A[i] * i;\n  }\n  memset(num, 0x00, sizeof num);\n  for (int i = 1; i <= n; i++) swap(x[i].x, x[i].y);\n  L = 1e7;\n  R = -1e7;\n  for (int i = 1; i <= n; i++) {\n    L = min(L, x[i].x);\n    R = max(R, x[i].x);\n  }\n  for (int i = 1; i <= n; i++)\n    if (x[i].x == L) {\n      l = i;\n      r = i;\n      break;\n    }\n  for (int i = L; i <= R; i++) {\n    while (x[l].x <= i && x[l].x != R) l = pre(l);\n    while (x[r].x <= i && x[r].x != R) r = next(r);\n    long double k3 = get(x[l], x[next(l)], i), k4 = get(x[r], x[pre(r)], i);\n    if (k3 > k4) swap(k3, k4);\n    int k1 = floor(k3 - 1e-7) + 1, k2 = floor(k4 + 1e-7);\n    A[i] = k2 - k1 + 1;\n  }\n  tot = 0, sum = 0;\n  for (int i = L; i <= R; i++) {\n    tot += A[i];\n    sum += A[i] * i;\n  }\n  for (int i = L; i <= R; i++) {\n    ans += -sum * 2 * A[i] * i + A[i] * (A[i] + 1) * (long double)i * i +\n           (long double)i * i * A[i] * (tot - 1);\n    sum -= A[i] * i;\n  }\n  printf(\"%.11lf\\n\", (double)(ans / tot / (tot - 1)));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double eps = 1E-8;\nstruct node {\n  long double x, s, t;\n} a[2000010];\nint xi[2000010], yi[2000010];\nlong double li[2000010], ri[2000010], ans, s, t;\nint n, m;\nvoid work(int x0, int y0, int x1, int y1) {\n  if (x0 > x1) swap(x0, x1), swap(y0, y1);\n  if (x0 == x1) {\n    li[x0] = min(li[x0], (long double)min(y0, y1)),\n    ri[x0] = max(ri[x0], (long double)max(y0, y1));\n    return;\n  }\n  for (int i = x0; i <= x1; i++) {\n    long double k = 1. * (y1 - y0) * (i - x0) / (x1 - x0) + y0;\n    li[i] = min(li[i], k), ri[i] = max(ri[i], k);\n  }\n}\nvoid solve(void) {\n  for (int i = 0; i < 2000010; i++) ri[i] = 0, li[i] = 2000010;\n  for (int i = 1; i <= n; i++) work(xi[i], yi[i], xi[i + 1], yi[i + 1]);\n  m = 0;\n  for (int i = 0; i < 2000010; i++)\n    if (li[i] < 2000010) {\n      int A = int(li[i] - eps) + 1, B = int(ri[i] + eps);\n      m++, a[m].x = i, a[m].s = B - A + 1;\n      a[m].t = a[m].x * a[m].s;\n    }\n  s = t = 0;\n  for (int i = 1; i <= m; i++) s += a[i].s, t += a[i].t;\n  for (int i = 1; i <= m; i++)\n    ans += a[i].t * a[i].x * (s - a[i].s) - (a[i].t * (t - a[i].t));\n}\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d%d\", xi + i, yi + i), xi[i] += 2000010 >> 1, yi[i] += 2000010 >> 1;\n  xi[n + 1] = xi[1], yi[n + 1] = yi[1], solve();\n  for (int i = 1; i <= n + 1; i++) swap(xi[i], yi[i]);\n  solve();\n  ans /= s * (s - 1), printf(\"%.10lf\\n\", (double)ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxXL = 1000000;\nconst int MaxN = 100000;\ninline long long floor(long long a, long long b) {\n  if (b < 0) a = -a, b = -b;\n  if (a > 0) return a / b;\n  return -((-a + b - 1) / b);\n}\ninline long long ceil(long long a, long long b) { return -floor(-a, b); }\ndouble calc(int n, int *px, int *py) {\n  long long area = 0;\n  for (int i = 0; i < n; i++)\n    area += (long long)px[i] * py[i + 1] - (long long)py[i] * px[i + 1];\n  if (area < 0) reverse(px + 1, px + n), reverse(py + 1, py + n);\n  static int h[MaxXL * 2 + 1];\n  fill(h, h + MaxXL * 2 + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if (px[i] < px[i + 1]) {\n      for (int x = px[i]; x < px[i + 1]; x++)\n        h[x + MaxXL] -= py[i] +\n                        ceil((long long)(py[i + 1] - py[i]) * (x - px[i]),\n                             px[i + 1] - px[i]) -\n                        1;\n      if (px[i + 1] >= px[(i + 2) % n]) h[px[i + 1] + MaxXL] -= py[i + 1] - 1;\n    } else if (px[i] > px[i + 1]) {\n      for (int x = px[i]; x > px[i + 1]; x--)\n        h[x + MaxXL] +=\n            py[i] + floor((long long)(py[i + 1] - py[i]) * (x - px[i]),\n                          px[i + 1] - px[i]);\n      if (px[i + 1] <= px[(i + 2) % n]) h[px[i + 1] + MaxXL] += py[i + 1];\n    }\n  }\n  long long cnt = 0;\n  double sum1 = 0;\n  double sum2 = 0;\n  for (int x = -MaxXL; x <= MaxXL; x++) {\n    cnt += h[x + MaxXL];\n    sum1 += (double)x * h[x + MaxXL];\n    sum2 += (double)x * x * h[x + MaxXL];\n  }\n  sum1 /= cnt;\n  sum2 /= cnt;\n  return (sum2 - sum1 * sum1) * cnt / (cnt - 1);\n}\nint main() {\n  int n;\n  static int px[MaxN + 1], py[MaxN + 1];\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%d %d\", &px[i], &py[i]);\n  px[n] = px[0], py[n] = py[0];\n  double res = 0;\n  res += calc(n, px, py);\n  res += calc(n, py, px);\n  printf(\"%.8f\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return floor(Y1 + (1e-8));\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) *\n                                (A[Y].second - A[X].second) /\n                                (double)(A[Y].first - A[X].first);\n  return ceil(Y1 - (1e-8));\n}\nlong double F[10000005];\nlong double Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    if (A[k + 1].first < i) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long double Cnt = 0;\n  long double SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    if (A[k + 1].first > i) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  for (int i = Q; i >= P; i--)\n    Ans += F[i] * (i - 1000005) * (i - 1000005) / (Cnt - 1);\n  Ans -= SumX * SumX / ((Cnt - 1) * Cnt);\n}\nvoid Work() {\n  long long S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += A[k].first * A[k + 1].second - A[k].second * A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000005;\nconst double eps = 1e-6;\nstruct _two {\n  int a, b;\n} a[N];\nint n;\nint num[N];\ndouble Min[N], Max[N], sum[N], sum1[N];\ndouble ans, s;\nvoid Work(_two x, _two y) {\n  if (x.a > y.a) swap(x, y);\n  if (x.a == y.a) return;\n  double t = (y.b - x.b) / (0. + y.a - x.a), cur = x.b;\n  for (int i = x.a; i <= y.a; i++) {\n    Min[i] = min(Min[i], cur);\n    Max[i] = max(Max[i], cur);\n    cur += t;\n  }\n}\nvoid Calc() {\n  a[0] = a[n];\n  for (int i = 0; i <= N - 1; i++) Min[i] = N, Max[i] = 0;\n  for (int i = 1; i <= n; i++) Work(a[i - 1], a[i]);\n  memset(num, 0, sizeof(num));\n  s = 0;\n  for (int i = 0; i <= N - 1; i++)\n    if (Min[i] < Max[i] + eps) {\n      int L = (int)(Min[i] - eps) + 1, R = (int)(Max[i] + eps);\n      s += num[i] = R - L + 1;\n    }\n  sum[0] = sum1[0] = 0;\n  for (int i = 1; i <= N - 1; i++) sum[i] = sum[i - 1] + num[i];\n  for (int i = 1; i <= N - 1; i++) sum1[i] = sum1[i - 1] + sum[i] + sum[i - 1];\n  double cur = 0;\n  for (int i = 1; i <= N - 1; i++) {\n    ans += num[i] * cur;\n    cur += sum1[i];\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &a[i].a, &a[i].b);\n    a[i].a += N / 2;\n    a[i].b += N / 2;\n  }\n  Calc();\n  for (int i = 1; i <= n; i++) swap(a[i].a, a[i].b);\n  Calc();\n  printf(\"%.7lf\\n\", ans / (s * (s - 1)));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, up[3000005], low[3000005], cnt[3000005];\ndouble ans;\nstruct point {\n  int x, y;\n} P[101000];\ndouble tot;\ndouble solve() {\n  double area = 0;\n  tot = 0;\n  for (int i = 0; i < n; i++)\n    area += P[i].x * P[(i + 1) % n].y - P[i].y * P[(i + 1) % n].x;\n  if (area < 0) reverse(P, P + n);\n  P[n] = P[0];\n  int mx = 0;\n  for (int i = 0; i < n; i++) mx = max(P[i].x, mx);\n  for (int i = 0; i < n; i++) {\n    long long x1 = P[i].x, x2 = P[i + 1].x, y1 = P[i].y, y2 = P[i + 1].y;\n    if (x1 < x2) {\n      for (int j = x1; j <= x2; j++)\n        low[j] =\n            (y1 * (x2 - x1) + ((y2 - y1) * (j - x1) + x2 - x1 - 1)) / (x2 - x1);\n    } else if (P[i].x > P[i + 1].x) {\n      for (int j = P[i + 1].x; j <= P[i].x; j++)\n        up[j] = (y2 * (x1 - x2) + (y1 - y2) * (j - x2)) / (x1 - x2);\n    }\n  }\n  for (int i = 0; i <= mx; i++) {\n    cnt[i] = up[i] - low[i] + 1;\n    tot += cnt[i];\n  }\n  double ans1 = 0, ans2 = 0;\n  for (int i = 0; i <= mx; i++) {\n    ans1 += (double)cnt[i] * i * i;\n    ans2 += (double)cnt[i] * i;\n  }\n  return (ans1 * tot - ans2 * ans2);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &P[i].x, &P[i].y);\n  int id = P[0].x;\n  for (int i = 0; i < n; i++)\n    if (P[i].x < id) id = P[i].x;\n  for (int i = 0; i < n; i++) P[i].x -= id;\n  id = P[0].y;\n  for (int i = 0; i < n; i++)\n    if (P[i].y < id) id = P[i].y;\n  for (int i = 0; i < n; i++) P[i].y -= id;\n  ans += solve();\n  for (int i = 0; i <= n; i++) swap(P[i].x, P[i].y);\n  ans += solve();\n  printf(\"%.10f\\n\", ans / tot / (tot - 1));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dcmp(long double p) {\n  if (abs(p) < 1e-13) return 0;\n  return p > 1e-13 ? 1 : -1;\n}\nvector<long double> L[2000010];\nint n;\nvoid read() {\n  scanf(\"%d\", &n);\n  static long long x[100010], y[100010];\n  for (int i = 1; i <= n; ++i) {\n    cin >> x[i] >> y[i];\n    x[i] += 1000001, y[i] += 1000001;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (x[i] == x[i % n + 1])\n      L[x[i]].push_back(y[i]), L[x[i]].push_back(y[i % n + 1]);\n    else {\n      long double k = 1.0 * (y[i % n + 1] - y[i]) / (x[i % n + 1] - x[i]),\n                  b = y[i] - x[i] * k;\n      for (int j = min(x[i], x[i % n + 1]); j <= max(x[i], x[i % n + 1]); ++j) {\n        long double vy = k * j + b;\n        if (dcmp(k) >= 0)\n          L[j].push_back(vy);\n        else\n          L[j].push_back(vy);\n      }\n    }\n  }\n}\nlong long sum2(int n) {\n  long long a = n, b = n + 1, c = 2 * n + 1;\n  if (a % 2 == 0)\n    a /= 2;\n  else\n    b /= 2;\n  if (a % 3 == 0)\n    a /= 3;\n  else if (b % 3 == 0)\n    b /= 3;\n  else\n    c /= 3;\n  return a * b * c;\n}\nlong double work() {\n  long long total = 0;\n  for (int i = 1; i <= 2000005; ++i)\n    if (L[i].size() > 1u) {\n      sort(L[i].begin(), L[i].end());\n      L[i].resize(unique(L[i].begin(), L[i].end()) - L[i].begin());\n      if (L[i].size() > 1u) {\n        long long l = ceil(L[i][0] - 1e-13),\n                  r = floor(L[i][L[i].size() - 1u] + 1e-13);\n        total += r - l + 1;\n      } else if (L[i].size())\n        ++total;\n    }\n  long double sumx1 = 0, sumy1 = 0, sumx2 = 0, sumy2 = 0, v = 1.0 / total;\n  for (int i = 1; i <= 2000005; ++i) {\n    if (L[i].size() > 1u) {\n      long long l = ceil(L[i][0] - 1e-13),\n                r = floor(L[i][L[i].size() - 1u] + 1e-13);\n      sumx1 += v * (r - l + 1) * i, sumx2 += v * (r - l + 1) * i * i;\n      sumy1 += v * (l + r) * (r - l + 1) / 2,\n          sumy2 += v * (sum2(r) - sum2(l - 1));\n    } else if (L[i].size() == 1u) {\n      long long y = floor(L[i][0] + 1e-13);\n      sumx1 += v * i, sumx2 += v * i * i;\n      sumy1 += v * y, sumy2 += v * y * y;\n    }\n  }\n  return (sumx2 + sumy2 - sumx1 * sumx1 - sumy1 * sumy1) / v / (total - 1);\n}\nint main() {\n  read();\n  printf(\"%.10f\\n\", (double)work());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nstruct pt {\n  int x, y;\n  pt(int xx = 0, int yy = 0) : x(xx), y(yy) {}\n};\npt operator-(pt a, pt b) { return pt(a.x - b.x, a.y - b.y); }\nbool operator<(const pt &a, const pt &b) {\n  return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\nlong long cross(pt a, pt b) { return (a.x + 0ll) * b.y - (a.y + 0ll) * b.x; }\nint sta[maxn << 1], top;\npt p[maxn];\nvoid convex(int n) {\n  top = 0;\n  sort(p + 1, p + 1 + n);\n  int i, j;\n  for (i = 1; i <= n; i++) {\n    while (top >= 2 &&\n           cross(p[i] - p[sta[top]], p[sta[top]] - p[sta[top - 1]]) >= 0)\n      top--;\n    sta[++top] = i;\n  }\n  j = top;\n  for (i = n - 1; i >= 1; i--) {\n    while (top > j &&\n           cross(p[i] - p[sta[top]], p[sta[top]] - p[sta[top - 1]]) >= 0)\n      top--;\n    sta[++top] = i;\n  }\n  top--;\n}\ndouble ans = 0;\nint shang[2000010], xia[2000010];\ndouble solve(int n) {\n  convex(n);\n  int s, x, i, j;\n  int mi = 210000000, ma = 0;\n  for (i = 1; i <= top; i++) {\n    if (p[sta[i]].x == p[sta[i + 1]].x) {\n      s = max(p[sta[i]].y, p[sta[i + 1]].y);\n      x = min(p[sta[i]].y, p[sta[i + 1]].y);\n      shang[p[sta[i]].x] = s;\n      xia[p[sta[i]].x] = x;\n    } else if (p[sta[i]].x < p[sta[i + 1]].x) {\n      j = p[sta[i]].x;\n      x = p[sta[i]].y;\n      do {\n        xia[j] = x;\n        j++;\n        while (cross(pt(j, x) - p[sta[i]], p[sta[i + 1]] - p[sta[i]]) > 0) x++;\n        while (cross(pt(j, x - 1) - p[sta[i]], p[sta[i + 1]] - p[sta[i]]) <= 0)\n          x--;\n      } while (j <= p[sta[i + 1]].x);\n    } else {\n      j = p[sta[i]].x;\n      x = p[sta[i]].y;\n      do {\n        shang[j] = x;\n        j--;\n        while (cross(pt(j, x) - p[sta[i]], p[sta[i + 1]] - p[sta[i]]) > 0) x--;\n        while (cross(pt(j, x + 1) - p[sta[i]], p[sta[i + 1]] - p[sta[i]]) <= 0)\n          x++;\n      } while (j >= p[sta[i + 1]].x);\n    }\n    mi = min(mi, p[sta[i]].x);\n    ma = max(ma, p[sta[i]].x);\n  }\n  long long tot = 0, ss = 0, tmp;\n  for (i = mi; i <= ma; i++)\n    tot += shang[i] - xia[i] + 1, ss += (shang[i] - xia[i] + 1ll) * i;\n  for (i = mi; i <= ma; i++) {\n    ans += (shang[i] - xia[i] + 1ll) * i / (tot - 1.0) *\n           ((tot * i - ss) / (tot + 0.0));\n  }\n  return ans;\n}\nint main() {\n  int n;\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++)\n    scanf(\"%d%d\", &p[i].x, &p[i].y), p[i].x += 1000000, p[i].y += 1000000;\n  solve(n);\n  for (i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  solve(n);\n  printf(\"%.12lf\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    static long count;\n\n    static void doCount(Point2DInteger[] p) {\n        count = 0;\n        long area = 0;\n        for (int i = 0; i < p.length; i++) {\n            int j = i + 1;\n            if (j == p.length) j = 0;\n            int dx = Math.abs(p[i].x - p[j].x);\n            int dy = Math.abs(p[i].y - p[j].y);\n            area += p[i].vmul(p[j]);\n            count += MathUtils.gcd(dx, dy);\n        }\n        area = Math.abs(area);\n        count = (area - count + 2) / 2 + count;\n    }\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        Point2DInteger[] p = new Point2DInteger[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = new Point2DInteger(in.nextInt(), in.nextInt());\n        }\n        doCount(p);\n        double ans = solve(p.clone());\n        for (int i = 0; i < n; i++) {\n            p[i] = new Point2DInteger(p[i].y, p[i].x);\n        }\n        ans += solve(p.clone());\n        out.println(1. * ans / count / (count - 1));\n    }\n\n    static double solve(Point2DInteger[] p) {\n        long area = 0;\n        int n = p.length;\n        for (int i = 0; i < n; i++) {\n            area += p[i].vmul(p[(i + 1) % n]);\n        }\n        if (area < 0) {\n            for (int i = 1, j = n - 1; i < j; i++, j--) {\n                Point2DInteger t = p[i];\n                p[i] = p[j];\n                p[j] = t;\n            }\n        }\n        int left = -1;\n        int right = -1;\n        for (int i = 0; i < n; i++) {\n            if (left < 0 || p[i].x < p[left].x) {\n                left = i;\n            }\n            if (right < 0 || p[i].x > p[right].x) {\n                right = i;\n            }\n        }\n        int cntDown = 1;\n        int cntUp = 1;\n        for (int i = left; i != right; i = (i + 1) % n) {\n            cntDown++;\n        }\n        for (int i = right; i != left; i = (i + 1) % n) {\n            cntUp++;\n        }\n        Point2DInteger[] down = new Point2DInteger[cntDown];\n        Point2DInteger[] up = new Point2DInteger[cntUp];\n        for (int i = left, j = 0; ; i = (i + 1) % n, j++) {\n            down[j] = p[i];\n            if (i == right) break;\n        }\n        for (int i = left, j = 0; ; i = (i + n - 1) % n, j++) {\n            up[j] = p[i];\n            if (i == right) break;\n        }\n        int d1 = 0;\n        int d2 = 0;\n        double sumxi = 0;\n        double ret = 0;\n        for (int x = p[left].x; x < p[right].x; x++) {\n            while (d1 + 1 < up.length && up[d1 + 1].x <= x) {\n                ++d1;\n            }\n            while (d2 + 1 < down.length && down[d2 + 1].x <= x) {\n                ++d2;\n            }\n            long y1, y2;\n            {\n                long den2 = (down[d2 + 1].x - down[d2].x);\n                long num2 = (long) (x - down[d2].x) * (down[d2 + 1].y - down[d2].y);\n                long z = num2 / den2;\n                while (den2 * z > num2) --z;\n                while (den2 * z < num2) ++z;\n                y2 = z + down[d2].y;\n            }\n            {\n                long den1 = (up[d1 + 1].x - up[d1].x);\n                long num1 = (long) (x - up[d1].x) * (up[d1 + 1].y - up[d1].y);\n                long z = num1 / den1;\n                while (den1 * z < num1) ++z;\n                while (den1 * z > num1) --z;\n                y1 = z + up[d1].y;\n            }\n            if (y1 < y2) {\n                continue;\n            }\n            long curCount = y1 - y2 + 1;\n            ret += 1. * (count - curCount) * (curCount) * x * x;\n            ret -= 2. * sumxi * curCount * x;\n            sumxi += 1. * curCount * x;\n        }\n        {\n            long y1 = Long.MIN_VALUE;\n            long y2 = Long.MAX_VALUE;\n            for (Point2DInteger e : p) {\n                if (e.x == p[right].x) {\n                    if (y1 < e.y) y1 = e.y;\n                    if (y2 > e.y) y2 = e.y;\n                }\n            }\n            long curCount = y1 - y2 + 1;\n            int x = p[right].x;\n            ret += 1. * (count - curCount) * (curCount) * x * x;\n            ret -= 2. * sumxi * curCount * x;\n            sumxi += 1. * curCount * x;\n        }\n        return ret;\n    }\n}\n\nclass Point2DInteger {\n    public int x;\n    public int y;\n\n    public Point2DInteger(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public long vmul(Point2DInteger p) {\n        return (long) x * p.y - (long) y * p.x;\n    }\n\n    public String toString() {\n        return \"{\" +\n                \"x=\" + x +\n                \", y=\" + y +\n                '}';\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Point2DInteger that = (Point2DInteger) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result = x;\n        result = 31 * result + y;\n        return result;\n    }\n\n\n    }\n\nclass MathUtils {\n\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n\n\n    }\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (c >= 0 && !isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author sheep\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    private double go(Point points[]) {\n        int n = points.length;\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        int at = 0;\n        for (int i = 0; i < points.length; ++i) {\n            if (points[i].x < min) {\n                at = i;\n                min = (int)points[i].x;\n            }\n\n            max = Math.max((int)points[i].x, max);\n        }\n\n        int next = at;\n        int prev = at;\n\n        int low, high;\n        low = high = 0;\n\n        int numPoints[] = new int[max - min + 1];\n        for (int i = min; i <= max; ++i) {\n            while (points[(next + 1) % n].x >= points[next].x && points[(next + 1) % n].x <= i) {\n                next = (next + 1) % n;\n            }\n\n            while (points[(prev + n - 1) % n].x >= points[prev].x && points[(prev + n - 1) % n].x <= i) {\n                prev = (prev + n - 1) % n;\n            }\n\n            if (points[next].x == i) low = (int)points[next].y;\n            else {\n                while (points[(next + 1) % n].subtract(points[next]).det(new Point(i, low).subtract(points[next])) < 0) {\n                    ++low;\n                }\n                while (points[(next + 1) % n].subtract(points[next]).det(new Point(i, low - 1).subtract(points[next])) >= 0) {\n                    --low;\n                }\n            }\n            if (points[prev].x == i) high = (int)points[prev].y;\n            else {\n                while (points[(prev + n - 1) % n].subtract(points[prev]).det(new Point(i, high).subtract(points[prev])) > 0) {\n                    --high;\n                }\n\n                while (points[(prev + n - 1) % n].subtract(points[prev]).det(new Point(i, high + 1).subtract(points[prev])) <= 0) {\n                    ++high;\n                }\n            }\n\n            int num = 0;\n            if (points[next].x == i && points[prev].x == i) {\n                num = (int)Math.abs(points[next].y - points[prev].y) + 1;\n            } else {\n                if (low <= high) {\n                    num = high - low + 1;\n                }\n            }\n\n            numPoints[i - min] = num;\n        }\n\n        double sumPoints = 0;\n        double sumCord = 0;\n        for (int i = min; i <= max; ++i) {\n            sumPoints += numPoints[i - min];\n            sumCord += i * (double)numPoints[i - min];\n        }\n\n        double res = 0;\n        double choose2 = sumPoints * (sumPoints - 1) * 0.5;\n        for (int i = min; i <= max; ++i) {\n            int num = numPoints[i - min];\n            res += i * (double)i * 2 / sumPoints * num;\n            res -= (sumCord - i) * i / choose2 * num;\n        }\n\n        //System.out.println(\"sumPoints = \" + sumPoints + \" res = \" + res);\n\n        return res;\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        Point points[] = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            points[i] = new Point(in.nextInt(), in.nextInt());\n        }\n\n        if (poly_area(points) < 0) {\n            for (int i = 0; n - 1 - i > i; ++i) {\n                Point tmp = points[i];\n                points[i] = points[n - 1 - i];\n                points[n - 1 - i] = tmp;\n            }\n        }\n\n        double ans = go(points);\n        for (Point o : points) {\n            o.turnLeft();\n        }\n\n        ans += go(points);\n\n        out.printf(\"%.10f\\n\", ans / 2.0);\n\n    }\n\n    private long poly_area(Point points[]) {\n        long ret = 0;\n        for (int i = 1; i + 1 < points.length; ++i) {\n            ret += points[i].subtract(points[0]).det(points[i + 1].subtract(points[0]));\n        }\n        return ret;\n    }\n}\n\nclass Point implements Comparable<Point> {\n    long x, y;\n\n    Point(long x, long y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Point(long x, long y, int color) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Point subtract(Point o) {\n        return new Point(x - o.x, y - o.y);\n    }\n\n    long det(Point o) {\n        return x * o.y - y * o.x;\n    }\n\n    void turnLeft() {\n        long tmp = this.y;\n        this.y = -this.x;\n        this.x = tmp;\n    }\n\n    public int compareTo(Point point) {\n        if (x != point.x) return Long.signum(x - point.x);\n        return Long.signum(y - point.y);\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (Exception e) {\n                throw new UnknownError();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s[100005][2], fn[2000005];\ndouble ans, ptot, f[2000005][3];\nvoid makeline(double x0, double y0, double x1, double y1, double *a, double *b,\n              double *c) {\n  *a = y1 - y0;\n  *b = x0 - x1;\n  *c = x1 * y0 - y1 * x0;\n  return;\n}\ndouble intersection(double a, double b, double c, double x) {\n  if (a == 0)\n    return -c / b;\n  else\n    return (-c - a * x) / b;\n}\nvoid calc(void) {\n  int i, j, l, r, left = LONG_MAX, right = -LONG_MAX, dx;\n  double a0, b0, c0, del2, co1, co2;\n  ptot = 0;\n  memset(f, 0, sizeof(f));\n  memset(fn, 0, sizeof(fn));\n  for (i = 0; i < n; i++) {\n    makeline(s[i][0], s[i][1], s[i + 1][0], s[i + 1][1], &a0, &b0, &c0);\n    l = s[i][0];\n    r = s[i + 1][0];\n    if (l <= r)\n      dx = 1;\n    else\n      dx = -1;\n    if (b0 == 0) {\n      f[s[i][0]][++fn[s[i][0]]] = s[i][1];\n      continue;\n    }\n    left = min(left, min(s[i][0], s[i + 1][0]));\n    right = max(right, max(s[i][0], s[i + 1][0]));\n    for (j = l; j != r; j += dx) f[j][++fn[j]] = intersection(a0, b0, c0, j);\n  }\n  for (i = left, del2 = co1 = co2 = 0; i <= right; i++) {\n    if (f[i][1] > f[i][2]) swap(f[i][1], f[i][2]);\n    if (fn[i] == 1)\n      f[i][0] = 1;\n    else\n      f[i][0] = floor(f[i][2] + 1e-6) - ceil(f[i][1] - 1e-6) + 1;\n    ptot += f[i][0];\n    co2 += co1;\n    ans += f[i][0] * co2;\n    co1 += del2 + f[i][0];\n    del2 += f[i][0] * 2;\n  }\n  return;\n}\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++)\n    scanf(\"%d%d\", &s[i][0], &s[i][1]), s[i][0] += 1000000, s[i][1] += 1000000;\n  s[n][0] = s[0][0];\n  s[n][1] = s[0][1];\n  ans = 0;\n  calc();\n  for (i = 0; i <= n; i++) swap(s[i][0], s[i][1]);\n  calc();\n  ans /= ptot * (ptot - 1);\n  printf(\"%.8lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int OFFSET = 1000100;\nconst double oo = 1e18;\nconst double EPS = 1e-8;\nint n, x[100100], y[100100];\ndouble yLow[2000200], yHigh[2000200];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++)\n    scanf(\"%d%d\", x + i, y + i), x[i] += OFFSET, y[i] += OFFSET;\n  x[n] = x[0];\n  y[n] = y[0];\n  int xLow = x[0], xHigh = x[0];\n  for (int i = 1; i < n; i++) {\n    xLow = min(xLow, x[i]);\n    xHigh = max(xHigh, x[i]);\n  }\n  for (int i = xLow; i <= xHigh; i++) yLow[i] = oo, yHigh[i] = -oo;\n  for (int i = 0; i < n; i++)\n    if (x[i] == x[i + 1]) {\n      yLow[x[i]] = min(yLow[x[i]], 1.0 * min(y[i], y[i + 1]));\n      yHigh[x[i]] = min(yHigh[x[i]], 1.0 * max(y[i], y[i + 1]));\n    } else {\n      double A = y[i] - y[i + 1], B = x[i + 1] - x[i], C = -A * x[i] - B * y[i];\n      int xL = min(x[i], x[i + 1]), xR = max(x[i], x[i + 1]);\n      for (int curX = xL; curX <= xR; curX++) {\n        double curY = (-C - A * curX) / B;\n        yLow[curX] = min(yLow[curX], curY);\n        yHigh[curX] = max(yHigh[curX], curY);\n      }\n    }\n  double sumX = 0, sumY = 0, sumXSqr = 0, sumYSqr = 0, point = 0;\n  for (int curX = xLow; curX <= xHigh; curX++) {\n    int ylow = int(yLow[curX] + 1 - EPS), yhigh = int(yHigh[curX] + EPS);\n    point += yhigh - ylow + 1;\n    sumX += (yhigh - ylow + 1.0) * curX;\n    sumXSqr += (yhigh - ylow + 1.0) * curX * curX;\n    sumY += (yhigh + ylow) * (yhigh - ylow + 1.0) / 2;\n    sumYSqr += yhigh * (yhigh + 1.0) * (yhigh * 2 + 1) / 6 -\n               (ylow - 1.0) * (ylow) * (ylow * 2 - 1) / 6;\n  }\n  double ans = (sumXSqr + sumYSqr) - (sumX * sumX + sumY * sumY) / point;\n  ans /= (point - 1);\n  printf(\"%.12lf\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fpm(long long b, long long e, long long m) {\n  long long t = 1;\n  for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0;\n  return t;\n}\ntemplate <class T>\ninline bool chkmin(T &a, T b) {\n  return a > b ? a = b, true : false;\n}\ntemplate <class T>\ninline bool chkmax(T &a, T b) {\n  return a < b ? a = b, true : false;\n}\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nT gcd(T x, T y) {\n  for (T t; x; t = x, x = y % x, y = t)\n    ;\n  return y;\n}\ntemplate <class edge>\nstruct Graph {\n  vector<vector<edge> > adj;\n  Graph(int n) {\n    adj.clear();\n    adj.resize(n + 5);\n  }\n  Graph() { adj.clear(); }\n  void resize(int n) { adj.resize(n + 5); }\n  void add(int s, edge e) { adj[s].push_back(e); }\n  void del(int s, edge e) { adj[s].erase(find(iter(adj[s]), e)); }\n  vector<edge> &operator[](int t) { return adj[t]; }\n};\nconst int U = 1100000, maxn = U;\nconst long double eps = 1e-10;\nint n;\nlong double tot;\nset<long double> S[U * 2 + 10];\nint x[maxn], y[maxn];\nint w[maxn];\nlong double work() {\n  long double ret = 0;\n  for (int _end_ = (U + U), i = (0); i <= _end_; ++i) S[i].clear();\n  for (int _end_ = (n), i = (1); i <= _end_; ++i) {\n    int l = i, r = i % n + 1;\n    if (x[l] > x[r]) swap(l, r);\n    if (x[l] == x[r]) {\n      S[x[l] + U].insert(y[l]);\n      S[x[r] + U].insert(y[r]);\n      continue;\n    }\n    for (int _end_ = (x[r]), a = (x[l]); a <= _end_; ++a) {\n      S[a + U].insert(\n          (long double)(1ll * y[l] * (x[r] - a) + 1ll * y[r] * (a - x[l])) /\n          (x[r] - x[l]));\n    }\n  }\n  long double S0 = 0, S1 = 0, S2 = 0;\n  for (int _end_ = (U), i = (-U); i <= _end_; ++i) {\n    if (!(int)((S[i + U]).size())) continue;\n    long double l = *S[i + U].begin(), r = *--S[i + U].end();\n    int lb = ceil(l - eps);\n    int rb = floor(r + eps);\n    long double v = rb - lb + 1;\n    ret += v * (S2 - 2 * S1 * i + S0 * i * i);\n    S2 += 1.0 * v * i * i;\n    S1 += 1.0 * v * i;\n    S0 += 1.0 * v;\n  }\n  cerr << \"ret: \" << ret << \" \" << S0 << endl;\n  if (tot) assert(tot == S0);\n  tot = S0;\n  for (int _end_ = (n), i = (1); i <= _end_; ++i) swap(x[i], y[i]);\n  return ret;\n}\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int _end_ = (n), i = (1); i <= _end_; ++i) {\n    cin >> x[i] >> y[i];\n  }\n  cout << setprecision(15) << (work() + work()) / tot / (tot - 1) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 100005;\nconst int SZ = 2000005;\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-10;\nstruct Point {\n  int x, y;\n};\nlong long cross(const Point &x, const Point &y) {\n  return (long long)x.x * y.y - (long long)x.y * y.x;\n}\nint n;\nPoint a[MAXN];\nint left[SZ];\nint right[SZ];\nint cc[SZ];\nvoid init() {\n  const int SZ2 = 1000002;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\n    a[i].x += SZ2;\n    a[i].y += SZ2;\n  }\n  long long sum = 0;\n  for (int i = 0; i < n; ++i) sum += cross(a[i], a[(i + 1) % n]);\n  if (sum < 0) std::reverse(a + 1, a + n);\n}\nvoid work(long long &cnt, double &sum) {\n  memset(left, INF, sizeof(left));\n  memset(right, -INF, sizeof(right));\n  for (int i = 0; i < n; ++i) {\n    int x1 = a[i].x;\n    int x2 = a[(i + 1) % n].x;\n    int y1 = a[i].y;\n    int y2 = a[(i + 1) % n].y;\n    int minx = std::min(x1, x2);\n    int maxx = std::max(x1, x2);\n    for (int j = minx; j <= maxx; ++j) {\n      double y = (double)(j - x1) / (x2 - x1) * (y2 - y1) + y1;\n      if (x1 < x2) left[j] = (int)(y + 1 - EPS);\n      if (x1 > x2) right[j] = (int)(y + EPS);\n    }\n  }\n  cnt = 0;\n  for (int i = 0; i < SZ; ++i)\n    if (left[i] <= right[i])\n      cnt += cc[i] = right[i] - left[i] + 1;\n    else\n      cc[i] = 0;\n  double p1 = 0;\n  double p2 = 0;\n  double p3 = 0;\n  sum = 0;\n  for (int i = 0; i < SZ; ++i) {\n    sum += cc[i] * p1;\n    p3 += cc[i];\n    p2 += 2 * p3 - cc[i];\n    p1 += p2;\n  }\n}\nvoid solve() {\n  long long cnt;\n  double sumx, sumy;\n  work(cnt, sumy);\n  for (int i = 0; i < n; ++i) std::swap(a[i].x, a[i].y);\n  std::reverse(a + 1, a + n);\n  work(cnt, sumx);\n  printf(\"%.12f\\n\", (sumx + sumy) / 2 / ((double)cnt * (cnt - 1) / 2));\n}\nint main() {\n  init();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  long long x, y;\n} high, low, st, en, temp_up, temp_down;\nlong long n, k;\nlong long total = 0, cntx[2000002], cnty[2000002];\nvector<point> v, up, down;\nlong long check(point a, point b, point c) {\n  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (long long i = 1, x, y; i <= n; i++) {\n    cin >> x >> y;\n    v.push_back({x + 1000000, y + 1000000});\n  }\n  sort(v.begin(), v.end(),\n       [](point a, point b) { return a.x < b.x || (a.x == b.x && a.y < b.y); });\n  st = v[0], en = v.back();\n  for (long long i = 0; i < (long long)v.size(); i++) {\n    if (i != (long long)v.size() - 1 && check(v[i], st, en) < 0) continue;\n    while (up.size() > 2 &&\n           check(up[up.size() - 1], up[up.size() - 2], v[i]) < 0) {\n      up.pop_back();\n    }\n    up.push_back(v[i]);\n  }\n  for (long long i = 0; i < (long long)v.size(); i++) {\n    if (i != (long long)v.size() - 1 && check(v[i], st, en) > 0) continue;\n    while (down.size() > 2 &&\n           check(down[down.size() - 1], down[down.size() - 2], v[i]) > 0) {\n      down.pop_back();\n    }\n    down.push_back(v[i]);\n  }\n  high = low = {v[0].x + 1, v[0].y};\n  long long cur = 0, mn = v[0].y, mx = v[0].y;\n  while (1) {\n    cur++;\n    if (v[cur].x == v[cur - 1].x) {\n      mx = max(mx, v[cur].y);\n      mn = min(mn, v[cur].y);\n    } else {\n      break;\n    }\n  }\n  high.y = mx;\n  low.y = mn;\n  cntx[v[0].x] = high.y - low.y + 1;\n  while (high.x <= v.back().x && low.x <= v.back().x) {\n    long long k = lower_bound(up.begin(), up.end(), (point){high.x, 0},\n                              [](point a, point b) {\n                                return a.x < b.x || (a.x == b.x && a.y < b.y);\n                              }) -\n                  up.begin();\n    temp_up = high;\n    while (check(up[k - 1], up[k], temp_up) <= 0) {\n      high = temp_up;\n      temp_up.y++;\n    }\n    while (check(up[k - 1], up[k], high) > 0) {\n      temp_up.y--;\n      high = temp_up;\n    }\n    k = lower_bound(down.begin(), down.end(), (point){low.x, 0},\n                    [](point a, point b) {\n                      return a.x < b.x || (a.x == b.x && a.y < b.y);\n                    }) -\n        down.begin();\n    temp_down = low;\n    while (check(down[k - 1], down[k], temp_down) >= 0) {\n      low = temp_down;\n      temp_down.y--;\n    }\n    while (check(down[k - 1], down[k], temp_down) < 0) {\n      temp_down.y++;\n      low = temp_down;\n    }\n    cntx[high.x] = high.y - low.y + 1;\n    high.x++;\n    low.x++;\n  }\n  up.clear();\n  down.clear();\n  sort(v.begin(), v.end(),\n       [](point a, point b) { return a.y < b.y || (a.y == b.y && a.x < b.x); });\n  st = v[0], en = v.back();\n  for (long long i = 0; i < (long long)v.size(); i++) {\n    if (i != (long long)v.size() - 1 && check(v[i], st, en) < 0) continue;\n    while (up.size() > 2 &&\n           check(up[up.size() - 1], up[up.size() - 2], v[i]) < 0) {\n      up.pop_back();\n    }\n    up.push_back(v[i]);\n  }\n  for (long long i = 0; i < (long long)v.size(); i++) {\n    if (i != (long long)v.size() - 1 && check(v[i], st, en) > 0) continue;\n    while (down.size() > 2 &&\n           check(down[down.size() - 1], down[down.size() - 2], v[i]) > 0) {\n      down.pop_back();\n    }\n    down.push_back(v[i]);\n  }\n  high = low = {v[0].x, v[0].y + 1};\n  cur = 0, mn = v[0].x, mx = v[0].x;\n  while (1) {\n    cur++;\n    if (v[cur].y == v[cur - 1].y) {\n      mx = max(mx, v[cur].x);\n      mn = min(mn, v[cur].x);\n    } else {\n      break;\n    }\n  }\n  low.x = mx;\n  high.x = mn;\n  cnty[v[0].y] = low.x - high.x + 1;\n  total += cnty[v[0].y];\n  while (high.y <= v.back().y && low.y <= v.back().y) {\n    k = lower_bound(up.begin(), up.end(), (point){0, high.y},\n                    [](point a, point b) {\n                      return a.y < b.y || (a.y == b.y && a.x < b.x);\n                    }) -\n        up.begin();\n    point temp_up = high, temp_down = low;\n    while (check(up[k - 1], up[k], temp_up) <= 0) {\n      high = temp_up;\n      temp_up.x--;\n    }\n    while (check(up[k - 1], up[k], high) > 0) {\n      temp_up.x++;\n      high = temp_up;\n    }\n    k = lower_bound(down.begin(), down.end(), (point){0, low.y},\n                    [](point a, point b) {\n                      return a.y < b.y || (a.y == b.y && a.x < b.x);\n                    }) -\n        down.begin();\n    while (check(down[k - 1], down[k], temp_down) >= 0) {\n      low = temp_down;\n      temp_down.x++;\n    }\n    while (check(down[k - 1], down[k], temp_down) < 0) {\n      temp_down.x--;\n      low = temp_down;\n    }\n    cnty[high.y] = low.x - high.x + 1;\n    total += cnty[high.y];\n    high.y++;\n    low.y++;\n  }\n  long long sumx = 0, sumy = 0;\n  double sumx_square = 0, sumy_square = 0;\n  long double ansx = 0, ansy = 0;\n  for (long long j = 0; j <= 2e6; j++) {\n    sumx += (j - 1e6) * cntx[j];\n    sumx_square +=\n        (long double)(j - 1e6) * (j - 1e6) / (total - 1) / 2 * cntx[j];\n    sumy += (j - 1e6) * cnty[j];\n    sumy_square +=\n        (long double)(j - 1e6) * (j - 1e6) / (total - 1) / 2 * cnty[j];\n  }\n  for (long long i = 0; i <= 2e6; i++) {\n    ansx += (long double)((i - 1e6) * total - 2ll * sumx) / total * (i - 1e6) /\n            (total - 1) * cntx[i] / 2;\n    ansy += (long double)((i - 1e6) * total - 2ll * sumy) / total * (i - 1e6) /\n            (total - 1) * cnty[i] / 2;\n  }\n  ansx += sumx_square;\n  ansy += sumy_square;\n  long double t = ansx + ansy;\n  cout << fixed << setprecision(10) << t << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int ding = 1000005;\nconst double eps = 1e-8;\nlong long n, m, z, x[100005], y[100005], a[2000011], l, r, mi, sum, node, t;\nlong long tx[100005], ty[100005];\nlong double ans, zc;\ndouble fans;\ninline int pre(int l) {\n  if (l > 1)\n    return l - 1;\n  else\n    return n;\n}\ninline int next(int l) {\n  if (l < n)\n    return l + 1;\n  else\n    return 1;\n}\ninline int workx(int p, int l, int r) {\n  int a, b;\n  if (x[l] == x[pre(l)])\n    a = min(y[l], y[pre(l)]) - 1;\n  else\n    a = ceil(y[l] + (y[pre(l)] - y[l]) / (1.0 * x[pre(l)] - x[l]) * (p - x[l]) -\n             eps) -\n        1;\n  if (x[r] == x[next(r)])\n    b = max(y[r], y[next(r)]);\n  else\n    b = floor(y[r] +\n              (y[next(r)] - y[r]) / (1.0 * x[next(r)] - x[r]) * (p - x[r]) +\n              eps);\n  return b - a;\n}\ninline int worky(int p, int l, int r) {\n  int a, b;\n  if (y[l] == y[pre(l)])\n    a = max(x[l], x[pre(l)]);\n  else\n    a = floor(x[l] +\n              (x[pre(l)] - x[l]) * (p - y[l]) / (1.0 * y[pre(l)] - y[l]));\n  if (y[r] == y[next(r)])\n    b = min(x[r], x[next(r)]) - 1;\n  else\n    b = ceil(x[r] +\n             (x[next(r)] - x[r]) * (p - y[r]) / (1.0 * y[next(r)] - y[r])) -\n        1;\n  return a - b;\n}\ninline void work() {\n  zc = 0;\n  for (long long i = 0; i <= 2 * ding; ++i)\n    if (a[i] > 0) {\n      z = i - ding;\n      zc += 1.0 * a[i] * z * z;\n      sum += a[i] * z;\n    }\n  ans += zc / (node * 1.0);\n  zc = 0;\n  for (long long i = 0; i <= 2 * ding; ++i)\n    if (a[i] > 0) {\n      z = i - ding;\n      zc += 1.0 * a[i] * z * (sum - z);\n    }\n  ans -= zc / (node * 1.0) / ((node - 1) * 1.0);\n}\nint main() {\n  scanf(\"%I64d\", &n);\n  mi = 2 * ding;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%I64d%I64d\", &x[i], &y[i]);\n    if (x[i] + ding < mi) mi = x[i] + ding, l = i;\n  }\n  for (int i = 1; i <= n; ++i)\n    tx[i] = x[(i + l - 2) % n + 1], ty[i] = y[(i + l - 2) % n + 1];\n  for (int i = 1; i <= n; ++i) x[i] = tx[i], y[i] = ty[i];\n  if (y[2] < y[n])\n    for (int i = 2; i <= (n + 1) / 2; ++i)\n      swap(x[i], x[n - i + 2]), swap(y[i], y[n - i + 2]);\n  t = x[1];\n  r = l = 1;\n  for (int i = 1; i <= n - 1; ++i) {\n    if (x[pre(l)] <= x[next(r)]) {\n      for (int j = t; j < x[pre(l)]; ++j) a[j + ding] = workx(j, l, r);\n      l = pre(l);\n      t = x[l];\n    } else {\n      for (int j = t; j < x[next(r)]; ++j) a[j + ding] = workx(j, l, r);\n      r = next(r);\n      t = x[r];\n    }\n  }\n  a[x[l] + ding] = workx(x[l], next(l), r);\n  node = 0;\n  for (long long i = 0; i <= 2 * ding; ++i) node += a[i];\n  work();\n  memset(a, 0, sizeof(a));\n  sum = 0;\n  mi = 2 * ding;\n  for (int i = 1; i <= n; ++i)\n    if (y[i] + ding < mi) mi = y[i] + ding, l = i;\n  r = l;\n  t = y[l];\n  for (int i = 1; i <= n - 1; ++i) {\n    if (y[pre(l)] <= y[next(r)]) {\n      for (int j = t; j < y[pre(l)]; ++j) a[j + ding] = worky(j, l, r);\n      l = pre(l);\n      t = y[l];\n    } else {\n      for (int j = t; j < y[next(r)]; ++j) a[j + ding] = worky(j, l, r);\n      r = next(r);\n      t = y[r];\n    }\n  }\n  a[y[l] + ding] = worky(y[l], next(l), r);\n  work();\n  fans = ans;\n  printf(\"%.10lf\", fans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) /\n                                (double)(A[Y].first - A[X].first) *\n                                (double)(A[Y].second - A[X].second);\n  return floor(Y1 + 0);\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) /\n                                (double)(A[Y].first - A[X].first) *\n                                (double)(A[Y].second - A[X].second);\n  return ceil(Y1 - 0);\n}\nlong long F[10000005];\ndouble Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    for (; A[k + 1].first < i;) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long long Cnt = 0;\n  long long SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    for (; A[k + 1].first > i;) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  double Ans0 = 0;\n  for (int i = Q; i >= P; i--)\n    Ans0 += (double)F[i] * (i - 1000005) * (i - 1000005) * Cnt;\n  Ans0 -= (double)SumX * SumX;\n  Ans0 /= ((double)(Cnt - 1) * Cnt);\n  Ans += Ans0;\n}\nvoid Work() {\n  double S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += (double)A[k].first * (double)A[k + 1].second -\n         (double)A[k].second * (double)A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) std::swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct TPoint {\n  long long x, y;\n  TPoint(int x = 0, int y = 0) : x(x), y(y) {}\n};\nTPoint p[100011];\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lfloor(long long a, long long b);\nlong long lceil(long long a, long long b) {\n  if (a < 0) {\n    return -lfloor(-a, b);\n  }\n  return (a + b - 1) / b;\n}\nlong long lfloor(long long a, long long b) {\n  if (a < 0) {\n    return -lceil(-a, b);\n  }\n  return a / b;\n}\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%I64d%I64d\", &p[i].x, &p[i].y);\n  }\n  p[N] = p[0];\n  long long S = 0;\n  for (int i = 0; i < N; ++i) {\n    S += (p[i + 1].y + p[i].y) * (p[i + 1].x - p[i].x);\n  }\n  if (S > 0) {\n    reverse(p, p + N);\n    p[N] = p[0];\n  }\n  S = std::abs(S);\n  long long bord = 0;\n  for (int i = 0; i < N; ++i) {\n    bord += gcd(abs(p[i + 1].x - p[i].x), abs(p[i + 1].y - p[i].y));\n  }\n  long long total = (S + bord + 2) / 2;\n  vector<TPoint> low, high, left, right;\n  int m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].x < p[m].x || (p[i].x == p[m].x && p[i].y < p[m].y)) {\n      m = i;\n    }\n  }\n  low.push_back(p[m]);\n  for (int i = m + 1;; ++i) {\n    i = (i + N) % N;\n    if (p[i].x > p[(i + N - 1) % N].x) {\n      low.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].x < p[m].x || (p[i].x == p[m].x && p[i].y > p[m].y)) {\n      m = i;\n    }\n  }\n  high.push_back(p[m]);\n  for (int i = m + N - 1;; --i) {\n    i = (i + N) % N;\n    if (p[i].x > p[(i + 1) % N].x) {\n      high.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].y < p[m].y || (p[i].y == p[m].y && p[i].x < p[m].x)) {\n      m = i;\n    }\n  }\n  left.push_back(p[m]);\n  for (int i = m + N - 1;; --i) {\n    i = (i + N) % N;\n    if (p[i].y > p[(i + 1) % N].y) {\n      left.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].y < p[m].y || (p[i].y == p[m].y && p[i].x > p[m].x)) {\n      m = i;\n    }\n  }\n  right.push_back(p[m]);\n  for (int i = m + 1;; ++i) {\n    i = (i + N) % N;\n    if (p[i].y > p[(i + N - 1) % N].y) {\n      right.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  double ex2 = 0.0, ex = 0.0;\n  {\n    int li = 0, hi = 0;\n    for (int x = -1000001; x <= 1000001; ++x) {\n      if (x < low[0].x) {\n        continue;\n      }\n      if (x > low.back().x) {\n        break;\n      }\n      int l = low[li].y + lceil((x - low[li].x) * (low[li + 1].y - low[li].y),\n                                (low[li + 1].x - low[li].x));\n      int r =\n          high[hi].y + lfloor((x - high[hi].x) * (high[hi + 1].y - high[hi].y),\n                              (high[hi + 1].x - high[hi].x));\n      int p = (r - l + 1);\n      ex2 += (double)1.0 * p * x * x;\n      ex += (double)1.0 * p * x;\n      if (x == low[li + 1].x) {\n        ++li;\n      }\n      if (x == high[hi + 1].x) {\n        ++hi;\n      }\n    }\n  }\n  double ey2 = 0.0, ey = 0.0;\n  {\n    int li = 0, ri = 0;\n    for (int y = -1000001; y <= 1000001; ++y) {\n      if (y < left[0].y) {\n        continue;\n      }\n      if (y > left.back().y) {\n        break;\n      }\n      int l =\n          left[li].x + lceil((y - left[li].y) * (left[li + 1].x - left[li].x),\n                             (left[li + 1].y - left[li].y));\n      int r = right[ri].x +\n              lfloor((y - right[ri].y) * (right[ri + 1].x - right[ri].x),\n                     (right[ri + 1].y - right[ri].y));\n      int p = (r - l + 1);\n      ey2 += (double)1.0 * p * y * y;\n      ey += (double)1.0 * p * y;\n      if (y == left[li + 1].y) {\n        ++li;\n      }\n      if (y == right[ri + 1].y) {\n        ++ri;\n      }\n    }\n  }\n  ex2 /= total;\n  ex /= total;\n  ey2 /= total;\n  ey /= total;\n  double ans = ex2 - ex * ex + ey2 - ey * ey;\n  ans *= 1.0 * total / (total - 1);\n  printf(\"%.10lf\", (double)ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 2e6 + 2e5;\nconst int N = M >> 1;\nconst int MX = 2e6;\nconst int D = 1e6;\ndouble L[M], R[M];\nint g[M];\nstruct pnt {\n  int x, y;\n  void input() { scanf(\"%d %d\", &x, &y); }\n} p[N];\nint n;\ndouble ans;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    p[i].input();\n    p[i].x += D, p[i].y += D;\n  }\n  function<void(int, double)> update = [&](int y, double x) {\n    L[y] = min(L[y], x);\n    R[y] = max(R[y], x);\n  };\n  for (int step = 0; step < 2; step++) {\n    for (int i = 0; i <= MX; i++) L[i] = M, R[i] = -1;\n    for (int i = 1; i <= n; i++) {\n      update(p[i].y, p[i].x);\n      int ni = i == n ? 1 : i + 1;\n      if (p[i].y == p[ni].y) continue;\n      double d = (p[ni].x - p[i].x) * 1.0 / (p[ni].y - p[i].y);\n      double cur;\n      cur = p[i].x;\n      for (int j = p[i].y + 1; j < p[ni].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n      cur = p[ni].x;\n      for (int j = p[ni].y + 1; j < p[i].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n    }\n    long long tot = 0;\n    for (int i = 0; i <= MX; i++) {\n      int lx = L[i] + 0.9999999;\n      int rx = R[i] + 0.0000001;\n      g[i] = rx >= lx ? rx - lx + 1 : 0;\n      tot += g[i];\n    }\n    double c = 0, d = 0, dd = 0;\n    for (int i = 0; i < MX; i++) {\n      double r = g[i] * 1.0 / (tot - 1);\n      d = d + dd + r;\n      dd = dd + r + r;\n      c = c + d;\n      ans += 1.0 * g[i + 1] / tot * c;\n    }\n    for (int i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  }\n  cout << fixed << setprecision(10) << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct ww {\n  double x, s, t, sumy, sumyy;\n} a[2000010];\nint i, j, k, n, m;\nint x[2000010], y[2000010];\ndouble l[2000010], r[2000010], s, t, an;\ninline void work(int x, int y, int xx, int yy) {\n  if (x > xx) swap(x, xx), swap(y, yy);\n  if (x == xx) {\n    l[x] = min(l[x], 0. + y);\n    r[x] = max(r[x], 0. + yy);\n    return;\n  }\n  int i;\n  for (i = x; i <= xx; i++) {\n    double k = 1. * (yy - y) * (i - x) / (xx - x) + y;\n    l[i] = min(l[i], k);\n    r[i] = max(r[i], k);\n  }\n}\ninline void Do() {\n  int i;\n  for (i = 0; i <= 2000010 - 1; i++) r[i] = 0, l[i] = 2000010;\n  for (i = 1; i <= n; i++) work(x[i], y[i], x[i + 1], y[i + 1]);\n  m = 0;\n  for (i = 0; i <= 2000010 - 1; i++)\n    if (l[i] < 2000010) {\n      int A = int(l[i] - (1e-11)) + 1, B = int(r[i] + (1e-11));\n      m++;\n      a[m].x = i;\n      a[m].s = B - A + 1;\n      a[m].t = a[m].x * a[m].s;\n    }\n  s = t = 0;\n  for (i = 1; i <= m; i++) s += a[i].s, t += a[i].t;\n  for (i = 1; i <= m; i++)\n    an += a[i].t * a[i].x * (s - a[i].s) - (a[i].t * (t - a[i].t));\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++)\n    scanf(\"%d%d\", &x[i], &y[i]), x[i] += 2000010 / 2, y[i] += 2000010 / 2;\n  x[n + 1] = x[1], y[n + 1] = y[1];\n  Do();\n  for (i = 1; i <= n + 1; i++) swap(x[i], y[i]);\n  Do();\n  an /= s * (s - 1);\n  printf(\"%.10lf\\n\", an);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100004, M = 2000004, P = 1000000;\nstruct rec {\n  int x, y;\n} p[N], u[N], d[N];\nint n, nu, nd, ul, ur, dl, dr, ly[M], ry[M], cnt[M];\ndouble ans = 0;\nbool b[N];\nlong long cross(int p0, int p1, int p2) {\n  return (long long)(p[p1].x - p[p0].x) * (p[p2].y - p[p0].y) -\n         (long long)(p[p1].y - p[p0].y) * (p[p2].x - p[p0].x);\n}\nvoid process() {\n  int i;\n  nu = nd = 0;\n  ul = ur = dl = dr = 1;\n  for (i = 1; i <= n; i++) {\n    if ((p[i].x < p[ul].x) || ((p[i].x == p[ul].x) && (p[i].y > p[ul].y)))\n      ul = i;\n    if ((p[i].x > p[ur].x) || ((p[i].x == p[ur].x) && (p[i].y > p[ur].y)))\n      ur = i;\n    if ((p[i].x < p[dl].x) || ((p[i].x == p[dl].x) && (p[i].y < p[dl].y)))\n      dl = i;\n    if ((p[i].x > p[dr].x) || ((p[i].x == p[dr].x) && (p[i].y < p[dr].y)))\n      dr = i;\n  }\n  if (cross(1, 2, 3) > 0) {\n    for (i = ul;; i = (i == 1) ? n : (i - 1)) {\n      u[++nu] = p[i];\n      if (i == ur) break;\n    }\n    for (i = dl;; i = (i == n) ? 1 : (i + 1)) {\n      d[++nd] = p[i];\n      if (i == dr) break;\n    }\n  } else {\n    for (i = ul;; i = (i == n) ? 1 : (i + 1)) {\n      u[++nu] = p[i];\n      if (i == ur) break;\n    }\n    for (i = dl;; i = (i == 1) ? n : (i - 1)) {\n      d[++nd] = p[i];\n      if (i == dr) break;\n    }\n  }\n  u[++nu] = p[ur];\n  d[++nd] = p[dr];\n  int lx = p[ul].x, rx = p[ur].x, pu = 1, pd = 1;\n  for (i = lx; i < rx; i++) {\n    if ((pu <= nu) && (i == u[pu + 1].x)) pu++;\n    if ((pd <= nd) && (i == d[pd + 1].x)) pd++;\n    ly[i + P] =\n        d[pd].y + ceil((i - d[pd].x) * ((double)(d[pd + 1].y - d[pd].y) /\n                                        (d[pd + 1].x - d[pd].x)) -\n                       1e-6);\n    ry[i + P] =\n        u[pu].y + floor((i - u[pu].x) * ((double)(u[pu + 1].y - u[pu].y) /\n                                         (u[pu + 1].x - u[pu].x)) +\n                        1e-6);\n  }\n  ry[rx + P] = u[nu].y;\n  ly[rx + P] = d[nd].y;\n  double ret = 0;\n  long long tot = 0;\n  for (i = lx; i <= rx; i++)\n    cnt[i - lx + 1] = ry[i + P] - ly[i + P] + 1, tot += cnt[i - lx + 1];\n  double s1 = cnt[1], s2 = cnt[1], s = 0;\n  for (i = 2; i <= rx - lx + 1; i++) {\n    s += s2;\n    s1 += cnt[i - 1] + cnt[i];\n    s2 += s1;\n    ret += s * cnt[i] / tot;\n  }\n  ans += ret / (tot - 1);\n}\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) scanf(\"%d%d\", &p[i].x, &p[i].y), b[i] = true;\n  for (i = 2; i < n; i++)\n    if (cross(i - 1, i, i + 1) == 0) b[i] = false;\n  if (cross(n - 1, n, 1) == 0) b[n] = false;\n  if (cross(n, 1, 2) == 0) b[1] = false;\n  int m = n;\n  n = ans = 0;\n  for (i = 1; i <= m; i++)\n    if (b[i]) p[++n] = p[i];\n  process();\n  for (i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  process();\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMax = 1000100 * 2, MMax = 101000;\nint N;\nint xmin, xmax, ymin, ymax;\npair<long double, long double> line[MMax];\npair<int, int> area[MMax], P1[MMax];\nvector<long double> X[NMax], Y[NMax];\nlong double sum[NMax];\nlong double Ceil(long double a) { return ceil(a); }\nlong double Floor(long double a) { return floor(a); }\npair<long double, long double> P[MMax];\nbool flag[NMax];\nint main() {\n  scanf(\"%d\", &N);\n  xmin = 100000000;\n  xmax = -100000000;\n  ymin = 100000000;\n  ymax = -100000000;\n  int minx = 100000000, miny = 100000000;\n  for (int i = 1; i <= N; i++) {\n    int first, second;\n    scanf(\"%d%d\", &first, &second);\n    minx = min(minx, first);\n    miny = min(miny, second);\n    P1[i].first = first;\n    P1[i].second = second;\n    P[i].first = (long double)first;\n    P[i].second = (long double)second;\n  }\n  for (int i = 1; i <= N; i++)\n    P[i].first -= (long double)minx, P[i].second -= (long double)miny,\n        P1[i].first -= minx, P1[i].second -= miny;\n  for (int i = 1; i <= N; i++) {\n    xmin = min(xmin, P1[i].first);\n    ymin = min(ymin, P1[i].second);\n    xmax = max(xmax, P1[i].first);\n    ymax = max(ymax, P1[i].second);\n  }\n  if (P1[N].first == P1[1].first) flag[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    int j = i + 1;\n    if (j > N) j = 1;\n    if (P1[i].first == P1[j].first) {\n      line[i].first = -1;\n      line[i].second = -1;\n      flag[i] = 1;\n      area[i].first = P1[i].first;\n      area[i].second = P1[j].first;\n      if (!flag[i - 1]) {\n        X[area[i].first].push_back(P[i].second);\n      }\n      if (P1[j].first != P1[(j % N) + 1].first)\n        X[area[i].first].push_back(P[j].second);\n    } else {\n      line[i].first = (P[j].second - P[i].second) / (P[j].first - P[i].first);\n      line[i].second = P[j].second - P[j].first * line[i].first;\n      area[i].first = P1[i].first;\n      area[i].second = P1[j].first;\n      if (area[i].first < area[i].second)\n        for (int j = flag[i - 1] ? (area[i].first + 1) : area[i].first;\n             j < area[i].second; j++)\n          X[j].push_back(line[i].first * (long double)j + line[i].second);\n      else\n        for (int j = flag[i - 1] ? (area[i].first - 1) : area[i].first;\n             j > area[i].second; j--)\n          X[j].push_back(line[i].first * (long double)j + line[i].second);\n    }\n  }\n  memset(flag, 0, sizeof(flag));\n  if (P1[N].second == P1[1].second) flag[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    swap(P[i].first, P[i].second);\n    swap(P1[i].first, P1[i].second);\n    int j = i + 1;\n    if (j > N) j = 1;\n    swap(P[j].first, P[j].second);\n    swap(P1[j].first, P1[j].second);\n    if (P1[i].first == P1[j].first) {\n      line[i].first = -1;\n      line[i].second = -1;\n      flag[i] = 1;\n      area[i].first = P1[i].first;\n      area[i].second = P1[j].first;\n      if (!flag[i - 1]) Y[area[i].first].push_back(P[i].second);\n      if (P1[j].first != P1[(j % N) + 1].second)\n        Y[area[i].first].push_back(P[j].second);\n    } else {\n      line[i].first = (P[j].second - P[i].second) / (P[j].first - P[i].first);\n      line[i].second = P[j].second - P[j].first * line[i].first;\n      area[i].first = P1[i].first;\n      area[i].second = P1[j].first;\n      if (area[i].first < area[i].second)\n        for (int j = flag[i - 1] ? (area[i].first + 1) : area[i].first;\n             j < area[i].second; j++)\n          Y[j].push_back(line[i].first * (long double)j + line[i].second);\n      else\n        for (int j = flag[i - 1] ? (area[i].first - 1) : area[i].first;\n             j > area[i].second; j--)\n          Y[j].push_back(line[i].first * (long double)j + line[i].second);\n    }\n    swap(P[i].first, P[i].second);\n    swap(P[j].first, P[j].second);\n    swap(P1[i].first, P1[i].second);\n    swap(P1[j].first, P1[j].second);\n  }\n  for (int i = xmin; i <= xmax; i++) {\n    for (int j = 0; j < X[i].size(); j++)\n      if (X[i][j] <= 0 && -X[i][j] < 1e-8f || (X[i][j] >= 0 && X[i][j] < 1e-8f))\n        X[i][j] = +0.0;\n    sort(X[i].begin(), X[i].end());\n    vector<long double>::iterator it = unique(X[i].begin(), X[i].end());\n    X[i].resize(distance(X[i].begin(), it));\n    if (X[i].size() == 1) X[i].push_back(X[i][0]);\n    if (X[i][0] > X[i][1]) swap(X[i][0], X[i][1]);\n    X[i][0] = (long double)Ceil(X[i][0]);\n    X[i][1] = (long double)Floor(X[i][1]);\n  }\n  for (int i = ymin; i <= ymax; i++) {\n    for (int j = 0; j < Y[i].size(); j++)\n      if (Y[i][j] <= 0 && -Y[i][j] < 1e-8f || (Y[i][j] >= 0 && Y[i][j] < 1e-8f))\n        Y[i][j] = +0.0;\n    sort(Y[i].begin(), Y[i].end());\n    vector<long double>::iterator it = unique(Y[i].begin(), Y[i].end());\n    Y[i].resize(distance(Y[i].begin(), it));\n    if (Y[i].size() == 1) Y[i].push_back(Y[i][0]);\n    if (Y[i][0] > Y[i][1]) swap(Y[i][0], Y[i][1]);\n    Y[i][0] = (long double)Ceil(Y[i][0]);\n    Y[i][1] = (long double)Floor(Y[i][1]);\n  }\n  long double ret = 0, div = 0, cnt = 0, mul = 0, mul1 = 0;\n  for (int i = xmin; i <= xmax; i++)\n    mul += X[i][1] - X[i][0] + 1,\n        mul1 += (long double)i * (X[i][1] - X[i][0] + 1);\n  for (int i = xmin; i <= xmax; i++) {\n    div = div + X[i][1] - X[i][0] + 1;\n    long double tmp = mul - (X[i][1] - X[i][0] + 1),\n                tmp1 = mul1 - (long double)i * (X[i][1] - X[i][0] + 1.0);\n    ret =\n        ret + (X[i][1] - X[i][0] + 1.0) * (long double)i * (long double)i * tmp;\n    ret = ret - (X[i][1] - X[i][0] + 1.0) * (long double)i * tmp1;\n  }\n  cnt = 0;\n  mul = 0;\n  mul1 = 0;\n  for (int i = ymin; i <= ymax; i++)\n    mul += Y[i][1] - Y[i][0] + 1.0,\n        mul1 += (long double)i * (Y[i][1] - Y[i][0] + 1.0);\n  for (int i = ymin; i <= ymax; i++) {\n    long double tmp = mul - (Y[i][1] - Y[i][0] + 1.0),\n                tmp1 = mul1 - (long double)i * (Y[i][1] - Y[i][0] + 1.0);\n    ret =\n        ret + (Y[i][1] - Y[i][0] + 1.0) * (long double)i * (long double)i * tmp;\n    ret = ret - (Y[i][1] - Y[i][0] + 1.0) * (long double)i * tmp1;\n  }\n  div = div * (div - 1.0);\n  ret = ret / div;\n  printf(\"%.10lf\\n\", (double)ret);\n  getchar();\n  getchar();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Tpoint {\n  long long x, y;\n  const bool operator!=(Tpoint a) const { return (a.x != x) || (a.y != y); }\n} P[100050];\nstruct Tline {\n  Tpoint p0, p1;\n} L[100050];\ndouble s1[2000050], s2[2000050], s3[2000050];\nlong long cnt[2000050];\nint n, tot, m;\nbool cmp(Tline a, Tline b) {\n  return (a.p0.x < b.p0.x) || ((a.p0.x == b.p0.x) && (a.p1.y < b.p1.y));\n}\ndouble work() {\n  Tpoint _p, _p0, _p1;\n  double ans;\n  long long i, A, B, _L, _R;\n  tot = 0;\n  for (i = 0; i <= n - 1; i++)\n    if (P[i].x != P[(i + 1) % n].x) {\n      tot++;\n      L[tot].p0 = P[i];\n      L[tot].p1 = P[(i + 1) % n];\n      if (L[tot].p0.x > L[tot].p1.x) {\n        swap(L[tot].p0, L[tot].p1);\n      }\n    }\n  sort(L + 1, L + tot + 1, cmp);\n  A = 1;\n  B = 2;\n  m = L[tot].p1.x - L[1].p0.x + 1;\n  cnt[1] = L[2].p0.y - L[1].p0.y + 1;\n  for (i = L[1].p0.x + 1; i <= L[tot].p1.x; i++) {\n    if (i > L[A].p1.x) {\n      _p = L[A].p1;\n      while (L[A].p0 != _p) A++;\n    }\n    _p0 = L[A].p0;\n    _p1 = L[A].p1;\n    if (_p0.y > _p1.y) swap(_p0, _p1);\n    _L = _p0.y + (llabs(i - _p0.x) * (_p1.y - _p0.y)) / llabs(_p1.x - _p0.x);\n    if ((llabs(i - _p0.x) * (_p1.y - _p0.y)) % llabs(_p1.x - _p0.x)) _L++;\n    if (i > L[B].p1.x) {\n      _p = L[B].p1;\n      while (L[B].p0 != _p) B++;\n    }\n    _p0 = L[B].p0;\n    _p1 = L[B].p1;\n    if (_p0.y > _p1.y) swap(_p0, _p1);\n    _R = _p0.y + (llabs(i - _p0.x) * (_p1.y - _p0.y)) / llabs(_p1.x - _p0.x);\n    cnt[i - L[1].p0.x + 1] = _R - _L + 1;\n  }\n  s1[0] = 0;\n  s2[0] = 0;\n  s3[0] = 0;\n  ans = 0;\n  for (i = 1; i <= m; i++) s1[i] = s1[i - 1] + cnt[i];\n  for (i = 1; i <= m; i++) s2[i] = s2[i - 1] + 2 * s1[i - 1] + cnt[i];\n  for (i = 1; i <= m; i++) s3[i] = s3[i - 1] + s2[i];\n  for (i = 1; i <= m; i++) ans += s3[i - 1] * cnt[i];\n  ans /= s1[m] * (s1[m] - 1);\n  return ans;\n}\nint main() {\n  double ans;\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 0; i <= n - 1; i++) {\n    scanf(\"%I64d%I64d\", &P[i].x, &P[i].y);\n    P[i].x += 1000000;\n    P[i].y += 1000000;\n  }\n  ans = work();\n  for (i = 0; i <= n - 1; i++) swap(P[i].x, P[i].y);\n  ans += work();\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Get(int &T) {\n  char C;\n  bool F = 0;\n  for (; C = getchar(), C < '0' || C > '9';)\n    if (C == '-') F = 1;\n  for (T = C - '0'; C = getchar(), C >= '0' && C <= '9'; T = T * 10 + C - '0')\n    ;\n  F && (T = -T);\n}\npair<int, int> A[1000005];\nint N;\nvoid Init() {\n  Get(N);\n  for (int i = 1; i <= N; i++) {\n    Get(A[i].first);\n    Get(A[i].second);\n    A[i].first += 1000005;\n    A[i].second += 1000005;\n  }\n}\ndouble Floor(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) /\n                                (double)(A[Y].first - A[X].first) *\n                                (double)(A[Y].second - A[X].second);\n  return floor(Y1 + 0);\n}\ndouble Ceil(int X, int Y, int P) {\n  double Y1 = A[X].second + (double)(P - A[X].first) /\n                                (double)(A[Y].first - A[X].first) *\n                                (double)(A[Y].second - A[X].second);\n  return ceil(Y1 - 0);\n}\nlong long F[10000005];\ndouble Ans;\nvoid Calc() {\n  rotate(A + 1, min_element(A + 1, A + N + 1), A + N + 1);\n  A[N + 1] = A[1];\n  int Pos = max_element(A + 1, A + N + 1) - A;\n  int P = A[1].first, Q = A[Pos].first;\n  for (int i = P, k = 1; i <= Q; i++) {\n    for (; A[k + 1].first < i;) k++;\n    int Pos = Ceil(k, k + 1, i);\n    F[i] = -Pos + 1;\n  }\n  long long Cnt = 0;\n  long long SumX = 0;\n  for (int i = Q, k = Pos; i >= P; i--) {\n    for (; A[k + 1].first > i;) k++;\n    int Pos = Floor(k, k + 1, i);\n    F[i] += Pos;\n    Cnt += F[i];\n    SumX += (i - 1000005) * F[i];\n  }\n  double Ans0 = 0;\n  for (int i = Q; i >= P; i--)\n    Ans0 += (double)F[i] * (i - 1000005) * (i - 1000005) * Cnt;\n  Ans0 -= (double)SumX * SumX;\n  Ans0 /= ((double)(Cnt - 1) * Cnt);\n  Ans += Ans0;\n}\nvoid Work() {\n  long long S = 0;\n  A[N + 1] = A[1];\n  for (int k = 1; k <= N + 1; k++)\n    S += A[k].first * A[k + 1].second - A[k].second * A[k + 1].first;\n  if (S < 0) reverse(A + 1, A + N + 1);\n  Calc();\n  for (int k = 1; k <= N; k++) std::swap(A[k].first, A[k].second);\n  reverse(A + 1, A + N + 1);\n  Calc();\n}\nvoid Output() { printf(\"%.15lf\\n\", (double)Ans); }\nint main() {\n  Init();\n  Work();\n  Output();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000;\nint x[N], y[N];\nvector<int> vec[2];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  auto prv = [&n](int x) { return (x - 1 + n) % n; };\n  auto nxt = [&n](int x) { return (x + 1) % n; };\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &x[i], &y[i]);\n  for (int T = 0; T < 2; T++) {\n    if (T)\n      for (int i = 0; i < n; i++) swap(x[i], y[i]);\n    int id, miy = 1e8;\n    for (int i = 0; i < n; i++)\n      if (miy > y[i]) miy = y[i], id = i;\n    int lid = id, rid = id;\n    while (y[prv(lid)] == miy) lid = prv(lid);\n    while (y[nxt(rid)] == miy) rid = nxt(rid);\n    vec[T].push_back(abs(x[lid] - x[rid]) + 1);\n    int now_y = miy;\n    while (1) {\n      ++now_y;\n      if (y[prv(lid)] == now_y) lid = prv(lid);\n      if (y[nxt(rid)] == now_y) rid = nxt(rid);\n      if (y[prv(lid)] <= y[lid]) {\n        vec[T].push_back(abs(x[lid] - x[rid]) + 1);\n        break;\n      }\n      double lx = (1.0 * x[lid] * (y[prv(lid)] - now_y) +\n                   1.0 * x[prv(lid)] * (now_y - y[lid])) /\n                  (y[prv(lid)] - y[lid]);\n      double rx = (1.0 * x[rid] * (y[nxt(rid)] - now_y) +\n                   1.0 * x[nxt(rid)] * (now_y - y[rid])) /\n                  (y[nxt(rid)] - y[rid]);\n      if (lx > rx) swap(lx, rx);\n      vec[T].push_back(floor(rx) - ceil(lx) + 1);\n    }\n  }\n  long long all = 0;\n  for (auto &t : vec[0]) all += t;\n  double ans = 0;\n  for (int T = 0; T < 2; T++) {\n    double sum0 = 0, sum1 = 0, sum2 = 0;\n    int k = 0;\n    for (auto &t : vec[T]) {\n      sum0 += t;\n      sum1 += 1.0 * k * t;\n      sum2 += 1.0 * k * k * t;\n      ++k;\n    }\n    ans += 2 * sum2 * sum0 - 2 * sum1 * sum1;\n  }\n  printf(\"%.10lf\\n\", ans / all / (all - 1) / 2);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8;\nint n;\nint x[100000], y[100000];\ndouble gao(int x[], int y[]) {\n  int leftMost = min_element(x, x + n) - x;\n  int minVal = *min_element(x, x + n);\n  int maxVal = *max_element(x, x + n);\n  int up1 = leftMost, up2 = (up1 + 1) % n;\n  int down1 = leftMost, down2 = (down1 + n - 1) % n;\n  double sqSum = 0.0;\n  double sum = 0.0;\n  double allCount = 0;\n  for (int i = minVal; i <= maxVal; ++i) {\n    if (i > x[up2]) {\n      up1 = up2;\n      up2 = (up2 + 1) % n;\n    }\n    if (i > x[down2]) {\n      down1 = down2;\n      down2 = (down2 + n - 1) % n;\n    }\n    int count = 0;\n    if (i == x[up2] && (x[up1] == x[up2] || x[up2] == x[(up2 + 1) % n])) {\n      count = 1 + (x[up1] == x[up2] ? abs(y[up1] - y[up2])\n                                    : abs(y[up2] - y[(up2 + 1) % n]));\n    } else if (i == x[down2] &&\n               (x[down1] == x[down2] || x[down2] == x[(down2 + n - 1) % n])) {\n      count =\n          1 + (x[down1] == x[down2] ? abs(y[down1] - y[down2])\n                                    : abs(y[down2] - y[(down2 + n - 1) % n]));\n    } else {\n      double ub =\n          (double)(y[up1] - y[up2]) / (x[up1] - x[up2]) * (i - x[up1]) + y[up1];\n      double db = (double)(y[down1] - y[down2]) / (x[down1] - x[down2]) *\n                      (i - x[down1]) +\n                  y[down1];\n      count = floor(ub + EPS) - ceil(db - EPS) + 1;\n    }\n    allCount += count;\n    sqSum += (double)i * i * count;\n    sum += (double)i * count;\n  }\n  return (allCount * sqSum - sum * sum) / (allCount * (allCount - 1) / 2);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n  }\n  long long sgn = 0;\n  for (int i = 0; i < n && sgn == 0; ++i) {\n    int j = (i + 1) % n, k = (j + 1) % n;\n    sgn = (long long)(x[j] - x[i]) * (y[k] - y[i]) -\n          (long long)(x[k] - x[i]) * (y[j] - y[i]);\n  }\n  if (sgn > 0) {\n    reverse(x, x + n);\n    reverse(y, y + n);\n  }\n  double res = 0.0;\n  res += gao(x, y);\n  reverse(x, x + n);\n  reverse(y, y + n);\n  res += gao(y, x);\n  res /= 2;\n  printf(\"%.13f\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  long long x, y;\n  point() { x = y = 0; }\n  point(long long _x, long long _y) { x = _x, y = _y; }\n  void read() { scanf(\"%I64d%I64d\", &x, &y); }\n  point operator-(point &a) { return point(x - a.x, y - a.y); }\n  long long operator*(point a) { return x * a.y - y * a.x; }\n} a[200005];\nint n, l, r, p;\nlong double c[2000005], second[2000005], q[2000005];\nlong long up, down;\nbool cmp(point &a, point &b) {\n  return ((a.x < b.x) || (a.x == b.x && a.y < b.y));\n}\nvoid Up(point &a, point &b, int i) {\n  if (a.x == b.x)\n    up = max(a.y, b.y);\n  else\n    up = (long long)floor((a.x - i + 0.0) * (a.y - b.y) / (b.x - a.x)) + a.y;\n  if (b.x == i) l = (l + 1) % n;\n}\nvoid Down(point &a, point &b, int i) {\n  if (a.x == b.x)\n    down = min(a.y, b.y);\n  else\n    down = (long long)ceil((a.x - i + 0.0) * (a.y - b.y) / (b.x - a.x)) + a.y;\n  if (b.x == i) r = (r - 1 + n) % n;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int L = 0, R = 0;\n  for (int i = 0; i < n; ++i) {\n    a[i].read();\n    a[i].x += 1000000;\n    a[i].y += 1000000;\n  }\n  long long S = 0;\n  for (int i = 0; i < n; ++i) S += (a[i] * a[(i + 1) % n]);\n  if (S > 0) reverse(a, a + n);\n  for (int i = 0; i < n; ++i) {\n    if (cmp(a[i], a[L])) L = i;\n    if (cmp(a[R], a[i])) R = i;\n  }\n  int M1 = a[L].x, M2 = a[R].x;\n  l = L, r = L;\n  long double a1 = 0;\n  for (int i = M1; i <= M2; ++i) {\n    int j = (l + 1) % n, k = (r - 1 + n) % n;\n    Up(a[l], a[j], i);\n    Down(a[r], a[k], i);\n    if (up + 1 < down) continue;\n    c[i] = up - down + 1.0;\n    second[i] = 1.0 * up * (up + 1) / 2 - 1.0 * down * (down - 1) / 2;\n    q[i] = 1.0 * up * (up + 1) * (2 * up + 1) / 6 -\n           1.0 * down * (down - 1) * (2 * down - 1) / 6;\n    a1 += c[i];\n  }\n  long double a2 = 0, a3 = 0, a4 = 0, a5 = 0;\n  for (int i = M1; i <= M2; ++i) {\n    a2 += q[i] / (a1 - 1), a3 += second[i];\n    a4 += c[i] * i * i / (a1 - 1), a5 += c[i] * i;\n  }\n  long double res =\n      (a2 + a4) - (a3 / (a1 - 1)) * (a3 / a1) - (a5 / (a1 - 1)) * (a5 / a1);\n  printf(\"%.15lf\", (double)res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 2e6 + 10;\nconst double eps = 1e-11;\nint n, x[MAXN], y[MAXN];\ndouble l[MAXM], r[MAXM];\nvoid get(int x1, int y1, int x2, int y2) {\n  if (x1 > x2) swap(x1, x2), swap(y1, y2);\n  if (x1 == x2) {\n    l[x1] = min(l[x1], 1.0 * y1);\n    r[x1] = max(r[x1], 1.0 * y2);\n  } else {\n    for (int i = x1; i <= x2; ++i) {\n      double k = 1.0 * (y2 - y1) * (i - x1) / (x2 - x1) + y1;\n      l[i] = min(l[i], k);\n      r[i] = max(r[i], k);\n    }\n  }\n}\nint tot = 0;\ndouble tx[MAXM], ts[MAXM], tss[MAXM], ans = 0, size, sum;\nvoid work() {\n  for (int i = 0; i < MAXM; ++i) l[i] = 1e9, r[i] = 0;\n  for (int i = 0; i < n; ++i) get(x[i], y[i], x[(i + 1) % n], y[(i + 1) % n]);\n  tot = size = sum = 0;\n  for (int i = 0; i < MAXM; ++i)\n    if (l[i] < 1e8) {\n      int st = (int)(l[i] - eps) + 1, ed = (int)(r[i] + eps);\n      tx[tot] = i;\n      ts[tot] = ed - st + 1;\n      tss[tot] = tx[tot] * ts[tot];\n      tot++;\n    }\n  for (int i = 0; i < tot; ++i) size += ts[i], sum += tss[i];\n  for (int i = 0; i < tot; ++i)\n    ans += tss[i] * tx[i] * (size - ts[i]) - (tss[i] * (sum - tss[i]));\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n    cin >> x[i] >> y[i], x[i] += MAXM / 2, y[i] += MAXM / 2;\n  work();\n  for (int i = 0; i < n; ++i) swap(x[i], y[i]);\n  work();\n  ans /= size * (size - 1);\n  printf(\"%.6lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100100;\nstruct Point {\n  long long x, y;\n  bool operator<(const Point& o) const { return x < o.x; }\n};\nlong long floor(long long a, long long b) {\n  return a >= 0 ? a / b : (a - b + 1) / b;\n}\nlong long ceil(long long a, long long b) {\n  return a >= 0 ? (a + b - 1) / b : a / b;\n}\nlong long floor(const Point& a, const Point& b, long long x) {\n  return a.y + floor((b.y - a.y) * (x - a.x), b.x - a.x);\n}\nlong long ceil(const Point& a, const Point& b, long long x) {\n  return a.y + ceil((b.y - a.y) * (x - a.x), b.x - a.x);\n}\ndouble gao(vector<Point> v) {\n  int n = v.size();\n  int x1 = min_element(v.begin(), v.end())->x;\n  int x2 = max_element(v.begin(), v.end())->x;\n  vector<Point> y1, y2;\n  rotate(v.begin(), min_element(v.begin(), v.end()), v.end());\n  for (int i = 1;; ++i) {\n    if (y1.empty()) {\n      if (v[i].x > x1) {\n        y1.push_back(v[i - 1]);\n      } else {\n        continue;\n      }\n    }\n    y1.push_back(v[i]);\n    if (v[i].x == x2) {\n      break;\n    }\n  }\n  for (int i = n - 1;; --i) {\n    if (y2.empty()) {\n      if (v[i].x > x1) {\n        y2.push_back(v[(i + 1) % n]);\n      } else {\n        continue;\n      }\n    }\n    y2.push_back(v[i]);\n    if (v[i].x == x2) {\n      break;\n    }\n  }\n  if (y1[0].y > y2[0].y || (y1[0].y == y2[0].y && y1[1].y > y2[1].y)) {\n    swap(y1, y2);\n  }\n  vector<long long> x(x2 - x1 + 1, 0);\n  int k1 = 1, k2 = 1;\n  for (int i = x1; i <= x2; ++i) {\n    if (y1[k1].x < i) {\n      ++k1;\n    }\n    if (y2[k2].x < i) {\n      ++k2;\n    }\n    x[i - x1] = floor(y2[k2 - 1], y2[k2], i) - ceil(y1[k1 - 1], y1[k1], i) + 1;\n  }\n  long long cnt = 0, sx = 0;\n  for (int i = 0; i < (int)x.size(); ++i) {\n    cnt += x[i];\n    sx += i * x[i];\n  }\n  double sum = 0;\n  for (int i = 0; i < (int)x.size(); ++i) {\n    sum += (cnt - 1.0) * x[i] * i * i;\n    sum -= 1.0 * x[i] * i * (sx - i);\n  }\n  return sum / cnt / (cnt - 1);\n}\nint main() {\n  int n, x, y;\n  double ans = 0;\n  vector<Point> v;\n  scanf(\"%d\", &n);\n  v.resize(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    v[i].x = x;\n    v[i].y = y;\n  }\n  ans = gao(v);\n  for (int i = 0; i < n; ++i) {\n    swap(v[i].x, v[i].y);\n  }\n  ans += gao(v);\n  printf(\"%.10lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T LOW_BIT(T n);\ntemplate <class T>\ninline int COUNT_BIT(T n);\ntemplate <class T>\ninline T GCD(T a, T b);\ntemplate <class T>\ninline T LCM(T a, T b);\nbool isUpperCase(char c);\nbool isLowerCase(char c);\nbool isLetter(char c);\nbool isDigit(char c);\nchar toLowerCase(char c);\nchar toUpperCase(char c);\ntemplate <class T>\nstring toString(T n);\ntemplate <class T>\nvoid stoa(const string &s, int &n, T A[]);\ntemplate <class T>\nvoid atos(int n, T A[], string &s);\ntemplate <class T>\nvoid atov(int n, T A[], vector<T> &vi);\ntemplate <class T>\nvoid vtoa(const vector<T> &vi, int &n, T A[]);\ntemplate <class T>\nvoid stov(const string &s, vector<T> &vi);\ntemplate <class T>\nvoid vtos(const vector<T> &vi, string &s);\ntemplate <class T>\ninline vector<pair<T, int> > factorize(T n);\nint64_t inverse_mod(int64_t a, int64_t mod);\nstring testCaseOutTemp = \"Case #%d: \";\nint numThread = 4;\nvoid initProgram() {}\nclass Task {\n public:\n  ostringstream out;\n  int testcase;\n  int N;\n  int X[100010];\n  int Y[100010];\n  int64_t lo[2 * 1000010];\n  int64_t hi[2 * 1000010];\n  int64_t a[2 * 1000010];\n  int64_t sum[2 * 1000010];\n  double T[2 * 1000010];\n  double P[2 * 1000010];\n  double Q[2 * 1000010];\n  int64_t area() {\n    int64_t a = 0, b = 0;\n    for (int i = 0, __e__ = (int)(N); i < __e__; ++i) {\n      a += int64_t(X[i]) * int64_t(Y[(i + 1) % N]);\n      b += int64_t(Y[i]) * int64_t(X[(i + 1) % N]);\n    }\n    return a - b;\n  }\n  void readInput() {\n    scanf(\"%d\", &N);\n    for (int i = 0, __e__ = (int)(N); i < __e__; ++i) {\n      scanf(\"%d %d\", X + i, Y + i);\n      X[i] += 1000010;\n      Y[i] += 1000010;\n    }\n  }\n  void pre() {\n    int64_t ar = area();\n    if (ar > 0) {\n      reverse(X, X + N);\n      reverse(Y, Y + N);\n    }\n    memset(lo, 0, sizeof lo);\n    for (int i = 0, __e__ = (int)(2 * 1000010); i < __e__; ++i) hi[i] = -1;\n    for (int i = 0, __e__ = (int)(N); i < __e__; ++i) {\n      int next = (i + 1) % N;\n      int64_t A = -(Y[i] - Y[next]);\n      int64_t B = (X[i] - X[next]);\n      int64_t C = A * int64_t(X[i]) + B * int64_t(Y[i]);\n      if (X[i] == X[next]) {\n        lo[X[i]] = min(Y[i], Y[next]);\n        hi[X[i]] = max(Y[i], Y[next]);\n      } else if (X[i] < X[next]) {\n        for (int x = (X[i]), __e__ = (int)(X[next]); x <= __e__; ++x) {\n          hi[x] = (-A * int64_t(x) + C) / B;\n        }\n      } else {\n        for (int x = (X[next]), __e__ = (int)(X[i]); x <= __e__; ++x) {\n          int64_t temp = (-A * int64_t(x) + C);\n          lo[x] = temp / B;\n          if (temp % B != 0) {\n            lo[x]++;\n          }\n        }\n      }\n    }\n  }\n  double calcs() {\n    for (int i = 0, __e__ = (int)(2 * 1000010); i < __e__; ++i) {\n      a[i] = hi[i] - lo[i] + 1LL;\n    }\n    sum[0] = a[0];\n    for (int i = (1), __e__ = (int)(2 * 1000010 - 1); i <= __e__; ++i) {\n      sum[i] = a[i] + sum[i - 1];\n    }\n    T[1] = a[0];\n    P[2] = a[1] + 3 * a[0];\n    T[2] = T[1] + P[2];\n    for (int i = (3), __e__ = (int)(2 * 1000010); i <= __e__; ++i) {\n      Q[i] = a[i - 1] + 2.0 * sum[i - 2];\n      P[i] = P[i - 1] + Q[i];\n      T[i] = T[i - 1] + P[i];\n    }\n    double ss = 0;\n    for (int i = (1), __e__ = (int)(2 * 1000010); i <= __e__; ++i) {\n      ss += (double)a[i] * T[i];\n    }\n    return ss;\n  }\n  void process() {\n    double ss = 0;\n    pre();\n    ss += calcs();\n    for (int i = 0, __e__ = (int)(N); i < __e__; ++i) {\n      swap(X[i], Y[i]);\n    }\n    pre();\n    ss += calcs();\n    int64_t cnt = sum[2 * 1000010 - 1];\n    out << fixed << ss / (double)cnt / (double)(cnt - 1LL);\n  }\n};\nint main() {\n  srand(time(0));\n  initProgram();\n  int ntest = 1;\n  {} {\n    for (int i = 0, __e__ = (int)(ntest); i < __e__; ++i) {\n      cerr << \"processing test: \" << i + 1 << endl;\n      Task *pT = new Task();\n      pT->testcase = i + 1;\n      pT->readInput();\n      pT->process();\n      cout << pT->out.str();\n      delete pT;\n    }\n  }\n}\ntemplate <class T>\ninline T LOW_BIT(T n) {\n  return (n ^ (n - 1)) & n;\n}\ntemplate <class T>\ninline int COUNT_BIT(T n) {\n  return (n == 0) ? 0 : (1 + COUNT_BIT(n & (n - 1)));\n}\ntemplate <class T>\ninline T GCD(T a, T b) {\n  if (a < 0) return GCD(-a, b);\n  if (b < 0) return GCD(a, -b);\n  return (b == 0) ? a : GCD(b, a % b);\n}\ntemplate <class T>\ninline T LCM(T a, T b) {\n  if (a < 0) return LCM(-a, b);\n  if (b < 0) return LCM(a, -b);\n  return a * (b / GCD(a, b));\n}\nbool isUpperCase(char c) { return c >= 'A' && c <= 'Z'; }\nbool isLowerCase(char c) { return c >= 'a' && c <= 'z'; }\nbool isLetter(char c) {\n  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\nbool isDigit(char c) { return c >= '0' && c <= '9'; }\nchar toLowerCase(char c) { return (isUpperCase(c)) ? (c + 32) : c; }\nchar toUpperCase(char c) { return (isLowerCase(c)) ? (c - 32) : c; }\ntemplate <class T>\nstring toString(T n) {\n  ostringstream ost;\n  ost << n;\n  ost.flush();\n  return ost.str();\n}\ntemplate <class T>\ninline vector<pair<T, int> > factorize(T n) {\n  vector<pair<T, int> > R;\n  for (T i = 2; n > 1;) {\n    if (n % i == 0) {\n      int C = 0;\n      for (; n % i == 0; C++, n /= i)\n        ;\n      R.push_back(make_pair(i, C));\n    }\n    i++;\n    if (i > n / i) i = n;\n  }\n  if (n > 1) R.push_back(make_pair(n, 1));\n  return R;\n}\ntemplate <class T>\nvoid stoa(const string &s, int &n, T A[]) {\n  n = 0;\n  istringstream sin(s);\n  for (T v; sin >> v; A[n++] = v)\n    ;\n}\ntemplate <class T>\nvoid atos(int n, T A[], string &s) {\n  ostringstream sout;\n  for (int i = 0; i < n; i++) {\n    if (i > 0) sout << ' ';\n    sout << A[i];\n  }\n  s = sout.str();\n}\ntemplate <class T>\nvoid atov(int n, T A[], vector<T> &vi) {\n  vi.clear();\n  for (int i = 0; i < n; i++) vi.push_back(A[i]);\n}\ntemplate <class T>\nvoid vtoa(const vector<T> &vi, int &n, T A[]) {\n  n = vi.size();\n  for (int i = 0; i < n; i++) A[i] = vi[i];\n}\ntemplate <class T>\nvoid stov(const string &s, vector<T> &vi) {\n  vi.clear();\n  istringstream sin(s);\n  for (T v; sin >> v; vi.push_bakc(v))\n    ;\n}\ntemplate <class T>\nvoid vtos(const vector<T> &vi, string &s) {\n  ostringstream sout;\n  for (int i = 0; i < vi.size(); i++) {\n    if (i > 0) sout << ' ';\n    sout << vi[i];\n  }\n  s = sout.str();\n}\nstruct extended_gcd_res {\n  int64_t x;\n  int64_t y;\n  extended_gcd_res(int64_t _x, int64_t _y) {\n    x = _x;\n    y = _y;\n  }\n};\nextended_gcd_res extended_gcd(int64_t a, int64_t b) {\n  if (b == 0)\n    return extended_gcd_res(1, 0);\n  else {\n    int64_t q = a / b;\n    int64_t r = a - b * q;\n    extended_gcd_res res = extended_gcd(b, r);\n    return extended_gcd_res(res.y, res.x - q * res.y);\n  }\n}\nint64_t inverse_mod(int64_t a, int64_t mod) {\n  extended_gcd_res res = extended_gcd(mod, a);\n  if (res.y < 0) res.y += mod;\n  return res.y;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\nint n;\nint m;\nint x[100001];\nint y[100001];\nint gcd(int a, int b) { return a ? gcd(b % a, a) : b; }\nint up(pair<int, int> a, pair<int, int> b, int c) {\n  long long p = (long long)a.second * (b.first - a.first) +\n                (long long)(b.second - a.second) * (c - a.first);\n  long long q = b.first - a.first;\n  if (p < 0) return p / q;\n  return (p + q - 1) / q;\n}\nint down(pair<int, int> a, pair<int, int> b, int c) {\n  long long p = (long long)a.second * (b.first - a.first) +\n                (long long)(b.second - a.second) * (c - a.first);\n  long long q = b.first - a.first;\n  if (p > 0) return p / q;\n  return (p - q + 1) / q;\n}\ndouble calc() {\n  int a = 0, b = 0, c = 0, d = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] < x[a] || (x[i] == x[a] && y[i] < y[a])) a = i;\n    if (x[i] > x[b] || (x[i] == x[b] && y[i] < y[b])) b = i;\n    if (x[i] < x[c] || (x[i] == x[c] && y[i] > y[c])) c = i;\n    if (x[i] > x[d] || (x[i] == x[d] && y[i] > y[d])) d = i;\n  }\n  vector<pair<int, int> > v, w;\n  for (int i = a; i != b; i = (i + 1) % n) v.push_back(make_pair(x[i], y[i]));\n  v.push_back(make_pair(x[b], y[b]));\n  for (int i = d; i != c; i = (i + 1) % n) w.push_back(make_pair(x[i], y[i]));\n  w.push_back(make_pair(x[c], y[c]));\n  reverse((w).begin(), (w).end());\n  int i = 0, j = 0;\n  double s = 0, sx = 0, sxx = 0, ans = 0;\n  for (int c = x[a]; c <= x[b]; c++) {\n    while (v[i + 1].first < c) i++;\n    while (w[j + 1].first < c) j++;\n    int l = up(v[i], v[i + 1], c);\n    int r = down(w[j], w[j + 1], c);\n    int cur = r - l + 1;\n    ans += cur * (s * (c + 0.0) * c - 2 * sx * c + sxx);\n    s += cur;\n    sx += (c + 0.0) * cur;\n    sxx += ((c + 0.0) * (c + 0.0)) * cur;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d%d\", &x[i], &y[i]);\n  x[n] = x[0];\n  y[n] = y[0];\n  double sum = 0;\n  for (int i = 0; i < n; i++)\n    sum += (double)x[i] * y[i + 1] - (double)x[i + 1] * y[i];\n  if (sum < 0) {\n    reverse(x, x + n + 1);\n    reverse(y, y + n + 1);\n    sum = -sum;\n  }\n  sum /= 2;\n  double cnt = 0;\n  for (int i = 0; i < n; i++)\n    cnt += gcd(abs(x[i + 1] - x[i]), abs(y[i + 1] - y[i]));\n  cnt += (sum + 1 - cnt / 2);\n  double ans = calc();\n  for (int i = 0; i <= n; i++) swap(x[i], y[i]);\n  reverse(x, x + n + 1);\n  reverse(y, y + n + 1);\n  ans += calc();\n  printf(\"%.10f\\n\", ans / (cnt * (cnt - 1) / 2) / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 2e6 + 2e5;\nconst int N = M >> 1;\nconst int MX = 2e6;\nconst int D = 1e6;\ndouble L[M], R[M];\nint g[M];\nstruct pnt {\n  int x, y;\n  void input() { scanf(\"%d %d\", &x, &y); }\n} p[N];\nint n;\ndouble ans;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    p[i].input();\n    p[i].x += D, p[i].y += D;\n  }\n  function<void(int, double)> update = [&](int y, double x) {\n    L[y] = min(L[y], x);\n    R[y] = max(R[y], x);\n  };\n  for (int step = 0; step < 2; step++) {\n    for (int i = 0; i <= MX; i++) L[i] = M, R[i] = -1;\n    for (int i = 1; i <= n; i++) {\n      update(p[i].y, p[i].x);\n      int ni = i == n ? 1 : i + 1;\n      if (p[i].y == p[ni].y) continue;\n      double d = (p[ni].x - p[i].x) * 1.0 / (p[ni].y - p[i].y);\n      double cur;\n      cur = p[i].x;\n      for (int j = p[i].y + 1; j < p[ni].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n      cur = p[ni].x;\n      for (int j = p[ni].y + 1; j < p[i].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n    }\n    long long tot = 0;\n    for (int i = 0; i <= MX; i++) {\n      int lx = L[i] + 0.9999999;\n      int rx = R[i] + 0.0000001;\n      g[i] = rx >= lx ? rx - lx + 1 : 0;\n      tot += g[i];\n    }\n    double c = 0, d = 0, dd = 0;\n    for (int i = 0; i < MX; i++) {\n      double r = g[i] * 1.0 / (tot - 1);\n      d = d + dd + r;\n      dd = dd + r + r;\n      c = c + d;\n      ans += 1.0 * g[i + 1] / tot * c;\n    }\n    for (int i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  }\n  cout << fixed << setprecision(10) << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint N, X[maxn], Y[maxn];\ndouble S0, S1, S2;\nint p(int x) {\n  int ret = (((x)-1 + N) % N);\n  while (X[ret] == X[x] && Y[ret] == Y[x]) ret = (((ret)-1 + N) % N);\n  return ret;\n}\nint s(int x) {\n  int ret = (((x) + 1) % N);\n  while (X[ret] == X[x] && Y[ret] == Y[x]) ret = (((ret) + 1) % N);\n  return ret;\n}\nbool Work(int x, int &uu, int &dd, int X[], int Y[]) {\n  int u, d;\n  if (uu != dd) {\n    u = (X[p(uu)] > X[s(uu)] ? p(uu) : s(uu));\n    d = (X[p(dd)] > X[s(dd)] ? p(dd) : s(dd));\n  } else if (Y[p(uu)] > Y[s(uu)])\n    u = p(uu), d = s(uu);\n  else\n    u = s(uu), d = p(uu);\n  if (x > X[u]) return false;\n  double t, b;\n  t = Y[uu] +\n      floorl((long double)(Y[u] - Y[uu]) * (x - X[uu]) / (X[u] - X[uu]));\n  b = Y[dd] + ceill((long double)(Y[d] - Y[dd]) * (x - X[dd]) / (X[d] - X[dd]));\n  S0 += t - b + 1;\n  S1 += (t - b + 1) * (t + b) / 2;\n  S2 += (t * (t + 1) * (2 * t + 1) - (b - 1) * b * (2 * b - 1)) / 6;\n  if (x == X[u]) uu = u;\n  if (x == X[d]) dd = d;\n  return true;\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) scanf(\"%d%d\", &X[i], &Y[i]);\n  int Lu(0), Ld(0), Dl(0), Dr(0);\n  for (int i = 1; i < N; i++) {\n    if (X[Lu] > X[i] || X[Lu] == X[i] && Y[Lu] < Y[i]) Lu = i;\n    if (X[Ld] > X[i] || X[Ld] == X[i] && Y[Ld] > Y[i]) Ld = i;\n    if (Y[Dl] > Y[i] || Y[Dl] == Y[i] && X[Dl] > X[i]) Dl = i;\n    if (Y[Dr] > Y[i] || Y[Dr] == Y[i] && X[Dr] < X[i]) Dr = i;\n  }\n  double ans = 0;\n  for (int x = X[Lu], uu = Lu, dd = Ld; Work(x, uu, dd, X, Y); x++)\n    ;\n  ans += (S0 * S2 - S1 * S1) / (S0 * (S0 - 1)) * 2;\n  S0 = S1 = S2 = 0;\n  for (int y = Y[Dl], ll = Dl, rr = Dr; Work(y, rr, ll, Y, X); y++)\n    ;\n  ans += (S0 * S2 - S1 * S1) / (S0 * (S0 - 1)) * 2;\n  printf(\"%.10f\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst double eps = 1e-8, inf = 1e9;\nint n, li_n, evt;\nstruct point {\n  double x, y;\n  void init() { scanf(\"%lf %lf\", &x, &y); }\n} p[N];\nstruct line {\n  point s, t;\n  double gety(double x) { return s.y + (x - s.x) / (t.x - s.x) * (t.y - s.y); }\n} li[N];\nstruct event {\n  double t;\n  int id;\n} ev[N * 2];\ndouble minx, maxx;\nint ii, jj;\ndouble ans = 0.0;\nbool dcmp(double a, double b) { return fabs(a - b) < eps; }\nvoid addline(point s, point t) {\n  if (dcmp(s.x, t.x)) return;\n  if (t.x < s.x) swap(s, t);\n  li[++li_n] = (line){s, t};\n  ev[evt++] = (event){s.x, +li_n};\n  if (!dcmp(t.x, maxx)) ev[evt++] = (event){t.x, -li_n};\n}\nvoid deal(event e) {\n  if (e.id > 0) {\n    if (!ii)\n      ii = e.id;\n    else\n      jj = e.id;\n  } else {\n    if (ii == -e.id)\n      ii = 0;\n    else\n      jj = 0;\n  }\n}\nbool cmp_ev(const event& a, const event& b) {\n  if (dcmp(a.t, b.t)) return a.id < b.id;\n  return a.t < b.t;\n}\nvoid process() {\n  minx = inf, maxx = -inf;\n  p[0] = p[n];\n  for (int i = 1; i <= n; ++i) {\n    minx = min(minx, p[i].x);\n    maxx = max(maxx, p[i].x);\n  }\n  li_n = evt = 0;\n  for (int i = 1; i <= n; ++i) addline(p[i], p[i - 1]);\n  sort(ev, ev + evt, cmp_ev);\n  int evq = 0;\n  ii = jj = 0;\n  double sum = 0, gum = 0, tot = 0;\n  for (int x = minx; x <= maxx; ++x) {\n    while (evq != evt && dcmp(ev[evq].t, x)) deal(ev[evq++]);\n    if (!ii || !jj) ii = jj = 0;\n    double y0 = li[ii].gety(x);\n    double y1 = li[jj].gety(x);\n    if (y0 > y1) swap(y0, y1);\n    double cnt = floor(y1 + eps) - ceil(y0 - eps) + 1;\n    tot += cnt;\n    sum += cnt * x;\n    gum += cnt * x * x;\n  }\n  ans += 2.0 * gum / tot - 2.0 / tot / (tot - 1) * (sum * sum - gum);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) p[i].init();\n  process();\n  for (int i = 1; i <= n; ++i) swap(p[i].x, p[i].y);\n  process();\n  printf(\"%.10lf\\n\", ans / 2);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 101010;\nint n;\nclass Point {\n public:\n  int x, y;\n  Point() {}\n  Point(int x, int y) : x(x), y(y) {}\n  Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n} a[MAXN];\ndouble det(const Point &a, const Point &b) {\n  return 1.0 * a.x * b.y - 1.0 * a.y * b.x;\n}\nbool cmpx(const Point &a, const Point &b) {\n  if (a.x != b.x) return a.x < b.x;\n  return a.y < b.y;\n}\nint maxx, minx, maxy, miny;\nint minpos, mp1;\nint gup1, gup2;\nint gdw1, gdw2;\nint cnt[2010101];\ndouble sx, sx2;\ndouble ans;\nbool changed;\nvoid solve() {\n  int cury1, cury2;\n  cury1 = cury2 = a[minpos].y;\n  gup1 = gdw1 = minpos;\n  gup2 = minpos + 1;\n  gdw2 = minpos - 1;\n  if (gup2 > n) gup2 -= n;\n  if (gdw2 < 1) gdw2 += n;\n  changed = false;\n  if (1.0 * (a[gup2].y - a[gup1].y + 1e-8) * (1e-8 + a[gdw2].x - a[gdw1].x) <\n      1.0 * (1e-8 + a[gdw2].y - a[gdw1].y) * (1e-8 + a[gup2].x - a[gup1].x))\n    changed = true;\n  Point now;\n  double cnt = 0;\n  sx = sx2 = 0;\n  bool flag = true, flag1 = true;\n  for (int x1 = minx; x1 <= maxx; ++x1) {\n    while ((x1 > a[gup2].x ||\n            (x1 != maxx && a[gup1].x == x1 && a[gup1].x == a[gup2].x))) {\n      gup1 = gup2;\n      gup2++;\n      if (gup2 > n) gup2 -= n;\n    }\n    while ((x1 > a[gdw2].x ||\n            (x1 != maxx && a[gdw1].x == a[gdw2].x && a[gdw1].x == x1))) {\n      gdw1 = gdw2;\n      gdw2--;\n      if (gdw2 < 1) gdw2 += n;\n    }\n    if (flag)\n      if (!changed && a[gup1].y > a[gup2].y)\n        flag = false;\n      else if (changed && a[gdw1].y > a[gdw2].y)\n        flag = false;\n    if (x1 == minx && !changed) {\n      cury1 = max(cury1, a[gup1].y);\n      cury2 = min(cury2, a[gdw1].y);\n    }\n    if (x1 == minx && changed) {\n      cury1 = max(cury1, a[gdw1].y);\n      cury2 = min(cury2, a[gup1].y);\n    }\n    if (flag1)\n      if (changed && a[gup1].y < a[gup2].y)\n        flag1 = false;\n      else if (!changed && a[gdw1].y < a[gdw2].y)\n        flag1 = false;\n    now.x = x1;\n    now.y = cury1;\n    if (!changed) {\n      if (flag) {\n        now.y++;\n        while (det(now - a[gup2], now - a[gup1]) >= 0) now.y++;\n        cury1 = now.y - 1;\n      } else {\n        while (det(now - a[gup2], now - a[gup1]) < 0) now.y--;\n        cury1 = now.y;\n      }\n      now.y = cury2;\n      if (flag1) {\n        now.y--;\n        while (det(now - a[gdw2], now - a[gdw1]) <= 0) now.y--;\n        cury2 = now.y + 1;\n      } else {\n        while (det(now - a[gdw2], now - a[gdw1]) > 0) now.y++;\n        cury2 = now.y;\n      }\n    } else {\n      if (flag) {\n        now.y++;\n        while (det(now - a[gdw2], now - a[gdw1]) >= 0) now.y++;\n        cury1 = now.y - 1;\n      } else {\n        while (det(now - a[gdw2], now - a[gdw1]) < 0) now.y--;\n        cury1 = now.y;\n      }\n      now.y = cury2;\n      if (flag1) {\n        now.y--;\n        while (det(now - a[gup2], now - a[gup1]) <= 0) now.y--;\n        cury2 = now.y + 1;\n      } else {\n        while (det(now - a[gup2], now - a[gup1]) > 0) now.y++;\n        cury2 = now.y;\n      }\n    }\n    sx2 += 1.0 * (cury1 - cury2 + 1) * x1 * x1;\n    sx += 1.0 * (cury1 - cury2 + 1) * x1;\n    cnt += cury1 - cury2 + 1;\n  }\n  double key;\n  key = sx * sx;\n  key -= sx2 * cnt;\n  key = -key;\n  key /= cnt * (cnt - 1) / 2;\n  ans += key;\n}\nint top, down;\nint main() {\n  scanf(\"%d\", &n);\n  maxx = maxy = -1010101;\n  minx = miny = 1010101;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &a[i].x, &a[i].y);\n    maxx = max(a[i].x, maxx);\n    if (a[i].x < minx) {\n      minpos = i;\n      minx = a[i].x;\n    }\n    maxy = max(a[i].y, maxy);\n    if (a[i].y < miny) {\n      mp1 = i;\n      miny = a[i].y;\n    }\n  }\n  solve();\n  for (int i = 1; i <= n; ++i) {\n    swap(a[i].x, a[i].y);\n  }\n  minpos = mp1;\n  minx = miny;\n  maxx = maxy;\n  solve();\n  printf(\"%.10lf\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  int x, y;\n  double k, b;\n  friend double operator*(const point& A, const point& B) {\n    return 1.0 * A.x * B.y - 1.0 * A.y * B.x;\n  }\n} a[100005];\nint N, F[100005 * 20];\ndouble ans, S;\nvoid read(int& x) {\n  char c, n = 0;\n  for (; !isdigit(c = getchar());)\n    if (c == '-') n = 1;\n  for (x = 0; isdigit(c); c = getchar()) (x *= 10) += c - 48;\n  if (n) x = -x;\n}\nvoid init() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%d%d\", &a[i].x, &a[i].y);\n}\nvoid work() {\n  a[N + 1] = a[1], S = 0, memset(F, 0, sizeof(F));\n  double area = 0;\n  for (int i = 1; i <= N; i++) area += a[i] * a[i + 1];\n  if (area < -1e-9)\n    for (int i = 1; i + i <= N + 1; i++) swap(a[i], a[N + 2 - i]);\n  int mi = 1e9, ma = -1e9, l, r, t = 0;\n  auto inc = [&](int i) { return i < N ? i + 1 : 1; };\n  auto dec = [&](int i) { return i > 1 ? i - 1 : N; };\n  for (int i = 1; i <= N; i++) {\n    if (a[i].x < mi) mi = a[i].x, l = i;\n    if (a[i].x > ma) ma = a[i].x, r = i;\n    if (a[i].x != a[i + 1].x)\n      a[i].k = 1.0 * (a[i].y - a[i + 1].y) / (a[i].x - a[i + 1].x),\n      a[i].b = a[i].y - a[i].k * a[i].x;\n    else\n      F[a[i].x + int(1e6)] += abs(a[i].y - a[i + 1].y) + 1, a[i].k = 1e99;\n  }\n  for (int x = mi, i = l, j = l; x <= ma; x++) {\n    for (; dec(i) != r && a[dec(i)].x <= x; i = dec(i))\n      ;\n    for (; inc(j) != r && a[inc(j)].x <= x; j = inc(j))\n      ;\n    if (a[dec(i)].k >= 1e99 || a[j].k >= 1e99) continue;\n    F[x + int(1e6)] = floor(a[dec(i)].k * x + a[dec(i)].b + 1e-9) -\n                      ceil(a[j].k * x + a[j].b - 1e-9) + 1;\n  }\n  double u = 0, v = 0, w = 0;\n  for (int i = 0; i <= 2e6; i++)\n    w += v, v += 2 * u + F[i], u += F[i], ans += w * F[i], S += F[i];\n}\nvoid doit() {\n  work();\n  for (int i = 1; i <= N; i++) swap(a[i].x, a[i].y);\n  work();\n  printf(\"%.9f\\n\", 1.0 * ans / S / (S - 1));\n}\nint main() {\n  init();\n  doit();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = false;\nint n, m, k;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nlong long ln, lk, lm;\nint x[100005], y[100005];\nvector<double> mpx[2000005], mpy[2000005];\nvoid dd(int i, int j) {\n  int vx = x[j] - x[i], vy = y[j] - y[i];\n  if (vx == 0) {\n    mpx[x[i] + 1000000].push_back(y[i]);\n    mpx[x[i] + 1000000].push_back(y[j]);\n  } else {\n    for (int p = min(x[i], x[j]); p <= max(x[i], x[j]); p++) {\n      double t = 1.0 * (p - x[i]) * vy / vx + y[i];\n      mpx[p + 1000000].push_back(t);\n    }\n  }\n  if (vy == 0) {\n    mpy[y[i] + 1000000].push_back(x[i]);\n    mpy[y[i] + 1000000].push_back(x[j]);\n  } else {\n    for (int p = min(y[i], y[j]); p <= max(y[i], y[j]); p++) {\n      double t = 1.0 * (p - y[i]) * vx / vy + x[i];\n      mpy[p + 1000000].push_back(t);\n    }\n  }\n}\nvector<double> v;\ndouble ans;\ndouble total;\nvoid cal() {\n  double tmp = 0;\n  vector<double> vl;\n  vl.push_back(v[0]);\n  tmp = v[0];\n  for (int i = 1; i < v.size(); i++) {\n    double g = tmp * 2 + vl.back() + v[i];\n    vl.push_back(g);\n    tmp += v[i];\n  }\n  tmp = 0;\n  for (int i = 1; i < v.size(); i++) {\n    tmp += vl[i - 1];\n    ans += v[i] * tmp;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int(i) = 0; (i) < (int)(n); (i)++) {\n    scanf(\"%d%d\", x + i, y + i);\n  }\n  for (int(i) = 0; (i) < (int)(n); (i)++) {\n    dd(i, (i + 1) % n);\n  }\n  for (int i = 0; i < 2000005; i++)\n    if (!mpx[i].empty()) {\n      vector<double> p = mpx[i];\n      sort(p.begin(), p.end());\n      int h = floor(max(p[0], p.back()));\n      int l = ceil(min(p[0], p.back()));\n      v.push_back(h - l + 1);\n      total += v.back();\n    }\n  cal();\n  v.clear();\n  for (int i = 0; i < 2000005; i++)\n    if (!mpy[i].empty()) {\n      vector<double> p = mpy[i];\n      sort(p.begin(), p.end());\n      int h = floor(max(p[0], p.back()));\n      int l = ceil(min(p[0], p.back()));\n      v.push_back(h - l + 1);\n    }\n  cal();\n  double gg = 1.0 * total * (total - 1);\n  printf(\"%.10lf\\n\", ans / gg);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double finf = 1e208, eps = 1e-9;\nconst int Maxn = 100005, MaxN = 2000005, N = 1000000, inf = 999999999 + 208;\nint n;\ndouble ans = 0, min_y[MaxN], max_y[MaxN];\ndouble *miny = min_y + N, *maxy = max_y + N;\ninline int get() {\n  bool f = 0;\n  char ch;\n  while (!isdigit(ch = getchar())) f |= ch == '-';\n  int v = ch - 48;\n  while (isdigit(ch = getchar())) v = v * 10 + ch - 48;\n  return f ? -v : v;\n}\ntemplate <class T, class T2>\ninline void gmin(T &x, const T2 &y) {\n  if (x > y) x = y;\n}\ntemplate <class T, class T2>\ninline void gmax(T &x, const T2 &y) {\n  if (x < y) x = y;\n}\nstruct Point {\n  int x, y;\n} p[Maxn];\ndouble solve() {\n  int minx = inf, maxx = -inf;\n  for (int i = 1; i <= n; i++) gmin(minx, p[i].x), gmax(maxx, p[i].x);\n  for (int i = minx; i <= maxx; i++) miny[i] = finf, maxy[i] = -finf;\n  for (int i = 1; i <= n; i++) {\n    Point s = p[i], t = p[i == n ? 1 : i + 1];\n    if (s.x == t.x) {\n      gmin(miny[s.x], min(s.y, t.y));\n      gmax(maxy[s.x], max(s.y, t.y));\n    } else {\n      if (s.x > t.x) swap(s, t);\n      double y, a = 1. / (t.x - s.x);\n      for (int i = s.x; i <= t.x; i++) {\n        y = s.y + (i - s.x) * a * (t.y - s.y);\n        gmin(miny[i], y);\n        gmax(maxy[i], y);\n      }\n    }\n  }\n  double tot = 0, res = 0, s1 = 0, s2 = 0, s3 = 0, cnt;\n  for (int i = minx; i <= maxx; i++) {\n    tot += cnt = floor(maxy[i] + eps) - floor(miny[i] - eps);\n    res += cnt * (s1 * i * i - 2 * s2 * i + s3);\n    s1 += cnt;\n    s2 += cnt * i;\n    s3 += cnt * i * i;\n  }\n  res /= tot * (tot - 1) / 2;\n  return res;\n}\nint main() {\n  n = get();\n  for (int i = 1; i <= n; i++) p[i].x = get(), p[i].y = get();\n  ans += solve();\n  for (int i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  ans += solve();\n  printf(\"%.8lf\\n\", ans * 0.5);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// Croc Champ 2013 - Round 2\n// Problem D -- Ksusha and Square\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Solution {\n    InputReader reader;\n    PrintWriter writer;\n\n    Solution() {\n        reader = new InputReader();\n        writer = new PrintWriter(System.out);\n    }\n\n    public static void main(String[] args) {\n        new Solution().run();\n    }\n\n    class Point implements Comparable <Point> {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        Point flip() {\n            return new Point(y, x);\n        }\n\n        public int compareTo(Point o) {\n            if (x != o.x) {\n                return x - o.x;\n            }\n            return y - o.y;\n        }\n\n        Point subtract(Point o) {\n            return new Point(x - o.x, y - o.y);\n        }\n    }\n\n    long det(Point a, Point b) {\n        return (long)a.x * b.y - (long)a.y * b.x;\n    }\n\n    boolean isConvex(Point a, Point b, Point c) {\n        return det(b.subtract(a), c.subtract(b)) >= 0;\n    }\n\n    Point[] getConvex(Point[] points) {\n        ArrayList <Point> hull = new ArrayList <Point>();\n        for (Point p : points) {\n            while (hull.size() >= 2 && !isConvex(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p)) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        while (hull.size() >= 2 && hull.get(hull.size() - 1).x == hull.get(hull.size() - 2).x) {\n            hull.remove(hull.size() - 1);\n        }\n        return hull.toArray(new Point[0]);\n    }\n\n    Point[] reverse(Point[] points) {\n        int n = points.length;\n        Point[] ret = new Point[n];\n        for (int i = 0; i < n; ++ i) {\n            ret[i] = points[n - 1 - i];\n        }\n        return ret;\n    }\n\n    double solve(Point[] points) {\n        int n = points.length;\n        Arrays.sort(points);\n        Point[] down = getConvex(points);\n        Point[] up = reverse(getConvex(reverse(points)));\n        int xMin = down[0].x;\n        int xMax = down[down.length - 1].x;\n        long total = 0;\n        double sum = 0.0;\n        double squareSum = 0.0;\n        for (int x = xMin, i = 0, j = 0; x <= xMax; ++ x) {\n            while (i + 1 < down.length && down[i + 1].x < x) {\n                i ++;\n            }\n            while (j + 1 < up.length && up[j + 1].x < x) {\n                j ++;\n            }\n            int yMin = (int)Math.ceil((double)(x - down[i].x) / (down[i + 1].x - down[i].x) * (down[i + 1].y - down[i].y)) + down[i].y;\n            int yMax = (int)Math.floor((double)(x - up[j].x) / (up[j + 1].x - up[j].x) * (up[j + 1].y - up[j].y)) + up[j].y;\n            int count = yMax - yMin + 1;\n            total += count;\n            sum += (double)count * x;\n            squareSum += (double)count * x * x;\n        }\n        return (total * squareSum - sum * sum) / ((double)total * (total - 1));\n    }\n\n    public void run() {\n        try {\n            int n = reader.nextInt();\n            Point[] points = new Point[n];\n            for (int i = 0; i < n; ++ i) {\n                int x = reader.nextInt();\n                int y = reader.nextInt();\n                points[i] = new Point(x, y);\n            }\n            double answer = solve(points);\n            for (int i = 0; i < n; ++ i) {\n                points[i] = points[i].flip();\n            }\n            answer += solve(points);\n            writer.println(String.format(\"%.8f\", answer));\n        } catch (IOException ex) {\n        }\n        writer.close();\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    InputReader() {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    Integer nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\npair<int, int> a[100005];\nlong long ccw(pair<int, int> a, pair<int, int> b, pair<int, int> c) {\n  int dx1 = b.first - a.first;\n  int dy1 = b.second - a.second;\n  int dx2 = c.first - a.first;\n  int dy2 = c.second - a.second;\n  return 1ll * dx1 * dy2 - 1ll * dy1 * dx2;\n}\nint cnt[2000005], low[2000005], high[2000005];\nlong long tot = 0;\nlong double solve() {\n  memset(low, 0x3f, sizeof(low));\n  memset(high, 0, sizeof(high));\n  long long tmp = 0;\n  for (int i = 0; i < n; i++) {\n    bool swp = 0;\n    if (a[i] > a[i + 1]) {\n      swp = 1;\n      swap(a[i], a[i + 1]);\n    }\n    if (a[i].first == a[i + 1].first) {\n      low[a[i].first] = a[i].second;\n      high[a[i].first] = a[i + 1].second;\n    } else {\n      for (int j = a[i].first; j <= a[i + 1].first; j++) {\n        double t = 1.0 * (j - a[i].first) / (a[i + 1].first - a[i].first);\n        double p = t * (a[i + 1].second - a[i].second) + a[i].second;\n        low[j] = min(low[j], (int)ceil(p - 1e-10));\n        high[j] = max(high[j], (int)floor(p + 1e-10));\n      }\n    }\n    if (swp) swap(a[i], a[i + 1]);\n  }\n  long double ret = 0;\n  tot = 0;\n  for (int i = 0; i <= 2000000; i++) {\n    cnt[i] = max(0, high[i] - low[i] + 1);\n    tot += cnt[i];\n  }\n  long double t0 = 0, t1 = 0, t2 = 0;\n  for (int j = 0; j <= 2000000; j++) {\n    t0 += 1.0 * cnt[j] * j * j;\n    t1 += -2.0 * cnt[j] * j;\n    t2 += 1.0 * cnt[j];\n  }\n  for (int i = 0; i <= 2000000; i++) {\n    ret += 1.0 * cnt[i] * t0;\n    ret += 1.0 * cnt[i] * i * t1;\n    ret += 1.0 * cnt[i] * i * i * t2;\n  }\n  ret /= 2;\n  return ret;\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first >> a[i].second;\n    a[i].first += 1000000;\n    a[i].second += 1000000;\n  }\n  a[n] = a[0];\n  double ret = solve();\n  for (int i = 0; i <= n; i++) {\n    swap(a[i].first, a[i].second);\n  }\n  ret += solve();\n  ret /= tot;\n  ret /= tot - 1;\n  printf(\"%.10f\", ret);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst long double eps = 1e-9;\nconst int maxn = (int)1e5 + 10;\nstruct pt {\n  long long x, y;\n  pt() : x(0), y(0) {}\n  pt(long long x, long long y) : x(x), y(y) {}\n  void read() { scanf(\"%I64d%I64d\", &x, &y); }\n};\ninline pt operator+(pt p1, pt p2) { return pt(p1.x + p2.x, p1.y + p2.y); }\ninline pt operator-(pt p1, pt p2) { return pt(p1.x - p2.x, p1.y - p2.y); }\ninline long long vect(pt p1, pt p2) { return p1.x * p2.y - p1.y * p2.x; }\ninline bool upper(pt left, pt right, pt p) {\n  return vect(right - left, p - left) > 0;\n}\ninline bool lower(pt left, pt right, pt p) {\n  return vect(right - left, p - left) < 0;\n}\ninline bool operator<(pt p1, pt p2) {\n  return make_pair(p1.x, p1.y) < make_pair(p2.x, p2.y);\n}\ninline long long sum(long long x) {\n  if (x > 0) return (x * (x + 1) * (2 * x + 1)) / 6;\n  if (x < 0) {\n    return -sum(-x - 1);\n  }\n  return 0;\n}\npt a[maxn];\nvector<int> up, down;\npt S;\nlong double S2 = 0;\nlong double N = 0;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; (i) < (n); ++i) a[i].read();\n  sort(a, a + n);\n  int xmin = a[0].x;\n  int xmax = a[n - 1].x;\n  up.push_back(0), down.push_back(0);\n  for (int i = 1; i < n - 1; i++) {\n    if (upper(a[0], a[n - 1], a[i]))\n      up.push_back(i);\n    else\n      down.push_back(i);\n  }\n  int iup = 0, idown = 0;\n  up.push_back(n - 1), down.push_back(n - 1);\n  while (a[up[iup]].x == a[0].x) iup += 1;\n  iup -= 1;\n  int downEnd = ((int)(down).size()) - 1;\n  while (a[down[downEnd]].x == a[n - 1].x) downEnd -= 1;\n  downEnd += 1;\n  long long ymin = 0, ymax = 0;\n  for (int x = xmin; x <= xmax; x++) {\n    if (x > xmin && x < xmax) {\n      while (!upper(a[up[iup]], a[up[iup + 1]], pt(x, ymax))) ymax += 1;\n      while (upper(a[up[iup]], a[up[iup + 1]], pt(x, ymax))) ymax -= 1;\n      while (!lower(a[down[idown]], a[down[idown + 1]], pt(x, ymin))) ymin -= 1;\n      while (lower(a[down[idown]], a[down[idown + 1]], pt(x, ymin))) ymin += 1;\n    } else if (x == xmin) {\n      ymin = a[0].y;\n      ymax = a[up[iup]].y;\n    } else if (x == xmax) {\n      ymax = a[n - 1].y;\n      ymin = a[down[downEnd]].y;\n    }\n    N += ymax - ymin + 1;\n    S = S + pt((ymax - ymin + 1) * x, ((ymax - ymin + 1) * (ymin + ymax)) >> 1);\n    S2 += (ymax - ymin + 1) * (long long)x * x + sum(ymax) - sum(ymin - 1);\n    if (a[up[iup + 1]].x == x) iup += 1;\n    if (a[down[idown + 1]].x == x) idown += 1;\n  }\n  long double RES =\n      (S2 - (S.x * (long double)S.x + S.y * (long double)S.y) / N) / (N - 1);\n  RES = RES;\n  printf(\"%.18lf\\n\", (double)RES);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nstruct poi {\n  ll x, y;\n  poi operator-(poi p) { return {x - p.x, y - p.y}; }\n  bool operator<(poi p) const { return tie(x, y) < tie(p.x, p.y); }\n  ll cross(poi p) { return x * p.y - y * p.x; }\n};\nll xmul(poi a, poi b, poi c) { return (b - a).cross(c - a); }\nusing vp = vector<poi>;\nvp convex(vp v) {\n  sort(v.begin(), v.end());\n  vp r;\n  for (int i = 0; i < v.size(); i++) {\n    while (r.size() > 1 && xmul(*++r.rbegin(), v[i], *r.rbegin()) >= 0)\n      r.pop_back();\n    r.push_back(v[i]);\n  }\n  int d = r.size();\n  for (int i = (int)v.size() - 2; i >= 0; i--) {\n    while (r.size() > d && xmul(*++r.rbegin(), v[i], *r.rbegin()) >= 0)\n      r.pop_back();\n    if (i != 0) r.push_back(v[i]);\n  }\n  return r;\n}\nll f(ll a, ll b) {\n  if (a >= 0) return a / b;\n  return a / b - bool(a % b);\n}\nll g(ll a, ll b) { return f(a + b - 1, b); }\nld solve(vp v) {\n  v = convex(v);\n  v.push_back(v[0]);\n  vp up, down;\n  for (int i = 0; i < v.size(); i++)\n    if (!i || v[i].x > v[i - 1].x)\n      down.push_back(v[i]);\n    else\n      break;\n  while (v.back().x == (++v.rbegin())->x) v.pop_back();\n  reverse(v.begin(), v.end());\n  for (int i = 0; i < v.size(); i++)\n    if (!i || v[i].x > v[i - 1].x)\n      up.push_back(v[i]);\n    else\n      break;\n  int j = 0, k = 0;\n  vector<pii> xs;\n  ld c = 0, s = 0, s2 = 0;\n  for (int i = up[0].x; i <= up.back().x; i++) {\n    while (up[j + 1].x < i) j++;\n    while (down[k + 1].x < i) k++;\n    ll u = f((up[j + 1].y - up[j].y) * (i - up[j].x), up[j + 1].x - up[j].x) +\n           up[j].y;\n    ll d = g((down[k + 1].y - down[k].y) * (i - down[k].x),\n             down[k + 1].x - down[k].x) +\n           down[k].y;\n    xs.push_back({i, u - d + 1});\n    c += u - d + 1;\n    s += i * (u - d + 1);\n    s2 += ld(i) * i * (u - d + 1);\n  }\n  ld ret = 0;\n  for (pii p : xs) {\n    ret += ld(p.first) * p.first * c * p.second;\n    ret += -2.0L * p.first * s * p.second;\n    ret += s2 * p.second;\n  }\n  return ret / c / (c - 1);\n}\nint main() {\n  int n;\n  cin >> n;\n  vp v;\n  while (n--) {\n    poi p;\n    cin >> p.x >> p.y;\n    v.push_back(p);\n  }\n  ld ans = 0;\n  for (int t = 0; t < 2; t++) {\n    ans += solve(v);\n    for (auto &p : v) swap(p.x, p.y);\n  }\n  cout << fixed << setprecision(9) << ans / 2 << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace orz {\nconst char *LL_SPECIFIER = \"%I64d\";\nconst long double eps = 1e-9;\ninline void read(int &x) { scanf(\"%d\", &x); }\ninline void read(char *x) { scanf(\"%s\", x); }\ntemplate <typename T1, typename T2>\ninline void read(T1 &x1, T2 &x2) {\n  read(x1);\n  read(x2);\n}\ntemplate <typename T1, typename T2, typename T3>\ninline void read(T1 &x1, T2 &x2, T3 &x3) {\n  read(x1);\n  read(x2);\n  read(x3);\n}\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline void read(T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\n  read(x1);\n  read(x2);\n  read(x3);\n  read(x4);\n}\ninline void write(const int x) { printf(\"%d\", x); }\ninline void write(const long long x) { printf(LL_SPECIFIER, x); }\ninline void write(const double x) { printf(\"%.15lf\", x); }\ninline void write(const long double x) { write((double)x); }\ntemplate <typename T>\ninline void writeln(T x) {\n  write(x);\n  putchar('\\n');\n}\ntemplate <typename T>\ninline std::set<T> &operator<<(std::set<T> &S, const T a) {\n  S.insert(a);\n  return S;\n}\n}  // namespace orz\nusing namespace orz;\nstruct dat {\n  long double x, s, t, sy, sy2;\n} a[2000086];\nint n, x[100086], y[100086];\nlong double l[2000086], r[2000086], ss, st;\ninline void work(int x, int y, int xx, int yy) {\n  if (x > xx) {\n    std::swap(x, xx);\n    std::swap(y, yy);\n  }\n  if (x == xx) {\n    if (y < l[x]) l[x] = y;\n    if (yy > r[x]) r[x] = yy;\n  } else\n    for (int cx = (x); cx <= (xx); ++cx) {\n      long double k = (double)(yy - y) * (cx - x) / (xx - x) + y;\n      if (k < l[cx]) l[cx] = k;\n      if (k > r[cx]) r[cx] = k;\n    }\n}\ninline long double go() {\n  long double ans = 0;\n  for (int i = (0); i < (2000086); ++i) {\n    l[i] = 2000086;\n    r[i] = 0;\n  }\n  for (int i = (1); i <= (n); ++i) work(x[i], y[i], x[i + 1], y[i + 1]);\n  int m = 0;\n  for (int i = (0); i < (2000086); ++i)\n    if (l[i] < 2000086) {\n      int L = (int)(l[i] - eps) + 1, R = (int)(r[i] + eps);\n      ++m;\n      a[m].x = i;\n      a[m].s = R - L + 1;\n      a[m].t = a[m].x * a[m].s;\n    }\n  ss = 0;\n  st = 0;\n  for (int i = (1); i <= (m); ++i) {\n    ss += a[i].s;\n    st += a[i].t;\n  }\n  for (int i = (1); i <= (m); ++i)\n    ans += a[i].t * a[i].x * (ss - a[i].s) - a[i].t * (st - a[i].t);\n  return ans;\n}\nint main() {\n  read(n);\n  for (int i = (1); i <= (n); ++i) {\n    read(x[i], y[i]);\n    x[i] += 2000086 / 2;\n    y[i] += 2000086 / 2;\n  }\n  x[n + 1] = x[1];\n  y[n + 1] = y[1];\n  long double ans = 0;\n  ans += go();\n  for (int i = (1); i <= (n + 1); ++i) std::swap(x[i], y[i]);\n  ans = (ans + go()) / (ss * (ss - 1));\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\nstruct Point {\n  int x, y;\n} d[200005];\nlong double ans, s2, s1, s0;\nint n;\nvoid Work() {\n  int t = 1, l = 1, r = n + 1;\n  s2 = s1 = s0 = 0;\n  for (int i = 1; i <= n; i++)\n    if (d[i].x < d[t].x) t = i;\n  for (int i = 1; i < t; i++) d[i + n] = d[i];\n  for (int i = 1; i <= n; i++) d[i] = d[i + t - 1];\n  while (d[l + 1].x == d[1].x) l++;\n  while (d[r - 1].x == d[1].x) r--;\n  l++;\n  r--;\n  d[n + 1] = d[1];\n  for (int x = d[1].x;; x++) {\n    while (d[l].x < x && l <= r) l++;\n    if (l > r) break;\n    while (d[r].x < x) r--;\n    double ly = ((double)d[l].y - d[l - 1].y) / (d[l].x - d[l - 1].x) *\n                    (x - d[l - 1].x) +\n                d[l - 1].y;\n    double ry = ((double)d[r].y - d[r + 1].y) / (d[r].x - d[r + 1].x) *\n                    (x - d[r + 1].x) +\n                d[r + 1].y;\n    if (ly > ry) swap(ly, ry);\n    ans += s2 * (floor(ry + eps) - ceil(ly - eps) + 1);\n    s0 += floor(ry + eps) - ceil(ly - eps) + 1;\n    s1 += s0;\n    s2 += s1 * 2 - s0;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &d[i].x, &d[i].y);\n  Work();\n  for (int i = 1; i <= n; i++) d[i].x = -d[i].x;\n  Work();\n  for (int i = 1; i <= n; i++) swap(d[i].x, d[i].y);\n  Work();\n  for (int i = 1; i <= n; i++) d[i].x = -d[i].x;\n  Work();\n  printf(\"%.20Lf\\n\", (double)(ans * 0.5 / (s0 * s0 - s0)));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Min[(1 << 21)];\nint Max[(1 << 21)];\nint X[(1 << 21)];\nint Y[(1 << 21)];\ndouble f(int n) {\n  int i, j;\n  for (i = (0); i < ((1 << 21)); ++i) {\n    Min[i] = (1 << 21);\n    Max[i] = 0;\n  }\n  for (i = (0); i < (n); ++i) {\n    int x1 = X[i];\n    int y1 = Y[i];\n    int x2 = X[(i + 1) % n];\n    int y2 = Y[(i + 1) % n];\n    if (pair<int, int>(x1, y1) > pair<int, int>(x2, y2)) {\n      swap(x1, x2);\n      swap(y1, y2);\n    }\n    if (x1 == x2) {\n      Min[x1] = min(Min[x1], y1 - 1);\n      Max[x1] = max(Max[x1], y2 + 1);\n      continue;\n    }\n    for (j = (x1); j < (x2 + 1); ++j) {\n      long long l = x2 - j;\n      long long r = j - x1;\n      long long d = x2 - x1;\n      long long v = y1 * l + y2 * r;\n      Min[j] = min(Min[j], int((v - 1) / d));\n      Max[j] = max(Max[j], int((v + d) / d));\n    }\n  }\n  long double sum0 = 0;\n  long double sum1 = 0;\n  long double sum2 = 0;\n  for (i = (0); i < ((1 << 21)); ++i)\n    if (Min[i] < Max[i]) {\n      long long cnt = Max[i] - Min[i] - 1;\n      long long value = i;\n      sum0 += cnt;\n      sum1 += cnt * value;\n      sum2 += cnt * value * value;\n    }\n  return sum0 < 1.5 ? 0.0 : (sum2 * sum0 - sum1 * sum1) / (sum0 * (sum0 - 1));\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int i, j;\n  for (i = (0); i < (n); ++i) scanf(\"%d%d\", &X[i], &Y[i]);\n  for (i = (0); i < (n); ++i) {\n    X[i] += (1 << 21) / 2;\n    Y[i] += (1 << 21) / 2;\n  }\n  double res = 0;\n  for (i = (0); i < (2); ++i) {\n    res += f(n);\n    for (j = (0); j < (n); ++j) swap(X[j], Y[j]);\n  }\n  printf(\"%.11lf\\n\", res);\n  return 0;\n};\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint N, X[maxn], Y[maxn];\ndouble S0, S1, S2;\nbool Work(int x, int &uu, int &dd, int X[], int Y[]) {\n  int u, d;\n  if (uu != dd) {\n    u = (X[(((uu)-1 + N) % N)] > X[(((uu) + 1) % N)] ? (((uu)-1 + N) % N)\n                                                     : (((uu) + 1) % N));\n    d = (X[(((dd)-1 + N) % N)] > X[(((dd) + 1) % N)] ? (((dd)-1 + N) % N)\n                                                     : (((dd) + 1) % N));\n  } else if (Y[(((uu)-1 + N) % N)] > Y[(((uu) + 1) % N)])\n    u = (((uu)-1 + N) % N), d = (((uu) + 1) % N);\n  else\n    u = (((uu) + 1) % N), d = (((uu)-1 + N) % N);\n  if (X[u] <= X[uu] || X[d] <= X[dd]) return false;\n  double t, b;\n  t = Y[uu] + floor(double(Y[u] - Y[uu]) * (x - X[uu]) / (X[u] - X[uu]));\n  b = Y[dd] + ceil(double(Y[d] - Y[dd]) * (x - X[dd]) / (X[d] - X[dd]));\n  S0 += t - b + 1;\n  S1 += (t - b + 1) * (t + b) / 2;\n  S2 += (t * (t + 1) * (2 * t + 1) - (b - 1) * b * (2 * b - 1)) / 6;\n  if (x == X[u]) uu = u;\n  if (x == X[d]) dd = d;\n  return true;\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) scanf(\"%d%d\", &X[i], &Y[i]);\n  int Lu(0), Ld(0), Dl(0), Dr(0);\n  for (int i = 1; i < N; i++) {\n    if (X[Lu] > X[i] || X[Lu] == X[i] && Y[Lu] < Y[i]) Lu = i;\n    if (X[Ld] > X[i] || X[Ld] == X[i] && Y[Ld] > Y[i]) Ld = i;\n    if (Y[Dl] > Y[i] || Y[Dl] == Y[i] && X[Dl] > X[i]) Dl = i;\n    if (Y[Dr] > Y[i] || Y[Dr] == Y[i] && X[Dr] < X[i]) Dr = i;\n  }\n  double ans = 0;\n  for (int x = X[Lu], uu = Lu, dd = Ld; Work(x, uu, dd, X, Y); x++)\n    ;\n  ans += (S0 * S2 - S1 * S1) / (S0 * (S0 - 1)) * 2;\n  S0 = S1 = S2 = 0;\n  for (int y = Y[Dl], ll = Dl, rr = Dr; Work(y, rr, ll, Y, X); y++)\n    ;\n  ans += (S0 * S2 - S1 * S1) / (S0 * (S0 - 1)) * 2;\n  printf(\"%.10f\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\nstruct Point {\n  int x, y;\n  int read() {\n    int ok = scanf(\"%d%d\", &x, &y);\n    return ok == 2;\n  }\n  Point() {}\n  Point(int _x, int _y) : x(_x), y(_y) {}\n  inline Point operator-(const Point &p) const {\n    return Point(x - p.x, y - p.y);\n  }\n  inline long long operator^(const Point &p) const {\n    return (long long)x * p.y - (long long)y * p.x;\n  }\n  inline bool operator<(const Point &p) const {\n    if (y != p.y) return y < p.y;\n    return x < p.x;\n  }\n  inline bool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\nconst int maxc = (int)1e6;\nint tmpCnts[maxc * 2 + 1], *cnts = tmpCnts + maxc + 1;\ninline double get(const Point &p1, const Point &p2, int y) {\n  return p1.x + (p2.x - p1.x) * (y - p1.y + 0.0) / (p2.y - p1.y);\n}\ndouble solve(Point *ps, int n) {\n  rotate(ps, min_element(ps, ps + n), ps + n);\n  ps[n] = ps[0];\n  long long S = 0;\n  for (int i = 0; i < n; i++) S += ps[i] ^ ps[i + 1];\n  if (S < 0) reverse(ps + 1, ps + n), S = -S;\n  int n0 = n;\n  n = 0;\n  for (int i = 0; i <= n0; i++) {\n    if (n && ps[i] == ps[n - 1]) continue;\n    if (n >= 2 && !((ps[n - 1] - ps[n - 2]) ^ (ps[i] - ps[n - 2]))) --n;\n    ps[n++] = ps[i];\n  }\n  --n;\n  int miny = maxc, maxy = -maxc;\n  for (int i = 0; i < n; i++)\n    miny = min(miny, ps[i].y), maxy = max(maxy, ps[i].y);\n  assert(ps[0].y == miny);\n  ps[n] = ps[0];\n  {\n    long long Sn = 0;\n    for (int i = 0; i < n; i++) Sn += ps[i] ^ ps[i + 1];\n    assert(S == Sn);\n    ps[n + 1] = ps[1];\n    for (int i = 0; i < n; i++)\n      assert((ps[i] - ps[i + 1]) ^ (ps[i] - ps[i + 2]));\n  }\n  double ans = 0;\n  long long sum = 0, cntSum = 0;\n  for (int y = miny, left = n, right = 0; y <= maxy; ++y) {\n    while (left > 0 && ps[left - 1].y < y) --left;\n    while (right < n && ps[right + 1].y < y) ++right;\n    assert(left > 0 && right < n);\n    int minx = (ps[left].y == ps[left - 1].y\n                    ? min(ps[left].x, ps[left - 1].x)\n                    : ceil(get(ps[left], ps[left - 1], y) - (1e-9)));\n    int maxx = (ps[right].y == ps[right + 1].y\n                    ? max(ps[right].x, ps[right + 1].x)\n                    : floor(get(ps[right], ps[right + 1], y) + (1e-9)));\n    assert(maxx >= minx - 1);\n    cnts[y] = maxx - minx + 1;\n    sum += (long long)cnts[y] * y;\n    ans += (long long)cnts[y] * y * y;\n    cntSum += cnts[y];\n  }\n  if (cntSum < 2) return 0;\n  ans -= (double)sum * sum / cntSum;\n  ans /= cntSum - 1;\n  ans *= 2;\n  return ans;\n}\nconst int maxn = (int)1e5;\nPoint ps[maxn + 2], ps0[maxn];\nint main() {\n  srand(rdtsc());\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    for (int i = 0; i < n; i++) assert(ps0[i].read());\n    double ans = 0;\n    for (int coord = 0; coord < 2; coord++) {\n      memcpy(ps, ps0, sizeof(ps[0]) * n);\n      ans += solve(ps, n);\n      for (int i = 0; i < n; i++) swap(ps0[i].x, ps0[i].y);\n    }\n    ans /= 2;\n    printf(\"%.18lf\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int co = 1000010;\nconst int N = 6 * co + 10;\nlong long yN[N], yd[N];\nlong long bn[42], bd[42];\nint pred[N];\nint last[2 * co + 10];\nint x[100010], y[100010];\nint m;\nvoid add(int xa, int ya, int xb, int yb) {\n  if (xa == xb) return;\n  if (xa > xb) {\n    int tmp = xa;\n    xa = xb;\n    xb = tmp;\n    tmp = ya;\n    ya = yb;\n    yb = tmp;\n  }\n  for (int xx = xa; xx <= xb; xx++) {\n    m++;\n    yN[m] = (long long)ya * (xb - xa) + (long long)(yb - ya) * (xx - xa);\n    yd[m] = xb - xa;\n    pred[m] = last[xx + co];\n    last[xx + co] = m;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d %d\", x + i, y + i);\n  double ans = 0.0;\n  for (int r = 0; r < 2; r++) {\n    x[n] = x[0];\n    y[n] = y[0];\n    m = 0;\n    for (int i = 0; i <= 2 * co; i++) last[i] = 0;\n    for (int i = 0; i < n; i++) add(x[i], y[i], x[i + 1], y[i + 1]);\n    double sum = 0, sq = 0, cnt = 0;\n    for (int xx = -co; xx <= co; xx++) {\n      int k = 0;\n      int j = last[xx + co];\n      while (j > 0) {\n        bn[k] = yN[j];\n        bd[k] = yd[j];\n        k++;\n        j = pred[j];\n      }\n      if (k == 0) continue;\n      for (int i = 0; i < k; i++)\n        for (int j = i + 1; j < k; j++)\n          if (bn[i] * bd[j] > bn[j] * bd[i]) {\n            long long tmp = bn[i];\n            bn[i] = bn[j];\n            bn[j] = tmp;\n            tmp = bd[i];\n            bd[i] = bd[j];\n            bd[j] = tmp;\n          }\n      long long up = bn[k - 1] / bd[k - 1];\n      while (up * bd[k - 1] > bn[k - 1]) up--;\n      while ((up + 1) * bd[k - 1] <= bn[k - 1]) up++;\n      long long down = bn[0] / bd[0];\n      while (down * bd[0] < bn[0]) down++;\n      while ((down - 1) * bd[0] >= bn[0]) down--;\n      cnt += 1.0 * (up - down + 1);\n      sum += 1.0 * xx * (up - down + 1);\n      sq += 1.0 * xx * xx * (up - down + 1);\n    }\n    ans += (sq - sum * sum / cnt) / (cnt - 1);\n    for (int i = 0; i < n; i++) {\n      int tmp = x[i];\n      x[i] = y[i];\n      y[i] = tmp;\n    }\n  }\n  printf(\"%.17lf\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_SIZE = 100000;\nconst int INF = 0x3f3f3f3f;\nstruct Point {\n  int x, y;\n};\ninline Point operator-(const Point& a, const Point& b) {\n  Point ans;\n  ans.x = a.x - b.x;\n  ans.y = a.y - b.y;\n  return ans;\n}\ninline long long det(const Point& a, const Point& b) {\n  return (long long)a.x * b.y - a.y * b.x;\n}\nint minn, maxn;\nint n;\nPoint data[MAX_SIZE * 2 + 10];\nlong double xsqtot, ysqtot, xtot, ytot;\nlong long cnt;\ninline void update(int x, int l, int r) {\n  if (l > r) return;\n  cnt += r - l + 1;\n  xsqtot += (long double)x * x * (r - l + 1);\n  ysqtot += ((long double)r * (r + 1) * ((r << 1) + 1) -\n             (long double)(l - 1) * l * (((l - 1) << 1) + 1)) /\n            6.0;\n  xtot += (long double)x * (r - l + 1);\n  ytot += (long double)(l + r) * (r - l + 1) / 2.0;\n}\ninline void findRange(int x, int& low, int& high) {\n  low = INF;\n  high = -INF;\n  for (int i = 1; i <= n; i++)\n    if (data[i].x == x) {\n      if (data[i].y < low) low = data[i].y;\n      if (data[i].y > high) high = data[i].y;\n    }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &data[i].x, &data[i].y);\n    data[i].y += 1000001;\n  }\n  long long tot = 0;\n  for (int i = 2; i < n; i++)\n    tot += det(data[i] - data[1], data[i + 1] - data[i]);\n  if (tot < 0) reverse(data + 1, data + n + 1);\n  minn = INF;\n  maxn = -INF;\n  for (int i = 1; i <= n; i++) {\n    if (data[i].x < minn) minn = data[i].x;\n    if (data[i].x > maxn) maxn = data[i].x;\n  }\n  int L = 1, R = n;\n  while (data[L].x != maxn) data[++R] = data[L++];\n  data[++R] = data[L];\n  int mid;\n  for (mid = L; data[mid].x != minn; mid++)\n    ;\n  int pl = mid, pr = mid;\n  for (int x = minn; x <= maxn; x++) {\n    int high, low;\n    if (x == minn || x == maxn)\n      findRange(x, low, high);\n    else {\n      while (pl > L && data[pl].x <= x) --pl;\n      while (pr < R && data[pr].x <= x) ++pr;\n      high = (int)(((long long)(x - data[pl + 1].x) *\n                        (data[pl].y - data[pl + 1].y) +\n                    (long long)data[pl + 1].y * (data[pl].x - data[pl + 1].x)) /\n                   (data[pl].x - data[pl + 1].x));\n      low = (int)(((long long)(x - data[pr - 1].x) *\n                       (data[pr].y - data[pr - 1].y) +\n                   (long long)data[pr - 1].y * (data[pr].x - data[pr - 1].x)) /\n                      (data[pr].x - data[pr - 1].x) +\n                  ((long long)(x - data[pr - 1].x) *\n                       (data[pr].y - data[pr - 1].y) %\n                       (data[pr].x - data[pr - 1].x) !=\n                   0));\n    }\n    update(x, low, high);\n  }\n  long double ans =\n      ((xsqtot + ysqtot) -\n       ((xtot * xtot - xsqtot) + (ytot * ytot - ysqtot)) / (cnt - 1)) /\n      cnt;\n  printf(\"%.10f\\n\", (double)ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  int x, y;\n} high, low, st, en, temp_up, temp_down;\nint n, k;\nlong long cntx[2000002], cnty[2000002], total = 0;\nvector<point> v, up, down;\nlong long check(point a, point b, point c) {\n  return 1ll * (b.x - a.x) * (c.y - a.y) - 1ll * (b.y - a.y) * (c.x - a.x);\n}\nsigned main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, x, y; i <= n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    v.push_back({x + 1000000, y + 1000000});\n  }\n  sort(v.begin(), v.end(),\n       [](point a, point b) { return a.x < b.x || (a.x == b.x && a.y < b.y); });\n  st = v[0], en = v.back();\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i != (int)v.size() - 1 && check(v[i], st, en) < 0) continue;\n    while (up.size() > 2 &&\n           check(up[up.size() - 1], up[up.size() - 2], v[i]) < 0) {\n      up.pop_back();\n    }\n    up.push_back(v[i]);\n  }\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i != (int)v.size() - 1 && check(v[i], st, en) > 0) continue;\n    while (down.size() > 2 &&\n           check(down[down.size() - 1], down[down.size() - 2], v[i]) > 0) {\n      down.pop_back();\n    }\n    down.push_back(v[i]);\n  }\n  high = low = {v[0].x + 1, v[0].y};\n  int cur = 0, mn = v[0].y, mx = v[0].y;\n  while (1) {\n    cur++;\n    if (v[cur].x == v[cur - 1].x) {\n      mx = max(mx, v[cur].y);\n      mn = min(mn, v[cur].y);\n    } else {\n      break;\n    }\n  }\n  high.y = mx;\n  low.y = mn;\n  cntx[v[0].x] = high.y - low.y + 1;\n  while (high.x <= v.back().x && low.x <= v.back().x) {\n    int k = lower_bound(up.begin(), up.end(), (point){high.x, 0},\n                        [](point a, point b) {\n                          return a.x < b.x || (a.x == b.x && a.y < b.y);\n                        }) -\n            up.begin();\n    temp_up = high;\n    while (check(up[k - 1], up[k], temp_up) <= 0) {\n      high = temp_up;\n      temp_up.y++;\n    }\n    while (check(up[k - 1], up[k], high) > 0) {\n      temp_up.y--;\n      high = temp_up;\n    }\n    k = lower_bound(down.begin(), down.end(), (point){low.x, 0},\n                    [](point a, point b) {\n                      return a.x < b.x || (a.x == b.x && a.y < b.y);\n                    }) -\n        down.begin();\n    temp_down = low;\n    while (check(down[k - 1], down[k], temp_down) >= 0) {\n      low = temp_down;\n      temp_down.y--;\n    }\n    while (check(down[k - 1], down[k], temp_down) < 0) {\n      temp_down.y++;\n      low = temp_down;\n    }\n    cntx[high.x] = high.y - low.y + 1;\n    high.x++;\n    low.x++;\n  }\n  up.clear();\n  down.clear();\n  sort(v.begin(), v.end(),\n       [](point a, point b) { return a.y < b.y || (a.y == b.y && a.x < b.x); });\n  st = v[0], en = v.back();\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i != (int)v.size() - 1 && check(v[i], st, en) < 0) continue;\n    while (up.size() > 2 &&\n           check(up[up.size() - 1], up[up.size() - 2], v[i]) < 0) {\n      up.pop_back();\n    }\n    up.push_back(v[i]);\n  }\n  for (int i = 0; i < (int)v.size(); i++) {\n    if (i != (int)v.size() - 1 && check(v[i], st, en) > 0) continue;\n    while (down.size() > 2 &&\n           check(down[down.size() - 1], down[down.size() - 2], v[i]) > 0) {\n      down.pop_back();\n    }\n    down.push_back(v[i]);\n  }\n  high = low = {v[0].x, v[0].y + 1};\n  cur = 0, mn = v[0].x, mx = v[0].x;\n  while (1) {\n    cur++;\n    if (v[cur].y == v[cur - 1].y) {\n      mx = max(mx, v[cur].x);\n      mn = min(mn, v[cur].x);\n    } else {\n      break;\n    }\n  }\n  low.x = mx;\n  high.x = mn;\n  cnty[v[0].y] = low.x - high.x + 1;\n  total += cnty[v[0].y];\n  while (high.y <= v.back().y && low.y <= v.back().y) {\n    k = lower_bound(up.begin(), up.end(), (point){0, high.y},\n                    [](point a, point b) {\n                      return a.y < b.y || (a.y == b.y && a.x < b.x);\n                    }) -\n        up.begin();\n    point temp_up = high, temp_down = low;\n    while (check(up[k - 1], up[k], temp_up) <= 0) {\n      high = temp_up;\n      temp_up.x--;\n    }\n    while (check(up[k - 1], up[k], high) > 0) {\n      temp_up.x++;\n      high = temp_up;\n    }\n    k = lower_bound(down.begin(), down.end(), (point){0, low.y},\n                    [](point a, point b) {\n                      return a.y < b.y || (a.y == b.y && a.x < b.x);\n                    }) -\n        down.begin();\n    while (check(down[k - 1], down[k], temp_down) >= 0) {\n      low = temp_down;\n      temp_down.x++;\n    }\n    while (check(down[k - 1], down[k], temp_down) < 0) {\n      temp_down.x--;\n      low = temp_down;\n    }\n    cnty[high.y] = low.x - high.x + 1;\n    total += cnty[high.y];\n    high.y++;\n    low.y++;\n  }\n  long long sumx = 0, sumy = 0;\n  long double sumx_square = 0, sumy_square = 0;\n  long double ansx = 0, ansy = 0;\n  for (long long j = 0; j <= 2e6; j++) {\n    sumx += j * cntx[j];\n    sumx_square += (long double)j * j / (total - 1) / 2 * cntx[j];\n    sumy += j * cnty[j];\n    sumy_square += (long double)j * j / (total - 1) / 2 * cnty[j];\n  }\n  for (long long i = 0; i <= 2e6; i++) {\n    ansx += (long double)(i * total - 2ll * sumx) / total * i / (total - 1) *\n            cntx[i] / 2;\n    ansy += (long double)(i * total - 2ll * sumy) / total * i / (total - 1) *\n            cnty[i] / 2;\n  }\n  ansx += sumx_square;\n  ansy += sumy_square;\n  long double t = ansx + ansy;\n  printf(\"%.10Lf\\n\", t);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100100][2];\nlong long round_ud(long long p, long long q, int dir) {\n  long long r = p / q, t = p % q;\n  if (t == 0) return r;\n  if (dir) {\n    if (t < 0)\n      return r;\n    else\n      return r + 1;\n  } else {\n    if (t < 0)\n      return r - 1;\n    else\n      return r;\n  }\n}\nint main() {\n  int l[2] = {-1, -1}, r[2] = {-1, -1};\n  int n, m = 0;\n  double sum[2] = {}, p1[2] = {}, p2[2] = {}, p0[2] = {}, cnt = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      scanf(\"%d\", &a[i][j]);\n      if (l[j] < 0 || a[i][j] < a[l[j]][j]) l[j] = i;\n      if (r[j] < 0 || a[i][j] > a[r[j]][j]) r[j] = i;\n    }\n  }\n  for (int j = 0; j < 2; j++) {\n    int s[2] = {l[j], l[j]}, mv[2] = {1, n - 1};\n    for (int k = 0; k < 2; k++) {\n      while (a[(s[k] + mv[k]) % n][j] == a[s[k]][j]) s[k] = (s[k] + mv[k]) % n;\n    }\n    double sc = abs(a[s[1]][j ^ 1] - a[s[0]][j ^ 1]) + 1;\n    cnt += sc * (sc - 1) / 2;\n    p0[j] = sc;\n    p1[j] = sc * a[l[j]][j];\n    p2[j] = sc * a[l[j]][j] * a[l[j]][j];\n    for (int x = a[l[j]][j] + 1; x <= a[r[j]][j]; x++) {\n      long long p[2], q[2];\n      for (int k = 0; k < 2; k++) {\n        while (a[s[k]][j] < x && a[(s[k] + mv[k]) % n][j] <= x)\n          s[k] = (s[k] + mv[k]) % n;\n        int px = a[s[k]][j], py = a[s[k]][j ^ 1];\n        int nx = a[(s[k] + mv[k]) % n][j], ny = a[(s[k] + mv[k]) % n][j ^ 1];\n        if (x == px)\n          p[k] = py, q[k] = 1;\n        else {\n          p[k] = 1LL * py * (nx - px) + 1LL * (x - px) * (ny - py);\n          q[k] = nx - px;\n        }\n      }\n      int large = 0;\n      if (p[0] * q[1] < p[1] * q[0]) large = 1;\n      double ty[2];\n      for (int k = 0; k < 2; k++) {\n        ty[k] = round_ud(p[k], q[k], k ^ large);\n      }\n      sc = ty[large] - ty[large ^ 1] + 1;\n      sum[j] += sc * (p2[j] - 2 * p1[j] * x + p0[j] * x * x);\n      cnt += sc * p0[j] + sc * (sc - 1) / 2;\n      p0[j] += sc;\n      p1[j] += sc * x;\n      p2[j] += sc * x * x;\n    }\n  }\n  printf(\"%.8f\\n\", 1.0 * (sum[0] + sum[1]) / cnt);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  double x, y;\n  point() { x = y = 0; }\n  point(double _x, double _y) { x = _x, y = _y; }\n  void read() { scanf(\"%lf%lf\", &x, &y); }\n  point operator-(point &a) { return point(x - a.x, y - a.y); }\n  double operator*(point a) { return x * a.y - y * a.x; }\n} a[200005];\nint n, l, r, p;\ndouble up, down, c[2000005], second[2000005], q[2000005];\nbool cmp(point &a, point &b) {\n  return ((a.x < b.x) || (a.x == b.x && a.y < b.y));\n}\nvoid Up(point &a, point &b, int i) {\n  if (a.x == b.x)\n    up = max(a.y, b.y);\n  else\n    up = floor((a.x - i) * (a.y - b.y) / (b.x - a.x)) + a.y;\n  if (b.x == i) l = (l + 1) % n;\n}\nvoid Down(point &a, point &b, int i) {\n  if (a.x == b.x)\n    down = min(a.y, b.y);\n  else\n    down = ceil((a.x - i) * (a.y - b.y) / (b.x - a.x)) + a.y;\n  if (b.x == i) r = (r - 1 + n) % n;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int L = 0, R = 0;\n  for (int i = 0; i < n; ++i) {\n    a[i].read();\n    a[i].x += 1000000;\n    a[i].y += 1000000;\n  }\n  double S = 0;\n  for (int i = 0; i < n; ++i) S += (a[i] * a[(i + 1) % n]);\n  if (S > 0) reverse(a, a + n);\n  for (int i = 0; i < n; ++i) {\n    if (cmp(a[i], a[L])) L = i;\n    if (cmp(a[R], a[i])) R = i;\n  }\n  int M1 = (int)a[L].x, M2 = (int)a[R].x;\n  l = L, r = L;\n  long double a1 = 0;\n  for (int i = M1; i <= M2; ++i) {\n    int j = (l + 1) % n, k = (r - 1 + n) % n;\n    Up(a[l], a[j], i);\n    Down(a[r], a[k], i);\n    if (up + 1 < down) assert(false);\n    c[i] = up - down + 1;\n    second[i] = up * (up + 1) / 2 - down * (down - 1) / 2;\n    q[i] = up * (up + 1) * (2 * up + 1) / 6 -\n           down * (down - 1) * (2 * down - 1) / 6;\n    a1 += c[i];\n  }\n  long double a2 = 0, a3 = 0, a4 = 0, a5 = 0;\n  for (int i = M1; i <= M2; ++i) {\n    a2 += q[i] / (a1 - 1), a3 += second[i];\n    a4 += c[i] * i * i / (a1 - 1), a5 += c[i] * i;\n  }\n  long double res =\n      (a2 + a4) - (a3 / (a1 - 1)) * (a3 / a1) - (a5 / (a1 - 1)) * (a5 / a1);\n  printf(\"%.9lf\", (double)res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 2e6 + 2e5;\nconst int N = M >> 1;\nconst int MX = 2e6;\nconst int D = 1e6;\ndouble L[M], R[M];\nint g[M];\nstruct pnt {\n  int x, y;\n  void input() { scanf(\"%d %d\", &x, &y); }\n} p[N];\nint n;\ndouble ans;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    p[i].input();\n    p[i].x += D, p[i].y += D;\n  }\n  function<void(int, double)> update = [&](int y, double x) {\n    L[y] = min(L[y], x);\n    R[y] = max(R[y], x);\n  };\n  for (int step = 0; step < 2; step++) {\n    for (int i = 0; i <= MX; i++) L[i] = M, R[i] = -1;\n    for (int i = 1; i <= n; i++) {\n      update(p[i].y, p[i].x);\n      int ni = i == n ? 1 : i + 1;\n      if (p[i].y == p[ni].y) continue;\n      double d = (p[ni].x - p[i].x) * 1.0 / (p[ni].y - p[i].y);\n      double cur;\n      cur = p[i].x;\n      for (int j = p[i].y + 1; j < p[ni].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n      cur = p[ni].x;\n      for (int j = p[ni].y + 1; j < p[i].y; j++) {\n        cur += d;\n        update(j, cur);\n      }\n    }\n    long long tot = 0;\n    for (int i = 0; i <= MX; i++) {\n      int lx = L[i] + 0.9999999;\n      int rx = R[i] + 0.0000001;\n      g[i] = rx >= lx ? rx - lx + 1 : 0;\n      tot += g[i];\n    }\n    double c = 0, d = 0, dd = 0;\n    for (int i = 0; i < MX; i++) {\n      double r = g[i] * 1.0 / (tot - 1);\n      d = d + dd + r;\n      dd = dd + r + r;\n      c = c + d;\n      ans += 1.0 * g[i + 1] / tot * c;\n    }\n    for (int i = 1; i <= n; i++) swap(p[i].x, p[i].y);\n  }\n  cout << fixed << setprecision(10) << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T min(T &a, T &b) {\n  return a < b ? a : b;\n}\ntemplate <class T>\ninline T max(T &a, T &b) {\n  return a > b ? a : b;\n}\ntemplate <class T>\nvoid read(T &x) {\n  char ch;\n  while ((ch = getchar()) && !isdigit(ch))\n    ;\n  x = ch - '0';\n  while ((ch = getchar()) && isdigit(ch)) x = x * 10 + ch - '0';\n}\nlong long Pow(long long a, long long b, long long Mod) {\n  long long ans = 1;\n  a %= Mod;\n  for (; b; b >>= 1) ans = b & 1 ? (ans * a % Mod) : ans, a = a * a % Mod;\n  return ans;\n}\nconst int N = 2200000, L = 2000000;\nstruct lj {\n  int x, y;\n} P[N];\nconst long double eps = 1e-7;\nint Max[N], Min[N], n;\nlong double ans, cnt;\nvoid add(int X1, int Y1, int X2, int Y2) {\n  if (X1 > X2) swap(X1, X2), swap(Y1, Y2);\n  if (X1 == X2) {\n    Min[X1] = min(Min[X1], min(Y1, Y2)), Max[X1] = max(Max[X1], max(Y1, Y2));\n    return;\n  }\n  long double p = (long double)(Y2 - Y1) / (X2 - X1);\n  for (long double c = Y1; X1 <= X2; X1++, c += p) {\n    Min[X1] = min(Min[X1], (int)ceil(c - (eps)));\n    Max[X1] = max(Max[X1], (int)floor(c + (eps)));\n  }\n}\nvoid work() {\n  for (int i = 0; i <= L; i++) Min[i] = int(2e9), Max[i] = -int(2e9);\n  for (int i = 1; i <= n; i++)\n    add(P[i].x, P[i].y, P[i % n + 1].x, P[i % n + 1].y);\n  cnt = 0;\n  long double p0 = 0, p1 = 0, p2 = 0, q0 = 0, q1 = 0, q2 = 0;\n  for (int i = 0; i <= L; i++)\n    if (Max[i] != -int(2e9)) {\n      cnt += Max[i] - Min[i] + 1;\n      p0 = Max[i] - Min[i] + 1;\n      p1 = (long double)i * (Max[i] - Min[i] + 1);\n      p2 = (long double)i * i * (Max[i] - Min[i] + 1);\n      ans += p2 * q0 + p0 * q2 - 2. * p1 * q1;\n      q0 += Max[i] - Min[i] + 1;\n      q1 += (long double)i * (Max[i] - Min[i] + 1);\n      q2 += (long double)i * i * (Max[i] - Min[i] + 1);\n    } else\n      break;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int Minx = int(2e9), Miny = int(2e9);\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d%d\", &P[i].x, &P[i].y), Minx = min(Minx, P[i].x),\n                                     Miny = min(Miny, P[i].y);\n  for (int i = 1; i <= n; i++) P[i].x -= Minx, P[i].y -= Miny;\n  work();\n  for (int i = 1; i <= n; i++) swap(P[i].x, P[i].y);\n  work();\n  printf(\"%.10lf\\n\", (double)(ans / cnt / (cnt - 1.)));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Read() {\n  char c;\n  while (c = getchar(), (c != '-') && (c < '0' || c > '9'))\n    ;\n  bool neg = (c == '-');\n  int ret = (neg ? 0 : c - 48);\n  while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + c - 48;\n  return neg ? -ret : ret;\n}\nconst int MAXN = 100005, MAXM = 2000005;\npair<int, int> a[MAXN];\nint N, l[MAXM], r[MAXM];\nlong double cnt;\nvoid init() {\n  scanf(\"%d\", &N);\n  int mx = MAXM, my = MAXM;\n  for (int i = 1; i <= N; i++)\n    a[i].first = Read(), a[i].second = Read(), mx = min(mx, a[i].first),\n    my = min(my, a[i].second);\n  for (int i = 1; i <= N; i++) a[i].first -= (mx - 1), a[i].second -= (my - 1);\n}\nlong double Solve() {\n  double rot = 0;\n  a[N + 1] = a[1];\n  int mx = 0;\n  cnt = 0;\n  for (int i = 1; i <= N; i++)\n    rot += a[i].first * a[i + 1].second - a[i].second * a[i + 1].first,\n        mx = max(mx, a[i].first);\n  if (rot > 0) reverse(a + 1, a + N + 2);\n  for (int i = 1; i <= N; i++) {\n    long long x1 = a[i].first, y1 = a[i].second, x2 = a[i + 1].first,\n              y2 = a[i + 1].second;\n    if (x1 < x2)\n      for (int j = x1; j <= x2; j++)\n        r[j] = (y1 * (x2 - j) + y2 * (j - x1)) / (x2 - x1);\n    if (x1 > x2)\n      for (int j = x2; j <= x1; j++)\n        l[j] = (y2 * (x1 - j) + y1 * (j - x2) - 1) / (x1 - x2);\n  }\n  long double s1 = 0, s2 = 0;\n  for (int i = 0; i <= mx; i++)\n    cnt += r[i] - l[i], s1 += 1.0 * i * (r[i] - l[i]),\n        s2 += 1.0 * i * i * (r[i] - l[i]);\n  return s2 * cnt - s1 * s1;\n}\nvoid work() {\n  long double ans = Solve();\n  for (int i = 1; i <= N; i++) swap(a[i].first, a[i].second);\n  printf(\"%.10f\\n\", (double)((ans + Solve()) / cnt / (cnt - 1)));\n}\nint main() {\n  init();\n  work();\n  return 0 - 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x[1000001 << 1], y[1000001 << 1], cx[1000001], cy[1000001];\nlong long CNT;\nlong double TWO, ONE;\nvector<long double> xx[2000001];\nint get(long double v1, long double v2) {\n  return (int)(floor(v2 + 1e-9) - ceil(v1 - 1e-9)) + 1;\n}\nvoid go(int px[], int py[], int n) {\n  long double two = 0, sum = 0, sec = 0;\n  int i, j;\n  long long cnt = 0;\n  if ((long long)(px[0] - px[1]) * (py[2] - py[1]) -\n          (long long)(px[2] - px[1]) * (py[0] - py[1]) >\n      0) {\n    for (i = 1; i < n - i; i++) {\n      swap(px[i], px[n - i]);\n      swap(py[i], py[n - i]);\n    }\n  }\n  for (i = 0; i <= 2000000; i++) xx[i].clear();\n  for (i = 0; i < n; i++) {\n    if (px[i] < px[i + 1]) {\n      for (j = px[i]; j <= px[i + 1]; j++) {\n        xx[j + 1000001].push_back(py[i] + (py[i + 1] - py[i]) * 1. *\n                                              (j - px[i]) /\n                                              (px[i + 1] - px[i]));\n      }\n    } else if (px[i] > px[i + 1]) {\n      for (j = px[i + 1]; j <= px[i]; j++) {\n        xx[j + 1000001].push_back(py[i] + (py[i + 1] - py[i]) * 1. *\n                                              (j - px[i]) /\n                                              (px[i + 1] - px[i]));\n      }\n    } else {\n      xx[px[i] + 1000001].push_back(py[i]);\n      xx[px[i] + 1000001].push_back(py[i + 1]);\n    }\n  }\n  for (i = 0; i <= 2000000; i++) {\n    if (xx[i].size()) {\n      long long ker = i - 1000001;\n      sort(xx[i].begin(), xx[i].end());\n      int now = get(xx[i][0], xx[i].back());\n      long long nt_cnt = cnt + now;\n      long double nt_two = two + ((long double)ker * ker * cnt -\n                                  (long double)ker * sum * 2 + sec) *\n                                     now;\n      long double nt_sec = sec + (long double)ker * ker * now;\n      long double nt_sum = sum + (long double)ker * now;\n      cnt = nt_cnt;\n      two = nt_two;\n      sec = nt_sec;\n      sum = nt_sum;\n    }\n  }\n  CNT = cnt;\n  TWO += two;\n}\nint main() {\n  int i, j, k, n, No, miX = 100000000, miY;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    cx[i] = x[i];\n    cy[i] = y[i];\n    x[n + i] = x[i];\n    y[n + i] = y[i];\n    if (x[i] < miX || (x[i] == miX && y[i] < miY)) {\n      miX = x[i];\n      miY = y[i];\n      No = i;\n    }\n  }\n  go(x + No, y + No, n);\n  miX = 100000000;\n  for (i = 0; i < n; i++) {\n    x[i] = cy[i];\n    y[i] = cx[i];\n    x[n + i] = x[i];\n    y[n + i] = y[i];\n    if (x[i] < miX || (x[i] == miX && y[i] < miY)) {\n      miX = x[i];\n      miY = y[i];\n      No = i;\n    }\n  }\n  go(x + No, y + No, n);\n  printf(\"%.15lf\\n\", (double)(TWO * 0.5 / ((long double)CNT * (CNT - 1) / 2)));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:600000000\")\nusing namespace std;\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ndouble const pi = 3.1415926535897932384626433832795;\nint const inf = (int)1e9;\nlong long const inf64 = (long long)4e18;\nconst string name = \"d\";\nconst int NMAX = 101010;\nconst int XMAX = 2001010;\nint n, x[NMAX], y[NMAX];\nint l[XMAX], r[XMAX], zn[XMAX];\nvoid update(int x1, int qqqqqqq, int x2, int y2) {\n  if (x1 == x2) {\n    l[x1] = min(l[x1], min(qqqqqqq, y2));\n    r[x1] = max(r[x1], max(qqqqqqq, y2));\n    return;\n  }\n  if (x1 > x2) {\n    swap(x1, x2);\n    swap(qqqqqqq, y2);\n  }\n  for (int i = x1; i <= x2; ++i) {\n    int now;\n    now = qqqqqqq + (double)(i - x1) * (y2 - qqqqqqq) / (x2 - x1) - 1e-7 + 1;\n    l[i] = min(l[i], now);\n    now = qqqqqqq + (double)(i - x1) * (y2 - qqqqqqq) / (x2 - x1) + 1e-7;\n    r[i] = max(r[i], now);\n  }\n}\ndouble solve() {\n  x[n] = x[0], y[n] = y[0];\n  for (int i = 0; i < (int)XMAX; i++) l[i] = inf, r[i] = -inf;\n  for (int i = 0; i < (int)n; i++) update(x[i], y[i], x[i + 1], y[i + 1]);\n  for (int i = 0; i < (int)XMAX; i++) zn[i] = max(0, r[i] - l[i] + 1);\n  double ans = 0, now = 0, cnt = 0, dist = 0;\n  for (int i = 0; i < (int)XMAX; i++) {\n    ans += zn[i] * now;\n    cnt += zn[i];\n    now += 2 * dist + cnt;\n    dist += cnt;\n  }\n  return ans / (cnt * (cnt - 1) / 2);\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < (int)n; i++) scanf(\"%d%d\", &x[i], &y[i]);\n  int xmin = 0, ymin = 0;\n  for (int i = 0; i < (int)n; i++) {\n    xmin = min(xmin, x[i]);\n    ymin = min(ymin, y[i]);\n  }\n  for (int i = 0; i < (int)n; i++) {\n    x[i] -= xmin;\n    y[i] -= ymin;\n  }\n  double ans = solve();\n  for (int i = 0; i < (int)n; i++) swap(x[i], y[i]);\n  ans += solve();\n  printf(\"%.10lf\\n\", ans / 2);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105000;\nconst int T = 1000000;\nconst int M = 2005000;\nconst double mi = 1e-8;\nconst int inf = 1987654321;\nint n;\nint cha;\nint a[N], b[N];\nint minz[M], maxz[M];\nint l, r;\nint cc[M];\ndouble ans = 0.0;\nlong long m;\nvoid getData() {\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &a[i], &b[i]);\n    a[i] += T;\n    b[i] += T;\n  }\n  a[n + 1] = a[1];\n  b[n + 1] = b[1];\n}\ndouble fang() {\n  double res = 0;\n  int i;\n  for (i = l; i <= r; i++) {\n    double now = i - cha;\n    now *= i - cha;\n    now *= cc[i];\n    now *= m;\n    res += now;\n  }\n  return res;\n}\ndouble ji() {\n  double res = 0.0;\n  int i;\n  for (i = l; i <= r; i++) {\n    double now = i - cha;\n    now *= cc[i];\n    res += now;\n  }\n  res *= res;\n  return res;\n}\nvoid Do(int x[], int y[]) {\n  memset(minz, 0x3f, sizeof minz);\n  memset(maxz, 0xc0, sizeof maxz);\n  l = inf;\n  r = -inf;\n  int i, j;\n  for (i = 1; i <= n; i++) {\n    int p = x[i];\n    int q = y[i];\n    int s = x[i + 1];\n    int t = y[i + 1];\n    if (p > s) {\n      swap(p, s);\n      swap(q, t);\n    }\n    l = min(l, p);\n    r = max(r, s);\n    for (j = p; j <= s; j++) {\n      if (p == s) {\n        if (q > t) swap(q, t);\n        minz[j] = min(minz[j], q);\n        maxz[j] = max(maxz[j], t);\n        continue;\n      }\n      double now = t - q;\n      now *= j - p;\n      now /= s - p;\n      now += q;\n      int zheng = floor(now + 0.5);\n      if (now - zheng < mi && zheng - now < mi) {\n        minz[j] = min(minz[j], zheng);\n        maxz[j] = max(maxz[j], zheng);\n      } else {\n        int qz = floor(now);\n        minz[j] = min(minz[j], qz + 1);\n        maxz[j] = max(maxz[j], qz);\n      }\n    }\n  }\n  for (i = l; i <= r; i++) cc[i] = maxz[i] - minz[i] + 1;\n  m = 0;\n  for (i = l; i <= r; i++) m += cc[i];\n  int aim = (m + 1) / 2;\n  for (i = l; i <= r; i++) {\n    if (aim <= cc[i]) break;\n    aim -= cc[i];\n  }\n  cha = i;\n  ans += fang();\n  ans -= ji();\n}\nvoid print() {\n  ans /= m;\n  ans /= (m - 1);\n  printf(\"%.8f\\n\", ans);\n}\nint main() {\n  getData();\n  Do(a, b);\n  Do(b, a);\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxXL = 1000000;\nconst int MaxN = 100000;\ninline long long floor(long long a, long long b) {\n  if (b < 0) a = -a, b = -b;\n  if (a > 0) return a / b;\n  return -((-a + b - 1) / b);\n}\ninline long long ceil(long long a, long long b) { return -floor(-a, b); }\ndouble calc(int n, int *px, int *py) {\n  long long area = 0;\n  for (int i = 0; i < n; i++)\n    area += (long long)px[i] * py[i + 1] - (long long)py[i] * px[i + 1];\n  if (area < 0) reverse(px + 1, px + n), reverse(py + 1, py + n);\n  static int h[MaxXL * 2 + 1];\n  fill(h, h + MaxXL * 2 + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if (px[i] < px[i + 1]) {\n      for (int x = px[i]; x < px[i + 1]; x++)\n        h[x + MaxXL] -= py[i] +\n                        ceil((long long)(py[i + 1] - py[i]) * (x - px[i]),\n                             px[i + 1] - px[i]) -\n                        1;\n      if (px[i + 1] >= px[(i + 2) % n]) h[px[i + 1] + MaxXL] -= py[i + 1] - 1;\n    } else if (px[i] > px[i + 1]) {\n      for (int x = px[i]; x > px[i + 1]; x--)\n        h[x + MaxXL] +=\n            py[i] + floor((long long)(py[i + 1] - py[i]) * (x - px[i]),\n                          px[i + 1] - px[i]);\n      if (px[i + 1] <= px[(i + 2) % n]) h[px[i + 1] + MaxXL] += py[i + 1];\n    }\n  }\n  long long cnt = 0;\n  double sum1 = 0;\n  double sum2 = 0;\n  for (int x = -MaxXL; x <= MaxXL; x++) {\n    cnt += h[x + MaxXL];\n    sum1 += (double)x * h[x + MaxXL];\n    sum2 += (double)x * x * h[x + MaxXL];\n  }\n  return (sum2 - sum1 * sum1 / cnt) / (cnt - 1);\n}\nint main() {\n  int n;\n  static int px[MaxN + 1], py[MaxN + 1];\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%d %d\", &px[i], &py[i]);\n  px[n] = px[0], py[n] = py[0];\n  double res = 0;\n  res += calc(n, px, py);\n  res += calc(n, py, px);\n  printf(\"%.10f\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int E = 1000100;\nint n, i, j, x[100100], y[100100], Cx[2 * E], Cy[2 * E], Dx[2 * E], Dy[2 * E];\ndouble d, sqri, ddx, ddy, sqx, sqy, smx, smy, cntx, cnty, sum, eps = 1e-9;\ndouble sqr(double x) { return x * x; }\nint main() {\n  memset(Cx, 120, sizeof(Cx));\n  memset(Cy, 120, sizeof(Cy));\n  memset(Dx, 140, sizeof(Dx));\n  memset(Dy, 140, sizeof(Dy));\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    x[i] += E;\n    y[i] += E;\n  }\n  x[n] = x[0];\n  y[n] = y[0];\n  for (i = 0; i < n; i++) {\n    double A = y[i + 1] - y[i];\n    double B = x[i] - x[i + 1];\n    double C = -A * x[i] - B * y[i];\n    int cx = min(x[i], x[i + 1]), dx = max(x[i], x[i + 1]);\n    int cy = min(y[i], y[i + 1]), dy = max(y[i], y[i + 1]);\n    if (x[i] == x[i + 1]) {\n      Cy[x[i]] = min(Cy[x[i]], cy);\n      Dy[x[i]] = max(Dy[x[i]], dy);\n    } else\n      for (j = cx; j <= dx; j++) {\n        d = (-A * j - C) / B;\n        Cy[j] = min(Cy[j], int(d - eps) + 1);\n        Dy[j] = max(Dy[j], int(d + eps));\n      }\n    if (y[i] == y[i + 1]) {\n      Cx[y[i]] = min(Cx[y[i]], cx);\n      Dx[y[i]] = max(Dx[y[i]], dx);\n    } else\n      for (j = cy; j <= dy; j++) {\n        d = (-B * j - C) / A;\n        Cx[j] = min(Cx[j], int(d - eps) + 1);\n        Dx[j] = max(Dx[j], int(d + eps));\n      }\n  }\n  for (i = 0; i < 2 * E; i++) {\n    sqri = sqr(i);\n    if (Dx[i] >= Cx[i]) {\n      ddx = Dx[i] - Cx[i] + 1;\n      sum += ddx * (sqx - 2 * smx * i + cntx * sqri);\n      sqx += sqri * ddx;\n      smx += i * ddx;\n      cntx += ddx;\n    }\n    if (Dy[i] >= Cy[i]) {\n      ddy = Dy[i] - Cy[i] + 1;\n      sum += ddy * (sqy - 2 * smy * i + cnty * sqri);\n      sqy += sqri * ddy;\n      smy += i * ddy;\n      cnty += ddy;\n    }\n  }\n  printf(\"%.10lf\\n\", sum / cntx / (cntx - 1.));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT nextInt() {\n  T x = 0, p = 1;\n  char ch;\n  do {\n    ch = getchar();\n  } while (ch <= ' ');\n  if (ch == '-') {\n    p = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * p;\n}\nconst int maxN = (int)1e5 + 10;\nconst int maxK = (int)2e6 + 10;\nconst int OFFSET = (int)1e6 + 1;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst long double LLINF = (long double)1e15;\nstruct pt {\n  long double x, y;\n};\nint n;\npt poly[maxN];\nvector<long double> byX[maxK];\nvoid find(pt a, pt b, long double &A, long double &B, long double &C) {\n  A = a.y - b.y;\n  B = b.x - a.x;\n  C = -A * a.x - B * a.y;\n}\nvoid process(pt a, pt b) {\n  if (a.x == b.x) {\n    byX[(int)a.x + OFFSET].push_back(a.y);\n    byX[(int)b.x + OFFSET].push_back(b.y);\n    return;\n  }\n  long double A, B, C;\n  find(a, b, A, B, C);\n  if (a.x > b.x) swap(a, b);\n  for (int x = a.x; x <= b.x; ++x) {\n    long double y = -(A * x + C) / 1.0 / B;\n    byX[x + OFFSET].push_back(y);\n  }\n}\nlong double ALL = 0;\nlong double solve() {\n  for (int i = 0; i < maxK; ++i) {\n    byX[i].clear();\n  }\n  for (int i = 0; i < n; ++i) {\n    process(poly[i], poly[i + 1]);\n  }\n  long double ret = 0LL;\n  long double sums = 0LL;\n  long double sumx = 0LL;\n  long double pts = 0LL;\n  for (int i = 0; i < maxK; ++i) {\n    if (byX[i].empty()) continue;\n    sort(byX[i].begin(), byX[i].end());\n    long double x = i - OFFSET;\n    long double lo = ceill(byX[i][0]);\n    long double hi = floorl(byX[i].back());\n    if (lo > hi) continue;\n    int len = (int)hi - (int)lo + 1;\n    ret += (x * 1LL * x * pts + sums - 2LL * x * sumx) * len;\n    sums += x * 1LL * x * len;\n    sumx += x * len;\n    pts += len;\n  }\n  ALL = pts;\n  return ret;\n}\nint main() {\n  n = nextInt<int>();\n  for (int i = 0; i < n; ++i) {\n    poly[i].x = nextInt<int>();\n    poly[i].y = nextInt<int>();\n  }\n  poly[n] = poly[0];\n  long double res = 0LL;\n  res += solve();\n  for (int i = 0; i <= n; ++i) {\n    swap(poly[i].x, poly[i].y);\n  }\n  res += solve();\n  long double answer = res / 1.0 / ALL;\n  answer /= ALL - 1;\n  cout.precision(20);\n  cout << answer << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong double solve(vector<long long> x, vector<long long> y, long long n) {\n  long long area = 0;\n  for (long long i = 0; i < n; i++) {\n    long long ax = x[i], bx = x[(i + 1) % n];\n    long long ay = y[i], by = y[(i + 1) % n];\n    area += ax * by - ay * bx;\n  }\n  if (area > 0) {\n    reverse(x.begin(), x.end());\n    reverse(y.begin(), y.end());\n  }\n  vector<long double> count(2e6 + 10, 0);\n  long long maxx = -1e9;\n  for (long long i = 0; i < n; i++) {\n    long long ax = x[i], bx = x[(i + 1) % n];\n    long long ay = y[i], by = y[(i + 1) % n];\n    for (long long j = ax; j < bx; j++) {\n      count[j] += (ay * (bx - ax) + (by - ay) * (j - ax)) / (bx - ax);\n    }\n    for (long long j = bx; j < ax; j++) {\n      count[j] -= (by * (ax - bx) + (ay - by) * (j - bx) - 1) / (ax - bx);\n    }\n    if (ax == bx && by < ay) {\n      count[ax] += ay - by;\n    }\n    maxx = max(maxx, ax);\n  }\n  count[maxx]++;\n  long double sum = 0, sum2 = 0, tot = 0;\n  for (long long i = 0; i < count.size(); i++) {\n    tot += count[i];\n    sum += count[i] * i;\n  }\n  assert(tot > 1);\n  sum /= tot;\n  for (long long i = 0; i < count.size(); i++) {\n    sum2 += count[i] * (i - sum) * (i - sum);\n  }\n  return 2 * sum2 / (tot - 1);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += 1e6 + 1;\n    y[i] += 1e6 + 1;\n  }\n  long double ans = 0;\n  ans += solve(x, y, n);\n  ans += solve(y, x, n);\n  cout << fixed << setprecision(10) << ans / 2;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble x[100000], y[100000];\ndouble Intersection(int i, int j, int level) {\n  return (double)(level - y[i]) / (y[j] - y[i]) * (x[j] - x[i]) + x[i];\n}\nvoid Scan(int n, double& sum, double& square_sum, long long& ct) {\n  int start = 0;\n  for (int i = 1; i < n; ++i) {\n    if (y[i] > y[start]) {\n      start = i;\n    }\n  }\n  int a = start, b = start;\n  while (y[(b + 1) % n] == y[b]) {\n    b = (b + 1) % n;\n  }\n  b = (b + 1) % n;\n  while (y[(a - 1 + n) % n] == y[a]) {\n    a = (a - 1 + n) % n;\n  }\n  a = (a - 1 + n) % n;\n  int level = y[start];\n  while (true) {\n    double l = Intersection(a, (a + 1) % n, level);\n    double r = Intersection(b, (b - 1 + n) % n, level);\n    if (l > r) swap(l, r);\n    l = ceil(l);\n    r = floor(r);\n    ct += r - l + 1;\n    sum += (l + r) * (r - l + 1) / 2;\n    --l;\n    square_sum += r * (r + 1) * (2 * r + 1) / 6 - l * (l + 1) * (2 * l + 1) / 6;\n    if (y[a] == level) {\n      a = (a - 1 + n) % n;\n      if (y[a] >= level) break;\n    }\n    if (y[b] == level) {\n      b = (b + 1) % n;\n    }\n    --level;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lf%lf\", x + i, y + i);\n    if (i > 0 && x[i] == x[i - 1] && y[i] == y[i - 1]) {\n      --i, --n;\n    }\n  }\n  if (x[n - 1] == x[0] && y[n - 1] == y[0]) {\n    --n;\n  }\n  double sum = 0;\n  double square_sum = 0;\n  long long ct = 0;\n  Scan(n, sum, square_sum, ct);\n  double answer = ct * square_sum - sum * sum;\n  for (int i = 0; i < n; ++i) {\n    swap(x[i], y[i]);\n  }\n  sum = 0;\n  square_sum = 0;\n  ct = 0;\n  Scan(n, sum, square_sum, ct);\n  answer += ct * square_sum - sum * sum;\n  printf(\"%.10f\\n\", answer / ct / (ct - 1));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, X[100006], Y[100006];\nvector<vector<pair<int, int> > > H;\nvoid solve() {\n  int i, j, k, l, r, x, y;\n  string s;\n  H.resize(2000005);\n  cin >> N;\n  for (i = 0; i < N; i++) cin >> X[i] >> Y[i], X[i] += 1000000, Y[i] += 1000000;\n  double ret = 0;\n  double T;\n  for (k = 0; k < 2; k++) {\n    T = 0;\n    for (x = 0; x < 2000001; x++) H[x].clear();\n    for (i = 0; i < N; i++) {\n      H[X[i]].push_back(make_pair(Y[i], Y[i]));\n      if (X[i] != X[(i + 1) % N]) {\n        int dx = (X[i] < X[(i + 1) % N]) ? 1 : -1;\n        for (x = X[i] + dx; x != X[(i + 1) % N]; x += dx) {\n          signed long long dy = 1LL * (x - X[i]) * (Y[(i + 1) % N] - Y[i]);\n          signed long long y2 = Y[i] + dy / (X[(i + 1) % N] - X[i]);\n          if ((dy >= 0) ^ (X[(i + 1) % N] < X[i]))\n            H[x].push_back(\n                make_pair(y2, y2 + ((dy % (X[(i + 1) % N] - X[i]) != 0))));\n          else\n            H[x].push_back(\n                make_pair(y2 - (dy % (X[(i + 1) % N] - X[i]) != 0), y2));\n        }\n      }\n    }\n    double S1 = 0, S2 = 0;\n    for (x = 0; x < 2000001; x++)\n      if (H[x].size()) {\n        int mf = H[x][0].first, ms = H[x][0].second;\n        for (i = 0; i < H[x].size(); i++)\n          mf = max(mf, H[x][i].first), ms = min(ms, H[x][i].second);\n        int h = mf - ms + 1;\n        if (h <= 0) continue;\n        ret += h * (T * x * x - 2LL * x * S1 + S2);\n        T += h;\n        S1 += 1LL * h * x;\n        S2 += 1LL * h * x * x;\n      }\n    for (i = 0; i < N; i++) swap(X[i], Y[i]);\n  }\n  (void)printf(\"%.12lf\\n\", ret / (T - 1.0) / T);\n}\nint main(int argc, char** argv) {\n  string s;\n  int i;\n  if (argc == 1) ios::sync_with_stdio(false);\n  for (i = 0; i < argc - 1; i++) s += argv[i + 1], s += '\\n';\n  for (i = 0; i < s.size(); i++) ungetc(s[s.size() - 1 - i], stdin);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class D {\n\tprivate static Scanner in;\n\n\tpublic void run() {\n\t\tint n = in.nextInt();\n\t\tint s = 0;\n\t\tint[] x = new int[n + 1];\n\t\tint[] y = new int[n + 1];\n\t\tint xmin = Integer.MAX_VALUE;\n\t\tint xmax = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt() + s;\n\t\t\ty[i] = in.nextInt() + s;\n\t\t\txmin = Math.min(xmin, x[i]);\n\t\t\txmax = Math.max(xmax, x[i]);\n\t\t}\n\t\tx[n] = x[0];\n\t\ty[n] = y[0];\n\t\tdouble sx = 0;\n\t\tdouble sx2 = 0;\n\t\tdouble sy = 0;\n\t\tdouble sy2 = 0;\n\t\tdouble cnt = 0;\n\t\tint i = 0;\n\t\twhile (x[i] != xmin) {\n\t\t\ti++;\n\t\t}\n\t\tint j = i;\n\t\tif (j == 0) j = n;\n\t\tdouble slope1 = (y[i + 1] - y[i]) * 1.0 / (x[i + 1] - x[i]);\n\t\tdouble slope2 = (y[j - 1] - y[j]) * 1.0 / (x[j - 1] - x[j]);\n\t\tfor (int t = xmin; t <= xmax; t++) {\n\t\t\tif (t < xmax) {\n\t\t\t\twhile (x[i + 1] <= t) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (i == n) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t\tslope1 = (y[i + 1] - y[i]) * 1.0 / (x[i + 1] - x[i]);\n\t\t\t\t}\n\t\t\t\twhile (x[j - 1] <= t) {\n\t\t\t\t\tj--;\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tj = n;\n\t\t\t\t\t}\n\t\t\t\t\tslope2 = (y[j - 1] - y[j]) * 1.0 / (x[j - 1] - x[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble y1 = y[i] + (t - x[i]) * slope1;\n\t\t\tdouble y2 = y[j] + (t - x[j]) * slope2;\n\t\t\tif (y1 > y2) {\n\t\t\t\tdouble p = y1; y1 = y2; y2 = p;\n\t\t\t}\n\t\t\tdouble yFrom = Math.ceil(y1);\n\t\t\tdouble yTo = Math.floor(y2) + 1;\n//\t\t\tSystem.out.println(t + \": \" + yFrom + \"..\" + yTo);\n\t\t\tdouble m = yTo - yFrom;\n\t\t\tcnt += m;\n\t\t\tsx += m * 1.0 * t;\n\t\t\tsx2 += m * 1.0 * t * t;\n\t\t\tsy += m * 0.5 * (yFrom + yTo - 1);\n\t\t\tsy2 += ((yTo - 1) * 1.0 * (yTo) * (2 * yTo - 1) - (yFrom - 1) * 1.0 * (yFrom) * (2 * yFrom - 1)) / 6;\n\t\t}\n\t\tdouble ans = (sx2 * cnt - sx * sx + sy2 * cnt - sy * sy) / cnt / (cnt - 1);\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.US);\n\t\tin = new Scanner(System.in);\n\t\tnew D().run();\n\t\tin.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (int)1e5 + 10, MAXM = (int)2e6 + 10, D = (int)1e6 + 5;\nint n, first[MAXN], second[MAXN], u[MAXM], d[MAXM];\nlong long tot;\nlong double Tohka;\nvoid Upd(int &u, int &d, int second, int t) {\n  u = max(u, second);\n  d = min(d, second + t);\n}\nvoid Work(int &u, int &d, int xa, int ya, int xb, int yb, int first) {\n  int Y = (int)((long double)ya +\n                ((long double)(yb - ya) / (xb - xa) * (first - xa)));\n  if ((long long)(yb - ya) * (first - xa) % (xb - xa) == 0)\n    Upd(u, d, Y, 0);\n  else\n    Upd(u, d, Y, 1);\n}\nvoid Calc() {\n  tot = 0;\n  int l = MAXM, r = 0;\n  for (int i = 0; i < MAXM; ++i) d[i] = MAXM, u[i] = 0;\n  for (int i = 1; i <= n; ++i) {\n    int xa = first[i], xb = first[((i + 1) > n) ? 1 : (i + 1)], ya = second[i],\n        yb = second[((i + 1) > n) ? 1 : (i + 1)];\n    if (xa > xb) swap(xa, xb), swap(ya, yb);\n    Upd(u[first[i]], d[first[i]], second[i], 0);\n    l = min(l, first[i]);\n    r = max(r, first[i]);\n    if (xa != xb)\n      for (int j = xa; j <= xb; ++j) Work(u[j], d[j], xa, ya, xb, yb, j);\n  }\n  long double s = 0, a = 0, b = 0;\n  for (int i = l; i <= r; ++i) {\n    int c = u[i] - d[i] + 1;\n    tot += c;\n    s += a * i + b;\n    a += (long double)c * 2;\n    b += (long double)-c * 2 * (i + 1) + c;\n    Tohka += s * c;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%d%d\", &first[i], &second[i]), first[i] += D, second[i] += D;\n  Calc();\n  for (int i = 1; i <= n; ++i) swap(first[i], second[i]);\n  Calc();\n  Tohka /= (long double)tot * (tot - 1);\n  cout << setprecision(10);\n  cout << fixed << Tohka << endl;\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  long long x, y;\n};\nint N;\npoint P[100010];\nlong long area(point &P, point &Q) { return P.x * Q.y - P.y * Q.x; }\nbool smaller(point &P, point &Q) {\n  if (P.x < Q.x) return true;\n  if (P.x == Q.x && P.y < Q.y) return true;\n  return false;\n}\nlong long low[2000010], high[2000010];\nvoid lower(point P, point Q) {\n  if (P.x == Q.x) return;\n  for (int i = P.x; i <= Q.x; i++) {\n    double y = P.y + (double)(Q.y - P.y) / (Q.x - P.x) * (i - P.x);\n    low[i] = max(low[i], (long long)(y - 1.0E-7) + 1);\n  }\n}\nvoid upper(point P, point Q) {\n  if (P.x == Q.x) return;\n  for (int i = P.x; i <= Q.x; i++) {\n    double y = P.y + (double)(Q.y - P.y) / (Q.x - P.x) * (i - P.x);\n    high[i] = min(high[i], (long long)(y + 1.0E-7));\n  }\n}\ndouble func(void) {\n  int i;\n  long long s = 0;\n  for ((i) = 0; (i) < (int)(N); (i)++) s += area(P[i], P[(i + 1) % N]);\n  if (s < 0) reverse(P, P + N);\n  int L = 0, R = 0;\n  for ((i) = 0; (i) < (int)(N); (i)++) {\n    if (smaller(P[i], P[L])) L = i;\n    if (smaller(P[R], P[i])) R = i;\n  }\n  int X1 = P[L].x;\n  int X2 = P[R].x;\n  for (i = X1; i <= X2; i++) low[i] = -(1 << 29);\n  for (i = X1; i <= X2; i++) high[i] = (1 << 29);\n  for (i = 0;; i++) {\n    int a = (L + i) % N, b = (L + i + 1) % N;\n    lower(P[a], P[b]);\n    if (b == R) break;\n  }\n  for (i = 0;; i++) {\n    int a = (R + i + 1) % N, b = (R + i) % N;\n    upper(P[a], P[b]);\n    if (a == L) break;\n  }\n  double cnt = 0.0;\n  double xsum = 0.0;\n  double x2sum = 0.0;\n  for (i = X1; i <= X2; i++) {\n    double tmp = high[i] - low[i] + 1;\n    cnt += tmp;\n    xsum += tmp * (double)i;\n    x2sum += tmp * (double)i * (double)i;\n  }\n  double ans = 2.0 * cnt * x2sum - 2.0 * xsum * xsum;\n  return ans / cnt / (cnt - 1.0);\n}\nint main(void) {\n  int i;\n  cin >> N;\n  for ((i) = 0; (i) < (int)(N); (i)++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    P[i].x = x + 1000000;\n    P[i].y = y + 1000000;\n  }\n  double ans1 = func();\n  for ((i) = 0; (i) < (int)(N); (i)++) swap(P[i].x, P[i].y);\n  double ans2 = func();\n  printf(\"%.9f\\n\", (ans1 + ans2) / 2.0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inv = numeric_limits<int>::max();\nconst int minv = numeric_limits<int>::min();\nconst int max_n = 100010;\nconst int clim = 1000010;\nint n;\npair<int, int> v[max_n];\ndouble res = 0.0;\ndouble c[2 * clim + 1][2];\nint csz[2 * clim + 1];\nint miny, maxy;\nvoid markoff(int i) {\n  int j = (i + 1) % n;\n  int x1 = v[i].first, y1 = v[i].second, x2 = v[j].first, y2 = v[j].second;\n  if (y1 == y2)\n    c[y1 - miny][csz[y1 - miny]++] = x1;\n  else {\n    double dx = ((double(x2 - x1)) / (abs((double(y2 - y1)))));\n    double x = x1;\n    for (int y = y1; y != y2; y += ((y2 - y1) / (abs(y2 - y1)))) {\n      c[y - miny][csz[y - miny]++] = x;\n      x += dx;\n    }\n  }\n}\nint rddn(double d) {\n  if (abs(d - floor(d)) < (1.0e-12)) return (int(floor(d)));\n  if (abs(d - ceil(d)) < (1.0e-12)) return (int(ceil(d)));\n  return (int(floor(d)));\n}\nint rdup(double d) {\n  if (abs(d - floor(d)) < (1.0e-12)) return (int(floor(d)));\n  if (abs(d - ceil(d)) < (1.0e-12)) return (int(ceil(d)));\n  return (int(ceil(d)));\n}\ndouble a[2 * clim + 1];\nvoid finda(int y) {\n  if (csz[y] == 1) {\n    a[y] = 1;\n    return;\n  }\n  double x1 = c[y][0], x2 = c[y][1];\n  if (x1 > x2) swap(x1, x2);\n  int rx1 = rdup(x1), rx2 = rddn(x2);\n  a[y] = (double(rx2 - rx1 + 1));\n}\ndouble sa[2 * clim + 2];\nvoid process() {\n  miny = inv;\n  maxy = minv;\n  for (int i = 0; i < n; ++i) {\n    miny = min(miny, v[i].second);\n    maxy = max(maxy, v[i].second);\n  }\n  fill(csz, csz + maxy - miny + 1, 0);\n  for (int i = 0; i < n; ++i) markoff(i);\n  for (int y = 0; y <= maxy - miny; ++y) finda(y);\n  sa[maxy - miny + 1] = 0.0;\n  for (int y = maxy - miny; y >= 0; --y) sa[y] = sa[y + 1] + a[y];\n  double Qa = 0.0;\n  double dQa = a[maxy - miny];\n  for (int y = maxy - miny - 1; y >= 0; --y) {\n    Qa += dQa;\n    res += a[y] * Qa;\n    dQa += (a[y] + 2.0 * sa[y + 1]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &v[i].first);\n    scanf(\"%d\", &v[i].second);\n  }\n  process();\n  for (int i = 0; i < n; ++i) swap(v[i].first, v[i].second);\n  process();\n  res /= (sa[0] * (sa[0] - 1.0) / 2.0);\n  res /= 2.0;\n  printf(\"%.12f\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  int x, y;\n  double k, b;\n  friend double operator*(const point& A, const point& B) {\n    return 1.0 * A.x * B.y - 1.0 * A.y * B.x;\n  }\n} a[100005];\nint N;\ndouble ans, S;\nmap<int, int> F;\nvoid init() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%d%d\", &a[i].x, &a[i].y);\n}\nvoid work() {\n  a[N + 1] = a[1], S = 0, F.clear();\n  double area = 0;\n  for (int i = 1; i <= N; i++) area += a[i] * a[i + 1];\n  if (area < -1e-9)\n    for (int i = 1; i + i <= N + 1; i++) swap(a[i], a[N + 2 - i]);\n  int mi = 1e9, ma = -1e9, l, r, t = 0;\n  auto inc = [&](int i) { return i < N ? i + 1 : 1; };\n  auto dec = [&](int i) { return i > 1 ? i - 1 : N; };\n  for (int i = 1; i <= N; i++) {\n    if (a[i].x < mi) mi = a[i].x, l = i;\n    if (a[i].x > ma) ma = a[i].x, r = i;\n    if (a[i].x != a[i + 1].x)\n      a[i].k = 1.0 * (a[i].y - a[i + 1].y) / (a[i].x - a[i + 1].x),\n      a[i].b = a[i].y - a[i].k * a[i].x;\n    else\n      F[a[i].x] += abs(a[i].y - a[i + 1].y) + 1, a[i].k = 1e99;\n  }\n  for (int x = mi, i = l, j = l; x <= ma; x++) {\n    for (; dec(i) != r && a[dec(i)].x <= x; i = dec(i))\n      ;\n    for (; inc(j) != r && a[inc(j)].x <= x; j = inc(j))\n      ;\n    if (a[dec(i)].k >= 1e99 || a[j].k >= 1e99) continue;\n    F[x] = floor(a[dec(i)].k * x + a[dec(i)].b + 1e-9) -\n           ceil(a[j].k * x + a[j].b - 1e-9) + 1;\n  }\n  double u = 0, v = 0, w = 0;\n  for (auto i : F)\n    w += v, v += 2 * u + i.second, u += i.second, ans += w * i.second,\n        S += i.second;\n}\nvoid doit() {\n  work();\n  for (int i = 1; i <= N; i++) swap(a[i].x, a[i].y);\n  work();\n  printf(\"%.9lf\\n\", 1.0 * ans / S / (S - 1));\n}\nint main() {\n  init();\n  doit();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct TPoint {\n  long long x, y;\n  TPoint(int x = 0, int y = 0) : x(x), y(y) {}\n};\nTPoint p[100011];\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lfloor(long long a, long long b);\nlong long lceil(long long a, long long b) {\n  if (a < 0) {\n    return -lfloor(-a, b);\n  }\n  return (a + b - 1) / b;\n}\nlong long lfloor(long long a, long long b) {\n  if (a < 0) {\n    return -lceil(-a, b);\n  }\n  return a / b;\n}\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%I64d%I64d\", &p[i].x, &p[i].y);\n  }\n  p[N] = p[0];\n  long long S = 0;\n  for (int i = 0; i < N; ++i) {\n    S += (p[i + 1].y + p[i].y) * (p[i + 1].x - p[i].x);\n  }\n  if (S > 0) {\n    reverse(p, p + N);\n    p[N] = p[0];\n  }\n  S = std::abs(S);\n  long long bord = 0;\n  for (int i = 0; i < N; ++i) {\n    bord += gcd(abs(p[i + 1].x - p[i].x), abs(p[i + 1].y - p[i].y));\n  }\n  long long total = (S + bord + 2) / 2;\n  vector<TPoint> low, high, left, right;\n  int m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].x < p[m].x || (p[i].x == p[m].x && p[i].y < p[m].y)) {\n      m = i;\n    }\n  }\n  low.push_back(p[m]);\n  for (int i = m + 1;; ++i) {\n    i = (i + N) % N;\n    if (p[i].x > p[(i + N - 1) % N].x) {\n      low.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].x < p[m].x || (p[i].x == p[m].x && p[i].y > p[m].y)) {\n      m = i;\n    }\n  }\n  high.push_back(p[m]);\n  for (int i = m + N - 1;; --i) {\n    i = (i + N) % N;\n    if (p[i].x > p[(i + 1) % N].x) {\n      high.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].y < p[m].y || (p[i].y == p[m].y && p[i].x < p[m].x)) {\n      m = i;\n    }\n  }\n  left.push_back(p[m]);\n  for (int i = m + N - 1;; --i) {\n    i = (i + N) % N;\n    if (p[i].y > p[(i + 1) % N].y) {\n      left.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  m = 0;\n  for (int i = 0; i < N; ++i) {\n    if (p[i].y < p[m].y || (p[i].y == p[m].y && p[i].x > p[m].x)) {\n      m = i;\n    }\n  }\n  right.push_back(p[m]);\n  for (int i = m + 1;; ++i) {\n    i = (i + N) % N;\n    if (p[i].y > p[(i + N - 1) % N].y) {\n      right.push_back(p[i]);\n    } else {\n      break;\n    }\n  }\n  long double ex2 = 0.0, ex = 0.0;\n  {\n    int li = 0, hi = 0;\n    for (int x = -1000001; x <= 1000001; ++x) {\n      if (x < low[0].x) {\n        continue;\n      }\n      if (x > low.back().x) {\n        break;\n      }\n      int l = low[li].y + lceil((x - low[li].x) * (low[li + 1].y - low[li].y),\n                                (low[li + 1].x - low[li].x));\n      int r =\n          high[hi].y + lfloor((x - high[hi].x) * (high[hi + 1].y - high[hi].y),\n                              (high[hi + 1].x - high[hi].x));\n      int p = (r - l + 1);\n      ex2 += (long double)1.0 * p * x * x;\n      ex += (long double)1.0 * p * x;\n      if (x == low[li + 1].x) {\n        ++li;\n      }\n      if (x == high[hi + 1].x) {\n        ++hi;\n      }\n    }\n  }\n  long double ey2 = 0.0, ey = 0.0;\n  {\n    int li = 0, ri = 0;\n    for (int y = -1000001; y <= 1000001; ++y) {\n      if (y < left[0].y) {\n        continue;\n      }\n      if (y > left.back().y) {\n        break;\n      }\n      int l =\n          left[li].x + lceil((y - left[li].y) * (left[li + 1].x - left[li].x),\n                             (left[li + 1].y - left[li].y));\n      int r = right[ri].x +\n              lfloor((y - right[ri].y) * (right[ri + 1].x - right[ri].x),\n                     (right[ri + 1].y - right[ri].y));\n      int p = (r - l + 1);\n      ey2 += (long double)1.0 * p * y * y;\n      ey += (long double)1.0 * p * y;\n      if (y == left[li + 1].y) {\n        ++li;\n      }\n      if (y == right[ri + 1].y) {\n        ++ri;\n      }\n    }\n  }\n  ex2 /= total;\n  ex /= total;\n  ey2 /= total;\n  ey /= total;\n  long double ans = ex2 - ex * ex + ey2 - ey * ey;\n  ans *= 1.0 * total / (total - 1);\n  printf(\"%.10lf\", (double)ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100000 + 9;\nint n, n2;\nlong double sum, ans;\nstruct point {\n  int x, y;\n  point(const int _x, const int _y) : x(_x), y(_y) {}\n  point() {}\n} p[N * 2];\ninline long long cpr(const point &a, const point &b, const point &c) {\n  return 1ll * (b.x - a.x) * (c.y - a.y) - 1ll * (c.x - a.x) * (b.y - a.y);\n}\ninline double sqr(const double x) { return x * x; }\nvoid work1() {\n  sum = 0;\n  int l = 1, r = 1, Max = -99999999;\n  for (int i = 1; i <= n2; ++i) {\n    if (p[i].x < p[l].x) l = i;\n    if (p[i].x <= p[r].x) r = i;\n    Max = std::max(Max, p[i].x);\n  }\n  if (p[l].x == p[l + 1].x) ++l;\n  if (p[r].x == p[r - 1].x) --r;\n  for (int i = p[l].x; i <= Max; ++i) {\n    if (p[l + 1].x < i) ++l;\n    if (p[r - 1].x < i) --r;\n    int bot = std::ceil((p[l + 1].y - p[l].y) * 1.0 / (p[l + 1].x - p[l].x) *\n                            (i - p[l].x) +\n                        p[l].y);\n    int top = std::floor((p[r - 1].y - p[r].y) * 1.0 / (p[r - 1].x - p[r].x) *\n                             (i - p[r].x) +\n                         p[r].y);\n    sum += (top - bot + 1);\n  }\n}\nvoid work() {\n  int l = 1, r = 1, Max = -99999999;\n  for (int i = 1; i <= n2; ++i) {\n    if (p[i].x < p[l].x) l = i;\n    if (p[i].x <= p[r].x) r = i;\n    Max = std::max(Max, p[i].x);\n  }\n  if (p[l].x == p[l + 1].x) ++l;\n  if (p[r].x == p[r - 1].x) --r;\n  long double sum1 = 0, sum2 = 0, sum3 = 0;\n  for (int i = p[l].x; i <= Max; ++i) {\n    if (p[l + 1].x < i) ++l;\n    if (p[r - 1].x < i) --r;\n    int bot = std::ceil((p[l + 1].y - p[l].y) * 1.0 / (p[l + 1].x - p[l].x) *\n                            (i - p[l].x) +\n                        p[l].y);\n    int top = std::floor((p[r - 1].y - p[r].y) * 1.0 / (p[r - 1].x - p[r].x) *\n                             (i - p[r].x) +\n                         p[r].y);\n    sum1 += sum2;\n    sum2 += sum3 * 2 + (top - bot + 1);\n    sum3 += (top - bot + 1);\n    ans += (top - bot + 1) / (sum * (sum - 1)) * sum1;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  n2 = 2 * n;\n  for (int i = 1; i <= n; ++i) scanf(\"%d%d\", &p[i].x, &p[i].y);\n  p[n + 1] = p[1];\n  long long S = 0;\n  for (int i = 1; i <= n; ++i) S += cpr(point(0, 0), p[i], p[i + 1]);\n  if (S < 0) std::reverse(p + 1, p + 1 + n);\n  for (int i = 1; i <= n; ++i) {\n    p[i + n] = p[i];\n  }\n  work1();\n  work();\n  for (int i = 1; i <= n2; ++i) {\n    std::swap(p[i].x, p[i].y);\n    p[i].x = -p[i].x;\n  }\n  work();\n  printf(\"%.8f\\n\", (double)(ans));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e5 + 5, X = (int)2e6 + 100;\nint n, x[N], y[N], cnt[X];\nlong double work() {\n  long double area = 0;\n  for (int i = 0; i < n; i++) area += x[i + 1] * y[i] - x[i] * y[i + 1];\n  if (area < 0) {\n    reverse(x, x + n);\n    x[n] = x[0];\n    reverse(y, y + n);\n    y[n] = y[0];\n  }\n  long long tot = 0;\n  long double ans1 = 0, ans2 = 0;\n  for (int i = 0; i < X; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] < x[i + 1]) {\n      for (int j = x[i]; j < x[i + 1]; j++)\n        cnt[j] += floor(\n            y[i] + 1. * (y[i + 1] - y[i]) / (x[i + 1] - x[i]) * (j - x[i]) +\n            1e-8);\n      if (x[i + 1] >= x[(i + 2) % n]) cnt[x[i + 1]] += y[i + 1];\n    } else if (x[i] > x[i + 1]) {\n      for (int j = x[i]; j > x[i + 1]; j--)\n        cnt[j] -= floor(\n            y[i] + 1. * (y[i + 1] - y[i]) / (x[i + 1] - x[i]) * (j - x[i]) -\n            1e-8);\n      if (x[i + 1] <= x[(i + 2) % n]) cnt[x[i + 1]] -= y[i + 1] - 1;\n    }\n  }\n  for (int i = 0; i < X; i++) {\n    tot += cnt[i];\n    ans1 += 1. * i * cnt[i];\n    ans2 += 1. * i * i * cnt[i];\n  }\n  return (ans2 * tot - 2 * ans1 * ans1 + ans2 * tot) / tot / (tot - 1);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d%d\", &x[i], &y[i]), x[i] += X / 2, y[i] += X / 2;\n  x[n] = x[0];\n  y[n] = y[0];\n  long double ans = work();\n  for (int i = 0; i <= n; i++) swap(x[i], y[i]);\n  ans += work();\n  printf(\"%.12lf\\n\", double(ans / 2));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, minn = 1e9, maxx;\nint x[200100], y[200100], s = 1, ss = 1;\ndouble ans, sum, cnt[2000100], tot;\nint main() {\n  int i, j, h, t, p1, p2;\n  double pp1, pp2;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", x + i, y + i);\n    x[i] += 1000000;\n    y[i] += 1000000;\n    x[n + i] = x[i];\n    y[n + i] = y[i];\n    if (x[i] < x[s]) s = i;\n    if (x[i] > x[ss]) ss = i;\n  }\n  minn = 1e9;\n  maxx = 0;\n  for (i = 1; i <= n; ++i)\n    if (x[i] == x[s]) {\n      if (y[i] < minn) minn = y[i];\n      if (maxx < y[i]) maxx = y[i];\n    }\n  cnt[x[s]] = maxx - minn + 1;\n  minn = 1e9;\n  maxx = 0;\n  for (i = 1; i <= n; ++i)\n    if (x[i] == x[ss]) {\n      if (y[i] < minn) minn = y[i];\n      if (maxx < y[i]) maxx = y[i];\n    }\n  cnt[x[ss]] = maxx - minn + 1;\n  h = s;\n  t = s + n;\n  for (i = x[s] + 1; i < x[ss]; ++i) {\n    while (x[h + 1] < i) ++h;\n    while (x[t - 1] < i) --t;\n    pp1 = ((double)y[h + 1] - y[h]) * (i - x[h]) / (x[h + 1] - x[h]) + y[h];\n    pp2 = ((double)y[t - 1] - y[t]) * (i - x[t]) / (x[t - 1] - x[t]) + y[t];\n    p1 = pp1 + 1e-3;\n    p2 = pp2 + 1e-3;\n    if (pp1 < pp2) {\n      if (((long long)y[h + 1] - y[h]) * (i - x[h]) % (x[h + 1] - x[h]) == 0)\n        --p1;\n      cnt[i] = p2 - p1;\n    } else {\n      if (((long long)y[t - 1] - y[t]) * (i - x[t]) % (x[t - 1] - x[t]) == 0)\n        --p2;\n      cnt[i] = p1 - p2;\n    }\n  }\n  tot = sum = 0.0;\n  for (i = x[s]; i <= x[ss]; ++i) {\n    tot += cnt[i];\n    sum += (double)cnt[i] * i;\n  }\n  for (i = x[s]; i <= x[ss]; ++i)\n    ans += tot * 2 * cnt[i] * i * i - 2 * cnt[i] * i * sum;\n  s = ss = 1;\n  for (i = 1; i <= n; ++i) {\n    if (y[i] < y[s]) s = i;\n    if (y[i] > y[ss]) ss = i;\n  }\n  minn = 1e9;\n  maxx = 0;\n  for (i = 1; i <= n; ++i)\n    if (y[i] == y[s]) {\n      if (x[i] < minn) minn = x[i];\n      if (maxx < x[i]) maxx = x[i];\n    }\n  cnt[y[s]] = maxx - minn + 1;\n  minn = 1e9;\n  maxx = 0;\n  for (i = 1; i <= n; ++i)\n    if (y[i] == y[ss]) {\n      if (x[i] < minn) minn = x[i];\n      if (maxx < x[i]) maxx = x[i];\n    }\n  cnt[y[ss]] = maxx - minn + 1;\n  h = s;\n  t = s + n;\n  for (i = y[s] + 1; i < y[ss]; ++i) {\n    while (y[h + 1] < i) ++h;\n    while (y[t - 1] < i) --t;\n    pp1 = ((double)x[h + 1] - x[h]) * (i - y[h]) / (y[h + 1] - y[h]) + x[h];\n    pp2 = ((double)x[t - 1] - x[t]) * (i - y[t]) / (y[t - 1] - y[t]) + x[t];\n    p1 = pp1 + 1e-3;\n    p2 = pp2 + 1e-3;\n    if (pp1 < pp2) {\n      if (((long long)x[h + 1] - x[h]) * (i - y[h]) % (y[h + 1] - y[h]) == 0)\n        --p1;\n      cnt[i] = p2 - p1;\n    } else {\n      if (((long long)x[t - 1] - x[t]) * (i - y[t]) % (y[t - 1] - y[t]) == 0)\n        --p2;\n      cnt[i] = p1 - p2;\n    }\n  }\n  tot = sum = 0.0;\n  for (i = y[s]; i <= y[ss]; ++i) {\n    tot += cnt[i];\n    sum += (double)cnt[i] * i;\n  }\n  for (i = y[s]; i <= y[ss]; ++i)\n    ans += tot * 2 * cnt[i] * i * i - 2 * cnt[i] * i * sum;\n  printf(\"%.7lf\\n\", ans / tot / (tot - 1.0) / 2);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package croc2013.r2;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class D2 {\n\tInputStream is;\n\tPrintWriter out;\n//\tString INPUT = \"\";\n//\tString INPUT = \"4 1000000 -1000000 1000000 1000000 -1000000 1000000 -1000000 -1000000\\r\\n\";\n//\tString INPUT = \"4 0 0 4 0 4 1 0 1\";\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni(), ni()};\n\t\t}\n\t\tfor(int j = 0;j < n-2;j++){\n\t\t\tint a = j, b = (j+1)%n, c = (j+2)%n;\n\t\t\tlong s = (long)(co[b][1]-co[a][1])*(co[c][0]-co[a][0])-(long)(co[c][1]-co[a][1])*(co[b][0]-co[a][0]);\n\t\t\tif(s > 0){\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tco[i][1] = -co[i][1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(s < 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble SX = go(co);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d = co[i][0]; co[i][0] = co[i][1]; co[i][1] = d;\n\t\t\tco[i][0] = -co[i][0];\n\t\t}\n\t\tdouble SY = go(co);\n\t\tout.printf(\"%.12f\\n\", (SX+SY)/num/(num-1)*2/2/2);\n\t}\n\t\n\tdouble go(int[][] co)\n\t{\n\t\tint n = co.length;\n\t\tint I = 100000000;\n\t\t// cc\n\t\tint minx = I;\n\t\tint minxiup = -1;\n\t\tint minxilo = -1;\n\t\tint upy = -I;\n\t\tint loy = I;\n\t\t\n\t\tint maxx = -I;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(co[i][0] <= minx){\n\t\t\t\tif(co[i][0] < minx){\n\t\t\t\t\tupy = -I;\n\t\t\t\t\tloy = I;\n\t\t\t\t}\n\t\t\t\tminx = co[i][0];\n\t\t\t\tif(co[i][1] > upy){\n\t\t\t\t\tupy = co[i][1];\n\t\t\t\t\tminxiup = i;\n\t\t\t\t}\n\t\t\t\tif(co[i][1] < loy){\n\t\t\t\t\tloy = co[i][1];\n\t\t\t\t\tminxilo = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co[i][0] > maxx){\n\t\t\t\tmaxx = co[i][0];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint upper = minxiup;\n\t\tint lower = minxilo;\n\t\tlong[] f = new long[maxx-minx+1];\n\t\tnum = 0;\n\t\tfor(int x = minx;x <= maxx;x++){\n\t\t\twhile(co[upper][0] < x){\n\t\t\t\tupper--;\n\t\t\t\tif(upper < 0)upper += n;\n\t\t\t}\n\t\t\twhile(co[lower][0] < x){\n\t\t\t\tlower++;\n\t\t\t\tif(lower >= n)lower -= n;\n\t\t\t}\n\t\t\t\n\t\t\tif(x == minx){\n\t\t\t\tf[0] = upy-loy+1;\n\t\t\t}else if(x == maxx){\n\t\t\t\tf[maxx-minx] = co[upper][1]-co[lower][1]+1;\n\t\t\t}else{\n\t\t\t\tlong uy, ly;\n\t\t\t\t{\n\t\t\t\t\tint upnx = upper+1;\n\t\t\t\t\tif(upnx >= n)upnx -= n;\n\t\t\t\t\tlong a = co[upnx][0], b = co[upnx][1];\n\t\t\t\t\tlong c = co[upper][0], d = co[upper][1];\n\t\t\t\t\tuy = (d-b)*(x-a) >= 0 ? (d-b)*(x-a)/(c-a)+b : ((d-b)*(x-a)-(c-a-1))/(c-a)+b;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tint lonx = lower-1;\n\t\t\t\t\tif(lonx < 0)lonx += n;\n\t\t\t\t\tlong a = co[lonx][0], b = co[lonx][1];\n\t\t\t\t\tlong c = co[lower][0], d = co[lower][1];\n\t\t\t\t\tly = (d-b)*(x-a) >= 0 ? ((d-b)*(x-a)+(c-a-1))/(c-a)+b : (d-b)*(x-a)/(c-a)+b;\n\t\t\t\t}\n//\t\t\t\ttr(ly, uy, x);\n\t\t\t\tf[x-minx] = uy-ly+1;\n\t\t\t}\n//\t\t\tif(f[x-minx] < 0)f[x-minx] = 0;\n\t\t\tnum += f[x-minx];\n\t\t}\n\t\t\n\t\tdouble total = 0;\n\t\t{\n\t\t\tdouble[] g = new double[f.length];\n\t\t\tfor(int i = 0;i < f.length;i++)g[i] = f[i];\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += sum;\n\t\t\t\tsum += 2*f[i];\n\t\t\t}\n\t\t\tfor(int i = 1;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += g[i-1];\n\t\t\t}\n\t\t\tfor(int i = 1;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += g[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = maxx-minx-1;i >= 0;i--){\n//\t\t\tfor(int i = 0;i < maxx-minx;i++){\n\t\t\t\ttotal += (double)g[i] * f[i+1];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tfor(int i = 0, j = f.length-1;i < j;i++,j--){\n\t\t\t\tlong u = f[i]; f[i] = f[j]; f[j] = u;\n\t\t\t}\n\t\t\tdouble[] g = new double[f.length];\n\t\t\tfor(int i = 0;i < f.length;i++)g[i] = f[i];\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i = 0;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += sum;\n\t\t\t\tsum += 2*f[i];\n\t\t\t}\n\t\t\tfor(int i = 1;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += g[i-1];\n\t\t\t}\n\t\t\tfor(int i = 1;i < maxx-minx+1;i++){\n\t\t\t\tg[i] += g[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = maxx-minx-1;i >= 0;i--){\n//\t\t\tfor(int i = 0;i < maxx-minx;i++){\n\t\t\t\ttotal += (double)g[i] * f[i+1];\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n\t\n\tlong num;\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong double ans;\npair<int, int> Point[100005];\nlong double Number[2000005];\nlong double Partial[2000005], cnt = 0;\nconst int add = 1000000;\nvector<long double> Ox[2000005];\nvoid Read() {\n  cin >> N;\n  for (int i = 1; i <= N; i++) cin >> Point[i].first >> Point[i].second;\n}\nvoid Coef(long double& A, long double& B, long double& C,\n          pair<long double, long double> p1,\n          pair<long double, long double> p2) {\n  A = p1.second - p2.second;\n  B = p2.first - p1.first;\n  C = -A * p1.first - B * p1.second;\n}\nvoid precalcRange() {\n  Point[N + 1] = Point[1];\n  for (int i = 1; i <= N; i++) {\n    int left = Point[i].first, right = Point[i + 1].first;\n    if (left > right) swap(left, right);\n    if (left == right) {\n      Ox[left + add].push_back((long double)Point[i].second);\n      Ox[left + add].push_back((long double)Point[i + 1].second);\n      continue;\n    }\n    for (int j = left; j <= right; j++) {\n      long double A, B, C;\n      Coef(A, B, C, Point[i], Point[i + 1]);\n      long double Y = (-C - A * j) / (B);\n      Ox[j + add].push_back(Y);\n    }\n  }\n  for (int x = -1000000; x <= 1000000; x++) {\n    if (Ox[x + add].size() == 0) continue;\n    long double Min = Ox[x + add][0], Max = Min;\n    for (int i = 1; i < Ox[x + add].size(); i++) {\n      Min = min(Min, Ox[x + add][i]);\n      Max = max(Max, Ox[x + add][i]);\n    }\n    if (floor(Max) < ceil(Min)) continue;\n    Number[x + add] = floor(Max) - ceil(Min) + 1;\n  }\n}\nvoid Solve() {\n  long double sum = Number[0], curr = Number[0], last = Number[0];\n  Partial[0] = 2.0 * Number[0];\n  cnt = 0;\n  cnt += Number[0];\n  for (int i = -1000000 + 1; i <= 1000000; i++) {\n    cnt += Number[i + add];\n    if (i == 0) {\n      int d;\n      d = 0;\n    }\n    Partial[i + add] = 2.0 * Number[i + add];\n    ans += Number[i + add] * last;\n    if (i + add > 0) Partial[i + add] += Partial[i + add - 1];\n    sum += Partial[i + add] - Number[i + add];\n    last += sum;\n  }\n}\nint main() {\n  Read();\n  precalcRange();\n  Solve();\n  for (int i = 1; i <= N; i++) swap(Point[i].first, Point[i].second);\n  for (int i = 0; i <= add * 2; i++) {\n    Partial[i] = Number[i] = 0.0;\n    Ox[i].clear();\n  }\n  precalcRange();\n  Solve();\n  cout << fixed << setprecision(15) << ans / ((cnt) * (cnt - 1));\n  return 0;\n}\n"
        }
    ]
}