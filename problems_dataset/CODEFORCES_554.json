{
    "name": "554_C. Kyoya and Colored Balls",
    "source": "CODEFORCES",
    "description": "Kyoya Ootori has a bag with n colored balls that are colored with k different colors. The colors are labeled from 1 to k. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color i before drawing the last ball of color i + 1 for all i from 1 to k - 1. Now he wonders how many different ways this can happen. \n\nInput\n\nThe first line of input will have one integer k (1 \u2264 k \u2264 1000) the number of colors.\n\nThen, k lines will follow. The i-th line will contain ci, the number of balls of the i-th color (1 \u2264 ci \u2264 1000).\n\nThe total number of balls doesn't exceed 1000.\n\nOutput\n\nA single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1 000 000 007. \n\nExamples\n\nInput\n\n3\n2\n2\n1\n\n\nOutput\n\n3\n\n\nInput\n\n4\n1\n2\n3\n4\n\n\nOutput\n\n1680\n\nNote\n\nIn the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are: \n    \n    \n      \n    1 2 1 2 3  \n    1 1 2 2 3  \n    2 1 1 2 3  \n    ",
    "difficulty": "C",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "rating": 1500,
    "public_test": [
        {
            "input": "3\n2\n2\n1\n",
            "output": "3\n"
        },
        {
            "input": "4\n1\n2\n3\n4\n",
            "output": "1680\n"
        }
    ],
    "generated_test": [
        {
            "input": "25\n35\n43\n38\n33\n36\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n42\n46\n42\n34\n33\n",
            "output": "683385905\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n21\n23\n17\n15\n24\n19\n18\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "874969659\n"
        },
        {
            "input": "1\n3\n",
            "output": "1\n"
        },
        {
            "input": "5\n10\n5\n10\n10\n10\n",
            "output": "418394244\n"
        },
        {
            "input": "11\n291\n381\n126\n39\n19\n20\n3\n1\n20\n43\n2\n",
            "output": "133409084\n"
        },
        {
            "input": "4\n1\n4\n3\n4\n",
            "output": "13860\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n42\n46\n42\n34\n33\n",
            "output": "960840482\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n17\n15\n24\n19\n18\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "777222528\n"
        },
        {
            "input": "5\n10\n5\n10\n19\n10\n",
            "output": "704582418\n"
        },
        {
            "input": "11\n291\n394\n126\n39\n19\n20\n3\n1\n20\n43\n2\n",
            "output": "762530917\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n46\n42\n34\n33\n",
            "output": "447995088\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n17\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "436630400\n"
        },
        {
            "input": "5\n15\n5\n10\n19\n10\n",
            "output": "277332034\n"
        },
        {
            "input": "11\n291\n394\n126\n39\n19\n20\n3\n2\n20\n43\n2\n",
            "output": "757104390\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n46\n42\n34\n33\n",
            "output": "297569513\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "512670764\n"
        },
        {
            "input": "5\n15\n2\n10\n19\n10\n",
            "output": "337657833\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n20\n3\n2\n20\n43\n2\n",
            "output": "157057612\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n42\n34\n33\n",
            "output": "66678052\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "723498274\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n20\n3\n2\n20\n43\n3\n",
            "output": "497992827\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n64\n34\n33\n",
            "output": "125583648\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "126998154\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n20\n3\n2\n31\n43\n3\n",
            "output": "795265363\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n64\n11\n33\n",
            "output": "151250638\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "695576313\n"
        },
        {
            "input": "11\n291\n394\n52\n73\n19\n20\n3\n2\n31\n43\n3\n",
            "output": "71028079\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n11\n33\n",
            "output": "115424347\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "588344159\n"
        },
        {
            "input": "11\n291\n394\n52\n73\n19\n26\n3\n2\n31\n43\n3\n",
            "output": "944364428\n"
        },
        {
            "input": "25\n69\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n11\n33\n",
            "output": "960926976\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n25\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "742867140\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n2\n31\n43\n3\n",
            "output": "654505129\n"
        },
        {
            "input": "25\n69\n43\n38\n63\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n11\n33\n",
            "output": "610729591\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n30\n20\n25\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "566478672\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n2\n31\n68\n3\n",
            "output": "729515917\n"
        },
        {
            "input": "25\n69\n43\n38\n63\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n8\n77\n11\n33\n",
            "output": "511882986\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n38\n20\n19\n26\n30\n20\n25\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "173840134\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n3\n31\n68\n3\n",
            "output": "539856535\n"
        },
        {
            "input": "25\n69\n43\n38\n63\n27\n44\n40\n37\n41\n42\n33\n14\n49\n42\n62\n39\n40\n35\n43\n31\n19\n8\n77\n11\n33\n",
            "output": "620013562\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n3\n31\n119\n3\n",
            "output": "257936337\n"
        },
        {
            "input": "25\n69\n43\n38\n38\n27\n44\n40\n37\n41\n42\n33\n14\n49\n42\n62\n39\n40\n35\n43\n31\n19\n8\n77\n11\n33\n",
            "output": "741359563\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n3\n16\n119\n3\n",
            "output": "654952422\n"
        },
        {
            "input": "25\n69\n43\n38\n38\n27\n44\n40\n37\n41\n42\n33\n14\n58\n42\n62\n39\n40\n35\n43\n31\n19\n8\n77\n11\n33\n",
            "output": "728192535\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n26\n26\n3\n3\n16\n119\n3\n",
            "output": "255552417\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n22\n26\n24\n17\n18\n21\n22\n21\n23\n17\n15\n24\n13\n18\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "314954011\n"
        },
        {
            "input": "3\n188\n317\n337\n",
            "output": "607706537\n"
        },
        {
            "input": "5\n10\n10\n17\n10\n10\n",
            "output": "705078768\n"
        },
        {
            "input": "11\n291\n291\n126\n39\n19\n20\n3\n1\n20\n45\n2\n",
            "output": "664062671\n"
        },
        {
            "input": "3\n2\n2\n2\n",
            "output": "15\n"
        },
        {
            "input": "4\n2\n2\n3\n4\n",
            "output": "5400\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n36\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n49\n35\n43\n31\n42\n46\n42\n34\n33\n",
            "output": "807245750\n"
        },
        {
            "input": "5\n10\n5\n10\n2\n10\n",
            "output": "670344246\n"
        },
        {
            "input": "11\n291\n381\n126\n39\n19\n20\n3\n1\n20\n43\n1\n",
            "output": "46751493\n"
        },
        {
            "input": "4\n2\n4\n3\n4\n",
            "output": "61600\n"
        },
        {
            "input": "25\n7\n43\n38\n33\n27\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n42\n46\n42\n34\n33\n",
            "output": "997824461\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n11\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n17\n15\n24\n19\n18\n21\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "977947431\n"
        },
        {
            "input": "5\n10\n5\n20\n19\n10\n",
            "output": "930377845\n"
        },
        {
            "input": "11\n291\n394\n126\n54\n19\n20\n3\n1\n20\n43\n2\n",
            "output": "347669631\n"
        },
        {
            "input": "25\n35\n75\n38\n33\n27\n44\n40\n36\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n46\n42\n34\n33\n",
            "output": "785395614\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n17\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n30\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "627302562\n"
        },
        {
            "input": "5\n15\n5\n10\n19\n14\n",
            "output": "585017380\n"
        },
        {
            "input": "11\n214\n394\n126\n39\n19\n20\n3\n2\n20\n43\n2\n",
            "output": "400475244\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n43\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n46\n42\n34\n33\n",
            "output": "614705642\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n34\n20\n19\n26\n25\n20\n17\n17\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "89604172\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n16\n3\n2\n20\n43\n2\n",
            "output": "569301761\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n27\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n42\n34\n33\n",
            "output": "414231253\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n18\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n25\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "638382221\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n20\n3\n4\n20\n43\n3\n",
            "output": "345839683\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n4\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n64\n34\n33\n",
            "output": "934280941\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n20\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n30\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "328940714\n"
        },
        {
            "input": "11\n291\n394\n52\n39\n19\n20\n3\n2\n43\n43\n3\n",
            "output": "403670881\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n36\n62\n39\n40\n35\n43\n31\n19\n6\n64\n11\n33\n",
            "output": "460872653\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n24\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n20\n24\n19\n9\n21\n20\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "73100902\n"
        },
        {
            "input": "11\n291\n394\n52\n73\n19\n14\n3\n2\n31\n43\n3\n",
            "output": "110668519\n"
        },
        {
            "input": "25\n35\n43\n38\n33\n27\n80\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n11\n33\n",
            "output": "386012099\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n36\n19\n26\n25\n20\n17\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "923085909\n"
        },
        {
            "input": "11\n291\n394\n52\n73\n19\n26\n3\n4\n31\n43\n3\n",
            "output": "195591746\n"
        },
        {
            "input": "25\n69\n43\n38\n33\n27\n44\n40\n37\n41\n42\n33\n30\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n1\n33\n",
            "output": "672123031\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n25\n20\n25\n7\n17\n41\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "149753111\n"
        },
        {
            "input": "11\n291\n457\n52\n42\n19\n26\n3\n2\n31\n43\n3\n",
            "output": "605457812\n"
        },
        {
            "input": "25\n69\n43\n38\n63\n27\n44\n40\n37\n41\n42\n33\n16\n49\n42\n62\n39\n40\n35\n43\n31\n19\n6\n77\n11\n33\n",
            "output": "41476019\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n9\n21\n20\n19\n26\n30\n20\n25\n7\n17\n26\n32\n20\n21\n48\n51\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "805880511\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n19\n26\n3\n2\n8\n68\n3\n",
            "output": "294275718\n"
        },
        {
            "input": "47\n20\n21\n16\n18\n2\n7\n25\n13\n20\n20\n26\n24\n17\n18\n21\n22\n19\n23\n9\n15\n24\n19\n5\n38\n20\n19\n26\n30\n20\n25\n7\n17\n26\n32\n20\n21\n48\n28\n24\n21\n21\n17\n28\n20\n20\n31\n19\n",
            "output": "415341452\n"
        },
        {
            "input": "11\n291\n82\n52\n42\n19\n26\n3\n3\n31\n68\n3\n",
            "output": "584182163\n"
        },
        {
            "input": "25\n69\n43\n38\n63\n27\n44\n40\n37\n41\n42\n33\n14\n49\n42\n62\n39\n40\n35\n43\n31\n19\n8\n64\n11\n33\n",
            "output": "167316265\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n11\n26\n3\n3\n31\n119\n3\n",
            "output": "627529073\n"
        },
        {
            "input": "25\n69\n43\n38\n38\n27\n44\n40\n37\n41\n70\n33\n14\n49\n42\n62\n39\n40\n35\n43\n31\n19\n8\n77\n11\n33\n",
            "output": "514489760\n"
        },
        {
            "input": "11\n291\n394\n52\n42\n30\n26\n3\n3\n16\n119\n3\n",
            "output": "891327513\n"
        },
        {
            "input": "1\n4\n",
            "output": "1\n"
        },
        {
            "input": "1\n2\n",
            "output": "1\n"
        }
    ],
    "solution": [
        {
            "language": 1,
            "solution": "import sys\n\nfactorials = [1]\n\ndef newton(n, k):\n  global factorials\n  return factorials[n] / (factorials[k] * factorials[n - k])\n\ndef solve(x):\n  if len(x) == 1:\n    return 1\n  last = x.pop() - 1\n  n = sum(x) + last\n  k = last\n  return (solve(x) * newton(n, k)) % 1000000007\n\ndef preprocess():\n  for i in xrange(1, 1001):\n    factorials.append(factorials[-1] * i)\n\nif __name__ == '__main__':\n  sys.setrecursionlimit(1010)\n  k = int(raw_input())\n  x = []\n  preprocess()\n  for i in xrange(k):\n    x.append(int(raw_input()))\n  print solve(x)\n"
        },
        {
            "language": 1,
            "solution": "maxn=1010\nmod=10**9+7\na=[[0 for i in range(maxn)] for i in range(maxn)]\na[0][0]=1\nfor i in range(maxn):\n\ta[i][0]=1\n\tfor j in range(1,i+1):\n\t\ta[i][j]=(a[i-1][j-1]+a[i-1][j])%mod\n\nk=int(raw_input())\nb=[]\nfor i in range(k):\n\tb.append(int(raw_input()))\nans=1\ntot=0\nfor i in range(k):\n\tans=(ans*a[tot+b[i]-1][b[i]-1])%mod\n\ttot+=b[i]\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vikash Kumar\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Codeforces solver = new Codeforces();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Codeforces {\n        static int mod = (int) 1e9 + 7;\n        long[][] dp = new long[2010][2010];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            dp[1][1] = 1;\n            for (int i = 1; i < 2010; i++) {\n                dp[i][1] = i;\n                dp[i][i] = 1;\n                dp[i][0] = 1;\n            }\n            for (int i = 1; i < 2010; i++) {\n                for (int j = 1; j < 2010; j++) {\n                    dp[i][j] = Math.max(dp[i - 1][j] + dp[i - 1][j - 1], dp[i][j]) % mod;\n                }\n            }\n            int k = in.ni();\n            int[] color = in.nia(k);\n            int total = color[0];\n            long ans = 1;\n            for (int i = 1; i < k; i++) {\n                ans = (ans * dp[color[i] - 1 + total][color[i] - 1]) % mod;\n                total += color[i];\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public InputReader(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String n() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(n());\n        }\n\n        public int[] nia(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = ni();\n            return array;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int Mod = (int)1e9 + 7;\nconst int MX = 2147483647;\nconst long long MXLL = 9223372036854775807;\nconst int Sz = 1110111;\nusing namespace std;\ninline void Read_rap() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nlong long a[Sz], n, f[Sz], ans = 1, len = 0;\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) {\n      res *= a, res %= Mod;\n      b--;\n    }\n    a *= a;\n    a %= Mod;\n    b >>= 1;\n  }\n  return res;\n}\nlong long C(long long x, long long y) {\n  long long res = f[x + y - 1];\n  res *= binpow(f[x], Mod - 2);\n  res %= Mod;\n  res *= binpow(f[y - 1], Mod - 2);\n  res %= Mod;\n  return res;\n}\nint main() {\n  Read_rap();\n  f[0] = 1;\n  for (int i = 1; i < Sz; i++) f[i] = (f[i - 1] * i) % Mod;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    ans *= C(len, a[i]);\n    ans %= Mod;\n    len += a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, pair<long long, long long> > > L;\nset<pair<long long, long long> > Z;\nstruct N {\n  int l;\n  int d;\n};\nbool comp(N a, N b) { return a.l < b.l; }\nlong long combination[1010][1010];\nint main() {\n  long long k, c, i, j;\n  cin >> k;\n  combination[0][0] = 1;\n  for (i = 1; i < 1004; i++) {\n    combination[i][0] = 1;\n    for (j = 1; j < i + 1; j++) {\n      combination[i][j] =\n          (combination[i - 1][j] + combination[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  long long ans = 1, N = 0, R;\n  for (i = 0; i < k; i++) {\n    cin >> c;\n    N += c;\n    R = c - 1;\n    ans = (ans * combination[N - 1][R]) % 1000000007;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Bat-Orgil\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    static int mod= 1000000007;\n    static int[] c;\n    static int[] sum;\n    static int[][] comb;\n\n    public static int choose(int n, int k){\n        if(k==0 || k==n){\n            return 1;\n        }\n        if(n <= 10000 && k<1000 && comb[n][k]!=0){\n            return comb[n][k];\n        }\n        int ans= (choose(n-1,k-1)+ choose(n-1,k))%mod;\n        if(n<=10000 && k<1000){\n            comb[n][k]=ans;\n        }\n        return ans;\n    }\n    public static long ans(int k){\n        if(k==0){\n            return 1;\n        }else{\n            long l= choose(sum[k]-1,c[k]-1);\n            return (l*ans(k-1))%mod;\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int k =in.nextInt();\n        c= new int[k];\n        sum= new int[k];\n        for(int i=0; i<k; i++){\n            c[i]=in.nextInt();\n        }\n        sum[0]= c[0];\n        for(int i=1; i<k; i++){\n            sum[i]=sum[i-1]+c[i];\n        }\n        comb= new int[10001][1000];\n        long answer= ans(k-1);\n        out.println(answer);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nc = [[0]*1002 for _ in range(0,1002)]\nMOD = int(1e9+7)\n\nfor i in range(0,1002):\n    c[i][0] = c[i][i] = 1\n    for j in range(0,i):\n        c[i][j] = (c[i-1][j-1] + c[i-1][j])%MOD\n\nr = map(int,stdin.read().split())\n\nn = next(r)\nans = 1\nsum = 0\n\nfor _ in range(0,n):\n    x = next(r)\n    ans = (ans * c[sum+x-1][sum])%MOD\n    sum += x\n\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Main {\n\tprivate final int MOD = 1000000007;\n\tprivate final int MAX_N = 1002;\n\tprivate int K;\n\n\tpublic void solve() {\n\t\tint[][] tpas = new int[MAX_N][MAX_N];\n\t\tfor (int i = 1; i < MAX_N; i++) {\n\t\t\tfor (int j = 1; j < MAX_N; j++) {\n\t\t\t\tif (j == 0) { // \u884c\u306e\u5de6\u7aef\u306f 1\n\t\t\t\t\ttpas[i][j] = 1;\n\t\t\t\t} else if (j == i) { // \u884c\u306e\u53f3\u7aef\u3082 1\n\t\t\t\t\ttpas[i][j] = 1;\n\t\t\t\t\tbreak; // \u53f3\u7aef\u307e\u3067\u8a08\u7b97\u3057\u305f\u306e\u3067\u5185\u5074\u306e\u30eb\u30fc\u30d7\u304b\u3089\u629c\u3051\u308b\n\t\t\t\t} else {\n\t\t\t\t\t// \u884c\u306e\u9014\u4e2d\u306f\u4e00\u3064\u4e0a\u306e\u4e8c\u3064\u306e\u8981\u7d20\u306e\u5408\u8a08\n\t\t\t\t\ttpas[i][j] = tpas[i - 1][j - 1] + tpas[i - 1][j];\n\t\t\t\t\ttpas[i][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tK = sc.nextInt();\n\t\tif (K == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\tsc.close();\n\t\t\treturn;\n\t\t}\n\n\t\tint[] balls = new int[K];\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tballs[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tlong[] dp = new long[K];\n\t\tdp[0] = 1;\n\t\tint prevs = balls[0];\n\t\tfor (int k = 1; k < K; k++) {\n\t\t\tprevs += balls[k] - 1;\n\t\t\tint usable = balls[k] - 1;\n\t\t\tdp[k] = (long) dp[k - 1] * tpas[prevs + 1][usable + 1];\n\t\t\tdp[k] %= MOD;\n\t\t\tprevs++;\n\t\t}\n\t\tSystem.out.println(dp[K - 1]);\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void get_int(int &x) {\n  register int c = getchar();\n  x = 0;\n  int neg = 0;\n  for (; ((c < 48 || c > 57) && c != '-'); c = getchar())\n    ;\n  if (c == '-') {\n    neg = 1;\n    c = getchar();\n  }\n  for (; c > 47 && c < 58; c = getchar()) {\n    x = (x << 1) + (x << 3) + c - 48;\n  }\n  if (neg) x = -x;\n}\ninline void get_long(long long int &x) {\n  register int c = getchar();\n  x = 0;\n  int neg = 0;\n  for (; ((c < 48 || c > 57) && c != '-'); c = getchar())\n    ;\n  if (c == '-') {\n    neg = 1;\n    c = getchar();\n  }\n  for (; c > 47 && c < 58; c = getchar()) {\n    x = (x << 1) + (x << 3) + c - 48;\n  }\n  if (neg) x = -x;\n}\ninline void print_int(int X) {\n  if (X < 0) {\n    putchar('-');\n    X = -X;\n  }\n  int Len = 0, Data[20];\n  while (X) {\n    Data[Len++] = X % 10;\n    X /= 10;\n  }\n  if (!Len) Data[Len++] = 0;\n  while (Len--) putchar(Data[Len] + 48);\n  putchar('\\n');\n}\ninline void print_long(long long int X) {\n  if (X < 0) {\n    putchar('-');\n    X = -X;\n  }\n  int Len = 0, Data[20];\n  while (X) {\n    Data[Len++] = X % 10;\n    X /= 10;\n  }\n  if (!Len) Data[Len++] = 0;\n  while (Len--) putchar(Data[Len] + 48);\n  putchar('\\n');\n}\nlong long int modPow(long long int a, long long int x, long long int p) {\n  long long int res = 1;\n  while (x > 0) {\n    if (x & 1) {\n      res = (res * a) % p;\n    }\n    a = (a * a) % p;\n    x /= 2;\n  }\n  return res;\n}\nlong long int arr[5005];\nlong long int pas[5005][5005];\nvoid init() {\n  for (int i = 0; i < 2222; i++)\n    for (int j = 0; j < 2222; j++) pas[0][j] = pas[i][j] = 1;\n  for (int i = 2; i < 2222; i++)\n    for (int j = 1; j < i; j++) {\n      pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n      pas[i][j] %= 1000000007;\n    }\n}\nint main() {\n  init();\n  long long int i, k;\n  long long int s = 0;\n  get_long(k);\n  for (i = 0; i <= k - 1; i++) {\n    get_long(arr[i]);\n    s += arr[i];\n  }\n  s -= 1;\n  long long int ans = 1;\n  for (i = k - 1; i >= 0; i--) {\n    ans *= pas[s][arr[i] - 1];\n    ans %= 1000000007;\n    s -= arr[i];\n  }\n  print_long(ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class A553 {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        int k = scan.nextInt();\n\n        BigInteger count = BigInteger.valueOf(1);\n\n        int space = 1;\n        for (int i = 0; i < k; i++) {\n            int num = scan.nextInt();\n\n            count = count.multiply(partition(num - 1, space));\n            space += num;\n        }\n\n        System.out.println(count.mod(BigInteger.valueOf(1000000007)));\n    }\n\n    public static BigInteger partition(int a, int b) {\n\n        BigInteger rtn = BigInteger.valueOf(1);\n\n        if (b <= 1 || a <= 0) {\n            return rtn;\n        }\n\n        for (int i = 0; i < b - 1; i++) {\n            BigInteger x = BigInteger.valueOf(a + b - 1 - i);\n            rtn = rtn.multiply(x);\n        }\n        for (int i = 1; i < b; i++) {\n            rtn = rtn.divide(BigInteger.valueOf(i));\n        }\n\n        return rtn;\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "ans,s=1,0\nfor _ in range(int(input())):\n\tn=int(input())\n\ts+=n\n\tif s==n:continue\n\tk=1\n\tfor i in range(1,n):\n\t\tk=k*(s-i)//i\n\tans=(ans*k)%(10**9+7)\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class File {\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\t\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\n\t\t\n\t\tint k = sc.nextInt();\n\t\tint[] counts = new int[k];\n\t\tint[] pre = new int[k];\n\t\tint total = 0;\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tcounts[i] = sc.nextInt();\n\t\t\ttotal += counts[i];\n\t\t\tpre[i] = total;\n\t\t}\n\t\t\n\t\tlong[][] dp = new long[1001][1001];\n\t\t// Ways = (total[c-1] + count[c] - 1) Choose (count[c] - 1)\n\t\t// n choose k = (n-1) choose (k-1) + (n-1) choose (k)\n\t\t\n\t\tlong mod = 1000000007;\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor (int i = 1; i <= 1000; i++) {\n\t\t\tdp[i][0] = 1L;\n\t\t\t\n\t\t\tfor (int j = 1; j <= 1000; j++) {\n\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong res = 1;\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint N = i > 0 ? pre[i-1] : 0;\n\t\t\tres = (res  * (dp[N + counts[i] - 1][counts[i] - 1])) % mod;\n\t\t}\n\t\t\n\t\tout.println(res);\n\t\t\n\t\t\n\t\t\n\t\tout.close();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7, MAXN = 1002;\nint C[MAXN][MAXN], A[MAXN];\nint main() {\n  for (int i = 0; i < MAXN; i++)\n    for (int l = 0; l < MAXN; l++) {\n      if (!i || !l || i == l)\n        C[i][l] = 1;\n      else\n        C[i][l] = (C[i - 1][l] + C[i - 1][l - 1]) % MOD;\n    }\n  int n, sum = 0, tot;\n  long long ans = 1;\n  scanf(\"%d\", &n), tot = n;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &A[i]), sum += A[i];\n  for (int i = n - 1; i >= 0; i--) {\n    ans = (ans * C[sum - 1][A[i] - 1]) % MOD;\n    sum -= A[i];\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 1,
            "solution": "\nMOD=10**9+7\nMAXN=10**6+2;\nn=int(raw_input())\nfact=[1 for i in xrange(MAXN)]\nfor i in xrange(1,MAXN):\n    fact[i]=fact[i-1]*i%MOD;\n\ndef calc(a,b):\n    ans=1\n    while b>0:\n        if (b&1)==1:\n            ans=ans*a%MOD\n        a=a*a%MOD;\n        b=b>>1\n    return ans\n\ndef binary_coeffient(n,m):\n    if n<m:\n        return 0\n    if m==n or m==0:\n        return 1\n    ans=fact[n]*calc(fact[m],MOD-2)*calc(fact[n-m],MOD-2);\n    ans%=MOD;\n    return ans;\n\nans=1\ns=0\nfor i in xrange(n):\n    c=int(raw_input())\n    tmp=binary_coeffient(s+c-1,c-1)\n    s+=c\n    ans=ans*tmp%MOD\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.InputMismatchException;\n\nimport org.xml.sax.HandlerBase;\n\npublic class Solution \n{\n    public static void main(String[] args) {\n       new Solution().solve();\n    }\n    \n    PrintWriter out;\n   long[][] arr=new long[1001][10001];\n   long mod=1000000007L ;\n    public void solve()\n    {\n        out=new PrintWriter(System.out);\n        for(int i=0;i<arr.length;i++)\n        {\n            arr[i][0]=1L;\n            arr[i][1]+=i;\n        }\n        arr[2][2]=1;\n        for(int i=3;i<arr.length;i++)\n        {\n            for(int j=2;j<=i;j++)\n            {\n                arr[i][j]=(arr[i-1][j-1]+arr[i-1][j])%mod;\n            }\n        }\n        int k=in.nextInt();\n        long ans=1L;\n        int prv=in.nextInt();\n        for(int i=1;i<k;i++)\n        {\n            int t=in.nextInt();\n        //  System.out.println((prv+1)+\" \"+(t-1));\n            ans*=arr[prv+t-1][prv];\n            \n            prv+=t;\n            ans%=mod;\n        //  System.out.println(ans);\n        }\n        System.out.println(ans);\n        out.close();\n    }\n   \n\n   \n    public static int gcd(int a, int b) {\n        BigInteger b1 = BigInteger.valueOf(a);\n        BigInteger b2 = BigInteger.valueOf(b);\n        BigInteger gcd = b1.gcd(b2);\n        return gcd.intValue();\n    }\n    \n        \n        \n    FasterScanner in=new FasterScanner();\n\n    public static class FasterScanner {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = System.in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nlong long c[1005][1005];\nlong long a[maxn];\nvoid init() {\n  int i, j;\n  c[0][0] = 1;\n  for (i = 1; i <= 1000; i++) {\n    for (j = 0; j <= 1000; j++) {\n      if (j == 0)\n        c[i][j] = 1;\n      else\n        c[i][j] = (c[i - 1][j] + c[i][j - 1]) % MOD;\n    }\n  }\n  return;\n}\nint main() {\n  int i, j, n, m, t, z;\n  init();\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  long long sum = 1;\n  long long ans = 1;\n  for (i = 1; i <= n; i++) {\n    ans = ans * c[sum][a[i] - 1] % MOD;\n    sum = (sum + a[i]) % MOD;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod_minus(long long a, long long b) {\n  return (a - b + 1000000007) % 1000000007;\n}\nint ara[1005];\nlong long dp[1005], fake_place[1005][1005];\nlong long func(int seat, int ball) {\n  if (!ball) return 1;\n  if (seat == 1) return 1;\n  if (fake_place[seat][ball] != -1) return fake_place[seat][ball];\n  int i;\n  long long ans = 0;\n  for (i = 0; i <= ball; i++) {\n    ans += func(seat - 1, i);\n    ans %= 1000000007;\n  }\n  return fake_place[seat][ball] = ans;\n}\nint main() {\n  int k, i, j;\n  for (i = 0; i < 1005; i++)\n    for (j = 0; j < 1005; j++) fake_place[i][j] = -1;\n  scanf(\"%d\", &k);\n  for (i = 0; i < k; i++) scanf(\"%d\", &ara[i]);\n  dp[0] = 1;\n  int total = ara[0];\n  for (i = 1; i < k; i++) {\n    dp[i] =\n        dp[i - 1] * (mod_minus(func(total + 1, ara[i]), func(total, ara[i])));\n    dp[i] %= 1000000007;\n    total += ara[i];\n  }\n  printf(\"%I64d\\n\", dp[k - 1]);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def main():\n    k = int(raw_input())\n    a = [int(raw_input()) for _ in xrange(k)]\n    b = [0] * 4000\n    c = [0] * 4000\n    t = 1\n    for x in a:\n        b[t + x - 2] += 1\n        c[t - 1] += 1\n        c[x - 1] += 1\n        t += x\n    ans = x = t = 1\n    mod = 1000000007\n    for i in xrange(1, 4000):\n        t = t * i % mod\n        ans = ans * pow(t, b[i], mod) % mod\n        x = x * pow(t, c[i], mod) % mod\n    ans = ans * pow(x, mod - 2, mod) % mod\n    print ans\nmain()\n"
        },
        {
            "language": 1,
            "solution": "n=input()\narr=[]\ni=0\nwhile i<n:\n    x=input()\n    arr.append(x)\n    i=i+1\nfac=[1]\ni=1\np=1\nwhile i<=1000:\n    p=p*i\n    fac.append(p)\n    i=i+1\ni=0\np=1\nsm=0\nwhile i<n-1:\n    sm=sm+arr[i]\n    p=(p* (fac[sm+arr[i+1]-1]/(fac[sm]*fac[arr[i+1]-1]))%1000000007)%1000000007\n    i=i+1\nprint p%1000000007\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid out(T x) {\n  cout << x << endl;\n  exit(0);\n}\nconst int maxn = 1e6 + 5;\nconst long long mod = 1e9 + 7;\nlong long fac[maxn], ifac[maxn];\nlong long modpow(long long, long long);\nlong long inv(long long);\nlong long nck(long long, long long);\nvoid build();\nvoid testlib();\nint k, c[maxn], acc[maxn];\nlong long f[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  build();\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> c[i];\n    acc[i] = c[i] + acc[i - 1];\n  }\n  f[1] = 1;\n  for (int i = 2; i <= k; i++) {\n    f[i] = nck(acc[i] - 1, c[i] - 1) * f[i - 1];\n    while (f[i] < 0) f[i] += mod;\n    f[i] %= mod;\n  }\n  f[k] %= mod;\n  cout << f[k] << endl;\n  return 0;\n}\nlong long modpow(long long x, long long y) {\n  x %= mod;\n  long long res = 1;\n  while (y > 0) {\n    if (y % 2 == 1) {\n      res *= x;\n      res %= mod;\n    }\n    x = x * x;\n    x %= mod;\n    y = y / 2;\n  }\n  return res;\n}\nlong long inv(long long x) {\n  assert(x != 0);\n  return modpow(x, mod - 2);\n}\nvoid build() {\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    fac[i] = fac[i - 1] * i;\n    fac[i] %= mod;\n    ifac[i] = inv(fac[i]);\n    ifac[i] %= mod;\n  }\n}\nlong long nck(long long n, long long k) {\n  assert(n >= 0 && k >= 0);\n  if (k > n) return 0;\n  long long res = (((fac[n] * ifac[k]) % mod) * ifac[n - k]) % mod;\n  assert(res > 0);\n  return res;\n}\nvoid testlib() {\n  assert(modpow(1, 1) == 1);\n  assert(modpow(4, 2) == 16);\n  assert(modpow(2, 5) == 32);\n  assert(fac[3] == 6);\n  assert(nck(4, 2) == 6);\n  assert(nck(10, 2) == 45);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\nint k, n, a[1010];\nint C[1010][1010];\nint main() {\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n    n += a[i];\n  }\n  C[1][0] = C[1][1] = 1;\n  for (int i = 2; i <= 1000; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n  }\n  int res = 1;\n  for (int i = k; i >= 2; i--) {\n    res = 1ll * res * C[n - 1][a[i] - 1] % mod;\n    n -= a[i];\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from math import factorial\n\nn = input()\nm = 1\nl = 0\n\n\nfor i in range(n):\n    if i == 0:\n        x = input()\n        l += x\n    else:\n        x = input()\n        if x > 1:\n            L = l+1\n            X = x-1\n            h = factorial(L+X-1)/(factorial(X)*factorial(L-1))\n            m = h*m\n        l += x\nprint m%1000000007\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXK = 1000;\nconst int mod = 1000000007;\nint arr[MAXK + 10];\nint acc[MAXK + 10];\nint ncr[MAXK + 10][MAXK + 10];\nint main() {\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> arr[i];\n  for (int i = 1; i <= k; i++) acc[i] = acc[i - 1] + arr[i];\n  for (int i = 0; i <= MAXK; i++) ncr[i][0] = 1;\n  for (int i = 1; i <= MAXK; i++)\n    for (int j = 1; j <= MAXK; j++)\n      ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod;\n  long long res = 1;\n  for (int i = 2; i <= k; i++) res = (res * ncr[acc[i] - 1][arr[i] - 1]) % mod;\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Created by hama_du on 15/06/25.\n */\npublic class A {\n\n    private static final long MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] ball = new int[n];\n        for (int i = 0; i < n ; i++) {\n            ball[i] = in.nextInt();\n        }\n        \n        long[][] C = new long[1010][1010];\n        for (int i = 0; i < C.length ; i++) {\n            C[i][0] = C[i][i] = 1;\n            for (int j = 1 ; j < i ; j++) {\n                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n            }\n        }\n\n        long ptn = 1;\n        int length = 0;\n        for (int i = 0; i < n; i++) {\n            int left = ball[i]-1;\n            ptn *= C[left+length][left];\n            ptn %= MOD;\n            length += ball[i];\n        }\n\n        out.println(ptn);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char)c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char)c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char)c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class ColoredBalls {\n\n\tprivate static final long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[] colors = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcolors[i] = scanner.nextInt();\n\t\t}\n\t\tlong sum = 1;\n\t\tint total = colors[0];\n\t\tfor (int i = 1; i<n; i++) {\n\t\t\tsum *= perms(total, colors[i]);\n\t\t\ttotal += colors[i];\n\t\t\tsum %= mod;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\t\n\tprivate static long perms(int numPre, int numBalls) {\n\t\tif ( numBalls <= 1) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n//\t\tint [] numerators = new int[numBalls];\n//\t\tint [] denumerators = new int[numBalls];\n\t\tBigInteger b = BigInteger.ONE;\n\t\tBigInteger den = BigInteger.ONE;\n\t\tfor (int i = numBalls - 1; i >= 1; i--) {\n\t\t\tlong choices = numPre + i;\n\t\t\tb = b.multiply(BigInteger.valueOf(choices));\n\t\t\tden = den.multiply(BigInteger.valueOf(i));\n\t\t}\n\t\t\n\t\tb = b.divide(den);\n\t\tb = b.mod(BigInteger.valueOf(mod));\n\t\treturn b.longValue();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long mod(long long n, long long m) {\n  long long ret = n % m;\n  if (ret < 0) ret += m;\n  return ret;\n}\nlong long gcd(long long a, long long b) { return (b == 0 ? a : gcd(b, a % b)); }\nlong long exp(long long a, long long b, long long m) {\n  if (b == 0) return 1;\n  if (b == 1) return mod(a, m);\n  long long k = mod(exp(a, b / 2, m), m);\n  if (b & 1) {\n    return mod(mod(k * k, m) * a, m);\n  } else\n    return mod(k * k, m);\n}\nlong long c[1010];\nlong long f[1010];\nlong long fat[1010];\nlong long inv[1010];\nlong long comb(long long a, long long b) {\n  long long res = fat[a];\n  res = mod(res * inv[b], 1000000007);\n  res = mod(res * inv[a - b], 1000000007);\n  return res;\n}\nint32_t main() {\n  long long k;\n  cin >> k;\n  for (long long i = 1; i <= k; i++) cin >> c[i];\n  fat[1] = fat[0] = 1;\n  inv[0] = inv[1] = 1;\n  for (long long i = 1; i <= 1010; i++) {\n    fat[i] = mod(fat[i - 1] * i, 1000000007);\n    inv[i] = exp(fat[i], 1000000007 - 2, 1000000007);\n  }\n  f[1] = 1;\n  long long soma = c[1];\n  for (long long i = 2; i <= k; i++) {\n    soma = mod(soma + c[i], 1000000007);\n    f[i] = mod(f[i - 1] * comb(soma - 1, c[i] - 1), 1000000007);\n  }\n  cout << f[k] << \"\\n\";\n}\n"
        },
        {
            "language": 1,
            "solution": "# cook your code here\nP = 1000000007\ndef fact(N):\n    x = 1\n    for i in xrange(1,N+1):\n        x *= i\n    return x\ndef nCk(n,k):\n    if k == 0:\n        return 1\n    return (fact(n)/(fact(k)*fact(n-k)))%P\nK = int(raw_input())\nr = 1\ns = int(raw_input())\nfor _ in xrange(K-1):\n    c = int(raw_input())\n    s += c\n    s -= 1\n    r = (r * nCk(s,c-1))%P\n    s += 1\nprint r%P"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static java.lang.Math.ceil;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        File file = new File(\"in.txt\");\n        File fileOut = new File(\"out.txt\");\n        InputStream inputStream = null;\n        OutputStream outputStream = null;\n        // try {inputStream= new FileInputStream(file);} catch (FileNotFoundException ex){return;};\n//        try {outputStream= new FileOutputStream(fileOut);} catch (FileNotFoundException ex){return;};\n        inputStream = System.in;\n        outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n\n}\n\nclass Task {\n    final Long mod = 1000000007L;\n    long[][] comb;\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        Integer n = in.nextInt();\n\n        Long result = 1L;\n        computeComb();\n        int[] counts = new int[n];\n        for(int i=0; i<n; i++){\n            counts[i] = in.nextInt();\n        }\n        Integer currentLength = 0;\n\n        for(int i=0; i<n; i++){\n            Integer ballCount = counts[i];\n            Integer positions = currentLength + ballCount -1;\n            Long temp = chooseMod(positions, ballCount-1);\n            result = (result * temp) % mod;\n            currentLength += ballCount;\n        }\n\n\n\n        out.println(result);\n\n\n\n\n\n\n    }\n\n    public void computeComb(){\n        comb = new long[1010][1010];\n        comb[0][0] = 1;\n        for(int i=1; i<1010; i++){\n            comb[i][0] = 1;\n            for(int j=1; j<=i; j++){\n                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % mod;\n            }\n        }\n\n    }\n\n    public Long chooseMod(Integer n, Integer k){\n        return comb[n][k];\n    }\n\n\n\n\n\n\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine(){\n        try {\n            return reader.readLine();\n        } catch (IOException e){\n            throw new RuntimeException(e);\n        }\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() { return Long.parseLong(next()); }\n\n}\n\n\n\nclass Pair<F, S> {\n    public final F first;\n    public final S second;\n\n\n\n\n    public Pair(F first, S second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Pair)) {\n            return false;\n        }\n        Pair<?, ?> p = (Pair<?, ?>) o;\n        return Objects.equals(p.first, first) && Objects.equals(p.second, second);\n    }\n\n    @Override\n    public int hashCode() {\n        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + first + \", \" + second + ')';\n    }\n}\n\nclass IntPair extends Pair<Integer, Integer>{\n    public IntPair(Integer first, Integer second){\n        super(first, second);\n    }\n}\n\nclass LPair extends Pair<Long, Long>{\n    public LPair(Long first, Long second){\n        super(first, second);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1009, mod = 1e9 + 7;\nlong long k, c[N], i, j, n, ncr[N][N], ans = 1;\nint main() {\n  for (i = 0; i < N; i++) ncr[i][0] = 1;\n  for (i = 1; i < N; i++) {\n    for (j = 0; j <= i; j++)\n      ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % mod;\n  }\n  scanf(\"%lld\", &k);\n  for (i = 0; i < k; i++) {\n    scanf(\"%lld\", &c[i]);\n    n += c[i];\n    ans = (ans * ncr[n - 1][c[i] - 1]) % mod;\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        final long mod = (long) 1e9 + 7;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int nmax = 1001;\n            long[][] C = new long[nmax][nmax];\n            C[0][0] = 1;\n            for (int i = 1; i < nmax; i++) {\n                C[i][0] = 1;\n                for (int j = 1; j <= i; j++) {\n                    C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n                }\n            }\n\n            int colors = in.nextInt();\n            int[] balls = new int[colors];\n\n            for (int i = 0; i < colors; i++) {\n                balls[i] = in.nextInt();\n            }\n            int sum = 0;\n            long ans = 1L;\n            long[] dp = new long[colors];\n\n\n            for (int i = 0; i < colors; i++) {\n                dp[i] = C[sum + balls[i] - 1][balls[i] - 1];\n                sum += balls[i];\n            }\n\n            for (int i = 0; i < colors; i++) {\n                ans = ans * dp[i] % mod;\n            }\n            out.println(ans);\n\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader reader;\n        StringTokenizer st;\n\n        public FastReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            st = null;\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String line = reader.readLine();\n                    if (line == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(line);\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nn,ans,s = int(input()),1,0\nfor i in range(n) :\n  a = int(input())\n  ans=(ans*factorial(s+a-1)//factorial(s)//factorial(a-1))%1000000007\n  s+=a\nprint(ans)\n\n\n#copied...\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007L;\nint k;\nint c[1000];\nlong long leftSum[1000];\nlong long nn[1001];\nlong long coolPow(long long x, long long y) {\n  if (y == 0) return 1;\n  if (y == 1) return x;\n  long long pp = coolPow(x, y / 2);\n  return (((pp * pp) % mod) * coolPow(x, y % 2)) % mod;\n}\nlong long N(long long k) {\n  if (k == 1) return 1;\n  if (nn[k]) return nn[k];\n  long long sum = N(k - 1);\n  long long left = 1;\n  long long s = 1;\n  for (; left < c[k - 1]; left++) {\n    s = (s * (leftSum[k - 2] + left - 1)) % mod;\n    long long leftInv = coolPow(left, mod - 2);\n    s = (s * leftInv) % mod;\n    sum = (sum + N(k - 1) * s) % mod;\n  }\n  nn[k] = sum;\n  return sum;\n}\nint main(int argc, char *argv[]) {\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  leftSum[0] = c[0];\n  for (int i = 1; i < k; i++) leftSum[i] = leftSum[i - 1] + c[i];\n  cout << N(k) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long n;\nlong long a[1005];\nlong long fac[1000005];\nlong long ppow(long long a, long long b) {\n  long long c = 1;\n  while (b) {\n    if (b & 1) c = c * a % mod;\n    b >>= 1;\n    a = a * a % mod;\n  }\n  return c;\n}\nlong long work(long long m, long long i) {\n  return ((fac[m] % mod) * (ppow((fac[i] * fac[m - i]) % mod, mod - 2) % mod)) %\n         mod;\n}\nint main() {\n  long long i, j, k;\n  fac[0] = 1;\n  for (i = 1; i < 1000005; i++) fac[i] = (fac[i - 1] * i) % mod;\n  long long ans = 1, sum = 0;\n  scanf(\"%I64d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    sum += a[i];\n  }\n  for (i = n; i >= 1; i--) {\n    ans *= work(sum - 1, a[i] - 1);\n    ans %= mod;\n    sum -= a[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "mod = 10**9+7\nfactorial = [1 for i in range(10**3+3)]\nifactorial = [1 for i in range(10**3+3)]\n\ndef nCr(n,r):\n    res = 1\n    res = res*factorial[n]%mod\n    res = res*ifactorial[r]%mod\n    res = res*ifactorial[n-r]%mod\n    return res\n\ndef fill():\n    for i in range(1,10**3+3):\n        factorial[i] = i*factorial[i-1]%mod\n        ifactorial[i] = pow(factorial[i],(mod-2),mod)%mod\nfill()\nn = input()\nballs = []\nfor i in range(n):\n    balls.append(input())\ncountUpto = 0\nans = 1\nfor i in balls:\n    countUpto += i\n    ans = ( ans*factorial[countUpto-1]*ifactorial[i-1]*ifactorial[countUpto-i] )%mod\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e3 + 5;\nlong long dp[MAXN + 1][MAXN + 1];\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n  long long i, N, j;\n  cin >> N;\n  long long K[N + 1];\n  for (i = 0; i < N; i++) cin >> K[i];\n  for (i = 0; i < MAXN + 1; i++)\n    for (j = 0; j < i + 1; j++)\n      if (j == 0 || i == j)\n        dp[i][j] = 1LL;\n      else\n        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 1000000007LL;\n  long long balls_so_far = 0LL;\n  long long ways = 1LL;\n  for (i = 0; i < N; i++) {\n    if (i) {\n      long long empty = balls_so_far;\n      long long prev_ways = ways;\n      for (j = 1; j < K[i]; j++) {\n        ways = (ways + prev_ways * dp[empty + j - 1][empty - 1]) % 1000000007LL;\n      }\n    }\n    balls_so_far += K[i];\n  }\n  cout << ways;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nlong long binpow(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n & 1) {\n      res *= a;\n      res %= MOD;\n    }\n    a *= a;\n    a %= MOD;\n    n >>= 1;\n  }\n  return res;\n}\nlong long invert(long long num) { return binpow(num, MOD - 2); }\nconst long long MAXN = 3000;\nlong long fact[MAXN];\nlong long cnk(long long n, long long k) {\n  long long ret = fact[n];\n  ret *= invert(fact[k]);\n  ret %= MOD;\n  ret *= invert(fact[n - k]);\n  ret %= MOD;\n  return ret;\n}\nlong long num_comb(long long n, long long r) {\n  if (r == 0) {\n    return 1;\n  }\n  return cnk(r + n - 1, r);\n}\nvoid solve(int k) {\n  vector<long long> c(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> c[i];\n  }\n  vector<long long> dp(k + 1, 0);\n  dp[0] = 1;\n  long long total_c = 0;\n  for (long long i = 0; i < k; ++i) {\n    const long long f = num_comb(total_c + 1, c[i] - 1);\n    dp[i + 1] = dp[i] * f;\n    dp[i + 1] %= MOD;\n    total_c += c[i];\n  }\n  cout << dp[k] << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  fact[0] = 1;\n  for (long long i = 1; i < MAXN; ++i) {\n    fact[i] = fact[i - 1] * i;\n    fact[i] %= MOD;\n  }\n  int k;\n  while (cin >> k) {\n    solve(k);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double PI = acos(-1.0);\nconst double EPS = 1E-6;\nconst int INF = 2 * (1e+9) + 1;\nconst int MAXN = 3 * 100000001;\nconst int MOD = (1e+9) + 7;\nlong long c[1003][1003];\nconst int MD = 1000000000 + 7;\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    c[i][0] = c[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n      if (c[i][j] >= MD) {\n        c[i][j] -= MD;\n      }\n    }\n  }\n  long long ans = 1;\n  int n;\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    sum += x - 1;\n    ans = (ans * c[sum][x - 1]) % MD;\n    sum++;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int com[1005][1005];\nvoid cal() {\n  int i, j;\n  com[0][0] = 1;\n  for (i = 1; i < 1005; i++) {\n    com[i][0] = 1;\n    for (j = 1; j <= i; j++)\n      com[i][j] = (com[i - 1][j] + com[i - 1][j - 1]) % 1000000007;\n  }\n}\nint main() {\n  long long int i, k;\n  cal();\n  long long int c[1005];\n  cin >> k;\n  long long int n = 0, ans = 1;\n  for (i = 0; i < k; i++) {\n    cin >> c[i];\n    ans = (ans * com[n + c[i] - 1][c[i] - 1]) % 1000000007;\n    n += c[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\tstatic long[] fact, facti, invs;\n\tpublic static void main(String[] args) {\n\t\tfact = new long[1001];\n\t\tfacti = new long[1001];\n\t\tinvs = new long[1001];\n\t\tfact[0] = facti[0] = invs[1] = 1;\n\t\tfor(int i=1;i<fact.length;i++) {\n\t\t\tif(i >= 2)\n\t\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tfacti[i] = (facti[i-1] * invs[i]) % MOD;\n\t\t}\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tlong ans = 1;\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c = in.nextInt();\n\t\t\tans *= multichoose(cnt + 1, c - 1);\n\t\t\tans %= MOD;\n\t\t\tcnt += c;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long multichoose(int n, int k) {\n\t\treturn choose(n + k - 1, k);\n\t}\n\tstatic final long MOD = (long) (1e9 + 7);\n\tpublic static long choose(int n, int k) {\n\t\treturn (((fact[n]*facti[k]) % MOD)*facti[n-k]) % MOD;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class TaskC {\n    static final int MOD = 1000000007;\n    static final int MAXN = 1000;\n    void solve() {\n        int k = in.nextInt();\n        int[] colors = new int[k];\n        for (int i = 0; i<k; i++){\n            colors[i] = in.nextInt();\n        }\n\n        long[][] comb = new long[MAXN][MAXN];\n        comb[0][0] = 1;\n        for (int i =1; i < MAXN; i++){\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++){\n                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD;\n            }\n        }\n\n        long ans = 1;\n        int total = colors[0];\n        for (int i = 1; i < k; i++){\n            ans = (ans * comb[total + colors[i] - 1][colors[i] - 1]) % MOD;\n            total += colors[i];\n        }\n        out.println(ans);\n    }\n\n    InputReader in;\n    PrintWriter out;\n\n    void runIO() {\n\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new TaskC().runIO();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, x, y, l, r;\ndouble a, b, c, d, q;\nvector<int> V;\nvector<vector<int> > D;\nstring s, k, z;\nlong long res = 0;\ndouble eps = 0.000000001;\nconst int INF = 1000000007;\nconst int MAXNUM = 1005;\nint main() {\n  long long arr[MAXNUM][MAXNUM] = {0};\n  arr[0][0] = 1;\n  for (int i = 1; i < MAXNUM; i++) {\n    arr[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1]) % INF;\n    }\n  }\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> m;\n    V.push_back(m);\n  }\n  m = 0;\n  res = 1;\n  for (int i = 0; i < n; i++) {\n    res = (res * arr[m + V[i] - 1][V[i] - 1]) % INF;\n    m += V[i];\n  }\n  cout << res % INF << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.awt.*;\n\npublic class Main {\n    static int mod=(int)1e9+7;\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n        StringBuilder sb = new StringBuilder();\n        long fact[]=new long[1000001];\n        fact[0]=1;\n        for (int i=1;i<=1000;i++)fact[i]=(i*fact[i-1])%mod;\n        int k=sc.nextInt();\n        int[] arr=new int[k];\n        int sum=0;\n        for(int i=0;i<k;i++){\n            arr[i]=sc.nextInt();\n            sum+=arr[i];\n        }\n        long ans=1;\n\n        for(int i=k-1;i>=1;i--){\n            long temp=(fact[sum-1]*binpow((fact[arr[i]-1]*fact[(sum-1)-(arr[i]-1)])%mod,mod-2))%mod;\n            ans=(ans*temp)%mod;\n            sum-=arr[i];\n        }\n        System.out.println(ans);\n    }\n    static long binpow(long a,  long b){\n        a %= mod;\n        long res = 1;\n        while (b > 0) {\n            if ((b&1)==1) res = (res * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res%mod;\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int nextInt() { return Integer.parseInt(next()); }\n    long nextLong() { return Long.parseLong(next()); }\n    double nextDouble() { return Double.parseDouble(next()); }\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic long MOD = (long)1e9 + 7;\n\tstatic long [][] comb; \n\tstatic long comb(int n, int k)\t\t\n\t    {\n\t        if(n < k)\n\t            return 0;\n\t        if(k == 0 || k == n)\t\t\n\t            return 1;\n\t        if(comb[n][k] != -1)\n\t            return comb[n][k];\n\t        if(n - k < k)\n\t            return comb[n][k] = comb(n, n - k);\t\t\n\t        return comb[n][k] = (comb(n - 1, k - 1) + comb(n - 1 , k)) % MOD;\n\t    }\n\t public static void main(String[] args) {\n\t\t Scanner sc = new Scanner(System.in);\n\t\t comb = new long [1001][1001];\n\t\t for (int i = 0 ; i < 1001 ; ++ i) Arrays.fill(comb[i] , - 1);\n\t\t int n = sc.nextInt();\n\t\t long res = 1;\n\t\t int sum = sc.nextInt();\n\t\t for (int i = 1 ; i < n ; ++ i) {\n\t\t\t int now = sc.nextInt();\n\t\t\t res = (res * (comb(sum + now - 1 , now - 1))) % MOD;\n\t\t\t sum += now;\n\t\t }\n\t\t System.out.println(res);\n\t }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class KyoyaAndColoredBalls {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\t\n\tstatic final long MOD = 1000000007l; \n\t\n\tstatic int [][] combs;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint [] array = new int[n];\n\t\tint totalBalls = 0;\n\t\tint maxColor = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttotalBalls += array[i] = Integer.parseInt(br.readLine());\n\t\t\tif (array[i] > maxColor) \n\t\t\t\tmaxColor = array[i];\n\t\t}\n\t\t\n\t\tconstructCombs(totalBalls, array, maxColor);\n\t\t\n\t\tlong result = 1;\n\t\t\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tresult = (result * getCombinations(totalBalls - 1, array[i] - 1)) % MOD;\n\t\t\ttotalBalls -= array[i];\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\tprivate static void constructCombs(int totalBalls, int[] array, int max) {\n\t\tcombs = new int[totalBalls + 1][max + 1];\n\t\tfor (int i = 0; i <= totalBalls; i++) {\n\t\t\tcombs[i][0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < totalBalls; i++) {\n\t\t\tfor (int j = 1; j < max; j++) {\n\t\t\t\tcombs[i][j] = (int) ((combs[i - 1][j] + combs[i - 1][j - 1]) % MOD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static long getCombinations(int n, int r) {\n\t\treturn combs[n ][r];\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "mod = 10 ** 9 + 7\nimport math\ndef f(n): return math.factorial(n)\nk = int(input())\nc = [int(input()) for i in range(k)]\ns, cnt = 0, 1\nfor i in c:\n    cnt *= f(s + i - 1) // f(i - 1) // f(s)\n    cnt %= mod\n    s += i\nprint(cnt)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int p = 1000000007;\nlong long quick_mod(long long a, long long b) {\n  long long ans = 1;\n  a %= p;\n  while (b) {\n    if (b & 1) {\n      ans = ans * a % p;\n      b--;\n    }\n    b >>= 1;\n    a = a * a % p;\n  }\n  return ans;\n}\nlong long C(long long n, long long m) {\n  if (m > n) return 0;\n  long long ans = 1;\n  for (int i = 1; i <= m; i++) {\n    long long a = (n + i - m) % p;\n    long long b = i % p;\n    ans = ans * (a * quick_mod(b, p - 2) % p) % p;\n  }\n  return ans;\n}\nlong long Lucas(long long n, long long m) {\n  if (m == 0) return 1;\n  return C(n % p, m % p) * Lucas(n / p, m / p) % p;\n}\nint main() {\n  long long ans = 1;\n  int n, cnt, x;\n  scanf(\"%d%d\", &n, &cnt);\n  for (int i = 2; i <= n; i++) {\n    scanf(\"%d\", &x);\n    long long t = C(cnt + x - 1, x - 1) % p;\n    ans = ans * t % p;\n    cnt += x;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class Main  {\n\tstatic PrintWriter out=new PrintWriter(new BufferedOutputStream(System.out));\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    \n    static final int N=1234;\n    static final int mod=1000000007;\n    static long[] f=new long[N];\n    static long[][] c=new long[N][N];\n    static int[] ball=new int[N];\n    \n    static void prepare() {\n    \tfor(int i=0;i<N;i++) {\n    \t\tfor(int j=0;j<=i;j++) {\n    \t\t\tc[i][j]=(j==0) ?1:(c[i-1][j-1]+c[i-1][j])%mod;\n    \t\t}\n    \t}\n    }\n    \n    public static void main(String args[]) throws Exception {\n    \tprepare();\n    \tint k=Integer.parseInt(br.readLine());\n    \tfor(int i=1;i<=k;i++) {\n    \t\tball[i]=Integer.parseInt(br.readLine());\n    \t}\n    \tint total=ball[1];\n    \tf[1]=1;\n    \tfor(int i=2;i<=k;i++) {\n    \t\tf[i]=(f[i-1]*c[total+ball[i]-1][ball[i]-1])%mod;\n    \t\ttotal+=ball[i];\n    \t}\n    \tout.println(f[k]);\n    \tout.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Kyoya {\n  \n\tpublic static void main (String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong[][] comb = new long[1010][1010];\n\t\tcomb[0][0] = 1;\n\t\tfor (int i = 1; i < 1010; i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % 1000000007;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint K = in.nextInt();\n\t\tint[] color = new int[K];\n\t\tfor (int i = 0; i < K; i++) color[i] = in.nextInt();\n\t\t\n\t\tlong res = 1;\n\t\tint total = 0;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres = (res * comb[total + color[i] - 1][color[i] - 1]) % 1000000007;\n\t\t\ttotal += color[i];\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport inspect\nimport re\nimport math\nfrom pprint import pprint as pp\nmod = 1000000007\nMAX = 10**15\n\n\ndef deb(p):\n    for line in inspect.getframeinfo(inspect.currentframe().f_back)[3]:\n        m = re.search(r'\\bdeb\\s*\\(\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\)', line)\n        print('%s %d' % (m.group(1), p))\n\n\ndef vector(size, val=0):\n    vec = [val for i in range(size)]\n    return vec\n\n\ndef matrix(rowNum, colNum, val=0):\n    mat = []\n    for i in range(rowNum):\n        collumn = [val for j in range(colNum)]\n        mat.append(collumn)\n    return mat\n\n\ndef pascle(lim):\n    p = matrix(lim, lim)\n    for i in range(lim):\n        p[i][i] = p[i][0] = 1\n    for i in range(1, lim):\n        for j in range(1, lim):\n            p[i][j] = (p[i - 1][j - 1] + p[i - 1][j]) % mod\n    return p\n\n\ndef main():\n    p = pascle(1005)\n    n = int(input())\n    a = [0] + [int(input()) for i in range(n)]\n    s = 0\n    ans = 1\n    for i in range(1, n + 1):\n        ans = (ans * p[s + a[i] - 1][a[i] - 1]) % mod\n        s += a[i]\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class code309_2C\n{\n    public static void main(String args[])\n    {\n        InputReader in=new InputReader(System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        int k=in.readInt();\n        int[] a=new int[k];\n        for(int i=0;i<k;i++)\n            a[i]=in.readInt();\n        int no=a[0];BigInteger ans=new BigInteger(\"1\");\n        for(int i=1;i<k;i++){\n            for(int j=(a[i]-1);j>=1;j--){\n                ans=ans.multiply(BigInteger.valueOf(no+1));\n                no++;\n            }\n            no++;\n            for(int j=1;j<a[i];j++){\n                ans=ans.divide(BigInteger.valueOf(j));\n            }\n        }\n        ans=ans.remainder(BigInteger.valueOf(1000000007));\n        out.println(ans);out.flush();\n    }\n}\nclass InputReader\n{\n    private InputStream stream;\n    private byte[] buf=new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n    public InputReader(InputStream stream)\n    {this.stream=stream;}\n    public int read()\n    {\n        if(numChars==-1)\n        throw new InputMismatchException();\n        if(curChar>=numChars)\n        {\n            curChar=0;\n            try{\n                numChars=stream.read(buf);\n            }catch(IOException e){\n                throw new InputMismatchException();\n            }\n            if(numChars<=0)\n            return -1;\n        }\n        return buf[curChar++];\n    }\n    public int readInt()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        int res=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            res*=10;\n            res+=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res*sgn;\n    }\n    public long readLong()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        long res=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            res*=10;\n            res+=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res*sgn;\n    }\n    public int[] readArray(int len)\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        int sgn=1;\n        if(c=='-')\n        {\n            sgn=-1;\n            c=read();\n        }\n        int[] res=new int[len];int j=0;\n        do{\n            if(c<'0'||c>'9')\n            throw new InputMismatchException();\n            //res*=10;\n            res[j++]=c-'0';\n            c=read();\n        }while(!isSpaceChar(c));\n        return res;\n    }\n    public String readString()\n    {\n        int c=read();\n        while(isSpaceChar(c))\n            c=read();\n        StringBuilder res=new StringBuilder();\n        do{\n            res.appendCodePoint(c);\n            c=read();\n        }while(!isSpaceChar(c));\n        return res.toString();\n    }\n    public boolean isSpaceChar(int c)\n    {\n        if(filter!=null)\n            return filter.isSpaceChar(c);\n        return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n    }\n    public String next()\n    {\n        return readString();\n    }\n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*Author: Satyajeet Singh, Delhi Technological University*/\nimport java.io.*;\nimport java.util.*;\nimport java.text.*; \nimport java.lang.*;\n\npublic class Main {\n\tstatic PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\t\t\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic long mod=(long)1e9+7;\n\tstatic long mod1=998244353;\n\tstatic boolean sieve[];\n\tstatic ArrayList<Integer> primes;\n\tstatic ArrayList<Long> factorial;\n/****************************************Solutions Begins***************************************************/\n\tpublic static void main (String[] args) throws Exception {\n\t\tString st[]=br.readLine().split(\" \");\n\t\tint k=Integer.parseInt(st[0]);\n\t\tint input[]=new int[k+1];\n\n\t\tfact(2000);\n\t\tint n=0;\n\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tst=br.readLine().split(\" \");\n\t\t\tinput[i]=Integer.parseInt(st[0]);\n\t\t\tn+=input[i];\t\t\t\n\t\t}\n\t\tlong ans=1;\n\t\tfor(int i=k;i>=2;i--){\n\t\t\t//System.out.println(n+\" \"+input[i]);\n\t\t\tlong h=ncr(n-1,input[i]-1);\n\t\t\tn-=input[i];\n\t\t\tans=(ans*h)%mod;\n\t\t}\n\t\tout.println(ans);\n\t\n/****************************************Solutions Ends*****************************************************/\n\t\tout.flush();\n\t\tout.close();\n    }\n/****************************************Template Begins***************************************************/\n\n/*******************************************************TRIPLET********************************************/\n\tstatic class tripletComparator implements Comparator<triplet>{\n\t\tpublic int compare(triplet p1,triplet p2){\n\t\t\tif(p1.u<p2.u){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(p1.u>p2.u){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tstatic class triplet{\n\t\tint u;\n\t\tint v;\n\t\tint i;\n\t\tpublic triplet(int u,int v,int i){\n\t\t\tthis.u=u;\n\t\t\tthis.v=v;\n\t\t\tthis.i=i;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[u=\" + u + \", v=\" + v + \", i=\"+i+\"]\";\n\t\t}\n\t}\n/*********************************************PAIR*************************************************/\n\tstatic class PairComp implements Comparator<Pair>{\n\t\tpublic int compare(Pair p1,Pair p2){\n\t\t\tif(p1.u>p2.u){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(p1.u<p2.u){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint u;\n\t\tint v;\n\t\tint index=-1;\n\t\tpublic Pair(int u, int v) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t}\n \n\t\tpublic int hashCode() {\n\t\t\tint hu = (int) (u ^ (u >>> 32));\n\t\t\tint hv = (int) (v ^ (v >>> 32));\n\t\t\treturn 31 * hu + hv;\n\t\t}\n \n\t\tpublic boolean equals(Object o) {\n\t\t\tPair other = (Pair) o;\n\t\t\treturn u == other.u && v == other.v;\n\t\t}\n \n\t\tpublic int compareTo(Pair other) {\n\t\t\tif(index!=other.index)\n\t\t\t\treturn Long.compare(index, other.index);\n\t\t\treturn Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n\t\t}\n \n\t\tpublic String toString() {\n\t\t\treturn \"[u=\" + u + \", v=\" + v + \"]\";\n\t\t}\n\t}\n/*******************************************LONG PAIR******************************************/\n\tstatic class PairCompL implements Comparator<Pairl>{\n\t\tpublic int compare(Pairl p1,Pairl p2){\n\t\t\tif(p1.u>p2.u){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(p1.u<p2.u){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\nstatic class Pairl implements Comparable<Pair> {\n\t\tlong u;\n\t\tlong v;\n\t\tint index=-1;\n\t\tpublic Pairl(long u, long v) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t}\n \n\t\tpublic int hashCode() {\n\t\t\tint hu = (int) (u ^ (u >>> 32));\n\t\t\tint hv = (int) (v ^ (v >>> 32));\n\t\t\treturn 31 * hu + hv;\n\t\t}\n \n\t\tpublic boolean equals(Object o) {\n\t\t\tPair other = (Pair) o;\n\t\t\treturn u == other.u && v == other.v;\n\t\t}\n \n\t\tpublic int compareTo(Pair other) {\n\t\t\tif(index!=other.index)\n\t\t\t\treturn Long.compare(index, other.index);\n\t\t\treturn Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n\t\t}\n \n\t\tpublic String toString() {\n\t\t\treturn \"[u=\" + u + \", v=\" + v + \"]\";\n\t\t}\n\t}\n/*****************************************DEBUG***********************************************************/\n\tpublic static void debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n/*****************************************NUMBER THEORY***********************************************/\n\n/************************************MODULAR EXPONENTIATION************************************/\n\tstatic long modulo(long a,long b,long c) {\n\t\tlong x=1;\n\t\tlong y=a;\n\t\twhile(b > 0){\n\t\t\tif(b%2 == 1){\n\t\t\t\tx=(x*y)%c;\n\t\t\t}\n\t\t\ty = (y*y)%c; // squaring the base\n\t\t\tb /= 2;\n\t\t}\n\t\treturn  x%c;\n\t}\n/*********************************************GCD*****************************/\n\tstatic long gcd(long x, long y)\n\t{\n\t\tif(x==0)\n\t\t\treturn y;\n\t\tif(y==0)\n\t\t\treturn x;\n\t\tlong r=0, a, b;\n\t\ta = (x > y) ? x : y; // a is greater number\n\t\tb = (x < y) ? x : y; // b is smaller number\n\t\tr = b;\n\t\twhile(a % b != 0)\n\t\t{\n\t\t\tr = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn r;\n\t}\n/*******************************************SIEVE*********************************/\n\tstatic void sieveMake(int n){\n\t\tsieve=new boolean[n];\n\t\tArrays.fill(sieve,true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor(int i=2;i*i<n;i++){\n\t\t\tif(sieve[i]){\n\t\t\t\tfor(int j=i*i;j<n;j+=i){\n\t\t\t\t\tsieve[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprimes=new ArrayList<Integer>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(sieve[i]){\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t}\t\t\n\t}\n/***************************************FACTORIAL*********************************************************/\n\tstatic void fact(int n){\n\t\tfactorial=new ArrayList<>();\n\t\tfactorial.add((long)1);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfactorial.add((factorial.get(i-1)*i)%mod);\n\t\t}\n\t}\n/*******************************************ncr*********************************************************/\n\tstatic long ncr(int n,int k){\n\t\tlong aa=modulo(factorial.get(n-k),mod-2,mod);\n\t\tlong bb=modulo(factorial.get(k),mod-2,mod);\n\t\tlong cc=factorial.get(n);\n\t\tlong ans=(aa*cc)%mod;\n\t\tans=(ans*bb)%mod;\n\t\treturn ans;\n\t}\n/***************************************STRING REVERSE****************************************************/\n\tstatic String reverse(String str){\n\t\tchar r[]=new char[str.length()];\n\t\tint j=0;\n\t\tfor(int i=str.length()-1;i>=0;i--){\n\t\t\tr[j]=str.charAt(i);\n\t\t\tj++;\n\t\t}\n\t\treturn new String(r);\n\t}\n}\n/*******************************************************End***********************************************************/"
        },
        {
            "language": 4,
            "solution": "/* Author : DEBOJYOTI MANDAL\nAttribute : Some of the methods are copied from GeeksforGeeks Website  */\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{ \n  static  Reader sc=new Reader();\n  // static FastReader sc=new FastReader(System.in);\n  static long mod=(long)1e9+7;\n  static long binomialCoeff(long n, long r)\n{\n \n    if (r > n)\n    return 0;\n    long  m = 1000000007;\n    long  inv[] = new long[(int)r + 1];\n    inv[0] = 1;\n    if(r+1>=2)\n    inv[1] = 1;\n \n    // Getting the modular inversion\n    // for all the numbers\n    // from 2 to r with respect to m\n    // here m = 1000000007\n    for (int i = 2; i <= r; i++) {\n        inv[i] = m - (m / i) * inv[(int) (m % i)] % m;\n    }\n \n    long ans = 1;\n \n    // for 1/(r!) part\n    for (int i = 2; i <= r; i++) {\n        ans = (int) (((ans % m) * (inv[i] % m)) % m);\n    }\n \n    // for (n)*(n-1)*(n-2)*...*(n-r+1) part\n    for (long i = n; i >= (n - r + 1); i--) {\n        ans = (int) (((ans % m) * (i % m)) % m);\n    }\n    return ans;\n}\n public static void main (String[] args) throws java.lang.Exception\n   {\n//\ttry{\n\t    /*\n\t        int n=sc.nextInt();\n\t        ArrayList<Integer> al=new ArrayList<>();\n\t        ArrayList<Long> al=new ArrayList<>();\n\t        Set<Integer> set=new HashSet<>();\n\t        Collections.sort(al,Collections.reverseOrder());\n\t     \n\t        long n=sc.nextLong();\n\t        for(int i=0;i<n;i++) \n\t        String s=sc.next();\n\t     */\n\t\t  int t =1;// sc.nextInt();\n\t\t  while(t-->0)\n\t\t    { \n\t\t       int n=sc.nextInt();\n\t\t       \n\t\t       int a[]=new int[n];\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t           a[i]=sc.nextInt();\n\t\t         }\n\t\t       long ans=1;\n\t\t       long total=0;\n\t\t       for(int i=0;i<n;i++)\n\t\t         {\n\t\t            long res=binomialCoeff(total+a[i]-1,a[i]-1);\n\t\t            ans=(ans*res%mod)%mod;\n\t\t            total+=a[i];\n\t\t            \n\t\t            if(total>=mod)\n\t\t             total%=mod;\n\t\t         }\n\t\t      \n\t\t      out.println(ans);\n\t\t    }\n\t     out.flush();\n\t     out.close();\n// \t   }     \n// \tcatch(Exception e)\n// \t\t {}\n\t}\n \n /*\n   ...SOLUTION ENDS HERE...........SOLUTION ENDS HERE...\n */\n \nstatic void flag(boolean flag)\n   {\n       out.println(flag ? \"YES\" : \"NO\");\n       out.flush();\n   }\n   \n /*                     \n    Map<Long,Long> map=new HashMap<>();\n             for(int i=0;i<n;i++)\n               {\n                  if(!map.containsKey(a[i]))\n                   map.put(a[i],1);\n                 else\n                   map.replace(a[i],map.get(a[i])+1);\n               }\n     \n    Set<Map.Entry<Long,Long>> hmap=map.entrySet();\n             for(Map.Entry<Long,Long> data : hmap)\n               {\n          \n               }\n       \n   Iterator<Integer> it = set.iterator();\n          while(it.hasNext()) \n           { \n            int x=it.next();\n           }\n   */\n\nstatic void print(int a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print(long a[])\n  {\n     int n=a.length;\n     for(int i=0;i<n;i++)\n       {\n          out.print(a[i]+\" \");\n       }\n     out.println();\n     out.flush();\n  } \nstatic void print_int(ArrayList<Integer> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\nstatic void print_long(ArrayList<Long> al)\n  {\n     int si=al.size();\n     for(int i=0;i<si;i++)\n       {\n          out.print(al.get(i)+\" \");\n       }\n     out.println();\n     out.flush();\n  }\n\nstatic class Graph\n  {\n        int v;\n        ArrayList<Integer> list[];\n        Graph(int v)\n        {\n            this.v=v;\n            list=new ArrayList[v+1];\n            for(int i=1;i<=v;i++)\n                list[i]=new ArrayList<Integer>();\n        }\n        void addEdge(int a, int b)\n        {\n            this.list[a].add(b);\n        }\n    }\nstatic void DFS(Graph g, boolean[] visited, int u)\n\t{\n        visited[u]=true;\n        int v=0;\n        for(int i=0;i<g.list[u].size();i++)\n        {\n            v=g.list[u].get(i);\n            if(!visited[v])\n               DFS(g,visited,v);\n        }\n  } \n  \n// static class Pair\n//    {\n//       int x,y;\n//       Pair(int x,int y)\n//        {\n//           this.x=x;\n//           this.y=y;\n//        }\n//    }\n   \nstatic long sum_array(int a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\nstatic long sum_array(long a[])\n {\n    int n=a.length;\n    long sum=0;\n    for(int i=0;i<n;i++)\n     sum+=a[i];\n    return sum;\n }\n\n static void sort(int[] a) \n   {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\nstatic void sort(long[] a) \n   {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\nstatic void reverse_array(int a[])\n {\n    int n=a.length;\n    int i,t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\nstatic void reverse_array(long a[])\n {\n    int n=a.length;\n    int i; long t; \n    for (i = 0; i < n / 2; i++) { \n            t = a[i]; \n            a[i] = a[n - i - 1]; \n            a[n - i - 1] = t; \n        } \n }\n \nstatic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \nstatic int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\n   static class FastReader{\n \n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) {\n            in = is;\n        }\n \n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n   \n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    }\n  static  PrintWriter out=new PrintWriter(System.out);\n  static int int_max=Integer.MAX_VALUE;\n  static int int_min=Integer.MIN_VALUE;\n  static long long_max=Long.MAX_VALUE;\n  static long long_min=Long.MIN_VALUE;\n}\n// Thank You !"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        static int[][] fif = NT.enumFIF(20000, NT.MOD7I);\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int k = in.nextInt();\n            int[] c = in.nextIntArray(k);\n            int tot = 0;\n            long ret = 1L;\n            for (int i = 0; i < k; ++i) {\n                ret = ret * NT.C(tot + c[i] - 1, c[i] - 1, NT.MOD7I, fif) % NT.MOD7I;\n                tot += c[i];\n            }\n            out.println(ret);\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        private boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        private static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class NT {\n        public static final int MOD7I = (int) 1e9 + 7;\n\n        public static long C(int n, int r, int mod, int[][] fif) {\n            if (n < 0 || r < 0 || r > n) return 0;\n            return (long) fif[0][n] % mod * fif[1][r] % mod * fif[1][n - r] % mod;\n        }\n\n        public static int[][] enumFIF(int n, int mod) {\n            int[] f = new int[n + 1];\n            int[] invf = new int[n + 1];\n            f[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                f[i] = (int) ((long) f[i - 1] * i % mod);\n            }\n            long a = f[n];\n            long b = mod;\n            long p = 1, q = 0;\n            while (b > 0) {\n                long c = a / b;\n                long d;\n                d = a;\n                a = b;\n                b = d % b;\n                d = p;\n                p = q;\n                q = d - c * q;\n            }\n            invf[n] = (int) (p < 0 ? p + mod : p);\n            for (int i = n - 1; i >= 0; i--) {\n                invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n            }\n            return new int[][]{f, invf};\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if ((a == 0) || (b == 0)) return a + b;\n  return gcd(b, a % b);\n}\nlong long pow_mod(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % 1000000007;\n    a = (a * a) % 1000000007;\n    b >>= 1;\n  }\n  return res;\n}\nlong long arr[1010], fact[1010], ifact[1010];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long N, i, j, T, res = 1, total, tt, opop;\n  string st;\n  fact[0] = 1;\n  for (i = 1; i <= 1002; i++) {\n    fact[i] = ((fact[i - 1] * i) % 1000000007);\n  }\n  ifact[1002] = pow_mod(fact[1002], 1000000007 - 2);\n  for (i = 1001; i >= 0; i--) {\n    ifact[i] = ((ifact[i + 1] * (i + 1)) % 1000000007);\n  }\n  cin >> N;\n  for (i = 0; i <= N - 1; i++) {\n    cin >> arr[i];\n  }\n  total = arr[0];\n  tt = arr[0];\n  for (i = 1; i <= N - 1; i++) {\n    tt += arr[i];\n    total += arr[i];\n    total--;\n    opop = ((fact[total] *\n             ((ifact[arr[i] - 1] * ifact[total - arr[i] + 1]) % 1000000007)) %\n            1000000007);\n    res = ((res * opop) % 1000000007);\n    total = tt;\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, sol = 1, acc, t;\nint C[1003][1003];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie();\n  C[0][0] = 1;\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 0; j <= i; j++)\n      C[i][j] =\n          (j == 0 ? 1LL : 1LL * C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n  cin >> n;\n  while (n-- && cin >> t) {\n    acc += t;\n    sol = 1LL * sol * C[acc - 1][t - 1] % 1000000007;\n  }\n  cout << sol % 1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p[2010][2010], k;\nint input[1010];\nstruct H {\n  int value;\n  H(int x, int y) { value = p[x + y - 1][y]; }\n};\ninline void createPascal() {\n  for (int i = 0; i <= 2000; i++) p[i][0] = 1, p[i][i] = 1;\n  for (int i = 2; i <= 2000; i++) {\n    for (int j = 1; j < i; j++) {\n      p[i][j] = (p[i - 1][j - 1] % mod + p[i - 1][j] % mod) % mod;\n    }\n  }\n}\nint main() {\n  createPascal();\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) scanf(\"%d\", &input[i]);\n  int present = input[0];\n  long long ans = 1;\n  for (int i = 1; i < k; i++) {\n    if (input[i] == 1) {\n      present += 1;\n      continue;\n    } else {\n      ans = (H(present + 1, input[i] - 1).value * ans) % mod;\n    }\n    present += input[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {        \n        Task s = new Task();\n        s.solve();          \n    }    \n}\n\nclass Task{     \n    \n    public long C(long n, long k){\n        BigInteger res = BigInteger.ONE;\n        for(long i = n - k + 1; i <= n; ++i) {\n            res = res.multiply(BigInteger.valueOf(i));\n        }            \n        for(long i = 2; i <= k; ++i){\n            res = res.divide(BigInteger.valueOf(i));\n        }    \n        return (res.remainder(BigInteger.valueOf(1000000007))).longValue();\n    }\n    \n    public void solve(){\n        long MOD = 1000000007;\n        Scanner sc = new Scanner(System.in);\n        int k;\n        long cc[] = new long[1111];\n        k = sc.nextInt();\n        for(int i = 0; i < k; ++i){\n            cc[i] = sc.nextLong();\n        }\n        long cur = cc[0];\n        long ans = 1;\n        for(int i = 1; i < k; ++i){  \n            cur = cur + cc[i] - 1;\n            cc[i]--;\n            ans = (ans * C(cur, cc[i])) % MOD;\n            cur++;\n        }\n        System.out.println(ans);\n    }\n    \n}\n\n"
        },
        {
            "language": 1,
            "solution": "def C(k, n):\n    x = 1\n    for i in range(n - k + 1, n + 1):\n        x *= i\n    for i in range(1, k + 1):\n        x /= i\n    return x % 1000000007\n\n\nimport sys\na = map(int, sys.stdin.read().split())[1:]\n\nx = 1\nwhile len(a) > 1:\n    x *= C(a[-1] - 1, sum(a) - 1)\n    x = x % 1000000007\n    a = a[:-1]\n\nprint(x)\n\n"
        },
        {
            "language": 1,
            "solution": "def f(n):\n    k=n\n    C = [[0 for x in range(k+1)] for x in range(n+1)] \n  \n    # Calculate value of Binomial Coefficient in bottom up manner \n    for i in range(n+1): \n        for j in range(min(i, k)+1): \n            # Base Cases \n            if j == 0 or j == i: \n                C[i][j] = 1\n  \n            # Calculate value using previously stored values \n            else: \n                C[i][j] = (C[i-1][j-1] + C[i-1][j])%1000000007 \n  \n    return C\nl=f(1000)\nn=input()\nsm=input()\nans=1\nfor i in range(n-1):\n    x=input()\n    sm+=x\n    ans=(ans*l[sm-1][x-1])%1000000007\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1001][1001];\nint M = 1e9 + 7;\nvoid init() {\n  for (int i = 1; i < 1001; i++) {\n    dp[1][i] = 1;\n    dp[i][1] = i;\n  }\n  for (int i = 2; i < 1001; i++)\n    for (int j = 2; j < 1001; j++) dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % M;\n}\nint main() {\n  init();\n  vector<int> c(1001);\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  int x = c[0];\n  unsigned long long res = 1;\n  for (int i = 1; i < k; i++) {\n    if (c[i] != 1) res = (res * dp[x + 1][c[i] - 1]) % M;\n    x += (c[i]);\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner scan= new Scanner(System.in)) {\n\t\t\t\n\t\t\tint k = scan.nextInt();\n\t\t\t\n\t\t\tint total = 0;\n\t\t\tlong ways = 1;\n\t\t\tfor (int i = 0; i < k; i++){\n\t\t\t\tint n = scan.nextInt();\n\t\t\t\ttotal+=n;\n\t\t\t\tways = (ways*lucas(total-1, n-1, 1000000007))%1000000007;\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ways);\n\t\t}\n\t}\n\t\n\tprivate static long lucas (long n, long k, long p) {\n\t\t\n\t\tif (n < k) return 0;\n\t\t\n\t\tlong n_ = n;\n\t\tlong k_ = k;\n\t\tArrayList<Long> numer = new ArrayList<Long>();\n\t\tArrayList<Long> denom = new ArrayList<Long>();\n\t\t\n\t\twhile (n_!=0){\n\t\t\tnumer.add(n_%p);\n\t\t\tn_/=p;\n\t\t}\n\t\twhile(k_!=0){\n\t\t\tdenom.add(k_%p);\n\t\t\tk_/=p;\n\t\t}\n\t\t\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < numer.size(); i++) {\n\t\t\tlong a = numer.get(i);\n\t\t\tlong b;\n\t\t\tif (i >= denom.size()) b = 0;\n\t\t\telse b = denom.get(i);\n\t\t\t\n\t\t\tans = (ans*choose(a, b, p))%p;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tstatic long choose(long n, long k, long p) {\n\t\t//WARNING - DOES NOT CATCH WHEN N < K\n\t\tint num_degree= GetDegree(n,p)-GetDegree(n-k,p);\n\t\tint den_degree= GetDegree(k,p);\n\t\tif(num_degree>den_degree) return 0;\n\t\t\n\t\tlong result = 1;\n\t\t\n\t\t//if (n < k) return 0;\n\t\t\n\t\t//result = fact[(int)n];\n\t\t//result = (result*modinv[(int)n-(int)k])%p;\n\t\t//result = (result*modinv[(int)k])%p;\n\t\t\n\t\t\n\t\tfor (long i = n; i > n-k; --i){\n\t\t\tlong ti = i;\n\t\t\twhile (ti%p == 0) {\n\t\t\t\tti/=p;\n\t\t\t}\n\t\t\tresult = (result*ti)%p;\n\t\t}\n\t\tfor (long i = 1; i <=k; ++i){\n\t\t\tlong ti = i;\n\t\t\twhile (ti%p==0){\n\t\t\t\tti/=p;\n\t\t\t}\n\t\t\tresult = (result*FastExp(ti, p-2, p))%p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static long FastExp(long a, long b, long c) {\n\t\tlong x = 1; long y = a;\n\t\twhile (b > 0){\n\t\t\tif(b%2==1)\n\t\t\t\tx=(x*y)%c;\n\t\t\ty=(y*y)%c;\n\t\t\tb/=2;\n\t\t}\n\t\treturn x%c;\n\t}\n\n\tprivate static int GetDegree(long n, long p) {\n\t\tint degree = 0;\n\t\tlong u = p;\n\t\tlong temp = n;\n\t\twhile (u<=temp){\n\t\t\tdegree+=temp/u;\n\t\t\tu*=p;\n\t\t}\n\t\treturn degree;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[1010][1010], a[1010];\nvoid init() {\n  for (int i = 0; i <= 1000; i++) c[i][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 1; j <= 1000; j++) {\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % 1000000007;\n    }\n  }\n}\nint main() {\n  init();\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    a[i]--;\n  }\n  long long ans = 1;\n  long long anss = 0;\n  for (int i = 1; i <= n; i++) {\n    anss += a[i];\n    ans = (ans * c[anss][a[i]]) % 1000000007;\n    anss++;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k = int(input())\nfact = [1] * 1000000\nfor j in range(2, 1001):\n    fact[j] = fact[j - 1] * j\ncnt = 1\nl = 0\nfor i in range(k):\n    cur = int(input())\n    cnt *= (fact[l + cur - 1] // fact[cur - 1] // fact[l]) % 1000000007\n    l += cur\nprint(int(cnt) % 1000000007)\n"
        },
        {
            "language": 1,
            "solution": "MAXN = 1005\nMOD = 1000000007\n\ncomb = [[0] * MAXN for _ in xrange(MAXN)]\ncomb[0][0] = 1\n\nfor n in xrange(1, MAXN):\n    for m in xrange(n + 1):\n        comb[n][m] = comb[n - 1][m - 1] + comb[n - 1][m]\n\ncolor = [input() for _ in xrange(input())]\n\nres = 1\ntotal = 0\nfor c in color:\n    res = (res * comb[total + c - 1][c - 1]) % MOD\n    total += c\n\nprint res\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long fac[5005], invFac[5005];\nlong long inverseMod(long long x) {\n  long long t = 0, newt = 1, r = MOD, newr = x;\n  while (newr) {\n    long long quot = r / newr;\n    long long tmp = newt;\n    newt = t - quot * newt;\n    t = tmp;\n    tmp = newr;\n    newr = r - quot * newr;\n    r = tmp;\n  }\n  if (t < 0) t += MOD;\n  return t;\n}\nlong long ncr(long long n, long long c) {\n  return ((fac[n] * invFac[c]) % MOD * invFac[n - c]) % MOD;\n}\nint main() {\n  for (int i = 0; i < 5005; i++) {\n    if (!i) {\n      fac[i] = invFac[i] = 1;\n    } else {\n      fac[i] = (fac[i - 1] * i) % MOD;\n      invFac[i] = inverseMod(fac[i]);\n    }\n  }\n  int N;\n  cin >> N;\n  long long prod = 1;\n  long long cursum = 0;\n  for (int i = 0; i < N; i++) {\n    long long x;\n    cin >> x;\n    if (i) {\n      prod = (prod * ncr(cursum + x - 1, cursum)) % MOD;\n    }\n    cursum += x;\n  }\n  cout << prod << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace stuff {\nconst int MOD = int(1e9) + 7;\nlong long dp[1111][1111];\nlong long comb[1111][1111];\nvoid solve(int test_num) {\n  int K;\n  cin >> K;\n  vector<int> col(K + 1, 0);\n  for (int i = 1; i <= K; i++) cin >> col[i];\n  const int N = accumulate(col.begin(), col.end(), 0);\n  memset(comb, 0, sizeof(comb));\n  comb[0][0] = 1;\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 0; j <= 1000; j++)\n      if (j == 0)\n        comb[i][j] = 1;\n      else\n        comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  int sum = 0;\n  for (int c = 1; c <= K; c++) {\n    sum += col[c];\n    long long pr = 0;\n    for (int i = 0; i < sum; i++) pr = (pr + dp[c - 1][i]) % MOD;\n    for (int i = sum; i <= N; i++) {\n      dp[c][i] =\n          (dp[c][i] + pr * comb[i - 1 - (sum - col[c])][col[c] - 1]) % MOD;\n      pr = (pr + dp[c - 1][i]) % MOD;\n    }\n  }\n  cout << dp[K][N] << endl;\n}\nvoid solve() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int T = 1;\n  for (int t = 1; t <= T; t++) solve(t);\n}\n}  // namespace stuff\nint main() {\n  stuff::solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static long[][] nCr = new long[1005][1005];\n\tprivate static long mod = 1000000007;\n\tpublic static void pascal(){\n\t\tnCr[0][0] = 1;\n\t\tfor(int i=1;i<nCr.length;i++){\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tnCr[i][j] = nCr[i-1][j] + (j-1>-1?nCr[i-1][j-1]:0);\n\t\t\t\tnCr[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static long distribute(int n, int r){\n\t\treturn nCr[n+r-1][r-1];\n\t}\n\tpublic static void main(String[] args){\n\t\tpascal();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint k = sc.nextInt();\n\t\tint[] c = new int[k+1];\n\t\tint n = 0;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tc[k-i] = sc.nextInt();\n\t\t\tn += c[k-i];\n\t\t}\n\t\tlong[][] dp = new long[k+1][n];\n\t\tdp[1][0] = 1;\n\t\tint m = c[1];\n\t\tfor(int i=2;i<=k;i++){\n\t\t\tlong sum = dp[i-1][i-2];\n\t\t\tm += c[i];\n\t\t\tfor(int j=i-1;j<=m-c[i];j++){\n\t\t\t\tdp[i][j] = (sum * distribute(c[i] - 1, m - c[i] - j + 1)) % mod;\n\t\t\t\tsum = (sum + dp[i-1][j]) % mod;\n\t\t\t}\n\t\t}\n\t\tlong result = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tresult = (result + dp[k][i]) % mod;\n\t\t}\n\t\tfor(int i=0;i<=k;i++){\n\t\t\tfor(int j=0;j<n;j++){\n//\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t//\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1000000];\nlong long m[1001][1001];\nlong long md = 1000000007;\nlong long ans = 1;\nint cnt = 0;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  m[0][0] = 1;\n  for (int i = 1; i <= 1000; ++i) {\n    m[i][0] = 1;\n    for (int j = 1; j <= 1000; ++j) {\n      m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]) % md;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    ans = (ans * (m[a[i] + cnt - 1][a[i] - 1])) % md;\n    cnt += a[i];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "\n\n\nmod = int(1e9+7)\n\npascal=[];\nfor i in range(0,1001):\n\tpascal.append([])\n\tpascal[i].append(1)\n\tfor j in range(1,i):\n\t\tvalue = (pascal[i-1][j-1] + pascal[i-1][j])%mod\n\t\tpascal[i].append(value)\n\tpascal[i].append(1)\n\n\n\nn = int(input())\nValue,Acum,dp= [],[],[]\ndp.append(0)\nValue.append(0)\nAcum.append(0)\n\nfor i in range(1,n+1):\n\tdp.append(0)\n\tvalue = int(input())\n\tValue.append(value)\n\tAcum.append(value + Acum[i-1])\n\n\n\n\n\n\ndp[1] = 1\nfor i in range(2,n+1):\n\tballs = Acum[i]\n\tans = 0\n\tfor j in range(1,Value[i]+1):\n\t\tspace_balls = balls - j - 1 # el uno por que no tiene que estar juntas\n\t\trest_index = Value[i] - j\n\t\ttemp = 0\n\t\tif(space_balls>=rest_index):\n\t\t\ttemp = pascal[space_balls][rest_index]*dp[i-1]%mod\n\t\tans = (ans + temp)%mod\n\tdp[i] = ans\n\nprint(dp[n])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mn = 1e3 + 10;\nconst int mod = 1e9 + 7;\nlong long par[mn];\nlong long ent[1001][1001];\nint main() {\n  for (int i = 0; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || i == j) {\n        ent[i][j] = 1;\n      } else {\n        ent[i][j] = (ent[i - 1][j - 1] + ent[i - 1][j]) % mod;\n      }\n    }\n  }\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> par[i];\n    par[i] += par[i - 1];\n  }\n  long long ans = 1;\n  for (int i = 1; i <= k; i++) {\n    ans = (ent[par[i] - 1][par[i - 1]] * ans) % mod;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def f(a,b):\n    p = 1\n    while a!=b:\n        p = (p*a)%z\n        a -= 1\n    return p\ndef modinv(a,m):\n    p = 1\n    while m!=0:\n        if m%2:\n            p = (p*a)%z\n            m -= 1\n        else:\n            a = (a*a)%z\n            m //= 2\n    return p\nk = int(input())\ns = 0\nans = 1\nz = 1000000007\nfor i in range(k):\n    c = int(input())\n    if i>0:\n        ans = (ans*f(s+c-1,c-1)*modinv(f(s,0),z-2))%z\n    s += c\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "\n/**\n * @author Maxim98 \n */\nimport java.io.*;\nimport java.util.*;\n\npublic class ColoredBalls {\n  public static int mod = (int)(1e9 + 7);\n  public static int MAXN = 1010;\n  \n  public static void main (String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out, true);\n    \n    long[][] comb = new long[MAXN][MAXN];\n    comb[0][0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n        }\n    }\n    \n    int K = in.nextInt();\n    int[] color = new int[K];\n    for (int i = 0; i < K; i++) color[i] = in.nextInt();\n    \n    long res = 1;\n    int total = 0;\n    for (int i = 0; i < K; i++) {\n      res = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n      total += color[i];\n    }\n    \n    out.println(res);\n    out.close();\n    System.exit(0);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class A {\n\n\tstatic final long MOD = 1000_000_007;\n\n\tstatic long choose(long n, long k) {\n\t\tif (k == 0)\n\t\t\treturn 1;\n\t\tif (k > n / 2)\n\t\t\treturn choose(n, n - k);\n\t\tlong ans = 1;\n\t\tBigInteger mod = new BigInteger(\"1000000007\");\n\t\tfor (long i = 0; i < k; ++i) {\n\t\t\tans = (ans * (n - i)) % MOD;\n\t\t\tans = ans\n\t\t\t\t\t* Long.parseLong(new BigInteger(Long.toString(i + 1))\n\t\t\t\t\t\t\t.modInverse(mod).toString()) % MOD;\n\t\t\t// System.out.println(\"mod inv is \"\n\t\t\t// + Long.parseLong(new BigInteger(Long.toString(i + 1))\n\t\t\t// .modInverse(mod).toString()));\n\t\t\t// System.out.println(ans);\n\t\t\tans %= MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic long[][] ans = new long[1005][1005];\n\tstatic int[] c;\n\n\tstatic long get_ans(int k, int n) {\n\t\tif (k == -1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (ans[k][n] == -1)\n\t\t\tans[k][n] = (choose(n - 1, c[k] - 1) * get_ans(k - 1, n - c[k]))\n\t\t\t\t\t% MOD;\n\t\treturn ans[k][n];\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint k = Integer.parseInt(br.readLine());\n\t\tc = new int[k];\n\t\tint n = 0;\n\t\tfor (int i = 0; i < k; ++i) {\n\t\t\tc[i] = Integer.parseInt(br.readLine());\n\t\t\tn += c[i];\n\t\t}\n\n\t\tfor (int i = 0; i < 1005; ++i)\n\t\t\tfor (int j = 0; j < 1005; ++j)\n\t\t\t\tans[i][j] = -1;\n\n\t\tSystem.out.println(get_ans(k - 1, n));\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "mod = 1000000007\n\ndef pow1(a,b):\n    ans = 1\n    c=a\n    while(b):\n        #print('estoy en el while')\n        if(b & 1):\n            ans=ans*c%mod\n        b>>=1\n        c=c*c%mod\n    return ans\n\n\n\ndef factorial(a,b):\n    factor =fact[a]*pow1(fact[b]*fact[a-b]%mod,mod-2)%mod\n    return factor\n\n\nfact = []\nfor i in range(1000010):\n    fact.append(0)\n\na = []\nfor i in range(1010):\n    a.append(0)\n\n#================MAIN===============\nfact[0] = 1\n\nfor i in range(1,1000000):\n    fact[i]=fact[i-1]*i%mod\n\nn = int(input())\n#print(n)\nsum = 0\n\nfor i in range(0,n):\n    a[i] = int(input())\n    sum+=a[i]\n#print (a)\n#print(sum)\nans = 1\ni = n-1\nwhile(i>-1):\n    ans=ans*factorial(sum-1,a[i]-1)%mod\n    #print(ans)\n    sum-=a[i]\n    i-=1\n    #print(f\"suma:{sum}\")\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n\n    static long fact[];\n    public static long inv(long x)\n    {\n        long r,y;\n        for(r=1,y=mod-2;y>0;x=(x*x)%mod,y/=2)\n            if(y%2==1)\n                r=r*x%mod;\n        return r;\n    }\n    public static  long nCr(int n, int m)\n    {\n        return (fact[n] *inv(fact[m])%mod *inv(fact[n-m])%mod)%mod ;\n    }\n    static int n,arr[],sum;\n    static int presum[];\n    static long mod=1000000007;\n    static long cache[][];\n    public static long dp(int balls,int color)\n    {\n        if(balls==sum)\n        {\n            if(color==n)\n            return 1;\n            return 0;\n        }\n        if(cache[balls][color]!=-1)\n            return cache[balls][color];\n        long ans=dp(balls+1,color)%mod;\n        if(presum[color+1]<=balls+1)\n            ans+=nCr(balls-presum[color],arr[color]-1)*dp(balls+1,color+1)%mod;\n        return cache[balls][color]=ans%mod;\n    }\n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        n=sc.i();\n        arr=sc.arr(n);\n        for(int i=0;i<n;i++)\n            sum+=arr[i];\n        \n        fact=new long[10000];\n        fact[0]=1l;\n        for (int i=1;i<10000;i++)\n            fact[i]=(fact[i-1]*i)%mod;\n            \n        presum=new int[n+1];\n        for(int i=1;i<=n;i++)\n            presum[i]+=presum[i-1]+arr[i-1];\n            \n        cache=new long[1002][1002];\n        for(int i=0;i<1002;i++)\n            Arrays.fill(cache[i],-1l);\n        out.println(dp(0,0));\n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1005];\nlong long D[1005];\nlong long C[1005][1005];\nlong long n;\nlong long sum[1005];\nconst long long MOD = 1e9 + 7;\nvoid init() {\n  C[0][0] = 1;\n  for (long long i = 1; i <= 1000; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (long long j = 1; j <= i - 1; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  init();\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sum[1] = a[1];\n  for (long long i = 2; i <= n; i++) {\n    sum[i] = sum[i - 1] + a[i];\n  }\n  D[1] = 1;\n  for (long long i = 2; i <= n; i++) {\n    D[i] = (D[i - 1] * C[sum[i - 1] + a[i] - 1][a[i] - 1]) % MOD;\n  }\n  cout << D[n];\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "if __name__ == '__main__':\n    data = [int(input()) for i in range(int(input()))]\n\n    total = 1\n    prev = data[0]\n\n    for i, x in enumerate(data[1:]):\n        prev += 1\n        f = 1\n        c = 1\n\n        for j in range(x - 1):\n            total *= prev\n            prev += 1\n            f *= c\n            c += 1\n\n        total //= f\n        if total > 1000000007:\n                total %= 1000000007\n\n\n    print(total)"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef coloredBalls():\n    \n    k = int(input())\n    \n    if(k==1 or k==1000):\n        print(\"1\")\n        return\n    \n    n = 0\n    resultado = 1\n    \n    for i in range(0,k):\n        balls = int(input())\n        resultado = resultado * math.factorial(n+balls-1) // math.factorial(n) // math.factorial(balls - 1) % 1000000007\n        n += balls\n    \n    print(resultado)\n        \ncoloredBalls()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k;\nint c[1005];\nlong long fact[1005];\nlong long th[1005][1005];\nint s[1005];\nlong long res;\nvoid init() {\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; ++i) fact[i] = (fact[i - 1] * i) % 1000000007;\n  th[0][0] = 1;\n  for (int i = 1; i <= 1000; ++i) {\n    th[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      th[i][j] = (th[i - 1][j - 1] + th[i - 1][j]) % 1000000007;\n    }\n  }\n}\nint main() {\n  init();\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d\", &c[i]);\n    if (i == 0)\n      s[i] = c[i];\n    else\n      s[i] = s[i - 1] + c[i];\n  }\n  res = 1;\n  for (int i = 1; i < k; ++i) {\n    res = (res * th[s[i - 1] + c[i] - 1][c[i] - 1]) % 1000000007;\n  }\n  printf(\"%lld\\n\", res);\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\n    Author - Satwik Tiwari .\n    4th Oct , 2020  - Sunday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\n\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\n\n# from itertools import *\nfrom heapq import *\nfrom math import gcd, factorial,floor,ceil\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\n# from collections import Counter as counter  # Counter(list)  return a dict with {key: count}\n# from itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\n# from itertools import permutations as permutate\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\nmod = 10**9+7\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#===============================================================================================\n# code here ;))\ndef nCr_mod(n,r,max_n=2 * 10**5, mod=10**9 + 7):\n    max_n = min(max_n, mod - 1)\n\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def do_nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return do_nCr_mod(n,r)\n\n\"\"\"\n    print nCr(4,3)\n\"\"\"\n\n\ndef solve(case):\n    n = int(inp())\n    ans = 1\n    total = 0\n    for i in range(n):\n        x = int(inp())\n        total+= x\n        ans*=ncr(total-1,x-1)%mod\n\n    print(ans%mod)\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class KyoyaAndColoredBalls {\n    public static void main(String[] args) {\n        Scanner read = new Scanner(System.in);\n        int[] colors = new int[read.nextInt()];\n        int n = 0;\n        int maximumAmount = 0;\n        for (int i = 0; i < colors.length; i++) {\n            colors[i] = read.nextInt();\n            n += colors[i];\n            maximumAmount = Math.max(maximumAmount, colors[i]);\n        }\n\n        int MOD = (int) (1e9 + 7);\n        long[][] combination = new long[n][maximumAmount];\n        combination[0][0] = 1;\n        for (int i = 1; i < n; i++)\n            for (int j = 0; j <= Math.min(i, maximumAmount - 1); j++)\n                combination[i][j] = (combination[i - 1][j] + (j == 0 ? 0 : combination[i - 1][j - 1])) % MOD;\n\n        long result = 1;\n        int balls = colors[0];\n        for (int i = 1; i < colors.length; i++) {\n            result = (result * combination[balls + colors[i] - 1][colors[i] - 1]) % MOD;\n            balls += colors[i];\n        }\n        System.out.println(result);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int countFact(long long int n, long long int p) {\n  long long int k = 0;\n  while (n >= p) {\n    k += n / p;\n    n /= p;\n  }\n  return k;\n}\nlong long pow(long long int a, long long int b, long long int MOD) {\n  long long x = 1, y = a;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      x = (x * y);\n      if (x > MOD) x %= MOD;\n    }\n    y = (y * y);\n    if (y > MOD) y %= MOD;\n    b /= 2;\n  }\n  return x;\n}\nlong long InverseEuler(long long int n, long long int MOD) {\n  return pow(n, MOD - 2, MOD);\n}\nlong long factMOD(long long int n, long long int MOD) {\n  long long res = 1;\n  while (n > 0) {\n    for (long long int i = 2, m = n % MOD; i <= m; i++) res = (res * i) % MOD;\n    if ((n /= MOD) % 2 > 0) res = MOD - res;\n  }\n  return res;\n}\nlong long C(long long int n, long long int r, long long int MOD) {\n  if (countFact(n, MOD) > countFact(r, MOD) + countFact(n - r, MOD)) return 0;\n  return (factMOD(n, MOD) * ((InverseEuler(factMOD(r, MOD), MOD) *\n                              InverseEuler(factMOD(n - r, MOD), MOD)) %\n                             MOD)) %\n         MOD;\n}\nint main() {\n  long long int n;\n  cin >> n;\n  long long int a[n], i, j, sum = 0;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  sum -= 1;\n  long long int ans = 1;\n  for (i = n - 1; i >= 0; i--) {\n    ans = ans * C(sum, a[i] - 1, 1000000007) % 1000000007;\n    sum -= a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "mod = 1000000007\nc = [[1,0]]\nfor i in range(1,1001):\n    row = [1]\n    for j in range(1, i + 1):\n        row.append((c[-1][j] + c[-1][j - 1]) % mod)\n    row.append(0)\n    c.append(row)\n\nn = int(raw_input())\na = int(raw_input())\nans = 1\nfor i in range(1, n):\n    b = int(raw_input())\n    ans *= c[a + b - 1][b - 1]\n    ans %= mod\n    a += b\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ColoredBalls {\n\tfinal static int mod = 1000000007;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tlong[] permu = new long[1001];\n\t\tpermu[0] = 1;\n\t\tfor (int i = 1; i < permu.length; i++) {\n\t\t\tpermu[i] = (permu[i - 1] * i) % mod;\n\t\t}\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tint[] balls = new int[n + 1];\n\t\tfor (int i = 1; i < balls.length; i++) {\n\t\t\tballs[i] = Integer.parseInt(br.readLine());\n\t\t}\n\n\t\tint[] sumpar = new int[n + 1];\n\t\tsumpar[1] = balls[1] - 1;\n\t\tfor (int i = 2; i < sumpar.length; i++) {\n\t\t\tsumpar[i] = sumpar[i - 1] + balls[i];\n\t\t}\n\n\t\tlong total = 1;\n\t\tfor (int i = 2; i < balls.length; i++) {\n\n\t\t\tlong divisor = (permu[sumpar[i - 1] + 1] * permu[balls[i] - 1])\n\t\t\t\t\t% mod;\n\n\t\t\ttotal *= (permu[sumpar[i]] * modinv((int) (divisor), mod)) % mod;\n\t\t\ttotal %= mod;\n\t\t}\n\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static int modinv(int b, int m) {\n\t\tint[] r = new int[2];\n\t\tint[] t = new int[2];\n\t\tint q;\n\t\tr[0] = m;\n\t\tr[1] = b;\n\t\tt[0] = 0;\n\t\tt[1] = 1;\n\t\tint j;\n\t\tfor (j = 0; r[j ^ 1] > 0; j ^= 1) {\n\t\t\tq = r[j] / r[j ^ 1];\n\t\t\tr[j] = r[j] - r[j ^ 1] * q;\n\t\t\tt[j] = t[j] - t[j ^ 1] * q;\n\t\t}\n\t\treturn t[j] < 0 ? t[j] + m : t[j];\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2100;\nlong long c[MAX][MAX];\nconst int mod = (int)1e9 + 7;\ninline void load(int n) {\n  c[0][0] = 1;\n  for (int i = 1; i < n; i++) {\n    c[i][0] = 1;\n    c[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  load(MAX);\n  long long ans = 1;\n  int n, k, C = 0;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    ans = (ans * c[k + C - 1][C]) % mod;\n    C += k;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:2000000\")\nlong long k, a[1024][1024], dp[1024], b[1024];\nvoid f() {\n  for (long long i = 0; i < (long long)1024; i++) a[i][0] = a[i][i] = 1;\n  for (long long i = (long long)2; i < (long long)1024; i++)\n    for (long long j = (long long)1; j < (long long)i; j++)\n      a[i][j] = ((a[i - 1][j - 1] + a[i - 1][j]) % (1000 * 1000 * 1000 + 7));\n}\nint main() {\n  cin >> k;\n  for (long long i = (long long)1; i < (long long)k + 1; i++) cin >> b[i];\n  f();\n  memset(dp, 0, sizeof dp);\n  dp[1] = 1;\n  long long t = b[1];\n  for (long long i = (long long)2; i < (long long)k + 1; i++) {\n    dp[i] = (dp[i - 1] * a[t + b[i] - 1][t]) % (1000 * 1000 * 1000 + 7);\n    t += b[i];\n  }\n  cout << dp[k] % (1000 * 1000 * 1000 + 7) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n\n public class DrazilAndFactorial {\n    static class Reader\n    {\n    BufferedReader r;\n    StringTokenizer str;\n    Reader()\n    {\n        r=new BufferedReader(new InputStreamReader(System.in));\n    }\n    Reader(String fileName) throws FileNotFoundException\n    {\n        r=new BufferedReader(new FileReader(fileName));\n    }\n    public String getNextToken() throws IOException\n    {\n        if(str==null||!str.hasMoreTokens())\n    {\n        str=new StringTokenizer(r.readLine());\n    }\n        return str.nextToken();\n    }\n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(getNextToken());\n    }\n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(getNextToken());\n    }\n    public double nextDouble() throws IOException\n    {\n        return Double.parseDouble(getNextToken());\n    }\n    public String nextString() throws IOException\n    {\n        return getNextToken();\n    }\n    public int[] intArray(int n) throws IOException\n    {\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextInt();\n       \n        return a;\n       \n    }\n    public long[] longArray(int n) throws IOException\n    {\n        long a[]=new long[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextLong();\n       \n        return a;\n       \n    }\n    public String[] stringArray(int n) throws IOException\n    {\n        String a[]=new String[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextString();\n       \n        return a;\n       \n    }\n    public long gcd(long a, long b) {\n        if(b == 0){\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n    }\n   \n    public static long factorial(long number) {\n        if (number <= 1)\n           return 1;\n        else\n           return number * factorial(number - 1);\n     }\n    \n    public static void main(String args[]) throws IOException{\n\n       Reader r=new Reader();\n       PrintWriter pr=new PrintWriter(System.out,false);\n\n       BigInteger fact = BigInteger.valueOf(1);\n       //BigInteger factt = BigInteger.valueOf(1);\n       long num=r.nextLong();\n       long arr[]=new long[(int)num];\n       long arr2[]=new long[(int)num];\n       long temp=0;\n       \n       for(int a=0;a<num;a++)\n       {\n           arr[a]=r.nextLong();\n           temp+=arr[a];\n           arr2[a]=temp;\n       }\n\n       if(num>1)\n       {\n           for(int i=0;i<num;i++)\n           {\n               for(int j=1;j<=arr2[i]-1;j++)\n               {\n                   //pr.print(\"j is \" +j+\" \");\n                   fact = fact.multiply(BigInteger.valueOf(j));\n               }\n               //pr.print(fact+\" \");\n               for(int k=1;k<=arr[i]-1;k++)\n               {\n                   //pr.print(\"k is \" +k+\" \");\n                   fact = fact.divide(BigInteger.valueOf(k));\n               }\n               for(int l=1;l<=arr2[i]-arr[i];l++)\n               {\n                   //pr.print(\"l is \" +l+\" \");\n                   fact = fact.divide(BigInteger.valueOf(l));\n               }\n               //pr.println(fact);\n           }\n\n           pr.print(fact.remainder(BigInteger.valueOf(1000000007)));\n\n       }\n       else pr.print(1);\n       \n       pr.flush();\n       pr.close();\n       \n    }\n }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst char NL = '\\n';\nvoid read(vector<long long> &a);\nclass Combinatorics {\n public:\n  vector<vector<long long>> ncr(long long n, long long r, long long p) {\n    vector<vector<long long>> dp(n + 1, vector<long long>(r + 1, 0));\n    dp[0][0] = 1;\n    for (long long i = 1; i <= n; i++) {\n      dp[i][0] = 1;\n      for (long long j = 1; j <= i; j++)\n        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % p;\n    }\n    return dp;\n  }\n  vector<long long> derangements(long long n) {\n    vector<long long> der(n + 1, 0);\n    der[1] = 0;\n    der[2] = 1;\n    for (long long i = 3; i <= n; ++i)\n      der[i] = (i - 1) * (der[i - 1] + der[i - 2]);\n    return der;\n  }\n};\ninline void solve() {\n  const long long MAX = 1010;\n  const long long mod = 1e9 + 7;\n  long long n;\n  cin >> n;\n  vector<long long> col(n);\n  read(col);\n  class Combinatorics st;\n  vector<vector<long long>> ncr = st.ncr(MAX, MAX, mod);\n  long long res = 1;\n  long long total = 0;\n  for (long long i = 0; i < n; i++) {\n    res = (res * ncr[total + col[i] - 1][col[i] - 1]) % mod;\n    total += col[i];\n  }\n  cout << res << NL;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  fflush(stdin);\n  fflush(stdout);\n  return 0;\n}\nvoid read(vector<long long> &a) {\n  for (auto &it : a) cin >> it;\n}\n"
        },
        {
            "language": 1,
            "solution": "from math import factorial as fact\nt = input()\nm = 10**9 + 7\ns = 0\nans = 1\nfor _ in range(t):\n    n = input()\n    s += n\n    ans *= fact(s-1)/fact(n-1)/fact(s-n)\n    ans %= m\n    # print ans , s\nprint (ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long pow_mod(long long a, long long n, long long p) {\n  long long ans = 1, t = a;\n  while (n) {\n    if (n & 1) {\n      ans = ans * t % p;\n    }\n    t = t * t % p;\n    n >>= 1;\n  }\n  return ans;\n}\nlong long cal(long long n, long long m, long long p) {\n  if (m > n - m) m = n - m;\n  long long ans = 1;\n  for (int i = 1; i <= m; i++) {\n    ans = ans * (n - i + 1) % p;\n    int a = pow_mod(i, p - 2, p);\n    ans = ans * a % p;\n  }\n  return ans;\n}\nlong long com_mod(long long n, long long m, long long p) {\n  if (n < m) return 0;\n  return cal(n, m, p);\n}\nlong long lucas(long long n, long long m, long long p) {\n  long long r = 1;\n  while (n && m && r) {\n    r = r * com_mod(n % p, m % p, p) % p;\n    n /= p;\n    m /= p;\n  }\n  return r;\n}\nint main() {\n  int k;\n  long long a[1099];\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    scanf(\"%I64d\", &a[i]);\n  }\n  long long sum = a[0];\n  long long ansl = 1;\n  for (int i = 1; i < k; i++) {\n    if (a[i] == 1) {\n      sum++;\n      continue;\n    }\n    sum = sum + a[i] - 1;\n    ansl *= lucas(sum, a[i] - 1, 1000000007);\n    ansl %= 1000000007;\n    sum++;\n  }\n  printf(\"%I64d\\n\", ansl);\n}\n"
        },
        {
            "language": 3,
            "solution": "\nn = int(input())\nar = [int(input()) for _ in range(n)]\nfor i in range(1,n):\n\tar[i] += ar[i-1]\n\nM = 1000000007\nf = [1]\nfor i in range(1,1000000):\n\tf.append(f[-1]*i%M)\n\ndef C(n,k):\n\treturn (f[n]*pow(f[k],M-2,M)%M)*pow(f[n-k],M-2,M)%M\n\ndp = [1]*(n+4)\nfor i in range(1,n):\n\tdp[i] = C(ar[i]-1,ar[i-1])*dp[i-1]%M\n\nprint(dp[n-1])\n\n#  C:\\Users\\Usuario\\HOME2\\Programacion\\ACM"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package EpicCode;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n *\n * @author Hitarth\n */\npublic class Kyoya {\n    \n    public static void main(String[] args){\n        FasterScanner in=new FasterScanner();\n        long mod=(long) (1e9 + 7);\n        long[][] pascal=new long[1001][1001];\n        Arrays.fill(pascal[0], 1);\n        for(int i=1;i<=1000;i++){\n            for(int j=1;j<i;j++){\n                pascal[i][j]=(pascal[i-1][j]+pascal[i-1][j-1])%mod;\n            }\n            pascal[i][0]=1;\n            pascal[i][i]=1;\n        }\n        int k=in.nextInt();\n        int[] c=new int[k+1];\n        for(int i=1;i<=k;i++){\n            c[i]=in.nextInt();\n        }\n        long ans=1;\n        int fsum=c[1];\n        for(int i=2;i<=k;i++){\n            fsum+=c[i];\n            ans=(ans*pascal[fsum-1][c[i]-1])%mod;\n        }\n        System.out.println(ans);\n    }\n    \n    static class FasterScanner {\n\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = System.in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ncr[1001][1001] = {0};\nlong long c[1001], sum[1001];\nlong long precompute(long long n, long long r) {\n  if (ncr[n][r]) return ncr[n][r];\n  if (n == r) return ncr[n][r] = ncr[n][n - r] = 1;\n  if (r == 0) return ncr[n][r] = ncr[n][n - r] = 1;\n  if (r == 1) return ncr[n][r] = ncr[n][n - r] = (n % 1000000007);\n  return ncr[n][r] = ncr[n][n - r] = (precompute(n - 1, r) % 1000000007 +\n                                      precompute(n - 1, r - 1) % 1000000007) %\n                                     1000000007;\n}\nint main() {\n  long long k, i, ans = 1;\n  cin >> k;\n  for (i = 0; i < k; i++) {\n    cin >> c[i];\n  }\n  sum[0] = c[0];\n  for (i = 1; i < k; i++) {\n    sum[i] = sum[i - 1] + c[i];\n  }\n  for (i = 0; i < k; i++) {\n    ans = (ans * precompute(sum[i] - 1, c[i] - 1)) % 1000000007;\n  }\n  cout << ans % 1000000007 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k=int(input())\nsol=1\nprije=0\nfor i in range (k):\n    color=int(input())\n    br1=1\n    for y in range (prije+1, prije+color):\n        br1*=y\n    br2=1\n    for y in range (color-1, 1, -1):\n        br2*=y\n    #print(sol, color, br1, br2, prije)\n    prije+=color\n    sol*=(br1//br2)\n    sol%=(10**9+7)\nprint(sol)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint NCR[1005][1005];\nint mod_mul(long long a, long long b) { return (a * b) % 1000000007; }\nint mod_plus(int a, int b) { return (a + b) % 1000000007; }\nint nCr(int n, int r) {\n  if (n == r || r == 0) return 1;\n  int &ret = NCR[n][r];\n  if (ret != -1) return ret;\n  return ret = mod_plus(nCr(n - 1, r), nCr(n - 1, r - 1));\n}\nint main() {\n  memset(NCR, -1, sizeof(NCR));\n  int i, n, x, tot = 0, ans = 1;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &x);\n    tot += x;\n    ans = mod_mul(ans, nCr(tot - 1, x - 1));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Test {\n  public static int mod = 1000000007;\n  public static int MAXN = 1010;\n  \n  public static void main (String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out, true);\n    \n    long[][] comb = new long[MAXN][MAXN];\n    comb[0][0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n      }\n    }\n  \n    long n;\n    n = in.nextLong();\n\n    long color[] = new long[(int) n];\n    long total = 0;\n\n    for(int i=0;i<n;i++)\n    color[i]=in.nextLong();\n\n    long dp = 1;\n    total = 0;\n\n    for(int i=0;i<n;i++)\n    {\n     //   deb(i);\n     //   debug(total+color[i]-1,color[i]-1);\n    \tdp = ( (dp) * (comb[(int) (total+color[i]-1)][(int) (color[i]-1)]) )%1000000007;\n        total += color[i];\n    }\n\n    out.println(dp);\n    out.close();\n    System.exit(0);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KyoyaAndColoredBalls {\n\tstatic final int MOD = (int)1e9 + 7;\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\n\t\tint k = input.nextInt();\n\n\t\tint[] pre = new int[k + 1];\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint c = input.nextInt();\n\t\t\tpre[i] = pre[i - 1] + c;\n\t\t}\n\n\t\tinput.close();\n\n\t\tlong[][] comb = new long[pre[k] + 1][pre[k] + 1];\n\t\tfor (int i = 0; i <= pre[k]; i++) {\n\t\t\tfor (int j = 0; j <= Math.min(i, pre[k]); j++) {\n\t\t\t\tif (i == j || j == 0) {\n\t\t\t\t\tcomb[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong[] dp = new long[k + 1];\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= k; i++) {\n\t\t\tint b = pre[i] - pre[i - 1];\n\t\t\tdp[i] = (dp[i - 1] * comb[pre[i] - 1][b - 1]) % MOD;\n\t\t}\n\n\t\tSystem.out.println(dp[k]);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def comb(x, y):\n    num = 1\n    for i in range(x-y+1, x+1):\n        num *= i\n    den = 1\n    for i in range(1, y+1):\n        den *= i\n    return num//den\n\nif __name__ == \"__main__\":\n    n_colors = int(input())\n    balls = []\n    for _ in range(n_colors):\n        balls.append(int(input()))\n    total = 1\n    for i in range(len(balls)-1, 0, -1):\n        total *= comb(sum(balls[:i+1])-1, balls[i]-1)%1000000007\n        total %= 1000000007\n    print(total)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint k;\nint a[2000];\nlong long f[2000];\nlong long pre[2000];\nlong long c[1010][1010];\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> a[i];\n    pre[i] += pre[i - 1] + a[i];\n  }\n  for (int i = 0; i <= 1000; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n  }\n  f[1] = 1;\n  for (int i = 2; i <= k; i++) {\n    f[i] = f[i - 1] * c[pre[i] - 1][a[i] - 1] % mod;\n  }\n  cout << f[k] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Kyoya {\n  \n\tpublic static void main (String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\n\t\tint mod = 1000000007;\n\t\tint max = 1010;\n\t\n\t\tlong[][] comb = new long[max][max];\n\t\tcomb[0][0] = 1;\n\t\tfor (int i = 1; i < max; i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint K = in.nextInt();\n\t\tint[] color = new int[K];\n\t\tfor (int i = 0; i < K; i++) color[i] = in.nextInt();\n\t\t\n\t\tlong res = 1;\n\t\tint total = 0;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tres = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n\t\t\ttotal += color[i];\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n  }\n}"
        },
        {
            "language": 1,
            "solution": "from math import factorial\nk = int(raw_input())\na  = [0 for i in xrange(k)]\nfor i in xrange(k):\n    a[i] = int(raw_input())\ndp = [0 for i in xrange(k)]\ndp[0] = 1\nfor i in xrange(1, k):\n    indent = sum(a[0:i])+1\n    if a[i] == 1:\n        dp[i] = 1\n    else:\n        for j in xrange(min(a[i]-1, indent)):\n            dp[i] += factorial(a[i]-2)/factorial(j)/factorial(a[i]-2-j)*factorial(indent)\\\n            /factorial(j+1)/factorial(indent-j-1)\n    dp[i] = dp[i-1]*dp[i]%1000000007\nprint dp[k-1]"
        },
        {
            "language": 1,
            "solution": "__author__ = 'Nate'\n\n# balls = current counts of ball types 0, ... , k-1\n# L = # of balls left\n\ncomb = []\nfor _ in range(1001):\n    comb.append([0]*1001)\ndef preCalc():\n    comb[0][0] = 1\n    comb[1][0] = 1\n    comb[1][1] = 1\n    for i in xrange(2,1000):\n        for j in xrange(i+1):\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j]\n\npreCalc()\nMOD = 1000000007\ndef solve(balls, cumsum, idx):\n    #print balls, idx\n    f = [0]*idx\n    f[0] = 1\n    for i in range(1, idx):\n        #print i\n        f[i] = (f[i-1] * comb[cumsum[i] - 1][balls[i] - 1]) % MOD\n\n    return f[idx-1]\n\n\nn = input()\nballs = []\ncumsum = []\nfor _ in xrange(n):\n\n    balls.append(input())\n#print balls\nfor i in xrange(n):\n    if i == 0:\n        cumsum.append(balls[i])\n    else:\n        cumsum.append(cumsum[i-1]+balls[i])\n#print balls, cumsum, n-1\nprint solve(balls, cumsum, n)\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python3\n\nimport sys\nfrom functools import lru_cache\n\nMOD = 1000000007\n\ncnk = [[1 for i in range(1001)] for j in range(1001)]\nfor i in range(1, 1001):\n    for j in range(1, i):\n        cnk[i][j] = cnk[i - 1][j - 1] + cnk[i - 1][j]\n\n\nk = int(input())\ncs = [int(input()) for i in range(k)]\n\nans = 1\nsm = 0\nfor c in cs:\n    sm += c\n    ans = (ans * cnk[sm - 1][c - 1]) % MOD\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nmod = 10 ** 9 + 7\nk = int(input())\nans = 1\nn = 0\nfor i in range(k):\n    a = int(input())\n    ans = ((ans * (factorial(n + a - 1))) // (factorial(a - 1) * factorial(n))) % mod\n    n += a\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.PrintWriter;\npublic class MarchCookC {\n\tint INF = (int) 1e9;\n\tint MOD = 1000000007;\n    byte broken[][];\n    \n    long pow(int a ,int b){\n        if(b==0)\n            return 1;\n        if(b==1)\n            return a;\n        if(b%2==0){\n            long x = pow(a,b/2);\n            return x*x%MOD;\n        }\n        else{\n            return pow(a,b-1)*a%MOD;\n        }\n    }\n\tvoid solve(InputReader in, PrintWriter out) throws IOException {\n\t\tint k = in.nextInt();\n        int n =0;\n        int arr[] = new int[k];\n        for(int i=0;i<k;i++){\n            arr[i] = in.nextInt();\n            n+=arr[i];\n        }\n        //long dp[] = new long[k+1];\n        long begger[][] = new long[n][n];\n        Arrays.fill(begger[0],1);\n        for(int i=1;i<n;i++){\n            begger[i][0] = i+1;\n            for(int j=1;j<n;j++){\n                begger[i][j] = begger[i][j-1]+begger[i-1][j];\n                begger[i][j] %= MOD;\n            }\n        }\n//        for(int i=0;i<n;i++){\n//            System.out.println(Arrays.toString(begger[i]));\n//        }\n        int count=arr[0];\n        long ans=1;\n        for(int i=2;i<=k;i++){\n            if(arr[i-1]>1)\n                ans*=begger[count][arr[i-1]-2];\n            ans%=MOD;\n            count+=arr[i-1];\n//            System.out.println(ans+\" \"+arr[i-1]);\n        }\n        System.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputReader in = new InputReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = 1;//in.nextInt();\n//\t\tlong arr[] = new long[1000000];\n//\t\tfor(int i=0;i<1000000;i++){\n//\t\t\tarr[i]=(i+1)*(i+2)/2;\n//\t\t}\n\t\twhile (t-- > 0) {\n\t\t\tnew MarchCookC().solve(in, out);\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class InputReader {\n\t\tstatic BufferedReader br;\n\t\tstatic StringTokenizer st;\n\n\t\tpublic InputReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "fact = [1]\nmod = 1000000007\nfor j in range(1, 1001):\n    fact.append(fact[-1] * j)\na = int(input())\ns = []\nfor i in range(a):\n    s.append(int(input()))\nsumm = 1\nl = s[0]\nfor i in range(1, a):\n    summ *= ((fact[l + s[i] - 1] // fact[l] // fact[s[i] - 1]) % mod)\n    l += s[i]\nprint(summ % mod)"
        },
        {
            "language": 4,
            "solution": "\n//Author : Isabel Maqueda Rolon A01652906\nimport java.util.*;\n\npublic class Kyoya\n{\n    public static int mod = 1000000007; // mod dado por parametros de programa\n    \n    \n    public static void main(String[] args)\n    {   Scanner input = new Scanner(System.in);\n        \n        \n        int num_colors = input.nextInt();\n        int [] color  = new int [num_colors];\n        for (int i = 0; i < num_colors; i++) color[i] = input.nextInt();\n        \n        \n        long[][] comb = new long[1010][1010];// 1000 dado por num maximo de pelotas\n        comb[0][0] = 1; // La primera pelota se saca del color 1\n        for (int i = 1; i < 1010; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod; // the number of ways can drag a bag out of bag\n            }\n        }\n        \n        \n        long res = 1;\n        int total = 0;\n        for (int i = 0; i < num_colors; i++) {\n            res = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n            total += color[i];\n        }\n        \n        System.out.println(res);\n\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "F = {}\n\ndef fact(n):\n    if n in F:\n        return F[n]\n\n    res = 1\n    for i in xrange(2, n + 1):\n        res *= i\n\n    F[n] = res\n\n    return res\n\ndef c_n_k(n, k):\n    return fact(n) / (fact(k) * fact(n - k))\n\nk = int(raw_input())\n\nC = [0]\n\nn = 0\n\nfor i in xrange(k):\n    v = int(raw_input())\n    n += v\n    C.append(v)\n\nsum = 1\n\nfor i in xrange(0, k - 1):\n    sum *= c_n_k(n - 1, C[k - i] - 1)\n    n -= C[k - i]\n\nprint sum % 1000000007"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int def = 1000000007;\nlong long int c[1005][1005];\nlong long int C_(long long int a, long long int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  if (a == 0) {\n    if (b == 0)\n      return 1;\n    else\n      return 0;\n  }\n  return c[a][b] ? c[a][b] : c[a][b] = (C_(a - 1, b) + C_(a - 1, b - 1)) % def;\n}\nint N;\nint main() {\n  long long int cur, total = 0, sum = 1;\n  cin >> N;\n  while (N--) {\n    cin >> cur;\n    long long int t = C_(total + cur - 1, cur - 1) % def;\n    sum = sum * t % def;\n    total += cur;\n  }\n  cout << sum << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n    private static final int MOD = (int)1e9 + 7;\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int[] A = IOUtils.readIntArray(in, count);\n        long answer = 1;\n        int total = 0;\n        for (int i = 0; i < count; i++) {\n            answer = (answer * IntegerUtils.binomialCoefficient(total + A[i] - 1, A[i] - 1, MOD)) % MOD;\n            total += A[i];\n        }\n        out.printLine(answer);\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void printLine(long i) {\n        writer.println(i);\n    }\n\n}\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readInt();\n        return array;\n    }\n\n}\n\nclass IntegerUtils {\n\n    public static long factorial(int n, long mod) {\n        long result = 1;\n        for (int i = 2; i <= n; i++)\n            result = result * i % mod;\n        return result % mod;\n    }\n\n    public static long binomialCoefficient(int n, int m, long mod) {\n        if (m < 0 || m > n)\n            return 0;\n        if (2 * m > n)\n            m = n - m;\n        long result = 1;\n        for (int i = n - m + 1; i <= n; i++)\n            result = result * i % mod;\n        return result * BigInteger.valueOf(factorial(m, mod)).modInverse(BigInteger.valueOf(mod)).longValue() % mod;\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nk=int(input())\nans,s=1,0\nfor i in range(k):\n    ci=int(input())\n    ans=(ans*factorial(s+ci-1)//(factorial(ci-1)*factorial(s)))%1000000007\n    s+=ci\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nk = int(input())\nans = 1\nmod = 10 ** 9 + 7\nn = 0\nfor i in range(k):\n    x = int(input())\n    ans = (ans * (factorial(n + x - 1)) // (factorial(x - 1) * factorial(n))) % mod\n    n += x\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int MOD = 1000 * 1000 * 1000 + 7;\n\n\tpublic static void shuffleArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tsolve(in, out);\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static void solve(InputReader in, PrintWriter out) {\n\n\t\tint k = in.nextInt();\n\t\tint n = 1001;\n\t\tlong[][] newton = new long[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i < j) {\n\t\t\t\t\tnewton[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tnewton[i][j] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewton[i][j] = (newton[i - 1][j - 1] + newton[i - 1][j]) % MOD;\n\t\t\t}\n\t\t}\n\n\t\tlong res = 1;\n\t\tint balls = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint ci = in.nextInt() - 1;\n\t\t\tres = (res * newton[balls + ci][ci]) % MOD;\n\t\t\tballs += ci + 1;\n\t\t}\n\t\tout.print(res);\n\t}\n\n\t/*\n\t * \n\t */\n\t// --------------------------------------------------------\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int n = 1000;\nconst long mod = 1000000007;\nint main() {\n  int k, newk, newn;\n  int* balls;\n  long** cnk;\n  long long rez;\n  cin >> k;\n  balls = new int[k];\n  for (int i = 0; i < k; i++) cin >> balls[i];\n  cnk = new long*[n + 1];\n  for (int i = 0; i < n + 1; i++) cnk[i] = new long[n + 1];\n  for (int i = 0; i < n + 1; i++) cnk[0][i] = 0;\n  for (int i = 0; i < n + 1; i++) cnk[i][0] = 1;\n  for (int i = 1; i < n + 1; i++)\n    for (int j = 1; j < n + 1; j++)\n      cnk[i][j] = (cnk[i - 1][j] + cnk[i - 1][j - 1]) % mod;\n  newn = balls[0];\n  newk = 0;\n  rez = 1;\n  for (int i = 1; i < k; i++) {\n    newk = balls[i] - 1;\n    newn += balls[i];\n    rez = (rez * cnk[newn - 1][newk]) % mod;\n  }\n  cout << rez;\n  for (int i = 0; i < n + 1; i++) delete[] cnk[i];\n  delete[] cnk;\n  delete[] balls;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble Fib(double x, double z);\nstring BinDec(unsigned long long x);\nstring StringInt(long long x);\nunsigned long long StringInt(string x);\nunsigned long long BinDec(string x);\nunsigned long long POWMOD(unsigned long long x, unsigned long long y,\n                          unsigned long long mod);\nunsigned long long POWE(long long, long long);\nlong long fast_pow(long long a, long long b, long long mod) {\n  if (b == 0) return 1ll;\n  long long ans = 1;\n  if (b % 2) return ans = (fast_pow(a, b - 1, mod) * a) % mod;\n  ans = (fast_pow(a, b / 2, mod) % mod);\n  return ((ans * ans) % mod);\n}\nlong long arr[1020] = {};\nlong long nCp(long long a, long long b) {\n  long long ans2 = 1, mod = 1000000007;\n  if (b > a)\n    return 0;\n  else if (b == a)\n    return 1;\n  else {\n    ans2 = arr[a];\n    ans2 *= fast_pow(arr[a - b], mod - 2, mod);\n    ans2 %= mod;\n    ans2 *= fast_pow(arr[b], mod - 2, mod);\n    ans2 %= mod;\n    return ans2;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, i;\n  arr[0] = 1;\n  long long mod = 1000000007, ans = 1;\n  for (i = 1; i < 1003; i++) {\n    ans *= i;\n    ans %= mod;\n    arr[i] = ans;\n  }\n  long long s = 0, p = 1, a;\n  cin >> n;\n  cin >> a;\n  s = a;\n  for (i = 1; i < n; i++) {\n    cin >> a;\n    p *= nCp(s + a - 1, a - 1);\n    p %= mod;\n    s += a;\n  }\n  cout << p;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long comb[1005][1005];\nint main() {\n  ios::sync_with_stdio(false);\n  for (int i = 0; i < 1004; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || i == j)\n        comb[i][j] = 1;\n      else\n        comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  long long k, temp = 0, tempp = 0, ans = 1;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    long long a;\n    cin >> a;\n    ans = (ans * comb[temp + a - 1][a - 1]) % 1000000007;\n    temp += a;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = INT_MAX;\nconst long long MOD = 1000000007;\nint n;\nlong long c[1010], num[1010];\nlong long tab[1010][1010];\nlong long power(long long a, long long b) {\n  long long ans = 1;\n  a %= MOD;\n  while (b) {\n    if (b & 1) {\n      ans = ans * a % MOD;\n      b--;\n    }\n    b >>= 1;\n    a = a * a % MOD;\n  }\n  return ans;\n}\nvoid init() {\n  long long tmp = 1;\n  for (long long i = 1; i <= (long long)1000; i++) {\n    tmp = tmp * i % MOD;\n    num[i] = power(tmp, MOD - 2);\n  }\n  tab[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    tab[i][0] = tab[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % MOD;\n    }\n  }\n}\nint main() {\n  init();\n  scanf(\"%d\", &n);\n  long long ans = 1, tmp = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &c[i]);\n    c[i] -= 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    tmp += c[i] + 1;\n    ans = (ans * tab[tmp - 1][c[i]]) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ndef choose(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return ntok // ktok\n    else:\n        return 0\n\nR = 1000000007\n\ndef main():\n    k = int(sys.stdin.readline())\n    data = list(map(int,sys.stdin.readlines()))\n    s = sum(data)\n    ans=1\n    free = s\n    for i in range(k-1,0,-1):\n        t = choose(free-1, data[i]-1)\n        ans= (((t%R)*ans)%R)\n        free-=data[i]\n    print(ans)\n\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1003][1003];\nlong long mod = 1000000000 + 7;\nint main() {\n  time_t t1, t2;\n  t1 = clock();\n  C[0][0] = 1;\n  for (int i = 1; i < 1003; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    }\n  }\n  long long k;\n  cin >> k;\n  long long c[k];\n  for (long long i = (0); i < (k); i++) cin >> c[i];\n  long long ans[k + 1];\n  ans[1] = 1;\n  long long sm = c[0];\n  for (long long i = (2); i < (k + 1); i++) {\n    sm += c[i - 1];\n    ans[i] = (ans[i - 1] * C[sm - 1][c[i - 1] - 1]) % mod;\n  }\n  cout << ans[k] % mod;\n  t2 = clock();\n  cerr << \"time taken: \" << t2 - t1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\ninline void read(int &x) {\n  int f = 1;\n  x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s >= '0' && s <= '9') {\n    x = x * 10 + s - '0';\n    s = getchar();\n  }\n  x *= f;\n}\nconst int maxn = 1005;\nconst double PI = 3.141592653589793238462643383279;\nlong long a[maxn], e = 1000000007;\nlong long power(long long a, long long n) {\n  long long ans = 1;\n  while (n > 0) {\n    if (n & 1) {\n      ans *= a;\n      ans %= e;\n    }\n    a *= a;\n    a %= e;\n    n /= 2;\n  }\n  return ans;\n}\nlong long fac[1000010];\nint main() {\n  int n;\n  cin >> n;\n  fac[0] = 1;\n  for (int i = 1; i < 1000005; i++) fac[i] = (fac[i - 1] * i) % e;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &a[i]);\n  }\n  long long ans = 1;\n  long long tot = a[1];\n  for (int i = 2; i <= n; i++) {\n    ans = ans * (fac[tot + a[i] - 1] * power(fac[tot], e - 2) % e) % e *\n          power(fac[a[i] - 1], e - 2);\n    ans %= e;\n    tot += a[i];\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod = 1e9 + 7;\nint k, c[1001][1001], a[100001];\nlong long ans = 1;\nvoid init() {\n  c[0][0] = c[1][0] = c[1][1] = 1;\n  for (int i = 2; i <= 1000; i++) {\n    c[i][0] = c[i][i] = 1;\n    for (int j = 1; j <= i; j++) {\n      c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n      c[i][j] %= Mod;\n    }\n  }\n}\nint main() {\n  init();\n  int sum = 0;\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n    sum += a[i];\n  }\n  for (int i = k; i >= 1; i--) {\n    ans *= (long long)c[sum - 1][a[i] - 1];\n    ans %= Mod;\n    sum -= a[i];\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, l, k;\nconst int mx = 1e5 + 9;\nconst long long mod = 1e9 + 7;\nlong long w[mx], x[mx], d[mx];\nlong long sum;\nlong long ncr[2005][2005];\nlong long a[mx];\nint main() {\n  for (int i = 0; i < 2005; i++) {\n    ncr[i][0] = 1;\n    for (int x = 1; x <= i; x++)\n      ncr[i][x] = (ncr[i - 1][x] + ncr[i - 1][x - 1]) % mod;\n  }\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  long long ans = 1;\n  for (int i = k; i >= 1; i--) {\n    ans = (ans * ncr[sum - 1][a[i] - 1]) % mod;\n    sum -= a[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1ll * 1000 * 1000 * 1000ll + 7;\nlong long dp[1000 + 10][1000 + 10];\nint mark[1000 + 10][1000 + 10];\nvoid dpis(int n, int k) {\n  mark[n][k] = 1;\n  if (k > n) {\n    dp[n][k] = 0;\n    return;\n  }\n  if (k == n) {\n    dp[n][k] = 1;\n    return;\n  }\n  if (k == 1) {\n    dp[n][k] = n;\n    return;\n  }\n  if (k == 0) {\n    dp[n][k] = 1;\n    return;\n  }\n  if (n == 1) {\n    dp[n][k] = 0;\n    return;\n  }\n  if (n == 0) {\n    dp[n][k] == 0;\n    return;\n  }\n  if (mark[n - 1][k] == 0) dpis(n - 1, k);\n  if (mark[n - 1][k - 1] == 0) dpis(n - 1, k - 1);\n  dp[n][k] = (dp[n - 1][k - 1] + dp[n - 1][k]) % mod;\n}\nint main() {\n  for (int i = 0; i <= 1002; i++)\n    for (int j = 0; j <= 1002; j++)\n      if (mark[i][j] == 0) dpis(i, j);\n  int n;\n  cin >> n;\n  long long ted = 0, ans = 0;\n  int a;\n  cin >> a;\n  ted = a;\n  ans = 1;\n  for (int i = 0; i < n - 1; i++) {\n    cin >> a;\n    ans = (ans * (dp[ted + a - 1][a - 1])) % mod;\n    ted += a;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "MOD = 10**9 + 7\nN = 1010\nf = [1 for _ in range(N)]\nfor i in range(1, N): f[i] = (f[i - 1] * i) % MOD\ninv = [pow(f[i], MOD - 2, MOD) for i in range(N)]\ndef C(n, k):\n\tif n == 0 or k > n: return 0\n\treturn (f[n] * ((inv[k] * inv[n - k]) % MOD)) % MOD\n\nn = int(input())\ntot = int(input())\nret = 1\nfor i in range(1, n):\n\tx = int(input())\n\ttmp = C(tot + x - 1, x - 1)\n\tret = (ret * tmp) % MOD\n\ttot += x\nprint(ret)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int upto = 1010;\n            long[][] comb = new long[upto][upto];\n            long mod = (int) 1e9 + 7;\n            comb[0][0] = 1;\n            for (int i = 1; i < upto; i++) {\n                comb[i][0] = 1;\n                for (int j = 1; j <= i; j++)\n                    comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;\n            }\n            int k = in.ni();\n            int[] color = new int[k];\n            for (int i = 0; i < k; ++i)\n                color[i] = in.ni();\n            long res = 1;\n            int total = 0;\n            for (int i = 0; i < k; i++) {\n                res = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n                total += color[i];\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String n() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(n());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C554 solver = new C554();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C554 {\n        int K;\n        int N = 0;\n        int MOD = 1_000_000_007;\n        int[] balls;\n        int[][] choose;\n\n        void precomp() {\n            choose = new int[1001][1001];\n            choose[0][0] = choose[1][0] = choose[1][1] = 1;\n            for (int n = 2; n <= 1000; n++) {\n                choose[n][0] = 1;\n                for (int k = 1; k <= n; k++) {\n                    choose[n][k] = choose[n - 1][k] + choose[n - 1][k - 1];\n                    choose[n][k] %= MOD;\n                }\n            }\n        }\n\n        public void solve(int testNumber, FastScanner s, PrintWriter out) {\n            K = s.nextInt();\n            balls = new int[K];\n            for (int i = 0; i < K; i++) {\n                balls[i] = s.nextInt();\n                N += balls[i];\n            }\n            precomp();\n\n            long tot = 1;\n            int rem = N;\n            for (int ball = K - 1; ball >= 0; ball--) {\n                rem--;\n                balls[ball]--;\n                tot *= choose[rem][balls[ball]];\n                tot %= MOD;\n                rem -= balls[ball];\n            }\n\n            out.println(tot);\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e6 + 10;\nint n;\nint b[maxn];\nlong long int dp[maxn];\nint pes;\nlong long int fac[maxn];\nlong long int inv[maxn];\nlong long int pw(long long int a, long long int c) {\n  long long int res = 1;\n  while (c) {\n    if (c % 2) {\n      res = (1ll * res * a) % mod;\n    }\n    a = (1ll * a * a) % mod;\n    c /= 2;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  fac[0] = 1;\n  inv[0] = 1;\n  for (int i = 1; i <= (int)1e6 + 5; i++) {\n    fac[i] = (1ll * fac[i - 1] * i) % mod;\n    inv[i] = pw(fac[i], mod - 2);\n  }\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n  }\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      dp[i] = 1;\n    } else {\n      int fes = 0;\n      for (int j = 0; j < i; j++) {\n        fes += b[j];\n      }\n      dp[i] = (1ll * ((1ll * fac[fes + b[i] - 1] * inv[b[i] - 1]) % mod) *\n               inv[fes]) %\n              mod;\n      dp[i] *= dp[i - 1];\n      dp[i] %= mod;\n    }\n  }\n  cout << dp[n - 1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1100;\nconst int MOD = 1e9 + 7;\nlong long power(long long a, long long b) {\n  long long ret = 1;\n  for (; b > 0; b >>= 1) {\n    if (b & 1) ret = (ret * a) % MOD;\n    a = (a * a) % MOD;\n  }\n  return ret;\n}\nint N, A[MAXN];\nlong long ncr(int a, int b) {\n  long long ret = 1;\n  for (int i = a; i > a - b; --i) ret = (ret * i) % MOD;\n  for (int i = 1; i <= b; ++i) ret = (ret * power(i, MOD - 2)) % MOD;\n  return ret;\n}\nint main(void) {\n  scanf(\"%d\", &N);\n  int sum = 0;\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &A[i]);\n    sum += A[i];\n  }\n  long long ans = 1;\n  for (int i = N - 1; i >= 0; --i) {\n    int n = sum - 1;\n    int r = A[i] - 1;\n    sum -= A[i];\n    ans *= ncr(n, r);\n    ans %= MOD;\n  }\n  printf(\"%d\\n\", (int)ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Solution\n{\n    private static boolean stdin = true;\n    private static Scanner sc;\n    private static PrintWriter wr;\n    \n    public static void main(String[] args) throws Exception\n    {\n        if (stdin)\n        {\n            sc = new Scanner(System.in);\n            wr = new PrintWriter(System.out);\n        }\n        else\n        {\n            sc = new Scanner(new File(\"input.txt\"));\n            wr = new PrintWriter(new File(\"output.txt\"));\n        }\n        \n        Run();\n        \n        sc.close();\n        wr.close();\n    }\n    \n    private static BigInteger C(int n, int k)\n    {\n        BigInteger res = BigInteger.ONE, tmp = BigInteger.ONE;\n        \n        for (int i = 1; i <= n; ++i)\n            res = res.multiply(BigInteger.valueOf(i));\n        \n        for (int i = 1; i <= k; ++i)\n            tmp = tmp.multiply(BigInteger.valueOf(i));\n        \n        for (int i = 1; i <= n - k; ++i)\n            tmp = tmp.multiply(BigInteger.valueOf(i));\n        \n        res = res.divide(tmp);\n        \n        return res;\n    }\n\n    private static void Run() throws Exception\n    {\n        int k = sc.nextInt(), n = 0;\n        BigInteger ans = BigInteger.ONE;\n        \n        for (int i = 0; i < k; ++i)\n        {\n            int cnt = sc.nextInt();\n            \n            n += cnt;\n            \n            ans = ans.multiply(C(n - 1, cnt - 1));\n        }\n        \n        BigInteger inf = BigInteger.valueOf(1000000007);\n        \n        ans = ans.subtract(ans.divide(inf).multiply(inf));\n        \n        wr.println(ans);\n    }\n}"
        },
        {
            "language": 1,
            "solution": "def comb(n,r):\n    if(n-r<r):\n        r=n-r\n    nr,dr=(1,1)\n    for i in range(r):\n        nr*=n\n        n=n-1\n        dr*=i+1\n    return (nr/dr)%1000000007\n\n\n\nn=input()\na=[]\nsumm=0\nfor i in range(n):\n    num=input()\n    a.append(num)\n    summ+=num\nN=summ-1\nans=1\nfor i in a [::-1]:\n    ans=(ans*comb(N,i-1))%1000000007\n    N=N-i\n\nprint ans    \n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nn,ans,s = int(input()),1,0\nfor i in range(n) :\n  a = int(input())\n  ans=(ans*factorial(s+a-1)//factorial(s)//factorial(a-1))%1000000007\n  s+=a\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "    import java.util.*;\n    import java.io.*;\n\n     public class Codeforces {\n         \n        public static void main(String[] args) throws IOException {\n            Reader.init(System.in);\n            \n            int k = Reader.nextInt();\n            int arr[] = new int[k];\n            \n            for(int i = 0; i < k; i++)\n                arr[i] = Reader.nextInt();\n            \n            long comb[][] = new long[1001][1001];\n            comb[0][0] = 1;\n            \n            for(int i = 1; i < 1001; i++){\n                comb[i][0] = 1;\n                \n                for(int j = 1; j <= i; j++)\n                    comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % 1000000007;\n            }\n            \n            int total = 0;\n            long ans = 1;\n            \n            for(int i = 0; i < k; i++){\n                ans = (ans * comb[total + arr[i] - 1][arr[i] -1]) % 1000000007;\n                total += arr[i];\n            }\n            \n            System.out.println(ans);\n        }\n        \n     }\n\n    class  Pair implements Comparable<Pair>{\n\n        int val;\n        int index;\n\n        Pair(int a, int b){\n            val = a;\n            index = b;\n        }\n\n        @Override\n        public int compareTo(Pair t) {\n            int a = val - t.val;\n            if(a == 0)\n                return index - t.index;\n            return a;\n        }\n\n    }\n\n\n\n    class Reader {\n\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        public static int pars(String x) {\n            int num = 0;\n            int i = 0;\n            if (x.charAt(0) == '-') {\n                i = 1;\n            }\n            for (; i < x.length(); i++) {\n                num = num * 10 + (x.charAt(i) - '0');\n            }\n\n            if (x.charAt(0) == '-') {\n                return -num;\n            }\n\n            return num;\n        }\n\n        static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        static void init(FileReader input) {\n            reader = new BufferedReader(input);\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return pars(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }            "
        },
        {
            "language": 1,
            "solution": "t=1\nfact=[1]\nwhile t<=1002:\n    prod=t*fact[t-1]\n    fact.append(prod)\n    t=t+1\n    \nn=int(raw_input())\nsum=0\nprod=1\nt=1\nwhile t<=n:\n    r=int(raw_input())\n    sum=sum+r\n    if(t>1):\n        ncr=fact[sum-1]/(fact[sum-r]*fact[r-1])\n        prod=prod*ncr\n    t=t+1\n    \n\nprint prod%1000000007"
        },
        {
            "language": 3,
            "solution": "import math\nMOD = 1000000007\nMAXN = 1005\n\ncomb = [([0] * MAXN) for i in range(0, MAXN)]\ncomb[0][0] = 1\nfor i in range(1, MAXN):\n    comb[i][0] = 1\n    for j in range(1, i + 1):\n        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1]\n        comb[i][j] %= MOD\n\nk = int(input())\nsum = 0\nans = 1\nfor i in range(0, k):\n    num = int(input())\n    sum += num\n    ans = ans * comb[sum - 1][num - 1] % MOD\n\nprint (ans)"
        },
        {
            "language": 1,
            "solution": "def f(n):\n    a=1\n    for i in range(1,n+1):\n        a=a*i\n    return a\nk=input()\nsum=0\nans=1\nfor i in range(k):\n    t=input()\n    ans=ans*f(sum+t-1)/f(sum)/f(t-1)\n    ans=ans%1000000007\n    sum+=t\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1001];\nunsigned long long comb[3000][3000];\nvoid init() {\n  int i, j;\n  for (i = 0; i < 3000; i++) comb[i][0] = 1;\n  for (i = 1; i < 3000; i++) {\n    for (j = 1; j <= i; j++) {\n      comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n      comb[i][j] %= 1000000007;\n    }\n  }\n}\nint main() {\n  memset(comb, 0, sizeof(comb));\n  init();\n  int n;\n  cin >> n;\n  unsigned long long dp[n + 1], s[n + 1];\n  memset(c, 0, sizeof(c));\n  s[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n    s[i] = s[i - 1] + c[i];\n  }\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    dp[i] = dp[i - 1] * comb[s[i] - 1][c[i] - 1];\n    dp[i] %= 1000000007;\n  }\n  cout << dp[n] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long cc[1010][1010];\nvoid Init() {\n  for (int n = 0; n <= 1000; n++) {\n    for (int m = 0; m <= n; m++) {\n      if (m == 0 || n == m)\n        cc[n][m] = 1;\n      else\n        cc[n][m] = cc[n - 1][m] % 1000000007 + cc[n - 1][m - 1] % 1000000007;\n    }\n  }\n}\nint a[10000];\nint main() {\n  Init();\n  int n;\n  scanf(\"%d\", &n);\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    sum += a[i];\n  }\n  int last = n;\n  long long way = 1;\n  while (last >= 1) {\n    way = way * cc[sum - 1][a[last] - 1] % 1000000007;\n    sum -= a[last];\n    last--;\n  }\n  printf(\"%I64d\\n\", way % 1000000007);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int M = 1e3 + 10;\nconst int mod = 1e9 + 7;\nlong long a[M], sum[M], f[M];\nint k;\nlong long mul(long long x, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res % mod;\n}\nvoid init() {\n  f[0] = 1;\n  int i;\n  for (i = 1; i < M; i++) f[i] = (f[i - 1] * i) % mod;\n}\nlong long C(int m, int n) {\n  long long res =\n      ((f[m] * mul(f[n], mod - 2)) % mod * mul(f[m - n], mod - 2)) % mod;\n  return res;\n}\nint main() {\n  init();\n  while (~scanf(\"%d\", &k)) {\n    memset(sum, 0, sizeof(sum));\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%lld\", &a[i]);\n      sum[i] = sum[i - 1] + a[i];\n    }\n    long long ans = 1;\n    for (int i = k; i > 0; i--) {\n      ans = ans * C(sum[i] - 1, a[i] - 1) % mod;\n      sum[i] -= a[i];\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9L + 7;\nlong long power(long long x, long long y) {\n  long long res = 1LL;\n  x = x % MOD;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % MOD;\n    y = y >> 1;\n    x = (x * x) % MOD;\n  }\n  return res;\n}\nlong long modInverse(long long n) { return power(n, MOD - 2); }\nlong long nCr(long long n, long long r) {\n  if (r == 0) return 1;\n  long long fac[n + 1];\n  fac[0] = 1;\n  for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % MOD;\n  return (fac[n] * modInverse(fac[r]) % MOD * modInverse(fac[n - r]) % MOD) %\n         MOD;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int k;\n  cin >> k;\n  vector<int> c(k), p_sum(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> c[i];\n    p_sum[i] = c[i];\n    p_sum[i] += (i > 0 ? p_sum[i - 1] : 0);\n  }\n  vector<long long> dp(k + 1);\n  dp[0] = 1;\n  for (int i = 1; i < k; ++i) {\n    if (c[i] == 1) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = (dp[i - 1] % MOD * nCr(c[i] + p_sum[i - 1] - 1, c[i] - 1) % MOD) %\n              MOD;\n    }\n  }\n  cout << dp[k - 1] % MOD;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long s[1010][1010] = {0};\n  int t;\n  int a = 1;\n  int q;\n  long long ans = 1;\n  for (int i = 0; i < 1010; i++) s[i][0] = 1;\n  for (int i = 1; i < 1010; i++)\n    for (int j = 1; j < 1010; j++)\n      s[i][j] = (s[i][j - 1] + s[i - 1][j]) % 1000000007;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    cin >> q;\n    ans = (ans * s[a][q - 1]) % 1000000007;\n    a += q;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[1005], MOD = 1000000007, ara[1005], sum[1005];\nlong long BigMod(long long B, long long P, long long M) {\n  long long R = 1;\n  while (P > 0) {\n    if (P % 2 == 1) {\n      R = (R * B) % M;\n    }\n    P /= 2;\n    B = (B * B) % M;\n  }\n  return R;\n}\nvoid gen() {\n  long long i;\n  fac[0] = 1;\n  for (i = 1; i <= 1000; i++) fac[i] = (fac[i - 1] * i) % MOD;\n}\nlong long dp[1005];\nlong long solve(long long n) {\n  long long up = sum[n] - 1;\n  long long down = ara[n] - 1;\n  long long an = up - down;\n  up = fac[up];\n  down = fac[down];\n  an = fac[an];\n  long long res = BigMod(down, MOD - 2, MOD);\n  up = (up * res) % MOD;\n  res = BigMod(an, MOD - 2, MOD);\n  up = (up * res) % MOD;\n  return up;\n}\nlong long rec(long long n) {\n  dp[1] = 1;\n  long long i;\n  for (i = 2; i <= n; i++) {\n    dp[i] = (dp[i - 1] * solve(i)) % MOD;\n  }\n  return dp[n];\n}\nint main() {\n  gen();\n  long long n;\n  scanf(\"%I64d\", &n);\n  long long i, c;\n  for (i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &ara[i]);\n    sum[i] = sum[i - 1] + ara[i];\n  }\n  printf(\"%I64d\\n\", rec(n));\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n\n    int MAX = 1001;\n    int MOD = (int) 1e9 + 7;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        long[][] c = new long[MAX][MAX];\n        c[0][0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n                c[i][j] %= MOD;\n            }\n        }\n\n        long res = 1;\n        int k = in.readInt();\n        int[] colors = new int[k];\n        for (int i = 0; i < k; i++) colors[i] = in.readInt();\n\n        int total = 0;\n        for (int i = 0; i < k; i++) {\n            res *= c[total + colors[i] - 1][colors[i] - 1];\n            res %= MOD;\n            total += colors[i];\n        }\n\n        out.printLine(res);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e3 + 10;\nlong long dp[maxn][maxn];\nlong long a[maxn];\nlong long sum, ans, n;\nint main() {\n  dp[0][0] = 1;\n  dp[1][1] = 1;\n  dp[1][0] = 1;\n  for (int i = 2; i < 1005; i++) {\n    dp[i][0] = 1;\n    dp[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 1000000007;\n    }\n  }\n  while (~scanf(\"%lld\", &n)) {\n    sum = 0, ans = 1;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%lld\", &a[i]);\n      sum += a[i];\n      ans *= dp[sum - 1][a[i] - 1];\n      ans %= 1000000007;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long ans(int len, int c);\nlong long comb[1000][1000] = {0};\nint main(void) {\n  int k, c[1000], i;\n  long long dp[1000] = {1};\n  for (i = 0; i <= 1000; i++) {\n    comb[i][0] = comb[i][i] = 1;\n  }\n  scanf(\"%i\", &k);\n  for (i = 0; i < k; i++) scanf(\"%i\", &c[i]);\n  int len = c[0] - 1;\n  for (i = 1; i < k; i++) {\n    len += c[i];\n    dp[i] = (dp[i - 1] * ans(len, c[i] - 1)) % 1000000007;\n  }\n  printf(\"%I64d\\n\", dp[k - 1]);\n  return 0;\n}\nlong long ans(int len, int c) {\n  if (!comb[len][c])\n    comb[len][c] = (ans(len - 1, c) + ans(len - 1, c - 1)) % 1000000007;\n  return comb[len][c];\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class C554 {\n\n\tstatic int MAXN = 1001,mod = (int)(1e9+7);\n\tstatic long comb[][];\n\tpublic static void main(String[] args) {\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t/*My code starts here.*/\n\t\tint n = s.nextInt();\n\t\tpreCalcComb();\n\t\tint sum = 0;\n\t\tlong res = 1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x = s.nextInt();\n\t\t\tsum+=x;\n\t\t\tres = (res * comb[sum - 1][x - 1])%mod;\n\t\t}\n\t\tout.println(res);\n\t\t/*My code ends here.*/\n\t\tout.close();\n\t}\n\t\n\tstatic void preCalcComb(){\n\t    comb = new long[MAXN][MAXN];\n\t    comb[0][0] = 1;\n\t    for (int i = 1; i < MAXN; i++) {\n\t      comb[i][0] = 1;\n\t      for (int j = 1; j <= i; j++) {\n\t        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n\t      }\n\t    }\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint num, freq, idx;\n\n\t\tpublic Node(int u, int v, int idx) {\n\t\t\tthis.num = u;\n\t\t\tthis.freq = v;\n\t\t\tthis.idx = idx;\n\t\t}\n\n\t\tpublic int compareTo(Node n) {\n\t\t\tif (this.freq == n.freq)\n\t\t\t\treturn Integer.compare(this.num, n.num);\n\t\t\treturn Integer.compare(-this.freq, -n.freq);\n\t\t}\n\t}\n\n\tstatic long PowerMod(long a, long b, long m) {\n\t\tlong tempo;\n\t\tif (b == 0)\n\t\t\ttempo = 1;\n\t\telse if (b == 1)\n\t\t\ttempo = a;\n\t\telse {\n\t\t\tlong temp = PowerMod(a, b / 2, m);\n\t\t\tif (b % 2 == 0)\n\t\t\t\ttempo = (temp * temp) % m;\n\t\t\telse\n\t\t\t\ttempo = ((temp * temp) % m) * a % m;\n\t\t}\n\t\treturn tempo;\n\t}\n\n\tlong no_of_primes(long m, long n, long k) {\n\t\tlong count = 0, i, j;\n\t\tint primes[] = new int[(int) (n - m + 2)];\n\t\tif (m == 1)\n\t\t\tprimes[0] = 1;\n\t\tfor (i = 2; i <= Math.sqrt(n); i++) {\n\t\t\tj = (m / i);\n\t\t\tj *= i;\n\t\t\tif (j < m)\n\t\t\t\tj += i;\n\t\t\tfor (; j <= n; j += i) {\n\t\t\t\tif (j != i)\n\t\t\t\t\tprimes[(int) (j - m)] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i <= n - m; i++)\n\t\t\tif (primes[(int) i] == 0 && (i - 1) % k == 0)\n\t\t\t\tcount++;\n\t\treturn count;\n\t}\n\n\tstatic void shortestPaths(List<Edge>[] edges, int s, int[] prio, int[] pred) {\n\t\tArrays.fill(pred, -1);\n\t\tArrays.fill(prio, Integer.MAX_VALUE);\n\t\tprio[s] = 0;\n\t\tPriorityQueue<Long> q = new PriorityQueue<>();\n\t\tq.add((long) s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tlong cur = q.remove();\n\t\t\tint curu = (int) cur;\n\t\t\tif (cur >>> 32 != prio[curu])\n\t\t\t\tcontinue;\n\t\t\tfor (Edge e : edges[curu]) {\n\t\t\t\tint v = e.t;\n\t\t\t\tint nprio = prio[curu] + e.cost;\n\t\t\t\tif (prio[v] > nprio) {\n\t\t\t\t\tprio[v] = nprio;\n\t\t\t\t\tpred[v] = curu;\n\t\t\t\t\tq.add(((long) nprio << 32) + v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint t, cost;\n\n\t\tpublic Edge(int t, int cost) {\n\t\t\tthis.t = t;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[1003][1003];\nconst int MD = 1000000000 + 7;\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    c[i][0] = c[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n      if (c[i][j] >= MD) {\n        c[i][j] -= MD;\n      }\n    }\n  }\n  long long ans = 1;\n  int n;\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    sum += x - 1;\n    ans = (ans * c[sum][x - 1]) % MD;\n    sum++;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "MOD = 10 ** 9 + 7\ndef fact(n):\n    factor = 1\n    if n == 0:\n        return 1\n    for i in range(1, n + 1):\n        factor = (factor * i)\n    return factor\nmass = [] \nn = int(input())\nfor i in range(n):\n    mass.append(int(input()))\nres = 1\nsumm = 0\nfor i in range(n):\n    summ += mass[i]\n    res = (res * fact(summ - 1) // (fact(mass[i] - 1)\n           * fact(summ - mass[i]))) % MOD\nprint(res)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\n\nn = int(input())\n\nans,s = 1,0\nfor i in range(n) :\n  a = int(input())\n  ans=(ans*factorial(s+a-1)//factorial(s)//factorial(a-1))%1000000007\n  s+=a\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "\n// ~/BAU/ACM-ICPC/Teams/A++/BlackBurn95\n// ~/sudo apt-get Accpeted\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    static int MOD = (int)1e9+7;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        int [][] c = new int[2000][2000];\n        c[0][0] = 1;\n        for(int i=1; i<c.length; i++) {\n            c[i][0] = 1;\n            for(int j=1; j<=i; j++)\n                c[i][j] = (c[i-1][j] + c[i-1][j-1])%MOD;\n        }\n        \n        int k = parseInt(in.readLine());\n        int sum = 0;\n        long ans = 1;\n        \n        for(int i=0; i<k; i++) {\n            int x = parseInt(in.readLine());\n            \n            ans = ((long)ans * (long)c[sum+x-1][x-1])%MOD;\n            sum += x;\n        }\n        \n        System.out.println(ans);\n    }\n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n/**\n * Created by Shreyans Sheth [bholagabbar] on 6/25/2015 at 2:50 PM using IntelliJ IDEA (Fast IO Template)\n */\n\n\npublic class C\n{\n    static int mod= 1000000007;\n    static List<ArrayList<Long>>C=new ArrayList<ArrayList<Long>>(1005);\n\n    static void COMBINATIONS()\n    {\n        for(int i=0;i<=1005;i++)\n        {\n            C.add(new ArrayList<Long>(i+1));\n            for(int j=0;j<=i;j++)\n            {\n                if(j==0||j==i)\n                {\n                    C.get(i).add((long)1);\n                }\n                else\n                {\n                    C.get(i).add((C.get(i-1).get(j-1)+C.get(i-1).get(j))%mod);\n                }\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws Exception\n    {\n        //System.setIn(new FileInputStream(\"E:/Shreyans/Documents/Code/CODE/src/Stdin_File_Read.txt\"));\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n\n        COMBINATIONS();\n        int n=in.readInt();\n        int tb=in.readInt();//total balls =starting balls and arrange only in one way\n        long pro=1;\n\n        for(int i=2;i<=n;i++)\n        {\n            int cb=in.readInt();\n            pro=(pro%mod)*((C.get(tb+cb-1).get(cb-1))%mod);\n            tb+=cb;\n        }\n        out.printLine(pro%mod);\n\n        {\n            out.close();\n        }\n    }\n\n    //FAST IO\n    private static class InputReader\n    {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                } catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public double readDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, readInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public long readLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    private static class OutputWriter\n    {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream)\n        {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer)\n        {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects)\n        {\n            for (int i = 0; i < objects.length; i++)\n            {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n            writer.flush();\n        }\n\n        public void printLine(Object... objects)\n        {\n            print(objects);\n            writer.println();\n            writer.flush();\n        }\n\n        public void close()\n        {\n            writer.close();\n        }\n\n        public void flush()\n        {\n            writer.flush();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long mpow(long long a, long long n, long long mod) {\n  long long ret = 1;\n  long long b = a;\n  while (n) {\n    if (n & 1) ret = (ret * b) % mod;\n    b = (b * b) % mod;\n    n >>= 1;\n  }\n  return (long long)ret;\n}\nusing namespace std;\nlong long C[1001][1001];\nlong long a[1001];\nvoid c() {\n  int i, j;\n  for (i = 0; i <= 1000; i++) C[i][0] = 1;\n  for (i = 1; i <= 1000; i++) {\n    for (j = 1; j <= i; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % 1000000007;\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int i, j;\n  long long tot = 0;\n  c();\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    tot += a[i];\n  }\n  long long ans = C[tot - 1][a[n - 1] - 1];\n  tot--;\n  tot -= (a[n - 1] - 1);\n  for (j = n - 2; j >= 0; j--) {\n    ans = (ans * C[tot - 1][a[j] - 1]) % 1000000007;\n    tot -= (a[j]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class c {\n\n\tpublic static void main(String[] Args) throws Exception\n\t{\n\t\tfscan sc = new fscan(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong ans = 1;\n\t\tchoose();\n\t\tint tot = 0;\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tint nn = sc.nextInt();\n\t\t\tans *= choose[tot+nn-1][nn-1];\n\t\t\ttot += nn;\n\t\t\tans%=MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static long[][] choose = new long[2000][2000];\n\t\n\tpublic static final long MOD = 1000000007;\n\tpublic static void choose(){\n\t\tchoose[0][0] = 1;\n\t\tfor(int k = 1; k <2000; k++){\n\t\t\tchoose[k][0] = 1;\n\t\t\tfor(int j = 1; j <= k; j++){\n\t\t\t\tchoose[k][j] = (choose[k-1][j] + choose[k-1][j-1]) %MOD; \n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class fscan {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tfscan(InputStream in) throws Exception {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tif (st.hasMoreTokens()) {\n\t\t\t\treturn st.nextToken();\n\t\t\t}\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn next();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint mod = 1_000_000_007;\n\n\t\tint[] balls = new int[in.nextInt()];\n\t\tint nBalls = 0;\n\t\tfor (int i = 0; i < balls.length; i++) {\n\t\t\tballs[i] = in.nextInt();\n\t\t\tnBalls += balls[i];\n\t\t}\n\n\t\tlong[][] c = new long[1 + nBalls][1 + nBalls];\n\t\tfor (int n = 0; n < c.length; n++) {\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\tif (k == 0) {\n\t\t\t\t\tc[n][k] = 1;\n\t\t\t\t} else if (n == k) {\n\t\t\t\t\tc[n][k] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tc[n][k] = (c[n - 1][k] + c[n - 1][k - 1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong res = 1;\n\t\tint total = balls[0];\n\t\tfor (int i = 1; i < balls.length; i++) {\n\t\t\ttotal += balls[i];\n\t\t\t// out.println(i + \" \" + (total - 1) + \" \" + (balls[i] - 1) + \" = \"\n\t\t\t// + c[total - 1][balls[i] - 1]);\n\t\t\tres = (res * c[total - 1][balls[i] - 1]) % mod;\n\t\t}\n\n\t\tout.println(res);\n\t}\n\n\tvoid run() {\n\t\tLocale.setDefault(Locale.US);\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\ttry {\n\t\t\tsolve();\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, maxn = 1000005;\nint fact[maxn], inv[maxn];\nvoid init(int n = 1e6) {\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++)\n    fact[i] = (long long)i * fact[i - 1] % 1000000007;\n  inv[1] = 1;\n  for (int i = 2; i <= n; i++)\n    inv[i] = 1000000007 -\n             (long long)(1000000007 / i) * inv[1000000007 % i] % 1000000007;\n  inv[0] = 1;\n  for (int i = 1; i <= n; i++)\n    inv[i] = (long long)inv[i - 1] * inv[i] % 1000000007;\n}\nint C(int n, int m) {\n  return (long long)fact[n] * inv[m] % 1000000007 * inv[n - m] % 1000000007;\n}\nint n, k, a[maxn];\nint main() {\n  init();\n  while (~scanf(\"%d\", &k)) {\n    n = 0;\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%d\", &a[i]);\n      n += a[i];\n    }\n    int ans = 1;\n    for (int i = k; i >= 1; i--)\n      ans = (long long)ans * C(n - 1, a[i] - 1) % 1000000007, n -= a[i];\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n \n \n public   class Main {\n    static class Reader\n    {\n    BufferedReader r;\n    StringTokenizer str;\n    Reader()\n    {\n    r=new BufferedReader(new InputStreamReader(System.in));\n    }\n    Reader(String fileName) throws FileNotFoundException\n    {\n    r=new BufferedReader(new FileReader(fileName));\n    }\n    public String getNextToken() throws IOException\n    {\n    if(str==null||!str.hasMoreTokens())\n    {\n    str=new StringTokenizer(r.readLine());\n    }\n    return str.nextToken();\n    }\n    public int nextInt() throws IOException\n    {\n    return Integer.parseInt(getNextToken());\n    }\n    public long nextLong() throws IOException\n    {\n    return Long.parseLong(getNextToken());\n    }\n    public double nextDouble() throws IOException\n    {\n    return Double.parseDouble(getNextToken());\n    }\n    public String nextString() throws IOException\n    {\n    return getNextToken();\n    }\n    public int[] intArray(int n) throws IOException\n    {\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextInt();\n        \n        return a;\n        \n    }\n    public long[] longArray(int n) throws IOException\n    {\n        long a[]=new long[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextLong();\n        \n        return a;\n        \n    }\n    public String[] stringArray(int n) throws IOException\n    {\n        String a[]=new String[n];\n        for(int i=0;i<n;i++)\n            a[i]=nextString();\n        \n        return a;\n        \n    }\n    public long gcd(long a, long b) {\n        if(b == 0){\n        return a;\n        }\n        return gcd(b, a%b);\n    }\n    }\n   \n    \n    public static void main(String args[]) throws IOException{\n \n       Reader r =new Reader();\n       PrintWriter pr=new PrintWriter(System.out,false);\n       int n=r.nextInt();\n       \n       long mod=1000000007;\n       long count=0;\n       long ways=1;\n       long a=r.nextLong();\n       ways=1;\n       count=a;\n       BigInteger way=BigInteger.valueOf(ways);\n       for(int i=1;i<n;i++)\n       {\n           a=r.nextLong();\n           \n           \n           if(a>1)\n           {\n           ways=ways*fact(a-1+count,a-1);\n               ways%=mod;\n//               BigInteger fact=fact(a-1+count);\n//               fact=fact.divide(fact(count));\n//               fact=fact.divide(fact(a-1));\n//               //fact=fact.mod(BigInteger.valueOf(mod));\n//           //    System.out.println(fact);\n//               way=way.multiply(fact);\n           }\n                 //  way=way.mod(BigInteger.valueOf(mod));\n           count+=a;\n       }\n       \n       \n       pr.println(ways);\n       pr.flush();\n       pr.close();\n       \n    }\n    public static BigInteger fact(long a)\n    {\n        BigInteger num=BigInteger.ONE;\n        for(long i=1;i<=a;i++)\n            num=num.multiply(BigInteger.valueOf(i));\n        return num;\n    }\n    public static  long fact(long a,long b)\n    {\n       \n        BigInteger num=BigInteger.ONE;\n        num=new BigInteger(a+\"\");\n        for(long i=1;i<=b-1;i++)\n        {\n            \n            num=num.multiply(BigInteger.valueOf(a-i));\n            num=num.divide(BigInteger.valueOf(i));\n            \n            \n            \n        }\n        num=num.divide(BigInteger.valueOf(b));\n        \n        num=num.mod(BigInteger.valueOf(1000000007l));\n       \n        return num.longValue();\n    }\n    \n }"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1100][1100];\nint n, k;\nint sum[1100];\nint main() {\n  for (int i = 0; i < 1100; i++) C[i][0] = C[i][i] = 1;\n  for (int i = 1; i < 1100; i++)\n    for (int j = 1; j < i; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % 1000000007;\n    }\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> sum[i];\n  }\n  long long ans = 1;\n  long long tot = 0;\n  for (int i = 0; i < 1100; i++)\n    if (sum[i]) {\n      ans *= C[tot + sum[i] - 1][sum[i] - 1];\n      ans %= 1000000007;\n      tot += sum[i];\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int triangle[5000 + 1][5000 + 1];\nvoid makeTriangle() {\n  int i, j;\n  triangle[0][0] = 1;\n  for (i = 1; i < 5000; i++) {\n    triangle[i][0] = 1;\n    for (j = 1; j <= i; j++) {\n      triangle[i][j] =\n          (triangle[i - 1][j - 1] + triangle[i - 1][j]) % 1000000007;\n    }\n  }\n}\nlong long int C(long long int n, long long int r) { return triangle[n][r]; }\nint main() {\n  int k;\n  makeTriangle();\n  scanf(\"%d\", &k);\n  int a[1005], f[1005], i;\n  f[0] = 0;\n  for (i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n    f[i] = f[i - 1] + a[i];\n  }\n  int long long ans = 1;\n  for (i = 2; i <= k; i++) {\n    ans = (ans * C(f[i] - 1, a[i] - 1)) % 1000000007;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "MOD = 10 ** 9 + 7\n\nncr = [[0 for i in xrange(1000)] for j in xrange(1000)]\nfor i in xrange(1000):\n    ncr[i][0] = ncr[i][i] = 1\n    ncr[i][1] = i\n\nfor n in xrange(2, 1000):\n    for r in xrange(2, 1000):\n        ncr[n][r] = ncr[n - 1][r - 1] + ncr[n - 1][r]\n        if ncr[n][r] >= MOD: ncr[n][r] -= MOD\n\nk = input()\nc = [0] * k\nfor i in xrange(k):\n    c[i] = input()\n\nans = 1\npi = ci = 0\nfor i in xrange(k):\n    ci = c[i]\n    pi += ci\n\n    ans *= ncr[pi - 1][ci - 1]\n    if (ans >= MOD): ans %= MOD\n\nprint ans"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        IOUtils ut = new IOUtils(System.in, System.out);\n        new Solution(ut);\n        ut.close();\n    }\n}\n\nclass Solution {\n    IOUtils io;\n\n    int n;\n    int[] balls, cumulative;\n    long[] ans;\n    final long md = 1000000007;\n    long[][] ncr = new long[2005][2005];\n\n    public Solution(IOUtils io) throws Exception {\n        this.io = io;\n\n        for (int i = 0; i < 2005; i++) {\n            ncr[0][i] = 0;\n            ncr[i][0] = 1;\n        }\n        for (int i = 1; i < 2005; i++) {\n            for (int j = 1; j < 2005; j++) {\n                ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % md;\n            }\n        }\n\n        n = io.readInt();\n        balls = new int[n];\n        cumulative = new int[n];\n        ans = new long[n];\n        for (int i = 0; i < n; i++) {\n            balls[i] = io.readInt();\n        }\n        cumulative[0] = balls[0];\n        for (int i = 1; i < n; i++) {\n            cumulative[i] = cumulative[i - 1] + balls[i];\n        }\n\n        ans[0] = 1;\n        for (int i = 1; i < n; i++) {\n            ans[i] = (ans[i - 1] * ncr[cumulative[i - 1] + balls[i] - 1][balls[i] - 1]) % md;\n        }\n        io.writeln(ans[n - 1]);\n    }\n}\n\nclass IOUtils {\n    public BufferedReader in;\n    public PrintWriter out;\n    StringTokenizer st = null;\n\n    public IOUtils(InputStream inStream, OutputStream outStream) {\n        in = new BufferedReader(new InputStreamReader(inStream));\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream)));\n    }\n\n    private void read_input() throws Exception {\n        while (st == null || !(st.hasMoreTokens())) {\n            st = new StringTokenizer(in.readLine());\n        }\n    }\n\n    public void close() throws Exception {\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    public String read() throws Exception {\n        read_input();\n        return st.nextToken();\n    }\n\n    public int readInt() throws Exception {\n        read_input();\n        return Integer.parseInt(st.nextToken());\n    }\n\n    public long readLong() throws Exception {\n        read_input();\n        return Long.parseLong(st.nextToken());\n    }\n\n    public double readDouble() throws Exception {\n        read_input();\n        return Double.parseDouble(st.nextToken());\n    }\n\n    public void writeln(String i) throws Exception {\n        out.println(i);\n    }\n\n    public void write(String i) throws Exception {\n        out.print(i);\n    }\n\n    public void writeln() throws Exception {\n        out.print(\"\\n\");\n    }\n\n    public void write(int i) throws Exception {\n        out.print(i);\n    }\n\n    public void writeln(int i) throws Exception {\n        out.println(i);\n    }\n\n    public void write(long i) throws Exception {\n        out.print(i);\n    }\n\n    public void writeln(long i) throws Exception {\n        out.println(i);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys \nimport math\nfrom math import *\nfrom operator import add\nfrom itertools import permutations \nimport itertools\n# try:\n# \tsys.stdin = open('input.txt', 'r') \n# \tsys.stdout = open('output.txt', 'w')\n# except noerror:\n# \tprint(\"no input_file\")\ninf = 1e10\nmod = int(1e9 + 7)\ndef NcR(n, r):\n\t\"\"\"\n    p holds the value of n*(n-1)*(n-2)...,\n    k holds the value of r*(r-1)... \n    C(n, r) == C(n, n-r),\n    choosing the smaller value \"\"\"\n\tp = 1\n\tk = 1\n\tif (n - r < r):r = n - r\n\tif (r != 0):\n\t\twhile (r):\n\t\t\tp *= n\n\t\t\tk *= r\n\t\t\tm = gcd(p, k)\n\t\t\t\"\"\"\n\t\t\tgcd of p, k\n\t\t\tdividing by gcd, to simplify product\n\t\t\tdivision by their gcd saves from the overflow\"\"\"\n\t\t\tp //= m\n\t\t\tk //= m\n\t\t\tn -= 1\n\t\t\tr -= 1\n\treturn p\nt=1;# t=int(input())\nfor _ in range(t):\n\tk=int(input())\n\ttotal=int(input())\n\tres=1\n\tfor i in range(1,k):\n\t\tc=int(input())\n\t\tres = (res*NcR(total + c-1, c-1))%mod\n\t\ttotal+=c\n\tprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (long long)1e9 + 7;\nconst long long MAXN = 3000;\nlong long calc[MAXN][MAXN];\nlong long C(long long k, long long n) {\n  if (calc[k][n] != -1) {\n    return calc[k][n];\n  }\n  if (k == 0) {\n    calc[k][n] = 1;\n    return 1;\n  }\n  if (k == n) {\n    calc[k][n] = 1;\n    return 1;\n  }\n  calc[k][n] = (C(k - 1, n - 1) + C(k, n - 1)) % MOD;\n  return calc[k][n];\n}\nint main() {\n  for (long long i = 0; i < MAXN; ++i) {\n    for (long long j = 0; j < MAXN; ++j) {\n      calc[i][j] = -1;\n    }\n  }\n  long long k;\n  cin >> k;\n  long long ans = 1;\n  long long csum = 0;\n  for (long long i = 0; i < k; ++i) {\n    long long num;\n    cin >> num;\n    ans = ans * C(num - 1, num - 1 + csum);\n    ans %= MOD;\n    csum += num;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class C { \n\n    static long MOD = 1000000007;\n\n    public static void main(String [] args) throws IOException { \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int k = Integer.parseInt(br.readLine());\n        int n = 0;\n        int [] colors = new int[k];\n        for(int i=0; i<k; i++) { \n            colors[i] = Integer.parseInt(br.readLine());\n            n+= colors[i];\n        }\n\n        long [][] binomial = new long[n+1][n+1];\n        \n        binomial[0][0] = 1;\n        for(int i=1; i<=n; i++) {\n            for(int j=0; j<=i; ++j) {\n                \n                if(j==0) {\n                    binomial[i][j] = 1;\n                    continue;\n                }\n                if(j == i) {\n                    binomial[i][j] = 1;\n                    continue;\n                }\n                binomial[i][j] = (binomial[i-1][j-1] + binomial[i-1][j])%MOD;\n            }\n        }\n\n        long totalWays = 1;\n\n        int sumTaken = 0;\n        for(int i=k-1; i>=0; i--) { \n            \n            int upper  = n - 1 - sumTaken;\n            int lower = colors[i] - 1;\n            \n            //System.out.println(\"upper: \" + upper + \" lower: \" + lower);\n            \n            long toAdd = binomial[upper][lower];\n            //System.out.println(toAdd);\n            totalWays = (totalWays*toAdd)%MOD;\n            sumTaken += colors[i];\n        }\n\n        System.out.println(totalWays);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by ankeet on 6/21/16.\n */\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class C554 {\n\n    public static BufferedReader read = null;\n    public static PrintWriter out = null;\n    public static StringTokenizer token = null;\n\n    public static long powmod(long a, long b, long m)\n    {\n        if(b == 0) return 1;\n        if(b == 1) return a %m;\n        long c = powmod(a, b/2, m);\n        c = c * c % m;\n        if(b%2 == 1) c = c * a %m;\n        return c % m;\n    }\n    public static void solve()\n    {\n        long mod = 1000000000+7;\n        int k = nint();\n        int[] c = narr(k);\n        int n = 2000;\n        long[] f = new long[n];\n        f[0] = 1;\n        long[] finv = new long[n];\n        finv[0] = 1;\n        for(int i=1; i<n; i++)\n        {\n            f[i] = f[i-1] * i % mod;\n            finv[i] = powmod(f[i], mod-2, mod);\n        }\n\n        long w = 1;\n        int sofar = c[0];\n        for(int i=1; i<k; i++)\n        {\n            int tup = sofar+1;\n            int tupsum = c[i]-1;\n            w = w * f[tupsum+tup-1] % mod;\n            w = w * finv[tup-1] % mod;\n            w = w * finv[tupsum] % mod;\n            sofar+=c[i];\n\n        }\n        out.println(w % mod);\n    }\n\n    public static void main(String[] args)\n    {\n        read = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n        out.close();\n\n    }\n\n    // i/o functions\n    public static String next() // returns the next string\n    {\n        while(token == null || !token.hasMoreTokens())\n        {\n            try {\n                token = new StringTokenizer(read.readLine());\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        return token.nextToken();\n    }\n\n    public static int nint()\n    {\n        return Integer.parseInt(next());\n    }\n    public static long nlong()\n    {\n        return Long.parseLong(next());\n    }\n    public static double ndouble()\n    {\n        return Double.parseDouble(next());\n    }\n    public static int[] narr(int n)\n    {\n        int[] a = new int[n];\n        for(int i=0; i<n; i++) a[i] = nint();\n        return a;\n    }\n\n    public static long[] nal(int n)\n    {\n        long[] a = new long[n];\n        for(int i=0; i<n; i++) a[i] = nlong();\n        return a;\n    }\n\n\n}\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long sum, ans, n, i, j, k, l, a[1005], d[1005][1005], m = 1000000007;\nint main() {\n  cin >> k;\n  for (i = 1; i <= k; i++) cin >> a[i], n = n + a[i];\n  for (i = 0; i <= n; i++) {\n    for (j = 0; j <= i; j++) {\n      if (i == j || j == 0)\n        d[i][j] = 1;\n      else\n        d[i][j] = (d[i - 1][j - 1] + d[i - 1][j]) % m;\n    }\n  }\n  for (i = 1, ans = 1; i <= k; i++) {\n    ans = (ans * d[sum + a[i] - 1][sum]) % m;\n    sum += a[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Vector;\n\n\npublic class Solve {\n\tstatic int mod= 1000000007;\n\tstatic long [][]ncr ;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t PrintWriter out = new PrintWriter(System.out);\n\t\t Scanner sc = new Scanner(System.in);\n\t\t int k =sc.nextInt();\n\t\t int presum[]=new int[k+2];\n\t\t int colors[]=new int[k+1];\n\t\t for(int i=1;i<=k;i++) {\n\t\t\t colors[i]=sc.nextInt();\n\t\t\t presum[i]+=presum[i-1]+colors[i];\n\t\t }\n\t\t long dp[]=new long[k+3];\n\t\t dp[1]=1;\n\t\t ncrbuild(1000+2,1000+2);\n\t\t //System.out.println(ncr[5][2]);\n\t\t for(int i=2;i<=k;i++) {\n\t\t\t dp[i]=(ncr[presum[i]-1][colors[i]-1]%mod*dp[i-1]%mod)%mod;\n\t\t\t \n\t\t }\n\t\t System.out.println(dp[k]);\n\t\t\n\t\t \n\t\t\n\t\t\n\t\t\n\t}\n\n\tprivate static void ncrbuild(int n, int k) {\n\t\tncr= new long[n+4][k+4];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=0; j<=i;j++) {\n\t\t\t\tif(j==0 ||i==j )\n\t\t\t\t\tncr[i][j]=1L;\n\t\t\t\telse {\n\t\t\t\t\tncr[i][j]=(ncr[i-1][j-1]%mod+ncr[i-1][j]%mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\n\n\t\n\t\n\n\t\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\t\n\t\n\n\nclass point implements Comparable{\n\tint x ,y,z;\n\tpoint(int x,int y,int z)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t\tthis.z=z;\n\t}\n\t@Override\n\tpublic int compareTo(Object arg0) {\n\t\t\n\t\tpoint u =((point)arg0);\n\t\t\n\t\treturn -this.z+u.z;\n\t}\n}\n \t\n\n\n\t    \n\t    \n\t    \n\n\n\nclass Scanner {\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s) {\n\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t}\n\n\tpublic Scanner(String f) throws FileNotFoundException {\n\t\tbr = new BufferedReader(new FileReader(f));\n\t}\n\n\tpublic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic String nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic boolean ready() throws IOException {\n\t\treturn br.ready();\n\t}\n\n\tpublic int[] nextIntArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic int[] nextIntArray1(int n) throws IOException {\n\t\tint[] a = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic int[] shuffle(int[] a, int n) {\n\t\tint[] b = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = a[i];\n\t\tRandom r = new Random();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i + r.nextInt(n - i);\n\t\t\tint t = b[i];\n\t\t\tb[i] = b[j];\n\t\t\tb[j] = t;\n\t\t}\n\t\treturn b;\n\t}\n\n\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\t\tint[] a = nextIntArray(n);\n\t\ta = shuffle(a, n);\n\t\tArrays.sort(a);\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray1(int n) throws IOException {\n\t\tlong[] a = new long[n + 1];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\t\tlong[] a = nextLongArray(n);\n\t\tRandom r = new Random();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i + r.nextInt(n - i);\n\t\t\tlong t = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = t;\n\t\t}\n\t\tArrays.sort(a);\n\t\treturn a;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1e9 + 7;\nlong long f[10000];\nlong long pri[10000];\nlong long power(long long n, long long p) {\n  if (p == 0) return 1;\n  long long ans = 1;\n  ans *= power(n, p / 2);\n  ans = ans % MOD;\n  ans *= ans;\n  ans = ans % MOD;\n  if (p & 1) ans *= n;\n  ans = ans % MOD;\n  return ans % MOD;\n}\nvoid fact() {\n  f[0] = 1;\n  for (int i = 1; i < 1998; i++) {\n    f[i] = i * f[i - 1];\n    f[i] = f[i] % MOD;\n  }\n}\nlong long inv(long long a) {\n  a = a % MOD;\n  return power(a, MOD - 2) % MOD;\n}\nlong long ncr(long long n, long long r) {\n  return (f[n] * inv(f[r] * f[n - r])) % MOD;\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<int> v;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    v.push_back(a);\n    if (i == 0)\n      pri[i] = a;\n    else\n      pri[i] = a + pri[i - 1];\n  }\n  fact();\n  long long ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans *= ncr(pri[i] - 1, v[i] - 1);\n    ans = ans % MOD;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "def C(n, k):\n\treturn (math.factorial(n) // (math.factorial(k) * math.factorial(n - k)))\n\n\nimport sys\nimport math\nsys.setrecursionlimit(5000)\nn = int(input())\narr = [0]\nfor i in range(n):\n\tarr.append(int(input()))\nsum = [0] * (n + 1)\nans = 1;\nfor i in range(1, n + 1):\n\tsum[i] = sum[i - 1] + arr[i - 1]\nfor i in range (1, n + 1):\n\tif(arr[i] > 1):\n\t\tans *= C(sum[i] + arr[i] - 1, sum[i])\nprint(ans % 1000000007)"
        },
        {
            "language": 1,
            "solution": "n=int(raw_input())\nmod=1000000007\nc=[int(raw_input()) for i in xrange(n)]\nsum=[1 for i in xrange(1003)]\ndp=[[0 for i in xrange(1003)] for j in xrange(1003) ]\nfor i in xrange(1,1003):\n\tfor j in xrange(0,1003):\n\t\tdp[i][j]=sum[j]\n\tfor j in xrange(1,1003):\n\t\tsum[j]=(sum[j-1]+dp[i][j])%mod\nl=c[0]\nans=1\nfor i in xrange(1,n):\n\tans*=dp[l+1][c[i]-1]\n\tans%=mod\n\tl+=c[i]\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "//package round309;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(3005, mod);\n\t\tint num = a[0];\n\t\tlong ret = 1;\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tret = ret * C(num+a[i]-1, a[i]-1, mod, fif) % mod;\n\t\t\tnum += a[i];\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n\n# Universidade Federal de Campina Grande\n# Aluno: Diego Adolfo Silva de Ara\u00fajo\n# Matricula: 113210090\n# Disciplina: Algoritmos Avan\u00e7ados\n\n# Codeforces\n# Problem: 553A - A. Kyoya and Colored Balls\n# Time limit per test: 2 second\n# Memory limit per test: 256 megabytes\n# Input: standard input\n# Output: standard output\n\nMOD = 1000000007\n\ndef get_colors_comb(n=2000):\n    c = [[0] * n for l in xrange(n)]\n    for i in xrange(n):\n        c[i][0] = c[i][i] = 1\n        for j in xrange(i):\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD\n\n    return c\n\nk = int(raw_input())\ncolors = get_colors_comb()\n\ntemp = 0\nanswer = 1\nfor i in xrange(1, k + 1):\n    ball = int(raw_input())\n    a = temp + 1\n    b = ball - 1\n\n    temp += ball\n    answer = answer * colors[a + b - 1][a - 1] % MOD\n\nprint answer"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nlong long int dx[] = {0, 1, 0, -1, -1, 1, -1, 1};\nlong long int dy[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconst long long int MAXN = 1e4 + 5;\nconst long long int N = 1e5 + 5;\nlong long int n, m;\ntemplate <class A>\nostream& operator<<(ostream& out, const vector<A>& v) {\n  out << \"[\";\n  for (long long int i = 0; i < v.size(); i++) {\n    if (i) out << \", \";\n    out << v[i];\n  }\n  return out << \"]\";\n}\nlong long int binpow(long long int n, long long int p) {\n  long long int res = 1;\n  while (p > 0) {\n    if (p & 1) res = res * n;\n    n = n * n;\n    p >>= 1;\n  }\n  return res;\n}\nlong long int power(long long int n, long long int p) {\n  long long int res = 1;\n  n %= 1000000007;\n  while (p > 0) {\n    if (p & 1) res = (res * n) % 1000000007;\n    n = (n * n) % 1000000007;\n    p >>= 1;\n  }\n  return res;\n}\nlong long int modInverse(long long int n, long long int p) {\n  return power(n, p - 2);\n}\nlong long int fact[MAXN], inv[MAXN], invfact[MAXN];\nvoid initFactorials() {\n  fact[0] = 1;\n  for (long long int i = 1; i < MAXN; i++) {\n    fact[i] = (fact[i - 1] * i * 1LL) % 1000000007;\n  }\n  inv[1] = 1;\n  for (long long int i = 2; i < MAXN; i++)\n    inv[i] = inv[1000000007 % i] * (1000000007 - 1000000007 / i) % 1000000007;\n  invfact[0] = 1;\n  for (long long int i = 1; i < MAXN; i++)\n    invfact[i] = (invfact[i - 1] * inv[i]) % 1000000007;\n}\nlong long int nCrMod(long long int n, long long int r) {\n  if (n < r) return 0;\n  if (r == 0) return 1;\n  long long int num = fact[n], den = (fact[r] * fact[n - r]) % 1000000007;\n  long long int inv = modInverse(den, 1000000007);\n  return (num * inv) % 1000000007;\n}\nvoid solve() {\n  long long int x, y, z, k;\n  initFactorials();\n  cin >> k;\n  long long int a[k];\n  n = 0;\n  for (long long int i = 0; i < k; i++) cin >> a[i], n += a[i];\n  long long int res = 1;\n  for (long long int i = k - 1; i >= 0; i--) {\n    x = a[i];\n    y = nCrMod(n - 1, x - 1);\n    n -= x;\n    res *= y;\n    res %= 1000000007;\n  }\n  cout << res << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long degree(long long a, long long k, long long p) {\n  long long res = 1;\n  long long cur = a;\n  while (k) {\n    if (k % 2) {\n      res = (res * cur) % p;\n    }\n    k /= 2;\n    cur = (cur * cur) % p;\n  }\n  return res;\n}\nlong long get_degree(long long n, long long p) {\n  long long int degree_num = 0;\n  long long u = p;\n  long long temp = n;\n  while (u <= temp) {\n    degree_num += temp / u;\n    u *= p;\n  }\n  return degree_num;\n}\nlong long combinations(long long int n, long long int k, long long p) {\n  long long int num_degree = get_degree(n, p) - get_degree(n - k, p);\n  long long int den_degree = get_degree(k, p);\n  if (num_degree > den_degree) {\n    return 0;\n  }\n  long long res = 1;\n  for (long long i = n; i > n - k; --i) {\n    long long ti = i;\n    while (ti % p == 0) {\n      ti /= p;\n    }\n    res = (res * ti) % p;\n  }\n  for (long long i = 1; i <= k; ++i) {\n    long long ti = i;\n    while (ti % p == 0) {\n      ti /= p;\n    }\n    res = (res * degree(ti, p - 2, p)) % p;\n  }\n  return res;\n}\nlong long int dp[1001] = {0};\nlong long int c[1001] = {0};\nlong long int c1[1001] = {0};\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  long long int k;\n  cin >> k;\n  for (long long int i = 0; i < k; i++) cin >> c[i];\n  dp[0] = 1;\n  c1[0] = c[0];\n  for (long long int i = 1; i < k; i++) c1[i] = c[i] + c1[i - 1];\n  for (long long int i = 1; i < k; i++) {\n    dp[i] = dp[i - 1];\n    long long int obj = c[i] - 1;\n    long long int pla = c1[i - 1] + 1;\n    long long int comb;\n    if (pla > 1)\n      comb = combinations(obj + pla - 1, pla - 1, 1000000007ll);\n    else\n      comb = 1;\n    dp[i] = (dp[i - 1] * comb) % 1000000007ll;\n  }\n  cout << dp[k - 1];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class c {\n\n\tfinal public static long MOD = 1000000007L;\n\tpublic static long[] memo;\n\tpublic static int[] freq;\n\tpublic static int[] cumfreq;\n\tpublic static long[][] combo;\n\t\n\tpublic static void main(String[] args) {\n\t\n\t\tcombo = new long[1001][1001];\n\t\tfor (int i=0; i<1001; i++) {\n\t\t\tcombo[i][0] = 1L;\n\t\t\tcombo[i][i] = 1L;\n\t\t}\n\t\tfor (int i=2; i<1001; i++)\n\t\t\tfor (int j=1; j<i; j++)\n\t\t\t\tcombo[i][j] = (combo[i-1][j-1] + combo[i-1][j])%MOD;\n\t\t\n\t\tScanner stdin = new Scanner(System.in);\n\t\tint k = stdin.nextInt();\n\t\tfreq = new int[k];\n\t\tfor (int i=0; i<k; i++)\n\t\t\tfreq[i] = stdin.nextInt();\n\t\t\n\t\tcumfreq = new int[k];\n\t\tcumfreq[0] = freq[0];\n\t\tfor (int i=1; i<k; i++)\n\t\t\tcumfreq[i] = cumfreq[i-1] + freq[i];\n\t\t\n\t\tmemo = new long[k];\n\t\tArrays.fill(memo, -1);\n\t\tSystem.out.println(go(k-1));\n\t}\n\t\n\t\n\tpublic static long go(int k) {\n\t\t\n\t\tif (k == 0) return 1;\n\t\tif (memo[k] != -1) return memo[k];\n\t\t\n\t\tlong res = 0;\n\t\tfor (int last=1; last<=freq[k]; last++) {\n\t\t\t\n\t\t\tint numLast = freq[k] - last;\n\t\t\tint numBefore = cumfreq[k-1];\n\t\t\t\n\t\t\tres = (res + go(k-1)*combo[numLast+numBefore-1][numLast])%MOD;\n\t\t}\n\t\t\n\t\treturn memo[k] = res;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nfrom bisect import bisect_right\nk=int(input())\nans=1\ntotal=0\nMOD=1000000007\nfor i in range(k):\n\tz=int(input())\n\tans=(ans*factorial(total+z-1)//factorial(total)//factorial(z-1))%MOD\n\ttotal+=z\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.math.BigInteger;\npublic class Main{\n\n\tprivate static Scanner entrada = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\n\t\tint k = entrada.nextInt();\n\n\t\tint[] pelotas = new int[k];\n\t\tfor(int i = 0; i < k; i++)\n\t\t\tpelotas[i] = entrada.nextInt();\n\n\t\tint sumaAcumulada = 0;\n\t\tint[] suma = new int[k];\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tsumaAcumulada += pelotas[i];\n\t\t\tsuma[i] =sumaAcumulada;\n\t\t}\n\n\t\tBigInteger resultado = BigInteger.valueOf(1);\n\t\tfor(int i = 1; i < k; i++)\n\t\t\tresultado = resultado.multiply(combinacion(suma[i]-1, pelotas[i]-1));\n\n\t\tresultado = resultado.mod(BigInteger.valueOf(1000000007));\n\n\t\tSystem.out.println(resultado);\n\n\t}\n\n\tpublic static BigInteger combinacion(int n, int r){\n\n\t\tBigInteger nF = BigInteger.valueOf(1);\n\t\tfor (int i = n; i > 0; i--)\n        \tnF = nF.multiply(BigInteger.valueOf(i));\n\n\t\tBigInteger nrF = BigInteger.valueOf(1);\n\t\tfor (int i = (n-r); i > 0; i--)\n        \tnrF = nrF.multiply(BigInteger.valueOf(i));\n\n        BigInteger rF = BigInteger.valueOf(1);\n\t\tfor (int i = r; i > 0; i--)\n        \trF = rF.multiply(BigInteger.valueOf(i));\n\n        nrF = nrF.multiply(rF);\n        nF = nF.divide(nrF);\n\n        return nF;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "# your code goes here\nimport sys\nn=int(raw_input())\nc=[0]*n\nfor i in range(0,n):\n    c[i]=int(raw_input())\n\ncomb=[]\n\nfor i in range(0,1001):\n    a=[]\n    for j in range(0,1001):\n        a.append(0)\n    comb.append(a)\n        \nfor i in range(0,1001):\n    comb[i][0]=1\n    comb[i][i]=1\n\nval=0\nfor i in range(2,1001):\n    for j in range(1,i):\n        comb[i][j]=(comb[i-1][j]+comb[i-1][j-1])%1000000007\n        comb[i][i-j]=comb[i][j]\n\ntotal=[]\nfor i in range(0,n):\n    total.append(0)\ntotal[0]=c[0]\nres=1\n\nfor i in range(1,n):\n    total[i]=total[i-1]+c[i]\n    res*=comb[total[i]-1][c[i]-1]\n    res%=1000000007\nprint res\n\n        \n        \n        \n\n        \n    \n    \n\n\n    \n    "
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        Task Solver = new Task();\n        Solver.exe(in, out);\n        out.close();\n    }\n}\n\nclass Task { \n    \n    public static long x,y,n;\n    public static long modulo = 1000000007;\n    \n    static void euclideanExtended(long a,long b){\n        if (b==0) {\n            x = 1; \n            y = 0; \n            return ;\n        }\n        euclideanExtended(b,a%b);\n        long aux = x;\n        x = y; \n        y = aux - (a/b)*y;\n    }\n    \n    static long ModInv(long n){\n        euclideanExtended(n,modulo);\n        return (x<=0) ?  x+=modulo : x;\n    }\n    \n    static long fact(long n){\n     long f = 1;\n     for (int i=2;i<=n;++i) {\n         f*=i;\n         if (f >= modulo)  f%=modulo;\n        }\n    return f;\n    }\n    \n    \n    static long comb(long n, long k){\n      long t1 = fact(n); \n      long t2 = ModInv(fact(n-k));\n      long t3 = ModInv(fact(k));\n      t1 = (t1 * t2) % modulo;\n      t1 = (t1 * t3) % modulo; \n      return t1;\n    }\n    \n    public void exe(Scanner in, PrintWriter out) {\n      int n = in.nextInt(), poz = 0 ;\n      long sol = 1;\n      \n      int[] c = new int[n];\n      for (int i=0;i<n;++i) {\n          c[i] = in.nextInt();\n          poz+= c[i];\n       }\n      for (int i=n-1;i>=0;--i){\n          sol = (sol * comb(poz-1,c[i]-1)) % modulo;\n          poz -= c[i];\n      }\n      out.println(sol);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long scan_d() {\n  char t = getchar();\n  long long you = 0;\n  while (t > '9' || t < '0') t = getchar();\n  while (t <= '9' && t >= '0') {\n    you *= 10;\n    you += t - '0';\n    t = getchar();\n  }\n  return you;\n}\nlong long dp[1050][1050];\nlong long op[1001];\nint main() {\n  for (int i = 0; i <= 1010; i++) dp[1][i] = 1;\n  for (int i = 2; i <= 1010; i++)\n    for (int o = i - 1; o <= 1010; o++) {\n      dp[i][o] = dp[i - 1][o - 1] + dp[i][o - 1];\n      dp[i][o] %= 1000000007;\n    }\n  long long y;\n  y = scan_d();\n  long long sum = 0;\n  for (int i = 1; i <= y; i++) {\n    op[i] = scan_d();\n  }\n  long long ans = 1;\n  for (int i = 1; i <= y; i++) {\n    sum += op[i];\n    ans *= dp[op[i]][sum - 1];\n    ans %= 1000000007;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "        import java.util.*;\n        import java.io.*;\n        import java.math.*;\n        import java.util.LinkedList;\n         \n            public  class Sample implements Runnable\n            {     \n                  static int maxN=1010;\n                  static int[] a;\n                  static long[][] comb;\n\n\n                  public static void solve()\n                  { \n                    \n                    int n=i();\n                    a=new int[n];\n                    for(int i=0;i<n;i++)a[i]=i();\n                    comb=new long[maxN][maxN];\n                    comb[0][0]=1;\n                    for(int i=1;i<maxN;i++)\n                    {\n                      comb[i][0]=1;\n                      for(int j=1;j<=i;j++)\n                      {\n                        comb[i][j]=(comb[i-1][j]+comb[i-1][j-1])%mod;\n                      }\n                    }\n                    long res=1;\n                    int total=0;\n                    for(int i=0;i<n;i++)\n                    {\n                      res=(res*comb[total+a[i]-1][a[i]-1])%mod;\n                      total+=a[i];\n                    }\n                    out.println(res);\n\n\n                  }\n                  static void khojo(long[] a,HashMap hs,int i,int n,long res)\n                  {\n                    if(i>=n)\n                    {\n                      if(hs.containsKey(res))\n                      {\n                        hs.put(res,(long)hs.get(res)+1L);\n                      }\n                      else\n                      {\n                        hs.put(res,1L);\n                      }\n                    }\n                    else\n                    {\n                      khojo(a,hs,i+1,n,(res^a[i]));\n                      khojo(a,hs,i+1,n,res);\n                  }\n                  }\n                   \n                  public void run()\n                  {   \n                      solve();\n                      out.close();\n                  }\n         \n                  public static void main(String[] args) throws IOException\n                  { \n                        new Thread(null, new Sample(), \"whatever\", 1<<26).start();\n                  }\n                 static class Pair implements Comparable<Pair>\n                 {\n                    long a;\n                    int b;\n                    Pair(){}\n                    Pair(long a,int b)\n                    {\n                               this.a=a;\n                               this.b=b;\n                    }\n           \n                    public int compareTo(Pair x)\n                   {\n                        return Long.compare(x.a,this.a);\n                   }\n                }\n                \n               \n                 \n            ////////////////////////////////////////////////////// Merge Sort ////////////////////////////////////////////////////////////////////////\n             \n           static class Merge \n           {\n         \n                public static void sort(long inputArr[]) \n                {\n                    int length = inputArr.length;\n                    doMergeSort(inputArr,0, length - 1);\n                }\n         \n                private static void doMergeSort(long[] arr,int lowerIndex, int higherIndex) \n                {        \n                    if (lowerIndex < higherIndex) {\n                        int middle = lowerIndex + (higherIndex - lowerIndex) / 2;\n                        doMergeSort(arr,lowerIndex, middle);\n                        doMergeSort(arr,middle + 1, higherIndex);\n                        mergeParts(arr,lowerIndex, middle, higherIndex);\n                    }\n                }\n         \n                private static void mergeParts(long[]array,int lowerIndex, int middle, int higherIndex) \n                {\n                    long[] temp=new long[higherIndex-lowerIndex+1];\n                    for (int i = lowerIndex; i <= higherIndex; i++) \n                    {\n                        temp[i-lowerIndex] = array[i];\n                    }\n                    int i = lowerIndex;\n                    int j = middle + 1;\n                    int k = lowerIndex;\n                    while (i <= middle && j <= higherIndex) \n                    {\n                        if (temp[i-lowerIndex] < temp[j-lowerIndex]) \n                        {\n                            array[k] = temp[i-lowerIndex];\n                            i++;\n                        } else {\n                            array[k] = temp[j-lowerIndex];\n                            j++;\n                        }\n                        k++;\n                    }\n                    while (i <= middle) \n                    {\n                        array[k] = temp[i-lowerIndex];\n                        k++;\n                        i++;\n                    }\n                    while(j<=higherIndex)\n                    {\n                        array[k]=temp[j-lowerIndex];\n                        k++;\n                        j++;\n                    }\n                }\n         \n            }\n                \n              \n            /////////////////////////////////////////////////////////// Methods ////////////////////////////////////////////////////////////////////////\n         \n         \n             static boolean isPal(String s)\n             {\n                for(int i=0, j=s.length()-1;i<=j;i++,j--)\n                {\n                        if(s.charAt(i)!=s.charAt(j)) return false;\n                }\n                return true;\n             }\n             static String rev(String s)\n             {\n                        StringBuilder sb=new StringBuilder(s);\n                        sb.reverse();\n                        return sb.toString();\n             }\n             static int gcd(int a,int b){return (a==0)?b:gcd(b%a,a);}\n             static long gcdExtended(long a,long b,long[] x)\n             {\n         \n                if(a==0){\n                    x[0]=0;\n                    x[1]=1;\n                    return b;\n                }\n                long[] y=new long[2];\n                long gcd=gcdExtended(b%a, a, y);\n         \n                x[0]=y[1]-(b/a)*y[0];\n                x[1]=y[0];\n         \n                return gcd;\n            }\n         \n             boolean findSum(int set[], int n, long sum)\n            {\n              if (sum == 0)\n                 return true;\n              if (n == 0 && sum != 0)\n                 return false;\n              if (set[n-1] > sum)\n                 return findSum(set, n-1, sum);\n              return findSum(set, n-1, sum) ||findSum(set, n-1, sum-set[n-1]);\n            }\n           \n              public static long modPow(long base, long exp, long mod)\n             {\n                base = base % mod;\n                long result = 1;\n                while (exp > 0)\n               {\n                    if (exp % 2 == 1) \n                    {\n                        result = (result * base) % mod;\n                    }\n                    base = (base * base) % mod;\n                    exp = exp >> 1;\n               }\n                return result;\n            }\n         \n            static long[] fac;\n            static long[] inv;\n            static long mod=(long)1e9+7;\n            public static void cal() \n            {\n                fac = new long[1000005];\n                inv = new long[1000005];\n                fac[0] = 1;\n                inv[0] = 1;\n                for (int i = 1; i <= 1000000; i++)\n                {\n                    fac[i] = (fac[i - 1] * i) % mod;\n                    inv[i] = (inv[i - 1] * modPow(i, mod - 2, mod)) % mod;\n                }\n            }\n         \n            public static long ncr(int n, int r) \n            {\n                return (((fac[n] * inv[r]) % mod) * inv[n - r]) % mod;\n            }\n         \n         \n        ////////////////////////////////////////// Input Reader ////////////////////////////////////////////////////////////////////////////////////////////////////\n             \n            static InputReader sc = new InputReader(System.in);\n            static PrintWriter out= new PrintWriter(System.out);   \n            \n            static class InputReader {\n         \n                  private final InputStream stream;\n                  private final byte[] buf = new byte[8192];\n                  private int curChar, snumChars;\n                  private SpaceCharFilter filter;\n         \n                  public InputReader(InputStream stream) {\n                          this.stream = stream;\n                  }\n         \n                  public int snext()\n                 {\n                          if (snumChars == -1)\n                                  throw new InputMismatchException();\n                          if (curChar >= snumChars) {\n                                  curChar = 0;\n                                  try {\n                                          snumChars = stream.read(buf);\n                                  } catch (IOException e) {\n                                          throw new InputMismatchException();\n                                  }\n                                  if (snumChars <= 0)\n                                          return -1;\n                          }\n                          return buf[curChar++];\n                  }\n         \n                  public int nextInt()\n                 {\n                          int c = snext();\n                          while (isSpaceChar(c)) \n                          {\n                                  c = snext();\n                          }\n                          int sgn = 1;\n                          if (c == '-')\n                          {\n                                  sgn = -1;\n                                  c = snext();\n                          }\n                          int res = 0;\n                          do {\n                                  if (c < '0' || c > '9')\n                                          throw new InputMismatchException();\n                                  res *= 10;\n                                  res += c - '0';\n                                  c = snext();\n                          } while (!isSpaceChar(c));\n                          return res * sgn;\n                  }\n         \n                  public long nextLong() \n                  {\n                          int c = snext();\n                          while (isSpaceChar(c)) \n                          {\n                                  c = snext();\n                          }\n                          int sgn = 1;\n                          if (c == '-') \n                          {\n                                  sgn = -1;\n                                  c = snext();\n                          }\n                          long res = 0;\n                          do {\n                                  if (c < '0' || c > '9')\n                                          throw new InputMismatchException();\n                                  res *= 10;\n                                  res += c - '0';\n                                  c = snext();\n                          } while (!isSpaceChar(c));\n                          return res * sgn;\n                  }\n         \n                  public int[] nextIntArray(int n)\n                  {\n                          int a[] = new int[n];\n                          for (int i = 0; i < n; i++) \n                          {\n                                  a[i] = nextInt();\n                          }\n                          return a;\n                  }\n         \n                  public long[] nextLongArray(int n)\n                  {\n                          long a[] = new long[n];\n                          for (int i = 0; i < n; i++) \n                          {\n                                  a[i] = nextLong();\n                          }\n                          return a;\n                  }\n         \n                  \n                  public String nextLine()\n                 {\n                          int c = snext();\n                          while (isSpaceChar(c))\n                                  c = snext();\n                          StringBuilder res = new StringBuilder();\n                          do {\n                                  res.appendCodePoint(c);\n                                  c = snext();\n                          } while (!isEndOfLine(c));\n                          return res.toString();\n                  }\n         \n                  public boolean isSpaceChar(int c) \n                  {\n                          if (filter != null)\n                                  return filter.isSpaceChar(c);\n                          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n                  }\n         \n                  private boolean isEndOfLine(int c) \n                  {\n                          return c == '\\n' || c == '\\r' || c == -1;\n                  }\n         \n                  public interface SpaceCharFilter \n                  {\n                          public boolean isSpaceChar(int ch);\n                  }\n         \n            }\n         \n            static int i()\n            {\n                return sc.nextInt();\n            }\n            static long l(){\n                return sc.nextLong();\n            }\n            static int[] iarr(int n)\n            {\n                return sc.nextIntArray(n);\n            }\n            static long[] larr(int n)\n            {\n                return sc.nextLongArray(n);\n            }\n            static String s(){\n                return sc.nextLine();\n            }\n          \n         \n         }  "
        },
        {
            "language": 1,
            "solution": "used = {}\nimport math\ndef solve(k, balls, on = 0):\n\tif tuple(balls) in used:\n\t\treturn used[tuple(balls)]\n\tif on == k:\n\t\treturn 1\n\ttotal = 0\n\tfor i in range(on, k):\n\t\tif (balls[i] == 1 and i == on):\n\t\t\ttemp = list(balls)\n\t\t\ttemp[i] -= 1\n\t\t\ttotal += solve(k, temp, on + 1)\n\t\telif balls[i] != 1:\n\t\t\ttemp = list(balls)\n\t\t\ttemp[i] -= 1\n\t\t\ttotal += solve(k, temp, on)\n\tused[tuple(balls)] = total\n\treturn total\n\ndef solveBetter(k, balls):\n\ttotal = 1\n\tcount = balls[0]\n\tfor i in range(1, k):\n\t\tcount += balls[i]\n\t\ttotal *= math.factorial(count - 1) / math.factorial(balls[i] - 1) / math.factorial(count - balls[i])\n\treturn total % (10**9 + 7)\n\nk1 = int(raw_input())\nballs1 = [int(raw_input()) for i in range(k1)]\nprint solveBetter(k1, balls1)\n"
        },
        {
            "language": 1,
            "solution": "from __future__ import print_function\nimport sys\n\nit = iter(sys.stdin.read().splitlines())\ncolors = int(next(it))\n\npossibilities = [[0 for i in range(1000)] for j in range(1000)]\n\npossibilities[0][0] = 1\nfor i in xrange(1, 1000):\n    possibilities[i][0] = 1\n    for j in xrange(i+1):\n        possibilities[i][j] = (possibilities[i-1][j] + possibilities[i-1][j-1]) % 1000000007\n\nans = 1\ntotal = 0\n\nfor i in xrange(colors):\n    amount = int(next(it))\n    ans = (ans *possibilities[total + amount - 1][amount-1]) % 1000000007\n    total += amount\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "t = int(input())\nc = 1\ns = int(input())\nfor _ in range(t-1):\n    n = int(input())\n    s += n\n\n    k = 1\n    for i in range(1, n):\n        k = k*(s-i)//i\n    c = (c*k) % (10**9+7)\nprint(c)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[1010][1010];\nint main(int argc, char const *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int n, k, x;\n  cin >> k;\n  memset(dp, 0, sizeof(dp));\n  long long int ans = 1;\n  n = 0;\n  for (int(i) = (1); (i) < (1000 + 1); ++(i)) {\n    dp[i][i] = dp[i][0] = 1;\n    for (int(j) = (1); (j) < (i); ++(j)) {\n      dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 1000000007;\n    }\n  }\n  cin >> n;\n  for (int(i) = (1); (i) < (k); ++(i)) {\n    cin >> x;\n    ans = (ans * dp[n + x - 1][x - 1]) % 1000000007;\n    n += x;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k;\nlong long dp[1001][1001];\nlong long mod(long long a) { return a % 1000000007; }\nlong long sum(long long a, long long b) { return mod(mod(a) + mod(b)); }\nlong long mul(long long a, long long b) { return mod(mod(a) * mod(b)); }\nvoid initdp() {\n  for (int i = 0; i < 1001; ++i) dp[i][0] = dp[i][i] = 1;\n  for (int i = 1; i < 1001; ++i) {\n    for (int j = 1; j < 1001; ++j) {\n      dp[i][j] = sum(dp[i - 1][j - 1], dp[i - 1][j]);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  initdp();\n  while (cin >> k) {\n    vector<long long> v(k);\n    long long ans = 1, aux = 0;\n    for (int i = 0; i < k; ++i) cin >> v[i];\n    aux = v[0];\n    for (int i = 1; i < k; ++i) {\n      aux += v[i];\n      ans = mul(ans, dp[aux - 1][v[i] - 1]);\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[1005][1005];\nlong long int fact[100005], ifact[100005];\nlong long int power(long long int a, long long int b) {\n  long long int ans = 1, temp = a;\n  while (b > 0) {\n    if (b % 2 == 0) {\n      temp = (temp * temp) % 1000000007;\n      b /= 2;\n    } else {\n      ans = (ans * temp) % 1000000007;\n      b--;\n    }\n  }\n  return ans % 1000000007;\n}\nvoid precompute() {\n  long long int i = 1;\n  fact[0] = fact[1] = 1;\n  for (i = 2; i <= 100000; i++)\n    fact[i] = (long long int)(i * fact[i - 1]) % 1000000007;\n  ifact[100000] = power(fact[100000], 1000000007 - 2);\n  for (i = 99999; i >= 0; i--)\n    ifact[i] =\n        (long long int)(ifact[i + 1] * (i + (long long int)1)) % 1000000007;\n}\nlong long int cal(long long int n, long long int r) {\n  long long int ans;\n  if (n < r) return 0;\n  ans = (fact[n] % 1000000007 * ifact[r] % 1000000007) % 1000000007;\n  ans = (ans * ifact[n - r]) % 1000000007;\n  return ans % 1000000007;\n}\nint main() {\n  long long int t, i, j, n, m, ans, sum, col[1005], pos, ball, k, cnt;\n  cin >> k;\n  precompute();\n  memset(dp, 0, sizeof(dp));\n  sum = 0;\n  for (i = 1; i <= k; i++) {\n    cin >> col[i];\n    sum += col[i];\n  }\n  cnt = 0;\n  for (i = 1; i <= k; i++) {\n    for (j = 1; j <= sum; j++) {\n      pos = j - 1 - cnt;\n      ball = col[i] - 1;\n      if (i > 1)\n        dp[i][j] = (cal(pos, ball) * dp[i - 1][j - 1]) % 1000000007;\n      else\n        dp[i][j] = (cal(pos, ball)) % 1000000007;\n      dp[i][j] = (dp[i][j] + dp[i][j - 1]) % 1000000007;\n    }\n    cnt += col[i];\n  }\n  cout << dp[k][sum];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.PrintWriter;\npublic class a \n{\n\tpublic static void main(String[] arg)\n\t{\n\t\tnew a();\n\t}\n\tlong MOD = 1_000_000_007;\n\tlong[][] memo;\n\tpublic a()\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new long[2000][2000];\n\t\tint k = in.nextInt();\n\t\tint n = 0;\n\t\tint[] arr = new int[k];\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tarr[i] = in.nextInt();\n\t\t\tn += arr[i];\n\t\t}\n\t\tint right = 0;\n\t\tlong answer = 1;\n\t\tfor(int i = k-1; i >= 0; i--)\n\t\t{\n\t\t\tanswer = (answer * choose(n-1-right, arr[i]-1))%MOD;\n\t\t\tright += arr[i];\n\t\t}\n\t\tout.println(answer);\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tpublic long choose(int n, int k)\n\t{\n\t\tif(n == k || k == 0) return 1;\n\t\tif(memo[n][k] != 0) return memo[n][k];\n\t\treturn memo[n][k] = (choose(n-1, k) + choose(n-1, k-1))%MOD;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Problem309C {\n\tstatic int mod = 1000000007;\n\tstatic int MAXN = 1010;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputReader reader = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong[][] comb = new long[MAXN][MAXN];\n\t\tcomb[0][0] = 1;\n\t\tfor (int i = 1; i < MAXN; i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tcomb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n\t\t\t\tcomb[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint n = reader.readInt();\n\t\tint[] balls = new int[n];\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tballs[i] = reader.readInt();\n\t\t\tsum += balls[i];\n\t\t}\n\t\tlong total = 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\ttotal = (total * comb[sum - 1][balls[i] - 1]) % mod;\n\t\t\tsum = sum - balls[i];\n\t\t}\n\t\tout.println(total);\n\t\tout.close();\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\treturn (int) readLong();\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t\tif (c == -1)\n\t\t\t\t\tthrow new IOException();\n\t\t\t}\n\t\t\tboolean negative = false;\n\t\t\tif (c == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn negative ? -res : res;\n\t\t}\n\n\t\tpublic final int[] readIntArray(int size) throws IOException {\n\t\t\tint[] array = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tarray[i] = readInt();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final long[] readLongArray(int size) throws IOException {\n\t\t\tlong[] array = new long[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tarray[i] = readLong();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "MOD = 1000000007;\n\ndef C (n, r):\n    num = 1;\n    denom = 1;\n    for i in range(1, r+1):\n        denom *= i;\n    for i in range(n-r+1, n+1):\n        num *= i;\n    return (num/denom)%MOD;\n\nsum = 0;\ncnt = 1;\nn = (int(input()));\nc = {};\n\nfor i in range(1, n+1):\n    c[i] = int(input());\n\nsum = c[1];\n    \nfor i in range(2, n+1):\n    cnt *= C(sum + c[i] - 1, sum);\n    cnt %= MOD;\n    sum += c[i];\n\nprint cnt;\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000 + 10;\nint a[maxn];\nlong long dp[maxn][maxn];\nvoid pre() {\n  dp[0][0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    dp[i][i] = 1;\n    dp[i][0] = 1;\n    for (int j = 1; j < i; j++)\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % 1000000007;\n  }\n}\nint main() {\n  int k;\n  pre();\n  while (cin >> k) {\n    int total = 0;\n    for (int i = 0; i < k; i++) {\n      cin >> a[i];\n      total += a[i];\n    }\n    long long res = 1;\n    for (int i = k - 1; i > 0; i--) {\n      res *= dp[total - 1][a[i] - 1];\n      res %= 1000000007;\n      total -= a[i];\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class KyoyaAndColoredBalls {\n\tstatic int ncr[][]=new int[1001][1001];\n\tstatic int p=1000000007;\n\tstatic void init(){\n\t\tncr[1][0]=1;\n\t\tncr[1][1]=1;\n\t\tfor(int i=2;i<1001;i++){\n\t\t\tncr[i][i]=1;\n\t\t\tncr[i][0]=1;\n\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\tncr[i][j]=(ncr[i-1][j]+ncr[i-1][j-1])%p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int totalWays(int n,int c[]){\n\t\tinit();\n        long calc[]=new long[n];\n        calc[0]=1;\n        int sum[]=new int[n];\n        sum[0]=c[0];\n        for(int i=1;i<n;i++)\n        \tsum[i]=sum[i-1]+c[i];\n        for(int i=1;i<n;i++){\n        \tcalc[i]=(calc[i-1]*(ncr[sum[i]-1][c[i]-1]))%p;\n        }\n        return (int)calc[n-1];\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint c[]=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tc[i]=in.nextInt();\n\t\t}\n\t\tSystem.out.println(totalWays(n,c));\n\t\tin.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long s[1010][1010] = {0};\n  int t;\n  int a = 1;\n  int q;\n  long long ans = 1;\n  for (int i = 0; i < 1010; i++) s[i][0] = 1;\n  for (int i = 1; i < 1010; i++)\n    for (int j = 1; j < 1010; j++)\n      s[i][j] = (s[i][j - 1] + s[i - 1][j]) % 1000000007;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    cin >> q;\n    ans = (ans * s[a][q - 1]) % 1000000007;\n    a += q;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long PowerMod(long long a, long long b, long long c) {\n  long long ans = 1;\n  a = a % c;\n  while (b > 0) {\n    if (b % 2 == 1) ans = (ans * a) % c;\n    b = b / 2;\n    a = (a * a) % c;\n  }\n  return ans;\n}\nlong long C(long long n, long long m) {\n  if (m < n - m) m = n - m;\n  long long ans = 1;\n  for (long long i = n; i > m; i--) {\n    ans *= i;\n    ans %= 1000000007;\n  }\n  for (long long i = 1; i <= n - m; i++)\n    ans = ans * (PowerMod(i, 1000000007 - 2, 1000000007)) % 1000000007;\n  return ans % 1000000007;\n}\nint main() {\n  int k;\n  cin >> k;\n  int a[1005] = {0};\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int pre[1005] = {0};\n  for (int i = 1; i <= k; i++) {\n    pre[i] = pre[i - 1] + a[i];\n  }\n  long long answer = 1;\n  for (int i = k; i >= 1; i--) {\n    answer *= (C(pre[i] - 1, a[i] - 1));\n    answer %= 1000000007;\n  }\n  cout << answer % 1000000007 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst double Pi = 3.1415926535;\nlong long bin_pow(long long a, long long b) {\n  if (b == 1) return a;\n  if (b % 2 == 0) {\n    long long c = bin_pow(a, b / 2);\n    return (c * c) % 1000000007;\n  } else {\n    long long c = bin_pow(a, b / 2);\n    return ((c * c % 1000000007) * a) % 1000000007;\n  }\n}\nlong long colors[3000];\nlong long n[4005];\nlong long k[4005];\nint main() {\n  int sizeI;\n  cin >> sizeI;\n  for (int i = 0; i < sizeI; i++) {\n    cin >> colors[i];\n  }\n  n[1] = 1;\n  k[1] = 1;\n  for (int i = 2; i <= 4000; i++) {\n    n[i] = n[i - 1] * i % 1000000007;\n    k[i] = bin_pow(n[i], 1000000007 - 2);\n  }\n  long long sum = colors[0];\n  long long ans = 1;\n  for (int i = 1; i < sizeI; i++) {\n    sum += colors[i] - 1;\n    if (colors[i] == 1) {\n      sum++;\n      continue;\n    }\n    ans = (ans * (n[sum] * k[colors[i] - 1] % 1000000007) % 1000000007) *\n          k[sum - (colors[i] - 1)] % 1000000007;\n    sum++;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "INF = 1000000007\nk = int(input())\nks = []\nfor i in range(k):\n    ks.append(int(input()))\nfacts = [1, 1]\nfor i in range(2, 1000):\n    facts.append(facts[i - 1] * i)\ncount = 1\nsumm = ks[0]\nfor i in range(1, k):\n    count *= facts[ks[i] - 1 + summ] // facts[summ] // facts[ks[i] - 1]\n    count %= INF\n    summ += ks[i]\nprint(count % INF)"
        },
        {
            "language": 1,
            "solution": "import math\nfrom math import factorial\ndef combination(n, r):\n    return math.factorial(n)/(math.factorial(r)*math.factorial(n-r))\nn = input()\nl = []\nans = 1\nfor r in range(n):\n    c = input()\n    l.append(c)\nk = sum(l)-1\nfor r in range(n):\n    ans *= combination(k, l[-r-1]-1)\n    ans %= (10**9+7)\n    k -= l[-r-1]\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef read_data():\n    k = int(input())\n    ns = [int(input()) for i in range(k)]\n    return k, ns\n\ndef solve(k, ns):\n    n = sum(ns)\n    free_pos = n\n    result = 1\n    mod = 10**9 + 7\n    for ni in reversed(ns):\n        tmp = math.factorial(free_pos - 1)//math.factorial(free_pos - ni)\n        tmp //= math.factorial(ni - 1)\n        tmp %= mod\n        result *= tmp\n        result %= mod\n        free_pos -= ni\n    return result\n\nk, ns = read_data()\nprint(solve(k, ns))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main\n{\t\n\t/********************************************** a list of common variables **********************************************/\n\t\n\tprivate MyScanner scan = new MyScanner();\n\tprivate PrintWriter out = new PrintWriter(System.out);\n\tprivate final int MOD = (int)(1e9 + 7);\n\t\n\tpublic void decompose(int x, HashMap<Integer, Integer> hm, int d)\n\t{\n\t\tint m = 2;\n\t\twhile(x > 1)\n\t\t{\n\t\t\twhile(0 == x % m)\n\t\t\t{\n\t\t\t\tif(-1 == d)\n\t\t\t\t{\n\t\t\t\t\thm.put(m, hm.get(m) - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(hm.containsKey(m))\n\t\t\t\t\t{\n\t\t\t\t\t\thm.put(m, hm.get(m) + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\thm.put(m, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx /= m;\n\t\t\t}\n\t\t\t++m;\n\t\t}\n\t}\n\n\tpublic void foo()\n\t{\n\t\tint n = scan.nextInt();\n\t\tlong ans = 1;\n\t\tint s = 0;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tint a = scan.nextInt();\n\t\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\tfor(int j = 1;j <= a - 1;++j)\n\t\t\t{\n\t\t\t\tdecompose(s + j, hm, 1);\n\t\t\t}\n\t\t\tfor(int j = 1;j <= a - 1;++j)\n\t\t\t{\n\t\t\t\tdecompose(j, hm, -1);\n\t\t\t}\n\t\t\tfor(Entry<Integer, Integer> en : hm.entrySet())\n\t\t\t{\n\t\t\t\tint m = en.getKey();\n\t\t\t\tint d = en.getValue();\n\t\t\t\twhile(d-- > 0)\n\t\t\t\t{\n\t\t\t\t\tans = ans * m % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts += a;\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tMain m = new Main();\n\t\tm.foo();\n\t\tm.out.close();\n\t}\n\n\t/********************************************** a list of common algorithms **********************************************/\n\t\n\t/**\n\t * KMP match, i.e. kmpMatch(\"abcd\", \"bcd\") = 1, kmpMatch(\"abcd\", \"bfcd\") = -1.\n\t * \n\t * @param t: String to match.\n\t * @param p: String to be matched.\n\t * @return if can match, first index; otherwise -1.\n\t */\n\tpublic int kmpMatch(char[] t, char[] p)\n\t{\n\t\tint n = t.length;\n\t\tint m = p.length;\n\t\tint[] next = new int[m + 1];\n\t\tnext[0] = -1;\n\t\tint j = -1;\n\t\tfor(int i = 1;i < m;++i)\n\t\t{\n\t\t\twhile(j >= 0 && p[i] != p[j + 1])\n\t\t\t{\n\t\t\t\tj = next[j];\n\t\t\t}\n\t\t\tif(p[i] == p[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tnext[i] = j;\n\t\t}\n\t\tj = -1;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\twhile(j >= 0 && t[i] != p[j + 1])\n\t\t\t{\n\t\t\t\tj = next[j];\n\t\t\t}\n\t\t\tif(t[i] == p[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif(j == m - 1)\n\t\t\t{\n\t\t\t\treturn i - m + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass MyScanner\n\t{\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t    BufferedInputStream bis = new BufferedInputStream(System.in);\n\n\t    public int read() \n\t    {\n\t        if (-1 == numChars)\n\t        {\n\t        \tthrow new InputMismatchException();\n\t        }\n\t        if (curChar >= numChars)\n\t        {\n\t            curChar = 0;\n\t            try \n\t            {\n\t                numChars = bis.read(buf);\n\t            }\n\t            catch (IOException e)\n\t            {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t            {\n\t            \treturn -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t    \n\t    public long nextLong() \n\t    {\n\t    \tint c = read();\n\t    \twhile (isSpaceChar(c))\n\t    \t{\n\t    \t\tc = read();\n\t    \t}\n\t    \tint sgn = 1;\n\t    \tif (c == '-') \n\t    \t{\n\t    \t\tsgn = -1;\n\t    \t\tc = read();\n\t    \t}\n\t    \tlong res = 0;\n\t    \tdo \n\t    \t{\n\t    \t\tif (c < '0' || c > '9')\n\t    \t\t{\n\t    \t\t\tthrow new InputMismatchException();\n\t    \t\t}\n\t    \t\tres *= 10;\n\t    \t\tres += c - '0';\n\t    \t\tc = read();\n\t    \t} while (!isSpaceChar(c));\n\t    \treturn res * sgn;\n\t    }\n\t    \n\t    public double nextDouble() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-')\n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        double res = 0;\n\t        while (!isSpaceChar(c) && c != '.') \n\t        {\n\t            if (c == 'e' || c == 'E')\n\t            {\n\t            \treturn res * Math.pow(10, nextInt());\n\t            }\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        }\n\t        if (c == '.') \n\t        {\n\t            c = read();\n\t            double m = 1;\n\t            while (!isSpaceChar(c)) \n\t            {\n\t                if (c == 'e' || c == 'E')\n\t                {\n\t                \treturn res * Math.pow(10, nextInt());\n\t                }\n\t                if (c < '0' || c > '9')\n\t                {\n\t                \tthrow new InputMismatchException();\n\t                }\n\t                m /= 10;\n\t                res += (c & 15) * m;\n\t                c = read();\n\t            }\n\t        }\n\t        return res * sgn;\n\t    }\n\t    \n\t    public String next()\n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        StringBuilder res = new StringBuilder();\n\t        do \n\t        {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) \n\t    {\n\t        return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n\t    }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool sieve[1000100];\nvector<long long> primes;\nlong long v[1010];\nlong long dp[1000100];\nlong long sum;\nvoid mountSieve() {\n  for (int i = 2; i * i < 1000100; i++) {\n    if (!sieve[i]) {\n      int x = i * i;\n      while (x < 1000100) {\n        sieve[x] = true;\n        x += i;\n      }\n    }\n  }\n  for (int i = 2; i < 1000100; i++) {\n    if (!sieve[i]) {\n      primes.push_back(i);\n    }\n  }\n}\nint main() {\n  mountSieve();\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &v[i]);\n    sum += v[i];\n  }\n  sum--;\n  for (int i = 0; primes[i] <= sum; i++) {\n    long long x = primes[i];\n    while (x <= sum) {\n      dp[primes[i]] += sum / x;\n      x *= primes[i];\n    }\n  }\n  for (int j = 1; j <= n; j++) {\n    sum = v[j] - 1;\n    for (int i = 0; primes[i] <= sum; i++) {\n      long long x = primes[i];\n      while (x <= sum) {\n        dp[primes[i]] -= sum / x;\n        x *= primes[i];\n      }\n    }\n  }\n  sum = 0;\n  for (int i = 1; i < n; i++) {\n    sum += v[i];\n    long long x = sum;\n    for (int j = 0; primes[j] <= x; j++) {\n      while (x % primes[j] == 0) {\n        dp[primes[j]]--;\n        x /= primes[j];\n      }\n    }\n  }\n  long long ans = 1;\n  for (int i = 1; i < 1000100; i++) {\n    while (dp[i]--) {\n      ans *= i;\n      if (ans >= 1000000007) ans %= 1000000007;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces.practice.oneVone.Oct22_2020;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class A553 {\n    static InputReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) {\n        //initReaderPrinter(true);\n        initReaderPrinter(false);\n        //solve(in.nextInt());\n        solve(1);\n    }\n\n    static void solve(int testCnt) {\n        for (int testNumber = 0; testNumber < testCnt; testNumber++) {\n            int k = in.nextInt();\n            int sum = 0;\n            long mod = (long)1e9 + 7;\n            int[] c = new int[k];\n            for(int i = 0; i < k; i++) {\n                c[i] = in.nextInt();\n                sum += c[i];\n            }\n\n            long[] factor = new long[sum];\n            factor[0] = 1;\n            for(int i = 1; i < sum; i++) {\n                factor[i] = factor[i - 1] * i % mod;\n            }\n            long ans = 1, currSum = c[0];\n            for(int i = 1; i < k; i++) {\n                currSum += c[i];\n                ans = ans * modularMulInverse(factor, currSum - 1, c[i] - 1, mod) % mod;\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n\n    static long modularMulInverse(long[] factor, long n, long k, long mod) {\n        return factor[(int)n] * modInv_EEA(factor[(int)k], mod) % mod\n                * modInv_EEA(factor[(int)(n - k)], mod) % mod;\n    }\n\n    static long modInv_EEA(long a, long mod) {\n        long[] res = solveGcdEquation(a, mod);\n        if(res[2] != 1) {\n            // a and m are not coprime, modular inverse of a by m does not exist.\n            return -1;\n        }\n        return (res[0] + mod) % mod;\n    }\n\n    static long[] solveGcdEquation(long a, long b) {\n        if(b == 0) {\n            return new long[]{1, 0, a};\n        }\n        long[] res = solveGcdEquation(b, a % b);\n        return new long[]{res[1], res[0] - (a / b) * res[1], res[2]};\n    }\n\n    static void initReaderPrinter(boolean test) {\n        if (test) {\n            try {\n                in = new InputReader(new FileInputStream(\"src/input.in\"));\n                out = new PrintWriter(new FileOutputStream(\"src/output.out\"));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            in = new InputReader(System.in);\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        InputReader(InputStream stream) {\n            try {\n                br = new BufferedReader(new InputStreamReader(stream), 32768);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        Integer[] nextIntArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        Long[] nextLongArray(int n) {\n            Long[] a = new Long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Artyom Korzun\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\n    private static final int MOD = 1_000_000_007;\n\n    private int MAX_N = 1000;\n\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int k = in.nextInt();\n        int[] c = in.nextIntArray(k);\n\n        long[][] bc = new long[MAX_N + 1][MAX_N + 1];\n        bc[0][0] = 1;\n        for (int i = 1; i <= MAX_N; i++) {\n            bc[i][0] = 1;\n            for (int j = 1; j <= MAX_N; j++)\n                bc[i][j] = (bc[i - 1][j - 1] + bc[i - 1][j]) % MOD;\n        }\n        \n        long answer = 1;\n        for (int i = 1, sum = c[0]; i < k; i++) {\n            sum+= c[i];\n            answer = answer * bc[sum - 1][c[i] - 1] % MOD;\n        }\n        \n        out.print(answer);        \n    }\n\n}\n\nclass FastScanner {\n\n    private final BufferedReader reader;\n\n    private StringTokenizer tokenizer;\n\n    public FastScanner(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public int[] nextIntArray(int length) {\n        int[] array = new int[length];\n        for (int i = 0; i < length; i++)\n            array[i] = nextInt();\n\n        return array;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "M=1000000007\na=[input() for _ in range(input())]\np=[1]*1024\nfor i in range(1,1024):\n  p[i]=p[i-1]*i%M\nd=lambda x,y:x*pow(y,M-2,M)%M\nc=lambda n,m:d(d(p[n],p[m]),p[n-m])\ns,t=sum(a)-1,1\nwhile a:\n  x=a.pop()\n  t=t*c(s,x-1)%M\n  s-=x\nprint t\n"
        },
        {
            "language": 3,
            "solution": "\n# coding: utf-8\n\n# In[6]:\n\n\nmatrix = [[0 for x in range(1001)] for y in range(1001)]\nmod = 1000000007\n\ndef pascal():\n    matrix[0][0]=1;\n    for i in range(1001):\n        for j in range(1001):\n            if j==0 or j==i:\n                matrix[i][j]=1\n            else:\n                matrix[i][j] = (matrix[i-1][j-1]+matrix[i-1][j])%mod\n\na = int(input())\nb = []\nfor i in range(a):\n    b.append(int(input()))\npascal()\nr = 1\ns = b[0]\nfor i in range(1,a):\n    r = (r*matrix[s + b[i]-1][b[i]-1])%mod\n    s += b[i]\nprint(r)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1010;\nconst long long int Mod = 1000000007;\nlong long int C[N][N];\nint main() {\n  C[0][0] = 1;\n  C[1][0] = C[1][1] = 1;\n  for (int i = 2; i < N - 1; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod;\n  }\n  int n;\n  int a[N];\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  long long int ans = 1;\n  long long int count = 0;\n  for (int i = 0; i < n; i++) {\n    count += a[i];\n    ans = (ans * C[count - 1][a[i] - 1]) % Mod;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\n\n\npublic class C {\n\n  static long fact(int n) {\n    long result = 1;\n    for (int i = 1; i <= n; ++i) {\n      result *= i;\n    }\n    return result;\n  }\n\n  static int comb(int x, int y) {\n    int result = 1;\n    for (int i = 0; i < y; ++i) {\n      result *= (x - i);\n    }\n    for (int i = 1; i <= y; ++i) {\n      result /= i;\n    }\n    return result;\n  }\n\n  public static void main(String[] args) {\n    int mod = 1000000007;\n    MyScanner sc = new MyScanner();\n    out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    int k = sc.nextInt();\n    int[] elems = new int[k];\n    for (int i = 0; i < k; ++i) {\n      elems[i] = sc.nextInt();\n    }\n\n    long[][] b = new long[1001][1001];\n    for (int i = 0; i <= 1000; i++) {\n      for (int j = 0; j <= Math.min(i, 1000); j++) {\n        // Base Cases\n        if (j == 0 || j == i) {\n          b[i][j] = 1;\n        }\n        // Calculate value using previosly stored values\n        else {\n          b[i][j] = b[i - 1][j - 1] + b[i - 1][j];\n        }\n        b[i][j] %= mod;\n      }\n    }\n\n    long result = 1;\n    int nBalls = 0;\n    for (int i = 0; i < k; ++i) {\n      long to_add = b[nBalls + elems[i] - 1][elems[i] - 1];\n      to_add = Math.max(to_add, 1);\n      result *= to_add;\n      result %= mod;\n\n      nBalls += elems[i];\n\n    }\n    out.println(result);\n\n    out.close();\n  }\n\n  static int getSize(int n) {\n    if (n == 1) {\n      return 2;\n    } else {\n      return (1 << n) - 1;\n    }\n  }\n\n\n  public static PrintWriter out;\n\n  static class MyScanner {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public MyScanner() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n\n  }\n//--------------------------------------------------------\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nint a[1005];\nlong long C[1005][1005];\nvoid init() {\n  for (int i = 0; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (i == 0 || j == 0)\n        C[i][j] = 1;\n      else\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    }\n  }\n}\nint main() {\n  init();\n  int n;\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  long long cnt = 1;\n  for (int i = n; i >= 1; i--) {\n    cnt = cnt * C[sum - 1][a[i] - 1] % mod;\n    sum -= a[i];\n  }\n  cout << cnt << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nconst int MOD = 1E9 + 7;\nint n, x, c[N][N], ans = 1, sum;\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i < N; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n  }\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    sum += x;\n    ans = ((long long)ans * c[sum - 1][x - 1]) % MOD;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\ncnt = []\nfor i in range(n):\n    cnt.append(int(input()))\n\ndp = [1]\nlength = [cnt[0]]\nMOD = int(1000000007)\n\ndef C(n, k):\n    assert(n >= k)\n    res = 1\n    for i in range(n - k + 1, n + 1):\n        res *= i\n    for i in range(2, k + 1):\n        res //= i\n    \n    \"\"\"DEBUG\"\"\"\n    #import math as m\n    #assert(res == m.factorial(n) // m.factorial(k) // m.factorial(n - k))\n    \"\"\"\"/DEBUG\"\"\"\n\n    return res % MOD\n    \nfor i in range(1, n):\n    length.append(length[i - 1] + cnt[i])\n    dp.append((dp[i - 1] * C(length[i] - 1, cnt[i] - 1)) % MOD)\n\nprint(dp[n - 1])\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nint a[1055];\nlong long C[1055][1055];\nint main() {\n  C[0][0] = 1;\n  for (int i = 1; i < 1055; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  int k;\n  cin >> k;\n  vector<int> color(k + 2);\n  for (int i = 0; i < k; i++) {\n    cin >> color[i];\n  }\n  long long res = 1;\n  int tot = 0;\n  for (int i = 0; i < k; i++) {\n    res = (res * C[tot + color[i] - 1][color[i] - 1]) % 1000000007;\n    tot += color[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class A\n{\n   public static void main(String[] args)\n   {\n      PrintWriter out = new PrintWriter(System.out);\n      new A(new FastScanner(), out);\n      out.close();\n   }\n\n   int MODO = 1_000_000_007;\n   public A(FastScanner in, PrintWriter out)\n   {\n      int M = 1008;\n      int[][] pasc = new int[M][M];\n      pasc[0][0] = 1;\n      for (int i=0; i+1<M; i++)\n      {\n         for (int j=0; j<=i; j++)\n         {\n            pasc[i+1][j+1] += pasc[i][j];\n            pasc[i+1][j+1] %= MODO;\n            pasc[i+1][j] += pasc[i][j];\n            pasc[i+1][j] %= MODO;\n         }\n      }\n     \n      long res = 1;\n      int N = in.nextInt();\n      int numBefore = 0;\n      for (int i=0; i<N; i++)\n      {\n         int v = in.nextInt();\n         res *= pasc[numBefore+v-1][v-1];\n         res %= MODO;\n         numBefore += v;\n      }\n      out.println(res);\n   }\n}\n\nclass FastScanner{\n   private InputStream stream;\n   private byte[] buf = new byte[1024];\n   private int curChar;\n   private int numChars;\n\n   public FastScanner()\n   {\n      stream = System.in;\n   }\n\n   int read()\n   {\n      if (numChars == -1)\n         throw new InputMismatchException();\n      if (curChar >= numChars){\n         curChar = 0;\n         try{\n            numChars = stream.read(buf);\n         } catch (IOException e) {\n            throw new InputMismatchException();\n         }\n         if (numChars <= 0)\n            return -1;\n      }\n      return buf[curChar++];\n   }\n\n   boolean isSpaceChar(int c)\n   {\n      return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n   }\n   \n   boolean isEndline(int c)\n   {\n      return c=='\\n'||c=='\\r'||c==-1;\n   }\n\n   int nextInt()\n   {\n      return Integer.parseInt(next());\n   }\n   \n   long nextLong()\n   {\n      return Long.parseLong(next());\n   }\n\n   double nextDouble()\n   {\n      return Double.parseDouble(next());\n   }\n\n   String next(){\n      int c = read();\n      while (isSpaceChar(c))\n         c = read();\n      StringBuilder res = new StringBuilder();\n      do{\n         res.appendCodePoint(c);\n         c = read();\n      }while(!isSpaceChar(c));\n      return res.toString();\n   }\n   \n   String nextLine(){\n      int c = read();\n      while (isEndline(c))\n         c = read();\n      StringBuilder res = new StringBuilder();\n      do{\n         res.appendCodePoint(c);\n         c = read();\n      }while(!isEndline(c));\n      return res.toString();\n   }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class c1 {\n\t\n\tstatic long mod = 1000000007;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\t\n\t\tint a[] = new int[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tlong c[][] = new long[1010][1010];\n\t\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tc[i][0] = 1;\n\t\t\tc[i][i] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i < 1010; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 1;\n\t\tlong sum = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = 1l * ans * (c[(int) (sum + a[i] - 1)][a[i] - 1]) % mod; \n\t\t\tsum += a[i];\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fastStream() {\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n}\nconst int mod = 1000000000 + 7;\nint K;\nint C[1010];\nint dp[1010][1010];\nint tot;\nconst int MAX_ARG = 2200;\nlong long dp2[MAX_ARG][MAX_ARG];\nlong long comb(int a, int b) {\n  if (a < 0 || b < 0) return 0;\n  if (a < b)\n    return 0;\n  else if (b == 0)\n    return 1;\n  else if (dp2[a][b] >= 0)\n    return dp2[a][b];\n  return dp2[a][b] = (comb(a - 1, b) + comb(a - 1, b - 1)) % mod;\n}\nint dfs(int kind, int pos, int sum) {\n  if (dp[kind][pos] >= 0) return dp[kind][pos];\n  long long res = 0;\n  if (kind == K) {\n    res = 1;\n  } else if (pos == tot) {\n    res = 0;\n  } else {\n    if (pos + 1 >= C[kind] + sum) {\n      const int A = pos + 1 - (C[kind] + sum) + C[kind] - 1;\n      const int B = C[kind] - 1;\n      res = (res + (comb(A, B) * dfs(kind + 1, pos + 1, sum + C[kind]))) % mod;\n    }\n    res = (res + dfs(kind, pos + 1, sum)) % mod;\n  }\n  return dp[kind][pos] = res;\n}\nint main() {\n  memset(dp, -1, sizeof(dp));\n  fastStream();\n  cin >> K;\n  for (int i = 0; i < K; i++) {\n    cin >> C[i];\n    tot += C[i];\n  }\n  memset(dp2, -1, sizeof(dp2));\n  cout << dfs(0, 0, 0) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int k = in.nextInt();\n        BigInteger r = BigInteger.valueOf(1);\n        int n = 0;\n        for (int i = 0; i < k; i++) {\n            int ci = in.nextInt();\n            r = r.multiply(c(ci+n-1, n));// n+1 positions, put ci-1 elemnets in them; hit ci elements n times (size can be 0)\n            n += ci;\n        }\n        System.out.println(r.mod(BigInteger.valueOf(1000000007)));\n    }\n\n    public static BigInteger c(int n, int r) {\n        BigInteger c = BigInteger.valueOf(1);\n        for (int i = n; i > n - r; i--)\n            c = c.multiply(BigInteger.valueOf(i));\n        for (int i = r; i > 0; i--)\n            c = c.divide(BigInteger.valueOf(i));\n        return c;\n    }\n}\n\n \t\t\t\t\t     \t   \t \t \t  \t\t\t \t\t \t"
        },
        {
            "language": 3,
            "solution": "def fact(x):\n    r = 1\n    for i in range(1, x + 1): r *= i\n    return r\n\nmod = int(1e9 + 7)\nn = int(input())\narr = [0] * n\nfor i in range(n): arr[i] = int(input())\nr = 1; s = 0\nfor i in range(1, n):\n    s += arr[i - 1]\n    r *= fact(s + arr[i] - 1) // fact(s) // fact(arr[i] - 1)\n    r %= mod\nprint(r)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class first {\n\tstatic long mod = (int) 1e9 + 7;\n\tstatic long[][] choose;\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tchoose = new long[1001][1001];\n\t\tfor(int i =0 ; i < choose.length;i++)choose[0][i]=0;\n\t\tfor(int i = 0; i < choose.length; i++)choose[i][0]=1;\n\t\tfor (int nn = 1; nn < choose.length; nn++) {\n\t\t\tfor (int k = 1; k <= nn; k++) {\n\t\t\t\tchoose[nn][k] = (choose[nn - 1][k] + choose[nn - 1][k - 1]) % mod;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < choose.length; i++)\n\t\t\tchoose[0][i] = 1;\n\t\tfor (int i = 0; i < choose.length; i++) {\n\t\t\tchoose[i][0] = 1;\n\t\t}\n\t\t\n\t\tint[] guys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tguys[i] = in.nextInt();\n\t\t}\n\t\tlong ans = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k = guys[i]-1;\n\t\t\tint nn = sum+k;\n//\t\t\tSystem.out.println(nn+\" choose \"+k);\n\t\t\tans*=choose[nn][k];\n\t\t\tans%=mod;\n\t\t\tsum+=guys[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "def fact(n) :\n    p = n; \n    # print(\"n=\" + str(n))\n    for i in range(1, n) :\n        # print(\"i=\" + str(i)) \n        p *= i\n    if(n == 0) :\n        return 1\n    return p\ndef ncr(n, r) : \n    return fact(n) // fact(n-r) // fact(r)\nn = int(input())\nc = []\nfor i in range(n) :\n    k = int(input()) \n    c.insert(len(c), k)\n    # print(\"hi - \" + str(c[i]))\np = 1\nsum = 0\nfor i in range(n) :\n    # print(\"i=\" + str(i)) \n    sum += c[i]\n    # print(\"sum=\" + str(sum))\n# print(sum);\nfor i in range(n, 0, -1) :\n    # print(\"alala : \" + str(ncr(sum-1, c[i-1]-1)))\n    # print(\"sum=\" + str(sum-1) + \" c : \" + str(c[i-1]-1))\n    p = p * ncr(sum-1, c[i-1]-1)\n    p %= 1000000007\n    sum -= c[i-1]\nprint(int(p))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mo = 1e9 + 7;\nint n, a[1005];\nlong long c[1005][1005], ans = 1;\nvoid pai() {\n  c[0][0] = 1;\n  for (int i = 1; i < 1005; i++) {\n    c[i][i] = c[i][0] = 1;\n    for (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mo;\n  }\n}\nint main() {\n  pai();\n  cin >> n;\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  for (int i = n - 1; i > 0; i--) {\n    ans *= c[sum - 1][a[i] - 1];\n    ans %= mo;\n    sum -= a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Hieu Le\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    private final int MOD = (int)1e9 + 7;\n    private final int max = 1000;\n    private long[][] c;\n\n    public TaskC() {\n        c = new long[max + 1][max + 1];\n        for (int i = 0; i <= max; i++) {\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++)\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\n        }\n    }\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int k = in.nextInt();\n        int[] b = new int[k + 1];\n        for (int i = 1; i <= k; i++) b[i] = in.nextInt();\n        long[] cnt = new long[k + 1];\n        cnt[1] = 1;\n        int soFar = b[1];\n        for (int i = 2; i <= k; i++) {\n            cnt[i] = (cnt[i - 1] * c[soFar + b[i] - 1][soFar]) % MOD;\n            soFar += b[i];\n        }\n        out.println(cnt[k]);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1005][1005];\nvoid nCr() {\n  int i, j;\n  C[0][0] = 1;\n  for (i = 0; i < 1004; i++) C[i][0] = 1;\n  for (i = 1; i < 1004; i++) {\n    for (j = 1; j < i + 1; j++) {\n      C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n      if (C[i][j] >= 1000000007) C[i][j] = C[i][j] - 1000000007;\n    }\n  }\n}\nlong long dp[1005];\nint main() {\n  long long i, j;\n  ios_base ::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  nCr();\n  int k;\n  cin >> k;\n  int a[1005];\n  int n = 0;\n  for (i = 0; i < k; i++) {\n    cin >> a[i];\n    n += a[i];\n  }\n  dp[0] = 1;\n  for (i = 1; i < k; i++) {\n    dp[i] = (dp[i - 1] * C[n - 1][a[k - i] - 1]) % 1000000007;\n    n = n - a[k - i];\n  }\n  cout << dp[k - 1] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "        import java.util.*;\n        import java.io.*;\n        import java.math.*;\n        import java.util.LinkedList;\n         \n            public  class Sample implements Runnable\n            {     \n                  static int maxN=1010;\n                  static int[] a;\n                  static long[][] comb;\n\n                    //////////////\n                  public static void solve()\n                  { \n                    \n                    int n=i();\n                    a=new int[n];\n                    for(int i=0;i<n;i++)a[i]=i();\n                    comb=new long[maxN][maxN];\n                    comb[0][0]=1;\n                    for(int i=1;i<maxN;i++)\n                    {\n                      comb[i][0]=1;\n                      for(int j=1;j<=i;j++)\n                      {\n                        comb[i][j]=(comb[i-1][j]+comb[i-1][j-1])%mod;\n                      }\n                    }\n                    long res=1;\n                    int total=0;\n                    for(int i=0;i<n;i++)\n                    {\n                      res=(res*comb[total+a[i]-1][a[i]-1])%mod;\n                      total+=a[i];\n                    }\n                    out.println(res);\n\n\n                  }\n                  static void khojo(long[] a,HashMap hs,int i,int n,long res)\n                  {\n                    if(i>=n)\n                    {\n                      if(hs.containsKey(res))\n                      {\n                        hs.put(res,(long)hs.get(res)+1L);\n                      }\n                      else\n                      {\n                        hs.put(res,1L);\n                      }\n                    }\n                    else\n                    {\n                      khojo(a,hs,i+1,n,(res^a[i]));\n                      khojo(a,hs,i+1,n,res);\n                  }\n                  }\n                   \n                  public void run()\n                  {   \n                      solve();\n                      out.close();\n                  }\n         \n                  public static void main(String[] args) throws IOException\n                  { \n                        new Thread(null, new Sample(), \"whatever\", 1<<26).start();\n                  }\n                 static class Pair implements Comparable<Pair>\n                 {\n                    long a;\n                    int b;\n                    Pair(){}\n                    Pair(long a,int b)\n                    {\n                               this.a=a;\n                               this.b=b;\n                    }\n           \n                    public int compareTo(Pair x)\n                   {\n                        return Long.compare(x.a,this.a);\n                   }\n                }\n                \n               \n                 \n            ////////////////////////////////////////////////////// Merge Sort ////////////////////////////////////////////////////////////////////////\n             \n           static class Merge \n           {\n         \n                public static void sort(long inputArr[]) \n                {\n                    int length = inputArr.length;\n                    doMergeSort(inputArr,0, length - 1);\n                }\n         \n                private static void doMergeSort(long[] arr,int lowerIndex, int higherIndex) \n                {        \n                    if (lowerIndex < higherIndex) {\n                        int middle = lowerIndex + (higherIndex - lowerIndex) / 2;\n                        doMergeSort(arr,lowerIndex, middle);\n                        doMergeSort(arr,middle + 1, higherIndex);\n                        mergeParts(arr,lowerIndex, middle, higherIndex);\n                    }\n                }\n         \n                private static void mergeParts(long[]array,int lowerIndex, int middle, int higherIndex) \n                {\n                    long[] temp=new long[higherIndex-lowerIndex+1];\n                    for (int i = lowerIndex; i <= higherIndex; i++) \n                    {\n                        temp[i-lowerIndex] = array[i];\n                    }\n                    int i = lowerIndex;\n                    int j = middle + 1;\n                    int k = lowerIndex;\n                    while (i <= middle && j <= higherIndex) \n                    {\n                        if (temp[i-lowerIndex] < temp[j-lowerIndex]) \n                        {\n                            array[k] = temp[i-lowerIndex];\n                            i++;\n                        } else {\n                            array[k] = temp[j-lowerIndex];\n                            j++;\n                        }\n                        k++;\n                    }\n                    while (i <= middle) \n                    {\n                        array[k] = temp[i-lowerIndex];\n                        k++;\n                        i++;\n                    }\n                    while(j<=higherIndex)\n                    {\n                        array[k]=temp[j-lowerIndex];\n                        k++;\n                        j++;\n                    }\n                }\n         \n            }\n                \n              \n            /////////////////////////////////////////////////////////// Methods ////////////////////////////////////////////////////////////////////////\n         \n         \n             static boolean isPal(String s)\n             {\n                for(int i=0, j=s.length()-1;i<=j;i++,j--)\n                {\n                        if(s.charAt(i)!=s.charAt(j)) return false;\n                }\n                return true;\n             }\n             static String rev(String s)\n             {\n                        StringBuilder sb=new StringBuilder(s);\n                        sb.reverse();\n                        return sb.toString();\n             }\n             static int gcd(int a,int b){return (a==0)?b:gcd(b%a,a);}\n             static long gcdExtended(long a,long b,long[] x)\n             {\n         \n                if(a==0){\n                    x[0]=0;\n                    x[1]=1;\n                    return b;\n                }\n                long[] y=new long[2];\n                long gcd=gcdExtended(b%a, a, y);\n         \n                x[0]=y[1]-(b/a)*y[0];\n                x[1]=y[0];\n         \n                return gcd;\n            }\n         \n             boolean findSum(int set[], int n, long sum)\n            {\n              if (sum == 0)\n                 return true;\n              if (n == 0 && sum != 0)\n                 return false;\n              if (set[n-1] > sum)\n                 return findSum(set, n-1, sum);\n              return findSum(set, n-1, sum) ||findSum(set, n-1, sum-set[n-1]);\n            }\n           \n              public static long modPow(long base, long exp, long mod)\n             {\n                base = base % mod;\n                long result = 1;\n                while (exp > 0)\n               {\n                    if (exp % 2 == 1) \n                    {\n                        result = (result * base) % mod;\n                    }\n                    base = (base * base) % mod;\n                    exp = exp >> 1;\n               }\n                return result;\n            }\n         \n            static long[] fac;\n            static long[] inv;\n            static long mod=(long)1e9+7;\n            public static void cal() \n            {\n                fac = new long[1000005];\n                inv = new long[1000005];\n                fac[0] = 1;\n                inv[0] = 1;\n                for (int i = 1; i <= 1000000; i++)\n                {\n                    fac[i] = (fac[i - 1] * i) % mod;\n                    inv[i] = (inv[i - 1] * modPow(i, mod - 2, mod)) % mod;\n                }\n            }\n         \n            public static long ncr(int n, int r) \n            {\n                return (((fac[n] * inv[r]) % mod) * inv[n - r]) % mod;\n            }\n         \n         \n        ////////////////////////////////////////// Input Reader ////////////////////////////////////////////////////////////////////////////////////////////////////\n             \n            static InputReader sc = new InputReader(System.in);\n            static PrintWriter out= new PrintWriter(System.out);   \n            \n            static class InputReader {\n         \n                  private final InputStream stream;\n                  private final byte[] buf = new byte[8192];\n                  private int curChar, snumChars;\n                  private SpaceCharFilter filter;\n         \n                  public InputReader(InputStream stream) {\n                          this.stream = stream;\n                  }\n         \n                  public int snext()\n                 {\n                          if (snumChars == -1)\n                                  throw new InputMismatchException();\n                          if (curChar >= snumChars) {\n                                  curChar = 0;\n                                  try {\n                                          snumChars = stream.read(buf);\n                                  } catch (IOException e) {\n                                          throw new InputMismatchException();\n                                  }\n                                  if (snumChars <= 0)\n                                          return -1;\n                          }\n                          return buf[curChar++];\n                  }\n         \n                  public int nextInt()\n                 {\n                          int c = snext();\n                          while (isSpaceChar(c)) \n                          {\n                                  c = snext();\n                          }\n                          int sgn = 1;\n                          if (c == '-')\n                          {\n                                  sgn = -1;\n                                  c = snext();\n                          }\n                          int res = 0;\n                          do {\n                                  if (c < '0' || c > '9')\n                                          throw new InputMismatchException();\n                                  res *= 10;\n                                  res += c - '0';\n                                  c = snext();\n                          } while (!isSpaceChar(c));\n                          return res * sgn;\n                  }\n         \n                  public long nextLong() \n                  {\n                          int c = snext();\n                          while (isSpaceChar(c)) \n                          {\n                                  c = snext();\n                          }\n                          int sgn = 1;\n                          if (c == '-') \n                          {\n                                  sgn = -1;\n                                  c = snext();\n                          }\n                          long res = 0;\n                          do {\n                                  if (c < '0' || c > '9')\n                                          throw new InputMismatchException();\n                                  res *= 10;\n                                  res += c - '0';\n                                  c = snext();\n                          } while (!isSpaceChar(c));\n                          return res * sgn;\n                  }\n         \n                  public int[] nextIntArray(int n)\n                  {\n                          int a[] = new int[n];\n                          for (int i = 0; i < n; i++) \n                          {\n                                  a[i] = nextInt();\n                          }\n                          return a;\n                  }\n         \n                  public long[] nextLongArray(int n)\n                  {\n                          long a[] = new long[n];\n                          for (int i = 0; i < n; i++) \n                          {\n                                  a[i] = nextLong();\n                          }\n                          return a;\n                  }\n         \n                  \n                  public String nextLine()\n                 {\n                          int c = snext();\n                          while (isSpaceChar(c))\n                                  c = snext();\n                          StringBuilder res = new StringBuilder();\n                          do {\n                                  res.appendCodePoint(c);\n                                  c = snext();\n                          } while (!isEndOfLine(c));\n                          return res.toString();\n                  }\n         \n                  public boolean isSpaceChar(int c) \n                  {\n                          if (filter != null)\n                                  return filter.isSpaceChar(c);\n                          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n                  }\n         \n                  private boolean isEndOfLine(int c) \n                  {\n                          return c == '\\n' || c == '\\r' || c == -1;\n                  }\n         \n                  public interface SpaceCharFilter \n                  {\n                          public boolean isSpaceChar(int ch);\n                  }\n         \n            }\n         \n            static int i()\n            {\n                return sc.nextInt();\n            }\n            static long l(){\n                return sc.nextLong();\n            }\n            static int[] iarr(int n)\n            {\n                return sc.nextIntArray(n);\n            }\n            static long[] larr(int n)\n            {\n                return sc.nextLongArray(n);\n            }\n            static String s(){\n                return sc.nextLine();\n            }\n          \n         \n         }  "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e3 + 50;\nconst long long mod = 1000000007;\nlong long f[maxn][maxn];\nint k, sum[maxn], c[maxn];\nlong long ans = 1;\nlong long dp(int x, int y) {\n  if (f[x][y] != -1) return f[x][y];\n  long long &tans = f[x][y] = 1;\n  if (y == 0 || y == x) return tans = 1;\n  tans = dp(x - 1, y - 1) + dp(x - 1, y);\n  if (tans >= mod) tans %= mod;\n  return tans;\n}\nint main(int argc, char *argv[]) {\n  memset(f, -1, sizeof(f));\n  cin >> k;\n  for (int i = 1; i < k + 1; ++i) {\n    cin >> c[i];\n    sum[i] = sum[i - 1] + c[i];\n  }\n  for (int i = 2; i <= k; ++i) {\n    int vk = sum[i - 1] + 1;\n    int n = c[i] - 1;\n    ans *= dp(vk + n - 1, vk - 1);\n    if (ans >= mod) ans %= mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 10000;\nlong long n, sum = 0;\nlong long ans = 1;\nlong long mod = 1000000000 + 7;\nlong long a[1000][1000];\nlong long num;\nint32_t main() {\n  cin >> n;\n  a[0][0] = 1;\n  for (long long i = 1; i < 1000; i++) {\n    a[i][0] = 1;\n    for (long long j = 1; j <= i; j++) {\n      a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % mod;\n    }\n  }\n  while (n > 0) {\n    cin >> num;\n    sum += num;\n    ans = (ans * a[sum - 1][num - 1]) % mod;\n    n--;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k;\n  cin >> k;\n  vector<int> x;\n  int sum = 0;\n  for (int i = 0; i < k; i++) {\n    int t;\n    cin >> t;\n    sum += t;\n    x.push_back(t);\n  }\n  unsigned long v[1005][1005];\n  v[0][0] = 1;\n  v[0][1] = 1;\n  v[0][2] = 0;\n  for (int i = 1; i < sum; i++) {\n    v[i][0] = 1;\n    for (int j = 0; j < i + 1; j++) {\n      v[i][j + 1] = (v[i - 1][j + 1] + v[i - 1][j]) % 1000000007;\n    }\n    v[i][i + 2] = 0;\n  }\n  unsigned long long int p = 1;\n  for (int i = 0; i < k - 1; i++) {\n    p = (p * v[sum - 2][x[k - i - 1] - 1]) % 1000000007;\n    sum = sum - x[k - i - 1];\n  }\n  cout << p << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "def fac(n):\n  r = 1\n  for x in xrange(1, n+1):\n    r = r * x\n  return r\n\nk = int(raw_input())\nc = []\nfor i in xrange(0, k):\n  c.append(int(raw_input()))\n\nP = [c[0]]\nfor i in xrange(1, k):\n  P.append(c[i] + P[i-1])\n\ndp = [1]\nfor i in xrange(1, k):\n  r = dp[i-1]\n  for a in xrange(1, c[i]):\n    r = r * (P[i-1] + a)\n  r = r / (fac(c[i]-1))\n  dp.append(r % 1000000007)\n\nprint dp[k-1]"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Solution{\n\tpublic static void main (String[] args) throws IOException{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tString[] temp=br.readLine().trim().split(\" \");\n\t\t\n\t\tint k=Integer.parseInt(temp[0]);\n\t\tint[] arr=new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t    arr[i]=Integer.parseInt(br.readLine());\n\t\t}\n\t\tout.println(numWays(arr));\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tpublic static int numWays(int[] arr)\n\t{\n\t\tint k=arr.length;\n\t\tint[] prefixSum=new int[k];\n\t\tint[] fact=new int[1001];\n\t\tfact[0]=1;\n\t\tfactorial(1000,fact);\n\t\tprefixSum[0]=arr[0];\n\t\tfor(int i=1;i<k;i++){\n\t\t    prefixSum[i]=prefixSum[i-1]+arr[i];\n\t\t}\n\t\tint[] dp=new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t    dp[i]=-1;\n\t\t}\n\t\treturn numWaysHelper(arr,k-1,prefixSum,fact,dp);\n\t}\n\tpublic static int numWaysHelper(int[] arr,int end,int[] prefixSum,int[] fact,int[] dp)\n\t{\n\t    if(end==0){\n\t        return 1;\n\t    }\n\t    if(dp[end]>=0){\n\t        return dp[end];\n\t    }\n\t    int mod=1000000007;\n\t    int smallAns=numWaysHelper(arr,end-1,prefixSum,fact,dp);\n\t    int ways=nCr(prefixSum[end]-1,arr[end]-1,mod,fact);\n\t    int ans=(int)((1L*(smallAns%mod)*(ways%mod))%mod);\n\t    dp[end]=ans;\n\t    return ans;\n\t}\n\tpublic static int nCr(int n,int r,int mod,int[] fact)\n\t{\n\t   if(r==0){\n\t       return 1;\n\t   }\n\t   int num=fact[n];\n\t   int denom1=fact[n-r];\n\t   int denom2=fact[r];\n\t   int ans=(int)( ( 1L*num*power(denom1,mod-2,mod) ) % mod );\n\t   ans=(int)( ( 1L*ans*power(denom2,mod-2,mod) ) % mod );\n\n\t   return ans;\n\t}\n\tpublic static int power(int a,int b,int c){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    int smallAns=power(a,b/2,c);\n\t    int ans=(int)((1L*(smallAns%c)*(smallAns%c))%c);\n\t    if(b%2!=0){\n\t        ans=(int)((1L*(ans%c)*(a%c))%c);\n\t    }\n\t    return ans;\n\t}\n\tpublic static void factorial(int x,int[] fact)\n\t{\n\t    int mod=1000000007;\n\t    int ans=1;\n\t    for(int i=1;i<=x;i++){\n\t        ans=(int)((1L*(i%mod)*(ans%mod))%mod);\n\t        fact[i]=ans;\n\t       // System.out.println(\"i is \"+i+\" fact is \"+fact[i]);\n\t    }\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "from math import factorial\n\ndef permut(a,b):\n\treturn factorial(a)/(factorial(b) * factorial(a - b))\n\n\nn = int(raw_input())\n\nballs = []\n\nfor i in xrange(n):\n\tnum = int(raw_input())\n\tballs.append(num)\n\ntotal = 1\n\nsum = balls[0]\n\nfor i in xrange(1,len(balls)):\n\ttotal *= permut(sum + balls[i] - 1 , balls[i] - 1)\n\tsum += balls[i]\n\nprint total % 1000000007\n\n\n#1 2 3 4\n\n# PERMUT(2 , 1)\n# PERMUT(5 , 2)\n# PERMUT(9 , 3)"
        },
        {
            "language": 3,
            "solution": "mx=1001\nmod=1000000007\nnCr=[[0 for i in range(mx)] for j in range(mx)]\nnCr[0][0]=1\nfor i in range(1,mx):\n    nCr[i][0]=1\n    for j in range(1,mx):\n        nCr[i][j]=nCr[i-1][j-1]+nCr[i-1][j]\n\nn=int(input())\nl=[]\nfor i in range(n):\n    l.append(int(input()))\nres=1\ntotal=0\nfor i in range(n):\n    res=(res*nCr[total+l[i]-1][l[i]-1])%mod\n    total+=l[i]\nprint(res)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.concurrent.*;\n\npublic final class kyoya_and_balls\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n\tstatic Random rnd=new Random();\n\tstatic long mod=(long)(1e9+7);\n\tstatic int maxn=(int)(1005);\n\t\n    public static void main(String args[]) throws Exception\n    {\n\t\tint n=sc.nextInt();int[] a=new int[n+1];\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\t\n\t\tlong[][] c=new long[maxn][maxn];c[0][0]=1;\n\t\t\n\t\tfor(int i=1;i<maxn;i++)\n\t\t{\n\t\t\tfor(int j=0;j<maxn;j++)\n\t\t\t{\n\t\t\t\tc[i][j]=c[i-1][j];\n\t\t\t\t\n\t\t\t\tif(j>0)\n\t\t\t\t{\n\t\t\t\t\tc[i][j]=(c[i-1][j-1]+c[i][j])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] dp=new long[n+1];dp[1]=1;int sum=a[1];\n\t\t\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tlong curr=dp[i-1];\n\t\t\t\n\t\t\tlong now=c[sum+a[i]-1][a[i]-1];\n\t\t\t\n\t\t\tdp[i]=(curr*now)%mod;\n\t\t\t\n\t\t\tsum+=a[i];\n\t\t}\n\t\t\n\t\tout.println(dp[n]);out.close();\n    }\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 1,
            "solution": "mod = 1000000007\n\nraspuns = 1\nv = []\nn = 0\n\ndef factorial( n ):\n    p = 1\n    for i in range( 1, n + 1 ):\n        p *= i\n    #print( n, \" -> \", p )\n    return p\n\ndef combinari( n, k ):\n    p = factorial( n ) / ( factorial( k ) * factorial( n - k ) )\n    #print( n, k, \" - > \", p )\n    return p\n\nk = input()\nfor i in range( k ):\n    x = input()\n    n += x\n    v.append( x )\n\nfor i in v[::-1]:\n    n -= 1\n    i -= 1\n    if i:\n        raspuns *= combinari( n, i )\n    n -= i\n\nraspuns %= mod\n\nprint( raspuns )"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint pow(long long t, long long n) {\n  if (n == 1) return t % 1000000007;\n  if (n % 2 == 0)\n    return pow((t * t) % 1000000007, n / 2);\n  else\n    return (t * pow(t, n - 1)) % 1000000007;\n}\nint mod_inv(int r) { return pow(r, 1000000007 - 2); }\nint C(int n, int r) {\n  if (r == 0) return 1;\n  return (long long)C(n - 1, r - 1) * n % 1000000007 * mod_inv(r) % 1000000007;\n}\nint H(int n, int r) { return C(n + r - 1, r); }\nint main() {\n  int n;\n  cin >> n;\n  long long ans = 1;\n  int total = 0;\n  while (n--) {\n    int tmp;\n    cin >> tmp;\n    ans = ans * H(total + 1, tmp - 1) % 1000000007;\n    total += tmp;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nlong long fp[1010], fc[1010], inv[1010];\nint n, a[1010], m;\nlong long f[1010][1010];\nlong long fpm(long long x, int y) {\n  long long res = 1;\n  for (; y; y >>= 1, x = x * x % mod)\n    if (y & 1) res = res * x % mod;\n  return res;\n}\nvoid update(long long& x, long long y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nlong long C[2010][2010];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 0; i <= 2000; i++) C[i][0] = 1;\n  for (int i = 1; i <= 2000; i++)\n    for (int j = 1; j <= 2000; j++)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n  long long ans = 1;\n  int s = 0;\n  for (int i = 1; i <= n; i++) {\n    ans *= C[s + a[i] - 1][s], ans %= mod;\n    s += a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int mod = (int)(1e9) + 7;\n\n    public static void main(String[] args) throws Exception{\n        int k = io.getInt();\n        long[][] dp = new long[1003][1003];\n        for(long[] dd: dp)\n            Arrays.fill(dd, -1);\n        long ans = 1;\n        List<Integer> cs = io.getIntegerArray(k);\n        int cum = cs.get(0);\n\n        for(int i = 1; i < k; i++){\n            cum += cs.get(i);\n            ans = (ans * comp(cum - 1, cum - cs.get(i), dp)) % mod;\n        }\n        System.out.println(ans);\n    }\n\n    public static long comp(int n, int r, long[][] dp){\n        if(dp[n][r] != -1)\n            return dp[n][r];\n\n        if(n == r || r == 0){\n            dp[n][r] = 1;\n            return 1;\n        }\n\n        dp[n][r] = (comp(n - 1, r - 1, dp) + comp(n - 1, r, dp)) % mod;\n        return dp[n][r];\n    }\n}\n\nclass IO {\n    private BufferedReader br = null;\n    private StringTokenizer st = null;\n\n    public IO() {\n        this(System.in);\n    }\n\n    public IO(InputStream is) {\n        this.br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    public List<String> getStringArray(int n) throws IOException {\n        if (n == 0)\n            return new ArrayList<>();\n        if (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            res.add(st.nextToken());\n        }\n        return res;\n    }\n\n    public String getString() throws IOException {\n        List<String> res = this.getStringArray(1);\n        return res.size() == 0 ? \"\" : res.get(0);\n    }\n\n    public List<Integer> getIntegerArray(int n) throws IOException {\n        if (n == 0)\n            return new ArrayList<>();\n        List<String> res = getStringArray(n);\n        return res.stream().map(Integer::parseInt).collect(Collectors.toList());\n    }\n\n    public Integer getInt() throws IOException {\n        List<Integer> res = this.getIntegerArray(1);\n        return res.size() == 0 ? 0 : res.get(0);\n    }\n\n    public List<Long> getLongArray(int n) throws IOException {\n        if (n == 0)\n            return new ArrayList<>();\n        List<String> res = getStringArray(n);\n        return res.stream().map(Long::parseLong).collect(Collectors.toList());\n    }\n\n    public Long getLong() throws IOException {\n        List<Long> res = this.getLongArray(1);\n        return res.size() == 0 ? 0L : res.get(0);\n    }\n\n    public List<Double> getDoubleArray(int n) throws IOException {\n        if (n == 0)\n            return new ArrayList<>();\n        List<String> res = getStringArray(n);\n        return res.stream().map(Double::parseDouble).collect(Collectors.toList());\n    }\n\n    public Double getDouble() throws IOException {\n        List<Double> res = this.getDoubleArray(1);\n        return res.size() == 0 ? 0.0 : res.get(0);\n    }\n} "
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static BigInteger count(int m, int n) {\n\t\tif(m == 0){\n\t\t\treturn new BigInteger(\"1\");\n\t\t}\n\t\tBigInteger cnt1 = new BigInteger(\"1\");\n\t\tBigInteger cnt2 = new BigInteger(\"1\");\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcnt1 = cnt1.multiply(new BigInteger(String.valueOf(m - i)));\n\t\t\tcnt2 = cnt2.multiply(new BigInteger(String.valueOf(n - i)));\n\t\t}\n\t\treturn cnt2.divide(cnt1).divideAndRemainder(new BigInteger(\"1000000007\"))[1];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint k = in.nextInt();\n\t\tBigInteger s = new BigInteger(\"1\");\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tint a = in.nextInt();\n\t\t\ts = s.multiply(count(sum, sum + a - 1));\n\t\t\tsum += a;\n\t\t}\n\t\tSystem.out.println(s.divideAndRemainder(new BigInteger(\"1000000007\"))[1].intValue());\n\t\tin.close();\n\t}\n}\n\n \t\t\t\t\t\t \t\t \t  \t  \t \t  \t\t\t\t \t  \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e6 + 100;\nlong long inv[maxn], pro[maxn], invpro[maxn];\nlong long a[maxn], sum[maxn], dp[maxn];\nvoid Prepare_C() {\n  inv[1] = 1;\n  for (int i = 2; i < maxn; i++)\n    inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;\n  pro[0] = invpro[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    pro[i] = pro[i - 1] * i % mod;\n    invpro[i] = invpro[i - 1] * inv[i] % mod;\n  }\n}\nlong long get_C(int n, int m) {\n  if (n < m) return 0;\n  return pro[n] * invpro[m] % mod * invpro[n - m] % mod;\n}\nint main() {\n  int k;\n  Prepare_C();\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n    sum[i] = sum[i - 1] + a[i];\n  }\n  dp[1] = 1LL;\n  for (int i = 2; i <= k; i++) {\n    dp[i] = dp[i - 1];\n    for (int j = 1; j < a[i]; j++) {\n      dp[i] +=\n          get_C(sum[i - 1] + a[i] - j - 1, a[i] - j) % mod * dp[i - 1] % mod;\n      dp[i] %= mod;\n    }\n  }\n  printf(\"%I64d\\n\", dp[k] % mod);\n}\n"
        },
        {
            "language": 4,
            "solution": "// package Mathematical;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ColoredBalls {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        long fact[]=new long[1000001];\n        int mod=1000000007;\n        fact[0]=1;\n        for(int i=1;i<=1000000;i++){\n            fact[i]=(fact[i-1]*i)%mod;\n        }\n        int a[]=new int[n];\n        for(int i=0;i<n;i++){\n            a[i]=Integer.parseInt(br.readLine());\n        }\n        int sum=a[0];\n        long ans=1;\n        for(int i=1;i<n;i++){\n            sum+=a[i];\n            long temp=compute(sum-1,a[i]-1,fact,mod);\n            ans=(ans*temp)%mod;\n//            System.out.println(ans);\n        }\n        System.out.println(ans);\n    }\n    public static long compute(int n,int r,long factorial[],int mod){\n        long num=factorial[n];\n        long den1=modexp(factorial[r],mod-2,mod);\n        long den2=modexp(factorial[n-r],mod-2,mod);\n        long den=(den1*den2)%mod;\n        return (num*den)%mod;\n    }\n    public static long modexp(long a,long power,int mod){\n        if(power==0){\n            return 1;\n        }\n        if(power==1){\n            return a;\n        }\n        long small=modexp(a,power/2,mod);\n        long ans=((small%mod)*(small%mod))%mod;\n        if(power%2!=0){\n            ans=((ans%mod)*(a%mod))%mod;\n        }\n        return ans;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md = 1e9 + 7;\nint k, n, c[1005][1005];\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i < 1005; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j < 1005; j++)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % md;\n  }\n  scanf(\"%d\", &k);\n  long long ans = 1;\n  while (k--) {\n    int x;\n    scanf(\"%d\", &x);\n    ans = (ans * c[n + x - 1][x - 1]) % md;\n    n += x;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class P309C{\n\n\t//[2, 2, 1]\n\n\tpublic static int mod = 1000000007;\n  public static int MAXN = 1010;\n\n\tpublic long dp(int [] arr, int ptr, int [] pre){\n\t\tlong[][] comb = new long[MAXN][MAXN];\n    comb[0][0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n      }\n    }\n\n\n\t\tlong [] dp = new long[arr.length];\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i < dp.length; ++i){\n\t\t\tdp[i] = (dp[i - 1]*(comb[pre[i] + arr[i] - 1][arr[i] - 1]))%mod;\n\t\t\t//System.out.println(dp[i]);\n\t\t}\n\t\treturn dp[dp.length - 1];\n\t}\n\n\n\tpublic void ans(int [] arr, int [] pre){\n\t\tlong ans = 0;\n\t\tSystem.out.println(dp(arr, arr.length - 1, pre)%mod);\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tP309C main = new P309C();\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = Integer.parseInt(scanner.nextLine());\n\t\tint [] arr = new int[n + 1];\n\t\tint [] pre = new int[n + 1];\n\t\tpre[0] = 0;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tarr[i] = Integer.parseInt(scanner.nextLine());\n\t\t\tif(i >= 1) pre[i] = (pre[i - 1] + arr[i - 1]);\n\t\t}\n\t\tmain.ans(arr, pre);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nvector<long long> sil;\nlong long fme(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b % 2 == 1) return (fme(a, b - 1) * a) % MOD;\n  long long tmp = fme(a, b / 2);\n  return (tmp * tmp) % MOD;\n}\nlong long nck(long long n, long long k) {\n  if (k < 0 || k > n) return 0;\n  return ((sil[n] * fme(sil[k], MOD - 2) % MOD) * fme(sil[n - k], MOD - 2)) %\n         MOD;\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  sil.resize(2002);\n  sil[0] = 1;\n  for (long long i = 1; i < sil.size(); i++) sil[i] = (i * sil[i - 1]) % MOD;\n  int n;\n  cin >> n;\n  long long res = 1;\n  long long curSiz = 0;\n  vector<int> tab(n);\n  for (int i = 0; i < n; i++) {\n    cin >> tab[i];\n    res = res * nck(curSiz + tab[i] - 1, tab[i] - 1) % MOD;\n    curSiz += tab[i];\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int jie[1000001], n, a[1001], sum, ans;\nlong long int fast(long long int x, long long int y) {\n  long long int z = 1;\n  while (y) {\n    if (y & 1) z = (z * x) % 1000000007;\n    x = x * x % 1000000007;\n    y >>= 1;\n  }\n  return z;\n}\nlong long int zuhe(long long int nn, long long int mm) {\n  return ((jie[nn] % 1000000007) *\n          (fast((jie[mm] * jie[nn - mm]) % 1000000007, 1000000007 - 2) %\n           1000000007)) %\n         1000000007;\n}\nint main() {\n  int i;\n  jie[0] = 1;\n  for (i = 1; i < 1000001; i++) jie[i] = (jie[i - 1] * i) % 1000000007;\n  while (scanf(\"%I64d\", &n) != EOF) {\n    sum = 0;\n    ans = 1;\n    for (i = 1; i <= n; i++) {\n      scanf(\"%I64d\", &a[i]);\n      sum = sum + a[i];\n    }\n    for (i = n; i >= 1; i--) {\n      ans = ((ans % 1000000007) * (zuhe(sum - 1, a[i] - 1) % 1000000007)) %\n            1000000007;\n      sum = sum - a[i];\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n@Author Enes \u00c7ank\u0131r\u0131\n\t\t\t\t\t\u00a92015\n */\n\npublic class Main {\n\tstatic long mod = 1000000000+7;\n\tstatic long addMod( long a, long b )\n\t{\n\t\treturn ((a%mod)+(b%mod))%mod;\n\t}\n\n\tstatic long mulMod( long a, long b )\n\t{\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\n\t\tint v[] = new int[1001];\n\t\tlong c[][] = new long[1001][1001];\n\t\tfor(int i=0;i<=1000;++i){\n\t\t\tfor(int j=0;j<=i;++j){\n\t\t\t\tif(i == j || j == 0 ){\n\t\t\t\t\tc[i][j] = 1L;\n\t\t\t\t}else{\n\t\t\t\t\tc[i][j] = addMod(c[i-1][j],c[i-1][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint n = scn.nextInt();\n\t\tfor(int i=0;i<n;++i)\n\t\t{\n\t\t\tint x = scn.nextInt();\n\t\t\tv[i] = x;\n\t\t}\n\t\tint sum = 0;\n\t\tlong ans = 1;\n\t\tfor(int i=0;i<n;++i)\n\t\t{\n\t\t\tsum += v[i];\n\t\t\tans = mulMod( ans, c[sum-1][v[i]-1] );\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t\tscn.close();\n\t}\n\n\tpublic static int result;\n\n\tpublic static void solve(String m, int[] counts){\n\t\tboolean flag = true;\n\t\tfor (int i = 0; i < counts.length; i++) {\n\t\t\tif(counts[i] != 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!flag){\n\t\t\tfor (int i = 0; i < counts.length; i++) {\n\t\t\t\tif(counts[i] != 0) {\n\t\t\t\t\tif(i >= counts.length - 1 || counts[i+1] >= 1){\n\t\t\t\t\t\tint[] newCounts = counts.clone();\n\t\t\t\t\t\tnewCounts[i]--;\n\t\t\t\t\t\tString newM = m;\n\t\t\t\t\t\tnewM += \" \" + (i+1);\n\t\t\t\t\t\tsolve(newM, newCounts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tresult++;\n\t\t\t//System.out.println(m);\n\t\t}\n\t}\n\n\tpublic static int fact(int n){\n\t\tint x = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx *= i;\n\t\t\tx = x % 1000000007;\n\t\t}\n\t\treturn x;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class p553a {\n    public static int N = 0;\n    public static int K;\n    public static int MAX = 20010;\n    public static long mod = 1000000007L;\n    public static int dp;\n    public static int[] fac = new int[MAX + 1];\n    public static int[] invfac = new int[MAX + 1];\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        K = in.nextInt();\n        dp = 1;\n        prec();\n        int c = in.nextInt();\n        for (int i = 2; i <= K; i++) {\n            int d = in.nextInt();\n            c += d;\n            dp = (int)((long)dp * (long)C(c - 1, d - 1) % mod);\n        }\n        out.println(dp);\n        out.close();\n    }\n\n    public static void prec() {\n        fac[0] = 1; fac[1] = 1;\n        invfac[0] = 1; invfac[1] = 1;\n        for (int i = 2; i <= MAX; i++) {\n            fac[i] = (int)((long)fac[i - 1] * (long)i % mod);\n        }\n        invfac[MAX] = (int)pow((long)fac[MAX], mod - 2, mod);\n        for (int i = MAX; i > 2; i--) {\n            invfac[i - 1] = (int)((long)invfac[i] * (long)i % mod);\n        }\n    }\n\n    public static int C(int n, int k) {\n        if (k > n) {\n            return 0;\n        }\n        int res = (int)((long)fac[n] * (long)invfac[k] % mod);\n        res = (int)((long)res * (long)invfac[n - k] % mod);\n        return res;\n    }\n\n    public static long pow(long a, long p, long n) {\n        long r = a % n;\n        if (p == 0) {\n            return 1;\n        }\n        if (p == 1) {\n            return r;\n        }\n        if (p % 2 == 1) {\n            r = pow(a, p / 2, n) % n;\n            r = r * r % n;\n            return r * a % n;\n        } else {\n            r = pow(a, p / 2, n) % n;\n            r = r * r % n;\n            return r;\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        public boolean hasMoreElements() {\n            while (tokenizer == null || !tokenizer.hasMoreElements()) {\n                String s;\n                try {\n                    s = reader.readLine();\n                } catch (IOException e) {\n                    return false;\n                }\n                tokenizer = new StringTokenizer(s);\n            }\n            return tokenizer.hasMoreElements();\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int *arr = new int[n];\n  int *csum = new int[n];\n  int **pascal = new int *[1001];\n  for (int i = 0; i < 1001; i++) {\n    pascal[i] = new int[1001];\n    for (int j = 0; j < 1001; j++) {\n      if (j > i)\n        pascal[i][j] = 0;\n      else if (i == j)\n        pascal[i][j] = 1;\n      else if (j == 0)\n        pascal[i][j] = 1;\n      else {\n        pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]) % 1000000007;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    if (i == 0)\n      csum[i] = arr[i];\n    else\n      csum[i] = csum[i - 1] + arr[i];\n  }\n  long long int sum = 1;\n  for (int i = 1; i < n; i++) {\n    sum = (sum * pascal[csum[i - 1] + arr[i] - 1][csum[i - 1]]) % 1000000007;\n  }\n  cout << sum << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k,md,s,res=int(input()),1000000007,int(input()),1\nc=[[1]+[0]*1000 for i in range(1001)]\nfor i in range(1,1001):\n\tfor j in range(1,i+1):\n\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%md\nfor i in range(1,k):\n\tx=int(input())\n\ts+=x\n\tres=(res*c[s-1][x-1])%md\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[1010][1010];\nvoid init() {\n  for (long long i = 0; i <= 1005; i++) {\n    c[i][0] = c[i][i] = 1;\n    for (long long j = 1; j < i; j++)\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % 1000000007;\n  }\n}\nsigned main() {\n  init();\n  long long n;\n  cin >> n;\n  long long tot = 0, ans = 1;\n  for (long long i = 0; i < n; i++) {\n    long long tmp;\n    cin >> tmp;\n    if (tot) {\n      ans *= c[tot + tmp - 1][tmp - 1];\n      ans %= 1000000007;\n      tot += tmp;\n    } else\n      tot += tmp;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint C[1001][1001];\nint main() {\n  for (int i = 0; i < 1001; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j < i; ++j) {\n      C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n      if (C[i][j] >= mod) C[i][j] -= mod;\n    }\n    for (int j = i; j < 1001; ++j) C[i][j] = C[i][j - i];\n  }\n  int n;\n  scanf(\"%d\", &n);\n  long long ans = 1;\n  int cnt = 0;\n  while (n--) {\n    int x;\n    scanf(\"%d\", &x);\n    ans = ans * C[cnt + x - 1][x - 1] % mod;\n    cnt += x;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\n#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq\nimport math, string\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\n\"\"\"\nNumber of ways to position ith ball is (C1+C2+...+Ci - 1) choose (Ci - 1)\n\n\n\"\"\"\nfacs = [1]\ncurr = 1\nfor j in range(1,10**6+1):\n    curr *= j\n    curr %= MOD\n    facs.append(curr)\n\ndef solve():\n    N = getInt()\n    cols = []\n    pref = []\n    curr = 0\n    for i in range(N):\n        x = getInt()\n        curr += x\n        cols.append(x)\n        pref.append(curr)\n    dp = 1\n    for j in range(1,N):\n        tot = pref[j]\n        mult = facs[tot-1]*pow(facs[cols[j]-1], MOD-2, MOD)*pow(facs[pref[j-1]],MOD-2,MOD)\n        dp *= mult\n        dp %= MOD\n    return dp\n    \n    \n#for _ in range(getInt()):\nprint(solve())"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\nimport java.util.TreeSet;\n\n\n\npublic class Q1 {\n\t\n\tpublic static long ncr[][];\n\tpublic static void main(String[] args) {\n        FasterScanner s= new FasterScanner();\n        PrintWriter out=new PrintWriter(System.out);\n        \n        ncr=new long[1100][1100];\n\t\tlong mod=1000000007;\n        for(int i=0;i<ncr.length;i++)\n        {\n        \tncr[i][i]=1;\n        \tncr[i][0]=1;\n        \tfor(int j=1;j<i;j++)\n        \t{\n        \t\tncr[i][j]=(ncr[i-1][j]+ncr[i-1][j-1])%mod;\n        \t}\n        }\n        \n        int k=s.nextInt();\n        long a[] = s.nextLongArray(k);\n        \n        long answer=1;\n        long fixed=a[0];\n        for(int i=1;i<k;i++)\n        {\n        \tanswer*=ncr[(int) (fixed+a[i]-1)][(int) (a[i]-1)];\n        \tanswer%=mod;\n        \tfixed+=a[i];\n        }\n        \t\n        System.out.println(answer);\n        \n    }\n\t\n\tpublic static  long nCr(long n,long k)\n\t{\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\tlong ans=1;\n\t\tlong mod=1000000007;\n\t\tlong i=0;\n\t\twhile(i<k)\n\t\t{\n\t\t\tans*=n-i;\n\t\t\tans/=i+1 ;\n\t\t\ti++;\n\t\t\tans%=mod;\n\t\t}\n\t\t\t\n//\t\tSystem.out.println(n+\" \"+k+\" \"+ans);\n\t\tans%=mod;\n\t\treturn ans;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tprivate static long gcd(long a, long b)\n\t{\n\t    while (b > 0)\n\t    {\n\t        long temp = b;\n\t        b = a % b; // % is remainder\n\t        a = temp;\n\t    }\n\t    return a;\n\t}\nstatic class FasterScanner {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = System.in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n           \n        public int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n       \n        public long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def binomialCoefficient(n, k):  \n    if(k > n - k): \n        k = n - k  \n    res = 1\n    for i in range(k): \n        res = res * (n - i) \n        res = res // (i + 1) \n    return res \nk=int(input())\nsum=0\nans=1 \nm=1000000007\nfor i in range(k):\n    a=int(input())\n    ans=(ans%m)*(binomialCoefficient(sum+a-1,a-1))%m \n    sum+=a \nprint(ans)    \n    \n    "
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Proezd {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\tScanner in=new Scanner(System.in);\n\tint a=in.nextInt();\n        int[] shari=new int[a];\n        for (int i=0;i<a;i++)\n        {shari[i]=in.nextInt();}\n        long variants=1;\n       int l=shari[0];\n       for (int i=1;i<a;i++)\n       {\n       long n=merge2(l,shari[i]-1);\n       l=l+shari[i];\n       variants=(variants*n)%1000000007;\n       \n       }\n       System.out.print(variants);\n        }\n     \n      public static long merge(int a,int b)\n      { long sum=0; \n      long totalsum=0;\n      for (int i=0;i<a;i++)\n      {for (int j=1;j<=b;j++)\n      { sum+=posit(j,i);}\n      totalsum+=sum;\n      sum=0;\n      }\n      totalsum+=1;\n      \n      return totalsum;\n      }\n      public static long merge2(int a,int b)\n      {\n          long[] z=new long[a+1];\n          long[] increment=new long[a+1];\n          int c=0;\n          while (c<=b){\n      for (int i=0;i<=a;i++)\n      {if (c==0)\n          z[i]=1;\n      else if (i!=0) z[i]=(z[i-1]+increment[i])%1000000007;\n          }\n      for (int i=0;i<a+1;i++)\n      increment[i]=z[i];\n          c++;\n          }\n      return z[a];\n      }\n     \n      public static long posit(int m,int round)\n      {\n          int z=m;\n          if (round==0) return 1;\n          long sum=0;\n          for (int i=1;i<=m;i++)\n              sum+=posit(i,round-1);\n          \n          return sum;\n      }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1234567;\nlong long dp[1005], A[1005], fact[1005], inv[1005];\nlong long fast_pow(long long x, long long n) {\n  long long prod = 1;\n  while (n) {\n    if (n & 1) prod = prod * x % 1000000007;\n    x = x * x % 1000000007;\n    n >>= 1;\n  }\n  return prod;\n}\nvoid factorial() {\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    fact[i] = fact[i - 1] * i % 1000000007;\n  }\n}\nvoid mmi() {\n  for (int i = 0; i <= 1000; i++) inv[i] = fast_pow(fact[i], 1000000007 - 2);\n}\nlong long nCr(long long n, long long r) {\n  if (r > n) return 0;\n  if (r == 0) return 1;\n  return fact[n] * (inv[n - r] * inv[r] % 1000000007) % 1000000007;\n}\nint main() {\n  factorial();\n  mmi();\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> A[i];\n  long long sum = 0;\n  dp[0] = 1;\n  dp[1] = 1;\n  for (int i = 1; i <= k; i++) {\n    dp[i] = dp[i - 1] * nCr(sum + A[i] - 1, A[i] - 1) % 1000000007;\n    sum += A[i];\n  }\n  if (dp[k] < 0) dp[k] += 1000000007;\n  cout << dp[k];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static int mod = 1000000007;\n  public static int MAXN = 1010;\n  \n  public static void main (String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out, true);\n    \n    long[][] comb = new long[MAXN][MAXN];\n    comb[0][0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n      }\n    }\n    \n    int K = in.nextInt();\n    int[] color = new int[K];\n    for (int i = 0; i < K; i++) color[i] = in.nextInt();\n    \n    long res = 1;\n    int total = 0;\n    for (int i = 0; i < K; i++) {\n      res = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n      total += color[i];\n    }\n    \n    out.println(res);\n    out.close();\n    System.exit(0);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author George Marcus\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    private static final int MOD = 1000000007;\n    private static final int MAX = 1005;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int K = in.nextInt();\n        int[] C = new int[K];\n        int N = 0;\n        for (int i = 0; i < K; i++) {\n            C[i] = in.nextInt();\n            N += C[i];\n        }\n        int[][] comb = new int[MAX][MAX];\n        for (int i = 0; i < MAX; i++) {\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n                if (comb[i][j] >= MOD) {\n                    comb[i][j] -= MOD;\n                }\n            }\n        }\n        int sum = 0;\n        long ans = 1;\n        for (int i = 0; i < K; i++) {\n            ans = ans * comb[sum + C[i] - 1][C[i] - 1] % MOD;\n            sum += C[i];\n        }\n\n        out.println(ans);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "ans = 1\nn = int(input())\ns = int(input())\nmod = 1000000007\nfor _ in range(1, n):\n    now = int(input())\n    s += now\n    k = 1\n    for i in range(now - 1):\n        k = k * (s - 1 - i) // (i + 1)\n    ans = ans * k % mod\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10001;\nconst int P = 1e9 + 7;\ninline void add(int& a, int b) {\n  a += b;\n  if (a >= P) a -= P;\n}\ninline void mul(int& a, int b) { a = (long long)a * b % P; }\ninline int inver(int x) {\n  int ret = 1, y = P - 2;\n  while (y) {\n    if (y & 1) mul(ret, x);\n    mul(x, x);\n    y >>= 1;\n  }\n  return ret;\n}\nint fac[N], inv[N];\nvoid pre() {\n  fac[0] = inv[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fac[i] = i;\n    mul(fac[i], fac[i - 1]);\n  }\n  inv[N - 1] = inver(fac[N - 1]);\n  for (int i = N - 2; i > 0; i--) {\n    inv[i] = inv[i + 1];\n    mul(inv[i], i + 1);\n  }\n}\nint main() {\n  pre();\n  int k, x;\n  scanf(\"%d\", &k);\n  int ans = 1;\n  int tot = 0;\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d\", &x);\n    int tmp = 1;\n    mul(tmp, fac[tot + x - 1]);\n    mul(tmp, inv[tot]);\n    mul(tmp, inv[x - 1]);\n    mul(ans, tmp);\n    add(tot, x);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "c = []\nk = int(input())\nfor i in range(k):\n    c.append(int(input()))\n\nmaxN = 1010\nbinomials = [[1], [1, 1]]\nfor i in range(2, maxN):\n    binomials.append([1])\n    for j in range(1, i):\n        binomials[i].append((binomials[i - 1][j - 1] + binomials[i - 1][j]) % 1000000007)\n    binomials[i].append(1)\n\ndp = [1] * k\nfor i in range(1, k):\n    dp[i] = (dp[i - 1] * binomials[sum(c[:i + 1]) - 1][c[i] - 1]) % 1000000007\n\nprint(dp[k - 1])\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * Created by Tejas on 18-06-2018.\n */\npublic class Main {\n\n    static int MOD=(int)1e9+7;\n    static int x[];\n    static int dp[][];\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        int k = Integer.parseInt(bufferedReader.readLine());\n        int temp=k;\n        x=new int[k];\n        int index=0;\n        int total=0;\n        int max=0;\n        while (k-- > 0) {\n            x[index++] = Integer.parseInt(bufferedReader.readLine()) - 1;\n            if(max< x[index-1]+1)\n                max=x[index-1]+1;\n            total+=x[index-1]+1;\n        }\n        dp=new int[total+1][max];\n        choose(total+1,max);\n        System.out.println(solve(total,temp));\n    }\n\n    private static int solve(int n,int k) {\n        long result=1;\n        fact(n-k);\n        for(int i=k-1;i>=k/2;i--){\n            int remp=x[i];\n            x[i]=x[k-i-1];\n            x[k-i-1]=remp;\n        }\n       /* for(int i=0;i<k;i++)\n            if(x[i]!=0)\n                result=multMod(result,x[i]);\n*/\n\n        /*for(int i=0;i<k;i++)\n            if(x[i]!=0)\n                result=multMod(result,inv(x[i]));\n*/\n\n        int r=n;\n        for (int i = 0; i <k-1 ; i++) {\n            if(x[i]!=0) {\n                result = multMod(result, dp[r-1][x[i]]);\n                r = r - x[i] - 1;\n            }\n            else\n                r--;\n        }\n\n\n\n\n        return (int) (result%MOD);\n    }\n\n    private static void choose(int rows, int cols) {\n\n\n        for(int i=0;i<Math.min(cols,rows);i++)\n            dp[i][i]=1;\n        for(int i=0;i<rows;i++)\n            dp[i][0]=1;\n\n        for(int i=1;i<rows;i++)\n            for(int j=1;j<cols;j++)\n                dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%MOD;\n\n    }\n\n    private static int inv(int num) {\n            int m0 = MOD;\n            int y = 0, x = 1;\n\n            if (m0 == 1)\n                return 0;\n\n            while (num > 1) {\n                int q = num / m0;\n                int t = m0;\n                m0 = num % m0;\n                num = t;\n                t = y;\n                y = x - q * y;\n                x = t;\n            }\n\n            if (x < 0)\n                x += MOD;\n\n            return x;\n\n\n    }\n\n    private static long multMod(long result, int x) {\n\n        if(result==0)\n            return 0;\n        result = result%MOD;\n        return (result*x)%MOD;\n    }\n\n    private static long fact(int x){\n\n        long ans=1;\n\n        for(int i=1;i<=x;i++){\n            ans=(ans*i)%MOD;\n        }\n        return ans%MOD;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint balls[1000 + 1];\nlong long int d[1000 + 1][1000 + 1];\nint main(int argc, const char* argv[]) {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &balls[i]);\n    balls[i] += balls[i - 1];\n  }\n  for (int i = 0; i <= 1000; i++) {\n    d[0][i] = d[i][0] = 1;\n  }\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 1; j <= 1000; j++) {\n      d[i][j] = d[i - 1][j] + d[i][j - 1];\n      d[i][j] %= 1000000007;\n    }\n  }\n  long long int possibilities = 1;\n  for (int i = 1; i <= n; i++) {\n    possibilities *= d[balls[i - 1]][balls[i] - balls[i - 1] - 1];\n    possibilities %= 1000000007;\n  }\n  printf(\"%lld\\n\", possibilities);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def c(k,l):\n    d=1\n    for i in range(k+1,l+k+1): d*=i\n    for i in range(l): d//=(i+1)\n    return d%1000000007\n    \nans=1\nn=int(input())\nk=int(input())\nfor t in range(1,n):\n    a=int(input())\n    ans*=c(k,a-1)%1000000007\n    k+=a\nprint(ans%1000000007)\n    "
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class C {\n\n    private static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        s.nextLine();\n        int[] ka = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ka[i] = s.nextInt();\n            s.nextLine();\n        }\n\n\n        BigInteger result = BigInteger.ONE;\n        long len = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int k = ka[i];\n\n            result = result.multiply(cnnk(k - 1, len + 1).mod(new BigInteger(String.valueOf(MOD))));\n            len += k;\n        }\n\n        System.out.println(result.mod(new BigInteger(String.valueOf(MOD))));\n    }\n\n    private static BigInteger cnnk(long items, long pos) {\n        if (items == 0 || pos == 0) {\n            return BigInteger.ONE;\n        }\n        return cnk(items, items + pos - 1);\n    }\n\n    private static BigInteger cnk(long items, long pos) {\n        long high = Math.max(items, pos);\n        long low = Math.min(items, pos);\n\n        BigInteger highr = new BigInteger(\"1\");\n        BigInteger lowr = new BigInteger(\"1\");\n        for (long i = 0; i < low; ++i) {\n            highr = highr.multiply(new BigInteger(String.valueOf(high)));\n            lowr = lowr.multiply(new BigInteger(String.valueOf(i + 1)));\n            --high;\n        }\n        return highr.divide(lowr);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Cfone {\n\tstatic final long mod = 1000000007;\n\tstatic long[] fact = new long[1000010];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong[] col = new long[1010];\n\t\tlong sum = 0;\n\t\tfact[0] = 1;\n\t\tfor ( long i = 1 ; i<=1000000 ; ++i ) {\n\t\t\tfact[(int) i] = fact[(int) (i-1)] * i;\n\t\t\tfact[(int) i] %= mod;\n\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tfor ( int i = 1 ; i<=n ; ++i ) {\n\t\t\t\tcol[i] = sc.nextLong();\n\t\t\t\tsum += col[i];\n\t\t\t}\n\t\t\tlong res = 1;\n\t\t\tfor ( int i = n ; i>=1 ; --i ) {\n\t\t\t\tres *= cal( sum-1 , col[i]-1 );\n\t\t\t\tres %= mod;\n\t\t\t\tsum -= col[i];\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tpublic static long cal( long n , long m ) {\n\t\tif ( n==m || m==0 ) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn fact[(int)n] * fastpow(fact[(int)m]*fact[(int)(n-m)]%mod,mod-2)%mod;\n\t}\n\tpublic static long fastpow(long x,long y) {\n\t\tlong res = 1;\n\t\twhile ( y>0 ) {\n\t\t\tif ( (y&1)==1 ) {\n\t\t\t\tres *= x;\n\t\t\t\tres %= mod;\n\t\t\t}\n\t\t\tx *= x;\n\t\t\tx %= mod;\n\t\t\ty >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long comb[4001][4001];\nint main() {\n  int i, j;\n  for (i = 0; i < 4001; i++) comb[i][0] = comb[0][i] = comb[i][i] = 1;\n  for (i = 1; i < 4001; i++)\n    for (j = 1; j < i; j++)\n      comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\n  int n;\n  cin >> n;\n  long long ans = 1, k, spaces = 0, t;\n  cin >> k;\n  for (i = 1; i < n; i++) {\n    spaces += k;\n    cin >> k;\n    ans = (ans * comb[spaces + k - 1][k - 1]) % 1000000007;\n  }\n  cout << ans;\n  cin >> i;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    from math import factorial as f\n    n, res = 0, 1\n    for _ in range(int(input())):\n        m = int(input())\n        res = res * f(n + m - 1) // f(n) // f(m - 1) % 1000000007\n        n += m\n    print(res)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by ankeet on 6/21/16.\n */\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class C554 {\n\n    public static BufferedReader read = null;\n    public static PrintWriter out = null;\n    public static StringTokenizer token = null;\n\n    public static long powmod(long a, long b, long m)\n    {\n        if(b == 0) return 1;\n        if(b == 1) return a %m;\n        long c = powmod(a, b/2, m);\n        c = c * c % m;\n        if(b%2 == 1) c = c * a %m;\n        return c % m;\n    }\n    public static void solve()\n    {\n        long mod = 1000000000+7;\n        int k = nint();\n        int[] c = narr(k);\n        int n = 1000010;\n        long[] f = new long[n];\n        f[0] = 1;\n        long[] finv = new long[n];\n        finv[0] = 1;\n        for(int i=1; i<n; i++)\n        {\n            f[i] = f[i-1] * i % mod;\n            finv[i] = powmod(f[i], mod-2, mod);\n        }\n\n        long w = 1;\n        int sofar = c[0];\n        for(int i=1; i<k; i++)\n        {\n            int tup = sofar+1;\n            int tupsum = c[i]-1;\n            w = w * f[tupsum+tup-1] % mod;\n            w = w * finv[tup-1] % mod;\n            w = w * finv[tupsum] % mod;\n            sofar+=c[i];\n\n        }\n        out.println(w % mod);\n    }\n\n    public static void main(String[] args)\n    {\n        read = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n        out.close();\n\n    }\n\n    // i/o functions\n    public static String next() // returns the next string\n    {\n        while(token == null || !token.hasMoreTokens())\n        {\n            try {\n                token = new StringTokenizer(read.readLine());\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        return token.nextToken();\n    }\n\n    public static int nint()\n    {\n        return Integer.parseInt(next());\n    }\n    public static long nlong()\n    {\n        return Long.parseLong(next());\n    }\n    public static double ndouble()\n    {\n        return Double.parseDouble(next());\n    }\n    public static int[] narr(int n)\n    {\n        int[] a = new int[n];\n        for(int i=0; i<n; i++) a[i] = nint();\n        return a;\n    }\n\n    public static long[] nal(int n)\n    {\n        long[] a = new long[n];\n        for(int i=0; i<n; i++) a[i] = nlong();\n        return a;\n    }\n\n\n}\n\n\n\n"
        },
        {
            "language": 1,
            "solution": "def find(a,b):\n    f1=fact(a)\n    f2=fact(b)\n    f3=fact(a-b)\n    return f1/(f2*f3)\ndef fact(a):\n    f=1\n    for i in range(1,a+1):\n        f*=i\n    return f\nn=input()\ndp=[0]*n\ndp[0]=1\ncol=[]\nfor i in range(n):\n    col.append(input())\ns=col[0]\nfor i in range(1,n):\n    s=s+col[i]\n    res=find(s-1,col[i]-1)\n    dp[i]=(dp[i-1]*res)%1000000007\nprint dp[n-1]\n"
        },
        {
            "language": 3,
            "solution": "import math as ma\nm=10**9+7\nn=int(input())\na=[]\nfor i in range(n):\n    a.append(int(input()))\nb=a[0]\nc=1\nfor i in range(1,n):\n    c=((c*((ma.factorial(b+a[i]-1))//(ma.factorial(b)*ma.factorial(a[i]-1)))%m))\n    b=(b+a[i])%m\nprint(c)"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class KyoyaColorBalls_554C {\npublic static void main(String args[]){\n\tScanner sc=new Scanner(System.in);\n\tint num=sc.nextInt();\n\tint colorArr[]=new int[num];\n\tint i=0,sum=0;\n\tBigInteger ans=BigInteger.valueOf(1);\n\t// denom=BigInteger.valueOf(1);\n\t//System.out.println(x.mod(BigInteger.valueOf(1000000007)));\n\twhile(i<num){\n\t\tcolorArr[i]=sc.nextInt();\n\t\tsum+=colorArr[i];\n\t\tBigInteger numer=factorial(sum-1);\n\t\t\n\t\tBigInteger denom=factorial(colorArr[i]-1).multiply(factorial((sum-1)-(colorArr[i]-1)));\n\t\t//System.out.println(denom);\n\t\t\n\t\tans=ans.multiply(numer.divide(denom));\n\t\ti++;\n\t}\n\tSystem.out.println(ans.mod(BigInteger.valueOf(1000000007)));\n\t\n}\npublic static BigInteger factorial(int xNum){\n\tBigInteger fac=BigInteger.valueOf(1);\n\tint i=xNum;\n\tif(i==0)\n\t\treturn BigInteger.valueOf(1);\n\twhile(i>0){\n\t\tfac=fac.multiply(BigInteger.valueOf(i));\n\t\t//System.out.println(i+\" \"+fac);\n\t\ti--;\n\t}\n\treturn fac;\n\t\n}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int MOD = 1000 * 1000 * 1000 + 7;\n\n\tpublic static void shuffleArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp = arr[i];\n\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\tarr[i] = arr[randomPos];\n\t\t\tarr[randomPos] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tsolve(in, out);\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static void solve(InputReader in, PrintWriter out) {\n\n\t\tint k = in.nextInt();\n\t\tint n = 1001;\n\t\tlong[][] newt = new long[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnewt[i][0] = 1;\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tnewt[i][j] = (newt[i - 1][j - 1] + newt[i - 1][j]) % MOD;\n\t\t\t}\n\t\t}\n\n\t\tlong res = 1;\n\t\tint balls = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint ci = in.nextInt() - 1;\n\t\t\tres = (res * newt[balls + ci][ci]) % MOD;\n\t\t\tballs += ci + 1;\n\t\t}\n\t\tout.print(res);\n\t}\n\n\t/*\n\t * \n\t */\n\t// --------------------------------------------------------\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct T {\n  int a;\n};\nlong long int bigmod(long long int a, long long int b, long long int mod) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) {\n    long long int hh = bigmod(a, b / 2, mod);\n    return (hh * hh) % mod;\n  } else {\n    return (a * bigmod(a, b - 1, mod)) % mod;\n  }\n}\nlong long int ar[1000005], fact[1000005], ifac[1000005];\nint main() {\n  long long int i, j, k, l, t, cs = 1, r = 1, s, m, n, a, b, c, d, e, f, g, h,\n                               u, v, mod = 1000000007;\n  fact[0] = 1;\n  ifac[0] = bigmod(fact[0], mod - 2, mod);\n  for (i = 1; i <= 1000001; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    ifac[i] = bigmod(fact[i], mod - 2, mod);\n  }\n  scanf(\"%I64d\", &n);\n  long long int ans = 1;\n  s = 0;\n  for (i = 0; i < n; i++) {\n    scanf(\"%I64d\", &ar[i]);\n    s = s + ar[i];\n    if (i > 0) {\n      u = (ifac[ar[i] - 1] * ifac[s - 1 - ar[i] + 1]) % mod;\n      u = (fact[s - 1] * u) % mod;\n      ans = (ans * u) % mod;\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 7;\nlong long int mod = 1e9 + 7;\nlong long int comb[N][N], col[N];\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int k;\n  cin >> k;\n  comb[0][0] = 1;\n  for (int i = 0; i < k; ++i) {\n    cin >> col[i];\n  }\n  for (int i = 1; i < N; ++i) {\n    comb[i][0] = 1;\n  }\n  for (int i = 1; i < N; ++i) {\n    for (int j = 1; j < N; ++j) {\n      comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n      comb[i][j] %= mod;\n    }\n  }\n  long long int res = 1;\n  long long int tot = 0;\n  for (int i = 0; i < k; ++i) {\n    res *= comb[tot + col[i] - 1][col[i] - 1];\n    res %= mod;\n    tot += col[i];\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * _553A\n * O(1001^2) time\n * \u03b8(1001^2) space\n *\n * @author artyom\n */\npublic class _553A implements Runnable {\n    private static final int MOD = 1_000_000_007;\n    private BufferedReader in;\n    private PrintStream out;\n    private StringTokenizer tok;\n    private static final long[][] bc = new long[1001][1001];\n\n    private void solve() throws IOException {\n        long res = 1;\n        int k = nextInt(), l = nextInt();\n        for (int i = 1; i < k; i++) {\n            int c = nextInt();\n            res = res * bc(l + c - 1, l) % MOD;\n            l += c;\n        }\n        out.print(res);\n    }\n\n    private static long bc(int n, int k) {\n        if (bc[n][k] == 0) {\n            bc[n][k] = n == k || k == 0 ? 1 : (bc(n - 1, k) + bc(n - 1, k - 1)) % MOD;\n        }\n        return bc[n][k];\n    }\n\n    //--------------------------------------------------------------\n    public static void main(String[] args) {\n        new _553A().run();\n    }\n\n    @Override\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = System.out;\n            tok = null;\n            solve();\n            in.close();\n        } catch (IOException e) {\n            System.exit(0);\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private int[] readIntArray(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = nextInt();\n        }\n        return arr;\n    }\n\n    private static int getMax(int[] a) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0, n = a.length; i < n; i++) {\n            if (a[i] > max) {\n                max = a[i];\n            }\n        }\n        return max;\n    }\n\n    private static int getMin(int[] a) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0, n = a.length; i < n; i++) {\n            if (a[i] < min) {\n                min = a[i];\n            }\n        }\n        return min;\n    }\n}"
        },
        {
            "language": 1,
            "solution": "def fact(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans *= i\n    return ans\nn = 1\na = input()\ny = 0\nfor i in range(a):\n    x = input()\n    y += x\n    n *= (fact(y-1)/fact(x-1)/fact(y-x))\n    n = n % 1000000007\nprint n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine(), \" :\");\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    long[] f;\n\n    int mod = (int) 1e9 + 7;\n\n    long binpow(long x, int y) {\n        if (y == 0) return 1 % mod;\n        if (y % 2 == 0) {\n            long z = binpow(x, y / 2);\n            return (z * z % mod);\n        } else {\n            return x * binpow(x, y - 1) % mod;\n        }\n    }\n\n    long rev(long x) {\n        return binpow(x, mod - 2);\n    }\n\n    long c(int n, int k) {\n        return mul(mul(f[n], rev(f[k])), rev(f[n - k]));\n    }\n\n    long mul(long a, long b) {\n        return a * b % mod;\n    }\n\n    void solve() throws IOException {\n        f = new long[2000000];\n        f[0] = 1;\n        for (int i = 1; i < f.length; i++) {\n            f[i] = mul(f[i - 1], i);\n        }\n        int n = readInt();\n        long[] answer = new long[n + 1];\n        int[] a = readIntArray(n);\n        answer[1] = 1;\n        int sum = a[0];\n        for (int i = 2; i <= n; i++) {\n            answer[i] = mul(answer[i - 1], c(sum + a[i - 1] - 1, a[i - 1] - 1));\n            sum += a[i - 1];\n        }\n        out.println(answer[n]);\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        final long MOD = (long) 1e9 + 7;\n        int n = in.nextInt();\n\n        long[][] comb = new long[1001][1001];\n        comb[0][0] = 1;\n        for (int i = 1; i < 1001; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n            }\n        }\n        int[] k = in.nextIntArr(n);\n        long ans = 1;\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            total += k[i];\n            ans *= comb[total - 1][k[i] - 1];\n            ans %= MOD;\n        }\n        out.println(ans);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextIntArr(int n) {\n        int[] arrs = new int[n];\n        for (int i = 0; i < n; i++) {\n            arrs[i] = nextInt();\n        }\n        return arrs;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int ncr[1005][1005];\nvoid calculate() {\n  ncr[0][0] = 1;\n  for (int i = 1; i < 1005; ++i) {\n    for (int j = 0; j < 1005; ++j) {\n      if (i < j) {\n        ncr[i][j] = 0;\n        continue;\n      }\n      if (j == 0)\n        ncr[i][j] = 1;\n      else\n        ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % 1000000007;\n    }\n  }\n}\nint main() {\n  calculate();\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < 10; ++j) {\n    }\n  }\n  int k;\n  cin >> k;\n  int a[k + 1];\n  for (int i = 1; i <= k; ++i) {\n    cin >> a[i];\n  }\n  long long int f[k + 1];\n  f[1] = 1;\n  int sum = a[1];\n  for (int i = 2; i <= k; ++i) {\n    f[i] = ncr[sum + a[i] - 1][a[i] - 1] % 1000000007;\n    f[i] *= f[i - 1];\n    f[i] %= 1000000007;\n    sum += a[i];\n  }\n  cout << f[k] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package javaapplication1;\n\nimport java.math.BigInteger;\nimport static java.lang.System.out;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n    public class Main\n    {         \n        public static void main(String[] args) {\n        \n        Scanner in = new Scanner(System.in);\n        \n        final long mod = 1000000007;\n        \n        long cof[][] = new long [1005][1005];\n        \n        for(int i = 0 ; i < 1005 ; i ++)\n        {\n            cof[i][0] = cof[i][i] = 1;\n            \n            for(int j = 1 ; j < i ; j ++)\n                cof[i][j] = (cof[i - 1][j - 1] + cof[i - 1][j]) % mod;\n        }\n        \n        int k;\n        int c[] = new int [1005];\n        \n        k = in.nextInt();\n        \n        for(int i = 1 ; i <= k ; i ++)\n            c[i] = in.nextInt();\n        \n        long res = 1;\n        int sum = c[1];\n        \n        for(int i = 2 ; i <= k ; i ++)\n        {\n            res = res * cof[ sum + c[i] - 1 ][ c[i] - 1 ] % mod;\n            sum += c[i];\n        }\n        \n        out.println(res);\n    }\n\n           \n        \n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2020;\nconst long long MOD = 1000000007;\nlong long a[MAXN];\nlong long ncr[MAXN][MAXN];\nvoid myinit() {\n  ncr[0][0] = 1;\n  for (long long i = 1; i < MAXN; i++)\n    for (long long j = 0; j <= i; j++) {\n      ncr[i][j] = ncr[i - 1][j];\n      if (j > 0) ncr[i][j] = ((ncr[i][j] + ncr[i - 1][j - 1]) % MOD);\n    }\n}\nlong long mynhr(long long n, long long r) { return ncr[n + r - 1][r - 1]; }\nint main() {\n  myinit();\n  long long n;\n  cin >> n;\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  long long bucket = a[0] + 1;\n  long long ans = 1;\n  for (long long i = 1; i < n; i++) {\n    ans = (ans * mynhr(a[i] - 1, bucket)) % MOD;\n    bucket += a[i];\n  }\n  cout << (ans % MOD) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.TreeMap;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Collection;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Ankit Srivastava\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInReader in = new InReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    int n;\n    int c[], pre[];\n    int tot;\n    long MOD = (long) 1e9 + 7;\n    long C[][];\n    long dp[][];\n\n    long go(int i, int toBlock) {\n        if(dp[i][toBlock] != -1) return dp[i][toBlock];\n        if(i == tot - 1) {\n            if(toBlock == n - 1)\n                return 1;\n            else return 0;\n        }\n        if(i >= pre[toBlock] - 1) {\n            int open = i + 1;\n            if(toBlock > 0) open -= pre[toBlock - 1];\n            return dp[i][toBlock] = (C[open - 1][c[toBlock] - 1] * go(i + 1, toBlock + 1) % MOD + go(i + 1, toBlock)) % MOD;\n        }\n        else return dp[i][toBlock] = go(i + 1, toBlock);\n    }\n\n    public void solve(int testNumber, InReader in, OutputWriter out) {\n        C = IntegerUtils.generateBinomialCoefficients(1001, MOD);\n        n = in.readInt();\n        c = new int[n];\n        pre = new int[n];\n        for (int i = 0; i < n; i++) {\n            c[i] = in.readInt();\n            if(i > 0) pre[i] = pre[i - 1] + c[i];\n            else pre[i] = c[i];\n        }\n        tot = pre[n - 1];\n        dp = new long[tot][n];\n        ArrayUtils.fill2d(dp, -1);\n        out.printLine(go(0, 0));\n    }\n}\n\nclass InReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nclass IntegerUtils {\n\n    public static long gcd(long a, long b) {\n        a = Math.abs(a);\n        b = Math.abs(b);\n        while (b != 0) {\n            long temp = a % b;\n            a = b;\n            b = temp;\n        }\n        return a;\n    }\n\n    public static long[][] generateBinomialCoefficients(int n, long module) {\n        long[][] result = new long[n + 1][n + 1];\n        if (module == 1)\n            return result;\n        for (int i = 0; i <= n; i++) {\n            result[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n                if (result[i][j] >= module)\n                    result[i][j] -= module;\n            }\n        }\n        return result;\n    }\n\n\n}\n\nclass ArrayUtils {\n\n    public static void fill2d(long[][] array, long value) {\n        for (int i = 0; i < array.length; i++)\n            Arrays.fill(array[i], value);\n    }\n\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[1003];\nconst int mod = 1000000007;\nint comb[1005][1005], i, j;\nint main() {\n  int lim = 1002;\n  for (i = 1; i <= lim; i++) comb[i][i] = comb[i][0] = 1;\n  for (i = 2; i <= lim; i++)\n    for (j = 1; j < i; j++) {\n      long long aux = comb[i - 1][j] + comb[i - 1][j - 1];\n      aux %= mod;\n      comb[i][j] = aux;\n    }\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  long long ans = 1;\n  long long nr = a[1];\n  for (i = 2; i <= n; i++) {\n    int en = a[i] - 1;\n    ans = (1LL * ans * comb[en + nr][en]) % mod;\n    nr += a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import bisect\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport re\nimport sys\nimport itertools\n\ndef ni():\n    return int(raw_input())\n\ndef nis():\n    return map(int, raw_input().split())\n\ndef si():\n    return raw_input()\n\ndef sis():\n    return raw_input().split()\n\ndef spaced(a):\n    return ' '.join(map(str, a))\n\nMOD = 1000000007\n\nn = ni()\na = []\nfor _ in range(n):\n    a.append(ni())\n\nmax_balls = sum(a)\nnCr = [[1] for _ in range(max_balls + 1)]\n\nfor i in range(1, max_balls + 1):\n    row = nCr[i]\n    last_row = nCr[i - 1]\n    for j in range(1, i):\n        row.append((last_row[j - 1] + last_row[j]) % MOD)\n    row.append(last_row[i - 1])\n\nans = 1\nballs = 0\nfor i in range(n):\n    balls += a[i]\n    ans *= nCr[balls - 1][a[i] - 1]\n    ans %= MOD\n\nprint ans\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void umax(T &a, T b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void umin(T &a, T b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\ninline T max(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <class T>\ninline T min(T a, T b, T c) {\n  return min(a, min(b, c));\n}\nvector<vector<int> > ComputeCombination(int n) {\n  vector<vector<int> > res(n + 1, vector<int>(n + 1));\n  for (int i = 0; i <= n; i++) {\n    res[i][0] = 1;\n    res[i][i] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      res[i][j] = (res[i - 1][j] + res[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  return res;\n}\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int k, tmp;\n  cin >> k;\n  long long ans = 1;\n  int sum = 0;\n  vector<vector<int> > nCr = ComputeCombination(1010);\n  for (int i = 0; i < k; i++) {\n    cin >> tmp;\n    ans = (ans * nCr[sum + tmp - 1][tmp - 1]) % 1000000007;\n    sum += tmp;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k, c[1003], dp[1003][1003];\nlong long ans;\nint main() {\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  for (int i = 0; i < 1003; i++) {\n    for (int j = 0; j < 1003; j++) {\n      if (i == 0 || j == 0)\n        dp[i][j] = 1;\n      else\n        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n      dp[i][j] %= 1000000007;\n    }\n  }\n  ans = 1;\n  for (int i = 1; i <= k; i++) {\n    ans = (ans * dp[n][c[i] - 1]) % 1000000007;\n    n += c[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "mod = 10 ** 9 + 7\n\ndef fact(n):\n        res = 1\n        while n:\n                res = (res * n)\n                n -= 1\n        return res\n\nk = int(raw_input())\na = [int(raw_input()) for i in xrange(k)]\n\nans = 1\nball = a[0]\nfor ai in a[1:]:\n        ans = (ans * fact(ball + ai - 1) / fact(ball) / fact(ai - 1)) % mod\n        ball += ai\nprint ans\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class a309 {\n\n\tstatic class Task {\t\t\n\t\t\n\t\tpublic void Solve(InputReader in, PrintWriter out)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint arr[]=in.nextIntArray(n);\n\t\t\tint dp[]=new int[n];\n\t\t\tlong ans=1;\n\t\t\tdp[0]=arr[0];\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tdp[i]=dp[i-1]+arr[i];\n\t\t\t}\n\t\t\tlong bin[][]=new long[1001][1001];\n\t\t\tbin[0][0]=1;\n\t\t\tfor(int i=0;i<1001;i++){\n\t\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tbin[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(i==j){\n\t\t\t\t\t\tbin[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbin[i][j]=(bin[i-1][j]+bin[i-1][j-1])%1000000007;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=n-1;i>=0;i--)\n\t\t\t{\n\t\t\t\tans*=bin[dp[i]-1][arr[i]-1];\n\t\t\t\tans=ans%M;\n\t\t\t}\n\t\t\tout.println(ans);\n\t    }\n     }\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.Solve(in,out);\n        out.close();\n    }\n  \n    static int[][] sort2D(int arr[][]){\n        Arrays.sort(arr,new java.util.Comparator<int[]>(){\n        public int compare(int[] a, int[] b) {\n            return Integer.compare(a[0], b[0]);\n        }});\n        return arr;\n    }\n    \n    static long M=1000000000+7;\n    \n\tstatic int[] di={1,0,-1,0,1,-1,-1,1};\n\tstatic int[] dj={0,1,0,-1,1,1,-1,-1};\n    \n\tstatic class point{\n\t\tint x;int y;\n\t\tpublic point(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n    static void sort(int arr[]){\n\t\tint cnt[]=new int[(1<<16)+1];\n\t\tint ys[]=new int[arr.length];\t\n\t\tfor(int j=0;j<=16;j+=16){\n\t\t\tArrays.fill(cnt,0);\n\t\t\tfor(int x:arr){cnt[(x>>j&0xFFFF)+1]++;}\n\t\t\tfor(int i=1;i<cnt.length;i++){cnt[i]+=cnt[i-1];}\n\t\t\tfor(int x:arr){ys[cnt[x>>j&0xFFFF]++]=x;}\n\t\t\t{ final int t[]=arr;arr=ys;ys=t;}\n\t\t}\n\t\tif(arr[0]<0||arr[arr.length-1]>=0)return;\n\t\tint i,j,c;\n\t\tfor(i=arr.length-1,c=0;arr[i]<0;i--,c++){ys[c]=arr[i];}\n\t\tfor(j=arr.length-1;i>=0;i--,j--){arr[j]=arr[i];}\n\t\tfor(i=c-1;i>=0;i--){arr[i]=ys[c-1-i];}\n\t}\n    \n    static int lcm(int a,int b){return a*b/gcd(a,b);}\n    static int abs(int x){if(x>=0)return x;else return -x;}\n    static int gcd(int a,int b){return b==0?a:gcd(b,a%b);} \n    static int min(int x,int y){return x<y?x:y;}\n    static int min(int x,int y,int z){return x<y?(x<z?x:z):(y<z?y:z);}\n    static int max(int x,int y){return x>y?x:y;}\n    static int max(int x,int y,int z){return x>y?(x>z?x:z):(y>z?y:z);}\n    \n    static void joutArray(int arr[]){\n    \tfor(int i=0;i<arr.length;i++){\n    \t\tSystem.out.print(arr[i]+\" \");\n    \t}\n    \tSystem.out.println();\n    }\n    \n    static void joutArray(int arr[][],int n,int m){\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++)\n    \t\tSystem.out.print(arr[i][j]+\" \");\n    \t\tSystem.out.println();\n    \t}\n    \tSystem.out.println();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public String nextLine() {\n\t\t\tString fullLine=null;\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tfullLine=reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn fullLine;\n\t\t\t}\n\t\t\treturn fullLine;\n\t\t}\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() {\n        \treturn Long.parseLong(next());\n        }\n        \n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n        public int[] nextIntArray(int n) {\n        \tint arr[]=new int[n];\n        \tfor(int i=0;i<n;i++)\n        \t\tarr[i]=nextInt();\n        \treturn arr;\n        }\n        \n        public char[] nextCharArray(){\n        \tchar arr[]=next().toCharArray();\n        \treturn arr;\n        }\n        \n        public HashMap<Integer,Integer> inHashMap(int n){\n        \tHashMap<Integer,Integer> hm=new HashMap<>();\n        \tfor(int i=0;i<n;i++){\n    \t\t\tint num=nextInt();\n    \t\t\thm.put(num,hm.get(num)==null?1:hm.get(num)+1);\n    \t\t}\n        \treturn hm;\n        }\n     }\n    \n   }"
        },
        {
            "language": 4,
            "solution": "\n//package semanai;\nimport java.util.Scanner;\npublic class ColoredBalls {\n\n    public static void cBalls(){   \n        Scanner in = new Scanner(System.in);\n    \n    long[][] comb = new long[1010][1010];\n    comb[0][0] = 1;\n    for (int i = 1; i < 1010; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % 1000000007;\n      }\n    }\n    \n    int k = in.nextInt();\n    int[] color = new int[k];\n    for (int i = 0; i < k; i++) color[i] = in.nextInt();\n    \n    long res = 1;\n    int total = 0;\n    \n    for (int i = 0; i < k; i++) {\n      res = (res * comb[total + color[i] - 1][color[i] - 1]) % 1000000007;\n      total += color[i];\n    }\n        System.out.println(res);\n      }\n\n    public static void main(String[] args) {\n        cBalls();\n    }\n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class ColoredPelotas {\n\t\n\tpublic static long choose(int n, int k){\n\t\tlong[][] dp = new long[n+1][k+1];\n\t\tif (n == k) return 1;\n\t\tif (k == 1) return n;\n\t\tif (k == 0) return 1;\n\t\tfor (int i = 1; i < n+1; i++) {\n\t\t\tfor (int j = i;j > 0; j--) {\n\t\t\t\tif (j < k+1) {\n\t\t\t\t\tif (i == j) dp[i][j] = 1;\n\t\t\t\t\telse if (j == 1) dp[i][j] = i;\n\t\t\t\t\telse dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    return dp[n][k];\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint k = Integer.parseInt(reader.readLine());\n\t\tint sumaPelotas = 0;\n\t\tint pelota = 0;\t\n\t\tlong[] dp = new long[k];\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < k; i ++) {\n\t\t\tpelota = Integer.parseInt(reader.readLine());\n\t\t\tsumaPelotas += pelota;\n\t\t\tif (i > 0) dp[i] = dp[i-1]%1000000007*choose(sumaPelotas-1, pelota-1)%1000000007;\n\t\t}\n\t\tSystem.out.println(dp[k-1]);\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, U b) {\n  if (a < b) a = b;\n}\ntemplate <typename T>\ninline void gn(T &first) {\n  char c, sg = 0;\n  while (c = getchar(), (c > '9' || c < '0') && c != '-')\n    ;\n  for ((c == '-' ? sg = 1, c = getchar() : 0), first = 0; c >= '0' && c <= '9';\n       c = getchar())\n    first = (first << 1) + (first << 3) + c - '0';\n  if (sg) first = -first;\n}\ntemplate <class T, class T1>\ninline void gn(T &first, T1 &second) {\n  gn(first);\n  gn(second);\n}\ntemplate <class T, class T1, class T2>\ninline void gn(T &first, T1 &second, T2 &z) {\n  gn(first);\n  gn(second);\n  gn(z);\n}\ntemplate <typename T>\ninline void print(T first) {\n  if (first < 0) {\n    putchar('-');\n    return print(-first);\n  }\n  if (first < 10) {\n    putchar('0' + first);\n    return;\n  }\n  print(first / 10);\n  putchar(first % 10 + '0');\n}\ntemplate <typename T>\ninline void println(T first) {\n  print(first), putchar('\\n');\n}\ntemplate <typename T>\ninline void printsp(T first) {\n  print(first), putchar(' ');\n}\ntemplate <class T, class T1>\ninline void print(T first, T1 second) {\n  printsp(first), println(second);\n}\ntemplate <class T, class T1, class T2>\ninline void print(T first, T1 second, T2 z) {\n  printsp(first), printsp(second), println(z);\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = 1LL * a * a % m)\n    if (b & 1) ans = 1LL * ans * a % m;\n  return ans;\n}\nint n, con[1010][1010], dp[1010], a[1010], sum[1010];\nvoid proc() {\n  con[0][0] = 1;\n  for (int i = 1; i < 1010; i++) {\n    con[i][0] = 1;\n    con[i][i] = 1;\n    for (int j = 1; j < i; j++)\n      con[i][j] =\n          (con[i - 1][j - 1] % 1000000007 + con[i - 1][j] % 1000000007) %\n          1000000007;\n  }\n}\nint main() {\n  proc();\n  gn(n);\n  for (int i = 1; i <= n; i++) {\n    gn(a[i]);\n    sum[i] = sum[i - 1] + a[i];\n  }\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++)\n    dp[i] = (long long)dp[i - 1] * (con[sum[i] - 1][a[i] - 1]) % 1000000007;\n  println(dp[n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1010];\nlong long c[1010][1010];\nvoid preDeal() {\n  c[0][0] = c[1][0] = c[1][1] = 1;\n  for (int i = 1; i < 1010; i++) {\n    c[i][i] = c[i][0] = 1;\n    for (int j = 1; j < i; j++)\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % 1000000007;\n  }\n}\nint main() {\n  int i;\n  long long k, sum, sum1;\n  preDeal();\n  while (scanf(\"%lld\", &k) != EOF) {\n    sum1 = 1;\n    sum = 0;\n    for (i = 1; i <= k; i++) {\n      scanf(\"%lld\", &a[i]);\n      sum += a[i];\n    }\n    for (i = k; i >= 1; i--) {\n      sum1 = (sum1 % 1000000007) * (c[sum - 1][a[i] - 1] % 1000000007);\n      sum1 = sum1 % 1000000007;\n      sum = sum - a[i];\n    }\n    printf(\"%lld\\n\", sum1 % 1000000007);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, x, fact[1000 + 10], sum, sol;\nvoid precalc() {\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; i++) fact[i] = fact[i - 1] * i % 1000000007;\n}\nlong long lgput(long long a, long long n) {\n  if (!n) return 1;\n  if (n % 2 == 0) return lgput(a * a % 1000000007, n / 2);\n  return a * lgput(a * a % 1000000007, n / 2) % 1000000007;\n}\nlong long C(long long n, long long k) {\n  long long val1 = fact[n];\n  long long val2 = fact[n - k] * fact[k] % 1000000007;\n  long long val = val1 * lgput(val2, 1000000007 - 2) % 1000000007;\n  return val;\n}\nint main() {\n  precalc();\n  cin >> n >> x;\n  sum = x;\n  sol = 1;\n  for (int i = 2; i <= n; i++) {\n    cin >> x;\n    sol = sol * C(sum + x - 1, x - 1) % 1000000007;\n    sum = sum + x;\n  }\n  cout << sol << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans = 1;\nint n, c[1050];\ninline int Read() {\n  int x = 0;\n  char y;\n  do y = getchar();\n  while (y < '0' || y > '9');\n  do x = x * 10 + y - '0', y = getchar();\n  while (y >= '0' && y <= '9');\n  return x;\n}\ninline void In(int x, int y) {\n  int i, j, k, l = 0;\n  for (i = 2; i * i <= x; i++)\n    while (x % i == 0) x /= i, c[i] += y;\n  if (x > 1) c[x] += y;\n  return;\n}\ninline void C(int x, int y) {\n  for (int i = x + 1; i <= y; i++) In(i, 1);\n  for (int i = 2; i <= y - x; i++) In(i, -1);\n  return;\n}\nint main() {\n  int i, j, k, l, q = 0, w, e;\n  n = Read();\n  for (i = 1; i <= n; i++) w = Read(), C(w - 1, w - 1 + q), q += w;\n  for (i = 2; i <= 1000; i++)\n    for (j = 1; j <= c[i]; j++) ans = (ans * i) % 1000000007;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int MAXN = 1009;\nint n, k;\nint a[MAXN];\nlong long c[MAXN][MAXN];\nint main() {\n  cin >> k;\n  for (int i = 1; i <= k; ++i) {\n    cin >> a[i];\n    n += a[i];\n  }\n  for (int i = 0; i <= n; ++i) c[i][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n  long long ans = 1;\n  for (int i = k; i >= 2; --i) ans = ans * c[n - 1][a[i] - 1] % mod, n -= a[i];\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class C554C {\n    private static int k;\n    private static int[] c;\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws IOException {\n        input();\n        output();\n    }\n\n    private static long solve() {\n        long[][] combinations = getCombinations();\n        long res = 1;\n        int total = 0;\n\n        for (int i = 0; i < k; i++) {\n            total += c[i];\n            res = (res * combinations[total - 1][c[i] - 1]) % MOD;\n        }\n        return res;\n    }\n\n    private static long[][] getCombinations() {\n        long[][] combs = new long[1001][1001];\n        combs[0][0] = 1;\n        for (int i = 1; i <= 1000; i++) {\n            combs[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                combs[i][j] = (combs[i - 1][j] + combs[i - 1][j - 1]) % MOD;\n            }\n        }\n        return combs;\n    }\n\n    private static void output() {\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(solve());\n        out.close();\n    }\n\n    private static void input() {\n        Scanner sc = new Scanner(System.in);\n        k = sc.nextInt();\n        c = new int[k];\n        IntStream.range(0, k).forEach(i -> c[i] = sc.nextInt());\n        sc.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\n\nclass TaskC {\n\n    private long MOD = (long) (1e9 + 7);\n\n    private int colors[];\n\n    private int MAXN = 1000;\n\n    private long binomial_coefficient[][] = new long[MAXN+5][MAXN+5];\n\n\n    void solve(InputReader in, OutputWriter out) {\n        int k = in.nextInt();\n        colors = new int[k];\n        calculateBinomialCoefficient();\n        for(int i=0;i<k;i++) {\n            colors[i] = in.nextInt();\n        }\n\n        int sum = colors[0];\n        long result = 1;\n        for(int i=1;i<k;i++) {\n            sum += colors[i];\n            result = (result * binomial_coefficient[sum-1][colors[i]-1]) % MOD;\n        }\n        out.printLine(result);\n\n    }\n\n    private void calculateBinomialCoefficient() {\n        binomial_coefficient[0][0] = 1;\n        for(int i=1; i <= MAXN; i++ ) {\n            binomial_coefficient[i][0] = 1;\n            for(int j=1;j<=i;j++) {\n                binomial_coefficient[i][j] = (binomial_coefficient[i-1][j] + binomial_coefficient[i-1][j-1]) % MOD;\n            }\n        }\n    }\n\n\n}\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n    public boolean hasNext() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if ( line == null ) {\n                    return false;\n                }\n                tokenizer = new StringTokenizer(line);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return true;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\nclass OutputWriter {\n    private final PrintWriter writer;\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if ( i != 0 ) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n    public void close() {\n        writer.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.util.*; \nimport java.lang.*; \n\npublic class b {\n  private int mod = 1000000007;\n  \n  public static void main(String[] args) {\n    b solver = new b();\n  }\n\n  b() {\n    InputReader in = new InputReader();\n    in.init(System.in);\n\n    Combine kadal = new Combine();\n    int sum = 0;\n    int ans = 1;\n    int n = in.nextInt();\n    int k;\n    while (n-- > 0) {\n      k = in.nextInt();\n      ans = (int)((long)ans * kadal.count(sum + k - 1, k - 1) % mod);\n      sum += k;\n    }\n    System.out.println(ans);\n  }\n}\n\nclass Combine {\n  private int mod = 1000000007;\n  private int[] fac;\n  private int[] inv;\n\n  private int pln(int b, int e) {\n    int res = 1;\n    while (e > 0) {\n      if ((e & 1) == 1) \n        res = (int)((long)b * res % mod);\n      b = (int)((long)b * b % mod);\n      e >>= 1;\n    }\n    return res;\n  }\n\n  public Combine() {\n    fac = new int[1000007];\n    inv = new int[1000007];\n    fac[0] = inv[0] = 1;\n\n    for (int i = 1; i < 1000007; ++i) {\n      fac[i] = (int)((long)fac[i - 1] * i % mod);\n      inv[i] = pln(fac[i], mod - 2);\n    }\n  }\n\n  public int count(int n, int k) {\n    return (int)((long)fac[n] * inv[k] % mod * inv[n - k] % mod);\n  }\n}\n\nclass pair<K,V> {\n  public K first;\n  public V second;\n\n  public pair(K first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public pair(pair<K,V> rhs) {\n    this.first = rhs.first;\n    this.second = rhs.second;\n  }\n\n  public boolean equals(pair<K,V> rhs) {\n    return this.first == rhs.first && this.second == rhs.second;\n  }\n}\n\nclass InputReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n\n  public void init(InputStream input) {\n    reader = new BufferedReader(\n            new InputStreamReader(input), \n            32768);\n    tokenizer = null;\n  }\n\n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint arr[1010];\nint sum[1010];\nlong long c[1010][1010], dp[1010][1010];\nlong long C(int n, int r) {\n  if (n == r || r == 0) return 1;\n  if (c[n][r] != -1) return c[n][r];\n  return c[n][r] = (C(n - 1, r - 1) % 1000000007 + C(n - 1, r) % 1000000007) %\n                   1000000007;\n}\nlong long solve(int ind, int pos) {\n  if (pos == sum[N - 1] + 1) {\n    if (ind == N) return 1;\n    return 0;\n  }\n  if (dp[ind][pos] != -1) return dp[ind][pos];\n  long long p1 = 0, p2 = 0;\n  if (pos - sum[ind] < 0)\n    p1 = solve(ind, pos + 1);\n  else {\n    p1 = solve(ind, pos + 1);\n    p2 = (solve(ind + 1, pos + 1) % 1000000007 *\n          C(pos - sum[ind] + arr[ind] - 1, arr[ind] - 1) % 1000000007) %\n         1000000007;\n  }\n  return dp[ind][pos] = (p1 % 1000000007 + p2 % 1000000007) % 1000000007;\n}\nint main() {\n  memset(c, -1, sizeof(c));\n  memset(dp, -1, sizeof(dp));\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> arr[i];\n    if (i == 0)\n      sum[i] = arr[i];\n    else\n      sum[i] = sum[i - 1] + arr[i];\n  }\n  cout << solve(0, 1) << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class KyoyaAndColoredBalls {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int k = Integer.parseInt(br.readLine());\n        int[] color = new int[k];\n        for (int i = 0; i < k; i++) {\n            color[i] = Integer.parseInt(br.readLine());\n        }\n\n        final long MOD = (long) (1e9) + 7;\n        long[][] nCr = new long[1001][1001];\n        nCr[0][0] = 1;\n        for (int i = 1; i < 1001; i++) {\n            nCr[i][0] = 1;\n            for (int j = 1; j < i; j++) {\n                nCr[i][j] = (nCr[i - 1][j - 1] + nCr[i - 1][j]) % MOD;\n            }\n            nCr[i][i] = 1;\n        }\n\n        long count = 1;\n        int removed = 0;\n        for (int i = 0; i < k; i++) {\n            count = (count * nCr[removed + color[i] - 1][color[i] - 1]) % MOD;\n            removed += color[i];\n        }\n\n        System.out.println(count);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Competencia2 {\n\tpublic static void main(String[] args) {\n\t\t  int modulo = 1000000007;\n\t\t  int max = 1000;\n\t\t  Scanner scan = new Scanner(System.in);\n\t\t    \n\t\t  long[][] combinatoria = new long[max][max];\n\t\t  combinatoria[0][0] = 1;\n\t\t  for (int i = 1; i < max; i++) {\n\t\t\t  combinatoria[i][0] = 1;\n\t\t\t  \tfor (int j = 1; j <= i; j++) {\n\t\t\t  \t\tcombinatoria[i][j] = (combinatoria[i-1][j] + combinatoria[i-1][j-1]) % modulo;\n\t\t\t  \t}\n\t\t    }\n\t\t    \n\t\t    int K = scan.nextInt();\n\t\t    int[] color = new int[K];\n\t\t    for (int i = 0; i < K; i++) color[i] = scan.nextInt();\n\t\t    \n\t\t    long res = 1;\n\t\t    int total = 0;\n\t\t    for (int i = 0; i < K; i++) {\n\t\t      res = (res * combinatoria[total + color[i] - 1][color[i] - 1]) % modulo;\n\t\t      total += color[i];\n\t\t    }\n\t\t    \n\t\t   System.out.println(res);\n\t\t   scan.close();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class cf3092C{\n    public static void main(String[] args) throws IOException {\n    \tScanner f = new Scanner(System.in);\n        StringTokenizer st = new StringTokenizer(f.nextLine());\n        int n = Integer.parseInt(st.nextToken());\n        int[] balls = new int[n];\n        long ans = 1;\n        int num = 0;\n        for(int i = 0; i < n; i++){\n        \tst = new StringTokenizer(f.nextLine());\n        \tballs[i] = Integer.parseInt(st.nextToken());\n        \tnum += balls[i];\n        \tif(balls[i] - 1 != 0){\n\t        \tans *= C(num-1, balls[i]-1);\n\t        \tans %= 1000000007;\n        \t}\n        \t//System.out.println(i + \" \" + balls[i] + \" \" + ans);\n        }\n        f.close();\n        \n        System.out.println(ans);\n    }\n    \n    static long C(int n, int r){\n    \tlong num = 1;\n    \tlong d = 1;\n    \tfor(int i = n-r+1; i <= n; i++){\n    \t\tnum *= i;\n    \t\tnum %= 1000000007;\n    \t}\n    \tfor(int i = 1; i <= r; i++){ //r!\n    \t\td *= i;\n    \t\td %= 1000000007;\n    \t}\n    \t\n    \t//exp = 1000000005;\n    \t//111011100110101100101000000101_2\n    \t\n    \tlong a = d;\n    \tlong dbl = d;\n    \tdbl = doubl(dbl,2);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,7);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,2);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,3);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,2);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,2);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,3);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,2);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \tdbl = doubl(dbl,1);\n    \ta = (a * dbl) % 1000000007;\n    \t//System.out.println(n + \" \"  + r + \" \" + ((num*a)%1000000007));\n    \treturn (num*a) % 1000000007;\n    }\n    \n    static long doubl(long a, int i){\n    \tfor(int j = 0; j < i; j++){\n    \t\ta = (a*a) % 1000000007;\n    \t}\n    \treturn a;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Contest2_7_2 {\n\n  \n  public static void main (String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    long[][] combinatory = new long[1010][1010];\n    combinatory[0][0] = 1;\n    for (int i = 1; i < 1010; i++) {\n      combinatory[i][0] = 1;\n      \n      for (int j = 1; j <= i; j++) {\n        combinatory[i][j] = (combinatory[i-1][j] + combinatory[i-1][j-1]) % 1000000007;\n        \n      }\n    }\n    \n    int k = sc.nextInt();\n    int[] amounts_each_color = new int[k];\n    \n    for (int i = 0; i < k; i++){\n        amounts_each_color[i] = sc.nextInt();\n    \n    }\n    \n    long result = 1;\n    int total = 0;\n    \n    for (int i = 0; i < k; i++) {\n      result = (result * combinatory[total + amounts_each_color[i] - 1][amounts_each_color[i] - 1]) % 1000000007;\n      total += amounts_each_color[i];\n      \n    }\n    \n    System.out.println(result);\n    \n    System.exit(0);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ar[] = {0, 0, 1, -1};\nint ac[] = {1, -1, 0, 0};\nlong long fast_pow(int n, int m) {\n  long long res = 1;\n  long long p = n;\n  while (m) {\n    if (m % 2) res *= p;\n    p *= p;\n    m /= 2;\n  }\n  return res;\n}\nint dp[1005][1005];\nint a[1005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(9);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  long long res = 1;\n  int sum = 0;\n  dp[0][0] = 1;\n  for (int i = 1; i < 1005; i++)\n    for (int j = 0; j <= i; j++)\n      dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1], dp[i][j] %= 1000000007;\n  for (int i = 0; i < n; sum += a[i++])\n    res = res * dp[sum + a[i] - 1][a[i] - 1], res %= 1000000007;\n  cout << res << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "#------------------------template--------------------------#\nimport os\nimport sys\n# from math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=1000000007\nEPS=1e-6\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n    \n\ndef nCr(n, r, p=M): \n    num=1\n    den=1 \n    for i in range(r): \n        num=(num * (n - i)) % p \n        den=(den * (i + 1)) % p \n    return (num * pow(den,p-2,p))%p \n  \n\n\nk=Int()\nc=[]\nfor i in range(k):c.append(Int())\n\n\nhave_spaces=0\nans=1\n\nfor i in range(k):\n    \n    have_spaces+=c[i]\n    possible=nCr(have_spaces-1,c[i]-1)\n\n    ans=(ans*possible)%M\n\nprint(ans)\n\n\n\n\n\n            \n\n\n        \n\n\n\n\n    \n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\nlong long int countFact(long long int n, long long int p) {\n  long long int k = 0;\n  while (n >= p) {\n    k += n / p;\n    n /= p;\n  }\n  return k;\n}\nlong long int pow(long long int a, long long int b, long long int MOD) {\n  long long int x = 1, y = a;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      x = (x * y);\n      if (x > MOD) x %= MOD;\n    }\n    y = (y * y);\n    if (y > MOD) y %= MOD;\n    b /= 2;\n  }\n  return x;\n}\nlong long int InverseEuler(long long int n, long long int MOD) {\n  return pow(n, MOD - 2, MOD);\n}\nlong long int factMOD(long long int n, long long int MOD) {\n  long long int res = 1;\n  while (n > 1) {\n    res = (res * pow(MOD - 1, n / MOD, MOD)) % MOD;\n    for (long long int i = 2, j = n % MOD; i <= j; i++) res = (res * i) % MOD;\n    n /= MOD;\n  }\n  return res;\n}\nlong long int C(long long int n, long long int r, long long int MOD) {\n  if (countFact(n, MOD) > countFact(r, MOD) + countFact(n - r, MOD)) return 0;\n  return (factMOD(n, MOD) * ((InverseEuler(factMOD(r, MOD), MOD) *\n                              InverseEuler(factMOD(n - r, MOD), MOD)) %\n                             MOD)) %\n         MOD;\n}\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(0);\n  long long int k, A[1005], r, ans;\n  cin >> k;\n  for (int(i) = 0; (i) < (k); ++(i)) cin >> A[i];\n  r = A[0] + 1;\n  ans = 1;\n  for (int(i) = (1); (i) <= (k - 1); ++(i)) {\n    ans = (ans * C(A[i] - 2 + r, r - 1, mod)) % mod;\n    r += A[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1000 + 5];\nlong long comb[1000 + 5][1000 + 5];\nint main() {\n  comb[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    comb[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] =\n          (long long)((comb[i - 1][j] + comb[i - 1][j - 1]) % 1000000007);\n    }\n  }\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  long long ans = 1;\n  int sum = 0;\n  for (int i = 0; i < k; i++) {\n    ans = (ans * comb[sum + c[i] - 1][c[i] - 1]) % (long long)1000000007;\n    sum += c[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long combin[1010][1010];\nint main() {\n  combin[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    combin[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      combin[i][j] = (combin[i - 1][j] + combin[i - 1][j - 1]) % mod;\n    }\n  }\n  long long ans = 1, cnt = 0, k, x;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> x;\n    ans = (ans * combin[cnt + x - 1][x - 1]) % mod;\n    cnt += x;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e3 + 10;\nconst int MOD = 1e9 + 7;\nconst int dx[9] = {0, 1, -1, 0, 0, -1, -1, 1, 1};\nconst int dy[9] = {0, 0, 0, -1, 1, -1, 1, -1, 1};\nconst double pi = acos(-1.0);\nint k, n = 0;\nint c[MAXN][MAXN];\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) c[i][i] = 1, c[i][0] = 1;\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 1; j <= 1000; j++) {\n      c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n      if (c[i][j] >= MOD) c[i][j] -= MOD;\n    }\n  long long ans = 1;\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    n += x;\n    ans = (ans * c[n - 1][x - 1]) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1005;\nconst int MOD = 1e9 + 7;\nint n, i, j, a[maxN];\nlong long Choose[maxN][maxN];\nlong long ans = 1, sum = 0;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  Choose[0][0] = 1;\n  for (j = 0; j <= maxN - 5; j++) {\n    for (i = 0; i <= maxN - 5; i++) {\n      if (i == 0 || j == 0 || i == j) {\n        Choose[i][j] = 1;\n      } else if (i <= j) {\n        Choose[i][j] = Choose[i - 1][j - 1] + Choose[i][j - 1];\n        Choose[i][j] %= MOD;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    sum += a[i];\n    sum %= MOD;\n    ans *= Choose[a[i] - 1][sum - 1];\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e3 + 10;\nconst long long MOD = 1e9 + 7;\nlong long dp[MAX][MAX];\nlong long ncr(long long n, long long k) {\n  long long& ret = dp[n][k];\n  if (ret != -1) return ret;\n  if (k == 0) return ret = 1;\n  if (k == n) return ret = 1;\n  return ret = (ncr(n - 1, k) + ncr(n - 1, k - 1)) % MOD;\n}\nlong long arr[MAX], tot;\nlong long ways = 1;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  memset(dp, -1, sizeof(dp));\n  int k;\n  cin >> k;\n  for (int(i) = (0); (i) < (k); (i)++) {\n    cin >> arr[i];\n    tot += arr[i];\n  }\n  for (int i = k - 1; i >= 0; i--) {\n    long long temp = ncr(tot - 1, arr[i] - 1);\n    ways = (ways * temp) % MOD;\n    tot -= arr[i];\n  }\n  cout << (ways) << \"\\n\";\n  ;\n}\n"
        },
        {
            "language": 3,
            "solution": "__author__ = 'taras-sereda'\n\nfrom pprint import pprint as pp\n\nn = int(input())\n\nmaxn = 1000\nmod = 1000000007\ncoef = [[0 for i in range(maxn)]for i in range(maxn)]\n\nfor i in range(maxn):\n    coef[i][0] = 1\n    for j in range(1, maxn):\n        coef[i][j] = (coef[i-1][j] + coef[i-1][j-1]) % mod\n\ncolors = [int(input()) for i in range(n)]\n\nres = 1\ntotal = 0\n\nfor i in range(n):\n    res = (res*coef[total+colors[i]-1][colors[i]-1]) % mod\n    total += colors[i]\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int y) {\n  long long int ans = 1;\n  while (y > 0) {\n    if (y % 2 != 0) {\n      ans = (ans * x) % 1000000007ll;\n    }\n    x = (x * x) % 1000000007ll;\n    y /= 2;\n  }\n  return (ans % 1000000007ll);\n}\nint main() {\n  long long int k, a[1010], i, j, ans = 0, sum = 0, x, dp[1010][1010];\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> a[i];\n  }\n  dp[0][0] = 1;\n  dp[0][1] = 1;\n  for (i = 1; i <= k; i++) {\n    for (j = 1; j <= a[i]; j++) {\n      if (j == 1)\n        dp[i][j] = dp[i - 1][a[i - 1]];\n      else\n        dp[i][j] = ((((dp[i][j - 1] % 1000000007ll) * (sum % 1000000007ll)) %\n                     1000000007ll) *\n                    (power(j - 1, 1000000007ll - 2))) %\n                   1000000007ll;\n      sum++;\n      dp[i][j] %= 1000000007ll;\n    }\n  }\n  cout << dp[k][a[k]];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.lang.*;\n\npublic class Main {\n    final static boolean debug = false;\n    final static String fileName = \"\";\n    final static boolean useFiles = false;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        PrintWriter writer = new PrintWriter(System.out);\n        new Task(new InputReader(System.in), writer).solve();\n        writer.close();\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public byte nextByte() {\n        return Byte.parseByte(next());\n    }\n}\n\nclass Task {\n    final int mod = 1_000_000_007;\n\n    long inv(long x) {\n        long result = 1;\n        int pow = mod - 2;\n        long sqr = x;\n        while (pow != 0) {\n            if (pow % 2 == 0) {\n                result = (result * sqr) % mod;\n            }\n            pow >>= 1;\n            sqr = (sqr * sqr) % mod;\n        }\n        return result;\n    }\n\n    public void solve() {\n        final int maxC = 1010;\n        int k = in.nextInt();\n        int[] a = new int[k];\n        for (int i = 0; i < k; i++) {\n            a[i] = in.nextInt();\n        }\n        int[][] c = new int[maxC][maxC];\n        for (int i = 0; i < maxC; i++){\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++){\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n            }\n        }\n        int pref = 0;\n        long result = 1;\n        for (int i = 0; i < k; i++){\n            pref += a[i];\n            result = (result * c[pref - 1][a[i] - 1]) % mod;\n        }\n        out.println(result);\n    }\n\n    private InputReader in;\n    private PrintWriter out;\n\n    Task(InputReader in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Locale;\n\n/**\n * @author master_j\n * @version 0.4.1\n * @since Mar 22, 2015\n */\npublic class Solution {\n    final int MOD = 1_000_000_000 + 7;\n    final int N = 1001;\n\n    private long mod(long x) {\n        return x % MOD;\n    }\n\n    private void solve() throws IOException {\n        int n = io.nI();\n        int[] a = new int[1 + n];\n        for (int i = 1; i < a.length; i++)\n            a[i] = io.nI();\n\n        long[] ans = new long[1 + n];\n        ans[1] = 1;\n\n        int sum = a[1];\n        for (int i = 2; i <= n; i++) {\n            ans[i] = mod(f(a[i] - 1, 1 + sum) * ans[i - 1]);\n\n            sum += a[i];\n        }\n\n        io.wln(ans[n]);\n    }//2.2250738585072012e-308\n\n    long f(int balls, int boxes) {\n        return bin(balls + boxes - 1, boxes - 1);\n    }\n\n    long cache[][] = new long[N][N];\n\n    long bin(int n, int k) {\n        if (k == 0 || k == n)\n            return 1;\n\n        if (cache[n][k] == 0)\n            cache[n][k] = mod(mod(bin(n - 1, k - 1)) + mod(bin(n - 1, k)));\n\n        return cache[n][k];\n    }\n\n    public static void main(String[] args) throws IOException {\n        IO.launchSolution(args);\n    }\n\n    Solution(IO io) throws IOException {\n        this.io = io;\n        solve();\n    }\n\n    private final IO io;\n}\n\nclass IO {\n    static final String _localArg = \"master_j\";\n    private static final String _problemName = \"\";\n    private static final IO.Mode _inMode = Mode.STD_;\n    private static final IO.Mode _outMode = Mode.STD_;\n    private static final boolean _autoFlush = false;\n\n    enum Mode {STD_, _PUT_TXT, PROBNAME_}\n\n    private final StreamTokenizer st;\n    private final BufferedReader br;\n    private final Reader reader;\n\n    private final PrintWriter pw;\n    private final Writer writer;\n\n    static void launchSolution(String[] args) throws IOException {\n        boolean local = (args.length == 1 && args[0].equals(IO._localArg));\n        IO io = new IO(local);\n\n        long nanoTime = 0;\n        if (local) {\n            nanoTime -= System.nanoTime();\n            io.wln(\"<output>\");\n        }\n\n        io.flush();\n        new Solution(io);\n        io.flush();\n\n        if (local) {\n            io.wln(\"</output>\");\n            nanoTime += System.nanoTime();\n            final long D9 = 1000000000, D6 = 1000000, D3 = 1000;\n            if (nanoTime >= D9)\n                io.wf(\"%d.%d seconds\\n\", nanoTime / D9, nanoTime % D9);\n            else if (nanoTime >= D6)\n                io.wf(\"%d.%d millis\\n\", nanoTime / D6, nanoTime % D6);\n            else if (nanoTime >= D3)\n                io.wf(\"%d.%d micros\\n\", nanoTime / D3, nanoTime % D3);\n            else\n                io.wf(\"%d nanos\\n\", nanoTime);\n        }\n\n        io.close();\n    }\n\n    IO(boolean local) throws IOException {\n        if (_inMode == Mode.PROBNAME_ || _outMode == Mode.PROBNAME_)\n            if (_problemName.length() == 0)\n                throw new IllegalStateException(\"You imbecile. Where's my <_problemName>?\");\n\n        if (_problemName.length() > 0)\n            if (_inMode != Mode.PROBNAME_ && _outMode != Mode.PROBNAME_)\n                throw new IllegalStateException(\"You imbecile. What's the <_problemName> for?\");\n\n        Locale.setDefault(Locale.US);\n\n        if (local) {\n            reader = new FileReader(\"input.txt\");\n            writer = new OutputStreamWriter(System.out);\n        } else {\n            switch (_inMode) {\n                case STD_:\n                    reader = new InputStreamReader(System.in);\n                    break;\n                case PROBNAME_:\n                    reader = new FileReader(_problemName + \".in\");\n                    break;\n                case _PUT_TXT:\n                    reader = new FileReader(\"input.txt\");\n                    break;\n                default:\n                    throw new NullPointerException(\"You imbecile. Gimme _inMode.\");\n            }\n            switch (_outMode) {\n                case STD_:\n                    writer = new OutputStreamWriter(System.out);\n                    break;\n                case PROBNAME_:\n                    writer = new FileWriter(_problemName + \".out\");\n                    break;\n                case _PUT_TXT:\n                    writer = new FileWriter(\"output.txt\");\n                    break;\n                default:\n                    throw new NullPointerException(\"You imbecile. Gimme _outMode.\");\n            }\n        }\n\n        br = new BufferedReader(reader);\n        st = new StreamTokenizer(br);\n\n        pw = new PrintWriter(writer, _autoFlush);\n\n        if (local && _autoFlush)\n            wln(\"Note: auto-flush is on.\");\n    }\n\n    //@formatter:off\n    void wln()          {pw.println(); }\n    void wln(boolean x) {pw.println(x);}\n    void wln(char x)    {pw.println(x);}\n    void wln(char x[])  {pw.println(x);}\n    void wln(double x)  {pw.println(x);}\n    void wln(float x)   {pw.println(x);}\n    void wln(int x)     {pw.println(x);}\n    void wln(long x)    {pw.println(x);}\n    void wln(Object x)  {pw.println(x);}\n    void wln(String x)  {pw.println(x);}\n\n    void wf(String f, Object... o) {pw.printf(f, o);}\n\n    void w(boolean x)   {pw.print(x);}\n    void w(char x) {pw.print(x);}\n    void w(char x[]) {pw.print(x);}\n    void w(double x)    {pw.print(x);}\n    void w(float x)     {pw.print(x);}\n    void w(int x)       {pw.print(x);}\n    void w(long x)      {pw.print(x);}\n    void w(Object x)    {pw.print(x);}\n    void w(String x)    {pw.print(x);}\n\n    int nI() throws IOException {st.nextToken(); return (int)st.nval;}\n    double nD() throws IOException {st.nextToken(); return st.nval;}\n    float nF() throws IOException {st.nextToken(); return (float)st.nval;}\n    long nL() throws IOException   {st.nextToken(); return (long)st.nval;}\n    String nS() throws IOException {st.nextToken(); return st.sval;}\n\n    int[] nIa(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nI();\n        return a;\n    }\n    double[] nDa(int n) throws IOException {\n        double[] a = new double[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nD();\n        return a;\n    }\n    String[] nSa(int n) throws IOException {\n        String[] a = new String[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nS();\n        return a;\n    }\n\n    void wc(String x)         {wc(x.toCharArray());}\n    void wc(char c1, char c2) {for (char c = c1; c<=c2; c++) wc(c);}\n    void wc(char x[])         {for (char c : x) wc(c); }\n    void wc(char x)           {st.ordinaryChar(x); st.wordChars(x, x);}\n\n    public boolean eof() {return st.ttype == StreamTokenizer.TT_EOF;}\n    public boolean eol() {return st.ttype == StreamTokenizer.TT_EOL;}\n\n    void flush() {pw.flush();}\n    void close() throws IOException {reader.close(); br.close(); flush(); pw.close();}\n    //@formatter:on\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class c {\n    final int MOD = 1_000_000_007;\n    final int N = 1001;\n    long[][] comb = new long[N][N];\n    long doit(int n, int k) {\n        if(k == 0) return 1;\n        if(n == 0) return 0;\n        if(comb[n][k] != -1) return comb[n][k];\n        return comb[n][k] = (doit(n - 1, k - 1) + doit(n - 1, k)) % MOD;\n    }\n    private void solve() throws IOException {\n        for(int i = 0; i < comb.length; ++i) {\n            Arrays.fill(comb[i], -1); \n        }\n        int n = nextInt();\n        int[] balls = new int[n];\n        for(int i = 0; i < n; ++i) {\n            balls[i] = nextInt(); \n        }\n        long res = 1;\n        int total = 0;\n        for(int i = 0; i < n; ++i) {\n            int toAdd = balls[i] - 1;\n            res = (res * doit(total + toAdd, toAdd)) % MOD; \n            total += balls[i];\n        }\n        System.out.println(res);\n    }\n\n    static void debug(Object...o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    private void run() throws IOException {\n        //br = new BufferedReader(new FileReader(\"c.in\"));\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        //out = new PrintWriter(\"c.out\");\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new c().run();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        int i,a=0,s=0,N=1000000;\n        f=new long[N+1];\n        f[0]=1;\n        for(i=1;i<=N;i++) f[i]=f[i-1]*i%M;\n\n        long ans[]=new long[n];\n        for(i=0;i<n;i++)\n        {\n            a=Integer.parseInt(bu.readLine());\n            s+=a;\n            if(i==0) ans[i]=1;\n            else ans[i]=ncr(s-1,a-1);\n            if(i>0) ans[i]=ans[i-1]*ans[i]%M;\n        }\n        System.out.println(ans[n-1]);\n    }\n    static long f[],M=1000000007;\n\n    static long ncr(int n,int r)\n    {\n        return f[n]*power(f[n-r],M-2)%M*power(f[r],M-2)%M;\n    }\n\n    static long power(long a,long b)\n    {\n        long r=1;\n        while(b!=0)\n        {\n            if(b%2==1) r=r*a%M;\n            b>>=1;\n            a=a*a%M;\n        }\n        return r;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long exp(long long a, long long b) {\n  long long ans = 1, apow = a;\n  while (b > 0) {\n    if (b % 2) ans = (ans * apow) % mod;\n    b /= 2;\n    apow = (apow * apow) % mod;\n  }\n  return ans;\n}\nlong long fact[1001], invfact[1001];\nint main() {\n  long long k, i, j;\n  long long n, p, ans, mul, ball, m;\n  fact[1] = 1;\n  invfact[1] = 1;\n  for (i = 2; i <= 1001; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    invfact[i] = exp(fact[i], mod - 2);\n  }\n  invfact[0] = 1;\n  scanf(\"%lld\", &k);\n  ans = 1;\n  ball = 0;\n  for (i = 0; i < k; i++) {\n    scanf(\"%lld\", &j);\n    p = 1;\n    for (m = ball + j - 1, n = 1; n <= j - 1; n++, m--) p = (p * m) % mod;\n    p = (p * invfact[j - 1]) % mod;\n    ans = (ans * p) % mod;\n    ball += j;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[1005][1005], a[1005];\nvoid pre() {\n  int i, j;\n  for (i = 0; i <= 1001; i++) {\n    for (j = 0; j <= i; j++) {\n      if (j == 0 || j == i)\n        p[i][j] = 1;\n      else\n        p[i][j] = (p[i - 1][j - 1] + p[i - 1][j] * 1LL) % 1000000007;\n    }\n  }\n}\nint main() {\n  int n, sum, i;\n  long long int ans;\n  cin >> n;\n  pre();\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sum = a[0];\n  ans = 1;\n  for (i = 1; i < n; i++) {\n    ans = ans * (p[sum + a[i] - 1][a[i] - 1]) % 1000000007;\n    sum += a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "pc = c = 0\nres = 1\nfor i in range(int(input())):\n    pc += c\n    c = int(input())\n    for k in range(1, c):\n        res = res * (pc + c - k) // k\n    res %= 1000000007\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[1005], d[1005][1005], s[1005], dp[1005];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> c[i];\n  s[0] = 1;\n  for (int i = 1; i <= 1000; ++i) {\n    d[i][1] = 1;\n    s[i] = s[i - 1] + 1;\n  }\n  for (int j = 2; j <= 1000; ++j) {\n    d[0][j] = 1;\n    for (int i = 1; i <= 1000; ++i) {\n      d[i][j] = s[i];\n      s[i] = (s[i - 1] + d[i][j]) % 1000000007;\n    }\n  }\n  long long sum = c[0];\n  dp[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    dp[i] = (dp[i - 1] * d[c[i] - 1][sum + 1]) % 1000000007;\n    sum += c[i];\n  }\n  cout << dp[n - 1] % 1000000007;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int c[1002][1002], w[1002];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int i, j, k, n;\n  cin >> n;\n  c[0][0] = 1;\n  for (i = 1; i <= 1000; i++) {\n    c[i][0] = 1;\n    for (j = 1; j <= i; j++) {\n      c[i][j] = (c[i - 1][j] % 1000000007 + c[i - 1][j - 1] % 1000000007) %\n                1000000007;\n    }\n  }\n  long long int b = 0;\n  for (i = 1; i <= n; i++) {\n    cin >> w[i];\n    b += w[i];\n  }\n  long long int res = 1;\n  for (i = n; i >= 1; i--) {\n    res = ((res % 1000000007) * (c[b - 1][w[i] - 1] % 1000000007)) % 1000000007;\n    b = b - w[i];\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint c[1001];\nlong long fact[1001];\nlong long rfact[1001];\nlong long ppp(long long x, long long p) {\n  if (p == 0) return 1;\n  if (p % 2) {\n    return (ppp(x, p - 1) * x) % 1000000007;\n  } else {\n    long long half = ppp(x, p / 2);\n    return (half * half) % 1000000007;\n  }\n}\nlong long ccc(long long top, long long bottom) {\n  return (((fact[top] * rfact[top - bottom]) % 1000000007) * rfact[bottom]) %\n         1000000007;\n}\nint main() {\n  fact[0] = 1;\n  rfact[0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    fact[i] = (fact[i - 1] * i) % 1000000007;\n    rfact[i] = ppp(fact[i], 1000000005);\n  }\n  int k;\n  std::cin >> k;\n  for (int i = 1; i <= k; i++) {\n    std::cin >> c[k + 1 - i];\n  }\n  long long low = c[k];\n  long long p = 1;\n  long long top = c[k - 1] + c[k] - 1;\n  long long bottom = c[k];\n  for (int i = 2; i <= k; i++) {\n    long long pp = ccc(top, bottom);\n    p = (p * pp) % 1000000007;\n    top += c[k - i];\n    bottom += c[k - i + 1];\n  }\n  std::cout << p << std::endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1001][1001];\nconst int mod = 1e9 + 7;\nvoid calc() {\n  for (int i = 0; i < 1001; i++) C[i][0] = C[i][i] = 1;\n  for (int i = 1; i < 1001; i++)\n    for (int j = 1; j < i; j++)\n      C[i][j] = ((C[i - 1][j - 1] % mod) + (C[i - 1][j] % mod)) % mod;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  calc();\n  int n;\n  cin >> n;\n  vector<long long> v;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    v.push_back(x);\n  }\n  long long cnt = v[0];\n  long long res = 1;\n  for (int i = 1; i < n; i++) {\n    cnt += v[i];\n    res = (res * C[cnt - 1][v[i] - 1]) % mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\nimport static java.util.Arrays.stream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    private static final int MAGIC_MOD = 1_000_000_007;\n\n    private static final Long[] MOD_INVERSE_CACHE = new Long[2000];\n\n    public static void main(String[] args) {\n        Main main = new Main();\n\n        FastScanner fastScanner = new FastScanner();\n        PrintWriter output = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int k = fastScanner.nextInt();\n\n        int[] c = new int[k];\n\n        for (int index = 0; index < k; index++) {\n            c[index] = fastScanner.nextInt();\n        }\n\n        long result = main.solve(k, c);\n\n        output.println(result);\n\n        output.close();\n    }\n\n    long solve(int k, int[] c) {\n        if (k == 0 || k == 1) {\n            return 1;\n        }\n        return combinations(c[k - 1] - 1, stream(c).limit(k).sum() - 1) * solve(k - 1, c) % MAGIC_MOD;\n    }\n\n    long combinations(long k, long n) {\n        long result = 1;\n\n        for (long i = n - k + 1; i <= n; i++) {\n            result = (result * i) % MAGIC_MOD;\n        }\n\n        for (int i = 1; i <= k; i++) {\n            result = (result * modInverse(i)) % MAGIC_MOD;\n        }\n\n        return result;\n    }\n\n    long modInverse(int n) {\n        if (MOD_INVERSE_CACHE[n] == null) {\n            if (n == 1) {\n                MOD_INVERSE_CACHE[1] = 1L;\n            } else {\n                MOD_INVERSE_CACHE[n] = (-modInverse(MAGIC_MOD % n) * (MAGIC_MOD / n)) % MAGIC_MOD;\n                if (MOD_INVERSE_CACHE[n] < MAGIC_MOD) {\n                    MOD_INVERSE_CACHE[n] += MAGIC_MOD;\n                }\n            }\n        }\n\n        return MOD_INVERSE_CACHE[n];\n    }\n}\n\n class FastScanner {\n\n    private final BufferedReader bufferedReader;\n    private StringTokenizer stringTokenizer;\n\n    public FastScanner() {\n        bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n            try {\n                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(\"Can't read next value\", e);\n            }\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public String nextLine(){\n        String str = \"\";\n        try {\n            str = bufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1234567;\nlong long dp[1005], A[1005], fact[1005], inv[1005];\nlong long fast_pow(long long n, long long p) {\n  if (p == 0) return 1;\n  if (p == 1) return n;\n  long long b = fast_pow(n, p / 2);\n  if (p % 2) return (((b * b) % 1000000007) * n) % 1000000007;\n  return (b * b) % 1000000007;\n}\nvoid factorial() {\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    fact[i] = fact[i - 1] * i % 1000000007;\n  }\n}\nvoid mmi() {\n  for (int i = 0; i <= 1000; i++) inv[i] = fast_pow(fact[i], 1000000007 - 2);\n}\nlong long nCr(long long n, long long r) {\n  if (r > n) return 0;\n  if (r == 0) return 1;\n  return fact[n] * (inv[n - r] * inv[r] % 1000000007) % 1000000007;\n}\nint main() {\n  factorial();\n  mmi();\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> A[i];\n  long long sum = 0;\n  dp[0] = 1;\n  dp[1] = 1;\n  for (int i = 1; i <= k; i++) {\n    dp[i] = dp[i - 1] * nCr(sum + A[i] - 1, A[i] - 1) % 1000000007;\n    sum += A[i];\n  }\n  if (dp[k] < 0) dp[k] += 1000000007;\n  cout << dp[k];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gt[1000001 + 1];\nlong long power(long long a, long long n, long long m) {\n  long long cur = a, ans = 1;\n  while (n) {\n    if (n % 2) ans = ans * cur % m;\n    cur = cur * cur % m;\n    n /= 2;\n  }\n  return ans;\n}\nlong long inv(long long a, long long m) { return power(a, m - 2, m); }\nlong long C(long long k, long long n) {\n  return gt[n] * inv(gt[k], 1000000007) % 1000000007 *\n         inv(gt[n - k], 1000000007) % 1000000007;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long a[n + 1];\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  long long ans = 1, cur = a[1];\n  gt[0] = 1;\n  for (int i = 1; i <= 1000001; i++) gt[i] = gt[i - 1] * i % 1000000007;\n  for (int i = 2; i <= n; i++) {\n    ans *= C(cur, a[i] - 1 + cur);\n    ans %= 1000000007;\n    cur += a[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long yht[1111][1111];\nint col[1111];\nint main() {\n  yht[0][1] = 1;\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 1; j <= i; j++)\n      yht[i][j] = (yht[i - 1][j - 1] + yht[i - 1][j]) % mod;\n  int k;\n  scanf(\"%d\", &k);\n  int sum = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> col[i];\n    sum += col[i];\n  }\n  long long ans = 1;\n  for (int i = k; i >= 1; i--) {\n    ans = ans * yht[sum][col[i]] % mod;\n    sum -= col[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nlong long vis[1005][1005];\nint num[1005];\nint main() {\n  vis[0][0] = 1;\n  vis[1][0] = 1;\n  vis[1][1] = 1;\n  for (int i = 2; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || j == i)\n        vis[i][j] = 1;\n      else\n        vis[i][j] = (vis[i - 1][j] + vis[i - 1][j - 1]) % mod;\n    }\n  }\n  int n;\n  int sum = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &num[i]);\n    sum += num[i];\n  }\n  long long ans = 1;\n  for (int i = n - 1; i >= 0; i--) {\n    ans = (ans * vis[sum - 1][num[i] - 1]) % mod;\n    sum = sum - num[i];\n  }\n  printf(\"%lld\\n\", ans % mod);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k = int(input())\nc = [int(input()) for i in range(k)]\nmod, ans, s= 1000000007, 1, 0\nri = [0, 1]\nfor i in range(2, 1000010):\n    ri.append((mod//i) * (mod-ri[mod%i])%mod);\nfor p in c:\n    for i in range(1, p):\n        ans = ans * (s + i) * ri[i] % mod\n    s += p\nprint(ans)\n\n            "
        },
        {
            "language": 3,
            "solution": "mod = 1_000_000_007\n\ndef C(n, r):\n    if r > n - r:\n        r = n - r\n\n    val = 1\n    for i in range(1, r + 1):\n        val *= n - r + i\n        val //= i\n    return val % mod\n\nn = int(input())\na = []\nfor _ in range(n):\n    a.append(int(input()))\n\nz = [0 for _ in range(n)]\ncum = 0\nval = 1\nfor i in range(n):\n    cum += a[i]\n    val *= C(cum - 1, a[i] - 1)\n    val %= mod\n\nprint(val)\n"
        },
        {
            "language": 3,
            "solution": "MOD = 10**9+7\n\nimport os\nimport math\n\ndef combination(n,k):\n    return (math.factorial(n)//math.factorial(k)//math.factorial(n-k))%MOD\n\n\n\ndef main():\n\n    k = int(input().strip())\n    a=[]\n    for i in range(k):\n        a.append(int(input().strip()))\n\n    dp = [1]\n    used=a[0]\n    for i in range(1,k):\n        used+=a[i]\n        dp.append((dp[i - 1] * combination(used - 1, a[i] - 1))%MOD)\n\n    print(dp[-1])\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\"\"\"\n\n\n3\n2\n2\n1\n\n4\n1\n2\n3\n4\n\n\n\n\"\"\"\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\n\npublic class CF_309_CC {\n    public static void main(String[] args) throws IOException{\n        PrintWriter pw = new PrintWriter(System.out, true);\n        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n        int K = Integer.parseInt(input.readLine());\n        int[] arr = new int[K];\n        int n = 0, r = 0;\n        long MOD = 1000000007;\n        for(int i = 0 ; i < K ; i++){\n            arr[i] = Integer.parseInt(input.readLine());\n            n += arr[i];\n        }\n        \n        n += 1;\n        r = n;\n        long[][] C = new long[n][r ];\n        \n        for(int i = 0 ; i < n ; i++){\n            C[0][i] = 0;\n            C[i][0] = 1;\n        }\n        \n        for(int i = 1 ; i < n ; i++){\n            for(int j = 1 ; j < n ; j++){\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j])%MOD;\n            }\n        }\n        n -= 1;\n        \n        \n        long ans = 1;\n        int nn;\n        for(int i = K - 1 ; i >= 0 ; i--){\n        \n            nn = n-1;\n            r = arr[i] - 1;\n            \n            ans = (ans*C[nn][r])%MOD;\n            n -= arr[i];\n        }\n        \n        pw.println(ans);        \n        pw.close();\n        input.close();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int[] a=ir.nextIntArray(n);\n int tot=0;\n for(int val : a){\n  tot+=val;\n }\n long MOD=(long)1e9+7;\n Mod mm=new Mod(1111,MOD);\n long ans=1;\n for(int i=n-1;i>=0;i--){\n  ans*=mm.comb(tot-1,a[i]-1);\n  ans%=MOD;\n  tot-=a[i];\n }\n out.println(ans);\n}\n\nstatic class Mod{\n\n public static long MOD;\n public static int MAX;\n private long[] fact,factInv;\n\n public Mod(int MAX,long MOD){\n  this.MAX=MAX;\n  this.MOD=MOD;\n  fact=factArray();\n  factInv=factInverseArray();\n }\n\n public static long gcd(long a,long b){\n  if(b==0) return a;\n  return gcd(b,a%b);\n }\n\n public static long lcm(long a,long b){\n  return a/gcd(a,b)*b;\n }\n\n public long mod_inverse(long a){\n  long[] ret=extendedgcd(a,MOD);\n  return (MOD+ret[0]%MOD)%MOD;\n }\n\n public static long[] extendedgcd(long a,long b){\n  long[] ret=new long[3];\n  ret[2]=_extendedgcd(a,b,ret);\n  return ret;\n }\n\n private static long _extendedgcd(long a,long b,long[] x){\n  long g=a;\n  x[0]=1;\n  x[1]=0;\n  if(b!=0){\n   g=_extendedgcd(b,a%b,x);\n   long temp=x[0]; x[0]=x[1]; x[1]=temp;\n   x[1]-=(a/b)*x[0];\n  }\n  return g;\n }\n\n private long[] factArray(){\n  long[] ret=new long[MAX+1];\n  ret[0]=1%MOD;\n  for(int i=1;i<=MAX;i++){\n   ret[i]=ret[i-1]*i;\n   ret[i]%=MOD;\n  }\n  return ret;\n }\n\n private long[] factInverseArray(){\n  long[] ret=new long[MAX+1];\n  ret[0]=1;\n  for(int i=1;i<=MAX;i++){\n   ret[i]=ret[i-1]*mod_inverse(i)%MOD;\n  }\n  return ret;\n }\n\n public long comb(int n,int m){\n  long ret=fact[n];\n  ret*=factInv[m];\n  ret%=MOD;\n  ret*=factInv[n-m];\n  ret%=MOD;\n  return ret;\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    //---------------------------------------------------------------------------\n\n    static int n, sum;\n    static long mod = 1000000000 + 7;\n    static int MAXN = 1010;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        //-----------------------------------------------------------------------\n        long[][] c = new long[MAXN][MAXN];\n        c[0][0] = 1;\n        for (int i = 1; i < MAXN; i++) {\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n            }\n        }\n\n        int k = in.nextInt();\n        int[] a = new int[k];\n        for (int i = 0; i < k; i++) {\n            a[i] = in.nextInt();\n        }\n\n        long res = 1;\n        int total = 0;\n        for (int i = 0; i < k; i++) {\n            res = (res * c[total + a[i] - 1][a[i] - 1]) % mod;\n            total += a[i];\n        }\n        out.println(res);\n        //-----------------------------------------------------------------------\n        out.close();\n    }\n\n    //---------------------------------------------------------------------------\n    static void shuffleArray(int[] ar) {\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    static class Pair implements Comparator {\n\n        int first;\n        long second;\n\n        public Pair() {\n\n        }\n\n        public Pair(int f, long s) {\n            this.first = f;\n            this.second = s;\n        }\n\n        @Override\n        public int compare(Object o1, Object o2) {\n            Pair p1 = (Pair) o1;\n            Pair p2 = (Pair) o2;\n            int ret = Integer.compare(p1.first, p2.first);\n            if (ret == 0) {\n                ret = Long.compare(p1.second, p2.second);\n            }\n            return ret;\n        }\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] nextCharArray() {\n            return next().toCharArray();\n        }\n\n        public boolean hasNext() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    String s = reader.readLine();\n                    if (s == null) {\n                        return false;\n                    }\n                    tokenizer = new StringTokenizer(s);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return true;\n        }\n\n        public void skipLine() {\n            try {\n                tokenizer = null;\n                reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "k=int(input())\nl=[int(input()) for i in range(k)]\nMOD=10**9+7 \nfact=[0]*(10**6+5)\nfact[0]=1 \nfor i in range(1,10**6+5):\n    fact[i]=(fact[i-1]%MOD*i%MOD)%MOD\ndef MI(a,MOD):\n    return pow(a,MOD-2,MOD)\ndef c(n, k):\n    if n==k or k==0:\n        return 1 \n    if n<k:\n        return 0 \n    return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\nans=1 \nsm=l[0]\nfor i in range(1,k):\n    curr=l[i]\n    ans=ans*(c(sm+curr-1,curr-1))\n    ans%=MOD \n    sm+=l[i]\nprint(ans)"
        },
        {
            "language": 1,
            "solution": "from functools import reduce\nfrom operator import mul\nfrom math import factorial\n\nnCr = lambda n, r: int(reduce(mul, range(n, n - r, -1)) // factorial(r))\nans, s, mod = 1, 0, 1000000007\n\nfor _ in range(int(input())):\n    n = int(input())\n    s += n\n    try:\n        ans = (ans * nCr(s - 1, n - 1)) % mod\n    except:\n        continue\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\n\nn = int(input())\n\nans = 1\ns = 0\nfor i in range(n) :\n  a = int(input())\n  ans=(ans*factorial(s+a-1)//factorial(s)//factorial(a-1))%1000000007\n  s+=a\n\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1005][1005];\nint a[1005];\nint main() {\n  int i, j, k;\n  c[1][0] = c[1][1] = 1;\n  for (i = 2; i < 1005; i++) {\n    c[i][0] = 1;\n    for (j = 1; j <= i; j++)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % 1000000007;\n  }\n  scanf(\"%d\", &k);\n  int x, sum = 0;\n  for (i = 1; i <= k; i++) {\n    scanf(\"%d\", &a[i]);\n    sum += a[i];\n  }\n  long long res = 1;\n  for (i = k; i > 1; i--) {\n    res = (res * (long long)c[sum - 1][a[i] - 1]) % 1000000007;\n    sum -= a[i];\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Code_533A_KyoyaAndColoredBalls {\n    public static void main(String[] args) throws IOException {\n        int[][] nCr=new int[1001][1001];\n        int MOD=1000000007;\n        for(int n=0;n<=1000;++n) {\n            for (int r = 0; r <= n; ++r) {\n                nCr[n][r] = (r == 0 || r == n ? 1 : (nCr[n - 1][r - 1] + nCr[n - 1][r]) % MOD);\n            }\n        }\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out=new PrintWriter(System.out);\n        StringTokenizer in=new StringTokenizer(br.readLine());\n        int t=Integer.parseInt(in.nextToken());\n        long result=1;\n        int total=0;\n        for(int i=1;i<=t;++i){\n            in=new StringTokenizer(br.readLine());\n            int color=Integer.parseInt(in.nextToken());\n            result=(result*nCr[total+color-1][color-1])%MOD;\n            total+=color;\n        }\n        out.println(result);\n        out.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long nCr[1010][1010];\nint main() {\n  nCr[0][0] = 1;\n  for (int i = 1; i < 1010; ++i) {\n    nCr[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      nCr[i][j] = (nCr[i - 1][j] + nCr[i - 1][j - 1]) % 1000000007;\n  }\n  int k;\n  cin >> k;\n  long long n = 0, ans = 1;\n  while (k--) {\n    int tmp;\n    cin >> tmp;\n    ans *= nCr[n + tmp - 1][tmp - 1];\n    ans %= 1000000007;\n    n += tmp;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "t = 10**9 + 7\ncomb = [[0 for i in range(1001)]for i in range(1001)]\ncomb[0][0] = 1\nfor i in range(1, 1001):\n    comb[i][0] = 1\n    for j in range(1, i + 1):\n        comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % t\nans = 1\nf = 0\nfor _ in range(int(input())):\n    c = int(input())\n    ans = (ans * comb[f + c - 1][c - 1]) % t\n    f += c\n\nprint(ans % t)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Created by andrii on 8/3/15.\n */\npublic class _309C {\n\n    private static final int mod = 1000000007;\n\n    public static void main(String...args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out, true);\n        int n = reader.nextInt();\n        int[] kArray = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            kArray[i] = reader.nextInt();\n        }\n\n        long[][] comb = new long[1010][1010];\n        comb[0][0] = 1;\n        for (int i = 1; i < 1010; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n            }\n        }\n\n        long res = 1;\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            res = (res * comb[total + kArray[i] - 1][kArray[i] - 1]) % mod;\n            total += kArray[i];\n        }\n\n        out.println(res);\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n        }\n\n        public String next() {\n            if (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int T = 1001;\nint C[T], DP[T], KP[T][T];\nint main() {\n  long long k, j = -1, mod = 1000000007, tmp = 1, th = 0;\n  for (int i = 0; i < T; i++) {\n    KP[i][0] = 1;\n    for (int j = 1; j < i + 1; j++) {\n      KP[i][j] = (KP[i - 1][j] + KP[i - 1][j - 1]) % mod;\n    }\n  }\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> C[i];\n    j += C[i];\n  }\n  for (int i = 0; i < k; i++) {\n    th += C[i];\n    tmp *= KP[th - 1][C[i] - 1];\n    tmp %= mod;\n  }\n  cout << tmp;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class C554C {\n    private static int k;\n    private static int[] c;\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws IOException {\n        input();\n        output();\n    }\n\n    private static long solve() {\n        long[][] combinations = getCombinations();\n        long res = 1;\n        int total = 0;\n\n        for (int i = 0; i < k; i++) {\n            total += c[i];\n            res = (res * combinations[total - 1][c[i] - 1]) % MOD;\n        }\n        return res;\n    }\n\n    private static long[][] getCombinations() {\n        long[][] combs = new long[1001][1001];\n        combs[0][0] = 1;\n        for (int i = 1; i <= 1000; i++) {\n            combs[i][0] = combs[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                combs[i][j] = (combs[i - 1][j] + combs[i - 1][j - 1]) % MOD;\n            }\n        }\n        return combs;\n    }\n\n    private static void output() {\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(solve());\n        out.close();\n    }\n\n    private static void input() {\n        Scanner sc = new Scanner(System.in);\n        k = sc.nextInt();\n        c = new int[k];\n        IntStream.range(0, k).forEach(i -> c[i] = sc.nextInt());\n        sc.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a = 1;\n  vector<vector<long long int> > v(1005);\n  int i, j;\n  for (i = 0; i <= 1000; i++) {\n    j = 0;\n    while (j <= i) {\n      if (j == 0 || i == j) {\n        v[i].push_back(a);\n      } else {\n        v[i].push_back((v[i - 1][j] + v[i - 1][j - 1]) % 1000000007);\n      }\n      j++;\n    }\n  }\n  long long int k, n1, var1, var2, x;\n  long long int ans = 1;\n  cin >> k;\n  cin >> n1;\n  var1 = n1 - 1;\n  if (k == 1) {\n    cout << ans << endl;\n  } else {\n    for (i = 1; i < k; i++) {\n      cin >> x;\n      var1 = var1 + x;\n      var2 = x - 1;\n      ans = (ans * (v[var1][var2])) % 1000000007;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Luck{\n\tpublic static InputReader sc;\n    public static PrintWriter out;\n    public static final long MOD = (long)1e9 + 7L;\n    public static void main(String[] args){\n    \tsc=new InputReader(System.in);\t\n    \tout=new PrintWriter(System.out);\n    \tlong[][] dp=new long[1010][1010];\n    \tdp[0][0]=1L;\n    \tfor(int i=1;i<1010;i++){\n    \t\tdp[i][0]=1L;\n    \t\tfor(int j=1;j<=i;j++){\n    \t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%MOD;\n    \t\t}\n    \t}\n    \tint n=sc.nextInt();\n    \tint total=0;\n    \tlong res=1L;\n    \tfor(int i=0;i<n;i++){\n    \t\tint c=sc.nextInt();\n    \t\tres=(res*dp[total+c-1][c-1])%MOD;\n    \t\ttotal+=c;\n    \t}\n    \tout.println(res);\n    \tout.close();\n    }\n    \n//    static class Pair{\n//    \tString x;\n//    \tint y;\n//    \tPair(){\n//    \t\tthis.x=\"\";\n//    \t\tthis.y=-1;\n//    \t}\n//    \tPair(String profit,int val,int count){\n//    \t\tthis.x=profit;\n//    \t\tthis.y=val;\n//    \t}\n//    \tpublic static Comparator<Pair> Val=new Comparator<Pair>(){\n//    \t\tpublic int compare(Pair p1,Pair p2){\n//    \t\t\tif(p1.x==p2.y){\n//    \t\t\t\treturn p1.y-p2.y;\n//    \t\t\t}\n//    \t\t\treturn (int)p1.x-(int)p2.x;\n//    \t\t}\n//    \t};\n//    \tpublic int hashCode() {\n//    \t\tfinal int prime = 31;\n//    \t\tint result = 1;\n//    \t\tresult = prime * result + x;\n//    \t\tresult = prime * result + x;\n//    \t\treturn result;\n//    \t}\n//    \tpublic boolean equals(Object obj){\n//    \t\tif (this == obj)\n//    \t        return true;\n//    \t    if (!(obj instanceof Pair)) {\n//    \t        return false;\n//    \t    }\n//    \t \n//    \t    Pair p = (Pair) obj;\n//    \t    if(p.x!=this.x){\n//    \t    \treturn false;\n//    \t    }\n//    \t    else if(p.y!=p.y){\n//    \t    \treturn false;\n//    \t    }\n//    \t    return true;\n//    \t}\n//    }\n    static class DisjointSet{\n    \tint n;\n    \tint[] par;\n    \tint[] rank;\n    \tDisjointSet(int n){\n    \t\tthis.n=n;\n    \t\tthis.par=new int[n];\n    \t\tthis.rank=new int[n];\n    \t\tmakeSet();\n    \t}\n    \tvoid makeSet(){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tpar[i]=i;\n    \t\t\trank[i]=1;\n    \t\t}\n    \t}\n    \tvoid union(int x,int y){\n    \t\tint parX=parent(x);\n    \t\tint parY=parent(y);\n    \t\tif(parX!=parY){\n    \t\t\tif(rank[parX]>=rank[parY]){\n    \t\t\t\trank[parX]+=rank[parY];\n    \t\t\t\trank[parY]=0;\n    \t\t\t\tpar[parY]=parX;\n    \t\t\t}\n    \t\t\telse{\n    \t\t\t\trank[parY]+=rank[parX];\n    \t\t\t\trank[parX]=0;\n    \t\t\t\tpar[parX]=parY;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint parent(int c){\n    \t\tint i=c;\n    \t\twhile(i!=par[i]){\n    \t\t\ti=par[i];\n    \t\t}\n    \t\treturn i;\n    \t}\n    }\n    static int gcd(int a,int b){\n    \tif(b==0){\n    \t\treturn a;\n    \t}\n    \treturn gcd(b,a%b);\n    \t\n    }\n    static int lcm(int a,int b){\n    \tint g;\n    \tif(a<b){\n    \t\tg=gcd(b,a);\n    \t}\n    \telse{\n    \t\tg=gcd(a,b);\n    \t}\n    \treturn (a*b)/g;\n    }\n    static long bigmod ( long a, long p, long m ) {\n        long res = 1 % m, x = a % m;\n        while ( p>0 ) {\n            if ( (p & 1)==1 ) res = ( res * x ) % m;\n            x = ( x * x ) % m; p >>= 1;\n        }\n        return res;\n    }\n    static boolean isPrime(int n){\n    \t if (n == 2)\n    \t        return true;\n    \t    for (long i = 2; i * i <= n; i++) {\n    \t        if (n % i == 0)\n    \t            return false;\n    \t    }\n    \t    return true;\n    }\n    \n    static void shuffle(int[] A){\n    \tfor(int i=A.length-1;i>0;i--){\n    \t\tint j=(int)(Math.random()*(i+1));\n    \t\tint temp=A[j];\n    \t\tA[j]=A[i];\n    \t\tA[i]=temp;\n    \t}\n    }\n    \n//\tpublic static class Node implements Comparable<Node>{\n//\t    int u;\n//\t    int v;\n//\t    public Node(){\n//\t    \t;\n//\t    }\n//\t    public Node (int u, int v) {\n//\t    \tthis.u = u;\n//\t        this.v = v;\n//\t    }\n//\t    \n//\t    public void print() {\n//\t        out.println(v + \" \" + u + \" \");\n//\t    }\n//\t   \n//\t    public int compareTo(Node n1){\n//\t    \treturn this.u-n1.u;\n//\t    }\n//\t}\n\tpublic static long pow(long base,long exp,long mod){\n\t\tif(exp==0){\n\t\t\treturn 1;\n\t\t}\n\t\tif(exp==1){\n\t\t\treturn base;\n\t\t}\n\t\tlong temp=exp/2;\n\t\tlong val=pow(base,temp,mod);\n\t\tlong result=val*val;\n\t\tresult=(result%mod);\n\t\tlong AND=exp&1;\n\t\tif(AND==1){\n\t\t\tresult*=base;\n\t\t\tresult=(result%mod);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static BigInteger pow(BigInteger base, BigInteger exp) {\n\t    if(exp.equals(new BigInteger(String.valueOf(0)))){\n\t        return new BigInteger(String.valueOf(1));\n\t    }    \n\t    if(exp.equals(new BigInteger(String.valueOf(1))))\n\t        return base;\n\t    BigInteger temp=exp.divide(new BigInteger(String.valueOf(2)));\n\t    BigInteger val = pow(base, temp);\n\t    BigInteger result = val.multiply(val);\n\t    result=result.remainder(new BigInteger(String.valueOf(MOD)));\n\t    BigInteger AND=exp.and(new BigInteger(String.valueOf(1)));\n\t    if(AND.equals(new BigInteger(String.valueOf(1)))){\n\t        result = result.multiply(base);\n\t        result=result.remainder(new BigInteger(String.valueOf(MOD)));\n\t    }    \n\t    return result;\n\t}\n\t    \n\tstatic class InputReader {\n\n\t    private InputStream stream;\n\t    private byte[] buf = new byte[8192];\n\t    private int curChar, snumChars;\n\t    private SpaceCharFilter filter;\n\n\t    public InputReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\n\t    public int snext() {\n\t        if (snumChars == -1)\n\t            throw new InputMismatchException();\n\t        if (curChar >= snumChars) {\n\t            curChar = 0;\n\t            try {\n\t                snumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (snumChars <= 0)\n\t                return -1;\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = snext();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public long nextLong() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = snext();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t        int a[] = new int[n];\n\t        for (int i = 0; i < n; i++)\n\t            a[i] = nextInt();\n\t        return a;\n\t    }\n\n\t    public String readString() {\n\t        int c = snext();\n\t        while (isSpaceChar(c))\n\t            c = snext();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = snext();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    public boolean isSpaceChar(int c) {\n\t        if (filter != null)\n\t            return filter.isSpaceChar(c);\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    public interface SpaceCharFilter {\n\t        public boolean isSpaceChar(int ch);\n\t    }\n\t}\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class P554C {\n\n  static BufferedReader in;\n  static PrintWriter out;\n  static StringTokenizer tok;\n\n  static void solve() throws Exception {\n    long MOD = 1000000007;\n    int N = 1000;\n    int k = nextInt();\n    int[] c = nextIntArray(k, 0);\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n      sum += c[i];\n    long ans = 1;\n    long[][] bc = bc(N, MOD);\n    for (int i = k - 1; i > 0; i--) {\n      ans = ans * bc[sum - 1][c[i] - 1] % MOD;\n      sum -= c[i];\n    }\n    out.println(ans);\n  }\n\n  static long[][] bc(int n, long mod) {\n    long[][] bc = new long[n][n];\n    for (int i = 0; i < n; i++) {\n      bc[i][0] = bc[i][i] = 1;\n      for (int j = 1; j < i; j++)\n        bc[i][j] = (bc[i - 1][j - 1] + bc[i - 1][j]) % mod;\n    }\n    return bc;\n  }\n\n  public static void main(String args[]) {\n    try {\n      in = new BufferedReader(new InputStreamReader(System.in));\n      out = new PrintWriter(new OutputStreamWriter(System.out));\n      solve();\n      in.close();\n      out.close();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n\n  static int nextInt() throws IOException {\n    return Integer.parseInt(next());\n  }\n\n  static int[] nextIntArray(int len, int start) throws IOException {\n    int[] a = new int[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextInt();\n    return a;\n  }\n\n  static long nextLong() throws IOException {\n    return Long.parseLong(next());\n  }\n\n  static long[] nextLongArray(int len, int start) throws IOException {\n    long[] a = new long[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextLong();\n    return a;\n  }\n\n  static String next() throws IOException {\n    while (tok == null || !tok.hasMoreTokens()) {\n      tok = new StringTokenizer(in.readLine());\n    }\n    return tok.nextToken();\n  }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Jaydeep Maddipati\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    public static final int mod=(int)1e9+7;\n    public static final int N=(int)1e3+50;\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int k=in.nextInt();\n        int ncr[][]=new int[N][N];\n        ncr[0][0]=1;\n        for(int i=1;i<N;i++){\n            ncr[i][0]=1;\n            for(int j=1;j<=i;j++){\n                ncr[i][j]=ncr[i-1][j]+ncr[i-1][j-1];\n                if(ncr[i][j]>=mod)ncr[i][j]-=mod;\n            }\n        }\n        long ans=1;int tot=in.nextInt();\n        for(int i=1;i<k;i++){\n            int val=in.nextInt();\n            ans=ans*ncr[tot+val-1][val-1];\n            tot+=val;\n            ans%=mod;\n        }\n        out.println(ans);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a1[1001][1001];\nint main() {\n  for (int i = 0; i < 1001; ++i) a1[i][0] = 1;\n  for (int i = 1; i < 1001; ++i)\n    for (int j = 1; j <= i; ++j)\n      a1[i][j] = (a1[i - 1][j - 1] + a1[i - 1][j]) % 1000000007;\n  int n, k, a, b;\n  long long o = 1;\n  scanf(\"%d%d\", &n, &a);\n  for (int i = 1; i < n; ++i, a += b) {\n    scanf(\"%d\", &b);\n    o = o * a1[a + b - 1][b - 1] % 1000000007;\n  }\n  printf(\"%d\\n\", o);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Aldo Culquicondor\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    long[] FI;\n    final long mod = 1000000007;\n    long comb(int n, int m) {\n        long ans = 1;\n        for (int i = 0; i < m; ++i)\n            ans = NumberTheory.mod(ans * (n - i), mod);\n        ans = NumberTheory.mod(ans * FI[m], mod);\n        return ans;\n    }\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        FI = new long[1001];\n        long fa = 1;\n        FI[0] = 1;\n        for (int i = 1; i <= 1000; ++i) {\n            fa = NumberTheory.mod(fa * i, mod);\n            FI[i] = NumberTheory.expMod(fa, mod - 2, mod);\n        }\n        int k = in.nextInt(), sum = 0;\n        int[] C = new int[k];\n        for (int i = 0; i < k; ++i) {\n            C[i] = in.nextInt();\n            sum += C[i];\n        }\n        long ans = 1;\n        for (int i = k - 1; i >= 0; --i) {\n            ans = NumberTheory.mod(ans * comb(sum - 1, C[i] - 1), mod);\n            sum -= C[i];\n        }\n        out.println(ans);\n    }\n}\n\nclass NumberTheory {\n    public static long mod(long x, long mod) {\n        return x >= mod || x <= -mod ? x % mod : x;\n    }\n    public static long expMod(long a, long e, long mod) {\n        long r = 1;\n        while (e > 0) {\n            if ((e & 1) != 0)\n                r = mod(a * r, mod);\n            e >>= 1;\n            a = mod(a * a, mod);\n        }\n        return r < 0 ? r + mod : r;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from math import *\nfrom collections import deque\nfrom copy import deepcopy\nimport sys\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef multi(): return map(int,input().split())\ndef strmulti(): return map(str, inp().split())\ndef lis(): return list(map(int, inp().split()))\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef stringlis(): return list(map(str, inp().split()))\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef printlist(a) :\n    print(' '.join(str(a[i]) for i in range(len(a))))\n\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#copied functions end\n\n#start coding\n\n\nk=int(input())\n\nans=1\nsum=0\nfor i in range(k):\n    num=int(input())\n    sum+=num\n    ans*=(ncr(sum-1,num-1))\n    # print(ans)\n\nprint(ans%1000000007)\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int N = 1005;\nlong long dp[N][N];\nlong long arr[N];\nint main() {\n  for (int i = 1; i < N; ++i) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      if (i == j)\n        dp[i][j] = 1;\n      else if (i > j)\n        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD;\n    }\n  }\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> arr[i];\n  long long ans = 1, sum = arr[1];\n  for (int i = 2; i <= n; ++i) {\n    sum += arr[i];\n    ans = (ans * dp[sum - 1][arr[i] - 1]) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class Abood2A {\n\n\tstatic final long MOD = (long) 1e9 + 7;\n\n\n\n\tstatic long nCr4(long l, int K) {\n\t\tif(K > l)\n\t\t\treturn 0;\n\t\tlong res = 1;\n\t\tfor(int i = 1; i <= K; ++i) {\n\t\t\tres = (((l - K + i) * res) % MOD )* modPow(i, (int) (MOD - 2));\n\t\t\tres %= MOD;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modPow(long a, int e) {\n\t\ta %= MOD;\n\t\tlong res = 1;\n\t\twhile(e > 0)\n\t\t{\n\t\t\tif((e & 1) == 1)\n\t\t\t\tres = (res * a) % MOD;\n\t\t\ta = (a * a) % MOD;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tlong total = 0;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttotal += (a[i] = sc.nextInt());\n\n\t\tlong ans = 1;\n\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tans *= nCr4(total - 1, a[i] - 1);\n\t\t\tans %= MOD;\n\t\t\ttotal -= a[i];\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t\tout.flush();\n\n\t}\n\n\n\tstatic class Scanner \n\n\n\n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\n\n\t}\n\n}"
        },
        {
            "language": 1,
            "solution": "N = input()\nV = [input() for i in range(N)]\nC = [ [0 for i in range(1010)] for i in range(1010) ]\n\nAns = 1\nMOD = 10 ** 9 + 7\n\nC[0][0] = 1\n\nfor i in range(1, 1010):\n\tC[i][0] = 1\n\tC[i][i] = 1\n\tfor j in range(1, i):\n\t\tC[i][j] = C[i - 1][j] + C[i - 1][j - 1]\n\n\nfor i in range(N - 1, 0, -1):\n\tAns = (Ans * C[ sum(V[:i + 1]) - 1 ][ V[i] - 1 ]) % MOD\n\nprint Ans"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class Third {\n\n    public static long mod = 1000000007;\n//  public static long mod = 1;\n    \n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = readInt(br);\n        \n        int[] arr = new int[n];\n        \n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = readInt(br);\n            \n            total += arr[i];\n        }\n        \n        long ans = 1;\n//      System.out.println(comb(99, 2));\n        for(int i = n-1; i >= 0; i--) {\n            ans = ans * comb(total -1, arr[i] - 1);\n            \n            ans = ans%mod;\n            \n            total -= arr[i];\n        }\n        \n        System.out.println(ans);\n    }\n    \n    private static long comb(int n, int r) {\n//      System.out.print(n + \" \" + r + \" \");\n//      long mul = 1;\n        \n        BigInteger mul = BigInteger.ONE;\n        BigInteger bMod = new BigInteger(mod + \"\");\n        int l = n-r;\n        \n        while(n > 0) {\n            mul = mul.multiply(new BigInteger(n + \"\"));\n//          while(r > 1 && mul%r ==0) {\n//              mul = mul/r;\n//              r--;\n//          }\n//          while(l > 1 && mul%l ==0) {\n//              mul = mul/l;\n//              l--;\n//          }\n            \n//          mul = mul.mod(bMod);\n            n--;\n        }\n        \n        BigInteger den = BigInteger.ONE;\n        \n        while(l > 0) {\n            den = den.multiply(new BigInteger(l + \"\"));\n//          den = den.mod(bMod);\n            l--;\n        }\n        \n        while(r > 0) {\n            den = den.multiply(new BigInteger(r + \"\"));\n//          den = den.mod(bMod);\n            r--;\n        }\n        \n        mul = mul.divide(den);\n        mul = mul.mod(bMod);\n        \n//      System.out.println(mul);\n        return mul.longValue();\n    }\n\n    public static int readInt(BufferedReader br) throws NumberFormatException,\n            IOException {\n        return Integer.parseInt(br.readLine());\n    }\n\n    public static long readLong(BufferedReader br)\n            throws NumberFormatException, IOException {\n        return Long.parseLong(br.readLine());\n    }\n\n    public static int[] readArray(BufferedReader br) throws IOException {\n        String[] arr = br.readLine().split(\" \");\n        int[] a = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            a[i] = Integer.parseInt(arr[i]);\n        }\n        return a;\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "k, mod, top = int(input()), 1000000007, 1000\nc = [ int(input()) for _ in range(k) ]\n\nncr = [ [0] * top for _ in range(top) ] # rotates pascal lol\nncr[0][0] = 1\nfor n in range(1, top):\n    ncr[n][0] = 1\n    for r in range(top):\n        ncr[n][r] = (ncr[n - 1][r] + ncr[n - 1][r - 1]) % mod\n\nways, colors = 1, 0\n\nfor i in range(k):\n    ways = ( ways * ncr[ colors + c[i] - 1 ][ c[i] - 1 ] ) % mod\n    colors += c[i]\n\nprint(ways)"
        },
        {
            "language": 1,
            "solution": "k = int(raw_input())\n\nh = []\n\nfor i in xrange(k):\n    h.append(int(raw_input()))\n\n\nffs = [1]\ndef f(n):\n    if n < len(ffs):\n        return ffs[n]\n    v = n * f(n-1)\n    ffs.append(v)\n    return v\n\n\ndef c(k, n):\n    return f(n) / (f(k) * f(n-k))\n\ndef cc(k, n):\n    return c(n-1, n + k-1)\n\n\ndef solve(h):\n    if len(h) == 1:\n        return 1\n\n    hh = h[:-1]\n    hh_len = sum(hh)\n\n    return solve(hh) * cc(h[-1] -1, hh_len + 1)\n\n\nr = 1\nfor i in range(len(h)):\n    r *= cc(h[i] -1, sum(h[:i]) + 1)\nprint r % 1000000007\n\n\n\n#print solve(h)  % 1000000007"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long dp[1005][1005];\nint k;\nint c[1002];\nint main() {\n  cin >> k;\n  int n = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> c[i];\n    n += c[i];\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod;\n    }\n  }\n  int cb = 0;\n  long long ans = 1;\n  for (int i = 1; i <= k; i++) {\n    ans = (ans * dp[cb + c[i] - 1][c[i] - 1]) % mod;\n    cb += c[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\ncnt = []\nfor i in range(n):\n    cnt.append(int(input()))\n\ndp = [1]\nlength = [cnt[0]]\nMOD = int(1000000007)\n\ndef C(n, k):\n    assert(n >= k)\n    res = 1\n    for i in range(n - k + 1, n + 1):\n        res *= i\n    for i in range(2, k + 1):\n        res //= i\n    \n    \"\"\"DEBUG\"\"\"\n    #import math as m\n    #assert(res == m.factorial(n) // m.factorial(k) // m.factorial(n - k))\n    \"\"\"/DEBUG\"\"\"\n\n    return res % MOD\n    \nfor i in range(1, n):\n    length.append(length[i - 1] + cnt[i])\n    dp.append((dp[i - 1] * C(length[i] - 1, cnt[i] - 1)) % MOD)\n\nprint(dp[n - 1])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long m = 1000 * 1000 * 1000 + 7, maxN = 1000 + 10;\nlong long p[maxN];\nlong long dp[maxN];\nlong long a[maxN];\nlong long se[maxN][maxN];\nint main() {\n  for (int i = 0; i < 1000; i++) {\n    se[i][i] = 1;\n    se[i][0] = 1;\n  }\n  for (int i = 2; i < 1000; i++) {\n    for (int j = 1; j < i; j++) {\n      se[i][j] = (se[i - 1][j] + se[i - 1][j - 1]) % m;\n    }\n  }\n  int n;\n  cin >> n;\n  p[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    p[i] = p[i - 1] + a[i];\n  }\n  for (int i = n; i > 0; i--) {\n    dp[i] = (se[p[i] - 1][a[i] - 1]) % m;\n  }\n  dp[0] = 1;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = (dp[i - 1] * dp[i]) % m;\n  }\n  cout << dp[n];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class C implements Runnable {\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\tprivate long[][] comb;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new C(), \"\", 256 * (1L << 20)).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\tif (System.getProperty(\"ONLINE_JUDGE\") != null) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t\t}\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\n\t// solution\n\tfinal static private long MODULUS = 1000000007L;\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tlong sum = 0;\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\ta[i] = readLong();\n\t\t\tsum += a[i];\n\t\t}\n\t\tcomb = new long[(int) sum][(int) sum];\n\t\tfor(int i = 0 ; i < sum ; i++)\n\t\t\tcomb[i][0] = comb[0][i] = 1;\n\t\tcomb[0][0] = 0;\n\t\tfor(int  num = 1; num < sum ; num++)\n\t\t\tfor(int k = 1 ; k <= num ; k++) {\n\t\t\t\tcomb[k][num] = (comb[k-1][num-1] + comb[k][num-1]) %  MODULUS;\n//\t\t\t\tout.println(String.format(\"(k=%d, n =%d)=%d  \", k,num, comb[k][num]));\n\t\t\t}\n\t\tout.println(solution(a));\n\t}\n\n\tprivate long solution(long[] a) {\n\t\tif ( a.length == 1 ) return 1;\n\t\tlong sum = 0;\n\t\tfor(int i = 0 ; i < a.length ; i++)\n\t\t\tsum += a[i];\n\t\tlong[] b = new long[a.length-1];\n\t\tfor(int i = 0 ; i < b.length ; i++) b[i] = a[i];\n\t\treturn (comb[(int) a[a.length-1]-1][(int) (sum-1)] * solution(b)) % MODULUS;\n\t}\n\n\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nMAX = 1010\nMOD = 10**9+7\nfact = [0]*MAX #fact[i]: i!\ninv = [0]*MAX #inv[i]: i\u306e\u9006\u5143\nfinv = [0]*MAX #finv[i]: i!\u306e\u9006\u5143\nfact[0] = 1\nfact[1] = 1\nfinv[0] = 1\nfinv[1] = 1\ninv[1] = 1\n    \nfor i in range(2, MAX):\n    fact[i] = fact[i-1]*i%MOD\n    inv[i] = MOD-inv[MOD%i]*(MOD//i)%MOD\n    finv[i] = finv[i-1]*inv[i]%MOD\n\ndef C(n, r):\n    if n<r:\n        return 0\n    if n<0 or r<0:\n        return 0\n    return fact[n]*(finv[r]*finv[n-r]%MOD)%MOD\n\nk = int(input())\nc = [int(input()) for _ in range(k)]\ns = sum(c)\nacc = 0\np = [0]*(s+1)\np[0] = 1\n\nfor ci in c:\n    np = [0]*(s+1)\n    p_acc = p[0]\n    \n    for i in range(1, s+1):\n        np[i] = (p_acc*C(i-acc-1, ci-1))%MOD\n        p_acc += p[i]\n        \n    acc += ci\n    p = np\n    \nprint(p[s])"
        },
        {
            "language": 3,
            "solution": "from heapq import heapify, heappush, heappop\nfrom collections import Counter, defaultdict, deque, OrderedDict\nfrom sys import setrecursionlimit, maxsize\nfrom bisect import bisect_left, bisect, insort_left, insort\nfrom math import ceil, log, factorial, hypot, pi\nfrom fractions import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom operator import mul\nfrom itertools import product, permutations, combinations, accumulate, cycle\nfrom string import ascii_uppercase, ascii_lowercase, ascii_letters, digits, hexdigits, octdigits\n\nprod = lambda l: reduce(mul, l)\nprodmod = lambda l, mod: reduce(lambda x, y: mul(x,y)%mod, l)\n\ndef read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\nmod = 10**9+7\ndef inv(x):\n    return pow(x, mod-2, mod)\n\nK = read_line(int)\nballs = read_lines(int, K)\n\ns = balls[0]\nans = 1\nfor ball in balls[1:]:\n    ans *= ball\n    ans %= mod\n    for i in range(s+1, s+ball):\n        ans *= i\n        ans %= mod\n    for i in range(ball):\n        ans *= inv(i+1)\n        ans %= mod\n    s += ball\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nT sabs(T x) {\n  if (x < 0)\n    return x * -1;\n  else\n    return x;\n}\ntemplate <class T>\nT sgcd(T x, T y) {\n  if (y == 0)\n    return x;\n  else\n    return sgcd(y, x % y);\n}\ntemplate <class T>\nT smax(T x, T y) {\n  if (x > y)\n    return x;\n  else\n    return y;\n}\ntemplate <class T>\nT smin(T x, T y) {\n  if (x > y)\n    return y;\n  else\n    return x;\n}\ntemplate <class T>\nT smod(T a, T b, T m) {\n  T res = 1, x = b;\n  while (b > 0) {\n    if (x & 1) res = ((res % m) * (x % m)) % m;\n    x = (x * x) % m;\n    b = (b >> 1);\n  }\n  return res;\n}\nusing namespace std;\ninline void writeInt(int x) {\n  if (x == -1) {\n    putchar('-');\n    putchar('1');\n    putchar('\\n');\n  } else {\n    int i = 10;\n    char buf[11];\n    buf[10] = ' ';\n    do {\n      buf[--i] = x % 10 + '0';\n      x /= 10;\n    } while (x);\n    do {\n      putchar(buf[i]);\n    } while (buf[i++] != ' ');\n  }\n}\ninline void fastInput(int &x) {\n  register int c = getchar();\n  x = 0;\n  int neg = 0;\n  for (; ((c < 48 || c > 57) && c != '-'); c = getchar())\n    ;\n  if (c == '-') {\n    neg = 1;\n    c = getchar();\n  }\n  for (; c > 47 && c < 58; c = getchar()) {\n    x = (x << 1) + (x << 3) + c - 48;\n  }\n  if (neg) x = -x;\n}\nlong long int MOD = 1e9 + 7;\nint dp[1005][1005];\nvoid init() {\n  for (int i = 0; i <= 1000; i++) {\n    dp[i][0] = 1;\n    dp[0][i] = 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 1; j <= i; j++) {\n      long long int term = dp[i - 1][j] + dp[i - 1][j - 1];\n      term %= MOD;\n      dp[i][j] = term;\n    }\n  }\n}\nint main() {\n  init();\n  int a, k;\n  long long int ans = 1, res = 0;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> a;\n    res += a;\n    ans *= dp[res - 1][a - 1];\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Sol {\n\n\tstatic final boolean stdin = true;\n\tstatic final String filename = \"\";\n\tstatic FastScanner br;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (stdin) {\n\t\t\tbr = new FastScanner();\n\t\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t} else {\n\t\t\tbr = new FastScanner(filename + \".in\");\n\t\t\tpw = new PrintWriter(new FileWriter(filename + \".out\"));\n\t\t}\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(br, pw);\n\t}\n\n\tstatic class Solver {\n\t\tstatic long mod = 1000000007;\n\t\tstatic int[] cnts, psum;\n\t\tstatic long[][] c;\n\n\t\tpublic void solve(FastScanner br, PrintWriter pw) throws IOException {\n\t\t\tint n = br.nextInt();\n\t\t\tc = new long[1001][1001];\n\t\t\tcnts = new int[n];\n\t\t\tpsum = new int[n];\n\t\t\tc[0][0] = 1;\n\t\t\tfor (int i = 1; i < 1001; i++) {\n\t\t\t\tc[i][0] = 1;\n\t\t\t\tfor (int j = 1; j < i + 1; j++) {\n\t\t\t\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcnts[i] = br.nextInt();\n\t\t\t\tpsum[i] = cnts[i];\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tpsum[i] += psum[i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(recur(n));\n\t\t\tpw.close();\n\t\t}\n\n\t\tstatic long recur(int s) {\n\t\t\tif (s == 0) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\t//System.out.println((c[psum[s - 1] - 1][cnts[s - 1] - 1]) % mod);\n\t\t\t\treturn (recur(s - 1) * c[psum[s - 1] - 1][cnts[s - 1] - 1]) % mod;\n\t\t\t}\n\t\t}\n\n\t\tstatic long pow(long a, long b) {\n\t\t\tif (b == 0)\n\t\t\t\treturn 1L;\n\t\t\tlong val = pow(a, b / 2);\n\t\t\tif (b % 2 == 0)\n\t\t\t\treturn val * val % mod;\n\t\t\telse\n\t\t\t\treturn val * val % mod * a % mod;\n\t\t}\n\n\t}\n\n\tstatic class Point1 implements Comparable<Point1> {\n\t\tint a;\n\t\tint b;\n\n\t\tPoint1(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point1 o) {\n\t\t\treturn this.a - o.a;\n\t\t}\n\n\t}\n\n\tstatic class Point2 implements Comparable<Point2> {\n\t\tString a;\n\t\tint b;\n\n\t\tPoint2(String a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point2 o) {\n\t\t\tif (this.a.equals(o.a))\n\t\t\t\treturn 0;\n\t\t\treturn -this.b + o.b;\n\t\t}\n\n\t}\n\n\tstatic class Dsu {\n\t\tint n;\n\t\tint[] parent;\n\t\tint[] rank;\n\n\t\tpublic Dsu(int n) {\n\t\t\tthis.n = n;\n\t\t\tparent = new int[n];\n\t\t\trank = new int[n];\n\t\t}\n\n\t\tpublic void createSet() {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic int findParent(int x) {\n\t\t\tif (parent[x] == x)\n\t\t\t\treturn x;\n\t\t\tparent[x] = findParent(parent[x]);\n\t\t\treturn parent[x];\n\t\t}\n\n\t\tpublic void mergeSet(int a, int b) {\n\t\t\tint pa = findParent(a);\n\t\t\tint pb = findParent(b);\n\n\t\t\tif (pa == pb)\n\t\t\t\treturn;\n\n\t\t\tif (rank[pa] > rank[pb]) {\n\t\t\t\tparent[pb] = pa;\n\t\t\t} else if (rank[pa] < rank[pb]) {\n\t\t\t\tparent[pa] = pb;\n\t\t\t} else {\n\t\t\t\tparent[pb] = pa;\n\t\t\t\trank[pa]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tArrayList<Integer>[] nextGraph(int nodes, int edges) {\n\t\t\tArrayList<Integer>[] adj = new ArrayList[nodes];\n\t\t\tfor (int i = 0; i < nodes; i++) {\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < edges; i++) {\n\t\t\t\tint a = nextInt() - 1;\n\t\t\t\tint b = nextInt() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef euclid_algorithm(a, b):\n    t1, t2 = abs(a), abs(b)\n    #saving equalities:\n    #t1 == x1 * a + y1 * b,\n    #t2 == x2 * a + y2 * b. \n    x1, y1, x2, y2 = int(math.copysign(1, a)), 0, 0, int(math.copysign(1, b))\n    if t1 < t2:\n        t1, t2 = t2, t1\n        x1, y1, x2, y2 = x2, y2, x1, y1\n\n    while t2 > 0:\n        if x1 * a + y1 * b != t1:\n            print('inshalla')\n        k = int(t1 // t2)\n        t1, t2 = t2, t1 % t2\n        #t1 - k * t2 == (x1 - k * x2) * a + (y1 - k * y2) * b\n        x1, y1, x2, y2 = x2, y2, x1 - k * x2, y1 - k * y2\n\n    return t1, x1, y1\n\ndef opposite_element(x, p):\n    gcd, k, l = euclid_algorithm(x, p)\n    if gcd != 1:\n        return -1\n    return k % p\n\ndef fact_mod(n, p):\n    prod = 1\n    for i in range(2,n+1):\n        prod *= i\n        prod %= p\n    return prod\n\nk = int(input())\nc = []\nfor i in range(k):\n    c.append(int(input()))\nprefix_sum = 0\np = 10 ** 9 + 7\ndenominator = 1\nfor c_i in c:\n    denominator *= fact_mod(c_i - 1, p)\n    denominator %= p\n    prefix_sum += c_i\n    denominator *= prefix_sum\n    denominator %= p\n\nnumenator = fact_mod(prefix_sum, p)\n\nprint(numenator * opposite_element(denominator, p) % p)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    BufferedReader in;\n    StringTokenizer str = null;\n    PrintWriter out;\n\n    private String next() throws Exception{\n    \twhile (str == null || !str.hasMoreElements())\n    \t    str = new StringTokenizer(in.readLine());\n    \treturn str.nextToken();\n    }\n    \n    private int nextInt() throws Exception{\n\t   return Integer.parseInt(next());\n    }\n    \n    long [][]c;\n    final int N = 1010;\n    final long MOD = (long)1e9 + 7;\n    \n    public void run() throws Exception{\n    \tin = new BufferedReader(new InputStreamReader(System.in));\n    \tout = new PrintWriter(System.out);\n    \t\n    \tc = new long[N][N];\n    \tfor(int i = 0; i < N; ++i){\n    \t    c[i][0] = c[i][i] = 1;\n    \t    for(int j = 1; j < i; ++j){\n    \t\tc[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD;\n    \t    }\n    \t}\n    \t\n\tint n = nextInt();\n\tint []a = new int[n];\n\tfor(int i = 0; i < n; ++i) a[i] = nextInt();\n\tint []s = new int[n];\n\ts[0] = a[0];\n\tfor(int i = 1; i < n; ++i) s[i] = s[i-1] + a[i];\n\tlong []dp = new long[n];\n\tdp[0] = 1;\n\t\n\tfor(int i = 1; i < n; ++i){\n\t    dp[i] = dp[i-1] * C(s[i-1] + a[i] - 1, a[i] - 1) % MOD;\n\t}\n\t\n\tout.println(dp[n-1]);\n        out.close();\n    }\n    \n    private long C(int n, int k){\n\treturn c[n][k];\n    }\n\n    public static void main(String args[]) throws Exception{\n\t   new Main().run();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader ir = new InputReader(System.in);\n    final long kmod = 993960000099397l;\n    long mod = (long)(1e9 + 7);\n    long mem[][] = new long[2501][2501];\n    void solve() throws IOException{\n        for(int i = 0; i <= 2500; i++)\n            Arrays.fill(mem[i], -1);\n        int n = ir.readInt();\n        int place = ir.readInt();\n        long ans = 1;\n        for(int i = 1; i < n; i++) {\n            int num = ir.readInt();\n            int nbox = place + 1;\n            int kball = num - 1;\n            ans = (ans * nCr(nbox + kball - 1, kball))%mod;\n            place += num;\n        }\n        out.println(ans);\n    }\n    long nCr(int n, int r) {\n    if (r == 0 || r == n) return 1;\n    \n    if(mem[n][r] != -1)\n        return mem[n][r];\n\n    return mem[n][r] = (nCr(n-1, r-1)%mod + nCr(n-1, r)%mod)%mod;\n    }\n    void run() throws IOException{\n        solve();\n        out.close();\n    }\n    public static void main(String args[]) throws IOException{\n        new Main().run();\n    }\n}\nclass InputReader {\n \n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n \n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n    public final int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n    }\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n        public double readDouble() {\n        return Double.parseDouble(readString());\n    }\n \n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public String next() {\n        return readString();\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class ProblemC {\n    public static void main(String[] args) {\n        int testMode = 0;\n        String testInput = \"3\\n\" +\n                \"2\\n\" +\n                \"2\\n\" +\n                \"1\";\n        /*-------------------------------------------------------------------------------------------------------*/\n        FastReader in = new FastReader(testMode == 0 ? System.in : new ByteArrayInputStream(testInput.getBytes()));\n        PrintWriter out = new PrintWriter(System.out);\n        new ProblemSolver().solve(in, out);\n        out.close();\n    }\n}\n\nclass ProblemSolver {\n    final static long M = 1000000007;\n\n    void solve(FastReader in, PrintWriter out) {\n        long k = in.nextInt();\n        long[] c = new long[(int) k];\n        for (int i = 0; i < k; i++) c[i] = in.nextInt();\n\n        if (k == 1) {\n            out.println(1);\n            return;\n        }\n\n        long[] fact = new long[1000001];\n        long[] inv = new long[1000001];\n        inv[0] = 1;\n        fact[0] = 1;\n        for (int i = 1; i <= 1000000; i++) inv[i] = (inv[i - 1] * ModularMultiplicativeInverse.inverse(i, M)) % M;\n        for (int i = 1; i <= 1000000; i++) fact[i] = ((fact[i - 1]) * i) % M;\n\n        long n = c[0];\n        long ans = 1;\n        for (int i = 1; i < k; i++) {\n            long m = c[i] - 1;\n            if (m > 0) {\n                n += m;\n\n                long d = (((fact[(int) n] * inv[(int) m]) % M) * inv[(int) (n - m)]) % M;\n                ans = (ans * d) % M;\n            }\n            n += 1;\n        }\n\n        out.println(ans);\n    }\n}\n\nclass ModularMultiplicativeInverse {\n    // return b such that a*b=1 modulo n\n    // return 0 if such b doesn't exist\n    public static long inverse(long a, long n) {\n        return new MultiplicativeGroupZn(n).inverse(a);\n    }\n}\n\nclass MultiplicativeGroupZn {\n    long n;\n\n    public MultiplicativeGroupZn(long n) {\n        this.n = n;\n    }\n\n    // return b such a*b=1 mod n\n    // return 0 if such b doesn't exist\n    public long inverse(long a) {\n        long[] ret = EuclidAlgorithms.extendedGcd(a, n);\n        return ret[0] == 1 ? ((ret[1] % n) + n) % n : 0;\n    }\n}\n\nclass EuclidAlgorithms {\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    // return [d,x,y] such that d=gcd(a,b)=xa+yb\n    public static int[] extendedGcd(int a, int b) {\n        if (b == 0) return new int[]{a, 1, 0};\n        int[] ret = extendedGcd(b, a % b);\n        int x = ret[1];\n        ret[1] = ret[2];\n        ret[2] = x - ret[2] * (a / b);\n        return ret;\n    }\n\n    // return [d,x,y] such that d=gcd(a,b)=xa+yb\n    public static long[] extendedGcd(long a, long b) {\n        if (b == 0) return new long[]{a, 1, 0};\n        long[] ret = extendedGcd(b, a % b);\n        long x = ret[1];\n        ret[1] = ret[2];\n        ret[2] = x - ret[2] * (a / b);\n        return ret;\n    }\n}\n\nclass FastReader extends BufferedReader {\n    private StringTokenizer st;\n\n    public FastReader(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public String nextToken() {\n        try {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(readLine());\n            }\n            return st.nextToken();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    public int[] nextArrayInt(int size) {\n        int[] ret = new int[size];\n        for (int i = 0; i < size; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n}"
        },
        {
            "language": 1,
            "solution": "mod = 10**9 + 7\n\nfact = [1]\nfor i in xrange(1, 10**6 + 7):\n\tfact.append(fact[-1]*i % mod)\n\nimod = lambda x: pow(x, mod - 2, mod)\n\nk = int(raw_input())\ns = 0\nout = 1\nfor _ in xrange(k):\n\tc = int(raw_input())\n\tout = out*fact[s + c - 1]*imod(fact[s]*fact[c - 1]) % mod\n\ts += c\nprint out\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\n\npublic class Main implements Runnable {\n\t\t\n\tpublic void solve() throws IOException {\n            int n = 1000 + 1;\n            int MOD = 1_000_000_000 + 7;\n            int[][] C = new int[n][n];\n            for(int i = 1; i < n; i++){\n                C[i][i] = C[i][0] = 1;\n                for(int j = 1; j < i; j++){\n                    C[i][j] = C[i-1][j] + C[i-1][j-1];\n                    if(C[i][j] >= MOD) C[i][j] -= MOD;\n                }\n            }\n            \n            \n            int N = nextInt();\n            int[] a = new int[N];\n            int[] sum = new int[N];\n            for(int i = 0; i < N; i++) a[i] = nextInt();\n            for(int i = 0; i < N; i++){\n                sum[i] = a[i];\n                if(i > 0)sum[i] += sum[i-1];\n            }\n            \n            \n            long answer = 1; // if N == 1; there is only 1 way to pick the ball (since same color & indistinguishable)\n            for(int i = 1; i < N; i++){\n                //now assume we are picking the last ball from i-th index\n                //but we know that before picking that ball\n                // we have to pick all ball from 0...(i-1)th color and also (count[i] - 1) balls [count[i] th ball is the last ball we pick now]\n                //thus to pick i-th ball\n                // a[0] + a[1] +........ + (a[i]-1) FROM THIS MANY BALLS HOW MANY WAYS TO PLACE/CHOOSE (a[i] - 1) BALLS\n                // which is equal to\n                //(sum[i] - 1) CHOOSE (a[i]-1) balls\n                \n                answer *= C[sum[i] - 1][a[i]-1];\n                answer %= MOD;\n            }\n            \n            out.println(answer);\n            \n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//-----------------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n        public void debug(Object... arr){\n            System.out.println(Arrays.deepToString(arr));\n        }\n\n        public void print1Int(int[] a){\n                for(int i = 0; i < a.length; i++)\n                        System.out.print(a[i] + \" \");\n                System.out.println();\n        }\n        \n        public void print2Int(int[][] a){\n                for(int i = 0; i < a.length; i++){\n                        for(int j = 0; j < a[0].length; j++){\n                                System.out.print(a[i][j] + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n        \n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n                        out = new PrintWriter(System.out);\n\t\t\ttok = null;\n\t\t\tsolve();\n\t\t\tin.close();\n                        out.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n        PrintWriter out;\n\tBufferedReader in;\n\tStringTokenizer tok;\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tSolve slv = new Solve();\n\t\tslv.solve();\n\t}\n}\n\nclass Solve{\n\tScanner in = new Scanner(System.in);\n\tvoid solve(){\n\t\tint k = in.nextInt();\n\t\tlong res = 1;\n\t\tfinal int mod = 1000000007;\n\t\tint sum = 0;\n\t\tfor(int i=0; i<k; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tres = (res*modcomb(sum+a-1, a-1, mod))%mod;\n\t\t\tsum += a;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tint modcomb(int n, int r, int mod){\n\t\tif(n-r < r) r = n-r;\n\t\tlong res = 1;\n\t\tfor(int i=0; i<r; i++){\n\t\t\tres = (res*(n-i))%mod;\n\t\t}\n\t\tfor(int i=2; i<=r; i++){\n\t\t\tres = (res*modinv(i, mod))%mod;\n\t\t}\n\t\treturn (int)res;\n\t}\n\t\n\tint modinv(int n, int mod){\n\t\treturn modpow(n, mod-2, mod);\n\t}\n\t\n\tint modpow(int n, int a, int mod){\n\t\tlong res = 1;\n\t\twhile(a > 0){\n\t\t\tif((a&1)==1) res = (res*n)%mod;\n\t\t\tn = (int)(((long)n*n)%mod);\n\t\t\ta >>= 1;\n\t\t}\n\t\treturn (int)res;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k;\n  scanf(\"%d\", &k);\n  ;\n  int sum = 0, x;\n  long long int C[1010][1010];\n  for (int i = 0; i < 1010; i++) {\n    C[i][0] = C[i][i] = 1;\n  }\n  for (int i = 1; i < 1010; i++) {\n    for (int j = 1; j < i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      C[i][j] %= 1000000007;\n    }\n  }\n  long long int ans = 1;\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d\", &x);\n    ;\n    sum += x;\n    ans *= C[sum - 1][x - 1];\n    ans %= 1000000007;\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1010;\nconst int mod = 1e9 + 7;\nint nCk[MAXN][MAXN];\ninline int Add(int a, int b) { return (a + b) % mod; }\ninline int Mult(int a, int b) { return (int)(((long long)a * b) % mod); }\nint Povrh(int n, int k) { return nCk[n][k]; }\nvoid Init() {\n  nCk[0][0] = 1;\n  for (int i = 1; i < MAXN; i++) {\n    nCk[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      nCk[i][j] = Add(nCk[i - 1][j], nCk[i - 1][j - 1]);\n    }\n  }\n}\nint k;\nint arr[MAXN];\nint sol = 1;\nint main() {\n  Init();\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) scanf(\"%d\", &arr[i]);\n  int len = 0;\n  for (int i = 0; i < k; i++) {\n    sol = Mult(sol, Povrh(len + arr[i] - 1, arr[i] - 1));\n    len = Add(len, arr[i]);\n  }\n  printf(\"%d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static final long MOD = 1000*1000*1000+7;\n    private static long[][] binomial;\n\n    private static class FastReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public FastReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 1 << 16);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n                catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            }\n            catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        FastReader in = new FastReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int k = in.nextInt();\n        initiateBinomial(1005);\n        int[] C = new int[k];\n        for (int i = 0; i < k; i++) {\n            C[i] = in.nextInt();\n        }\n        long ans = 1;\n        int used = 1;\n        for (int i = 0; i < k; ++i) {\n\n            ans *= binomial[C[i] - 1 + used - 1][used - 1];\n            ans %= MOD;\n            used += C[i];\n        }\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static void initiateBinomial(int n) {\n        binomial = new long[n + 1][n + 1];\n        binomial[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            binomial[i][0] = 1;\n            for (int j = 1; j <= i; ++j) {\n                binomial[i][j] = binomial[i - 1][j - 1] + binomial[i - 1][j];\n                binomial[i][j] %= MOD;\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long found[1005];\nlong long qpow(long long a, long long b) {\n  a = a % mod;\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  found[1] = 1;\n  for (int i = 2; i <= 1000; ++i) {\n    found[i] = found[i - 1] * i % mod;\n  }\n  int n, now;\n  long long res = 1;\n  int cnt = 1;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> now;\n    if (now >= 2) res = qpow(found[now - 1], mod - 2) * res % mod;\n    for (int j = 0; j < now - 1; ++j) {\n      res = res * cnt % mod;\n      ++cnt;\n    }\n    ++cnt;\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main{\n    \n    \n    \n    \n    \n    public static void main(String args[]){\n        Scanner s = new Scanner(System.in);\n        int k=s.nextInt();\n        long modulo=1000000007;\n        long sum=0;\n        long ans=1;\n        for(int i=0;i<k;i++){\n            int x =s.nextInt();\n            sum=sum+x-1;\n            ans=(ans*func(sum,x-1))%modulo;\n            \n            sum++;\n        }\n        System.out.println(ans);\n    }\n    public static long func(long n, int k){\n        if(n<k)return 0;\n        if(n==k)return 1;\n        long modulo=1000000007;\n        long c[] = new long[k+1];\n        c[0]=1;\n        for(int i=1;i<=n;i++){\n            for(int j=Math.min(i,k);j>0;j--){\n                c[j]=c[j]+c[j-1];\n                c[j]=c[j]%modulo;\n            }\n        }\n        return c[k];\n    }\n    \n    \n} \n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\n\nn = int(input())\nc = [int(input()) for _ in range(n)]\n\nr, s = 1, 0\n\nfor i in range(n):\n    r *= factorial(s+c[i]-1) // factorial(s) // factorial(c[i]-1)\n    r %= 1000000007\n    s += c[i]\n\nprint(r)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long dp[1005][1005];\n  int n;\n  cin >> n;\n  dp[0][0] = 1;\n  for (int i = 1; i < 1005; ++i) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % 1000000007;\n  }\n  long long arr[n + 1];\n  long long sum = 0;\n  long long a = 1;\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n    a = (a * dp[sum + arr[i] - 1][arr[i] - 1]) % 1000000007;\n    sum += arr[i];\n  }\n  cout << a << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint cnt[1005];\nlong long c[1005][1005];\nint main() {\n  c[0][0] = c[1][0] = c[1][1] = 1;\n  for (int i = 2; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (i == 0 || i == j)\n        c[i][j] = 1;\n      else\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    int t;\n    cin >> cnt[i];\n  }\n  long long ans = 1;\n  int cs = 0;\n  for (int i = 1; i <= 1000; i++) {\n    if (cnt[i]) {\n      ans = (ans * c[cs + cnt[i] - 1][cnt[i] - 1]) % 1000000007;\n      cs += cnt[i];\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "ans=1\nn=input()\npre=s=input()\nmod=1000000007\nfor _ in range(1,n):\n\tnow=input()\t\n\ts+=now\n\tk=1\n\tfor i in range(now-1):\n\t\tk=k*(s-1-i)/(i+1)\n\tans=ans*k%mod\n\tpre=now\nprint ans\n\t\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ch[1001][1001];\nint main() {\n  for (int i = 0; i < 1001; i++) ch[i][0] = 1;\n  for (int i = 0; i < 1001; i++) {\n    for (int j = 1; j < 1001; j++) {\n      if (i < j) {\n        ch[i][j] = 0;\n        continue;\n      }\n      ch[i][j] = ch[i - 1][j] + ch[i - 1][j - 1];\n      ch[i][j] %= 1000000007;\n    }\n  }\n  int k;\n  cin >> k;\n  vector<int> a(k);\n  int n = 0;\n  for (int i = 0; i < k; i++) {\n    cin >> a[i];\n    n += a[i];\n  }\n  long long r = 1;\n  long long sm = 0;\n  for (int i = k - 1; i >= 0; i--) {\n    r *= ch[n - 1][a[i] - 1];\n    r %= 1000000007;\n    n -= a[i];\n  }\n  cout << r << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long k;\n  cin >> k;\n  long long arr[k];\n  for (auto &x : arr) cin >> x;\n  long **dp = new long *[1001];\n  for (auto i = (0); i <= (1000); i++) dp[i] = new long[1001];\n  long long mod = 1e9 + 7;\n  for (auto i = (0); i <= (1000); i++) {\n    for (auto j = (0); j <= (i); j++) {\n      if (j == 0 || j == i)\n        dp[i][j] = 1;\n      else\n        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;\n    }\n  }\n  long long x[2];\n  x[1] = 1;\n  long long tc = arr[0];\n  for (auto i = (2); i <= (k); i++) {\n    tc += arr[i - 1];\n    x[i % 2] = (x[(i - 1) % 2] * dp[tc - 1][arr[i - 1] - 1] % mod) % mod;\n  }\n  cout << x[k % 2];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KyoyaColoredBalls {\n\t\n\tstatic long[] f = new long[1000100];\n\n\tpublic static void main(String[] args) {\n\t\tint m = (int)(1e9)+7;\n\t\tf[0] = 1;\n\t\tfor(int i = 1; i < f.length; i++) f[i] = (f[i-1]%m*i%m)%m;\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] arr = new int[n];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tarr[i] = scan.nextInt();\n\t\tlong ans = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint top = sum+arr[i]-1;\n\t\t\tans *= nCr(top, arr[i]-1, m);\n\t\t\tans %= m;\n\t\t\tsum += arr[i];\n\t\t}\n\t\tSystem.out.println(ans%m);\n\t}\n\t\n\tstatic long power(long a, long b, long mod){\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0){\n\t\t\tif (b%2 > 0){\n\t\t\t\tx = (x*y)%mod;\n\t\t\t}\n\t\t\ty = (y*y)%mod;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x%mod;\n\t}\n\t \n\tstatic long modular_inverse(long n, long mod){\n\t\treturn power(n, mod-2, mod);\n\t}\n\t \n\tstatic long nCr(int n, int k, long mod){\n\t\treturn (f[n]*(modular_inverse(f[k], mod)*\n\t\t\t\tmodular_inverse(f[n-k], mod)%mod)\n\t\t\t\t%mod);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ncr[1001][1001];\nlong long mod = 1e9 + 7;\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int c[1001];\n  for (int i = 0; i < n; ++i) cin >> c[i];\n  for (int i = 0; i < 1001; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      if (i == 0 || i == j || j == 0)\n        ncr[i][j] = 1;\n      else {\n        ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod;\n      }\n    }\n  }\n  long long int ans = 1;\n  long long int total = c[0];\n  for (int i = 1; i < n; ++i) {\n    ans = (ans * ncr[total + c[i] - 1][c[i] - 1]) % mod;\n    total += c[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\tpublic static void main(String[] args) {\n\t\tchoose = new long[1001][1001];\n\t\tfor(long[] arr : choose)\n\t\t\tArrays.fill(arr, -1L);\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] cs = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcs[i] = in.nextInt();\n\t\tint cnt = 0;\n\t\tlong ans = 1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans *= multichoose(cnt+1, cs[i]-1);\n\t\t\tans %= MOD;\n\t\t\tcnt += cs[i];\n\t\t\t\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long multichoose(int n, int k) {\n\t\treturn choose(n+k-1, k);\n\t}\n\tstatic final long MOD = (long)(1e9+7);\n\tstatic long[][] choose;\n\tpublic static long choose(int n, int k) {\n\t\tif(k == 0)\n\t\t\treturn 1;\n\t\tif(n == 0)\n\t\t\treturn 0;\n\t\tif(choose[n][k] != -1)\n\t\t\treturn choose[n][k];\n\t\treturn choose[n][k] = (choose(n-1,k) + choose(n-1,k-1)) % MOD;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Solution{\n\tpublic static void main (String[] args) throws IOException{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tString[] temp=br.readLine().trim().split(\" \");\n\t\t\n\t\tint k=Integer.parseInt(temp[0]);\n\t\tint[] arr=new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t    arr[i]=Integer.parseInt(br.readLine());\n\t\t}\n\t\tout.println(numWays(arr));\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tpublic static int numWays(int[] arr)\n\t{\n\t\tint k=arr.length;\n\t\tint[] prefixSum=new int[k];\n\t\tint[] fact=new int[1001];\n\t\tint[] inverseFact=new int[1001];\n\t\tfact[0]=1;\n\t\tinverseFact[0]=1;\n\t\tint mod=1000000007;\n\t    int ans=1;\n\t    for(int i=1;i<=1000;i++){\n\t        ans=(int)((1L*(i%mod)*(ans%mod))%mod);\n\t        fact[i]=ans;\n\t        inverseFact[i]=power(ans,mod-2,mod);\n\t    }\n\t\tint[] dp=new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t    dp[i]=-1;\n\t\t}\n\t\tdp[0]=1;\n\t\tint count=arr[0];\n\t\tfor(int i=1;i<k;i++){\n\t\t    count+=arr[i];\n\t\t    int smallAns=dp[i-1];\n\t\t    int ways=nCr(count-1,arr[i]-1,mod,fact,inverseFact);\n\t\t    dp[i]=(int)((1L*(smallAns%mod)*(ways%mod))%mod);\n\t\t}\n\t\treturn dp[k-1];\n\t}\n\tpublic static int nCr(int n,int r,int mod,int[] fact,int[] inverseFact)\n\t{\n\t   int num=fact[n];\n\t   int ans=(int)( ( 1L*num*inverseFact[n-r] ) % mod );\n\t   ans=(int)( ( 1L*ans*inverseFact[r] ) % mod );\n\n\t   return ans;\n\t}\n\tpublic static int power(int a,int b,int c){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    int smallAns=power(a,b/2,c);\n\t    int ans=(int)((1L*(smallAns%c)*(smallAns%c))%c);\n\t    if(b%2!=0){\n\t        ans=(int)((1L*(ans%c)*(a%c))%c);\n\t    }\n\t    return ans;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial as f\nn, ans, sm, mod = map(int, input().split() + [1, 0, 1000000007])\ndef ncr(x, y):\n\treturn f(x) // (f(y) * f(x - y))\nfor _ in range(n):\n\tx = int(input())\n\tans = (ans * ncr(sm + x - 1, x - 1)) % mod\n\tsm += x\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\npublic class a{\n\tprivate static InputReader IN ;\n\tprivate static OutputWriter OUT ;\n\tprivate static int read(){ return IN.nextInt() ; }\n\tprivate static long readll(){ return IN.nextLong() ; }\n\tprivate static <T> void print ( T x ) { System.out.println ( x ) ; }\n\tstatic long Pow ( long x , long e , long mod ) {\n\t\tlong ret = 1L ; x %= mod ;\n\t\twhile ( e > 0 ) {\n\t\t\tif ( e % 2 == 1 ) ret = ( x * ret ) % mod ;\n\t\t\tx  = ( x * x ) % mod ;\n\t\t\te >>= 1 ; \n\t\t}\n\t\treturn ret ;\n\t}\n\tprivate static long F [] = new long [ 2002 ] , IF [] = new long [ 2002 ] , mod = 1000000007L ;\n\tprivate static long C ( int x , int k ) {\n\t\tif ( x < k ) return 0L ;\n\t\tlong ret = ( F [ x ] * IF [ k ] ) % mod ;\n\t\treturn ( ret * IF [ x - k ] ) % mod ;\n\t}\n\tpublic static void main ( String[] args ) { \n\t\t//-----------------------------------------------------//\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tIN = new InputReader(inputStream);\n\t\tOUT = new OutputWriter(outputStream);\n\t\t//-----------------------MAIN---------------------------//\n\t\tF [ 0 ] = IF [ 0 ] = 1L ;\n\t\tfor ( int i = 1 ; i <= 2000 ; i ++ ) F [ i ] = ( F [ i - 1 ] * i ) % mod ;\n\t\tfor ( int i = 1 ; i <= 2000 ; i ++ ) IF [ i ] = Pow ( F [ i ] , mod - 2 , mod ) ;\n\t\tlong ans = 1 ;\n\t\tint cnt = 0 , n = read() ; \n\t\tlong c[] = new long [ n ] ;\n\t\tfor ( int i = 0 ; i < n ; i ++ ) {\n\t\t\tint x = read() - 1 ; \n\t\t\tans *= C ( x + cnt , x ) ;\n\t\t\tans %= mod ;\n\t\t\tcnt += x + 1 ; \n\t\t}\n\t\tprint ( ans ) ; \n\t}\n\t\n\t//-----------------------TAIL------------------------------//\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate InputReader.SpaceCharFilter filter;\n\t\tpublic InputReader(InputStream stream) { this.stream = stream; }\n\t\tpublic int read() {\n\t\t\tif (numChars == -1) throw new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0 ) return -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n        public int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) c = read();\n\t\t\tboolean ok = false ;\n\t\t\tif ( c == '-') { ok = true ; c = read() ; }\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') { throw new InputMismatchException(); }\n\t\t\t\tres *= 10 ; res += c - '0';\n\t\t\t\tc = read();\n\t\t\t}while (!isSpaceChar(c));\n\t\t\tif ( ok ) res = -res ;\n\t\t\treturn res ;\n        }\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read() ;\n\t\t\twhile ( isSpaceChar ( c ) ) c = read() ;\n\t\t\tboolean ok = false ;\n\t\t\tif (c == '-') { ok = true ; c = read(); }\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') { throw new InputMismatchException(); }\n\t\t\t\tres *= 10 ; res += c - '0';\n\t\t\t\tc = read();\n\t\t\t}while (!isSpaceChar(c));\n\t\t\tif ( ok ) res = -res ;\n\t\t\treturn res ;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null) {\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t}\n\t\t\treturn isWhitespace(c);\n\t\t}\n\t\tpublic static boolean isWhitespace ( int c ) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1 ;\n\t\t}\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    static class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\t\tpublic OutputWriter(Writer writer) { this.writer = new PrintWriter(writer) ; }\n\t\tpublic void print(long[] array) {\n\t\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\t\tif (i != 0) writer.print(' ');\n\t\t\t\twriter.print(array[i]);\n\t\t\t}\n\t\t}\n\t\tpublic void println ( long[] array) { print(array) ; writer.println() ; }\n\t\tpublic void close() { writer.close() ; }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, tu[1001], mod = 1000000007, fac[9000];\nlong long qpow(long long a, long long b) {\n  long long ans = 1;\n  a %= mod;\n  for (long long i = b; i; i >>= 1, a = a * a % mod)\n    if (i & 1) ans = ans * a % mod;\n  return ans;\n}\nlong long C(long long n, long long m) {\n  if (m > n || m < 0) return 0;\n  long long s1 = fac[n], s2 = fac[n - m] * fac[m] % mod;\n  return s1 * qpow(s2, mod - 2) % mod;\n}\nint main() {\n  fac[0] = 1;\n  for (long long a = 1; a <= 1000; a++) fac[a] = fac[a - 1] * a % mod;\n  cin >> n;\n  for (long long a = 1; a <= n; a++) cin >> tu[a];\n  long long zhonglei = 1, he = tu[1];\n  for (long long a = 2; a <= n; a++) {\n    he += tu[a];\n    zhonglei *= C(he - 1, tu[a] - 1) % mod;\n    zhonglei %= mod;\n  }\n  cout << zhonglei;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans = 1;\nlong long exp(long long taban, long long us, long long md) {\n  long long carpan = taban % md;\n  if (carpan == 0) return 0;\n  long long temp = us;\n  long long res = 1;\n  while (temp) {\n    if (temp % 2) res = (res * carpan) % md;\n    temp /= 2;\n    carpan = (carpan * carpan) % md;\n  }\n  return res;\n}\nvector<long long> fact;\nvector<long long> inv_fact;\nvoid fact_init(int n) {\n  fact.resize(n + 5);\n  inv_fact.resize(n + 5);\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = (fact[i - 1] * i) % 1000000007;\n    inv_fact[i] = exp(fact[i], 1000000007 - 2, 1000000007);\n  }\n}\nlong long komb(long long a, long long b) {\n  if (a < b) return 0;\n  return fact[a] * (inv_fact[a - b] * inv_fact[b] % 1000000007) % 1000000007;\n}\nint main() {\n  fact_init(1005);\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  int sum = arr[0];\n  for (int i = 1; i < n; i++) {\n    sum += arr[i];\n    ans *= komb((sum - 1), arr[i] - 1);\n    ans = ans % 1000000007;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import *\n\nn = int(input())\n\nk1 = int(input())\nlast_vars = 1\nnum_pos = k1\nfor i in range(n-1):\n\tki = int(input())\n\tnum_pos += ki\n\tki -= 1\n\tCnk = 1\n\tfor k in range(num_pos-ki,num_pos):\n\t\tCnk *= k\n\tCnk //= factorial(ki)\n\tlast_vars *= Cnk\nprint(last_vars%1000000007)"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.Set;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Andrey Rechitsky (arechitsky@gmail.com)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    final long MOD = 1000000007;\n    final int maxN = 1000005;\n    long []f;\n    public TaskA(){\n        f = new long[maxN];\n        f[0] = 1;\n        for (int i = 1; i < maxN; i++) {\n            f[i] = (f[i-1]*i) %MOD;\n        }\n    }\n    long c(int n, int k){\n        long ret = NumberUtils.div(f[n], (f[k]*f[n-k])%MOD, MOD);\n        return ret;\n    }\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int k = in.nextInt();\n        int count = 0;\n        long ans = 1;\n        for (int i = 0; i < k; i++) {\n            int a = in.nextInt();\n            ans *= c(count+a-1, a-1);\n            ans %= MOD;\n            count += a;\n        }\n        out.printLine(ans);\n    }\n}\n\nclass NumberUtils {\n\n\n    public static long inverse(long a, long mod) {\n        long t = 0, newt = 1;\n        long r = mod, newr = a;\n        while (newr != 0) {\n            long q = r / newr;\n            long oldt = t, oldr = r;\n            t = newt;\n            r = newr;\n            newt = oldt - q * newt;\n            newr = oldr - q * newr;\n        }\n        if (r > 1) throw new IllegalArgumentException();\n        if (t < 0) t += mod;\n        return t;\n    }\n\n    public static long div(long a, long b, long mod) {\n        return a * inverse(b, mod) % mod;\n    }\n}\n\nclass FastScanner {\n\n    private BufferedReader reader;\n    private StringTokenizer st;\n\n    public FastScanner(InputStream stream) {\n        this.reader = new BufferedReader(new InputStreamReader(stream));\n        this.st = new StringTokenizer(\"\");\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public String next(){\n        while (!st.hasMoreTokens()){\n            st = new StringTokenizer(readLine());\n        }\n        return st.nextToken();\n    }\n\n    private String readLine() {\n        try {\n            String line = reader.readLine();\n            if (line==null) throw new InputMismatchException();\n            return line;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n}\n\nclass FastPrinter {\n    private final PrintWriter writer;\n\n    public FastPrinter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void printLine(long i) {\n        writer.println(i);\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;  \n\npublic class R309qA {\n\n\tstatic int c[][];\n\tstatic int n,k;\n\tstatic int a[],pre[];\n\tstatic int mod = (int)1e9 + 7;\n\tstatic long dp[][];\n\t\n\tpublic static void main(String args[]) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tc = new int[1001][1001];\n\t\tc[0][0] = 1;\n\t\t\n\t\tfor(int i=1;i<=1000;i++){\n\t\t\tc[i][0] = c[i][i] = 1;\n\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\tc[i][j] = c[i-1][j] + c[i-1][j-1];\n\t\t\t\tif(c[i][j] >= mod)\tc[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tk = in.nextInt();\n\n\t\ta = new int[k];\n\t\tfor (int i = 0; i < k; i++)\n\t\t\ta[i] = in.nextInt();\n\t\t\n\t\tpre = new int[k];\n\t\tpre[0] = a[0];\n\t\tfor(int i = 1;i <k; i++)\n\t\t\tpre[i] = pre[i-1] + a[i];\n\t\t\n\t\tn = 0;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tn += a[i];\n\t\t\n\t\tdp = new long[n + 1][k + 1];\n\t\tfor(int i=0;i<k;i++)\n\t\t\tdp[n][i] = 0;\n\t\tdp[n][k] = 1;\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tif(i + 1 >= pre[j]){\n\t\t\t\t\tif(a[j] != 1)\tdp[i][j] = j == 0 ? dp[i+1][j+1] * 1L * c[i][a[j]-1]: dp[i+1][j+1] * 1L * c[i - pre[j-1]][a[j]-1];\n\t\t\t\t\telse\tdp[i][j] = dp[i+1][j+1];\t\t\t\n\t\t\t\t}\n\t\t\t\tdp[i][j] += dp[i+1][j];\n\t\t\t\tif(dp[i][j] >= mod)\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\n\t\tw.println(dp[0][0]);\n\t\tw.close();\n\t}\n\t\n\t/*\n\tstatic public long solve(int i,int j){\n\t\tif(dp[i][j] == -1){\n\t\t\tdp[i][j] = 0;\n\t\t\tif(i + 1 >= pre[j]){\n\t\t\t\tif(a[j] != 1)\tdp[i][j] = j == 0 ? solve(i+1,j+1) * c[i][a[j]-1]: solve(i+1,j+1) * 1L * c[i - pre[j-1]][a[j]-1];\n\t\t\t\telse\tdp[i][j] = solve(i+1,j+1);\t\t\t\t\n\t\t\t\tif(i == 1 && j == 0)\n\t\t\t\t\tSystem.out.println(dp[i][j]);\n\t\t\t}\n\t\t\tif(i == 1 && j == 0)\tSystem.out.println(solve(i+1,j));\n\t\t\tdp[i][j] += solve(i+1,j);\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t\treturn dp[i][j];\n\t}*/\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C(long long int n, long long int r, long long int MOD) {\n  vector<vector<long long> > C(n + 1, vector<long long>(r + 1, 0));\n  for (int i = 0; i <= n; i++) {\n    for (int k = 0; k <= r && k <= i; k++)\n      if (k == 0 || k == i)\n        C[i][k] = 1;\n      else\n        C[i][k] = (C[i - 1][k - 1] + C[i - 1][k]) % MOD;\n  }\n  return C[n][r];\n}\nint main() {\n  long long int i, j, k;\n  cin >> k;\n  long long int a[k], b[k];\n  for (i = 0; i < k; i++) {\n    cin >> a[i];\n  }\n  b[0] = 1;\n  long long int sum = a[0];\n  for (i = 1; i < k; i++) {\n    sum = sum + a[i];\n    b[i] = C(sum - 1, a[i] - 1, 1000000007);\n  }\n  long long int ans = 1;\n  for (i = 0; i < k; i++) {\n    ans = ans * b[i];\n    if (ans >= 1000000007) ans = ans % 1000000007;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def fuck(n):\n    yazhka = 1\n    for i in range(1, n + 1):\n        yazhka *= i\n    return yazhka\n\ndef C(n, k):\n    return fuck(n) / fuck(k) / fuck(n - k)\n\nk = int(raw_input())\nca = 1\ncm = 0\nsasai = 1000000007\nfor i in xrange(k):\n    t = int(raw_input())\n    cm += t\n    ca *= C(cm - 1, t - 1)\n    ca %= sasai\nprint ca"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long di = (1e9) + 7;\nlong long arr[1111], ar[1111];\nlong long gcd(long long a, long long b) {\n  long long c;\n  while (b) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\nint main() {\n  long long a, b, c, d, e, f, g, h;\n  cin >> a;\n  e = f = 0;\n  g = 0;\n  for (d = 0; d < a; d++) {\n    cin >> c;\n    g += c;\n    if (d) {\n      for (int i = g - c + 1, j = 1; i < g; i++, j++) {\n        arr[e++] = i;\n        ar[f++] = j;\n      }\n    }\n  }\n  for (d = 0; d < f; d++) {\n    c = ar[d];\n    for (int i = 0; i < e && c > 1; i++) {\n      g = gcd(c, arr[i]);\n      c /= g;\n      arr[i] /= g;\n    }\n  }\n  for (d = 0, g = 1; d < e; d++) {\n    g *= arr[d];\n    g %= di;\n  }\n  cout << g << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class A{\n\tfinal static long modulo = 1000000007;\n\tstatic int n,a[];\n\tstatic class BigCal{\n\t\tprivate static long pow[],dv[],f[];//def[],inf[],f[];\n\t\tstatic void init(int n){\n\t\t\tpow=new long [n+1];\n\t\t\tdv=new long[n+1];\n\t\t\t//def=new long[n+1]; inf=new long[n+1];\n\t\t\tf=new long[n+1];\n\t\t\t\n\t\t\tint i; long j;\n\t\t\tfor (i=0;i<dv.length;i++) dv[i]=i;\n\t\t\tfor (i=2;i<dv.length;i++)if (dv[i]==i){\n\t\t\t\tfor (j=i;(i*j)<dv.length;j++) dv[(int)(i*j)]=i;\t\n\t\t\t}\n\t\t\tArrays.fill(pow, 0);\n\t\t\tArrays.fill(f, 0);//Arrays.fill(inf, 0);Arrays.fill(def, 0);\n\t\t}\n\t\tstatic void multiply(int x,long p){\n\t\t\tif (x<=1) return;\n\t\t\tpow[(int)dv[x]]+=p;\n\t\t\tmultiply((int)(x/dv[x]),p);\n\t\t}\n\t\tstatic void multiplyFact(int x){\n\t\t\tif (x<=1) return;\n\t\t\tf[x]++;\n\t\t}\n\t\tpublic static void divide(int x,long p){\n\t\t\tif (x<=1) return;\n\t\t\tpow[(int)dv[x]]-=p;\n\t\t\tdivide((int)(x/dv[x]),p);\n\t\t}\n\t\tpublic static void divideFact(int x){\n\t\t\tif (x<=1) return;\n\t\t\tf[x]--;\n\t\t}\n\t\tpublic static long power(long a, long n){\n\t\t\tif (n==0) return 1;\n\t\t\tlong res=power(a,n/2);\n\t\t\tres=(res*res)%modulo;\n\t\t\tif ((n%2)==1) res=(res*a)%modulo;\n\t\t\treturn res;\n\t\t}\n\t\tpublic static long getres(){\n\t\t\tlong res=1; int i;\n\t\t\tfor (i=f.length-2;i>=1;i--)\n\t\t\t{\n\t\t\t\tf[i]+=f[i+1];\n\t\t\t\tmultiply(i, f[i]);\n\t\t\t}\n\t\t\tArrays.fill(f, 0);\n\t\t\t\n\t\t\tfor (i=2;i<pow.length;i++)\n\t\t\t\tres=(res*(power(i,pow[i])%modulo))%modulo;\n\t\t\treturn res;\n\t\t\t\n\t\t}\n\t\tpublic static void multiplynCk(int n, int k){\n\t\t\tif ((k==0)||(n==0)||(n==k))return;\n\t\t\tint i;\n\t\t\tif ((n-k)<k) k=n-k;\n\t\t\tmultiplyFact(n);\n\t\t\tdivideFact(k);divideFact(n-k);\n\t\t}\n\t}\n\tstatic long res;\n\tstatic void MainMethod()throws Exception{\n\t\tn=reader.nextInt(); \n\t\ta=new int[n];\n\t\tint i;\n\t\tfor (i=0;i<n;i++) a[i]=reader.nextInt();\n\t\t//for (i=0;i<n;i++) a[i]=100;//=reader.nextInt();\n\t\tBigCal.init((n*1002));\n\t\tint total=a[0],k;\n\t\tfor (i=1;i<a.length;i++){\n\t\t\tk=total+a[i]-1;\n\t\t\tBigCal.multiplynCk(k,total);\n\t\t\ttotal+=a[i];\n\t\t}\n\t\tres=BigCal.getres(); \n\t\tprinter.println(res);\n\t}\n\tpublic static void main(String[] args)throws Exception{\n\t\tMainMethod();\n\t\tprinter.close();\n\t}\n\tstatic void halt(){\n\t\tprinter.close();\n\t\tSystem.exit(0);\n\t}\n\tstatic PrintWriter printer=new PrintWriter(new OutputStreamWriter(System.out));\n\tstatic class reader{\n\t\tstatic BufferedReader bReader=new BufferedReader(new InputStreamReader(System.in));\n\t\tstatic StringTokenizer token=new StringTokenizer(\"\");\n\t\tstatic String readNextLine() throws Exception{\n\t\t\treturn bReader.readLine();\n\t\t}\n\t\tstatic String next() throws Exception{\n\t\t\twhile (token.hasMoreTokens()==false){\n\t\t\t\ttoken=new StringTokenizer(bReader.readLine());\n\t\t\t}\n\t\t\treturn token.nextToken();\n\t\t}\n\t\tstatic int nextInt()throws Exception{\n\t\t\twhile (token.hasMoreTokens()==false){\n\t\t\t\ttoken=new StringTokenizer(bReader.readLine());\n\t\t\t}\n\t\t\treturn Integer.parseInt(token.nextToken());\n\t\t}\n\t\tstatic long nextLong()throws Exception{\n\t\t\twhile (token.hasMoreTokens()==false){\n\t\t\t\ttoken=new StringTokenizer(bReader.readLine());\n\t\t\t}\n\t\t\treturn Long.parseLong(token.nextToken());\n\t\t}\n\t\tstatic double nextDouble()throws Exception{\n\t\t\twhile (token.hasMoreTokens()==false){\n\t\t\t\ttoken=new StringTokenizer(bReader.readLine());\n\t\t\t}\n\t\t\treturn Double.parseDouble(token.nextToken());\n\t\t}\n\t}\n\tstatic class MyMathCompute{\n\t\tstatic long [][] MatrixMultiplyMatrix(long [][] A, long [][] B, long mod) throws Exception{\n\t\t\tint n=A.length, m=B[0].length; \n\t\t\tint p=A[0].length;\n\t\t\tint i,j,k;\n\t\t\tif (B.length!=p) throw new Exception(\"invalid matrix input\");\n\t\t\tlong [][] res=new long [n][m];\n\t\t\tfor (i=0;i<n;i++) for (j=0;j<m;j++){\n\t\t\t\tif (A[i].length!=p) throw new Exception(\"invalid matrix input\");\n\t\t\t\tres[i][j]=0;\n\t\t\t\tfor (k=0;k<p;k++)\n\t\t\t\t\tres[i][j]=(res[i][j]+((A[i][k]*B[k][j])% mod))% mod;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tstatic double [][] MatrixMultiplyMatrix(double [][] A, double [][] B ) throws Exception{\n\t\t\tint n=A.length, m=B[0].length; \n\t\t\tint p=A[0].length;\n\t\t\tint i,j,k;\n\t\t\tif (B.length!=p) throw new Exception(\"invalid matrix input\");\n\t\t\tdouble [][] res=new double [n][m];\n\t\t\tfor (i=0;i<n;i++) for (j=0;j<m;j++){\n\t\t\t\tif (A[i].length!=p) throw new Exception(\"invalid matrix input\");\n\t\t\t\tres[i][j]=0;\n\t\t\t\tfor (k=0;k<p;k++)\n\t\t\t\t\tres[i][j]=res[i][j]+(A[i][k]*B[k][j]);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tstatic long [][] MatrixPow(long [][] A,long n, long mod) throws Exception{\n\t\t\tif (n==1) return A;\n\t\t\tlong [][] res=MatrixPow(A, n/2, mod);\n\t\t\tres=MatrixMultiplyMatrix(res, res, mod);\n\t\t\tif ((n % 2) == 1) res=MatrixMultiplyMatrix(A,res, mod);\t\t\n\t\t\treturn res;\n\t\t}\n\t\tstatic double [][] MatrixPow(double [][] A,long n) throws Exception{\n\t\t\tif (n==1) return A;\n\t\t\tdouble[][] res=MatrixPow(A, n/2);\n\t\t\tres=MatrixMultiplyMatrix(res, res);\n\t\t\tif ((n % 2) == 1) res=MatrixMultiplyMatrix(A,res);\t\t\n\t\t\treturn res;\n\t\t}\n\t\tstatic long pow(long a,long n,long mod){\n\t\t\ta= a % mod;\n\t\t\tif (n==0) return 1;\n\t\t\tlong k=pow(a,n/2,mod);\n\t\t\tif ((n % 2)==0) return ((k*k)%mod);\n\t\t\telse return (((k*k) % mod)*a) % mod;\n\t\t}\n\t\tstatic double pow(double a,long n){\n\t\t\tif (n==0) return 1;\n\t\t\tdouble k=pow(a,n/2);\n\t\t\tif ((n % 2)==0) return (k*k);\n\t\t\telse return (((k*k) )*a) ;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * Created by watson on 04.04.15.\n */\npublic class B {\n    FastScanner in;\n    PrintWriter out;\n    final long mod = (long) (1e9+7);\n    public void solve() throws IOException {\n        int k = in.nextInt();\n        int[] a = new int[k];\n        int n = 0;\n        long ans = 1;\n        long[][] d = new long[2000][2000];\n        for (int i = 0; i < 2000; i++) {\n            d[i][0] = 1;\n        }\n        for (int i = 1; i < 2000; i++) {\n            for (int j = 1; j <= i; j++) {\n                d[i][j] = (d[i - 1][j - 1] + d[i - 1][j]) % mod;\n            }\n        }\n\n\n        for (int i = 0; i < k; i++) {\n            a[i] = in.nextInt();\n            long cV = 0;\n            //for (int j = 0; j <= Math.min(a[i] - 1, n); j++) {\n                cV = (cV +  d[n + a[i] - 1][a[i] - 1]) % mod;\n            //}\n            ans = (ans *  cV) % mod;\n            n = a[i] + n;\n        }\n        System.out.println(ans);\n    }\n/*\n\n    public int dfs(int i) {\n        if (i >= n / 2) {\n            return 0;\n        }\n        int c1 = dfs(2 * i + 1) + a[2 * i + 1];\n        int c2 = dfs(2 * i + 2) + a[2 * i + 2];\n        if (c1 > c2) {\n            b[i] = c1;\n            c[i] = 0;\n        } else {\n            b[i] = c2;\n            c[i] = 1;\n        }\n        return b[i];\n    }*/\n\n    public void run() {\n        try {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    public static void main(String[] arg) {\n        new B().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1010;\nint K;\nlong long c[1005];\ntemplate <class T>\nvector<vector<T> > pascal_triangle_mod(T n, T mod) {\n  vector<vector<T> > f = vector<vector<T> >(n);\n  f[0].push_back(1);\n  for (int i = 1; i < n; ++i) {\n    f[i] = vector<T>(i + 1);\n    f[i][0] = 1;\n    for (int j = 1; j < i; ++j) {\n      f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n      if (f[i][j] > mod) {\n        f[i][j] -= mod;\n      }\n    }\n    f[i][i] = 1;\n  }\n  return f;\n}\nvector<vector<long long> > ans;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.sync_with_stdio(false);\n  cout.sync_with_stdio(false);\n  cin >> K;\n  for (int i = 0; i < K; i++) cin >> c[i];\n  ans = pascal_triangle_mod<long long>((long long)1200, MOD);\n  long long res = 1;\n  int bask = 0;\n  int ball = 0;\n  for (int i = 0; i < K; i++) {\n    bask += 1;\n    ball = c[i] - 1;\n    res *= ans[ball + bask - 1][bask - 1];\n    if (res >= MOD) res %= MOD;\n    bask += (c[i] - 1);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "M = 1000000007\ndef C(n, t):\n    c = 1\n    for i in range(t):\n        c *= n-i\n        c /= i+1\n    return c\n\n# As check: C(x+y,x)=C(x+y-1,y-1)+C(x+y-1,x-1)\nk = int(raw_input().strip())\nc = [int(raw_input().strip()) for _ in range(k)]\nans = 1\ntc = c[0]\nfor i in range(1, len(c)):\n    ans *= C(tc+c[i]-1, c[i]-1)%M\n    ans %= M\n    tc += c[i]\nprint ans\n\n    \n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int maxn = 1005;\nint N;\nint c[maxn];\nlong long int pov[maxn][maxn];\nlong long int dp[maxn];\nvoid rijesi() {\n  pov[0][0] = 1;\n  for (int n = 1; n < maxn; n++) {\n    pov[n][0] = 1;\n    for (int k = 1; k <= n; k++) {\n      pov[n][k] = pov[n - 1][k - 1] + pov[n - 1][k];\n      pov[n][k] %= mod;\n    }\n  }\n  dp[0] = 1;\n  int ukupno = c[0];\n  for (int i = 1; i < N; i++) {\n    dp[i] = dp[i - 1] * pov[ukupno + c[i] - 1][c[i] - 1];\n    dp[i] %= mod;\n    ukupno += c[i];\n  }\n  printf(\"%I64d\\n\", dp[N - 1]);\n}\nvoid ucitaj() {\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) scanf(\"%d\", &c[i]);\n}\nint main(void) {\n  ucitaj();\n  rijesi();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1010;\nconst long long MOD = 1000000007;\nint cnt[MAXN];\nlong long fac[MAXN], ans = 1;\nlong long POW(long long exp, long long power) {\n  if (power == 0) return 1;\n  long long ansP = POW(exp, power / 2);\n  ansP = ansP * ansP % MOD;\n  if (power % 2 == 1) ansP = ansP * exp % MOD;\n  return ansP;\n}\nlong long C(long long n, long long r) {\n  long long ansC = (fac[n] * (POW(fac[r] * fac[n - r] % MOD, MOD - 2))) % MOD;\n  return ansC;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  fac[0] = 1;\n  fac[1] = 1;\n  for (int i = 2; i < MAXN; i++) {\n    fac[i] = i * fac[i - 1] % MOD;\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> cnt[i];\n  }\n  int length = cnt[0];\n  for (int i = 1; i < k; i++) {\n    ans *= C(cnt[i] + length - 1, length);\n    ans %= MOD;\n    length += cnt[i];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXK = 1005;\nconst int MOD = 1e9 + 7;\nint k, col[MAXK];\nlong long sum, res, f[MAXK], c[MAXK][MAXK];\nlong long nhan(long long a, long long b) {\n  a = a % MOD;\n  if (a <= 1 || b <= 1) return (a * b) % MOD;\n  return (nhan(a * 2, b / 2) + a * (b % 2)) % MOD;\n}\nint main() {\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> col[i];\n  for (int i = 0; i <= 1001; i++) c[i][0] = 1;\n  for (int i = 1; i <= 1001; i++)\n    for (int j = 1; j <= 1001; j++)\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\n  f[1] = 1;\n  sum = col[1];\n  for (int i = 2; i <= k; i++) {\n    sum += col[i];\n    f[i] = nhan(f[i - 1], c[sum - 1][col[i] - 1]);\n  }\n  cout << f[k];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int P = 1000000007;\n        long f[][] = new long[1001][1001];\n        for (int i = 0;i <= 1000; i++)\n            f[i][0] = 1;\n        for (int i = 1; i <= 1000;i++) {\n            for (int j = 1; j <= 1000;j++) {\n                f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % P; \n            }\n        }\n        int prev = -1, len = 0;\n        long ans = 1;\n        for (int i = 0;i < n; i++) {\n            int cur = in.nextInt();\n//            System.out.println(prev + \" \" + cur + \" \" + ans + \" \" + len + \" \" + f[len + cur - 1][cur - 1]);\n            if (i > 0) {\n                ans = (ans * f[len  + cur - 1][cur - 1]) % P;\n            }\n            prev = cur;\n            len += cur;\n        }\n        System.out.println(ans);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static BigInteger MOD = new BigInteger(\"1000000007\");\n    static int N = 1000;\n\n    public static void main(String [] args)\n    {\n        Scanner input = new Scanner(System.in);\n        int [] a = new int[N+1];\n        int k;\n        while (input.hasNext())\n        {\n            k = input.nextInt();\n            for (int i = 0; i < k; i++)\n                a[i] = input.nextInt();\n            BigInteger ans = new BigInteger(\"1\");\n            int sum = 0;\n            for (int i = 1; i < k; i++)\n            {\n                sum += a[i-1];\n                ans = (ans.multiply(com(sum + a[i] - 1, a[i] - 1)));\n            }\n            ans = ans.mod(MOD);\n\n            System.out.println(ans);\n        }\n    }\n\n    static BigInteger com(int n, int m)\n    {\n        BigInteger ans = new BigInteger(\"1\");\n        for (int i = 0; i < m; i++)\n            ans = ans.multiply(new BigInteger(Integer.toString(n-i)));\n        for (int i = 0; i < m; i++)\n            ans = ans.divide(new BigInteger(Integer.toString(m - i)));\n        ans = ans.mod(MOD);\n\n        return ans;\n    }\n}\n\n \t \t \t\t\t      \t\t  \t\t \t \t \t\t \t \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[1001][1001];\nlong long md = 1000000007;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  for (long long i = 0; i < 1001; i++) {\n    for (long long j = 0; j <= i; j++) {\n      if (i == j || j == 0) {\n        c[i][j] = 1;\n      } else\n        c[i][j] = ((c[i - 1][j] % md) + (c[i - 1][j - 1] % md)) % md;\n    }\n  }\n  long long n;\n  cin >> n;\n  long long sum = 0;\n  long long ans = 1;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    ans = ((ans % md) * (c[sum + x - 1][x - 1] % md)) % md;\n    sum += x;\n  }\n  cout << ans % md << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nn = int(input())\nans = 1\ns = 0\nmod = (10**9) + 7\nfor i in range(n):\n    a = int(input())\n    ans *= factorial(s+a-1)//(factorial(s) * factorial(a-1))\n    ans = ans%mod\n    s += a\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2000;\nconst long long MOD = 1e9 + 7;\nlong long C[N][N];\nint num[N];\nint main() {\n  C[0][0] = 1;\n  for (int i = 1; i < N; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      while (C[i][j] >= MOD) {\n        C[i][j] -= MOD;\n      }\n    }\n  }\n  int k;\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &num[i]);\n  }\n  long long ans = 1;\n  long long cnt = num[1];\n  for (int i = 2; i <= k; i++) {\n    ans = (ans * C[cnt + num[i] - 1][num[i] - 1]) % MOD;\n    cnt += num[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const MOD = 1000000007, MAX = 10000;\nint binomialCoeff(int n, int k) {\n  int C[n + 1][k + 1];\n  int i, j;\n  for (i = 0; i <= n; i++) {\n    for (j = 0; j <= min(i, k); j++) {\n      if (j == 0 || j == i)\n        C[i][j] = 1;\n      else\n        C[i][j] = (((C[i - 1][j - 1] % MOD) + (C[i - 1][j] % MOD)) % MOD);\n    }\n  }\n  return C[n][k];\n}\nint main() {\n  int s = 0;\n  vector<int> sumas, val;\n  int n;\n  scanf(\"%d\", &n);\n  long long memo[n + 1];\n  memset(memo, 0, sizeof(memo));\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    s += x;\n    sumas.push_back(s);\n    val.push_back(x);\n  }\n  memo[0] = 1;\n  for (int i = 1; i < n; i++) {\n    int cn = sumas[i] - 1;\n    int ck = val[i] - 1;\n    memo[i] = (((memo[i - 1] % MOD) * (binomialCoeff(cn, ck) % MOD)) % MOD);\n  }\n  printf(\"%d\\n\", memo[n - 1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 7;\nconst int M = 4e5;\nconst int lim = 1e3;\nconst int p = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nlong long inv[N], fac[N], a[N];\nvoid init() {\n  fac[0] = inv[0] = inv[1] = 1;\n  for (long long i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % p;\n  for (long long i = 2; i <= lim; i++) inv[i] = (p - p / i) * inv[p % i] % p;\n  for (long long i = 1; i <= lim; i++) inv[i] = inv[i - 1] * inv[i] % p;\n}\nlong long C(int n, int m) { return fac[n] * inv[m] % p * inv[n - m] % p; }\nint main() {\n  init();\n  int n, sum = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", &a[i]);\n    sum += a[i];\n  }\n  long long ans = 1;\n  for (int i = n - 1; i >= 0; i--) {\n    ans = (ans * C(sum - 1, a[i] - 1)) % p;\n    sum -= a[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x7FFFFFFF;\nconst int MOD = 1000000000 + 7;\nconst double EPS = 1e-10;\nconst double PI = 2 * acos(0.0);\nconst int maxn = 1000 + 66;\nint cnt[maxn];\nlong long C[maxn][maxn];\nvoid GetComMod(long long val, long long mod) {\n  memset(C, 0, sizeof(C));\n  for (long long i = 0; i <= val; i++) {\n    for (long long j = 0; j <= i; j++) {\n      if (!j || i == j)\n        C[i][j] = 1 % mod;\n      else\n        C[i][j] = (C[i - 1][j - 1] % mod + C[i - 1][j] % mod) % mod;\n    }\n  }\n  C[0][0] = 0 % mod;\n}\nint main() {\n  GetComMod(1000 + 2, MOD);\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> cnt[i];\n  long long res = 1, tempsum = cnt[1];\n  for (int i = 2; i <= k; i++) {\n    res = (res % MOD * C[tempsum + cnt[i] - 1][cnt[i] - 1]) % MOD;\n    tempsum += cnt[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n\n\npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\t\n\tstatic int[][] bino = new int[1005][1005];\n\tstatic int MOD = 1000000007;\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tfor(int i=0; i <= 1000; ++i) {\n\t\t\tbino[i][0] = bino[i][i] = 1;\n\t\t\tfor(int j = 1; j < i; ++j) {\n\t\t\t\tbino[i][j] = bino[i-1][j-1] + bino[i-1][j];\n\t\t\t\tbino[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\n\t\tint k = in.nextInt();\n\t\tint[] a = new int[k];\n\t\tint t = 0;\n\t\tfor(int i=0; i<k; ++i) {\n\t\t\ta[i] = in.nextInt();\n\t\t\tt += a[i];\n\t\t}\n\t\t\n\t\tlong ans = 1;\n\t\tfor(int i = k-1; i >= 0; --i) {\n\t\t\tans *= bino[t-1][a[i] - 1];\n\t\t\tans %= MOD;\n\t\t\t\n\t\t\tt -= a[i];\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n}\n\n\nclass InputReader {\n\n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n\n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n\n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long double min(long double a, long double b) {\n  if (a < b) return a;\n  return b;\n}\ninline long double max(long double a, long double b) {\n  if (a < b) return b;\n  return a;\n}\nint n;\nint k;\nint arr[1100];\nlong long res;\nint main() {\n  int f[1111][1111];\n  cin >> k;\n  for (int(i) = (0); (i) < (k); ++(i)) {\n    cin >> arr[i];\n    n += arr[i];\n  }\n  res = 1;\n  int cnt = n;\n  for (int i = 0; i <= cnt; ++i) f[i][0] = 1;\n  for (int i = 1; i <= cnt; ++i)\n    for (int j = 1; j <= cnt; ++j)\n      f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % 1000000007;\n  for (int i = k - 1; i >= 0; i--) {\n    res *= f[n - 1][arr[i] - 1];\n    res = res % 1000000007;\n    n -= arr[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fact[1001];\npair<long long, long long> add_pair(pair<long long, long long> a,\n                                    pair<long long, long long> b) {\n  return make_pair(a.first + b.first, a.second + b.second);\n}\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nlong long power(long long a, long long b) {\n  long long res = 1;\n  a = a % 1000000007;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % 1000000007;\n      b--;\n    }\n    a = (a * a) % 1000000007;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long fermat_inv(long long y) { return power(y, 1000000007 - 2); }\nvoid factorial() {\n  long long i;\n  fact[0] = 1;\n  fact[1] = 1;\n  for (i = 2; i < 1001; i += 1) fact[i] = (i * fact[i - 1]) % 1000000007;\n}\nlong long bin(long long n, long long r) {\n  return (((fact[n] * fermat_inv(fact[n - r])) % 1000000007) *\n          fermat_inv(fact[r])) %\n         1000000007;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long k, i;\n  cin >> k;\n  long long c[k], pr[k + 1], dp[k + 1];\n  factorial();\n  for (i = 0; i < k; i += 1) cin >> c[i];\n  for (i = 0; i < k; i += 1) pr[i + 1] = c[i];\n  pr[0] = 0;\n  for (i = 0; i < k; i += 1) pr[i + 1] += pr[i];\n  dp[0] = 0;\n  dp[1] = 1;\n  for (i = 2; i < k + 1; i += 1) {\n    dp[i] = (dp[i - 1] * bin(pr[i] - 1, c[i - 1] - 1)) % 1000000007;\n  }\n  cout << dp[k] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new PrintStream(System.out));\n        int k=Integer.parseInt(f.readLine());\n        int[]arr=new int[k];\n        int n=0;\n        for(int i=0;i<k;i++){\n            arr[i]=Integer.parseInt(f.readLine());\n            n+=arr[i];\n        }\n        n=1010;\n        long[][]c=new long[1010][1010];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=i;j++){\n                if(i==0 || j==0 || i==j){\n                    c[i][j]=1;\n                    continue;\n                }\n\n                c[i][j]=c[i-1][j]+c[i-1][j-1];\n                c[i][j]%=MOD;\n            }\n        }\n        long[]dp=new long[k];\n        dp[0]=1;\n        int prefix=arr[0];\n        for(int i=1;i<k;i++){\n            prefix+=arr[i];\n            dp[i]=dp[i-1]*c[prefix-1][arr[i]-1];\n            dp[i]%=MOD;\n        }\n        System.out.print(dp[k-1]);\n        f.close();\n        out.close();\n    }\n    static long MOD=1000000007;\n\n\n}\nclass pair implements Comparable <pair>{\n    int num;\n    int idx;\n\n    public int compareTo(pair other){\n        return num- other.num;\n    }\n\n\n    pair(int a, int b)\n    {\n        num=a;\n        idx=b;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class ColoredBalls {\n\n    static final int MOD = 1_000_000_007;\n\n    long[] FAC = new long[1005];\n    long[] iFAC = new long[1005];\n\n    {\n        FAC[0] = FAC[1] = 1;\n        for (int i = 2; i < 1005; i++) {\n            FAC[i] = i * FAC[i - 1] % MOD;\n        }\n        iFAC[0] = iFAC[1] = 1;\n        for (int i = 2; i < 1005; i++) {\n            iFAC[i] = mpow(i, MOD - 2) * iFAC[i - 1] % MOD;\n        }\n    }\n\n    private long mpow(long x, long n) {\n        long res = 1, a = x;\n        while (n > 0) {\n            if ((n & 1) > 0) res = res * a % MOD;\n            a = a * a % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n    \n    private long choose(int n, int k) {\n        if (k == 0) return 1;\n        return (FAC[n] * iFAC[k] % MOD) * iFAC[n - k] % MOD;\n    }\n\n    void solve() {\n        int k = in.nextInt();\n        int[] c = new int[k];\n        for (int i = 0; i < k; i++) c[i] = in.nextInt();\n        long[] dp = new long[k + 1];\n        dp[1] = 1;\n        int L = c[0];\n        for (int i = 1; i < k; i++) {\n            int m = L + 1;\n            int n = c[i] - 1;\n            if (n == 0) {\n                dp[i + 1] = dp[i];\n            } else {\n                dp[i + 1] = choose(n + m - 1, m - 1) * dp[i] % MOD;\n            }\n            L += c[i];\n        }\n        out.println(dp[k]);\n    }\n\n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new ColoredBalls().solve();\n        out.close();\n    }\n\n    static FastScanner in;\n    static PrintWriter out;\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    MOD = int(1e9 + 7)\n    \n    def power(x, p):\n        if p == 0:\n            return 1\n        if p & 1:\n            return x * power(x, p - 1) % MOD\n        return power(x * x % MOD, p >> 1) % MOD\n    \n    \n    \n    import sys\n    \n    k, *c = [int(i) for i in sys.stdin.read().split()]\n    \n    inv_factorial = [1] * 1001\n    factorial = [1] * 1001\n    for i in range(2, 1001):\n        factorial[i] = factorial[i - 1] * i % MOD\n        inv_factorial[i] = power(factorial[i], MOD - 2)\n    \n    result = 1\n    size = 0\n    for i in c:\n        size += i\n        m = factorial[size - 1] * inv_factorial[i - 1] % MOD * inv_factorial[size - i] % MOD\n        result = result * m % MOD\n    \n    print(result)\n    \n    \n    \nmain()\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nk,s,res=int(input()),int(input()),1\nfor i in range(1,k):\n\tx=int(input())\n\ts+=x\n\tres=(res*factorial(s-1)//factorial(x-1)//factorial(s-x))%1000000007\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nint k;\nlong long a[1111];\nmap<long long, long long> mp1;\nmap<long long, long long> mp2;\nvoid C(long long a, long long b) {\n  for (long long i = a; i >= a - b + 1; --i) mp1[i]++;\n  for (long long i = b; i >= 1; --i) mp2[i]++;\n}\nlong long q_pow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nvoid exgcd(long long a, long long b, long long &x, long long &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exgcd(b, a % b, x, y);\n  long long t = x;\n  x = y;\n  y = t - a / b * y;\n}\nint main() {\n  long long sum = 0;\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; ++i) {\n    scanf(\"%lld\", a + i);\n    sum += a[i];\n  }\n  for (int i = k; i >= 1; --i) {\n    C(sum - 1, a[i] - 1);\n    sum -= a[i];\n  }\n  long long ans1 = 1, ans2 = 1;\n  for (map<long long, long long>::iterator iter = mp1.begin();\n       iter != mp1.end(); ++iter) {\n    ans1 = (ans1 * q_pow(iter->first, iter->second)) % mod;\n  }\n  if (ans1 == 0) ans1 = mod;\n  for (map<long long, long long>::iterator iter = mp2.begin();\n       iter != mp2.end(); ++iter) {\n    ans2 = (ans2 * q_pow(iter->first, iter->second)) % mod;\n  }\n  if (ans2 == 0) ans2 = mod;\n  long long x, y;\n  long long t = gcd(ans2, mod);\n  long long tmpMod = mod / t;\n  ans2 /= t;\n  ans1 /= t;\n  exgcd(ans2, tmpMod, x, y);\n  printf(\"%lld\\n\", ((x % mod + mod) % mod * ans1) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n/**\n * Created by aitch_nu on 10/9/15.\n */\npublic class KyoyaAndColoredBalls {\n\n    private static int[][] pascal = new int[1001][1001];\n\n    private static void preCompute(){\n        pascal[0][0] = 1;\n        pascal[1][0] = 1;\n        pascal[1][1] = 1;\n        for(int i=2;i<=1000;i++){\n            pascal[i][0] = 1;\n            for(int j=1;j<=i;j++){\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j]) % 1000000007;\n            }\n        }\n    }\n\n    public static void main(String args[]){\n        preCompute();\n        Scanner sc = new Scanner(System.in);\n        int k = sc.nextInt();\n        long ans = 1;\n        int totalBalls = 0;\n        int c = sc.nextInt();\n        totalBalls = totalBalls + c;\n        for(int i=1;i<k;i++){\n            c = sc.nextInt();\n            ans = (ans * pascal[totalBalls + c -1][c-1]) % 1000000007;\n            totalBalls = totalBalls + c;\n        }\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint extgcd(int a, int b, int &x, int &y) {\n  int d = a;\n  if (b != 0) {\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  } else {\n    x = 1;\n    y = 0;\n  }\n  return d;\n}\nint mod_inverse(int a, int m) {\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int line;\n  scanf(\"%d\", &line);\n  int number[1000];\n  int a = line;\n  while (a > 0) {\n    scanf(\"%d\", &number[line - a]);\n    a--;\n  }\n  long long up = 1;\n  int sum = 0;\n  for (int d = 1; d < line; d++) {\n    sum = sum + number[d - 1];\n    if (number[d] != 1) {\n      for (int c = 1; c < number[d]; c++) {\n        int num = sum + c;\n        up = up * (num) % 1000000007;\n        up = up * mod_inverse(c, 1000000007);\n        up = up % 1000000007;\n      }\n    }\n  }\n  cout << up;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * @author pttrung\n */\npublic class A_Round_309_Div1 {\n\n    public static long MOD = 1000000007;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        long[][] c = new long[1001][1001];\n        c[0][0] = 1;\n\n        for (int i = 1; i < 1001; i++) {\n            c[i][0] = 1;\n            c[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n                c[i][j] %= MOD;\n            }\n        }\n        long result = 1;\n        int last = 0;\n        for(int i = 0; i < n; i++){\n            int v = in.nextInt();\n            result  *= c[last + v - 1][last];\n            result %= MOD;\n            last += v;\n           // System.out.println(result);\n        }\n        out.println(result);\n        out.close();\n    }\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return x - o.x;\n        }\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val % MOD;\n        } else {\n            return val * (val * a % MOD) % MOD;\n\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "k = int(input())\na = []\nfor _ in range(k):\n  a.append(int(input()))\nn = sum(a)\nN = 1000000007\n\ndef getCombi(a,n):\n  b = min(a,n-a)\n  ret = 1\n  for i in range(1,b+1):\n    ret = (ret*(n+1-i))//i\n  return ret%N\n\nret = 1\nfor i in range(k-1,0,-1):\n  ai = a[i] - 1\n  ni = sum(a[:i])\n  ret *= getCombi(ai,ni+ai)\n  ret %= N\nprint(ret)\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nn=int(stdin.readline())\nfrom math import factorial as f\nlst=[int(stdin.readline()) for _ in range(n)]\nsumma=sum(lst)\nres=1\nfor i,x in enumerate(reversed(lst)):\n    x-=1\n    summa-=1\n    res*=(f(summa)//(f(summa-x)*f(x)))\n    res=res%1000000007\n    summa-=x\nprint(res)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Class{\n\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[][] dp = new int[1001][1001];\n        int p = 1000000007;\n        dp[0][0] = 1;\n        for(int i=1; i<=1000; i++){\n            for(int j=0; j<=i; j++){\n                if(j==0)dp[i][j] = 1;\n                else dp[i][j] = (dp[i-1][j-1]+dp[i-1][j])%p;\n            }\n        }\n        \n        long ans = 1;\n        int sum = Integer.parseInt(br.readLine()); int curr = sum;\n        for(int i=1; i<n; i++){\n            curr = Integer.parseInt(br.readLine());\n            sum += curr;\n            ans = (ans*dp[sum-1][curr-1])%p;\n        }\n        System.out.print(ans);\n    }\n    \n    static class Pair{\n        long start;\n        long end;\n        \n        public Pair(long start, long end){\n            this.start = start;\n            this.end = end;\n        }\n        \n        public int hashCode() {\n            return (int)(this.start + this.end);\n        }\n        \n        public boolean equals(Object p){\n            if(((Pair)p).start==this.start && ((Pair)p).end==this.end)return true;\n            return false;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class ColoredBalls {\n    public static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int k = sc.nextInt();\n        int[] c = getArray(sc, k);\n        long res = 1;\n\n        int sumK = 0;\n        for (int i = 0; i < k; i++) {\n            sumK += c[i];\n            res = res * nChooseKbig(sumK - 1, c[i] - 1).intValue() % MOD;\n        }\n\n        System.out.println(res);\n    }\n\n    private static BigInteger nChooseKbig(int n, int k) {\n        BigInteger nCk = BigInteger.ONE;\n        for (int i = 0; i < k; i++) {\n            nCk = nCk.multiply( BigInteger.valueOf(n - i) ).divide(BigInteger.valueOf (i + 1));\n        }\n        return nCk.mod(BigInteger.valueOf(MOD));\n    }\n\n    private static int nChooseK(int n, int k) {\n        int nCk = 1;\n        for (int i = 0; i < k; i++) {\n            nCk = (nCk * (n - i) / (i + 1)) % MOD;\n        }\n        return nCk;\n    }\n\n    private static int[] getArray(Scanner sc, int k) {\n        int[] arr = new int[k];\n        for (int i = 0; i < k; i++) {\n            arr[i] = sc.nextInt();\n        }\n        return arr;\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "\n\ndef fact(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans *= i\n    return ans\n\nk = input()\n\nif k == 1:\n    x = input()\n    print 1\nelse:\n    store = []\n    running_sum = 0\n    \n    for i in range(k):\n        x = input()\n        store.append(x)\n\n    ans = fact(sum(store))\n\n\n    running_sum = store[0]\n    ans /= fact(store[0])\n    runs = []\n\n    \n    for i in range(1,k):\n        ans *= store[i]\n        running_sum += store[i]\n        runs.append(running_sum)\n        #print store[i],running_sum\n    \n    for i in range(1,k):\n        ans /= fact(store[i])\n    for i in runs:\n        ans /= i\n    print ans % 1000000007\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1010, mod = 1e9 + 7;\nint k, c[Maxn], s[Maxn];\nlong long fac[Maxn][Maxn];\nvoid init() {\n  int i, j;\n  fac[0][0] = 1;\n  for (i = 1; i <= 1000; i++) {\n    fac[i][0] = 1;\n    for (j = 1; j <= 1000; j++)\n      fac[i][j] = (fac[i - 1][j - 1] + fac[i - 1][j]) % mod;\n  }\n}\nint main(int argc, const char* argv[]) {\n  ios::sync_with_stdio(0);\n  int i;\n  cin >> k;\n  for (i = 1; i <= k; i++) cin >> c[i], s[i] = s[i - 1] + c[i];\n  init();\n  long long ans = 1;\n  for (i = 1; i <= k; i++) ans = 1LL * ans * fac[s[i] - 1][c[i] - 1] % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class A {\n    static final long MOD = 1_000_000_007;\n    public static void main(String[] args) {\n//        Scanner sc = new Scanner(System.in);\n        FastScanner sc = new FastScanner();\n\n        long[][] choose = new long[1001][1001];\n        for (int row = 0; row < choose.length; row++) {\n            choose[row][0] = 1;\n            for (int col = 1; col < row; col++) {\n                choose[row][col] = (choose[row-1][col-1] + choose[row-1][col]) % MOD;\n            }\n            choose[row][row] = 1;\n        }\n\n        int numColors = sc.nextInt();\n        long numWays = 1;\n        int prefixSum = 0;\n        for (int i = 0; i < numColors; i++) {\n            int freq = sc.nextInt();\n            prefixSum += freq;\n            numWays *= choose[prefixSum - 1][freq - 1];\n            numWays %= MOD;\n        }\n\n        System.out.println(numWays);\n    }\n\n    static void shuffle(int[] arr) {\n        Random rng = new Random();\n        int length = arr.length;\n        for (int idx = 0; idx < arr.length; idx++) {\n            int toSwap = idx + rng.nextInt(length-idx);\n            int tmp = arr[idx];\n            arr[idx] = arr[toSwap];\n            arr[toSwap] = tmp;\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k, c[1005][1005], mod = 1000000007, a[1005], dp[1005];\nint add(int a, int b) {\n  long long c = a + b;\n  if (c >= mod) c -= mod;\n  return (int)c;\n}\nint main() {\n  c[0][0] = 1;\n  for (int i = 1; i <= 1003; ++i) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      c[i][j] = add(c[i - 1][j], c[i - 1][j - 1]);\n    }\n  }\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", &a[i]);\n  long long ans = 1;\n  int sum = 0;\n  for (int i = 1; i <= k; ++i) {\n    ans = (ans * c[sum + a[i] - 1][a[i] - 1]) % mod;\n    sum += a[i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "MOD = int(1e9 + 7)\nC = [[0]*(1001) for i in range(1001)]\nC[0][0] = 1\nfor n in range(1,1001):\n\tC[n][0] = 1\n\tC[n][n] = 1\n\tfor k in range(1,n):\n\t\tC[n][k] = C[n-1][k-1] + C[n-1][k]\nk = int(input())\nr = 1\nn = 0\nfor i in range(k):\n\tc = int(input())\n\tn += c\n\tr = (r * C[n-1][c-1]) % MOD\nprint(r)\n"
        },
        {
            "language": 1,
            "solution": "m=1000000007\ndp=[[0 for i in range(1000+9)]for i in range(1000+9)]\ndef coeff(n,k):\n\t\n\ti=0\n\twhile i<=n:\n\t\tdp[i][0]=1\n\t\ti+=1\n\ti=1\n\twhile i<=n:\n\t\tj=1\n\t\twhile j<=i:\n\t\t\tdp[i][j]=dp[i-1][j-1]+dp[i-1][j]\n\t\t\tdp[i][j]=dp[i][j]%m\n\t\t\tj+=1\n\t\ti+=1\n\t\ndef ways(n,col,k):\n\ti=1\n\tans=1\n\tsum=col[0]\t\n\twhile i<=k:\n\t\tsum+=col[i]\n\t\tans*=dp[sum-1][col[i]-1]\n\t\tans=ans%m\n\t\ti+=1\n\treturn ans\n\ndef main():\n\tcoeff(1002,1002)\n\tk=raw_input()\n\tk=k.split(' ')\n\tk=int(k[0])\n\ti=0\n\tcol=[]\n\tsum=0\n\twhile i<k:\n\t\ta=raw_input()\n\t\ta=a.split(' ')\n\t\ta=int(a[0])\n\t\tcol.append(a)\n\t\tsum+=a\n\t\ti+=1\n\t#print dp\n\n\tprint ways(sum,col,k-1)\nif __name__=='__main__':\n\tmain()\n\t\n\n\n\n\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long comb[1003][1003], sum;\nint k, c[1003];\nint main() {\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  comb[0][0] = 1;\n  for (int i = 1; i < 1001; i++) {\n    comb[i][0] = 1, comb[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;\n    }\n  }\n  long long sol = 1;\n  for (int i = 0; i < k; i++) {\n    sum += c[i];\n    sol = (sol * comb[sum - 1][c[i] - 1]) % mod;\n  }\n  cout << sol << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "k = input()\ncounts = [input() for _ in xrange(k)]\n\ntotal = 1\nsu = sum(counts)\n\nfrom math import factorial\n\ndef c(n, k):\n    return (factorial(n) // (factorial(n-k) * factorial(k))) % (10 ** 9 + 7)\n\nfor i in range(k-1, -1, -1):\n    total = (total * c(su - 1, counts[i]-1)) % (10 ** 9 + 7)\n    su -= counts[i]\n\nprint total\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/**\n * Created by Snayde on 05.01.2015.\n */\npublic class Main {\n\n    private static int[] a;\n    private static long l = 1000000007l;\n    private static long[][] c;\n\n    public static void solve() {\n        int n = IO.readInt();\n        a = new int[n];\n        int sum = 0;\n        for (int index = 0; index < n; ++index) {\n            a[index] = IO.readInt();\n            sum += a[index];\n        }\n        c = new long[1001][1001];\n        for (int i = 1; i <= 1000; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                if (i == j || j == 0) {\n                    c[i][j] = 1;\n                }\n                else {\n                    c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % l;\n                }\n            }\n        }\n        IO.println(dp(n - 1, sum));\n    }\n\n    private static long dp(int index, int sum) {\n        long result = index == 0 ? 1 : dp(index - 1, sum - a[index]) * c[sum - 1][a[index] - 1];\n        result %= l;\n        return result;\n    }\n\n    // Input/Output ================================\n    public static class IO {\n\n        private static Scanner scanner;\n        private static PrintWriter writer;\n\n        public static void setUp(InputStream in, OutputStream out) {\n            scanner = new Scanner(new java.io.BufferedInputStream(in));\n            writer = new PrintWriter(out);\n        }\n\n        public static boolean isEmpty() {\n            return !scanner.hasNext();\n        }\n\n        public static boolean hasNextLine() {\n            return scanner.hasNextLine();\n        }\n\n        public static String readLine() {\n            String line;\n            try {\n                line = scanner.nextLine();\n            } catch (Exception e) {\n                line = null;\n            }\n            return line;\n        }\n\n        public static String readString() {\n            return scanner.next();\n        }\n\n        public static int readInt() {\n            return scanner.nextInt();\n        }\n\n        public static double readDouble() {\n            return scanner.nextDouble();\n        }\n\n        public static float readFloat() {\n            return scanner.nextFloat();\n        }\n\n        public static long readLong() {\n            return scanner.nextLong();\n        }\n\n        public static char readChar() {\n            return scanner.findInLine(\"[^\\\\s]\").charAt(0);\n        }\n\n        public static void print(Object o) {\n            writer.print(o);\n            writer.flush();\n        }\n\n        public static void println(Object o) {\n            writer.println(o);\n            writer.flush();\n        }\n    }\n\n    // Algorithms ================================\n\n    private static class Algo {\n\n        private static int binSearch(int[] array, int n, int lo, int hi) {\n            if (lo > hi) {\n                return lo;\n            }\n\n            int mid = lo + (hi - lo) / 2;\n            int cmp = (int) Math.signum(n - array[mid]);\n            if (cmp < 0) {\n                return binSearch(array, n, lo, mid - 1);\n            } else if (cmp == 0) {\n                return mid;\n            } else {\n                return binSearch(array, n, mid + 1, hi);\n            }\n        }\n\n        private static void permutations(int n) {\n            int[] p = new int[n];\n            for (int index = 0; index < n; ++index) {\n                p[index] = index + 1;\n            }\n\n            while (true) {\n                IO.println(Arrays.toString(p));\n\n                int k = n - 1;\n                while (k > 0) {\n                    if (p[k] < p[k - 1]) {\n                        k--;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (k == 0) {\n                    break;\n                }\n                int j = n - 1;\n                while (p[j] < p[k - 1]) {\n                    j--;\n                }\n\n                int t = p[j];\n                p[j] = p[k - 1];\n                p[k - 1] = t;\n\n                int i = 0;\n                while (k + i < n - 1 - i) {\n                    t = p[k + i];\n                    p[k + i] = p[n - i - 1];\n                    p[n - i - 1] = t;\n                    i++;\n                }\n            }\n        }\n\n        private static final boolean isPrime(int number) {\n            if (number <= 1) {\n                return false;\n            }\n            if (number <= 3) {\n                return true;\n            }\n            if (number % 2 == 0 || number % 3 == 0) {\n                return false;\n            }\n            int i = 5;\n            while (i * i <= number) {\n                if (number % i == 0 || number % (i + 2) == 0) {\n                    return false;\n                }\n                i += 6;\n            }\n            return true;\n        }\n\n        private static boolean isPalindrome(int number) {\n            int n = number;\n            int reverse = 0;\n            while (n > 0) {\n                reverse *= 10;\n                reverse += (n % 10);\n                n /= 10;\n            }\n            return reverse == number;\n        }\n\n        public static int gcd(int a,int b) {\n            while (b != 0) {\n                int tmp = a % b;\n                a = b;\n                b = tmp;\n            }\n            return a;\n        }\n    }\n\n    public static final void main(String[] args) {\n        IO.setUp(System.in, System.out);\n        /*\n        try {\n            IO.setUp(new FileInputStream(\"encode.in\"), new FileOutputStream(\"encode.out\"));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return;\n        }\n        */\n        solve();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n/**\n * Created by misanand on 6/26/15.\n * borrowed from lewin\n * http://codeforces.com/contest/553/problem/A\n */\npublic class ColoredBalls {\n    public static void main(String [] args) {\n        Scanner scanner = new Scanner(System.in);\n        int MAX = 1001;\n        int MOD = 1000000007;\n        long [][] ncr = new long[MAX][MAX];\n        ncr[0][0] = 1;\n        for (int i=1;i<MAX;i++) {\n            ncr[i][0] = 1;\n            for (int j=1;j<MAX;j++) {\n                ncr[i][j] = ( ncr[i-1][j-1]+ ncr[i-1][j])%MOD;\n            }\n        }\n        long res = 1;\n        int total = 0;\n        int K = scanner.nextInt();\n        int [] balls = new int[K];\n        for (int i=0;i<K;i++) {\n            balls[i] = scanner.nextInt();\n        }\n        for (int i=0;i<K;i++) {\n            res *= ncr[total+balls[i]-1][balls[i]-1];\n            res %= MOD;\n            total += balls[i];\n        }\n        System.out.println(res);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isPrime(long long int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool sortbydesc(const pair<long long int, long long int> &a,\n                const pair<long long int, long long int> &b) {\n  if (a.second < b.second)\n    return true;\n  else\n    return false;\n}\nlong long int bin[1001][1001];\nlong long int binomial(long long int n, long long int k) {\n  if (bin[n][k] != -1) return bin[n][k];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n;\n  cin >> n;\n  long long int bin[1001][1001];\n  memset(bin, 0, sizeof(bin));\n  bin[1][0] = 1 % 1000000007;\n  bin[1][1] = 1 % 1000000007;\n  for (long long int i = 2; i < 1001; i++) {\n    bin[i][0] = 1 % 1000000007;\n    for (long long int j = 1; j < i + 1; j++) {\n      bin[i][j] = (bin[i - 1][j] + bin[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  vector<long long int> v, k;\n  long long int a;\n  v.push_back(0);\n  k.push_back(0);\n  for (long long int i = 1; i < n + 1; i++) {\n    cin >> a;\n    k.push_back(a);\n    v.push_back(a + v[i - 1]);\n  }\n  long long int ans = 1;\n  for (long long int i = 2; i < n + 1; i++) {\n    ans = (ans * bin[v[i] - 1][k[i] - 1]) % 1000000007;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/python\n# -*- encoding: utf-8 -*-\n# pylint: disable=invalid-name,missing-docstring,bad-builtin\nfrom sys import stdin\nfrom itertools import imap\n\ndef main():\n    mod = 1000000007\n    fact = [1]\n    ifact = [1]\n    for x in xrange(1, 2002):\n        fact.append((fact[-1] * x) % mod)\n        ifact.append(pow(fact[-1], mod - 2, mod))\n    choose = lambda n, r: (fact[n] * ifact[n - r] * ifact[r]) % mod\n    dstream = imap(int, stdin.read().split())\n    balls = [next(dstream) for _ in xrange(next(dstream))]\n    prod = 1\n    till = balls[0]\n    for x in xrange(1, len(balls)):\n        prod = (prod * choose(balls[x] + till - 1, till)) % mod\n        till += balls[x]\n    print prod\n\nmain()\n"
        },
        {
            "language": 3,
            "solution": "f = [1] * (10 ** 6)\nfor i in range(2, 10 ** 3 + 1):\n    f[i] = f[i - 1] * i\nk = int(input())\ns = 0\nans = 1\nfor i in range(k):\n    c = int(input())\n    ans *= (f[(s + c - 1)] // f[c - 1] // f[s]) % (10 ** 9 + 7)\n    s += c\nprint(ans % (10 ** 9 + 7))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\tstatic PrintWriter writer;\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tstatic boolean eof = false;\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttokenizer = null;\n\t\t// reader = new BufferedReader(new FileReader(\"war.in\"));\n\t\t// writer = new PrintWriter(new FileWriter(\"war.out\"));\n\t\treader = new BufferedReader(new InputStreamReader(System.in, \"ISO-8859-1\"));\n\t\twriter = new PrintWriter(System.out);\n\t\tbanana();\n\t\treader.close();\n\t\twriter.close();\n\t}\n\n\tstatic long mod = 1000000000 + 7;\n\tstatic long ceizenpok[][] = new long[1001][1001];\n\n\tstatic void banana() throws IOException {\n\t\tint n = nextInt();\n\n\t\tint a[] = new int[n];\n\n\t\tint sum = 0;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\ta[i] = nextInt();\n\n\t\tfor (int i = 0; i <= 1000; ++i)\n\t\t\tceizenpok[i][0] = 1;\n\n\t\tfor (int i = 1; i <= 1000; ++i)\n\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\tceizenpok[i][j] = (ceizenpok[i - 1][j] + ceizenpok[i - 1][j - 1]) % mod;\n\t\t\t}\n\n\t\tlong dp[] = new long[n];\n\n\t\tdp[0] = 1;\n\t\tsum = a[0];\n\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tlong cum = 0;\n\n\t\t\tfor (int j = 0; j < a[i]; ++j)\n\t\t\t\tcum = (cum + ceizenpok[sum + j - 1][j]) % mod;\n\t\t\tsum += a[i];\n\n\t\t\tdp[i] = (dp[i - 1] * cum) % mod;\n\t\t}\n\n\t\tSystem.out.println(dp[n - 1]);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def fpow(a,n):\n    ret = 1\n    a = a % mod\n    while n:\n        if n&1:\n            ret = ret*a%mod\n        a = a*a%mod\n        n >>= 1\n    return ret\n\ndef prob(i, j):\n\treturn factorial[i]*fpow(factorial[j]*factorial[i-j]%mod,mod-2)%mod\n\nmod = 1000000007\nsum_colors = 0\nfactorial = [1]\ncolors = []\ntot = 1\n\nfor x in range(1, 1000000, 1):\n\tfactorial.append((factorial[x-1])*x%mod)\n\nn_colors = int(input())\nfor x in range(n_colors):\n\t_in = int(input())\n\tcolors.append(_in)\n\tsum_colors += _in\n\nfor x in range(n_colors-1, -1, -1):\n\ttot = tot * prob(sum_colors-1, colors[x]-1)%mod\n\tsum_colors -= colors[x]\n\nprint(tot)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class q3 \n{\n\n    static long fec[]=new long[2002];\n    \n    public static void make()\n    {\n        fec[0]=1;\n        for(int i=1;i<2002;i++)\n        {\n            fec[i]=(i*fec[i-1])%1000000007;\n        }\n    }\n    public static long ncr[][];\n    public static void main(String args[])\n    {\n        make();\n        Scanner s=new Scanner(System.in);\n        int k=s.nextInt();\n        int c[]=new int[k+1];\n        int tmp[]=new int[k];\n        for(int i=0;i<k;i++)\n        {\n            c[i]=s.nextInt();\n            if(i!=0)\n            tmp[i]=c[i]+tmp[i-1];\n            else\n                tmp[i]=c[i];\n        }\n        \n        \n         ncr=new long[1100][1100];\n            long mod=1000000007;\n            for(int i=0;i<ncr.length;i++)\n            {\n                ncr[i][i]=1;\n                ncr[i][0]=1;\n                for(int j=1;j<i;j++)\n                {\n                    ncr[i][j]=(ncr[i-1][j]+ncr[i-1][j-1])%mod;\n                }\n            }\n        \n        \n        \n        //long ans=1;\n        BigInteger ans=new BigInteger(\"1\");\n        long p=0;\n        \n        for(int i=1;i<k;i++)\n        {\n            //long tmp=0;\n//          p+=c[i-1];\n//          p++;\n            //System.out.println(ans+\" before\");\n            p=tmp[i-1]+1;\n            if(c[i]!=1)\n            {//System.out.println((p+c[i])+\" \");\n            ans=ans.multiply(new BigInteger(ncr[(int)p+c[i]-2][(int)p-1]+\"\"));     //%1000000007;\n            //System.out.println(ans+\" \"+i+\" \"+p+\" \"+c[i]+\" \"+(fec[(int)(p+c[i]-2)])/(fec[c[i]-1]*fec[(int)p-1])+\" \"+ans.multiply(new BigInteger((fec[(int)(p+c[i]-2)])/(fec[c[i]-1]*fec[(int)p-1])+\"\")));\n            }\n        }\n        ans=ans.mod(new BigInteger(\"1000000007\"));\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mod = 1000000007;\nlong long int fast_exp(long long int base, int exp) {\n  if (exp == 0) return 1;\n  if (exp == 1)\n    return base;\n  else {\n    if (exp % 2 == 0) {\n      long long int k, temp;\n      temp = exp >> 1;\n      k = fast_exp(base, temp) % mod;\n      k = k % mod * k % mod;\n      k %= mod;\n      long long int base1 = k;\n      if (base1 >= mod)\n        return base1 % mod;\n      else\n        return base1;\n    } else {\n      long long int k, temp;\n      temp = (exp - 1);\n      temp = temp >> 1;\n      k = fast_exp(base, temp) % mod;\n      k = k % mod * k % mod;\n      k %= mod;\n      long long int ans = (base % mod);\n      ans *= (k % mod);\n      ans %= mod;\n      if (ans >= mod)\n        return ans % mod;\n      else\n        return ans;\n    }\n  }\n}\nint a[1005];\nint main() {\n  unsigned long long int n, k, i;\n  unsigned long long int fans = 0, ans = 0, temp, len, seq = 0, t1;\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> a[i];\n  }\n  fans = 1;\n  len = 0;\n  fans = 1;\n  seq = 1;\n  long long int num = 1, den = 1;\n  for (i = 1; i <= k; i++) {\n    temp = a[i];\n    len++;\n    temp--;\n    t1 = 1;\n    while (temp--) {\n      seq *= (len);\n      den *= t1;\n      den %= mod;\n      t1++;\n      len++;\n      seq %= mod;\n    }\n  }\n  long long int d1 = fast_exp(den, mod - 2);\n  seq *= d1;\n  seq %= mod;\n  cout << seq << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nlong long cnt[2048];\nbool IsPrime(long long x) {\n  long long X = sqrt(x), i;\n  for (i = 2; i <= X; i++) {\n    if (x % i == 0) return false;\n  }\n  return false;\n}\nint main() {\n  long long ans = 1;\n  long long n, sum = 0, i, j;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    long long a;\n    cin >> a;\n    long long jj = i;\n    for (int i = sum + 1; i < sum + a; i++) {\n      long long a = i, j;\n      for (j = 2; j <= sqrt(a); j++) {\n        if (IsPrime(a)) break;\n        while (a % j == 0) {\n          a /= j;\n          cnt[j]++;\n        }\n      }\n      cnt[a]++;\n    }\n    sum += a;\n    for (int i = 1; i < a; i++) {\n      long long a = i, j;\n      for (j = 2; j <= sqrt(a); j++) {\n        if (IsPrime(a)) break;\n        while (a % j == 0) {\n          a /= j;\n          cnt[j]--;\n        }\n      }\n      cnt[a]--;\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    long long a = i, j;\n  }\n  for (i = 1; i < 2048; i++) {\n    for (j = 1; j <= cnt[i]; j++) {\n      ans *= i;\n      ans %= mod;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong long C[1001][1001];\nlong long dp[1001];\nlong long color[1001];\nlong long combination(int n, int p) {\n  if (n == p || p == 0) {\n    return C[n][p] = 1;\n  }\n  if (C[n][p] != -1) {\n    return C[n][p];\n  } else {\n    long long ans = combination(n - 1, p) % 1000000007L;\n    ans = ans + (combination(n - 1, p - 1) % 1000000007L);\n    return C[n][p] = ans % 1000000007L;\n  }\n}\nlong long solve(int k) {\n  if (k == 1) {\n    return 1;\n  } else if (dp[k] != -1) {\n    return dp[k];\n  } else {\n    long long sum = 0;\n    for (int i = 1; i <= k; i++) {\n      sum += color[i];\n    }\n    sum--;\n    long long ans = combination(sum, color[k] - 1);\n    ans *= solve(k - 1);\n    ans %= 1000000007L;\n    return dp[k] = ans;\n  }\n}\nint main() {\n  scanf(\"%d\\n\", &N);\n  for (int i = 1; i <= N; i++) {\n    cin >> color[i];\n  }\n  memset(dp, -1, sizeof dp);\n  memset(C, -1, sizeof C);\n  long long ans = solve(N);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.*;\nimport java.util.Scanner;\n\npublic class Main {\n    static BigInteger[][] c;\n    public static void main(String[] args)\n    {\n        Scanner cin = new Scanner(System.in);\n        getc();\n        int n = cin.nextInt(),sum=0;\n        BigInteger ans = BigInteger.ONE;\n        BigInteger mod = BigInteger.valueOf(1000000007);\n        for(int i=0;i<n;i++)\n        {\n            int a=cin.nextInt();\n            ans=ans.multiply(c[sum+a-1][a-1]);\n            ans=ans.mod(mod);\n            sum+=a;\n        }\n        System.out.println(ans);\n        \n    }\n    \n    static void getc()\n    {\n        c = new BigInteger[1005][1005];\n        for(int i=0;i<=1000;i++)\n        {\n            c[i][0] = BigInteger.ONE;\n        }\n        for(int i=1;i<=1000;i++)\n        {\n            for(int j=1;j<=i;j++)\n            {\n                c[i][j]=c[i][j-1].multiply(BigInteger.valueOf(i-j+1)).divide(BigInteger.valueOf(j));\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) *\n                                     rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) {\n    return v;\n  }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = (int)1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nconst int maxn = 2e6 + 1;\nvector<Mint> fact(maxn, (Mint)1);\nMint nCr(int n, int r) {\n  Mint ans = fact[n] / (fact[r] * fact[n - r]);\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  fact[0] = fact[1] = 1;\n  for (int i = 2; i < maxn; i++) fact[i] *= fact[i - 1] * i;\n  int k;\n  cin >> k;\n  Mint ans = 1;\n  vector<int> a(k);\n  for (auto& i : a) cin >> i;\n  int sum = a[0];\n  for (int i = 1; i < k; i++) {\n    sum += a[i];\n    ans *= nCr(sum - 1, a[i] - 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, const U &b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, const U &b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void gn(T &first) {\n  char c, sg = 0;\n  while (c = getchar(), (c > '9' || c < '0') && c != '-')\n    ;\n  for ((c == '-' ? sg = 1, c = getchar() : 0), first = 0; c >= '0' && c <= '9';\n       c = getchar())\n    first = (first << 1) + (first << 3) + c - '0';\n  if (sg) first = -first;\n}\ntemplate <class T1, class T2>\ninline void gn(T1 &x1, T2 &x2) {\n  gn(x1), gn(x2);\n}\ntemplate <class T1, class T2, class T3>\ninline void gn(T1 &x1, T2 &x2, T3 &x3) {\n  gn(x1, x2), gn(x3);\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline void gn(T1 &x1, T2 &x2, T3 &x3, T4 &x4) {\n  gn(x1, x2, x3), gn(x4);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\ninline void gn(T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5) {\n  gn(x1, x2, x3, x4), gn(x5);\n}\ntemplate <class T>\ninline void print(T first) {\n  if (first < 0) {\n    putchar('-');\n    return print(-first);\n  }\n  if (first < 10) {\n    putchar('0' + first);\n    return;\n  }\n  print(first / 10);\n  putchar(first % 10 + '0');\n}\ntemplate <class T>\ninline void println(T first) {\n  print(first);\n  putchar('\\n');\n}\ntemplate <class T>\ninline void printsp(T first) {\n  print(first);\n  putchar(' ');\n}\ntemplate <class T1, class T2>\ninline void print(T1 x1, T2 x2) {\n  printsp(x1), println(x2);\n}\ntemplate <class T1, class T2, class T3>\ninline void print(T1 x1, T2 x2, T3 x3) {\n  printsp(x1), printsp(x2), println(x3);\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline void print(T1 x1, T2 x2, T3 x3, T4 x4) {\n  printsp(x1), printsp(x2), printsp(x3), println(x4);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\ninline void print(T1 x1, T2 x2, T3 x3, T4 x4, T5 x5) {\n  printsp(x1), printsp(x2), printsp(x3), printsp(x4), println(x5);\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = 1LL * a * a % m)\n    if (b & 1) ans = 1LL * ans * a % m;\n  return ans;\n}\nint a[1010], c[1010][1010];\nint main() {\n  for (int i = 0; i < 1010; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || j == i)\n        c[i][j] = 1;\n      else\n        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % 1000000007;\n    }\n  }\n  int n;\n  gn(n);\n  for (int i = 0; i < n; i++) gn(a[i]);\n  int ans = 1, sum = a[0];\n  for (int i = 1; i < n; i++) {\n    ans = 1LL * ans * c[sum + a[i] - 1][a[i] - 1] % 1000000007;\n    sum += a[i];\n  }\n  println(ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxK = 1e3 + 7;\nconst long long MOD = 1000000007;\nint c[MaxK];\nlong long comb[MaxK][MaxK], dp[MaxK];\nint main() {\n  int k, n = 0;\n  cin >> k;\n  for (int i = 0; i < (int)k; ++i) {\n    cin >> c[i];\n    n += c[i];\n  }\n  comb[0][0] = 1;\n  for (int i = 1; i < MaxK; ++i) {\n    comb[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]);\n      if (comb[i][j] >= MOD) comb[i][j] -= MOD;\n    }\n  }\n  long long res = 1;\n  n = 0;\n  for (int i = 0; i < k; ++i) {\n    res = (res * comb[n + c[i] - 1][c[i] - 1]) % MOD;\n    n += c[i];\n  }\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial as f\ndef ncr(n, r): return f(n) // (f(r) * f(n - r))\nk = int(input())\nk += -1\nans = 1\nt1 = int(input())\nwhile k:\n    k += -1\n    t2 = int(input())\n    ans *= ncr(t1 + t2 - 1, t2 - 1)\n    t1 += t2\nprint(ans % 1000000007)\n     \t\t \t\t \t\t \t\t\t \t  \t\t\t   \t"
        },
        {
            "language": 1,
            "solution": "mod = 1000000007\nn = int(raw_input())\na = [int(raw_input()) for _ in range(n)]\nres = 1\nbefore = a[0]\nfor i in range(1, n):\n    before += 1\n    a[i] -= 1\n    alreadyadded = 1\n    tobeadded = a[i]\n    while a[i] > 0: \n        res *= before\n        res /= alreadyadded\n        alreadyadded += 1\n        a[i] -= 1\n        before += 1\nprint(res % mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 1000000007;\nusing namespace std;\nlong long int nCr[2010][2010];\nvoid init() {\n  int i, j;\n  for (i = 0; i <= 2000; i++) {\n    for (j = 0; j <= min(i, 2000); j++) {\n      if (j == 0 || j == i)\n        nCr[i][j] = 1;\n      else\n        nCr[i][j] = (nCr[i - 1][j] % MOD + nCr[i - 1][j - 1] % MOD) % MOD;\n    }\n  }\n}\nint main() {\n  int k, i;\n  init();\n  cin >> k;\n  int C[k];\n  int sum[k];\n  for (i = 0; i < k; i++) cin >> C[i];\n  sum[0] = C[0];\n  for (i = 1; i < k; i++) sum[i] = sum[i - 1] + C[i];\n  long long int a, b;\n  a = 1;\n  for (i = 1; i < k; i++) {\n    b = ((a % MOD) * (nCr[sum[i - 1] + C[i] - 1][C[i] - 1] % MOD)) % MOD;\n    a = b;\n  }\n  cout << a << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main \n{\n    private static MyScanner sc;\n    private static PrintWriter out;\n    private static int[][] binomial;\n    private static final Integer LIMIT = 1001;\n    private static final Integer MOD = 1000000007;\n    public static void main(String[] args)\n    {\n    \tsc = new MyScanner();\n    \tout = new PrintWriter(System.out);\n    \tprecompute();\n    \tint n = sc.nextInt();\n    \tint total = 0;\n    \tint[] arr = new int[n];\n    \tfor(int i = 0; i < n; i++)\n    \t{\n    \t\tarr[i] = sc.nextInt();\n    \t\ttotal += arr[i];\n    \t}\n    \tlong answer = 1;\n    \tint choosing = total;\n    \tfor(int k = arr.length - 1; k >= 0; k--)\n    \t{\n    \t\tchoosing--;\n    \t\tint left = arr[k] - 1;\n    \t\tanswer = (answer * binomial[choosing][left]) % MOD;\n    \t\tchoosing -= left;\n    \t}\n    \t\n    \tout.println(answer);\n    \tout.close();\n    }\n    \n    private static void precompute()\n    {\n    \tbinomial = new int[LIMIT][LIMIT];\n    \tfor(int n = 1; n < LIMIT; n++)\n    \t{\n    \t\tfor(int k = 0; k < LIMIT; k++)\n    \t\t{\n    \t\t\tif(k == 0) binomial[n][k] = 1;\n    \t\t\telse if(n == k) binomial[n][k] = 1;\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tbinomial[n][k] = (binomial[n - 1][k - 1] + binomial[n - 1][k])  % MOD;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t}\n    \tbinomial[0][0] = 1;\n    \t\n    }\n    \n    private static int max(int a, int b)\n    {\n        if(a > b) return a;\n        else return b;\n    }\n\n    private static int min(int a, int b)\n    {\n        if(a < b) return a;\n        else return b;\n\n    }\n\n private static int abs(int a, int b)\n    {\n        return (int) Math.abs(a - b);\n    }\n    \n     public static int modexp(int a, int b, int n) \n     {\n        if (b == 0) return 1;\n        long t = modexp(a, b/2, n);  \n        long c = (t * t) % n;\n        if (b % 2 == 1)\n           c = (c * a) % n;\n        return (int) c;\n    }\n    \n public static class MyScanner \n    {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() \n      {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() \n      {\n          while (st == null || !st.hasMoreElements()) \n          {\n              try \n              {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) \n              {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() \n      {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() \n      {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() \n      {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine()\n      {\n          String str = \"\";\n\t  try \n          {\n\t     str = br.readLine();\n\t  } catch (IOException e) \n          {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n\n   }\n}"
        },
        {
            "language": 3,
            "solution": "n=int(input())\nret=1\nsum=0\nmod=1000000007\nfor a in range(n):\n    q=int(input())\n    e=1\n    for b in range(q-1):\n        e*=(sum+1+b)\n    sil=1\n    for b in range(2,q):\n        sil*=b\n    e//=sil\n    e%=mod\n    ret*=e\n    ret%=mod\n    sum+=q\nprint(ret)\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n    \n    \npublic class Solution  {\n    \n    static class FastScanner{\n        BufferedReader s;\n        StringTokenizer st;\n        \n        \n        public FastScanner(){\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        public FastScanner(File f) throws FileNotFoundException{\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader (new FileReader(f));\n        }\n        \n        public int nextInt() throws IOException{\n            if(st.hasMoreTokens())\n                return Integer.parseInt(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextInt();\n            }\n        }\n        \n        public double nextDouble() throws IOException{\n            if(st.hasMoreTokens())\n                return Double.parseDouble(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextDouble();\n            }\n        }\n        \n        public long nextLong() throws IOException{\n            if(st.hasMoreTokens())\n                return Long.parseLong(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextLong();\n            }\n        }\n        \n        public String nextString() throws IOException{\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextString();\n            }\n            \n        }\n        public String readLine() throws IOException{\n            return s.readLine();\n        }\n        \n        public void close() throws IOException{\n            s.close();\n        }\n        \n    }\n    \n    \n    \n    \n    //FastScanner s = new FastScanner(new File(\"input.txt\"));       copy inside void solve\n    //PrintWriter ww = new PrintWriter(new FileWriter(\"output.txt\"));\n    static FastScanner s = new FastScanner();   \n    static PrintWriter ww = new PrintWriter(new OutputStreamWriter(System.out));\n    \n    public static void main(String args[])throws IOException{\n        //Main ob=new Main();\n        Solution ob=new Solution();\n        ob.solve();\n        ww.close();\n    }\n    /////////////////////////////////////////////\n   \n    //////////////////////////////////////////////\n    int MOD = (int)1e9+7;\n    long ncr[][] = new long[1000+7][1000+7];\n    \n    void precomputation(){\n        ncr[0][0] = 1;\n        \n        for(int i=1;i<=1000;i++){\n            for(int j=0;j<=i;j++){\n                if(j==0)\n                    ncr[i][j] = 1;\n                else{\n                    ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j])%MOD;\n                }\n            }\n        }\n    }\n    \n   ///////////////////////////////////////////\n\n    void solve() throws IOException{\n   \n        int n  = s.nextInt();\n        \n        precomputation();\n        \n        long ans = 1;\n        int sum = 0;\n        for(int i=0;i<n;i++){\n            int temp=s.nextInt();\n            sum+=temp;\n            ans=((ans%MOD)*(ncr[sum-1][temp-1]%MOD))%MOD;\n        }\n\n        ww.println(ans);\n    }\n}"
        },
        {
            "language": 1,
            "solution": "MAXN = 1005\nMOD = 1000000007\n\ncomb = [[0] * MAXN for _ in xrange(MAXN)]\ncomb[0][0] = 1\n\nfor n in xrange(1, MAXN):\n    for m in xrange(n + 1):\n        comb[n][m] = comb[n - 1][m - 1] + comb[n - 1][m]\n        comb[n][m] %= MOD\n\ncolor = [input() for _ in xrange(input())]\n\nres = 1\ntotal = 0\nfor c in color:\n    res = (res * comb[total + c - 1][c - 1]) % MOD\n    total += c\n\nprint res\n"
        },
        {
            "language": 3,
            "solution": "MOD = 1000000007\nfact = [1] * 1001\nfor i in range(1,1001):\n    fact[i] = fact[i-1]*i\n    fact[i]%=MOD\ndef comb(n,r):\n    return (fact[n] * pow(fact[n-r],MOD-2,MOD) * pow(fact[r],MOD-2,MOD))%MOD\nN = int(input())\nList = []\nfor i in range(N):\n    List.append(int(input()))\ndp = [1] * (N+1)\ncurr = 0\nAns = 1\nfor i in range(1,N+1):\n    Ans = Ans * comb(curr + List[i-1] - 1, List[i-1] - 1)\n    Ans %= MOD\n    curr += List[i-1]\nprint(Ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, i, a[1007], MOD = 1000 * 1000 * 1000 + 7, f[1000007], dp[1007], ch,\n                         zn, ans = 1, tp[1007][1007], j;\nint main() {\n  tp[0][0] = 1;\n  for (i = 1; i <= 1000; i++) {\n    tp[i][0] = 1;\n    for (j = 1; j <= i; j++) {\n      tp[i][j] = (tp[i - 1][j] + tp[i - 1][j - 1]) % MOD;\n    }\n  }\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  long long sum = 0;\n  for (i = 0; i < n; i++) {\n    sum += a[i];\n    ans = ans * tp[sum - 1][a[i] - 1];\n    ans %= MOD;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long pas[2222][2222], ans = 1, mod = 1000000007;\nint main() {\n  for (int i = 0; i < 2222; i++)\n    for (int j = 0; j < 2222; j++) pas[0][j] = pas[i][j] = 1;\n  for (int i = 2; i < 2222; i++)\n    for (int j = 1; j < i; j++) {\n      pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n      pas[i][j] %= mod;\n    }\n  long long k;\n  cin >> k;\n  long long s = 0;\n  vector<int> arr(1111);\n  for (int i = 0; i < k; i++) {\n    cin >> arr[i];\n    s += arr[i];\n  }\n  s--;\n  for (int i = k - 1; i >= 0; i--) {\n    ans *= pas[s][arr[i] - 1];\n    ans %= mod;\n    ;\n    s -= arr[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n;\nlong long a[1006];\nlong long fac[1000006];\nlong long power(long long a, long long i) {\n  if (i == 0) return 1 % 1000000007;\n  long long t = power(a, i / 2);\n  long long ans = t * t % 1000000007;\n  if (i % 2 == 1) ans = ans * a % 1000000007;\n  return ans;\n}\nlong long work(long long m, long long i) {\n  return ((fac[m] % 1000000007) *\n          (power(fac[i] * fac[m - i] % 1000000007, 1000000007 - 2) %\n           1000000007)) %\n         1000000007;\n}\nint main() {\n  fac[0] = 1;\n  for (int i = 1; i < 1000006; i++) fac[i] = (fac[i - 1] * i) % 1000000007;\n  long long ans = 1;\n  long long sum = 0;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  for (int i = n; i >= 1; i--) {\n    ans = ans * work(sum - 1, a[i] - 1) % 1000000007;\n    sum -= a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2500;\nconst unsigned long long M = 1000000007;\nunsigned long long c[N][N];\nunsigned long long cal(int n, int m) {\n  unsigned long long &cur = c[n][m];\n  if (cur) return cur;\n  if (n == m || m == 0) return cur = 1;\n  return cur = (cal(n - 1, m - 1) + cal(n - 1, m)) % M;\n}\nint main() {\n  int i, j;\n  for (i = 0; i < N; i++)\n    for (j = 0; j < N; j++) c[i][j] = 0;\n  unsigned long long ans, tot;\n  int k, ai;\n  scanf(\"%d\", &k);\n  scanf(\"%d\", &ai);\n  ans = 1;\n  tot = ai;\n  for (i = 1; i < k; i++) {\n    scanf(\"%d\", &ai);\n    ans = (ans * cal(tot + ai - 1, ai - 1)) % M;\n    tot += ai;\n  }\n  printf(\"%I64u\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nfrom collections import defaultdict, Counter\nfrom itertools import permutations, combinations\nfrom math import sin, cos, asin, acos, tan, atan, pi\n\nsys.setrecursionlimit(10 ** 6)\n\ndef pyes_no(condition, yes = \"YES\", no = \"NO\", none = \"-1\") :\n  if condition == None:\n    print (none)\n  elif condition :\n    print (yes)\n  else :\n    print (no)\n\ndef plist(a, s = ' ') :\n  print (s.join(map(str, a)))\n\ndef rint() :\n  return int(sys.stdin.readline())\n\ndef rstr() :\n  return sys.stdin.readline().strip()\n\n\ndef rints() :\n  return map(int, sys.stdin.readline().split())\n\ndef rfield(n, m = None) :\n  if m == None :\n    m = n\n  \n  field = []\n  for i in xrange(n) :\n    chars = sys.stdin.readline().strip()\n    assert(len(chars) == m)\n    field.append(chars)\n  return field\n\ndef pfield(field, separator = '') :\n  print ('\\n'.join(map(lambda x: separator.join(x), field)))\n\ndef check_field_equal(field, i, j, value) :\n  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :\n    return value == field[i][j]\n  return None \n\ndef digits(x, p) :\n  digits = []\n  while x > 0 :\n    digits.append(x % p)\n    x //= p\n  return digits[::-1]\n\ndef undigits(x, p) :\n  value = 0\n  for d in x :\n    value *= p\n    value += d\n  return value\n\ndef modpower(a, n, mod) :\n  r = a ** (n % 2)\n  if n > 1 :\n    r *= modpower(a, n // 2, mod) ** 2\n  return r % mod\n\ndef gcd(a, b) :\n  if a > b :\n    a, b = b, a\n  \n  while a > 0 :\n    a, b = b % a, a\n\n  return b\n\ndef vector_distance(a, b) :\n  diff = vector_diff(a, b)\n  \n  return scalar_product(diff, diff) ** 0.5\n\ndef vector_inverse(v) :\n  r = [-x for x in v]\n\n  return tuple(r)\n\ndef vector_diff(a, b) :\n  return vector_sum(a, vector_inverse(b))\n\ndef vector_sum(a, b) :\n  r = [c1 + c2 for c1, c2 in zip(a, b)]\n    \n  return tuple(r)\n\ndef scalar_product(a, b) :\n  r = 0\n  for c1, c2 in zip(a, b) :\n    r += c1 * c2\n\n  return r\n\ndef check_rectangle(points) :\n  assert(len(points) == 4)\n\n  A, B, C, D = points\n\n  for A1, A2, A3, A4 in [\n    (A, B, C, D),\n    (A, C, B, D),\n    (A, B, D, C),\n    (A, C, D, B),\n    (A, D, B, C),\n    (A, D, C, B),\n  ] :\n    sides = (\n      vector_diff(A1, A2),\n      vector_diff(A2, A3),\n      vector_diff(A3, A4),\n      vector_diff(A4, A1),\n    )\n    if all(scalar_product(s1, s2) == 0 for s1, s2 in zip(sides, sides[1:])) :\n       return True\n  return False\n\ndef check_square(points) :\n  if not check_rectangle(points) :\n    return False\n  A, B, C, D = points\n\n  for A1, A2, A3, A4 in [\n    (A, B, C, D),\n    (A, C, B, D),\n    (A, B, D, C),\n    (A, C, D, B),\n    (A, D, B, C),\n    (A, D, C, B),\n  ] :\n    side_lengths = [\n      (first[0] - next[0]) ** 2 + (first[1] - next[1]) ** 2 for first, next in zip([A1, A2, A3, A4], [A2, A3, A4, A1])\n    ]\n    if len(set(side_lengths)) == 1 :\n      return True\n    \n  return False\n\ndef check_right(p) :\n  # Check if there are same points\n  for a, b in [\n    (p[0], p[1]),\n    (p[0], p[2]),\n    (p[1], p[2]),\n  ] :\n    if a[0] == b[0] and a[1] == b[1] :\n      return False\n\n  a, b, c = p\n  a, b, c = vector_diff(a, b), vector_diff(b, c), vector_diff(c, a)   \n\n  return scalar_product(a, b) * scalar_product(a, c) * scalar_product(b, c) == 0\n\ndef modmatrixproduct(a, b, mod) :\n  n, m1 = len(a), len(a[0])\n  m2, k = len(b), len(b[0])\n\n  assert(m1 == m2)\n  m = m1\n\n  r = [[0] * k for i in range(n)]\n  for i in range(n) :\n    for j in range(k) :\n      for l in range(m) :\n        r[i][j] += a[i][l] * b[l][j]\n      r[i][j] %= mod\n  return r\n\ndef modmatrixpower(a, n, mod) :\n  magic = 2\n  for m in [2, 3, 5, 7] :\n    if n % m == 0 :\n      magic = m\n      break\n\n  r = None\n  if n < magic : \n    r = a\n    n -= 1\n  else :\n    s = modmatrixpower(a, n // magic, mod)\n    r = s\n    for i in range(magic - 1) :\n      r = modmatrixproduct(r, s, mod)\n\n  for i in range(n % magic) : \n    r = modmatrixproduct(r, a, mod)\n  \n  return r\n\nk = rint()\n\na = [rint() for i in range(k)]\n\nvariants = 1\nelements = 0\n\nfrom math import factorial\nfor v in a :\n  variants *= factorial(elements + v - 1) / factorial(elements) / factorial(v - 1)\n  elements += v\n  variants %= 1000000007\n\nprint variants\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long k, a[1002], p = 1000000007, l, ans, f[1002][1002];\nint main() {\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || j == i)\n        f[i][j] = 1;\n      else\n        f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % p;\n    }\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> a[i];\n  l = a[1];\n  ans = 1;\n  for (int i = 2; i <= k; i++) {\n    long long t = a[i] - 1;\n    if (t > 0) ans = (ans * f[t + l][t]) % p;\n    l += a[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nlong long factorial[2000];\nlong long pow_mod_base2(long long base, long long exp, long long mod) {\n  long long rv = 1;\n  base = base % mod;\n  while (exp > 0) {\n    if (exp & 1) {\n      rv = (rv * base) % mod;\n    }\n    exp >>= 1;\n    base = (base * base) % mod;\n  }\n  return rv;\n}\nlong long inv(long long n, long long mod) {\n  return pow_mod_base2(n, mod - 2, mod);\n}\nlong long C(long long n, long long k, long long mod) {\n  if (n < k) return 0;\n  return factorial[n] * inv(factorial[n - k], mod) % mod *\n         inv(factorial[k], mod) % mod;\n}\nlong long sum[1001];\nlong long c[1001], f[1001];\nint main() {\n  factorial[0] = 1;\n  for (int i = 1; i <= 2000; i++) {\n    factorial[i] = (factorial[i - 1] * i) % MOD;\n  }\n  int n;\n  cin >> n;\n  sum[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n    sum[i] = sum[i - 1] + c[i];\n    if (i == 1) {\n      f[i] = 1;\n      continue;\n    }\n    f[i] = (f[i - 1] * C(sum[i - 1] + c[i] - 1, sum[i - 1], MOD)) % MOD;\n  }\n  cout << f[n] % MOD << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Ejercicio7{\n  static int mod = 1000000007;\n  static int max = 1010;\n\n public static void main(String[] args){\n     Scanner sc = new Scanner(System.in);\n     int k = sc.nextInt();\n     int[] c = new int[k];\n     for(int i=0; i<k; i++){\n       c[i] = sc.nextInt();\n     }\n     ballsProb(c);\n     sc.close();\n }\n\n public static void ballsProb(int[] c){\n    long[][] prob = new long[max][max];\n    prob[0][0] = 1; // 100% (initialization)\n    long ans = 1;\n    int tot = 0;\n\n    for(int i=1; i<max; i++){\n      prob[i][0] = 1;\n      for(int j=1; j<= i; j++){\n        prob[i][j] = (prob[i-1][j] + prob[i-1][j-1]) % mod;\n      }\n    }\n\n    for (int i=0; i<c.length; i++) {\n      ans = (ans * prob[tot + c[i] - 1][c[i] - 1]) % mod;\n      tot += c[i];\n    }\n    System.out.println(ans);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int[] arr;\n        int k;\n        int mod;\n        long res;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            k = in.nextInt();\n            arr = new int[k];\n            mod = 1000000007;\n            for (int i = 0; i < k; ++i)\n                arr[i] = in.nextInt();\n\n            int sum = 0;\n            for (int i = 0; i < k; ++i) sum += arr[i];\n            res = 1;\n            for (int i = k - 1; i > -1; --i) {\n                res *= binomial(sum - 1, (arr[i] - 1)) % mod;\n                res %= mod;\n                sum -= arr[i];\n            }\n            out.println(res);\n        }\n\n        private long binomial(int n, int k) {\n            if (k > n - k)\n                k = n - k;\n            BigInteger b = BigInteger.ONE;\n            for (int i = 1, m = n; i <= k; i++, m--)\n                b = b.multiply(BigInteger.valueOf(m)).divide(BigInteger.valueOf(i));\n            return b.mod(BigInteger.valueOf(mod)).intValue();\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "ans=1\nprev=0\nM=10**9+7\nfor _ in range(int(input())):\n    x=int(input())\n    prev+=x\n    if(_==0):\n        continue\n    a=1\n    for i in range(1,x):\n        a=a*(prev-i)//(i)\n    ans=(ans*a)%M    \nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\npublic class Major {\nstatic long mod = 1000000007;\npublic static long findAns(int n,int r,long fact[]){\n\tif(r == 0)return 1;\n\tlong a = fact[n + r - 1];\n\tlong temp = fact[r]*fact[n-1]%mod;\n\ttemp = BigInteger.valueOf(temp).modInverse(BigInteger.valueOf(mod)).longValue();\n\treturn (temp*a)%mod;\n}\t\npublic static void main(String []args){\n\tScanner in = new Scanner(System.in);\n\tint k = in.nextInt();\n\tint array[]=new int[k+1];\n\t\n\tfor(int i = 1;i<=k;i++)\n\tarray[i]=in.nextInt();\n\t\n\tint temp[]=array.clone();\n\t\n\tfor(int i = 1;i<=k;i++)\n\t\ttemp[i] = temp[i-1] + array[i]; \n\t\t\t\n\tlong fact[] = new long [1005];\n\t\n\t       fact[0] = 1;\n\t       for(int i =1;i<fact.length;i++)\n\t                 fact[i] = (fact[i-1]*i)%mod;\n\t\n\tlong ans = 1;\n\t\n\tfor(int i = 2;i<=k;i++){\n\t\tans *= findAns(temp[i - 1] + 1,array[i] - 1,fact);\n\t\tans %= mod;\n\t}\n\tSystem.out.print(ans);                 \n}\t       \t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[1005];\nint cnt[1005];\nconst int MOD = 1000000007;\nlong long c[1005][1005];\nlong long dp[1005];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  cnt[0] = a[0];\n  for (int i = 1; i < n; ++i) cnt[i] += cnt[i - 1] + a[i];\n  memset(c, 0, sizeof(c));\n  for (int i = 0; i < 1005; ++i)\n    for (int j = 0; j <= i; ++j)\n      if (j == 0)\n        c[i][j] = 1;\n      else\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\n  dp[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    dp[i] = 0;\n    for (int j = 1; j <= a[i]; ++j) {\n      dp[i] += dp[i - 1] * c[cnt[i] - j - 1][a[i] - j];\n      dp[i] %= MOD;\n    }\n  }\n  cout << dp[n - 1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\t/*\t/ \uff8c\uff8c\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u30e0\n\t\t/ )\\\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800  Y\n\t\t(\u2800\u2800| ( \u0361\u00b0 \u035c\u0296 \u0361\u00b0\uff09\u2800\u2312(\u2800 \u30ce\n\t\t(\u2800 \uff89\u2312 Y \u2312\u30fd-\u304f __\uff0f\n\t\t| _\u2800\uff61\u30ce| \u30ce\uff61 |/\n\t\t(\u2800\u30fc '_\u4eba`\u30fc \uff89\n\t\t\u2800|\\ \uffe3 _\u4eba'\u5f61\uff89\n\t\t\u2800 )\\\u2800\u2800 \uff61\u2800\u2800 /\n\t\t\u2800\u2800(\\\u2800 #\u2800 /\n\t\t\u2800/\u2800\u2800\u2800/\u1f63====================D-\n\t\t/\u2800\u2800\u2800/\u2800 \\ \\\u2800\u2800\\\n\t\t( (\u2800)\u2800\u2800\u2800\u2800 ) ).\u2800)\n\t\t(\u2800\u2800)\u2800\u2800\u2800\u2800\u2800( | /\n\t\t|\u2800 /\u2800\u2800\u2800\u2800\u2800\u2800 | /\n\t\t[_] \u2800\u2800\u2800\u2800\u2800[___]                     */\n\t// Main Code at the Bottom\n\timport java.util.*;\n\timport java.lang.*;\n\timport java.io.*;\n\timport java.math.BigInteger; \n\tpublic class Main {\n\t\t//Fast IO class\n\t    static class FastReader {\n\t        BufferedReader br; \n\t        StringTokenizer st; \n\t        public FastReader() {\n\t        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n\t        \tif(!env) {\n\t        \t\ttry {\n\t\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t        \t}\n\t        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n\t        } \n\t        String next() {\n\t            while (st == null || !st.hasMoreElements()) {\n\t                try {\n\t                    st = new StringTokenizer(br.readLine()); \n\t                } \n\t                catch (IOException  e) {\n\t                    e.printStackTrace(); \n\t                } \n\t            } \n\t            return st.nextToken(); \n\t        } \n\t        int nextInt() {\n\t            return Integer.parseInt(next()); \n\t        } \n\t        long nextLong() {\n\t            return Long.parseLong(next()); \n\t        } \n\t        double nextDouble() {\n\t            return Double.parseDouble(next()); \n\t        } \n\t        String nextLine() {\n\t            String str = \"\"; \n\t            try {\n\t                str = br.readLine(); \n\t            } \n\t            catch (IOException e) {\n\t                e.printStackTrace(); \n\t            } \n\t            return str; \n\t        } \n\t    }     \n\t    static long MOD=1000000000+7;\n\t    //Euclidean Algorithm\n\t    static long gcd(long A,long B){\n\t    \treturn (B==0)?A:gcd(B,A%B);\n\t    }\n\t    //Modular Exponentiation\n\t    static long fastExpo(long x,long n){\n\t        if(n==0) return 1;\n\t        if((n&1)==0) return fastExpo((x*x)%MOD,n/2)%MOD;\n\t        return ((x%MOD)*fastExpo((x*x)%MOD,(n-1)/2))%MOD;\n\t    }\n\t    //Modular Inverse\n\t    static long inverse(long x) {\n\t    \treturn fastExpo(x,MOD-2);\n\t    }\n\t    //Prime Number Algorithm\n\t    static boolean isPrime(long n){\n\t        if(n<=1) return false;\n\t        if(n<=3) return true;\n\t        if(n%2==0 || n%3==0) return false;\n\t        for(int i=5;i*i<=n;i+=6) if(n%i==0 || n%(i+2)==0) return false;\n\t        return true;\n\t    }\n\t    //Reverse an array\n\t    static void reverse(int arr[],int l,int r){\n\t    \twhile(l<r) {\n\t    \t\tint tmp=arr[l];\n\t    \t\tarr[l++]=arr[r];\n\t    \t\tarr[r--]=tmp;\n\t    \t}\n\t    }\n\t    //Print array\n\t    static void print1d(int arr[]) {\n\t    \tout.println(Arrays.toString(arr));\n\t    }\n\t    static void print2d(long arr[][]) {\n\t    \tfor(long a[]: arr) out.println(Arrays.toString(a));\n\t    }\n\t    // Pair\n\t    static class pair{\n\t    \tint x,y;\n\t    \tpair(int a,int b){\n\t    \t\tthis.x=a;\n\t    \t\tthis.y=b;\n\t    \t}\n\t    \tpublic boolean equals(Object obj) {\n\t    \t\tif(obj == null || obj.getClass()!= this.getClass()) return false;\n\t            pair p = (pair) obj;\n\t            return (this.x==p.x && this.y==p.y);\n\t        }\n\t    \tpublic int hashCode() {\n\t            return Objects.hash(x,y);\n\t        }\n\t    }\n\t    static FastReader sc=new FastReader();\n\t    static PrintWriter out=new PrintWriter(System.out);  \n\t    //Main function(The main code starts from here\n\t    static int N=1000;\n\t    static long fact[]=new long[N+1];\n\t    static long C(int n,int r) {\n\t    \tlong num=fact[n];\n\t    \tlong denom=((fact[r]%MOD)*(fact[n-r]%MOD))%MOD;\n\t    \treturn ((num%MOD)*(inverse(denom)%MOD))%MOD;\n\t    }\n\t    public static void main (String[] args) throws java.lang.Exception {\n\t    \tint test;\n\t    \ttest=1;\n\t    \t//test=sc.nextInt();\n\t    \twhile(test-->0){\n\t    \t\tfact[0]=1;\n\t    \t\tfor(int i=1;i<=N;i++) fact[i]=(i*fact[i-1])%MOD;\n\t    \t\tint n=sc.nextInt(),a[]=new int[n];\n\t    \t\tfor(int i=0;i<n;i++) a[i]=sc.nextInt();\n\t    \t\tint sum=0;\n\t    \t\tlong ans=1;\n\t    \t\tfor(int i=0;i<n;i++) {\n\t    \t\t\tans=((ans%MOD)*(C(sum+a[i]-1,a[i]-1)%MOD))%MOD;\n\t    \t\t\tsum+=a[i];\n\t    \t\t}\n\t    \t\tout.println(ans);\n\t    \t}\n\t        out.flush();\n\t        out.close();\n\t    }\n\t}"
        },
        {
            "language": 3,
            "solution": "#not my solution saw the editorial ?>?\ndef color(arr):\n    s=0\n    ans=1\n    for i in arr:\n        temp=1\n        s+=i\n        if s==i:\n            continue\n        for placement in range(1,i):\n            temp=(temp*(s-placement))//placement\n        ans*=temp%(10**9+7)\n    return ans%(10**9+7)\n\nblanck=[]\nfor i in range(int(input())):\n    blanck.append(int(input()))\n\nprint(color(blanck))"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A_309 {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint[][] com = new int[1001][1001];\n\n\tvoid run() {\n\t\tint k = sc.nextInt();\n\t\tint[] c = sc.nextIntArray(k);\n\n\t\tpascal();\n\t\tlong res = 1;\n\t\tint total = c[0];\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\tres = (res * com[total + c[i] - 1][c[i] - 1]) % MOD;\n\t\t\ttotal += c[i];\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tvoid pascal() {\n\t\tcom[0][0] = 1;\n\t\tfor (int i = 1; i <= 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (j == 0 || j == i)\n\t\t\t\t\tcom[i][j] = 1;\n\t\t\t\telse\n\t\t\t\t\tcom[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A_309().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n    final int MOD = (int) 1e9 + 7;\n    final int MAX = 1201;\n    long[] f;\n\n    long calc(int n, int k) {\n        return f[n] * inverse(f[k] * f[n - k]) % MOD;\n    }\n\n    long inverse(long a) {\n        return pow(a % MOD, MOD - 2);\n    }\n\n    long pow(long a, long n) {\n        if (n == 0) return 1L;\n        long res = pow(a * a % MOD, n / 2) % MOD;\n        if (n % 2 == 0) return res;\n        return res * a % MOD;\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        f = new long[MAX];\n        f[0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            f[i] = i * f[i - 1] % MOD;\n        }\n        int n = in.nextInt();\n        int total = 0;\n        long res = 1;\n        for (int i = 0; i < n; i++) {\n            int current = in.nextInt();\n            total += current;\n            res = (res * calc(total - 1, current - 1)) % MOD;\n        }\n        out.println(res);\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n\n}\n"
        },
        {
            "language": 1,
            "solution": "from operator import mul\nfrom fractions import Fraction\n\ndef nCk(n,k):\n  return int( reduce(mul, (Fraction(n-i, i+1) for i in range(k)), 1) )\nn = int(raw_input())\ns = 0\na = []\nfor i in xrange(n):\n    b = int(raw_input())\n    a.append(b)\n    s+=b\ns-=1\nans = 1\nfor i in xrange(n):\n    ans*=(nCk(s, a[n-1-i]-1)%1000000007)\n    s-=a[n-1-i]\nprint ans%1000000007"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    static final int mod = (int)1e9 + 7;\n    static int k, n, afterBalls[], c[];\n    static long[][] memo;\n    \n    static long dp(int color, int pos)\n    {\n        if(color == k)\n            return pos == n ? 1 : 0;\n        if(pos == n)\n            return 0;\n        if(memo[color][pos] != -1)\n            return memo[color][pos];\n        \n        long place = 0, skip = dp(color, pos + 1);\n        if(n - pos - 1 <= afterBalls[color])\n            place = (dp(color + 1, pos + 1) * nCr(pos - (n - afterBalls[color] - c[color]), c[color] - 1).mod(BigInteger.valueOf(mod)).intValue())%mod;\n        return memo[color][pos] = (place + skip)%mod;\n    }\n    \n\n    static BigInteger m[][];      //may need BigInteger\n    \n    static BigInteger nCr(int n, int k)\n    {\n        if(k == 0)\n            return BigInteger.ONE;\n        if(m[n][k] != null)\n            return m[n][k];\n        if(n - k < k)\n            return m[n][k] = nCr(n, n - k);\n        \n        return m[n][k] = nCr(n - 1, k - 1).multiply(BigInteger.valueOf(n)).divide(BigInteger.valueOf(k));\n    }\n    \n    public static void main(String[] args) throws IOException \n    {\n        \n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        k = sc.nextInt();\n        afterBalls = new int[k]; c = new int[k];\n        for(int i = 0; i < k; i++)\n            n += c[i] = sc.nextInt();\n        afterBalls[0] = n - c[0];\n        for(int i = 1; i < k; i++)\n            afterBalls[i] = afterBalls[i-1] - c[i];\n        \n        memo = new long[k][n]; m = new BigInteger[n + 1][n + 1];\n        for(int i = 0; i < k; i++)\n            Arrays.fill(memo[i], -1);\n\n        System.out.println(dp(0, 0));\n        out.flush();\n    }\n\n    \n    static class Scanner \n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException \n        {\n            while (st == null || !st.hasMoreTokens()) \n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n        \n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n        \n        public double nextDouble() throws IOException\n        {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if(x.charAt(0) == '-')\n            {\n                neg = true;\n                start++;\n            }\n            for(int i = start; i < x.length(); i++)\n                if(x.charAt(i) == '.')\n                {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                }\n                else\n                {\n                    sb.append(x.charAt(i));\n                    if(dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg?-1:1);\n        }\n        \n        public boolean ready() throws IOException {return br.ready();}\n\n        int countTokens() throws IOException\n        {\n            st = new StringTokenizer(br.readLine());\n            return st.countTokens();\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "MOD = 10**9 + 7\n\ndef count_arrangements(colors):\n    \n    running_sum = 0\n    result = 1\n    for i in xrange(len(colors)):\n        result = (result * choose_mod(fact, inv_fact, colors[i] + running_sum - 1, running_sum, MOD)) % MOD\n        running_sum += colors[i]\n    return result\n\n\ndef generate_factorial(n, p):\n    \n    fact = [1]\n    inv_fact = [1]\n\n    for i in xrange(1, n + 1):\n        fact.append((fact[-1]*i) % p)\n        inv_fact.append(extended_euclidean(fact[-1], p)[0] % p)\n    \n    return fact, inv_fact\n    \ndef choose_mod(fact, inv_fact, n, k, p):\n\n    if n < k: return 0\n    return (((fact[n]*inv_fact[n - k]) % p)*inv_fact[k]) % p\n    \ndef extended_euclidean(a, b):\n\n    if a == 0:\n        return (0, 1, b)\n\n    a = abs(a)\n    b = abs(b)\n    a, b = min(a, b), max(a, b)\n    x, y, gcd = extended_euclidean(b % a, a)\n    x, y = y - (b/a)*x, x\n    return (x, y, gcd)\n\nfact, inv_fact = generate_factorial(2005, MOD)\nk = input()\narr = []\nfor i in xrange(k):\n    arr.append(input())\n\nprint count_arrangements(arr)"
        },
        {
            "language": 4,
            "solution": "//package kyoyaandcoloredballs;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class kyoyaandcoloredballs {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(fin.readLine());\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tnums[i] = Integer.parseInt(fin.readLine());\n\t\t}\n\t\tlong mod = 1000000007;\n\t\tlong ans = 1;\n\t\tint curBalls = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint next = nums[i];\n\t\t\tif(next != 1 && i != 0) {\n\t\t\t\tlong[][] pfx = new long[next  - 1][curBalls + 1];\n\t\t\t\tfor(int j = 0; j <= curBalls; j++) {\n\t\t\t\t\tpfx[0][j] = curBalls - j + 1;\n\t\t\t\t\t////System.out.print(pfx[0][j] + \" \");\n\t\t\t\t}\n\t\t\t\t////System.out.println();\n\t\t\t\tfor(int j = 1; j < next - 1; j++) {\n\t\t\t\t\tfor(int k = curBalls; k >= 0; k --) {\n\t\t\t\t\t\tif(k == curBalls) {\n\t\t\t\t\t\t\tpfx[j][k] = pfx[j - 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpfx[j][k] = pfx[j - 1][k] + pfx[j][k + 1];\n\t\t\t\t\t\t\tpfx[j][k] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t////System.out.print(pfx[j][k] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\t////System.out.println();\n\t\t\t\t}\n//\t\t\t\tfor(long[] j : pfx) {\n//\t\t\t\t\tfor(long k : j) {\n//\t\t\t\t\t\t//System.out.print(k + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\t//System.out.println();\n//\t\t\t\t}\n\t\t\t\tif(next > 1) {\n\t\t\t\t\t\n\t\t\t\t\tans *= pfx[next - 2][0];\n\t\t\t\t\tans %= mod;\n\t\t\t\t\t//System.out.println(\"add\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tans %= mod;\n\t\t\tcurBalls += next;\n\t\t\t//System.out.println(\"CUR BALLS: \" + curBalls);\n\t\t\t//System.out.println(\"ANS: \" + ans);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\n\npublic class Main {\n\n\tstatic IO io;\n\tstatic int n;\n\tstatic long mod = 1000000007L;\n\n\tstatic long ncr ( int n , int r ){\n\t\t\n\t\tlong num = 1;\n\t\tlong den = 1;\n\t\t\n\t\tfor( int i = n ; i >= n -r+1 ; --i )\n\t\t\tnum = (num*i)%mod;\n\t\t\n\t\tfor( int i = 1 ; i <= r ; ++i )\n\t\t\tden = (den*i)%mod;\n\t\t\n\t\treturn  (num*pow(den,mod-2))%mod;\n\t}\n\tpublic static void main(String args[]) throws Exception{\n\t\n\t\tio = new IO();\n\t\tio.init();\n\t\t\n\t\t//----------------------------------------\n\t\t\n\t\t\n\t\t\n\t\tint k  = io.nextInt();\n\t\tint n = 0 ;\n\t\t\n\t\tint array[] = new int[k];\n\t\t\n\t\tfor( int i  = 0 ; i <  k ; ++i ){\n\t\t\tarray[i] = io.nextInt();\n\t\t\tn += array[i];\n\t\t}\n\t\t\n\t\t\n\t\tlong ans = 1 ;\n\t\tint sum =  n ;\n\t\t\n\t\tfor( int i = k-1 ; i >= 0 ; --i ){\n\t\t\t\n\t\t\tans =  ( ans * ncr(  sum-1 ,  array[i]-1 ))%mod;\n\t\t\tsum -= array[i];\n\t\t\t\n\t\t}\n\t\t\n\t\tio.println( ans );\n\t\n\t\t//----------------------------------------\n\t\tio.destroy();\n\t}\n\t\n\tstatic long gcd(long a, long b){\n\t\tif( a == 0 ) return b;\n\t\tif( b == 0 ) return a;\n\t\tif( a > b) return gcd(a%b,b);\n\t\telse return gcd(a,b%a);\n\t}\n\t\n\tstatic long pow( long base , long exp){\n\t\t\n\t\tif( exp == 0 ) return 1;\n\t\t\n\t\tlong temp = pow( base,exp/2);\n\t\ttemp =(temp*temp)%mod;\n\t\t\n\t\tif( exp%2 == 0 ) \n\t\t\treturn temp;\n\t\telse\n\t\t\treturn (temp*base)%mod;\n\t}\n\t\n\tstatic class IO{\n\t\t\n\t\t\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\t\tPrintWriter writer;\n\n\t\tpublic void init() {\n\t\t\ttry {\n\t\t\t\treader = new BufferedReader(new InputStreamReader(System.in),8*1024);\n\t\t\t\twriter = new PrintWriter(System.out);\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.exit(261);\n\t\t\t}\n\t\t}\n\n\t\tvoid destroy() {\n\t\t\twriter.close();\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\tvoid print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tvoid println(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn reader.readLine();\n\t\t}\n\n\t\tString nextToken() throws IOException {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)2e9;\nconst long long INFL = (long long)9e18;\nconst int MAXINT = ((~0) ^ (1 << 31));\nconst long long MAXLL = ((~0) ^ ((long long)1 << 63));\ntemplate <class T>\ninline T pow2(T a) {\n  return a * a;\n}\ntemplate <class T>\ninline bool mineq(T& a, T b) {\n  return (a > b) ? (a = b, true) : false;\n}\ntemplate <class T>\ninline bool maxeq(T& a, T b) {\n  return (a < b) ? (a = b, true) : false;\n}\nconst int maxn = (int)1111;\n;\nconst int MOD = (int)1e9 + 7;\n;\nlong long fact[maxn], rfact[maxn];\nlong long powmod(long long a, long long b) {\n  if (!b) return 1;\n  long long t = powmod(a, b / 2);\n  t = (t * t) % MOD;\n  if (b & 1) t = (t * a) % MOD;\n  return t;\n}\nlong long cmb(long long n, long long k) {\n  if (k > n) return 0;\n  return ((fact[n] * rfact[n - k]) % MOD * rfact[k]) % MOD;\n}\nlong long k, cnt[maxn], n = 0;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  fact[0] = 1;\n  for (int i = 1; i < (int)(maxn); i++) fact[i] = (fact[i - 1] * i) % MOD;\n  for (int i = 0; i < (int)(maxn); i++) rfact[i] = powmod(fact[i], MOD - 2);\n  cin >> k;\n  for (int i = 0; i < (int)(k); i++) {\n    cin >> cnt[i];\n    n += cnt[i];\n  }\n  long long ans = 1;\n  for (int i = k - 1; i >= (int)(0); i--) {\n    ans = (ans * cmb(n - 1, cnt[i] - 1)) % MOD;\n    n -= cnt[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n/**\n * Created by yujiahao on 4/20/16.\n */\npublic class cf_309_c {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final static int MOD = 1000000007;\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int[][] bi = binomialCoe(1000);\n\n        int[] c = new int[n];\n        for (int i=0; i<n; i++)\n            c[i] = in.nextInt();\n\n        int sumBall = 0;\n        long ans = 1;\n\n        for (int i=0; i<n; i++){\n            sumBall += c[i];\n            ans *= bi[sumBall-1][c[i]-1];\n            ans %= MOD;\n        }\n\n        out.print(ans);\n\n\n    }\n\n    public int[][] binomialCoe(int n){\n        int[][] bi = new int[n+1][n+1];   // n chooses i\n        bi[0][0] = 1;\n        bi[1][0] = 1;\n        bi[1][1] = 1;\n\n        for (int i=2; i<n+1; i++){\n            bi[i][0] = 1;\n            bi[i][i] = 1;\n            for (int j= 1; j<i; j++){\n                bi[i][j] = (bi[i-1][j-1] + bi[i-1][j]) % MOD;\n            }\n        }\n        return bi;\n    }\n\n\n    public void run() {\n        try {\n            in = new FastScanner();\n            out = new PrintWriter(System.out);\n            solve();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class FastScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public BigInteger nextBigInteger() { return new BigInteger(next());}\n\n    }\n\n    public static void main(String[] arg) {\n        new cf_309_c().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int fact[1000001];\nlong long int a[1001], ans[1001];\nlong long int ex(long long int a, long long int b, long long int m) {\n  if (b == 0) return 1;\n  if (b % 2 == 1)\n    return (a * ex((a * a) % m, b >> 1, m)) % m;\n  else\n    return ex((a * a) % m, b >> 1, m) % m;\n}\nlong long int inline inv(long long int x) {\n  return ex(x, 1000000007 - 2, 1000000007);\n}\nlong long int inline comb(long long int a, long long int b) {\n  return ((fact[a] * inv(fact[b]) % 1000000007) * inv(fact[a - b])) %\n         1000000007;\n}\nint main() {\n  long long int k;\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  clock_t tStart = clock();\n  fact[0] = 1;\n  for (int i = int(1); i <= int(1000000); i++)\n    fact[i] = (fact[i - 1] * i) % 1000000007;\n  cin >> k;\n  for (int i = int(1); i <= int(k); i++) cin >> a[i];\n  ans[1] = 1;\n  long long int R = 0;\n  for (int i = int(2); i <= int(k); i++) {\n    R += a[i - 1];\n    long long int b = a[i];\n    ans[i] = ((ans[i - 1] * (comb(b - 1 + R, R))) % 1000000007);\n  }\n  cout << ans[k] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def fact(x):\n    res = 1\n    while x > 0:\n        res *= x\n        x -= 1\n    return res\n\nk = int(input())\nlst=[]\nfor i in range(0, k):\n    x = int(input())\n    lst.append(x)\n\nl = lst[0]\nans = 1\nfor i in range(1, k):\n    l += lst[i] - 1\n    ans *= fact(l) // (fact(l - lst[i] + 1) * fact(lst[i] - 1))\n    l += 1\nprint(ans % (1000 * 1000 * 1000 + 7))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author AlexFetisov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        static int MOD = (int) 1e9 + 7;\n        private int k;\n        private int[] am;\n        int[][] C = IntegerUtils.getC(2000, MOD);\n        int[][] dp;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            k = in.nextInt();\n            am = new int[k];\n            for (int i = 0; i < k; ++i) {\n                am[i] = in.nextInt();\n            }\n            dp = new int[1005][1005];\n            ArrayUtils.fill(dp, -1);\n\n//        for (int i = 0; i < 10; ++i) {\n//            for (int j = 0; j < 10; ++j) {\n//                out.print(rec(i, j) + \" \");\n//            }\n//            out.println();\n//        }\n\n            long res = 1;\n            int curSpots = am[0];\n\n            for (int i = 1; i < k; ++i) {\n                int needToPlace = am[i] - 1;\n                ++curSpots;\n                res *= rec(curSpots, needToPlace);\n                res %= MOD;\n                curSpots += am[i] - 1;\n            }\n            out.println(res);\n        }\n\n        private long rec(int curSpots, int needToPlace) {\n            if (curSpots == 0) {\n                return 1;\n            }\n            if (curSpots + needToPlace == 0) return 0;\n\n            return C[curSpots + needToPlace - 1][curSpots - 1];\n//        if (curSpots == 0) {\n//            if (needToPlace == 0) {\n//                return 1;\n//            }\n//            return 0;\n//        }\n//        if (needToPlace == 0) {\n//            return 1;\n//        }\n//        if (dp[curSpots][needToPlace] != -1) {\n//            return dp[curSpots][needToPlace];\n//        }\n//        int res = 0;\n//        for (int c = 0; c <= needToPlace; ++c) {\n//            res += rec(curSpots-1, needToPlace - c);\n//            if (res >= MOD) res -= MOD;\n//        }\n//        return res;\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static int[][] getC(int N, int MOD) {\n            int[][] C = new int[N][];\n            for (int i = 0; i < N; ++i) {\n                C[i] = new int[i + 1];\n                for (int j = 0; j <= i; ++j) {\n                    if (j == 0 || j == i) {\n                        C[i][j] = 1;\n                        if (C[i][j] >= MOD) C[i][j] -= MOD;\n                    } else {\n                        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);\n                        if (C[i][j] >= MOD) C[i][j] -= MOD;\n                    }\n                }\n            }\n            return C;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(int[][] f, int value) {\n            for (int i = 0; i < f.length; ++i) {\n                Arrays.fill(f[i], value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String nextString() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static final long MOD = 1000000007;\n\tstatic int[] arr;\n\tstatic int n;\n\tstatic int[] sum;\n\tstatic long [] fact;\n\tstatic long idiot[][] = new long[1001][1001];\n\tstatic\n\t{\n\t\t//initFact();\n\t\tinitIdiot();\n\t\t//print(fact);\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tMyScanner input = new MyScanner();\n\t\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\n\t\tn = input.nextInt();\n\t\tarr = new int[n];\n\t\tsum = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i] = input.nextInt();\n\t\t}\n\t\tsum[0] = arr[0];\n\t\tfor(int i = 1; i < n; i++)\n\t\t\tsum[i] = sum[i-1] + arr[i];\n\t\t\n\t\tlong ret;\n\t\tret = 1;\n\t\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tret = (ret * idiot [sum[i-1]+arr[i]-1][arr[i]-1] )% MOD;\n\t\t\t//System.out.println(\"ret \"+ ret);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(ret);\n\t\t\n\t\t\n\t}\n\t\n\tprivate static void initIdiot() \n\t{\n\t\tidiot[0][0] = 1;\n\t\t\n\t\tfor(int i = 1; i < 1001; i++)\n\t\t{\n\t\t\tidiot[i][0] = 1;\n\t\t\tfor(int j =1; j < 1001; j++)\n\t\t\t{\n\t\t\t\tidiot[i][j] = (idiot[i-1][j-1] + idiot[i-1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate static class MyScanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner(String s) \n\t\t{\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\n\t\tpublic MyScanner() \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic String next() \n\t\t{\n\t\t\tif (st == null || !st.hasMoreElements()) \n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tString line = br.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\tthrow new UnknownError();\n\t\t\t\t\t}\n\t\t\t\t\twhile (line.trim().equals(\"\")) {\n\t\t\t\t\t\tline = br.readLine();\n\t\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\t\tthrow new UnknownError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new UnknownError();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\tString line = br.readLine();\n\t\t\t\tif (line == null) {\n\t\t\t\t\tthrow new UnknownError();\n\t\t\t\t}\n\t\t\t\treturn line;\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new UnknownError();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k, c[1000 + 10], sum;\nlong long a[1010][1000 + 10];\nlong long ans[1000 + 10];\nconst long long mod = 1000000007;\nvoid calc() {\n  for (int i = 0; i < 1000 + 10; i++) a[0][i] = 1;\n  for (int i = 1; i < 1010; i++) {\n    for (int j = i; j < 1000 + 10; j++) {\n      a[i][j] = a[i - 1][j - 1] + a[i][j - 1];\n      a[i][j] %= mod;\n    }\n  }\n}\nint main() {\n  calc();\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> c[i];\n  }\n  ans[1] = 1;\n  sum = c[1];\n  for (int i = 2; i <= k; i++) {\n    ans[i] = ans[i - 1] * a[sum][(sum + c[i] - 1)];\n    ans[i] %= mod;\n    sum += c[i];\n  }\n  cout << ans[k] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nint color[1003], total;\nlong long bc[1005][1005], res = 1LL;\nint main() {\n  ios_base ::sync_with_stdio(0);\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> color[i];\n  bc[0][0] = 1;\n  for (int i = 1; i <= 1004; i++) {\n    bc[i][0] = bc[i][i] = 1;\n    for (int j = 1; j < i; j++)\n      bc[i][j] = (bc[i - 1][j] + bc[i - 1][j - 1]) % mod;\n  }\n  for (int i = 1; i <= k; i++) {\n    res = (res * 1LL * bc[total + color[i] - 1][color[i] - 1]) % mod;\n    total += color[i];\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int ModD = 1e9 + 7;\nlong long n, a[1005], f[1005], c[1005][1005], d[1005][1005];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= 1000; ++i) d[0][i] = 1, c[0][i] = 1;\n  for (int i = 1; i <= 1000; ++i)\n    for (int j = 1; j <= 1000; ++j) {\n      if (j == 1)\n        c[i][j] = 1;\n      else\n        c[i][j] = d[i][j - 1];\n      d[i][j] = (d[i - 1][j] + c[i][j]) % ModD;\n    }\n  int so = a[1];\n  f[1] = 1;\n  for (int i = 2; i <= 1000; ++i) {\n    f[i] = (f[i - 1] * c[a[i] - 1][so + 1]) % ModD;\n    so += a[i];\n  }\n  cout << f[n];\n  fclose(stdin);\n  fclose(stdout);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int INF = (1LL << 31) - 1;\nconst long long LINF = LLONG_MAX;\nconst int maxn = 1e3 + 1;\nlong long C[maxn][maxn], a[maxn], n, ans = 1;\nlong long c(int r, int n) {\n  if (r == 0 || r == n) return 1ll;\n  if (C[r][n]) return C[r][n];\n  C[r][n] = c(r - 1, n - 1);\n  C[r][n] %= mod;\n  C[r][n] += c(r, n - 1);\n  C[r][n] %= mod;\n  return C[r][n];\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n;\n  int s = 0, t = 0;\n  for (int i = 0; i < n; i++) cin >> a[i], t += a[i];\n  for (int i = n - 1; i >= 0; i--) {\n    ans *= c(a[i] - 1, t - s - 1) % mod;\n    ans %= mod;\n    s += a[i];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long cnk[1010][1010], n, c[1010];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> c[i];\n  cnk[0][0] = 1;\n  for (int i = 1; i < 1010; i++) {\n    cnk[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % 1000000007;\n  }\n  long long res = 1, sum = c[1];\n  for (int i = 2; i <= n; i++) {\n    res = (res * cnk[sum + c[i] - 1][c[i] - 1]) % 1000000007;\n    sum += c[i];\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n\npublic class main {\n\t\n\tpublic static long c[][];\n\tpublic static int k, kk, sum = 0;\n\tpublic static int mod = 1000000007;\n\tpublic static long res = 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner Reader = new Scanner(System.in);\n\t\tk = Reader.nextInt();\n\t\t\n\t\tc = new long[1111][1111];\n\t\tfor (int i = 0; i <= 1010; i++) c[i][0] = 1;\n\t\tfor (int i = 1; i <= 1010; i++)\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t\t\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tkk = Reader.nextInt();\n\t\t\tres = (res * c[sum + kk - 1][kk - 1]) % mod;\n\t\t\tsum += kk;\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\n# 554C_colored.py - Codeforces.com 554C Colored quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line of input will have one integer k (1<=k<=1000) the number\nof colors.\n\nThen, k lines will follow. The i-th line will contain ci, the number of\nballs of the i-th color (1<=ci<=1000).\n\nThe total number of balls doesn't exceed 1000.\nOutput\n\nA single integer, the number of ways that Kyoya can draw the balls from\nthe bag as described in the statement, modulo 1_000_000_007.\n\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\n\n\n###############################################################################\n# Colored Class\n###############################################################################\n\n\nclass Colored:\n    \"\"\" Colored representation \"\"\"\n\n    MOD = 1000000007\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        self.list = args\n\n    def fact(self, n):\n        result = 1\n        for i in range(n):\n            result *= i + 1\n        return result\n\n    def binom(self, n, k):\n        return (self.fact(n) // (self.fact(n - k) * self.fact(k)))\n\n    def f(self, i):\n        if i == 0:\n            return 1\n        bin = self.binom(sum(self.list[:i+1]) - 1, self.list[i] - 1)\n\n        return (bin % self.MOD) * self.f(i - 1)\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n        result = self.f(len(self.list) - 1) % self.MOD\n\n        return str(result)\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs\n    num = int(uinput())\n    nums = [int(uinput()) for i in range(num)]\n\n    # Decoding inputs\n    inputs = nums\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Colored(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n        self.assertEqual(calculate(\"3\\n2\\n2\\n1\"), \"3\")\n        self.assertEqual(calculate(\"4\\n1\\n2\\n3\\n4\"), \"1680\")\n        self.assertEqual(calculate(\n            \"10\\n100\\n100\\n100\\n100\\n100\\n100\\n100\" +\n            \"\\n100\\n100\\n100\"), \"12520708\")\n        s = \"1000\"\n        for n in range(1000):\n            s += \"\\n1\"\n        self.assertEqual(calculate(s), \"1\")\n\n    def test_get_inputs(self):\n        \"\"\" Input string decoding testing \"\"\"\n        self.assertEqual(get_inputs(\"2\\n1\\n3\"), [1, 3])\n\n    def test_Colored_class__basic_functions(self):\n        \"\"\" Colored class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Colored([2, 1])\n        self.assertEqual(d.list, [2, 1])\n\n        # Factorial using modulo\n        self.assertEqual(d.fact(4), 24)\n\n        # Binominal\n        self.assertEqual(d.binom(2, 1), 2)\n\n        # Dynamic programming function, solution for i colors\n        self.assertEqual(d.f(0), 1)\n        self.assertEqual(d.f(1), 1)\n\n\nif __name__ == \"__main__\":\n\n    # Avoid recursion limitaions\n    sys.setrecursionlimit(10000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long M = 1000000007;\nlong long fac(long long n) {\n  if (n == 0)\n    return 1;\n  else\n    return ((n % M) * (fac(n - 1) % M)) % M;\n}\nlong long pro(long long x, long long y) {\n  if (y == 0)\n    return 1;\n  else if (y % 2 == 0)\n    return pro((x * x) % M, y / 2);\n  else\n    return ((x % M) * (pro((x * x) % M, (y - 1) / 2)) % M) % M;\n}\nsigned main() {\n  long long k, z = 0, ans = 1;\n  cin >> k;\n  while (k--) {\n    long long x, a, b;\n    cin >> x;\n    if (z == 0)\n      z += x;\n    else {\n      x--;\n      a = pro(fac(x), M - 2);\n      b = pro(fac(z), M - 2);\n      long long p = ((a % M) * (b % M)) % M;\n      long long s = ((fac(z + x) % M) * (p % M)) % M;\n      ans = ((ans % M) * (s % M)) % M;\n      z += x + 1;\n    }\n  }\n  cout << ans % M;\n}\n"
        },
        {
            "language": 1,
            "solution": "k = input()\nc = []\nfatt = []\ninv = []\nmod = 10**9 + 7\nfatt.append( 1 )\ninv.append( 1 )\nfor i in range(1, 1001):\n    fatt.append( (fatt[i-1] * i)%mod )\n    inv.append( pow(fatt[i], mod-2,mod) )\nfor i in range(k):\n    tmp = input()\n    c.append( tmp )\n\nprec = 1\nsomma = c[ 0 ]\nfor i in range(2, k+1):\n    f = (((fatt[ somma + c[i-1] - 1] * inv[ c[i-1]-1 ] * inv[ somma ])%mod)*prec) % mod\n    prec = f\n    somma += c[i-1]\nprint str(prec)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MODNUM = 1000000007;\nint main() {\n  int totalColors;\n  cin >> totalColors;\n  vector<int> src(totalColors);\n  vector<int> sums(totalColors);\n  cin >> src[0];\n  sums[0] = src[0];\n  for (int i = 1; i < totalColors; ++i) {\n    cin >> src[i];\n    sums[i] = sums[i - 1] + src[i];\n  }\n  int MAXNK = 1500;\n  vector<int> empv(MAXNK, 0);\n  vector<vector<int> > C(MAXNK, empv);\n  for (int i = 0; i < MAXNK; ++i) C[i][0] = 1;\n  for (int i = 1; i < MAXNK; ++i) C[0][i] = 0;\n  for (int i = 1; i < MAXNK; ++i)\n    for (int j = 1; j < MAXNK; ++j) {\n      C[i][j] = ((long long)C[i - 1][j] + C[i - 1][j - 1]) % MODNUM;\n    }\n  vector<int> ans(totalColors, 1);\n  ans[0] = 1;\n  for (int i = 1; i < totalColors; ++i) {\n    ans[i] = ((long long)ans[i - 1] * C[sums[i - 1] + src[i] - 1][src[i] - 1]) %\n             MODNUM;\n  }\n  cout << ans[totalColors - 1] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class C {\n\n    private static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        s.nextLine();\n        int[] ka = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ka[i] = s.nextInt();\n            s.nextLine();\n        }\n\n\n        long result = 1;\n        long len = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int k = ka[i];\n\n            result *= cnnk(k - 1, len + 1);\n            result %= MOD;\n            len += k;\n        }\n\n        System.out.println(result);\n    }\n\n    private static long cnnk(long items, long pos) {\n        if (items == 0 || pos == 0) {\n            return 1;\n        }\n        return cnk(items, items + pos - 1);\n    }\n\n    private static long cnk(long items, long pos) {\n        long high = Math.max(items, pos);\n        long low = Math.min(items, pos);\n\n        long highr = 1;\n        long lowr = 1;\n        for (long i = 0; i < low; ++i) {\n            highr = (highr * high) % MOD;\n            lowr = (lowr * (i + 1)) % MOD;\n            --high;\n        }\n        long inv = pow(lowr, MOD - 2, MOD);\n        highr = (highr * inv) % MOD;\n        return highr;\n    }\n\n    private static long pow(long a, long p, long m) {\n        long result = 1;\n        while (p > 0) {\n            if (p % 2 == 1) {\n                result *= a;\n                result %= m;\n            }\n            a *= a;\n            a %= m;\n            p /= 2;\n        }\n        return result;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nlong long st[1005][1005];\nlong long zuhe(long long x, long long y) {\n  if (y == 0 || x == y)\n    return 1;\n  else\n    return (zuhe(x - 1, y) + zuhe(x - 1, y - 1)) % mod;\n}\nvoid play() {\n  for (int i = 1; i <= 1000; i++)\n    for (int j = 0; j <= i; j++) {\n      if (i == j)\n        st[i][j] = 1;\n      else if (j == 0)\n        st[i][j] = 1;\n      else {\n        st[i][j] = (st[i - 1][j] + st[i - 1][j - 1]) % mod;\n      }\n    }\n}\nint main() {\n  int t;\n  int ans[1005];\n  int sum[1005];\n  cin >> t;\n  play();\n  for (int i = 0; i < t; i++) cin >> ans[i];\n  sum[0] = ans[0];\n  for (int i = 1; i < t; i++) sum[i] = sum[i - 1] + ans[i];\n  long long answer = 1;\n  for (int i = t - 1; i >= 0; i--) {\n    if (ans[i] == 1) continue;\n    long long m = sum[i] - 1;\n    long long n = ans[i] - 1;\n    answer = (answer * st[m][n]) % mod;\n  }\n  cout << answer << endl;\n  ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxint = -1u >> 1;\nlong long mod = 1000000007LL;\nlong long comb[1024][1024];\nvoid get_comb() {\n  for (int i = 0; i < 1001; i++) comb[0][i] = 0LL;\n  for (int i = 0; i < 1001; i++) comb[i][0] = 1LL;\n  for (int i = 1; i < 1001; i++) {\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n      if (comb[i][j] >= mod) comb[i][j] -= mod;\n    }\n  }\n}\nint num[1024];\nint main() {\n  int n;\n  get_comb();\n  while (cin >> n) {\n    for (int i = 0; i < n; i++) {\n      cin >> num[i];\n    }\n    int sum = 0;\n    long long ans = 1LL;\n    for (int i = 0; i < n; i++) {\n      ans *= comb[num[i] - 1 + sum][num[i] - 1];\n      ans %= mod;\n      sum += num[i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool read(T &x) {\n  int c = getchar();\n  int sgn = 1;\n  while (~c && c < '0' || c > '9') {\n    if (c == '-') sgn = -1;\n    c = getchar();\n  }\n  for (x = 0; ~c && '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';\n  x *= sgn;\n  return ~c;\n}\nint X[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint Y[] = {-1, 0, +1, 1, 1, 0, -1, -1};\nlong long pas[1005][1005];\nint main() {\n  pas[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    pas[i][0] = pas[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      pas[i][j] = pas[i - 1][j] + pas[i - 1][j - 1];\n      pas[i][j] %= 1000000007;\n    }\n  }\n  int n;\n  int tot = 0;\n  long long ans = 1;\n  read(n);\n  for (int i = 0; i < n; i++) {\n    int a;\n    read(a);\n    a--;\n    ans = (ans * pas[tot + a][a]) % 1000000007;\n    a++;\n    tot += a;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t  public static void main(String[] args) {\n\t        InputStream inputStream = System.in;\n\t        OutputStream outputStream = System.out;\n\t        InputReader in = new InputReader(inputStream);\n\t            try (PrintWriter out = new PrintWriter(outputStream)) {\n\t            \tTaskC solver = new TaskC();\n\t                solver.solve(in, out);\n\t            }\n\t    }\n}\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputstream) {\n      reader = new BufferedReader(new InputStreamReader(inputstream));\n      tokenizer = null;\n    }\n    \n    public String nextLine(){\n    \tString fullLine=null;\n    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n              fullLine=reader.readLine();\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n            return fullLine;\n          }\n          return fullLine;\n    }\n\tpublic String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\tpublic long nextLong() {\n\t      return Long.parseLong(next());\n\t    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\nclass TaskC {\n\tfinal int mod=1000000007;\n\tlong dp[][]=new long[2000][2000];\n\tvoid solve(InputReader in,PrintWriter out){\n\t\tint n=in.nextInt();\n\t\tlong ans=1;\n\t\tlong sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong next=in.nextLong();\n\t\t\tans=(ans%mod*nCr((int)(sum+next-1),(int)Math.min(sum,next-1))%mod)%mod;\n\t\t\tsum+=next;\n\t\t\t//System.out.println(ans);\n\t\t}\n\t\tout.println(ans);\n\t}\n\tlong nCr(int n, int r)\n\t{\n\t    if(n==r) return dp[n][r] = 1;\n\t    if(r==0) return dp[n][r] = 1;\n\t    if(r==1) return dp[n][r] = n;\n\t    if(dp[n][r]!=0) return dp[n][r];\n\t    return dp[n][r] = (nCr(n-1,r) + nCr(n-1,r-1))%mod;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport collections\nfrom pprint import pprint\nmod = 1000000007\n\n\ndef vector(size, val=0):\n    vec = [val for i in range(size)]\n    return vec\n\n\ndef matrix(rowNum, colNum, val=0):\n    mat = []\n    for i in range(rowNum):\n        collumn = [val for j in range(colNum)]\n        mat.append(collumn)\n    return mat\n\n\ndef pascle(lim):\n    p = matrix(lim, lim)\n    for i in range(lim):\n        p[i][i] = p[i][0] = 1\n    for i in range(1, lim):\n        for j in range(1, lim):\n            p[i][j] = (p[i - 1][j - 1] + p[i - 1][j]) % mod\n    return p\n\n\np = pascle(1005)\nn = int(input())\na = [0] + [int(input()) for i in range(n)]\ns = 0\nans = 1\nfor i in range(1, n + 1):\n    ans = (ans * p[s + a[i] - 1][a[i] - 1]) % mod\n    s += a[i]\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException{\n        //BufferedReader f = new BufferedReader(new FileReader(\"uva.in\"));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        long[][] iChooseJ = new long[1001][1001];\n        iChooseJ[0][0] = 1;\n        for(int i = 1; i <= 1000; i++) {\n            iChooseJ[i][0] = 1;\n            for(int j = 1; j <= 1000; j++) {\n                iChooseJ[i][j] = (iChooseJ[i-1][j]+iChooseJ[i-1][j-1])%1000000007;\n            }\n        }\n        int k = Integer.parseInt(f.readLine());\n        long ways = 1;\n        int sum = 0;\n        for(int i = 0; i < k; i++) {\n            int ci = Integer.parseInt(f.readLine());\n            ways = (ways*iChooseJ[sum+ci-1][ci-1])%1000000007;\n            sum += ci;\n        }\n        out.println(ways);\n        f.close();\n        out.close();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class Main  {\n\tstatic PrintWriter out=new PrintWriter(new BufferedOutputStream(System.out));\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    \n    static int N=1234;\n    static int mod=1000000007;\n    static long[] f=new long[N];\n    static long[][] c=new long[N][N];\n    static int[] ball=new int[N];\n    \n    static void prepare() {\n    \tfor(int i=0;i<N;i++) {\n    \t\tfor(int j=0;j<=i;j++) {\n    \t\t\tc[i][j]=(j==0) ?1:(c[i-1][j-1]+c[i-1][j])%mod;\n    \t\t}\n    \t}\n    }\n    \n    public static void main(String args[]) throws Exception {\n    \tprepare();\n    \tint k=Integer.parseInt(br.readLine());\n    \tfor(int i=1;i<=k;i++) {\n    \t\tball[i]=Integer.parseInt(br.readLine());\n    \t}\n    \tint total=ball[1];\n    \tf[1]=1;\n    \tfor(int i=2;i<=k;i++) {\n    \t\tf[i]=(f[i-1]*c[total+ball[i]-1][ball[i]-1])%mod;\n    \t\ttotal+=ball[i];\n    \t}\n    \tout.println(f[k]);\n    \tout.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7, Base = 998244353;\nconst long long N = 1e3 + 7;\nconst long long INF = 1LL * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 + 7LL;\nconst double pie = acos(-1.0);\nlong long Fact[N], k, a[N], n, Ans;\nvoid extended_euclid(long long a, long long b, long long *x, long long *y) {\n  if (b == 0) {\n    *x = 1;\n    *y = 0;\n    return;\n  }\n  long long x1, y1;\n  extended_euclid(b, a % b, &x1, &y1);\n  *x = y1;\n  *y = x1 - ((a / b) * y1);\n}\nlong long inverse_mod(long long C) {\n  long long x, y;\n  extended_euclid(MOD, C, &x, &y);\n  return ((y % MOD) + MOD) % MOD;\n}\nlong long mod_expo(long long A, long long B) {\n  if (B == 0) return 1;\n  long long x = mod_expo(A, B / 2);\n  x %= MOD;\n  x = (x * x) % MOD;\n  if (B % 2 == 1) {\n    x = (x * (A % MOD)) % MOD;\n  }\n  return x;\n}\nlong long ncr(long long n, long long r) {\n  r = ((Fact[r] % MOD) * (Fact[n - r] % MOD)) % MOD;\n  return ((Fact[n] % MOD) * (inverse_mod(r) % MOD)) % MOD;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  Fact[0] = 1;\n  for (long long i = 1; i < N; ++i) Fact[i] = (i * Fact[i - 1]) % MOD;\n  cin >> k;\n  Ans = 1;\n  for (long long i = 1; i <= k; ++i) {\n    cin >> a[i];\n    n += a[i];\n    Ans = Ans * ncr(n - 1, a[i] - 1) % MOD;\n  }\n  cout << Ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main_origin {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\tint[][] com = new int[1001][1001];\n\n\tvoid pascal() {\n\t\tcom[0][0] = 1;\n\t\tfor (int i = 1; i <= 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (j == 0 || j == i)\n\t\t\t\t\tcom[i][j] = 1;\n\t\t\t\telse\n\t\t\t\t\tcom[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint[] c = sc.nextIntArray(n);\n\t\tint total = c[0];\n\t\tlong res = 1;\n\t\tpascal();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ttotal += c[i];\n\t\t\tres = (res * com[total - 1][c[i] - 1]) % MOD;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main_origin().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int D = 1e9 + 7;\nlong long k, A[1002], F[1002], c[1002][1002], d[1002][1002];\nint main() {\n  cin >> k;\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", &A[i]);\n  for (int i = 1; i <= 1000; ++i) d[0][i] = 1, c[0][i] = 1;\n  for (int i = 1; i <= 1000; ++i)\n    for (int j = 1; j <= 1000; ++j) {\n      if (j == 1)\n        c[i][j] = 1;\n      else\n        c[i][j] = d[i][j - 1];\n      d[i][j] = (d[i - 1][j] + c[i][j]) % D;\n    }\n  long long so = A[1];\n  F[1] = 1;\n  for (int i = 2; i <= 1000; ++i) {\n    F[i] = (F[i - 1] * c[A[i] - 1][so + 1]) % D;\n    so += A[i];\n  }\n  cout << F[k];\n  fclose(stdin);\n  fclose(stdout);\n}\n"
        },
        {
            "language": 3,
            "solution": "fac = [1] * 1001\nfor i in range(1, 1001):\n    fac[i] = fac[i - 1] * i\nk = int(input())\ntmp = 0\nres = 1\nfor i in range(k):\n    tmp2 = int(input())\n    res *= (fac[tmp2 + tmp - 1] // fac[tmp2 - 1] // fac[tmp]) % (10 ** 9 + 7)\n    tmp += tmp2\nprint(res % (10 ** 9 + 7))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long quick_mod(long long a, long long b) {\n  long long ans = 1;\n  a %= 1000000007;\n  while (b) {\n    if (b % 2 != 0) {\n      ans = ans * a % 1000000007;\n      b--;\n    }\n    b /= 2;\n    a = a * a % 1000000007;\n  }\n  return ans;\n}\nlong long judge(long long n, long long m) {\n  if (m > n) return 0;\n  long long ans = 1;\n  for (long long i = 1; i <= m; i++) {\n    long long a = (n + i - m) % 1000000007;\n    long long b = i % 1000000007;\n    ans = ans * (a * quick_mod(b, 1000000007 - 2) % 1000000007) % 1000000007;\n  }\n  return ans;\n}\nlong long work(long long n, long long m) {\n  if (m == 0) return 1;\n  return judge(n % 1000000007, m % 1000000007) *\n         work(n / 1000000007, m / 1000000007) % 1000000007;\n}\nint main() {\n  long long m, n, i, j, k, ans = 1, a[10005], t = 0, count;\n  while (cin >> m) {\n    for (i = 1; i <= m; i++) cin >> a[i];\n    ans = 1;\n    long long sum = a[1];\n    for (i = 2; i <= m; i++) {\n      sum += a[i];\n      ans = (ans * work(sum - 1, a[i] - 1)) % 1000000007;\n    }\n    cout << ans % 1000000007 << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "\ns = input()\nres = 1\nsum = 0\nfor i in xrange(s):\n    a = input()\n    if sum > 0 and a > 1:\n        sum += a\n        app = 1\n        add = 1\n        for j in xrange(1, a):\n            app *= sum - j\n            add *= j\n        res *= app /add\n    else:\n        sum += a\nprint (res % 1000000007)\n     \t\t\t\t \t  \t \t\t    \t  \t \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x7FFFFFFF;\nconst int MOD = 1000000000 + 7;\nconst double EPS = 1e-10;\nconst double PI = 2 * acos(0.0);\nconst int maxn = 1000 + 66;\nint cnt[maxn];\nbool prime[maxn];\nlong long primelist[maxn], prime_len;\nvoid GetPrime() {\n  memset(prime, true, sizeof(prime));\n  prime_len = 0;\n  long long i;\n  for (i = 2; i <= maxn; i++) {\n    if (prime[i]) primelist[prime_len++] = i;\n    long long j;\n    for (j = 0; j < prime_len; j++) {\n      if (i * primelist[j] > maxn) break;\n      prime[i * primelist[j]] = false;\n      if (i % primelist[j] == 0) break;\n    }\n  }\n}\nlong long mult_mod(long long a, long long b, long long mod) {\n  a %= mod;\n  b %= mod;\n  long long ans = 0;\n  long long temp = a;\n  while (b) {\n    if (b & 1) {\n      ans += temp;\n      if (ans > mod) ans -= mod;\n    }\n    temp <<= 1;\n    if (temp > mod) temp -= mod;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long pow_mod(long long a, long long n, long long mod) {\n  long long ans = 1;\n  long long temp = a % mod;\n  while (n) {\n    if (n & 1) ans = mult_mod(ans, temp, mod);\n    temp = mult_mod(temp, temp, mod);\n    n >>= 1;\n  }\n  return ans;\n}\nlong long Work(long long n, long long p) {\n  long long ans = 0;\n  while (n) {\n    ans += n / p;\n    n /= p;\n  }\n  return ans;\n}\nlong long GetComMod(long long n, long long m, long long p) {\n  long long ans = 1;\n  for (long long i = 0; i < prime_len && primelist[i] <= n; i++) {\n    long long x = Work(n, primelist[i]);\n    long long y = Work(n - m, primelist[i]);\n    long long z = Work(m, primelist[i]);\n    x -= (y + z);\n    ans *= pow_mod(primelist[i], x, p);\n    ans %= p;\n  }\n  return ans;\n}\nint main() {\n  GetPrime();\n  int k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> cnt[i];\n  long long res = 1, tempsum = cnt[1];\n  for (int i = 2; i <= k; i++) {\n    res = (res % MOD * GetComMod(tempsum + cnt[i] - 1, cnt[i] - 1, MOD)) % MOD;\n    tempsum += cnt[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "__author__ = 'taras-sereda'\n\nfrom pprint import pprint as pp\n\nn = int(input())\n\nmaxn = 1010\nmod = 1000000007\ncoef = [[0 for i in range(maxn)]for i in range(maxn)]\n\nfor i in range(maxn):\n    coef[i][0] = 1\n    for j in range(1, maxn):\n        coef[i][j] = (coef[i-1][j] + coef[i-1][j-1]) % mod\n\ncolors = [int(input()) for i in range(n)]\n\nres = 1\ntotal = 0\n\nfor i in range(n):\n    res = (res*coef[total+colors[i]-1][colors[i]-1]) % mod\n    total += colors[i]\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\n\np=(10**9)+7\npri=p\nfac=[1 for i in range((10**6)+1)]\nfor i in range(2,len(fac)):\n    fac[i]=(fac[i-1]*(i%pri))%pri\ndef modi(x):\n    return (pow(x,p-2,p))%p;\n    \ndef ncr(n,r):\n    x=(fac[n]*((modi(fac[r])%p)*(modi(fac[n-r])%p))%p)%p\n    return x;\na=int(input())\nans=[0 for i in range(a+1)]\n\nfor i in range(a):\n    s=int(input())\n    ans[i+1]=s\npref=[0]\n\nfor i in range(1,a+1):\n    pref.append(pref[-1]+ans[i])\n\ntotal=1\nfor i in range(2,len(ans)):\n    spaces=pref[i-1]+1\n    items=ans[i]-1\n    \n    x=ncr(spaces+items-1,spaces-1)\n    x%=pri\n    total=(total*x)%pri\nprint(total)\n    \n    \n    \n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D2_309C {\n    public static String filename = \"test\";\n    static int mod = 1000000007;\n    static int maxN = 1005;\n    public static void main(String [] args) throws IOException {\n        // BufferedReader in = new BufferedReader(new FileReader(filename+\".in\"));\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new\n            OutputStreamWriter(System.out)));\n        long [][] ncr = new long[maxN][maxN];\n        ncr[0][0] = 1;\n        for (int i = 1; i <  maxN; i++) {\n            ncr[i][0] = 1;\n            ncr[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                ncr[i][j] =  (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod;\n            }\n        }\n        int K = Integer.parseInt(in.readLine());\n        int [] color = new int[K];\n        for (int i = 0; i < K; i++) {\n            color[i] = Integer.parseInt(in.readLine());\n        }\n        int total = 0;\n        long res = 1;\n        for (int i = 0; i < K; i++) {\n            res = (res * ncr[total + color[i] - 1][color[i] - 1]) % mod;\n            total += color[i];\n        }\n        System.out.println(res);\n        in.close();\n        out.close();\n        System.exit(0);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000 + 10;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst int inf = 1000 * 1000 * 1000 * 2;\nconst int rad = 400;\nint c[maxn][maxn];\ninline void pre() {\n  for (int i = 0; i < maxn; ++i) c[0][i] = 1, c[1][i] = i, c[i][i] = 1;\n  for (int j = 2; j < maxn; ++j)\n    for (int i = 2; i < j; ++i) c[i][j] = (c[i - 1][j - 1] + c[i][j - 1]) % mod;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  pre();\n  int k;\n  cin >> k;\n  int x;\n  cin >> x;\n  long long ans = 1;\n  for (int i = 2; i <= k; ++i) {\n    int y;\n    cin >> y;\n    ans *= c[x][x + y - 1];\n    ans %= mod;\n    x += y;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nlong long C[1015][1015];\nlong long k;\nlong long sum = 0;\nlong long a[1015];\nvoid init() {\n  for (int i = 0; i <= 1010; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      C[i][j] = (i && j) ? (C[i - 1][j] + C[i - 1][j - 1]) % mod : 1;\n    }\n  }\n}\nint main() {\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  init();\n  long long ans = 1;\n  for (int i = k; i >= 1; i--) {\n    ans = ans * C[sum - 1][a[i] - 1] % mod;\n    sum -= a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k;\n  cin >> k;\n  if (k == 0) {\n    cout << 1;\n  } else {\n    vector<long long> c(k, 0);\n    for (int i = 0; i < k; i++) cin >> c[i];\n    long long tot = accumulate((c).begin(), (c).end(), 0);\n    vector<vector<long long> > coeffs(tot, vector<long long>(tot, 0));\n    for (int i = 0; i < tot; i++) coeffs[i][0] = 1, coeffs[i][i] = 1;\n    for (int i = 1; i < tot; i++) {\n      for (int j = 1; j < i; j++) {\n        coeffs[i][j] = (coeffs[i - 1][j] + coeffs[i - 1][j - 1]) % 1000000007;\n      }\n    }\n    vector<long long> d(k, 0);\n    d[0] = c[0];\n    for (int i = 1; i < k; i++) {\n      d[i] = d[i - 1] + c[i];\n    }\n    int soln = 1;\n    for (int i = 0; i < (c).size(); i++) {\n      soln = (soln * coeffs[d[i] - 1][c[i] - 1]) % 1000000007;\n    }\n    cout << soln;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long int *f;\nlong long int pow(long long int a, long long int b) {\n  long long int x = 1, y = a;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      x = (x * y);\n      if (x > 1000000007) x %= 1000000007;\n    }\n    y = (y * y);\n    if (y > 1000000007) y %= 1000000007;\n    b /= 2;\n  }\n  return x;\n}\nlong long int InverseEuler(long long int n) { return pow(n, 1000000007 - 2); }\nlong long int SmallC(long long int n, long long int r) {\n  return (f[n] * ((InverseEuler(f[r]) * InverseEuler(f[n - r])) % 1000000007)) %\n         1000000007;\n}\nlong long int Lucas(long long int n, long long int m) {\n  if (n == 0 && m == 0) return 1;\n  long long int ni = n % 1000000007;\n  long long int mi = m % 1000000007;\n  if (mi > ni) return 0;\n  return Lucas(n / 1000000007, m / 1000000007) * SmallC(ni, mi);\n}\nlong long int C(long long int n, long long int r) {\n  if (r == 0)\n    return 1;\n  else\n    return Lucas(n, r);\n}\nint main() {\n  long long int k, *a, i, n;\n  long long int ans;\n  scanf(\"%I64d\", &k);\n  f = (long long int *)malloc(sizeof(long long int) * (1000 + 1));\n  f[0] = f[1] = 1;\n  for (i = 2; i < 1000 + 1; i++) f[i] = (f[i - 1] * i) % 1000000007;\n  a = (long long int *)malloc(sizeof(long long int) * k);\n  n = 0;\n  for (i = 0; i < k; i++) {\n    scanf(\"%I64d\", &a[i]);\n    n += a[i];\n  }\n  ans = 1;\n  for (i = k - 1; i >= 0; i--) {\n    ans = (ans * C(n - 1, a[i] - 1)) % 1000000007;\n    n -= a[i];\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ncr[1001][1001];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int i, j, x, n, tot = 0, ans, k;\n  cin >> k;\n  long long int in[k + 1];\n  for (i = 1; i <= k; i++) {\n    cin >> in[i];\n  }\n  ncr[1][1] = 1;\n  ncr[1][0] = 1;\n  for (i = 0; i <= 1000; i++) {\n    ncr[i][0] = 1;\n    for (j = 1; j <= i; j++)\n      ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % 1000000007;\n  }\n  ans = 1;\n  tot = in[1];\n  for (i = 2; i <= k; i++) {\n    tot += in[i];\n    x = tot - 1;\n    ans = (ans * ncr[x][in[i] - 1]) % 1000000007;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "\n\nw, h = 1003, 1003 \nnCr = [[0 for x in range(0,w)] for x in range(h)]\nnCr[0][0]=1\nmod = 1000000007\n\n\nfor i in range(1,1001):\n  nCr[i][0]=1\n  for j in range(1,1001):\n    nCr[i][j]=  nCr[i-1][j-1] + nCr[i-1][j]  % mod\n\nn = input()\n\n\nkp = []\n\nfor i in range(0,n):\n  kp.append(input()  )\n\nres=1\ntotal = 0\n\nfor i in kp: \n  res=(res* (nCr[i-1 + total ][i-1] ) ) % mod\n  total+=i\n\n\nprint res"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long>> memo(1001, vector<long long>(1001, -1));\nlong long cnk(long long n, long long k) {\n  if (memo[n][k] == -1) {\n    if (n < k)\n      memo[n][k] = 0;\n    else if (n == k)\n      memo[n][k] = 1;\n    else if (k == 0)\n      memo[n][k] = 1;\n    else {\n      memo[n][k] = cnk(n - 1, k) + cnk(n - 1, k - 1);\n      memo[n][k] %= 1000000007;\n    }\n  }\n  return memo[n][k];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int k, sum = 0, a;\n  cin >> k;\n  long long ans = 1;\n  for (int i = 0; i < k; ++i) {\n    cin >> a;\n    ans *= cnk(sum + a - 1, a - 1);\n    ans %= 1000000007;\n    sum += a;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class solveC {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner f = new Scanner(System.in);\n\t\tStringTokenizer st = new StringTokenizer(f.nextLine());\n\n\t\tint p = Integer.parseInt(st.nextToken());\n\t\tint[] balls = new int[p];\n\n\t\tint largest = 2000;\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tst = new StringTokenizer(f.nextLine());\n\t\t\tballs[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\n\t\t//generate Pascal's Triangle\n\n\t\tlong[][] binomial = new long[largest+2][largest+2];\n\t\tbinomial[0][0] = 1;\n\n\n\t\tfor (int k = 1; k <= largest+1; k++) binomial[0][k] = 0l;\n\t\tfor (int n = 0; n <= largest+1; n++) binomial[n][0] = 1l;\n\n\t\tfor (int n = 1; n <= largest+1; n++)\n\t\t\tfor (int k = 1; k <= largest+1; k++)\n\t\t\t\tbinomial[n][k] = (binomial[n - 1][k - 1] + binomial[n - 1][k])%1000000007l;\n\n\t\tlong[] count = new long[p];\n\t\tcount[0] = 1l;\n\t\tint accumBalls = balls[0];\n\t\tfor(int i = 1; i < p; i++) {\n\t\t\t//System.out.println(Arrays.toString(count));\n\t\t\tcount[i] = (binomial[accumBalls + balls[i]-1][balls[i]-1]*count[i-1])%1000000007l;\n\t\t\taccumBalls += balls[i];\n\t\t}\n\n\t\tSystem.out.println(count[p-1]);\n\n\n\n\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint mod_inv(long long base) {\n  long long result = 1, exp = MOD - 2;\n  while (exp) {\n    if (exp & 1) result = (result * base) % MOD;\n    exp >>= 1;\n    base = (base * base) % MOD;\n  }\n  return result;\n}\nint fact(int a) {\n  long long f = 1;\n  for (int i = 2; i <= a; i++) f = (f * i) % MOD;\n  return f;\n}\nint comb(int a, int b) {\n  long long comb_res = 1;\n  int x = max(a, b - a);\n  for (int i = b; i > x; i--) comb_res = (comb_res * i) % MOD;\n  return (comb_res * (mod_inv(fact(b - x)) % MOD)) % MOD;\n}\nint c[1001], t[1001];\nint main() {\n  int i, k;\n  long long res = 1;\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> c[i];\n    t[i] = t[i - 1] + c[i];\n  }\n  for (i = 2; i <= k; i++) {\n    res *= comb(c[i] - 1, t[i] - 1);\n    res %= MOD;\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nfrom collections import defaultdict\nimport math\n#stdin = open('input.txt','r')\n\n\n\nmod = 10**9+7\nI = stdin.readline\nP = stdout.write\n\nk = int(I())\ntot = 0\nans = 1\nfor i in range(k):\n\tnow = int(I())\n\tans*=math.factorial(tot+now-1)//math.factorial(tot)//math.factorial(now-1)\n\ttot+=now\n\tans%=mod\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n       \n    \n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nll modpow(ll x, ll p, ll mod) {\n  ll res = 1LL;\n  for (; p; p >>= 1, (x *= x) %= mod)\n    if (p & 1) (res *= x) %= mod;\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int k;\n  cin >> k;\n  constexpr ll mod = 1e9 + 7, maxsum = 1000;\n  vector<ll> f(maxsum + 1, 1), inv(maxsum + 1, 1LL);\n  for (int x = 1; x <= maxsum; ++x) {\n    f[x] = x * f[x - 1] % mod;\n    inv[x] = modpow(f[x], mod - 2, mod);\n  }\n  ll sum = 0LL, res = 1LL;\n  for (int j = 0; j < k; ++j) {\n    ll ct;\n    cin >> ct;\n    res = ((res * f[sum + ct - 1] % mod) * inv[sum] % mod) * inv[ct - 1] % mod;\n    sum += ct;\n  }\n  cout << res << '\\n';\n  exit(0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int fact[1010], invfact[1010];\nlong long int powmod(long long int base, long long int expo) {\n  if (expo == 0)\n    return 1;\n  else if (expo & 1)\n    return base * powmod(base, expo - 1) % 1000000007;\n  else {\n    long long int root = powmod(base, expo >> 1);\n    return (root * root) % 1000000007;\n  }\n}\nlong long int inverse(long long int x) { return powmod(x, 1000000007 - 2); }\nvoid init(long long int n) {\n  long long int i;\n  fact[0] = 1;\n  for (i = 1; i <= n; i++) fact[i] = (i * fact[i - 1]) % 1000000007;\n  invfact[n] = inverse(fact[n]);\n  for (i = n; i > 0; i--) invfact[i - 1] = (i * invfact[i]) % 1000000007;\n}\nlong long int nCr(long long int n, long long int r) {\n  if (r > n || r < 0) return 0;\n  return ((fact[n] * invfact[r] % 1000000007) * invfact[n - r]) % 1000000007;\n}\nint main() {\n  long long int n, k, i, sum = 0;\n  init(1005);\n  cin >> k;\n  long long int ans = 1;\n  long long int p;\n  long long int arr[1005];\n  for (i = 0; i < k; i++) {\n    cin >> arr[i];\n    sum += arr[i];\n  }\n  for (i = k - 1; i >= 0; i--) {\n    p = arr[i] - 1;\n    ans = (ans * nCr(sum - 1, p)) % 1000000007;\n    sum -= arr[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\n\ndef nCk(n, k, mod):\n    result = math.factorial(n) % mod\n    result = (result * pow(math.factorial(k), mod-2, mod)) % mod\n    result = (result * pow(math.factorial(n-k), mod-2, mod)) % mod\n    return result\n\ndef main():\n    k = int(raw_input())\n    c = []\n    mod = int(1e9+7)\n    for i in xrange(k):\n        c.append(int(raw_input()))\n    sumC = sum(c)\n    result = 1\n    sumDec = sumC\n    for i in xrange(len(c)-1, 0, -1):\n        result *= nCk(sumDec-1, c[i]-1, mod)\n        sumDec -= c[i]\n    print result % mod\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n  public static IO in;\n  public static PrintWriter out;\n \n  static void init_io(String filename) throws Exception {\n    if (filename.equals(\"\")) {\n      in = new IO(System.in);\n      out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), true);\n    } else {\n      in = new IO(new FileInputStream(filename + \".in\"));\n      out = new PrintWriter(new BufferedWriter(new FileWriter(filename + \".out\")), true);\n    }\n  }\n \n  final static long mod = 1_000_000_007;\n  \n  static long[] fact, ifact;\n \n  public static void main(String[] _u_n_u_s_e_d_) throws Exception {\n    init_io(\"\");\n \n    int n = in.nint();\n    long[] counts = new long[n];\n    for (int i = 0; i < n; i++) counts[i] = in.nlong();\n    long[] sum = new long[n];\n    long run = 0;\n    for (int i = 0; i < n; i++) {\n        run += counts[i];\n        sum[i] = run;\n    }\n    \n    int tot = (int)(sum[n - 1] + 1);\n    \n    long[] dp = new long[n + 1];\n    \n    fact = new long[1005];\n    ifact = new long[1005];\n    fact[0] = fact[1] = ifact[0] = ifact[1] = 1;\n    for (int i = 2; i < 1005; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n        ifact[i] = minv(fact[i]);\n    }\n    \n    int cur = (int)counts[0];\n    long ways = 1;\n    for (int i = 1; i < n; i++) {\n        int x = (int)counts[i];\n        cur += x;\n        ways = (ways * nck(cur - 1, x - 1)) % mod;\n    }\n    out.println(ways);\n  }\n  \n  static long nck(int n, int k) {\n    long dem = (ifact[n - k] * ifact[k]) % mod;\n    return (fact[n] * dem) % mod;\n  }\n  \n  static long minv(long v) {\n    return mpow(v, mod - 2);\n  }\n \n  static long mpow(long base, long exp) {\n    long res = 1;\n \n    while (exp > 0) {\n      if ((exp & 1) == 1) {\n        res = (res * base) % mod;\n      }\n      base = (base * base) % mod;\n      exp >>= 1;\n    }\n \n    return res;\n  }\n \n  static int gcd(int a, int b) {\n    if (a == 0) return b;\n    return gcd(b % a, a);\n  }\n \n  static void qsort(long[] arr) {\n    Long[] oarr = new Long[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n      oarr[i] = arr[i];\n    }\n \n    ArrayList<Long> alist = new ArrayList<Long>(Arrays.asList(oarr));\n    Collections.sort(alist);\n \n    for (int i = 0; i < arr.length; i++) {\n      arr[i] = alist.get(i);\n    }\n  }\n \n  static void reverse(long[] arr) {\n    for (int i = 0; i < arr.length / 2; i++) {\n      long temp = arr[i];\n      arr[i] = arr[arr.length - 1 - i];\n      arr[arr.length - 1 - i] = temp;\n    }\n  }\n \n  static String atos(long[] arr) {\n    String s = Arrays.toString(arr);\n    s = s.substring(1, s.length() - 1);\n    return s.replace(\",\", \"\");\n  }\n \n  static class IO {\n    public BufferedReader in;\n    public StringTokenizer tokens;\n \n    public IO(InputStream x) throws Exception {\n      in = new BufferedReader(new InputStreamReader(x));\n      tokens = new StringTokenizer(in.readLine());\n    }\n \n    int nint() throws Exception {\n      return Integer.parseInt(nstr());\n    }\n \n    long nlong() throws Exception {\n      return Long.parseLong(nstr());\n    }\n \n    double ndouble() throws Exception {\n      return Double.parseDouble(nstr());\n    }\n \n    String nstr() throws Exception {\n      if (!tokens.hasMoreTokens()) tokens = new StringTokenizer(in.readLine());\n      return tokens.nextToken();\n    }\n    \n    long[] nla(int n) throws Exception {\n      long[] arr = new long[n];\n      for (int i = 0; i < n; i++) {\n        arr[i] = nlong();\n      }\n      return arr;\n    }\n  }\n \n  static class Pair<A extends Comparable<A>, B extends Comparable<B>> implements Comparable<Pair<A, B>> {\n    public A f;\n    public B s;\n \n    public Pair(A a, B b) {\n      f = a;\n      s = b;\n    }\n \n    public int compareTo(Pair<A, B> other) {\n      int v = f.compareTo(other.f);\n      if (v != 0) return v;\n      return s.compareTo(other.s);\n    }\n \n    public String toString() {\n      return \"(\" + f.toString() + \", \" + s.toString() + \")\";\n    }\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int MAX = 1000;\nlong long k;\nlong long sum;\nlong long buf[MAX + 1];\nlong long e[MAX + 1][MAX + 1];\nlong long res;\nint main(int argc, char const *argv[]) {\n  cin >> k;\n  for (int i = 0; i < MAX + 1; ++i) {\n    e[i][0] = 1;\n  }\n  for (int i = 1; i < MAX + 1; ++i) {\n    for (int j = 1; j < MAX + 1; ++j) {\n      e[i][j] = (e[i - 1][j - 1] + e[i - 1][j]) % INF;\n    }\n  }\n  res = 1;\n  for (int i = 0; i < k; ++i) {\n    int c;\n    cin >> c;\n    sum += c;\n    res = (res * e[sum - 1][c - 1]) % INF;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int m = 1e9 + 7;\nint c[1012][1012];\nlong long int n, k, t, res = 1, all;\nint main() {\n  for (int i = 0; i < 1012; i++) c[0][i] = 1;\n  for (int i = 1; i < 1012; i++) {\n    c[i][0] = 1, c[i][i] = 1;\n    for (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % m;\n  }\n  cin >> k;\n  while (k--) {\n    cin >> t;\n    all += t;\n    res = ((long long int)c[all - 1][t - 1] * res) % m;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "numeroColores=int(input())\nlistaNumColores=[]\nfor i in range (0, numeroColores):\n    listaNumColores.append(int(input()))\nconclusion= 1\nanterior= listaNumColores[0]\n\nfor i, numeroColores in enumerate(listaNumColores[1:]):\n#for i in range(0,numeroColores-1):\n    anterior+= 1\n    #reset\n    conteo1= 1\n    conteo2= 1\n    for j in range(numeroColores - 1):\n        conclusion= conclusion* anterior\n        anterior+= 1\n        conteo1= conteo1* conteo2\n        conteo2+= 1\n    conclusion= conclusion// conteo1\nif conclusion> 1000000007:\n    #Aplicar modulo\n    conclusion = conclusion% 1000000007\nprint(conclusion)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxk = 1e3 + 7;\nconst int p = 1000000007;\nint k;\nint c[maxk];\nlong long dp[maxk];\nint cnt;\nlong long n, m;\nlong long quick_mod(long long a, long long b) {\n  long long ans = 1;\n  a %= p;\n  while (b) {\n    if (b & 1) {\n      ans = ans * a % p;\n      b--;\n    }\n    b >>= 1;\n    a = a * a % p;\n  }\n  return ans;\n}\nlong long C(long long n, long long m) {\n  if (m > n) return 0;\n  long long ans = 1;\n  for (int i = 1; i <= m; i++) {\n    long long a = (n + i - m) % p;\n    long long b = i % p;\n    ans = ans * (a * quick_mod(b, p - 2) % p) % p;\n  }\n  return ans;\n}\nlong long Lucas(long long n, long long m) {\n  if (m == 0) return 1;\n  return C(n % p, m % p) * Lucas(n / p, m / p) % p;\n}\nlong long fun(long long x) {\n  long long ans = 0;\n  for (int i = 0; i < x - 1; i++) {\n    long long t = Lucas(x - 2, i);\n    long long y = Lucas(cnt + 1, i + 1);\n    ans = (ans % p + (t % p * y % p) % p) % p;\n  }\n  if (!ans) return 1ll;\n  return ans;\n}\nvoid solve() {\n  dp[0] = 1;\n  cnt = c[0];\n  for (int i = 1; i < k; i++) {\n    dp[i] = dp[i - 1] * fun(c[i]) % p;\n    cnt += c[i];\n  }\n  cout << dp[k - 1] << endl;\n}\nint main() {\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> c[i];\n  }\n  solve();\n}\n"
        },
        {
            "language": 1,
            "solution": "def extnd_euclid_eng(a, b, s, t, sp, tp):\n    if a%b == 0: return [s,t]\n    return extnd_euclid_eng(b, a%b, sp-s*(a/b), tp-t*(a/b), s, t)\n\ndef extnd_euclid(a, b):\n    if b > a :\n        x, y = extnd_euclid_eng(b, a, 0, 1, 1, 0)\n        return [y,x]\n    return extnd_euclid_eng(a, b, 0, 1, 1, 0)\n\ndef inv_mod(x, mod):\n    r, t = extnd_euclid(x, mod)\n    if r < 0: r = r+mod\n    return r\n\nlmt = 1001000\nmod = 1000000007\n\nfct = [1]*lmt\nfct_inv = [1]*lmt\n\nfor i in xrange(1, lmt):\n    fct[i] = (fct[i-1]*i)%mod\n\ndef ncr_mod(n, r):\n    return (fct[n]*inv_mod(fct[r], mod)*inv_mod(fct[n-r], mod))%mod\n\nk = int(raw_input())\nans = 1\nb = 0\nfor _ in range(k):\n    i = int(raw_input())\n    ans = (ans * ncr_mod(b+i-1, i-1))%mod\n    b += i\n\nprint ans\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long C[1001][1001];\nvoid PreCalc() {\n  C[0][0] = 1;\n  for (int i = 1; i < 1001; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    }\n  }\n}\nint main() {\n  PreCalc();\n  int k;\n  scanf(\"%d\", &k);\n  int n = 0;\n  vector<int> c(k);\n  for (int i = 0; i < k; ++i) {\n    scanf(\"%d\", &c[i]);\n    n += c[i];\n  }\n  long long ans = 1;\n  for (int i = k - 1; i >= 0; --i) {\n    ans *= C[n - 1][c[i] - 1];\n    ans %= mod;\n    n -= c[i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "__author__ = 'rols'\n\nn = int(raw_input())\n\nmod = 1000000007\n\ndef binomial(n,m,p):\n    if n < m:\n        return 0\n    if (m > n-m):\n        m = n-m\n    num = 1\n    denom = 1\n    for i in range(m):\n        num *= n-i\n        denom *= i+1\n    return num/denom %p\n\ndef binomial_module(n, m, p):\n    res = 1\n    while (n != 0 and m!=0):\n        np ,mp = n%p, m%p\n        n, m = n/p, m/p\n        res *= binomial(np,mp,p)\n        if res == 0:\n            break\n    return res\n\ntotalballs = 0\n\ns = 1\n\nfor i in range(n):\n    a = int(input())\n    s *= binomial_module( totalballs + 1 - 1 + a - 1, totalballs + 1 - 1  ,  mod)\n    totalballs += a\n\nprint s % mod\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint C[1010][1010];\nint main() {\n  std::ios::sync_with_stdio(false);\n  for (int i = 0; i < 1005; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      if (C[i][j] >= 1000000007) C[i][j] %= 1000000007;\n    }\n  }\n  long long int ans = 1, total = 0, n;\n  cin >> n;\n  long long int a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    ans = (ans * C[total + a[i] - 1][a[i] - 1]) % 1000000007;\n    total += a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long n;\nlong long f[1005];\nlong long sum;\nlong long C[1005][1005];\nvoid init() {\n  for (int i = 0; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (i == 0 || i == j)\n        C[i][j] = 1;\n      else\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    }\n  }\n  return;\n}\nint main() {\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    cin >> f[i];\n    sum += f[i];\n  }\n  init();\n  long long ans = 1;\n  for (int i = n; i > 0; i--) {\n    ans *= C[sum - 1][f[i] - 1];\n    sum -= f[i];\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\tpublic class Main {\n\t\tpublic static long mod= (long) (1e9 +7);\n\t\tstatic long ncr[][] = new long[1000+7][1000+7];\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tInputReader s= new InputReader(System.in);\n\t\t\tOutputStream outputStream= System.out;\n\t\t\tPrintWriter out= new PrintWriter(outputStream);\n\t\t\tint n= s.nextInt();\n\t\t\tlong ans = 1;\n\t        int sum = 0;\n\t        precomputation();\n\t        for(int i=0;i<n;i++){\n\t            int temp=s.nextInt();\n\t            sum+=temp;\n\t            ans=((ans%mod)*(ncr[sum-1][temp-1]%mod))%mod;\n\t        }\n\t\t\tout.println(ans%mod);\n\t\t\tout.close();\n\t\t}\n\t\tstatic void precomputation(){\n\t        ncr[0][0] = 1;\n\t        \n\t        for(int i=1;i<=1000;i++){\n\t            for(int j=0;j<=i;j++){\n\t                if(j==0)\n\t                    ncr[i][j] = 1;\n\t                else{\n\t                    ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j])%mod;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\tstatic long combinations1(long n,long r){   // O(r)\n\t\t\tif(r==0 || r==n) return 1;\n\t\t\tr= Math.min(r, n-r);\n\t\t\tlong ans=n;  // nC1=n;\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tans= ((ans%mod)*((n-i)%mod))%mod;\n\t\t\t\tans=  (long) ((ans%mod)*(Math.pow(i+1, -1))%mod)%mod;\n\t\t\t}\n\t\t\treturn ans%mod;\n\t\t\t\n\t\t}\n\t\tstatic long combinations(long n,long r){   // O(r)\n\t\t\tif(r==0 || r==n) return 1;\n\t\t\tr= Math.min(r, n-r);\n\t\t\tlong ans=n;  // nC1=n;\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tans= ans*(n-i);\n\t\t\t\tans= ans/(i+1);\n\t\t\t}\n\t\t\treturn ans;\n\t\t\t\n\t\t}\n\t\tstatic long modulo(long a,long b,long c) {\n\t\t\tlong x=1;\n\t\t\tlong y=a;\n\t\t\twhile(b > 0){\n\t\t\t\tif(b%2 == 1){\n\t\t\t\t\tx=(x*y)%c;\n\t\t\t\t}\n\t\t\t\ty = (y*y)%c; // squaring the base\n\t\t\t\tb /= 2;\n\t\t\t}\n\t\t\treturn  x%c;\n\t\t}\n\t\tstatic void catalan_numbers(int n) {\n\t\t\tlong catalan[]= new long[n+1];\n\t\t    catalan[1] = 1;\n\t\t    for (int i = 2; i <= n; i++) {\n\t\t        for (int j = 1; j <= i - 1; j++) {\n\t\t            catalan[i] = catalan[i] + ((catalan[j]) * catalan[i - j]);\n\t\t        }\n\t\t    }\n\t\t}\n\t\t\n\t\tstatic ArrayList<Integer> primeFactors(int n)   // O(sqrt(n))\n\t\t{\n\t\t    // Print the number of 2s that divide n\n\t\t\tArrayList<Integer> arr= new ArrayList<>();\n\t\t    while (n%2 == 0)\n\t\t    {\n\t\t        arr.add(2);\n\t\t        n = n/2;\n\t\t    }\n\t\t \n\t\t    // n must be odd at this point.  So we can skip one element (Note i = i +2)\n\t\t    for (int i = 3; i <= Math.sqrt(n); i = i+2)\n\t\t    {\n\t\t        // While i divides n, print i and divide n\n\t\t        while (n%i == 0)\n\t\t        {\n\t\t            arr.add(i);\n\t\t            n = n/i;\n\t\t        }\n\t\t    }\n\t\t    // This condition is to handle the case when n is a prime number\n\t\t    // greater than 2\n\t\t    if (n > 2)\n\t\t        arr.add(n);\n\t\t    \n\t\t    return arr;\n\t\t}\n\t\n\t\tpublic static long expo(long a, long b){\n\t\t\tif (b==0)\n\t\t        return 1%mod;\n\t\t    if (b==1)\n\t\t        return a%mod;\n\t\t    if (b==2)\n\t\t        return ((a%mod)*(a%mod))%mod;\n\t\n\t\t    if (b%2==0){\n\t\t            return expo(expo(a%mod,(b%mod)/2)%mod,2%mod)%mod;\n\t\t    }\n\t\t    else{\n\t\t        return (a%mod)*(expo(expo(a%mod,(b-1)%mod/2)%mod,2%mod)%mod)%mod;\n\t\t    }\n\t\t}\n\t\tstatic class Pair implements Comparable<Pair>\n\t\t{\n\t\t\tlong f;\n\t\t\tString s;\n\t\t\tPair(long ii, String cc)\n\t\t\t{\n\t\t\t\tf=ii;\n\t\t\t\ts=cc;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int compareTo(Pair o) \n\t\t\t{\n\t\t\t\treturn Long.compare(this.f, o.f);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static int[] sieve(int N){    // O(n*log(logn))\n\t\t\tint arr[]= new int[N+1];\n\t\t\tfor(int i=2;i<Math.sqrt(N);i++){\n\t\t\t\tif(arr[i]==0){\n\t\t\t\t\tfor(int j= i*i;j<= N;j= j+i){\n\t\t\t\t\t\tarr[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arr;\n\t\t\t// All the i for which arr[i]==0 are prime numbers.\n\t\t}\n\t\tstatic long gcd(long a,long b){       // O(logn)\n\t\t\tif(b==0) return a;\n\t\t\treturn gcd(b,a%b);\n\t\t}\n\t\tstatic class InputReader {\n\t\n\t\t    public BufferedReader reader;\n\t\t    public StringTokenizer tokenizer;\n\t \n\t\t    public InputReader(InputStream inputstream) {\n\t\t      reader = new BufferedReader(new InputStreamReader(inputstream));\n\t\t      tokenizer = null;\n\t\t    }\n\t\t    \n\t\t    public String nextLine(){\n\t\t    \tString fullLine=null;\n\t\t    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t            try {\n\t\t              fullLine=reader.readLine();\n\t\t            } catch (IOException e) {\n\t\t              throw new RuntimeException(e);\n\t\t            }\n\t\t            return fullLine;\n\t\t          }\n\t\t          return fullLine;\n\t\t    }\n\t\t\tpublic String next() {\n\t\t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t        try {\n\t\t          tokenizer = new StringTokenizer(reader.readLine());\n\t\t        } catch (IOException e) {\n\t\t          throw new RuntimeException(e);\n\t\t        }\n\t\t      }\n\t\t      return tokenizer.nextToken();\n\t\t    }\n\t\t\tpublic long nextLong() {\n\t\t\t      return Long.parseLong(next());\n\t\t\t    }\n\t\t    public int nextInt() {\n\t\t      return Integer.parseInt(next());\n\t\t    }\n\t\t  }\n\t}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1005][1005];\nint sum[1005];\nlong long Sech(int n, int m) {\n  if (n == 1) return 1;\n  return C[m - 1][sum[n] - 1] * Sech(n - 1, m - sum[n]) % 1000000007;\n}\nint main(void) {\n  int m, n, i, j;\n  for (i = 0; i <= 1002; i++) C[i][0] = 1;\n  for (i = 1; i <= 1002; i++) {\n    for (j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n  }\n  m = 0;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &sum[i]);\n    m += sum[i];\n  }\n  printf(\"%lld\\n\", Sech(n, m));\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nfrom collections import Counter\nnmbr = lambda: int(stdin.readline())\nlst = lambda: list(map(int,stdin.readline().split()))\nM=10**9+7\nfact=[1]\nfor i in range(1,1005):\n    fact+=[(fact[-1]*i)%M]\ndef ncr(n,r):\n    num=fact[n]\n    den=(fact[r]*fact[n-r])%M\n    ans=(num*pow(den,M-2,M))%M\n    return ans\nfor _ in range(1):#nmbr()):\n    n=nmbr()\n    a=[nmbr() for _ in range(n)]\n    dp=[0]*(1+n)\n    dp[1]=1\n    spaces=0\n    sm=a[0]\n    for i in range(2,n+1):\n        spaces=sm+a[i-1]-1\n        dp[i]=(dp[i-1]*(ncr(spaces,a[i-1]-1)))%M\n        sm+=a[i-1]\n    print(dp[n]%M)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int MAXN = 1003;\nint C[MAXN][MAXN];\nvoid build() {\n  C[0][0] = 1;\n  for (int i = 1; i < MAXN; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      if (C[i][j] >= MOD) C[i][j] -= MOD;\n    }\n  }\n}\nint main() {\n  build();\n  int n, ans = 1, cnt = 0;\n  int a;\n  cin >> n;\n  while (n-- > 0) {\n    scanf(\"%d\", &a);\n    ans = (long long)ans * C[cnt + a - 1][cnt] % MOD;\n    cnt += a;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int col[1000001], dp[1000001], fact[1000001], ifact[1000001],\n    sum[1000001];\nlong long int bpow(long long int x, long long int n) {\n  long long int ans = 1;\n  while (n > 0) {\n    if (n & 1) ans *= x;\n    x *= x;\n    ans %= 1000000007;\n    x %= 1000000007;\n    n /= 2;\n  }\n  return ans;\n}\nvoid pre_calc(long long int N) {\n  fact[0] = ifact[0] = 1;\n  for (long long int i = 1; i <= N; ++i) {\n    fact[i] = (fact[i - 1] * i) % 1000000007;\n    ifact[i] = bpow(fact[i], 1000000007 - 2);\n  }\n}\nlong long int ncr(int n, int r) {\n  if (r < 0 or n < r) return 0;\n  long long int ans = fact[n];\n  ans = (ans * ifact[r]) % 1000000007;\n  ans = (ans * ifact[n - r]) % 1000000007;\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  ;\n  cin.tie(0);\n  ;\n  pre_calc(1000000);\n  long long int i, j, k;\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> col[i];\n    sum[i] = sum[i - 1] + col[i];\n  }\n  dp[1] = 1;\n  for (i = 2; i <= k; i++) {\n    dp[i] = dp[i - 1] * ncr(sum[i] - 1, sum[i - 1]);\n    dp[i] %= 1000000007;\n  }\n  cout << dp[k];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k;\nint dp[1002][1002];\nint f(int pos, int sisa) {\n  if (sisa < 0) return 0;\n  if (pos == 0) return (sisa == 0);\n  if (dp[pos][sisa] != -1) return dp[pos][sisa];\n  return dp[pos][sisa] = (f(pos - 1, sisa) + f(pos, sisa - 1)) % 1000000007;\n}\nint main() {\n  scanf(\"%d\", &k);\n  int c;\n  long long ans = 1;\n  int now = 1;\n  memset(dp, -1, sizeof dp);\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d\", &c);\n    ans *= f(now, c - 1);\n    ans %= 1000000007;\n    now += c;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class Codeforces309Div2C {\n    private static final long MOD = 1000000007L;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[]arr = new int[n];\n        for (int i = 0; i < n; ++i) {\n            arr[i] = in.nextInt();\n        }\n        System.out.println(new Codeforces309Div2C().numArrangements(arr));\n    }\n    \n    private long[][]C;\n    \n    private long numArrangements(int[]ballCounts) {\n        int ballsLeft = 0;\n        for (int i : ballCounts) ballsLeft += i;\n        computeCombo(ballsLeft);\n        long result = 1;\n        for (int i = ballCounts.length-1; i >= 0; i--) {\n            result *= combo(ballsLeft-1, ballCounts[i]-1);\n            result %= MOD;\n            ballsLeft -= ballCounts[i];\n        }\n        return result;\n    }\n    \n    private void computeCombo(int n) {\n        C = new long[n+1][n+1];\n        C[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            C[i][0] = 1;\n            for (int j = 1; j <= i; ++j) {\n                C[i][j] = C[i-1][j-1] + C[i-1][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    private long combo(int n, int c) {\n        return C[n][c];\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*; \npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n    final long MOD = 1000000007;\n\n\t\tlong [][]comb = new long[1000][1000];\n\t\t\n\t\tfor(int i = 0; i < 1000; i++) {\n        \tcomb[i][0] = 1;\n        \tfor(int j = 1; j <= i; j++)\n            \tcomb[i][j] = (comb[i-1][j] + comb[i-1][j-1])%MOD;\n    \t}\n\n    \tint k = in.nextInt();\n    \tint tot = 0;\n    \tint [] v = new int[k];\n\n    \tfor(int i=0;i<k;i++){\n   \t\t\tint d = in.nextInt();\n  \t\t\tv[i] = d;\n   \t\t\ttot+=v[i];\n  \t\t}\n\n  \t\tlong ans = 1;\n  \t\tfor(int i=k-1;i>=0;i--){\n        \tint count=v[i];\n        \tans=(ans*comb[tot-1][count-1])%MOD;\n         \ttot-=count;\n   \t\t}\n\n   \t\tSystem.out.println(ans);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000100;\nconst int INF = (1 << 29);\nconst double EPS = 0.0000000001;\nconst double Pi = acos(-1.0);\nconst long long p = 1000000007;\nint k, a[maxn];\nlong long s[maxn];\nlong long qpow(long long n, long long k) {\n  long long res = 1;\n  while (k) {\n    if (k & 1) res = (res % p * (n % p)) % p;\n    n = (n % p) * (n % p) % p;\n    k >>= 1;\n  }\n  return res;\n}\nlong long C(long long n, long long k) {\n  if (n < k) return 0;\n  long long res = 1;\n  for (int(i) = (1); (i) <= (k); (i)++) {\n    long long a = (n - k + i) % p;\n    long long b = i % p;\n    res = (res * (a * qpow(b, p - 2) % p)) % p;\n  }\n  return res % p;\n}\nlong long lucas(long long n, long long k) {\n  if (k == 0) return 1;\n  return (C(n % p, k % p) % p) * (lucas(n / p, k / p) % p) % p;\n}\nlong long f(long long n, long long m) { return lucas(n + m, n); }\nint main() {\n  while (cin >> k) {\n    s[0] = 0;\n    for (int(i) = (1); (i) <= (k); (i)++)\n      scanf(\"%d\", &(a[i])), s[i] = s[i - 1] + a[i];\n    long long ans = 1;\n    for (int(i) = (1); (i) <= (k - 1); (i)++) {\n      ans = ans * (f(a[i + 1] - 1, s[i]) % p) % p;\n    }\n    cout << ans % p << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint k, n, c[1001];\nlong long gt[1001], igt[1001], kq = 1;\nlong long moe(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) return moe((a * a) % 1000000007, b / 2);\n  return (a * moe((a * a) % 1000000007, b / 2)) % 1000000007;\n}\nvoid init() {\n  gt[0] = 1;\n  for (int i = 1; i <= 1000; ++i) gt[i] = (gt[i - 1] * i) % 1000000007;\n  igt[1000] = moe(gt[1000], 1000000007 - 2);\n  for (int i = 999; i >= 0; --i) {\n    igt[i] = (igt[i + 1] * (i + 1)) % 1000000007;\n  }\n}\nvoid nhap() {\n  scanf(\"%d\", &k);\n  for (int i = 1; i <= k; ++i) {\n    scanf(\"%d\", &c[i]);\n  }\n}\nlong long nCk(int a, int b) {\n  return ((gt[a] * igt[b]) % 1000000007 * igt[a - b]) % 1000000007;\n}\nvoid process() {\n  n = c[1];\n  for (int i = 2; i <= k; ++i) {\n    kq = (kq * nCk(n + c[i] - 1, c[i] - 1)) % 1000000007;\n    n += c[i];\n  }\n  cout << kq;\n}\nint main() {\n  init();\n  nhap();\n  process();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from functools import reduce\nfrom operator import mul\n\nmod = 10 ** 9 + 7\n\nk = int(input())\ncs = [int(input()) for _ in range(k)]\ncumcs = cs[:]\nfor i in range(1, len(cs)):\n    cumcs[i] += cumcs[i - 1]\n\n\ndef C(n, k):\n    num = reduce(mul, range(n, n - k, -1), 1)\n    denom = reduce(mul, range(k, 0, -1), 1)\n\n    return (num // denom) % mod\n\nres = 1\nfor cum, c in zip(cumcs, cs):\n    res = (res * C(cum - 1, c - 1)) % mod\n\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long k, c[1000 + 7], ncr[2000 + 7][2000 + 7];\nint main(void) {\n  ncr[0][0] = 1;\n  for (int i = 1; i <= 2000; i++) {\n    ncr[i][0] = 1;\n    for (int j = 1; j < i; j++) {\n      ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % 1000000007;\n    }\n    ncr[i][i] = 1;\n  }\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  long long res = 1;\n  int cnt = c[0];\n  for (int i = 1; i < k; i++) {\n    if (c[i] != 1) res *= ncr[cnt + c[i] - 1][c[i] - 1];\n    res %= 1000000007;\n    cnt += c[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long M = 1e9 + 7;\nlong long triangle[2005][2005];\nvoid makeTriangle() {\n  long long i, j;\n  triangle[0][0] = 1;\n  for (i = 1; i < 2005; i++) {\n    triangle[i][0] = 1;\n    for (j = 1; j <= i; j++) {\n      triangle[i][j] = (triangle[i - 1][j - 1] + triangle[i - 1][j]) % M;\n    }\n  }\n}\nlong long CC(long long n, long long r) { return triangle[n][r]; }\nint main() {\n  makeTriangle();\n  long long k, i, nw, t, ans = 1;\n  cin >> k;\n  vector<long long> c(k);\n  for (i = 0; i < k; i++) {\n    cin >> c[i];\n  }\n  if (k == 1) {\n    cout << 1;\n    return 0;\n  }\n  t = c[0];\n  for (i = 1; i < k; i++) {\n    nw = c[i] - 1;\n    t += nw;\n    if (nw) ans = (ans * CC(t, nw)) % M;\n    t++;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\n\n\n/**\n *\n * @author Diego\n */\npublic class MainC {\n\n    static long MOD = 1000000007;\n    static long fact[] = new long[1003];\n            \n    static long pow(long a, long e) {\n        if(e==0) return 1;\n        long p = pow(a, e>>1L);\n        if((e&1)!=0) {\n            return p*p % MOD *a %MOD;\n        } else {\n            return p*p % MOD;\n        }\n    }\n    \n    static long comb(int n, int r) {\n        long aux = fact[n-r]*fact[r] % MOD;\n        return fact[n] * pow(aux, MOD -2) % MOD;\n    }\n    \n    public static void main(String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int k = Integer.parseInt(in.readLine());\n        int c[] = new int[k];\n        int sum = 0;\n        for (int i = 0; i < c.length; i++) {\n            c[i] = Integer.parseInt(in.readLine());\n            sum += c[i];\n        }\n        fact[0] = 1;\n        for (int i = 1; i < fact.length; i++) {\n            fact[i] = fact[i-1]*i%MOD;\n        }\n        long ans = 1;\n        for(int i=k-1; i>=0; i--) {\n            ans = ans * comb(sum - 1, c[i] - 1) % MOD;\n            sum-=c[i];\n        }\n        System.out.println(ans);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long m = 1002, n, r, s = 0, i, j, p = 1, a[1010][1010];\nint main() {\n  for (i = 1; i < m; i++)\n    for (j = 2, a[i][1] = 1; j <= i; j++)\n      (a[i][j] += a[i - 1][j] + a[i - 1][j - 1]) %= 1000000007;\n  for (cin >> n, i = 0; i < n; i++)\n    cin >> r, s += r, (p *= a[s][r]) %= 1000000007;\n  cout << p << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def fact(n):\n    r = 1\n    for i in range(1, n + 1):\n        r *= i\n    return r\n\n\n\nn = int(input())\nc = [int(input()) for i in range(n)]\nr = 1\nu = c[0] - 1\nd = 0\n\nfor i in range(1, n):\n    u += c[i]\n    d += c[i-1]\n    r *= fact(u) // fact(d) // fact(c[i] - 1)\n\nprint(r % 1000000007)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, x, y, l, r;\ndouble a, b, c, d, q;\nvector<int> V;\nvector<vector<int> > D;\nstring s, k, z;\nlong long res = 0;\ndouble eps = 0.000000001;\nconst int INF = 1000000007;\nconst int MAXNUM = 1005;\nlong long arr[MAXNUM][MAXNUM] = {0};\nint main() {\n  arr[0][0] = 1;\n  for (int i = 1; i < MAXNUM; i++) {\n    arr[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1]) % INF;\n    }\n  }\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> m;\n    V.push_back(m);\n  }\n  m = 0;\n  res = 1;\n  for (int i = 0; i < n; i++) {\n    res = (res * arr[m + V[i] - 1][V[i] - 1]) % INF;\n    m += V[i];\n  }\n  cout << res % INF << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long k;\nlong long c[1010];\nlong long s[1010];\nlong long ncr[1000][1000];\nvoid init() {\n  ncr[0][0] = 1;\n  for (long long i = 1; i < 1000; i++)\n    for (long long j = 0; j <= i; j++) {\n      ncr[i][j] = ncr[i - 1][j];\n      if (j > 0) ncr[i][j] = ((ncr[i][j] + ncr[i - 1][j - 1]) % 1000000007);\n    }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  init();\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  s[0] = c[0];\n  for (int i = 1; i < k; i++) s[i] = s[i - 1] + c[i];\n  long long q = 1;\n  for (int i = 1; i < k; i++) {\n    q = (q * ncr[s[i] - 1][c[i] - 1]) % 1000000007;\n  }\n  cout << q;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Cfone {\n\tstatic final long mod = 1000000007;\n\tstatic long[] fact = new long[1000010];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong[] col = new long[1010];\n\t\tfact[0] = 1;\n\t\tfor ( long i = 1 ; i<=1000000 ; ++i ) {\n\t\t\tfact[(int) i] = fact[(int) (i-1)] * i;\n\t\t\tfact[(int) i] %= mod;\n\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tlong sum = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tfor ( int i = 1 ; i<=n ; ++i ) {\n\t\t\t\tcol[i] = sc.nextLong();\n\t\t\t\tsum += col[i];\n\t\t\t}\n\t\t\tlong res = 1;\n\t\t\tfor ( int i = n ; i>=1 ; --i ) {\n\t\t\t\tres *= cal( sum-1 , col[i]-1 );\n\t\t\t\tres %= mod;\n\t\t\t\tsum -= col[i];\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tpublic static long cal( long n , long m ) {\n\t\tif ( n==m || m==0 ) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn fact[(int)n] * fastpow(fact[(int)m]*fact[(int)(n-m)]%mod,mod-2)%mod;\n\t}\n\tpublic static long fastpow(long x,long y) {\n\t\tlong res = 1;\n\t\twhile ( y>0 ) {\n\t\t\tif ( (y&1)==1 ) {\n\t\t\t\tres *= x;\n\t\t\t\tres %= mod;\n\t\t\t}\n\t\t\tx *= x;\n\t\t\tx %= mod;\n\t\t\ty >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class KyoyaAndColoredBalls {\n\tprivate static final int MOD = 1000000007;\n\t\n    public static void main(String[] args) {\n        FasterScanner sc = new FasterScanner();\n        \n        int K = sc.nextInt();\n        int[] A = sc.nextIntArray(K);\n        \n        final long[][] C = computeCombinations(1111);\n        long tot = 1;\n        int len = 0;\n        for (int i = 0; i < K; i++) {\n        \ttot *= C[len + A[i] - 1][len];\n        \ttot %= MOD;\n        \tlen += A[i];\n        }\n        System.out.println(tot);\n    }\n    \n    /**\n     * Computes all the combinations (i.e. Pascal's triangle) for the given levels.\n     * For example, combos[n][k] = (n choose k).\n     */\n    public static long[][] computeCombinations(int n) {\n    \tlong[][] combos = new long[n + 1][n + 1];\n    \tcombos[0][0] = 1;\n    \tfor (int r = 1; r <= n; r++) {\n    \t\tcombos[r][0] = 1;\n    \t\tfor (int c = 1; c <= r; c++) {\n    \t\t\tcombos[r][c] = (combos[r - 1][c - 1] + combos[r - 1][c]) % MOD;\n    \t\t}\n    \t}\n    \treturn combos;\n    }\n    \n\tpublic static class FasterScanner {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t        \n\t    public int[] nextIntArray(int n) {\n\t        int[] arr = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            arr[i] = nextInt();\n\t        }\n\t        return arr;\n\t    }\n        \n\t\tpublic long[] nextLongArray(int n) {\n\t\t    long[] arr = new long[n];\n\t\t    for (int i = 0; i < n; i++) {\n\t\t        arr[i] = nextLong();\n\t\t    }\n\t\t    return arr;\n\t\t}\n\n\t    private boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "#! /usr/bin/env python3\n\nk = int(input())\nc = [int(input()) for _ in range(k)]\nMOD = (10 ** 9 + 7)\n\ndef fact(x):\n    prod = 1\n    for i in range(1, x + 1):\n        prod *= i\n    return prod\n\ndef C(n, k):\n    prod = 1\n    for i in range(n - k + 1, n + 1):\n        prod *= i\n    return (prod // fact(k)) % MOD\n\nprod = 1\nc_sum = -1\nfor c_i in c:\n    c_sum += c_i\n    prod *= C(c_sum, c_i - 1)\n    prod %= MOD\n\nprint(prod)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1009];\nint k;\nlong long fact[1009];\nlong long mpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (1LL * res * a) % 1000000007;\n    b = b / 2;\n    a = (1LL * a * a) % 1000000007;\n  }\n  return res;\n}\nlong long nCr(int a, int b) {\n  return (((fact[a] * mpow(fact[b], 1000000007 - 2)) % 1000000007) *\n          mpow(fact[a - b], 1000000007 - 2)) %\n         1000000007;\n}\nint main() {\n  cin >> k;\n  for (int i = 0; i < k; i++) cin >> c[i];\n  fact[0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    fact[i] = (1LL * fact[i - 1] * i) % 1000000007;\n  }\n  long long res = 1;\n  long long sum = c[0];\n  for (int i = 1; i < k; i++) {\n    sum += c[i];\n    long long temp = nCr(sum - 1, c[i] - 1);\n    res = (1LL * res * temp) % 1000000007;\n  }\n  res = res % 1000000007;\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT min(T a, T b, T c) {\n  return min(a, min(b, c));\n}\ntemplate <class T>\nT min(T a, T b, T c, T d) {\n  return min(a, min(b, min(c, d)));\n}\ntemplate <class T>\nT max(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <class T>\nT max(T a, T b, T c, T d) {\n  return max(a, max(b, max(c, d)));\n}\nbool cmp(const int& a, const int& b) { return a > b; }\nint a[5007];\nlong long f[5007];\ninline long long power(long long n, long long k) {\n  if (k == 0LL) return 1LL;\n  long long tmp = power(n, k / 2LL) % 1000000007LL;\n  if (k % 2) return (((tmp * tmp) % 1000000007LL) * n) % 1000000007LL;\n  return (tmp * tmp) % 1000000007LL;\n}\ninline long long com(int n, int k) {\n  return (\n      f[n] *\n      (power(((long long)f[k] * f[n - k]) % 1000000007LL, 1000000007LL - 2) %\n       1000000007LL) %\n      1000000007LL);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (n); ++i) scanf(\"%d\", &a[i]);\n  f[0] = 1LL;\n  for (int i = (1); i <= (2000); ++i) f[i] = (f[i - 1] * i) % 1000000007LL;\n  int sum = 0;\n  long long ans = 1LL;\n  for (int i = (1); i <= (n); ++i) {\n    sum += a[i];\n    ans *= com(sum - 1, a[i] - 1) % 1000000007LL;\n    ans %= 1000000007LL;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long jc[1000010], c[1010];\nlong long poww(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b % 2) ans = ans * a % 1000000007;\n    b = b >> 1;\n    a = a * a % 1000000007;\n  }\n  return ans;\n}\nint main(void) {\n  int i;\n  long long ans = 1, tot = 0, k;\n  jc[0] = 1;\n  for (i = 1; i < 1000010; i++) jc[i] = jc[i - 1] * i % 1000000007;\n  scanf(\"%I64d\", &k);\n  for (i = 0; i < k; i++) {\n    scanf(\"%I64d\", &c[i]);\n    tot += c[i];\n  }\n  for (i = k - 1; i >= 0; i--) {\n    ans = ans *\n          (jc[tot - 1] *\n           (poww(jc[c[i] - 1] * jc[tot - c[i]] % 1000000007, 1000000007 - 2) %\n            1000000007) %\n           1000000007) %\n          1000000007;\n    tot -= c[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint k = sc.nextInt();\n\t\tint[] c = sc.nextIntArray(k);\n\t\tpascal();\n\t\tlong ans = 1;\n\t\tint sukima = c[0] + 1;\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\tans = (ans * com[sukima + c[i] - 2][c[i] - 1]) % MOD;\n\t\t\tsukima += c[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tint[][] com = new int[1001][1001];\n\n\tvoid pascal() {\n\t\tcom[0][0] = 1;\n\t\tfor (int i = 1; i <= 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (j == 0 || j == i)\n\t\t\t\t\tcom[i][j] = 1;\n\t\t\t\telse\n\t\t\t\t\tcom[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(long[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(char[] x, int a, int b) {\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tint gcd(int a, int b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tint lcm(int a, int b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class C_KyoyaAndColoredBalls {\n\n\tprivate static Scanner sc;\n\tpublic static BigInteger permutation(BigInteger intVal){\n\t\tBigInteger b = BigInteger.ONE;\n\t\t\n\t\tfor(BigInteger i = intVal ; i.compareTo(BigInteger.ONE) > 0 ; i = i.subtract(BigInteger.ONE)){\n\t\t\tb = b.multiply(i);\n\t\t}\n\t\treturn b;\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\n\t\tsc = new Scanner(System.in);\n\t\tint nBalls = sc.nextInt();\n\t\tint first = sc.nextInt();\n\t\tInteger totalBalls = first;\n\t\tBigInteger answer = new BigInteger(\"1\");\n\t\tfor(Integer i = 2 ; i <= nBalls ; i++){\n\t\t\tInteger ball = sc.nextInt();\n\t\t\ttotalBalls += ball;\n\t\t\tif(ball > 1){\n\t\t\t Integer b = totalBalls-1;\n\t\t\t \n\t\t\t BigInteger inter = permutation(new BigInteger(b.toString()));\n\t\t\t inter =  inter.divide(permutation(new BigInteger(new Integer(b-(ball-1)).toString())));\n\t\t\t inter = inter.divide(permutation(new BigInteger(new Integer(ball-1).toString())));\n\t\t\t answer = answer.multiply(inter);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(answer.mod(new BigInteger(\"1000000007\")).toString());\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\nn,ans,s = int(input()),1,0\nfor i in range(n) :\n  a = int(input())\n  ans=(ans*factorial(s+a-1)//factorial(s)//factorial(a-1))%1000000007\n  s+=a\nprint(ans)\n\n\n#copied...\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 3,
            "solution": "pt = []\nfor i in range(1000):\n    pt.append([0] * (i + 1))\n    pt[i][0] = pt[i][i] = 1\n    for j in range(1, i):\n        pt[i][j] = pt[i - 1][j - 1] + pt[i - 1][j]\nk, s, v = int(input()), int(input()), 1\nfor i in range(1, k):\n    c = int(input())\n    v = v * pt[s + c - 1][c - 1] % 1000000007\n    s += c\nprint(v)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint c[1005];\nlong long int tri[2005][2005];\nint main() {\n  int k;\n  for (int i = 0; i < 2001; ++i) {\n    tri[i][i] = tri[i][0] = 1;\n    for (int j = 1; j < i; ++j) {\n      tri[i][j] = (tri[i - 1][j - 1] + tri[i - 1][j]) % mod;\n    }\n  }\n  while (cin >> k) {\n    for (int i = 0; i < k; ++i) {\n      cin >> c[i];\n    }\n    long long int sum = 1;\n    int tot = c[0];\n    for (int i = 1; i < k; ++i) {\n      tot += c[i];\n      sum = (sum * tri[tot - 1][c[i] - 1]) % mod;\n    }\n    cout << sum << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class ColoredBalls {\n  public static int mod = 1000000007;\n  public static int MAXN = 1010;\n \n  public static void main (String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out, true);\n   \n    long[][] comb = new long[MAXN][MAXN];\n    comb[0][0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n      }\n    }\n   \n    int K = in.nextInt();\n    int[] color = new int[K];\n    for (int i = 0; i < K; i++) color[i] = in.nextInt();\n   \n    long res = 1;\n    int total = 0;\n    for (int i = 0; i < K; i++) {\n      res = (res * comb[total + color[i] - 1][color[i] - 1]) % mod;\n      total += color[i];\n    }\n   \n    out.println(res);\n    out.close();\n    System.exit(0);\n  }\n}"
        },
        {
            "language": 3,
            "solution": "k = int(input())\nres, mod, last = 1, 10**9 + 7, int(input())\ncomb = [[0]*1001 for _ in range(1001)]\ncomb[0][0] = 1\nfor i in range(1, 1001):\n    comb[i][0] = 1\n    for j in range(1, i+1):\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod\nfor _ in range(k-1):\n    to_place = int(input())\n    res = (res * comb[last+to_place-1][to_place-1]) % mod\n    last += to_place\nprint(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long C[1010][1010];\nlong long input[1010];\nvoid build() {\n  int i, j;\n  for (i = 0; i <= 1000; i++) C[i][0] = 1;\n  for (i = 0; i <= 1000; i++) C[i][i] = 1;\n  for (i = 2; i <= 1000; i++)\n    for (j = 1; j < i; j++)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % 1000000007L;\n}\nint main() {\n  build();\n  int i, j, k;\n  while (scanf(\"%d\", &k) != EOF) {\n    long long sum = 0;\n    long long ans = 1;\n    for (i = 0; i < k; i++) scanf(\"%I64d\", &input[i]);\n    for (i = 0; i < k; i++) {\n      ans = (ans * C[sum + input[i] - 1][input[i] - 1]) % 1000000007L;\n      sum += input[i];\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k = int(input())\n\nh = []\n\nfor i in range(k):\n    h.append(int(input()))\n\n\nffs = [1]\ndef f(n):\n    if n < len(ffs):\n        return ffs[n]\n    v = n * f(n-1)\n    ffs.append(v)\n    return v\n\n\ndef c(k, n):\n    return f(n) // (f(k) * f(n-k))\n\ndef cc(k, n):\n    return c(n-1, n + k-1)\n\n\ndef solve(h):\n    if len(h) == 1:\n        return 1\n\n    hh = h[:-1]\n    hh_len = sum(hh)\n\n    return solve(hh) * cc(h[-1] -1, hh_len + 1)\n\n\nr = 1\nfor i in range(len(h)):\n    r *= cc(h[i] -1, sum(h[:i]) + 1)\n\nprint(r % 1000000007)\n"
        },
        {
            "language": 3,
            "solution": "def g(): return int(input())\n\ndef ncr(n,r):\n    if 2*r > n:\n        r = n-r\n    a = 1\n    for i in range(r):\n        a = a * (n-i) // (i+1)\n    return a\n\nk = g()\nans = 1\nn2 = g()\nfor i in range(k-1):\n    n1 = n2\n    n2 += g()\n    ans = ans * ncr(n2-1,n1) % 1000000007\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "kk = 1\nf = [0] * 1001\nf[0] = 1\nfor i in range(1, 1001):\n    kk *= i\n    kk %= (10**9+7)\n    f[i] = pow(kk, 10**9+5, 10**9+7)\n\n\ndef c(n, k):\n    prod = 1\n    for i in range(n-k+1, n+1):\n        prod *= i\n        prod %= (10**9+7)\n    prod = (prod*f[k])%(10**9+7)\n    \n    return prod\nl = []\nm = []\na = 1\ns = 0\nfor i in range(int(input())):\n    x = int(input())\n    s += x\n    l.append(s-1)\n    m.append(x-1)\n\nans = 1\nfor i in range(len(l)):\n    ans = (ans*c(l[i], m[i]))%(10**9+7)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "s = int(input())\nMOD = int(1e9 + 7)\n\ncomb = [[1] + [0 for i in range(1000)] for j in range(1001)]\nfor i in range(1,1001):\n    for j in range(1,i+1):\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD\n\nres = 1\nsums = 0\nfor i in range(s):\n    x = int(input())\n    res = (res * comb[sums + x - 1][x - 1]) % MOD\n    sums += x\nprint(res)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long int fast_input(void) {\n  char t;\n  long long int x = 0;\n  long long int neg = 0;\n  t = getchar();\n  while ((t < 48 || t > 57) && t != '-') t = getchar();\n  if (t == '-') {\n    neg = 1;\n    t = getchar();\n  }\n  while (t >= 48 && t <= 57) {\n    x = (x << 3) + (x << 1) + t - 48;\n    t = getchar();\n  }\n  if (neg) x = -x;\n  return x;\n}\ninline void fast_output(long long int x) {\n  char a[20];\n  long long int i = 0, j;\n  a[0] = '0';\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x == 0) putchar('0');\n  while (x) {\n    a[i++] = x % 10 + 48;\n    x /= 10;\n  }\n  for (j = i - 1; j >= 0; j--) {\n    putchar(a[j]);\n  }\n  putchar('\\n');\n}\nlong long int power(long long int a, long long int b) {\n  long long int ans = 1;\n  while (b) {\n    if (b % 2) ans = ans * a;\n    b /= 2;\n    a *= a;\n    if (a > 1000000007) a %= 1000000007;\n    if (ans > 1000000007) ans %= 1000000007;\n  }\n  return ans;\n}\nlong long int k, c[1001], i, ans, fac[1000005], invfac[1000005], sum, bot;\nint main() {\n  k = fast_input();\n  fac[0] = 1, invfac[0] = 1;\n  sum = 0;\n  for (i = 0; i < k; i++) {\n    c[i] = fast_input();\n    sum += c[i];\n  }\n  for (i = 1; i <= sum; i++) {\n    fac[i] = fac[i - 1] * i;\n    if (fac[i] > 1000000007) fac[i] %= 1000000007;\n    invfac[i] = invfac[i - 1] * power(i, 1000000007 - 2);\n    if (invfac[i] > 1000000007) invfac[i] %= 1000000007;\n  }\n  ans = fac[sum];\n  ans *= invfac[c[0]];\n  ans %= 1000000007;\n  bot = c[0];\n  for (i = 1; i < k; i++) {\n    ans = ans * invfac[c[i]];\n    if (ans > 1000000007) ans %= 1000000007;\n    bot += c[i];\n    ans *= c[i];\n    if (ans > 1000000007) ans %= 1000000007;\n    ans = ans * invfac[bot];\n    if (ans > 1000000007) ans %= 1000000007;\n    ans = ans * fac[bot - 1];\n    if (ans > 1000000007) ans %= 1000000007;\n  }\n  fast_output(ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\n\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) / f(r) / f(n-r)\n\nk_str = raw_input()\nk = int(k_str)\n\nc = []\ns = []\nans = 1\nfor i in range(k):\n\tci_str = raw_input()\n\tc+=[int(ci_str)]\n\tif(i>0):\n\t\ts+=[s[i-1]+c[i]]\n\telse:\n\t\ts+=[c[0]]\n\n# for i in range(k):\n# \tprint str(c[i]) + \" \",\n# print\n# for i in range(k):\n# \tprint str(s[i]) + \" \",\n# print\n\nMOD = 10**9+7\nfor i in range(k):\n\tif(i>0):\n\t\tans = (ans*nCr(c[i]+s[i-1]-1, s[i-1]) % MOD)\n\nprint ans\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint k, A[1005], choose[1005][1005];\nint solve(int pos, int cnt) {\n  if (pos == 1) return 1;\n  return ((long long)solve(pos - 1, cnt - A[pos]) *\n          choose[cnt - 1][A[pos] - 1]) %\n         mod;\n}\nint main() {\n  scanf(\"%d\", &k);\n  int s = 0;\n  for (int i = 1; i <= k; i++) {\n    scanf(\"%d\", &A[i]);\n    s += A[i];\n  }\n  for (int i = 0; i <= 1001; i++) {\n    choose[i][0] = 1;\n  }\n  for (int i = 1; i <= 1001; i++) {\n    for (int j = 1; j <= 1001; j++) {\n      choose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % mod;\n    }\n  }\n  printf(\"%d\\n\", solve(k, s));\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "k = input();\nballs = [];\ni=0;\nmaxi = 0\nwhile(i<k):\n\tl = input();\n\tif(l > maxi):\n\t\tmaxi =  l\n\tballs.append(l);\n\ti+=1\nfacto = [1]\nu = 1\nwhile(u<=maxi):\n\tfacto.append(facto[u-1]*u)\n\tu+=1\nans = 1\nab_tak = 0\ni = 0;\nwhile(i<k):\n\tab_tak += 1\n\ttemp_ans = 1\n\tfreq = balls[i]\n\tj = 0\n\twhile(j<freq-1):\n\t\ttemp_ans*= ab_tak\n\t\tab_tak+=1\n\t\tj+=1\n\ttemp_ans = temp_ans/facto[freq-1]\n\tans = ans*temp_ans\n\ti+=1\n\t\nprint ans%1000000007"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007, pas[1005][1005];\nclass TaskC {\n public:\n  void solve(istream& in, ostream& out) {\n    for (int i = 0; i < 1005; i++) pas[i][0] = pas[i][i] = 1;\n    for (int i = 2; i < 1005; i++)\n      for (int j = 1; j < i; j++) {\n        pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n        pas[i][j] %= mod;\n      }\n    int k;\n    in >> k;\n    long long ans = 1;\n    vector<long long> c(k), psum(k);\n    for (int i = 0; i < k; ++i) in >> c[i];\n    partial_sum(c.begin(), c.end(), psum.begin());\n    for (int i = k - 1; i > 0; i--) {\n      ans *= pas[psum[i] - 1][c[i] - 1];\n      ans %= mod;\n    }\n    out << ans;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  TaskC solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MO = 1e9 + 7;\nlong long c[1010][1010], i, j, n, ans = 1, a[1010];\nint main() {\n  cin >> n;\n  for (i = 0; i <= 1005; i++) {\n    c[i][0] = 1;\n    c[i][i] = 1;\n    for (j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MO;\n  }\n  long long sum = 0;\n  for (i = 1; i <= n; i++) {\n    scanf(\"%ld\", &a[i]);\n    ans = ans * c[sum + a[i] - 1][a[i] - 1] % MO;\n    sum += a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Python3 function to \n# calculate nCr % p \ndef ncr(n, r, p): \n\t# initialize numerator \n\t# and denominator \n\tnum = den = 1\n\tfor i in range(r): \n\t\tnum = (num * (n - i)) % p \n\t\tden = (den * (i + 1)) % p \n\treturn (num * pow(den, \n\t\t\tp - 2, p)) % p \n\nk=int(input())\np=10**9+7\nans=1\ntotal=0\nfor i in range(k):\n    c=int(input())\n    ans*=ncr(total+c-1,total,p)\n    ans%=p\n    total+=c\nprint(ans)    "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class KyoyaAndColoredBalls {\n    static int[] arr;\n    static int[] total;\n    static Long[][] C = new Long[1 << 10][1 << 10];\n    static Long[][] dp = new Long[1 << 10][1 << 10];\n    static long mod = 1000000007;\n\n    static long C(int n, int r) {\n        if (n == 0 && r == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        if (r < 0)\n            return 0;\n        if (C[n][r] != null)\n            return C[n][r];\n        return C[n][r] = (C(n - 1, r) + C(n - 1, r - 1)) % mod;\n    }\n\n    static long go(int index, int position) {\n        if (index == arr.length) {\n            if (position == total[arr.length])\n                return 1;\n            return 0;\n        }\n        if (position > total[arr.length])\n            return 0;\n        if (dp[index][position] != null)\n            return dp[index][position];\n        long res = 0;\n        int empty = position - total[index];\n        res += C(empty, arr[index] - 1) * go(index + 1, position + 1);\n        res %= mod;\n        res += go(index, position + 1);\n        res %= mod;\n        return dp[index][position] = res;\n    }\n\n    public static void main(String[] args) {\n        InputReader r = new InputReader(System.in);\n        int n = r.nextInt();\n        arr = new int[n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = r.nextInt();\n        }\n        total = new int[n + 1];\n        for (int i = 1; i < total.length; i++) {\n            total[i] += total[i - 1];\n            total[i] += arr[i - 1];\n        }\n        System.out.println(go(0, 0));\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public InputReader(FileReader stream) {\n            reader = new BufferedReader(stream);\n            tokenizer = null;\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class a {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    \n    int n = input.nextInt();\n    int[] data = new int[n];\n    for(int i = 0; i<n; i++) data[i] = input.nextInt();\n    int soFar = 0;\n    long res = 1;\n    for(int i = 1; i<n; i++)\n    {\n        soFar += data[i-1];\n        res *= comb(soFar + data[i] - 1, data[i] - 1);\n        res %= mod;\n    }\n    out.println(res);\n    out.close();\n}\nstatic long comb(long n, long k)\n{\n    if(k >n - k) return comb(n, n-k);\n    long num = 1;\n    long denom = 1;\n    for(int i = 0; i<k; i++)\n    {\n        num = (num * (n - i))%mod;\n        denom = (denom * (i+1))%mod;\n    }\n    return (num * invmod(denom)) % mod;\n}\n//GCD - O(log(max(p, q)))\n//res[0] is gcd of p and q\n//res[1] and res[2] are values used in extended Euclidean algorithm for inverse mod\npublic static long[] gcd(long p, long q)\n{\n    if(q==0)\n        return new long[] {p, 1, 0};\n    long[] vals = gcd(q, p%q);\n    return new long[] {vals[0], vals[2], vals[1] - (p/q)*vals[2]};\n}\n//Inverse Mod - O(log(mod))\n//Returns A s.t. x*A = 1(MOD mod)\npublic static long invmod(long x)\n{\n    long[] vals = gcd(x, mod);\n    if(vals[0]>1)\n        return -1;\n    if(vals[1]>0)\n        return vals[1];\n    return mod + vals[1];\n}\nstatic long mod = (long)(1e9+7);\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n"
        },
        {
            "language": 3,
            "solution": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nfrom io import BytesIO, IOBase\nimport sys\nfrom heapq import heappush,heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,Counter,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input().rstrip()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('0')\n\nfile = 1\ndef ceil(a,b):\n    return (a+b-1)//b\n\n\n\n\ndef solve():\n\n\n    # for _ in range(ii()):\n    N = 10001\n    invfact = [0]*N\n    fact = [1]*N\n    for i in range(1,N):\n        fact[i] = (fact[i-1]*i)%mod\n    invfact[-1] = pow(fact[-1],mod-2,mod)\n    for i in range(N-2,-1,-1):\n        invfact[i] = ((i+1)*invfact[i+1])%mod\n\n    def nCr(x,y):\n        if y > x:\n            return 0\n        ans = (invfact[x-y]*invfact[y])%mod\n        ans *= fact[x]\n        ans %= mod\n        return ans\n\n    k = ii()\n    ans = 1\n    cnt = ii()\n    for i in range(1,k):\n        x = ii()\n        cnt += (x-1)\n        ans *= nCr(cnt,x-1)\n        ans %= mod\n        cnt += 1\n    print(ans)\n\n\n\n\n\n\n\n\n            \n\n\n\n\n\n    \n        \n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    if(file):\n\n        if path.exists('tmp/input.txt'):\n            sys.stdin=open('tmp/input.txt', 'r')\n            sys.stdout=open('tmp/output.txt','w')\n        else:\n            input=sys.stdin.readline\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1005][1005];\nint main() {\n  ios::sync_with_stdio(false);\n  for (long long i = 0; i < 1001; i++) dp[i][0] = 1;\n  for (long long i = 1; i < 1001; i++)\n    for (long long j = 1; j < i + 1; j++)\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % 1000000007;\n  long long n, ans = 1;\n  cin >> n;\n  long long a;\n  cin >> a;\n  for (long long i = 2; i < n + 1; i++) {\n    long long x;\n    cin >> x;\n    ans = (ans * dp[a + x - 1][x - 1]) % 1000000007;\n    a += x;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, len;\nlong long MOD = 1000000007ll;\nlong long a[1111], d[1111], cache[1111][1111];\nlong long C(long long x, long long y) {\n  if (x == y) return 1;\n  if (y == 1) return x;\n  if (y <= 0) return 1;\n  long long &ret = cache[x][y];\n  if (~ret) return ret;\n  return ret = (C(x - 1, y) + C(x - 1, y - 1)) % MOD;\n}\nint main() {\n  memset(cache, -1, sizeof(cache));\n  ios::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  d[1] = 1;\n  len = a[1];\n  for (int i = 2; i <= n; i++) {\n    d[i] = (d[i - 1] * C(len + a[i] - 1ll, a[i] - 1ll)) % MOD;\n    len += a[i];\n  }\n  cout << d[n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long comb[1001][1001];\nint col[1001];\nint k;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  comb[0][0] = 1;\n  ;\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 or j == i)\n        comb[i][j] = 1;\n      else\n        comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> col[i];\n  }\n  long long cnt = 0;\n  long long ans = 1;\n  for (int i = 1; i <= k; i++) {\n    ans = (ans * comb[cnt + col[i] - 1][col[i] - 1]) % 1000000007;\n    cnt += col[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint c[1005];\nint sum[1005];\nlong long dp[1005];\nconst int Mod = 1e9 + 7;\nint Pow(long long x, int y) {\n  if (y == 0) {\n    return 1;\n  } else if (y == 1) {\n    return x;\n  }\n  if (y % 2 == 0) {\n    return Pow(x * x % Mod, y / 2) % Mod;\n  } else {\n    return Pow(x * x % Mod, y / 2) % Mod * x % Mod;\n  }\n}\nint inv(int x) { return Pow(x, Mod - 2) % Mod; }\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n    sum[i] = sum[i - 1] + c[i];\n  }\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    int b = sum[i - 1] + c[i] - 1;\n    int a = c[i] - 1;\n    dp[i] = dp[i - 1];\n    for (int j = 1; j <= a; j++) {\n      dp[i] = (dp[i] * (b - j + 1)) % Mod;\n      dp[i] = (dp[i] * inv(j)) % Mod;\n    }\n  }\n  printf(\"%I64d\", dp[n]);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial as f\nn=int(input())\nd=0\nout=1\nfor i in range(n) :\n    m=int(input())\n    out=out*f(d+m-1)//f(d)//f(m-1)%1000000007\n   \n    d+=m\n    \nprint(out)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    final static boolean CONTEST = true;\n    //region shit\n\n    BufferedReader cin;\n    PrintWriter cout;\n    StringTokenizer stringTokenizer;\n    StringTokenizer st;\n\n\n    public static void main(String[] args) throws Exception {\n        Main sol = new Main();\n        if (CONTEST) {\n            sol.cin = new BufferedReader(new InputStreamReader(System.in));\n        } else {\n            sol.cin = new BufferedReader(new FileReader(\"input.txt\"));\n        }\n        sol.cout = new PrintWriter(System.out);\n        sol.solve();\n        sol.cin.close();\n        sol.cout.close();\n    }\n\n    String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(cin.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    //endregion\n\n\n    long[] c;\n    long[] sums;\n    final long MODULUS = 1000000007;\n    BigInteger bigModulus = BigInteger.valueOf(MODULUS);\n\n    private void solve() throws Exception {\n        int k = nextInt();\n        c = new long[k];\n        sums = new long[k];\n        sums[0] = c[0] = nextLong();\n\n        for (int i = 1; i < k; i++) {\n            c[i] = nextLong();\n            sums[i] = (sums[i - 1] + c[i]) % MODULUS;\n        }\n        long[] dp = new long[k];\n        dp[0] = 1;\n        for (int i = 1; i < k; i++) {\n            dp[i] = (ballBoxes(c[i] - 1, sums[i - 1] + 1) * dp[i - 1]) % MODULUS;\n        }\n        cout.println(dp[k - 1]);\n    }\n\n\n    private long ballBoxes(long balls, long boxes) {\n        //if (boxes == 0 || balls == 0) return 1;\n        return binomial(balls + boxes - 1, balls).mod(bigModulus).longValue();\n    }\n\n    static BigInteger binomial(long N, long K) {\n        BigInteger ret = BigInteger.ONE;\n        for (int k = 0; k < K; k++) {\n            ret = ret.multiply(BigInteger.valueOf(N - k))\n                    .divide(BigInteger.valueOf(k + 1));\n        }\n        return ret;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fr[1005];\nlong long comb[1005][1005];\nint main() {\n  for (long long i = 0; i < 1005; i++) {\n    comb[i][0] = 1;\n  }\n  for (long long i = 0; i < 1005; i++) {\n    comb[i][1] = i;\n  }\n  for (long long i = 2; i < 1005; i++) {\n    for (long long j = 2; j < 1005; j++) {\n      comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\n    }\n  }\n  long long k;\n  scanf(\"%lld\", &k);\n  long long n = 0;\n  for (long long i = 0; i < k; i++) {\n    long long in;\n    scanf(\"%lld\", &in);\n    fr[i] = in;\n    n += in;\n  }\n  long long ans = 1;\n  long long curr;\n  for (long long i = k - 1; i >= 0; i--) {\n    n--;\n    curr = comb[n][fr[i] - 1];\n    n -= (fr[i] - 1);\n    ans = (ans * curr) % 1000000007;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1000000007;\nint k, cur_balls, balls;\nlong long int pre_ans, ans;\nlong long int table[1005][1005];\nvoid C() {\n  memset(table, 0, sizeof(table));\n  for (int i = 0; i <= 1000; i++) {\n    table[i][0] = 1;\n    table[i][1] = i;\n  }\n  for (int i = 2; i <= 1000; i++) {\n    for (int j = 2; j <= i; j++) {\n      table[i][j] = table[i - 1][j] + table[i - 1][j - 1];\n      table[i][j] %= MOD;\n    }\n  }\n}\nint main(void) {\n  C();\n  while (1 == scanf(\"%d\", &k)) {\n    pre_ans = 1;\n    scanf(\"%d\", &balls);\n    if (k == 1) ans = 1;\n    for (int i = 1; i < k; i++) {\n      scanf(\"%d\", &cur_balls);\n      ans = (pre_ans * table[balls + (cur_balls - 1)][balls]) % MOD;\n      pre_ans = ans;\n      balls += cur_balls;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nlong long c[1005];\nlong long best[1005];\nlong long f_exp(long long n, long long exp) {\n  n %= MOD;\n  if (exp > 1) {\n    if (exp & 1) {\n      return (n * f_exp(n, exp - 1)) % MOD;\n    } else {\n      return f_exp(n * n, exp >> 1) % MOD;\n    }\n  }\n  return !exp ? 1LL : n;\n}\nlong long inv_mod(long long n) { return f_exp(n, MOD - 2); }\nlong long mult(initializer_list<long long> l) {\n  long long ans = 1;\n  for (auto each : l) {\n    ans = (ans * each) % MOD;\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long fat[1005];\n  fat[0] = fat[1] = 1LL;\n  for (long long i = 2; i <= 1000; i++) {\n    fat[i] = (fat[i - 1] * i) % MOD;\n  }\n  int K;\n  cin >> K;\n  for (int i = 1; i <= K; i++) {\n    cin >> c[i];\n  }\n  best[1] = 1;\n  long long total = c[1];\n  for (int i = 2; i <= K; i++) {\n    total += c[i];\n    best[i] = mult({best[i - 1], fat[total - 1], inv_mod(fat[c[i] - 1]),\n                    inv_mod(fat[(total - 1) - (c[i] - 1)])});\n  }\n  cout << best[K] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k;\n  cin >> k;\n  int a[k + 1];\n  for (int i = 0; i < k; i++) cin >> a[i];\n  long long int comb[1005][1005];\n  comb[0][0] = 1;\n  for (int i = 1; i < 1005; i++) {\n    comb[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  long long sum = 0, ans = 1;\n  for (int i = 0; i < k; i++) {\n    ans = (ans * comb[sum + a[i] - 1][a[i] - 1]) % 1000000007;\n    sum += a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\nfact = [1]\nfor i in range(1,1005):\n\tfact.append(fact[-1] * i)\n\ndef C(n,r):\n\treturn fact[n] / (fact[r] * fact[n-r])\n\nN = int(stdin.readline())\n\nc = []\nfor i in range(N):\n\tc.append(int(stdin.readline()))\n\nc = c[::-1]\nn = sum(c)\n\nans = 1\nmod = 10 ** 9 + 7\nfor e in c:\n\tans = ans * C(n - 1, e - 1) % mod\n\tn -= e\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom collections import deque\nmod = 10**9 + 7\nimport sys\n# sys.setrecursionlimit(10**6)\nfrom queue import PriorityQueue\n# def rl():\n#     return [int(w) for w in stdin.readline().split()]\nfrom bisect import bisect_right\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom math import sqrt,factorial,gcd,log2,inf,ceil\n# map(int,input().split())\n# # l = list(map(int,input().split()))\n# from itertools import permutations\nimport heapq\n# input = lambda: sys.stdin.readline().rstrip()\ninput = lambda : sys.stdin.readline().rstrip()\nfrom sys import stdin, stdout\nfrom heapq import heapify, heappush, heappop\nfrom itertools import permutations\nfrom math import factorial as f\n\ndef ncr(x, y):\n    return f(x) // (f(y) * f(x - y))\n\nn = int(input())\n\nans = 1\nsm = 0\nfor _ in range(n):\n    x = int(input())\n    ans = (ans*ncr(sm+x-1,x-1))%mod\n    sm+=x\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "s = int(input())\nMOD = 1000000007\nMAXN = 1000\ndp = [[1] + [0 for i in range(MAXN)] for j in range(MAXN + 1)]\nfor i in range(1, MAXN + 1):\n    for j in range(1, i + 1):\n        dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\nans = 1\nacum = 0\nfor i in range(s):\n    x = int(input())\n    ans = (ans * dp[acum + x - 1][x - 1]) % MOD\n    acum += x\nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author step_by_step\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        final long MOD = (long) 1e9 + 7;\n        long[] fact;\n\n        public long bin_pow(long a, long p) {\n            long res = 1;\n            while (p > 0) {\n                if ((p & 1) == 1)\n                    res = (res * a) % MOD;\n                a = (a * a) % MOD;\n                p >>= 1;\n            }\n            return res;\n        }\n\n        public long rev_mod(long x) {\n            return bin_pow(x, MOD - 2);\n        }\n\n        public long C(int n, int k) {\n            return fact[n] * rev_mod(fact[k]) % MOD * rev_mod(fact[n - k]) % MOD;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            fact = new long[1000000 + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= 1000000; i++)\n                fact[i] = fact[i - 1] * i % MOD;\n            int n = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            long res = 1;\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                res = res * C(cnt + a[i] - 1, a[i] - 1) % MOD;\n                cnt += a[i];\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class ProblemC {\n    public static void main(String[] args) throws IOException {\n        BigInteger standard = new BigInteger(\"1000000007\");\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int numColors = Integer.parseInt(in.readLine());\n        int[] colorArray = new int[numColors];\n        for (int i = 0; i < numColors; i++) {\n            colorArray[i] = Integer.parseInt(in.readLine());\n            colorArray[i]--;\n        }\n        BigInteger answer = new BigInteger(\"1\");\n        int numberInFront = 0;\n        for (int i = 0; i < numColors; i++) {\n            int top = numberInFront + colorArray[i];\n            int bottom = colorArray[i];\n            numberInFront += colorArray[i] + 1;\n            BigInteger ans = combo(top, bottom);\n            ans = ans.mod(standard);\n            answer = answer.multiply(ans);\n            answer = answer.mod(standard);\n        }\n        int realAnswer = Integer.parseInt(answer.toString());\n        System.out.println(realAnswer);\n    }\n\n    public static BigInteger combo(int n, int k) {\n        int bigger = Math.max(n-k,k);\n        int smaller = Math.min(n-k,k);\n        BigInteger fact = new BigInteger(\"1\");\n        for (int i = bigger+1; i <= n; i++) {\n            fact = fact.multiply(new BigInteger(i + \"\"));\n        }\n        for (int i = 1; i <= smaller; i++) {\n            fact = fact.divide(new BigInteger(i + \"\"));\n        }\n        return fact;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1 << 30, MOD = 1000000007;\nconst long double eps = 1e-9;\nint c[2000];\nlong long f[1000002], fobr[1000002], inv[1000002];\nlong long cnk[2000][2000];\nint s[1005];\nlong long ans[1005];\nint main() {\n  cnk[1][0] = cnk[1][1] = 1;\n  for (int i = 0; i < (int)1005; i++) cnk[i][0] = 1;\n  for (int n = 2; n < 1005; n++) {\n    for (int k = 1; k <= n; k++)\n      cnk[n][k] = (cnk[n - 1][k - 1] + cnk[n - 1][k]) % MOD;\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < (int)k; i++) scanf(\"%d\", &c[i]);\n  s[0] = c[0];\n  for (int i = 0; i < (int)k - 1; i++) s[i + 1] = s[i] + c[i + 1];\n  ans[0] = 1;\n  for (int i = 0; i < (int)k - 1; i++)\n    ans[i + 1] = (ans[i] * cnk[s[i + 1] - 1][c[i + 1] - 1]) % MOD;\n  cout << ans[k - 1];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int MOD = 1E9 + 7;\nconst int N = 1E3 + 5;\nint k;\nint c[N];\nlong long sum, dp[N], a[N][N];\nvoid solve() {\n  a[1][1] = 1;\n  a[2][1] = 1;\n  a[2][2] = 2;\n  a[2][3] = 1;\n  for (int i = 3; i < N - 3; i++) {\n    for (int j = 1; j <= i + 1; j++) {\n      a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % MOD;\n    }\n  }\n}\nint main() {\n  cin >> k;\n  memset(a, 0, sizeof(a));\n  solve();\n  for (int i = 0; i < k; i++) scanf(\"%d\", &c[i]);\n  memset(dp, 0, sizeof(dp));\n  dp[0] = 1;\n  sum = c[0] - 1;\n  for (int i = 1; i < k; i++) {\n    sum = (sum + c[i]);\n    dp[i] = (dp[i - 1] * a[sum][c[i]]) % MOD;\n  }\n  cout << dp[k - 1] % MOD << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\nconst long long MOD = 1000000007;\nlong long C[MAXN][MAXN];\nint a[MAXN];\nvoid db() {\n  C[0][0] = 1;\n  C[1][0] = 1;\n  C[1][1] = 1;\n  for (int i = 2; i < MAXN; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      C[i][j] %= MOD;\n    }\n  }\n}\nint main() {\n  int k;\n  db();\n  while (~scanf(\"%d\", &k)) {\n    long long sum = 0;\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%d\", a + i);\n      sum += a[i];\n    }\n    long long ans = 1;\n    for (int i = k; i >= 1; i--) {\n      ans *= C[sum - 1][a[i] - 1];\n      ans %= MOD;\n      sum -= a[i];\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long mod = 1000000007;\nusing namespace std;\nlong long a[1005], b[1005], c[1005][1005];\nlong long k;\nvoid init() {\n  c[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 0; j <= 1000; j++) {\n      if (!j)\n        c[i][j] = 1;\n      else\n        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n    }\n  }\n}\nint main() {\n  init();\n  scanf(\"%I64d\", &k);\n  for (long long i = 1; i <= k; i++) {\n    scanf(\"%I64d\", &a[i]);\n    b[i] = b[i - 1] + a[i];\n  }\n  long long ans = 1;\n  for (int i = k; i >= 1; i--) ans = (ans * c[b[i] - 1][a[i] - 1]) % mod;\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k=int(input())\nmod=10**9+7\nf=[0]*(10**6+1)\nf[0]=f[1]=1\nfor i in range(2,10**6+1):\n  f[i]=(f[i-1]*i)%mod\ndef comb(n,r):\n  return (f[n]*pow(f[r],mod-2,mod)*pow(f[n-r],mod-2,mod))%mod\nans=1\ncc=int(input())\nfor i in range(1,k):\n  c=int(input())\n  cc+=c\n  ans*=comb(cc-1,c-1)\n  ans%=mod\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e3 + 5;\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nint arr[MAXN];\nlong long C[MAXN][MAXN];\nvoid precalc() {\n  C[1][1] = 1;\n  for (int i = 2; i <= 1000; i++)\n    for (int j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n}\nlong long bin_mult(long long A, long long B, long long md) {\n  long long RES = 0;\n  while (B) {\n    if (B & 1) RES = (RES + A) % md;\n    A = (A + A) % md;\n    B >>= 1;\n  }\n  return RES;\n}\nint main() {\n  precalc();\n  int N = 0;\n  long long RES = 1;\n  scanf(\"%i\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%i\", &arr[i]);\n  long long prevI = arr[1];\n  for (int i = 2; i <= N; i++) {\n    RES = bin_mult(RES, C[arr[i] + prevI][arr[i]], MOD);\n    prevI += arr[i];\n  }\n  printf(\"%I64d\", RES);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        InputReader in = new InputReader();\n        PrintWriter out = new PrintWriter(System.out);\n        final int mod=1000000007;\n        long [][]C=new long[1005][1005];\n        C[0][0]=1;\n        for(int i=1;i<=1000;i++)\n        {\n            C[i][0]=1;\n            for(int j=1;j<=i;j++)\n                C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n        }\n        int n=in.nextInt();\n        int []a=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=in.nextInt();\n        long ans=1;\n        int sum=0;\n        for(int i=0;i<n;i++)\n        {\n            sum+=a[i];\n            ans=(ans*C[sum-1][a[i]-1])%mod;\n        }\n        out.println(ans);\n        out.close();\n        System.exit(0);\n    }\n}\n\nclass InputReader\n{\n    BufferedReader buf;\n    StringTokenizer tok;\n    InputReader()\n    {\n        buf = new BufferedReader(new InputStreamReader(System.in));\n    }\n    boolean hasNext()\n    {\n        while(tok == null || !tok.hasMoreElements()) \n        {\n            try\n            {\n                tok = new StringTokenizer(buf.readLine());\n            } \n            catch(Exception e) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    String next()\n    {\n        if(hasNext()) \n            return tok.nextToken();\n        return null;\n    }\n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n    BigInteger nextBigInteger()\n    {\n        return new BigInteger(next());\n    }\n    BigDecimal nextBigDecimal()\n    {\n        return new BigDecimal(next());\n    }\n}"
        },
        {
            "language": 3,
            "solution": "mod = 10**9+7\nk = int(input())\nmaxi = 1001\narr = []\nfor i in range(k):\n    arr.append(int(input()))\n\nC = [[0 for i in range(maxi)] for i in range(maxi)]\n\nfor i in range(maxi):\n    for j in range(i+1):\n        if i == j:\n            C[i][j] = 1\n        else:\n            C[i][j] = C[i-1][j-1] + C[i-1][j]\n\nans = 1\ntot = arr[0]\nfor i in arr[1:]:\n    tot += i\n    ans = ans*(C[tot-1][i-1])%mod\nprint(ans%mod)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long nck[1005][1005];\nlong long m(long long a) {\n  return ((a % 1000000007) + 1000000007) % 1000000007;\n}\nlong long ncr(long long n, long long r) {\n  if (r > n) return 0ll;\n  if (n == r || r == 0) return 1ll;\n  if (nck[n][r] != 0) return nck[n][r];\n  return nck[n][r] = m(ncr(n - 1, r) + ncr(n - 1, r - 1));\n}\nint main() {\n  int k;\n  scanf(\"%d\", &k);\n  vector<int> a(k);\n  for (int &i : a) scanf(\"%d\", &i);\n  vector<long long> dp(1005);\n  dp[1] = 1;\n  long long sm = a[0];\n  for (int i = 2; i <= k; i++) {\n    sm += a[i - 1];\n    dp[i] = m(dp[i - 1] * ncr(sm - 1, a[i - 1] - 1));\n  }\n  printf(\"%lld\\n\", dp[k]);\n}\n"
        },
        {
            "language": 1,
            "solution": "# File: o (Python 3.4)\n#045c8f47ec44c634\nimport math\nn = input()\nwow = 0\nans = 1\nmod = 1000000007\nfor i in range(0,n):\n    tmp = input()\n    if (i == 0):\n        wow = wow + tmp\n    else:\n        ans = ans * math.factorial(wow + tmp - 1)/math.factorial(wow)\n        '''for j in range(1, tmp):\n            wow = wow + 1\n            ans = (ans * wow) % mod'''\n        ans = ans/math.factorial(tmp - 1) % mod\n        wow = wow + tmp\nprint ans"
        },
        {
            "language": 4,
            "solution": "// In the name of Allah the Most Merciful. \n\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\n \npublic class Main\n{\n    \n    public static long MOD = (long)1e9+7;\n    public static long [][] ncr = new long[1005][1005]; \n    \n    public static void main(String[] args) throws IOException\n    {\n        Reader sc=new Reader();\n        \n        ncr[0][0] = 1;\n        \n        for(int i=1;i<1005;i++){\n            \n            ncr[i][0] = 1;\n            \n            for(int j=1;j<=i;j++){\n                \n                ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];\n                ncr[i][j] = ncr[i][j]%MOD;\n            }\n        }\n        \n        long[] ar = new long[1005];\n        long[] sum = new long[1005];\n        \n        int k = sc.nextInt();\n        \n        for(int i=0;i<k;i++){\n            \n            ar[i] = sc.nextLong();\n        }\n        \n        sum[0] = ar[0];\n        \n        for(int i=1;i<k;i++){\n            \n            sum[i] = sum[i-1] + ar[i];\n        }\n        \n        long ans = 1;\n        \n        for(int i=0;i<k;i++){\n            \n            ans*=ncr[(int)sum[i]-1][(int)ar[i]-1];\n            ans%=MOD;\n        }\n        \n        System.out.println(ans);\n    }\n    \n    \n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//package codeforces;\n\nimport java.util.Scanner;\n\n/**\n * https://codeforces.com/problemset/problem/553/A\n * todo \u7528\u7ec4\u5408\u7684\u529e\u6cd5\u786e\u5b9e\u597d\u4e00\u4e9b\uff0c\u4e3a\u4ec0\u4e48\u81ea\u5df1\u4e00\u5b9a\u8981\u6267\u7740\u4f7f\u7528dp\u5462 \u9700\u8981\u53cd\u601d\n */\npublic class KyoyaAndColoredBalls {\n\n\tprivate static int[][] nums = new int[1001][1001];\n\n\tprivate static int MOD = 1000000007;\n\n\tprivate static void calc() {\n\n\t\tfor (int i = 0; i <= 1000; i++) {\n\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\tif (i >= j) {\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tnums[i][j] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnums[i][j] = (nums[i - 1][j] + nums[i - 1][j - 1]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint k = in.nextInt();\n\t\tint[] c = new int[k + 1];\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\n\t\tcalc();\n\n\t\tlong res = 1;\n\t\tint total = 0;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tres = (res * nums[total + c[i] - 1][c[i] - 1]) % MOD;\n\t\t\ttotal += c[i];\n\t\t}\n\n\t\tSystem.out.println(res);\n\n\t\tin.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod = 1e9 + 7;\nlong long c[1100][1100];\nint main() {\n  int n, x;\n  cin >> n;\n  cin >> x;\n  long long ans = 1, sum = x;\n  c[1][1] = c[1][0] = 1;\n  for (int i = 2; i <= 1000; i++)\n    for (int j = 0; j <= i; j++) {\n      if (j == 0) c[i][j] = 1;\n      c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n      c[i][j] %= Mod;\n    }\n  for (int i = 1; i < n; i++) {\n    cin >> x;\n    long long res = c[sum + x - 1][sum];\n    ans *= res;\n    ans %= Mod;\n    sum += x;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\na = [0]\ns = [0]\nmd = 1000000007\nfor i in range(n) :\n  x = int(input())\n  a.append(x)\n  s.append(s[len(s)-1]+x)\n\ndef factor(x) :\n  total = 1\n  for i in range(2,x+1) : total*=i\n  return total\n\nans = 1\nfor i in range(2,n+1) :\n  ans*=factor(s[i-1]+a[i]-1)//factor(s[i-1])//factor(a[i]-1)\n  ans%=md\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "MOD = 1000000007\nMAX_BALLS = 1000\n\ndef initFactors():\n\tfactors = [1]\n\tfor i in range(1, MAX_BALLS + 1):\n\t\tlast_fact = factors[-1]\n\t\tfactors.append(last_fact * i)\n\treturn factors\n\nn_colors = int(input())\nfactors = initFactors()\nballs = []\nfor i in range(n_colors):\n\tballs.append(int(input()))\n\nres = 1\nl = balls[0]\nfor i in range(1, n_colors):\n\tres *= ((factors[l + balls[i] - 1] // (factors[l] * factors[balls[i] - 1])) % MOD)\n\tl += balls[i]\nprint(res % MOD)"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class problem309_3 {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tint num=Integer.parseInt(in.readLine());\n\t\tint[] ar=new int[num];\n\t\tfor(int i=0;i<num;++i){\n\t\t\tar[i]=Integer.parseInt(in.readLine());\n\t\t}\n\t\tint sum=ar[0];\n\t\tBigInteger res=BigInteger.ONE;\n\t\tfor(int i=1;i<num;++i){\n\t\t\tsum+=ar[i];\n\t\t\tres=res.multiply(ncr(sum-1,ar[i]-1));\n\t\t}\n\t\tres=res.mod(BigInteger.valueOf(1000000007));\n\t\tSystem.out.println(\"\"+res);\n\t\tin.close();\n\t}\n\t\n\tpublic static BigInteger ncr(int n,int r){\n\t\tif(n-r<r)\n\t\t\tr=n-r;\n\t\tBigInteger ncr=BigInteger.ONE;\n\t\tfor(int j=0;j<r;++j){\n\t\t\tncr=ncr.multiply(BigInteger.valueOf((n-j)));\n\t\t\tncr=ncr.divide(BigInteger.valueOf((j+1)));\n\t\t}\n\t\treturn ncr.mod(BigInteger.valueOf(1000000007));\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nballs = []\nfor i in range (n):\n    balls.append(int(input()))\nans = 1\nurns = balls[0] + 1\n\ndef theorem(n, k): # n urns    k balls\n    ret = 1\n    for i in range(1, k+1):\n        ret = ret * (n+k-i)\n    for i in range(1, k+1):\n        ret = ret // i\n    return ret\n     \nfor i in range (1, n):\n    ans *= theorem(urns, balls[i]-1) % 1000000007\n    urns += balls[i]\n    \nprint (ans % 1000000007)\n"
        },
        {
            "language": 3,
            "solution": "MOD = int(1e9+7)\n\ndef nCr(n, r):\n    if 2 * r > n:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n-i) // (i+1)\n    return res\n \nk = int(input())\nn2 = int(input())\nres = 1\nfor i in range(k-1):\n    n1 = n2\n    n2 += int(input())\n    res = res * nCr(n2 - 1, n1) % MOD\nprint(res)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\n    public static final long MOD = (long) 1e9 + 7;\n    public static final int  N = 1002 * 1002;\n\n    private static long[] fact = new long[N];\n    private static long[] invFact = new long[N];\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        InputReader inputReader = new InputReader(in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int k = inputReader.getNextInt();\n        Integer[] values = IntStream.range(0, k)\n                .mapToObj(x -> inputReader.getNextInt())\n                .collect(Collectors.toList())\n                .toArray(new Integer[k]);\n\n        fact[0] = invFact[0] = 1;\n\n        for (int i = 1; i < N; i++) {\n            fact[i] = (fact[i-1] * i) % MOD;\n            invFact[i] = exp(fact[i], MOD -2, MOD);\n        }\n\n        long sol = 1;\n        int len = values[0];\n\n        for (int i = 1; i < k; i++) {\n            sol = (sol * comb(len+values[i]-1, values[i]-1)) % MOD;\n            len = len + values[i];\n        }\n\n        out.println(sol);\n\n        in.close();\n        out.close();\n    }\n\n    public static final long comb(int n, int k) {\n        return (((fact[n] * invFact[k]) % MOD) * invFact[n-k]) % MOD;\n    }\n\n    public static final long exp(long b, long e, long mod) {\n        long sol = 1;\n\n        while (e > 0) {\n            if ((e & 1) > 0) {\n                sol = (sol * b) % mod;\n            }\n\n            b = (b * b) % mod;\n            e = e >> 1;\n        }\n\n        return sol;\n    }\n\n    public static class InputReader {\n\n        static final String SEPARATOR = \" \";\n\n        String[] split;\n        int head = 0;\n        BufferedReader in;\n\n        public InputReader(BufferedReader in) {\n            this.in = in;\n        }\n\n        private void fillBuffer() throws RuntimeException {\n            try {\n                if (split == null || head >= split.length) {\n                    head = 0;\n                    split = in.readLine().split(SEPARATOR);\n                }\n            } catch(Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String getNextToken() throws RuntimeException {\n            fillBuffer();\n            return split[head++];\n\n        }\n\n        public int getNextInt() throws RuntimeException {\n            return Integer.parseInt(getNextToken());\n        }\n\n        public long getNextLong() throws RuntimeException {\n            return Long.parseLong(getNextToken());\n        }\n    }\n\n    public static <T> String arrayToString(T[] arr) {\n        StringBuilder stringBuilder = new StringBuilder();\n        for(T x: arr) {\n            stringBuilder.append(x + \" \");\n        }\n        return stringBuilder.toString();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nlong long int dp[2000][2000];\nint arr[10010];\nint main() {\n  int i, j, k;\n  cin >> k;\n  for (i = 0; i < k; ++i) cin >> arr[i];\n  for (i = 0; i < 2000; ++i) {\n    dp[i][0] = dp[i][i] = 1;\n    for (j = 1; j < i; ++j)\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % 1000000007;\n  }\n  int tot = 0;\n  long long int ans = 1;\n  for (i = 0; i < k; ++i) {\n    ans = (ans * dp[tot + arr[i] - 1][arr[i] - 1]) % 1000000007;\n    tot += arr[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# coding=utf-8\n\ndef com(lo, hi):\n    loo = 1\n    for i in range(1, lo + 1):\n        loo *= i\n    hii = 1\n    for i in range(hi, hi - lo, -1):\n        hii *= i\n    return hii // loo\n\n\nn = int(input())\ndata = [int(input()) for i in range(n)]\n\nans = 1\ntotal = sum(data)\nfor i in range(len(data) - 1, -1, -1):\n    ans *= com(data[i] - 1, total - 1)\n    total -= data[i]\n\nprint(ans if ans < 1000000007 else ans % 1000000007)\n"
        },
        {
            "language": 1,
            "solution": "def f(n):\n    a=1\n    for i in range(1,n+1):\n        a=a*i\n    return a\nk=input()\na=[]\nt=input()\na.append(t)\n\nsum=t\nans=1\nmod=1000000007\nfor i in range(1,k):\n    t=input()\n    a.append(t)\n    ans=ans*f(sum+a[i]-1)/f(sum)/f(a[i]-1)\n    ans=ans%mod\n    sum+=a[i]\nprint ans\n"
        },
        {
            "language": 3,
            "solution": "MOD = 1000000007\nk = int(input())\nc = [int(input()) for i in range(k)]\ntotal_c = sum(c)\ncomb = [[0]*(max(c)+1) for i in range(total_c+1)]\ncomb[0][0] = 1\nfor i in range(1,len(comb)):\n    comb[i][0] = 1\n    for j in range(1,len(comb[0])):\n        comb[i][j] = comb[i-1][j-1] + comb[i-1][j]\n        comb[i][j] %= MOD\nw = [0]*(total_c+1)\nw[0] = 1\nfor color in range(k):\n    new_w = [0]*len(w)\n    for n in range(len(new_w)):\n        new_w[n] = w[n]\n        for i in range(c[color]):\n            if n-i-1 < 0: break\n            new_w[n] += comb[n-1][i]*w[n-i-1]\n            new_w[n] %= MOD\n    w = new_w\nprint(w[total_c])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long c[1001][1001];\n  for (long long i = 0; i < 1001; i++) {\n    for (long long j = 0; j < i + 1; j++) {\n      if (i == 0 || j == 0)\n        c[i][j] = 1;\n      else\n        c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n      c[i][j] %= 1000000007;\n    }\n  }\n  long long k;\n  cin >> k;\n  long long r[k];\n  long long s = 0;\n  for (long long i = 0; i < k; i++) {\n    cin >> r[i];\n    s += r[i];\n  }\n  long long ans = 1;\n  for (long long i = k - 1; i >= 0; i--) {\n    ans = ans * c[s - 1][r[i] - 1];\n    ans %= 1000000007;\n    s -= r[i];\n  }\n  cout << ans % 1000000007;\n}\n"
        },
        {
            "language": 1,
            "solution": "\n# Author : raj1307 - Raj Singh\n# Date   : 30.01.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\nfrom math import ceil,floor,log,sqrt,factorial,pi\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\ndef ncr(n, r, p): \n    # initialize numerator \n    # and denominator \n    num = den = 1 \n    for i in range(r): \n        num = (num * (n - i)) % p \n        den = (den * (i + 1)) % p \n    return (num * pow(den,  \n            p - 2, p)) % p \n\n\n \ndef main():\n \n    \n    #for _ in range(ii()):\n    if True:\n    \n        n=ii()\n        ans=1\n        tot=0\n        for i in range(n):\n            c=ii()\n            ans*=ncr(tot+c-1,c-1,mod);\n            ans%=mod\n            tot+=c\n\n        print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n"
        },
        {
            "language": 1,
            "solution": "k=input()\nans=1\ncnt=input()\nfor x in range(1,k):\n    temp=input()\n    for i in range(1,temp):\n        cnt=cnt+1\n        ans=ans*cnt\n    for i in range(1,temp):\n        ans=ans/i\n    cnt=cnt+1\nans=ans%1000000007\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "n = 1000\nmod = 10**9 + 7\npascal = [[1]]\nfor r in range(1, n+1):\n  previous_row = pascal[-1]\n  row = [1]\n  for c in range(1, r):\n    row.append((previous_row[c-1] + previous_row[c]) % mod)\n  row.append(1)\n  pascal.append(row)\n\nk = int(input())\nlength = int(input())\nproduct = 1\nfor i in range(1, k):\n  curr = int(input())\n  product *= pascal[length + curr - 1][length]\n  product %= mod\n  length += curr\nprint(product)\n"
        },
        {
            "language": 3,
            "solution": "from math import factorial\n\nn = int(input())\n\nans = 1\ns = 0\nfor i in range(n) :\n  a = int(input())\n  ans*=factorial(s+a-1)//factorial(s)//factorial(a-1)\n  ans%=1000000007\n  s+=a\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "ans, col, mod = 1, 0, 1000000007\nC = [[1 if i <= j else 0 for i in range(1001)] for j in range(1001)]\nfor i in range(1, 1001):\n  for j in range(1, i + 1):\n    C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod\nfor _ in range(int(input())):\n  a = int(input())\n  ans *= C[col + a - 1][col]\n  ans %= mod\n  col += a\nprint(ans)\n  \n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class C {\n\n    public static void main(String[] args) {\n        int PRIME = 1000000007;\n        Scanner sc = new Scanner(System.in);\n        int k = sc.nextInt();\n        int[] c = new int[k];\n        for(int i = 0; i < k; i++) {\n            c[i] = sc.nextInt();\n        }\n        long[][] pascal = new long[1000 + 1][1000 + 1];\n        pascal[0][0] = 1;\n        for(int i=1; i< 1001;i++) {\n            pascal[i][0] = 1;\n            for(int j=1;j< 1001;j++){\n                pascal[i][j] = (pascal[i - 1][j] + pascal[i - 1][j - 1]) % PRIME;\n            }\n        }\n        int[] total_sum = new int[k];\n        total_sum[0] = c[0];\n        for(int i=1; i< c.length; i++) {\n            total_sum[i] = c[i] + total_sum[i - 1];\n        }\n        long ans = 1;\n        for(int i = 0; i < k; i++) {\n            long combo = pascal[total_sum[i] - 1][c[i] - 1];\n            ans = (ans * combo) % 1000000007;\n        }\n        System.out.println(ans);\n    }\n\n    public static void print(long[][] pascal) {\n        for(int i=0; i<10;i++) {\n            for(int j=0;j<10;j++){\n                if(pascal[i][j] != 0)\n                    System.out.print(pascal[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from math import exp\n\ndef pfold (arr):\n    return arr[0] * pfold (arr[1:]) if arr else 1\n\ndef pscan (x, arr):\n    arr = (pscan (x * arr[-1], arr[:-1]) if arr else [])\n    arr.append(x)\n    return arr\n\ndef P(n, r):\n    return pfold(range(n, n-r, -1))\n\ndef F(n):\n    return P(n, n)\n    #return reduce(op.mul, range(n, 0, -1), 1)\n\ndef C(n, r):\n    if (r > n): return 0\n    r = min(r, n-r)\n    return P(n, r)//F(r)\n\ndef AC(a, b):\n    return C(a+b-1, b-1)\n\ndef CCC(n, k):\n    return AC(n, k)/F(k)\n\ndef Cat(n):\n    return C(2*n,n+1)/n\n\ndef Cat2(n):\n    return \n\ndef dot(a,b):\n    return sum(i*j for i, j in zip(a,b))\n\ndef Catray(n):\n    arr = [1]\n    for i in range(1,n):\n        arr = arr + [dot(arr,arr[::-1])]\n    return arr\n\n# binomial distribution:\n# with an event E which has probability p of occuring every try, \n# what is the chance of E occuring exactly k times from n tries\ndef Bd (n, p, k):\n    return C(n,k)*p**k*(1-p)**(n-k)\n\n# evaluate the sum of the binomial distribution in the range [0, k]\ndef BdS (n, p, k):\n    return sum(Bd(n, p, i) for i in range(k+1))\n\ndef Normal (mu, sigma, k):\n    return 0\n\n# exponential distribution\ndef Ed (p, k):\n    return (1-p)*p**(k-1)\n\ndef EdS (p, k):\n    return 1 - p**k\n\ndef Pd (x, k):\n    return x**k/F(k) * exp(-x)\n\ndef PdS (x, k):\n    return (sum(pscan (1, [x/i for i in range (k, 0, -1)]))) * exp(-x)\n\n#def PPP(n, k, m):\n\n\n\ndef nTermsSumToXInRangeAToB(n, x, a, b): # a <= b\n     x -= a*n\n     b -= a\n     if x < 0 or x > b*n:\n         return 0\n     else:\n         return nTermsUnderASumToX(n, x, b+1, 0)\n     \n\ndef nTermsUnderASumToX(n, x, a, b):\n    if x < 0:\n        return 0\n    else:\n        return AC(x,n) - (n-b)*nTermsUnderASumToX(n, x-a, a, b+1)\n\ndef f(n, x, a, b):\n    return nTermsSumToXInRangeAToB(n, x, a, b)\n\nM = 10**9+7\nk = int(input())\nv = 1\nn = 0\nfor _ in range(k):\n    c = int(input())\n    v *= C(n+c-1,c-1)\n    v %= M\n    n+= c\nprint(v)\n    \n    \n\n\n\n\n\n \t \t    \t \t  \t\t \t\t  \t\t\t     \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if ((a == 0) || (b == 0)) return a + b;\n  return gcd(b, a % b);\n}\nlong long pow_mod(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % 1000000007;\n    a = (a * a) % 1000000007;\n    b >>= 1;\n  }\n  return res;\n}\nlong long dp[1010], arr[2010], way = 1, fact[1010], ifact[1010];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long K, i, j, ans, opop;\n  fact[0] = 1;\n  for (i = 1; i <= 1002; i++) {\n    fact[i] = ((fact[i - 1] * i) % 1000000007);\n  }\n  ifact[1002] = pow_mod(fact[1002], 1000000007 - 2);\n  for (i = 1001; i >= 0; i--) {\n    ifact[i] = ((ifact[i + 1] * (i + 1)) % 1000000007);\n  }\n  cin >> K;\n  for (i = 1; i <= K; i++) {\n    cin >> arr[i];\n  }\n  ans = arr[1];\n  for (i = 2; i <= K; i++) {\n    ans += arr[i];\n    ans--;\n    opop = ((fact[ans] *\n             ((ifact[arr[i] - 1] * ifact[ans - arr[i] + 1]) % 1000000007)) %\n            1000000007);\n    way = ((way * opop) % 1000000007);\n    ans++;\n  }\n  cout << way;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nint k, c[1010];\nlong long dp[1010][1010];\nlong long calc(int id, int ball) {\n  if (id == 1)\n    return 1;\n  else if (ball == 0)\n    return 1;\n  long long& ans = dp[id][ball];\n  if (ans == -1)\n    ans = (calc(id - 1, ball) % MOD + calc(id, ball - 1) % MOD) % MOD;\n  return ans;\n}\nint main(void) {\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    cin >> c[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  long long ans = 1;\n  int ball = 1;\n  for (int i = 0; i < k; i++) {\n    ans *= calc(ball, c[i] - 1);\n    ans %= MOD;\n    ball += c[i];\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint MOD = 1000000007;\nint dp[1001][1001];\nint main() {\n  int k;\n  cin >> k;\n  int balls[1000];\n  int n = 0;\n  for (int i = 0; i < k; i++) {\n    cin >> balls[i];\n    n += balls[i];\n  }\n  long long l = 1;\n  for (int i = 0; i <= n; i++) {\n    dp[i][0] = 1;\n    dp[i][i] = 1;\n    for (int j = 1; j <= i; j++) {\n      dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD;\n    }\n  }\n  long long ans = 1;\n  int cur = balls[0];\n  for (int i = 1; i < k; i++) {\n    cur += balls[i];\n    ans = ((ans % MOD) * (dp[cur - 1][balls[i] - 1]) % MOD) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007, pas[1005][1005];\nclass TaskC {\n public:\n  void solve(istream& in, ostream& out) {\n    for (int i = 0; i < 1005; i++)\n      for (int j = 0; j < 1005; j++) pas[0][j] = pas[i][j] = 1;\n    for (int i = 2; i < 1005; i++)\n      for (int j = 1; j < i; j++) {\n        pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n        pas[i][j] %= mod;\n      }\n    int k;\n    in >> k;\n    long long ans = 1;\n    vector<long long> c(k), psum(k);\n    for (int i = 0; i < k; ++i) in >> c[i];\n    partial_sum(c.begin(), c.end(), psum.begin());\n    for (int i = k - 1; i > 0; i--) {\n      ans *= pas[psum[i] - 1][c[i] - 1];\n      ans %= mod;\n    }\n    out << ans;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  TaskC solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long k;\nvector<long long> c;\nvector<long long> tot;\nlong long dp[1002][1002];\nlong long C[1002][1002];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> k;\n  c.resize(k + 1);\n  tot.resize(k + 1, 0);\n  tot[0] = 0;\n  c[0] = 0;\n  for (int i = 1; i <= k; i++) {\n    cin >> c[i];\n    tot[i] = tot[i - 1] + c[i];\n  }\n  for (int i = 0; i < 1001; i++) C[0][i] = 0;\n  C[0][0] = 1;\n  for (int i = 1; i <= 1001; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0) {\n        C[i][j] = 1;\n        continue;\n      }\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  memset(dp, 0, sizeof dp);\n  dp[0][0] = 1;\n  for (int i = 1; i <= k; i++) {\n    for (int j = tot[k] - (k - i); j >= tot[i]; j--) {\n      int voids = j - tot[i - 1];\n      for (int l = j - 1; l >= tot[i - 1]; l--) {\n        dp[i][j] =\n            (dp[i][j] + dp[i - 1][l] * (C[voids - 1][c[i] - 1])) % 1000000007;\n      }\n    }\n  }\n  cout << dp[k][tot[k]] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\nconst int INF = -10000000;\nconst double pi = acos(-1.0);\nint a[1010];\nint c[1010][1010];\nvoid init() {\n  for (int i = 0; i < 1010; i++) c[i][0] = 1;\n  for (int i = 1; i < 1010; i++) {\n    for (int j = 1; j <= i; j++) {\n      c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n      c[i][j] %= 1000000007;\n    }\n  }\n}\nint main() {\n  init();\n  int k, s;\n  while (scanf(\"%d\", &k) != EOF) {\n    s = 0;\n    for (int i = 0; i < k; i++) {\n      scanf(\"%d\", a + i);\n      s += a[i];\n    }\n    long long ans = 1;\n    for (int i = k - 1; i > 0; i--) {\n      ans *= (long long)c[s - 1][a[i] - 1];\n      ans %= 1000000007;\n      s -= a[i];\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1005], num[1005];\nlong long poww(long long n, long long m) {\n  long long b = 1;\n  while (m > 0) {\n    if (m & 1) b = (b * n) % 1000000007;\n    m >>= 1;\n    n = (n * n) % 1000000007;\n  }\n  return b;\n}\nlong long solve(int n, int m) {\n  return ((num[n] % 1000000007) *\n          (poww((num[m] * num[n - m]) % 1000000007, 1000000007 - 2)) %\n          1000000007) %\n         1000000007;\n}\nint main() {\n  num[0] = 1;\n  num[1] = 1;\n  for (int i = 2; i <= 1005 - 5; i++) {\n    num[i] = (num[i - 1] * i) % 1000000007;\n  }\n  long long m, n = 0;\n  scanf(\"%I64d\", &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%I64d\", &a[i]);\n    n += a[i];\n  }\n  long long answer = 1;\n  for (int i = m; i >= 1; i--) {\n    answer = (answer * solve(n - 1, a[i] - 1)) % 1000000007;\n    n -= a[i];\n  }\n  printf(\"%I64d\\n\", answer);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        \n        \n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int[] balls = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; ++i) {\n            balls[i] = scan.nextInt(); sum += balls[i];\n        }\n\n        BigInteger MOD = new BigInteger(\"1000000007\");\n        BigInteger ans = BigInteger.ONE;\n        long left = sum;\n\n        BigInteger was = BigInteger.ONE;\n        // bool ifWas = false;\n\n        for (int i = n - 1; i >= 0; --i) {\n            left--;\n\n            for (int j = 1; j <= balls[i] - 1; ++j) {\n                ans = ans.multiply(BigInteger.valueOf(left));\n                left--;\n            }\n            \n            for (int j = 1; j <= balls[i] - 1; ++j) {\n                was = was.multiply(BigInteger.valueOf(j));\n                //ans = (ans * left / j) % MOD;\n                // left--;\n            }\n        \n        }\n\n        //if (ifWas) ans = (ans / (was)) % MOD;\n        // cout << (ans) % MOD << endl;\n        System.out.println(ans.divide(was).mod(MOD));\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint c[1005];\nint sum[1005];\nlong long dp[1005];\nint C[1005][1005];\nconst int Mod = 1e9 + 7;\nvoid pre_C() {\n  C[1][0] = C[1][1] = 1;\n  for (int i = 2; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0) {\n        C[i][0] = 1;\n      } else if (j == 1) {\n        C[i][1] = i % Mod;\n      } else {\n        C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n        C[i][j] %= Mod;\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n    sum[i] = sum[i - 1] + c[i];\n  }\n  pre_C();\n  dp[1] = 1ll;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] * C[sum[i - 1] + c[i] - 1][c[i] - 1];\n    dp[i] %= Mod;\n  }\n  printf(\"%I64d\", dp[n]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class KyoyaAndColoredBalls {\n\n    public static void main(String args[]) throws IOException {\n        FastReader in = new FastReader();\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        Task.solve(in, out);\n        out.close();\n    }\n\n    static class Task {\n\n        public static void solve(FastReader in, PrintWriter out) {\n            int k = in.nextInt();\n            int[] a = new int[k];\n            int mod = 1000000007;\n            for(int i=0;i<k;i++){\n                a[i] = in.nextInt();\n            }\n\n            int[][] dp = new int[1001][1001];\n\n            for(int i=1;i<=1000;i++){\n                for (int j=0;j<=i;j++){\n                    if(j==0){\n                        dp[i][j]=1;\n                    }else if(i==j) {\n                        dp[i][j]=1;\n                    }else {\n                        dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;\n                    }\n                }\n            }\n\n            int l = a[0];\n            long w = 1;\n            for(int i=1;i<k;i++){\n//                System.out.println(\"i: \"+i);\n                int places = a[i]-1;\n//                System.out.println(\"Places: \"+places);\n                if(places==0){\n                    l++;\n                    continue;\n                }\n                w = (dp[places+l][l]*w)%mod;\n                l+=a[i];\n//                System.out.println(i+\" \"+w+\" \"+l);\n            }\n            System.out.println(w);\n        }\n\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isvowel(char c) {\n  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' ||\n      c == 'E' || c == 'I' || c == 'O' || c == 'U')\n    return true;\n  return false;\n}\nbool prime[5000001];\nint spf[5000001];\nvector<int> primes;\nvoid sieve() {\n  memset(prime, true, sizeof(prime));\n  for (int p = 2; p * p <= 5000000; p++) {\n    if (prime[p] == true) {\n      for (int i = p * p; i <= 5000000; i += p) {\n        prime[i] = false;\n        if (spf[i] == 0) spf[i] = p;\n      }\n    }\n  }\n  for (int p = 2; p <= 5000000; p++)\n    if (prime[p]) primes.push_back(p);\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long int fast_exp(long long int x, long long int n) {\n  long long int ans = 1;\n  while (n) {\n    if (n & 1) ans *= x;\n    n = n >> 1;\n    x = x * x;\n  }\n  return ans;\n}\nlong long int mod_exp(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int pre_sum[2000005];\nvector<int> adj[2000005];\nlong long int dp[2000005];\nvoid solve() {\n  dp[0] = 1;\n  for (long long int i = 1; i <= 1000; i++) {\n    dp[i] = (dp[i - 1] * i) % 1000000007;\n  }\n  long long int k, n;\n  cin >> k;\n  long long int ans = 1, sum = 0;\n  while (k--) {\n    cin >> n;\n    sum += n;\n    long long int x = dp[n - 1];\n    long long int y = dp[sum - 1];\n    long long int xinv = mod_exp(x, 1000000007 - 2, 1000000007);\n    long long int res = (y * xinv) % 1000000007;\n    x = dp[sum - 1 - (n - 1)];\n    xinv = mod_exp(x, 1000000007 - 2, 1000000007);\n    res = (res * xinv) % 1000000007;\n    ans = (ans * res) % 1000000007;\n  }\n  cout << ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t = 1;\n  while (t--) {\n    solve();\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class A {\n\n    public static int MOD = 1_000_000_007;\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        int k = scanner.nextInt();\n        int[] c = new int[k + 1];\n        for (int i = 1; i <= k; ++i){\n            c[i] = scanner.nextInt();\n        }\n\n        long[] fact = new long[1005];\n        fact[0] = 1;\n        for(int i = 1; i < 1005; ++i){\n            fact[i] = (i * fact[i - 1]) % MOD;\n        }\n\n        long ans = 1;\n        int sum = c[1];\n        for (int i = 2; i <= k; ++i){\n            long res = fact[sum + c[i] - 1] * pow(fact[c[i] - 1], MOD - 2) % MOD;\n            res = (res * pow(fact[sum], MOD - 2)) % MOD;\n            ans = (ans * res) % MOD;\n            sum += c[i];\n        }\n\n        System.out.println(ans);\n    }\n\n\n    public static long pow(long x, long n){\n        if (n == 0) return 1;\n        if (n % 2 == 0) return pow((x * x) % MOD, n / 2);\n        return (x * pow((x * x) %  MOD, n / 2)) % MOD;\n    }\n\n\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Ashish\n */\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\npublic class Main {\n\n    final int MOD = 1000000007;\n    long fact[] = new long[1001];\n    \n    private void start(InputReader in, PrintStream out) {\n        fact[0] = 1;\n        fact[1] = 1;\n        \n        for (int i = 2; i <= 1000; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        \n        \n        int k = in.nextInt();\n        int n = 0;\n        int a[] = new int[k];\n        for (int i = 0; i < k; i++) {\n            a[i] = in.nextInt();\n            n += a[i];\n        }\n        \n        long res = foo(a, n, k - 1);\n        \n        out.println(res);\n    }\n    \n    long foo(int a[], int n, int k) {\n        if (k <= 0) {\n            return 1;\n        }\n        long term0 = (fact[n - a[k]] * fact[a[k] - 1]) % MOD;\n        long term1 = ((fact[n - 1] * power(term0, MOD - 2)) % MOD); \n        \n        long npk = (term1 * foo(a, n - a[k], k - 1)) % MOD;\n                \n        return npk;\n    }\n    \n    long power(long x, long n) {\n        if (n <= 0) {\n            return 1;\n        }\n        \n        if (n == 1) {\n            return x;\n        }\n        \n        long t = power(x, n / 2);\n        \n        if (n % 2 == 0) {\n            return (t * t) % MOD;\n        } else {\n            return (((t * t) % MOD) * x) % MOD;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        //InputReader in = new InputReader(new FileInputStream(new File(\"in.txt\")));\n        //PrintStream out = new PrintStream(\"out.txt\");\n\n        InputReader in = new InputReader(System.in);\n        PrintStream out = System.out;\n\n        new Main().start(in, out);\n    }\n\n    private static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public interface SpaceCharFilter {\n\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    private class Pair<K, V> implements Serializable {\n\n        private K key;\n\n        public K getKey() {\n            return key;\n        }\n        private V value;\n\n        public V getValue() {\n            return value;\n        }\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n\n        @Override\n        public int hashCode() {\n            return key.hashCode() * 13 + (value == null ? 0 : value.hashCode());\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o instanceof Pair) {\n                Pair pair = (Pair) o;\n                if (key != null ? !key.equals(pair.key) : pair.key != null) {\n                    return false;\n                }\n                if (value != null ? !value.equals(pair.value) : pair.value != null) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class prob7 {\n  public static int max = 1000;\n  \n  public static void main (String[] args) {\n    Scanner sc = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out, true);\n    \n    long[][] comb = new long[max][max];\n    comb[0][0] = 1;\n    for (int i = 1; i < max; i++) {\n      comb[i][0] = 1;\n      for (int j = 1; j <= i; j++) {\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % 1000000007;\n      }\n    }\n    \n    int K = sc.nextInt();\n    int[] color = new int[K];\n    for (int i = 0; i < K; i++) color[i] = sc.nextInt();\n    \n    long res = 1;\n    int total = 0;\n    for (int i = 0; i < K; i++) {\n      res = (res * comb[total + color[i] - 1][color[i] - 1]) % 1000000007;\n      total += color[i];\n    }\n    \n    out.println(res);\n    out.close();\n    System.exit(0);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long int cache[1001][1001] = {\n    0,\n};\nlong long int combi(int n1, int n2) {\n  if (cache[n1][n2]) return cache[n1][n2];\n  if (n1 == n2 || n2 == 0) return cache[n1][n2] = 1;\n  return cache[n1][n2] =\n             (combi(n1 - 1, n2 - 1) + combi(n1 - 1, n2)) % 1000000007;\n}\nint main() {\n  int n, sum = 0;\n  long long int temp = 1;\n  cache[1][1] = 1;\n  int cnt[1003];\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &cnt[i]);\n  for (int i = 1; i <= n; i++) {\n    sum += cnt[i];\n    temp = (combi(sum - 1, cnt[i] - 1) * temp) % 1000000007;\n  }\n  printf(\"%lld\", temp);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class Main {\n\n    public static long inf = 1000000007;\n\n    public static void main(String args[]) throws NumberFormatException,\n            IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int i, j;\n        int k = readInt(br);\n        int[] a = new int[k];\n        for (i = 0; i < k; i++) {\n            a[i] = readInt(br);\n        }\n        BigInteger ans = new BigInteger(\"1\");\n        int sum = 0;\n        for (i = 0; i < k; i++) {\n            sum += a[i];\n        }\n        for (i = k - 1; i >= 0; i--) {\n            // System.out.println((sum-1) + \"c\" + (a[i]-1) + \" = \" +\n            // c(sum-1,a[i]-1));\n            ans = ans.multiply(c(sum-1, a[i]-1)).mod(new BigInteger(inf+\"\"));\n            sum -= a[i];\n        }\n        System.out.println(ans);\n    }\n\n    public static BigInteger c(int a, int b) {\n        BigInteger ans = new BigInteger(\"1\");\n        for (int i=1;i<=a;i++) {\n            ans = ans.multiply(new BigInteger(i+\"\"));\n        }\n        for (int i=1;i<=b;i++) {\n            ans = ans.divide(new BigInteger(i+\"\"));\n        }\n        for (int i=1;i<=a-b;i++) {\n            ans = ans.divide(new BigInteger(i+\"\"));\n        }\n        ans = ans.mod(new BigInteger(inf+\"\"));\n        return ans;\n//      long ans = 1;\n//      if (b == 0) {\n//          return 1;\n//      }\n//      if (b == 1) {\n//          return a;\n//      }\n//      int temp = a - b + 1;\n//      for (int i = a; i >= temp; i--) {\n//          ans = (ans * i) % inf;\n//          if (ans % b == 0) {\n//              ans /= b;\n//              b--;\n//          }\n//      }\n//      return ans;\n    }\n\n    public static long fact(int a) {\n        long ans = 1;\n        for (int i = 1; i <= a; i++) {\n            ans = (ans*i)%inf;\n        }\n        return ans;\n    }\n\n    public static int readInt(BufferedReader br) throws NumberFormatException,\n            IOException {\n        return Integer.parseInt(br.readLine());\n    }\n\n    public static long readLong(BufferedReader br)\n            throws NumberFormatException, IOException {\n        return Long.parseLong(br.readLine());\n    }\n\n    public static int[] readArray(BufferedReader br) throws IOException {\n        String[] arr = br.readLine().split(\" \");\n        int[] a = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            a[i] = Integer.parseInt(arr[i]);\n        }\n        return a;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7, maax = 1010;\nlong long pos[maax][maax];\nint main() {\n  int n;\n  cin >> n;\n  pos[0][0] = 1;\n  for (int i = 1; i < maax; i++) {\n    pos[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      pos[i][j] = (pos[i - 1][j] + pos[i - 1][j - 1]) % mod;\n  }\n  int col[maax];\n  for (int i = 0; i < n; i++) scanf(\"%d\", &col[i]);\n  long long sol = 1;\n  int tot = 0;\n  for (int i = 0; i < n; i++) {\n    sol *= (pos[tot + col[i] - 1][col[i] - 1]);\n    sol %= mod;\n    tot += col[i];\n  }\n  cout << sol;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author yousuf\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\n    public static int mod = 1000000007;\n    public int NCR_range = 1000;\n    long[][] ncr = new long[NCR_range+1][NCR_range+1];\n\n\n    void Cal_NCR() {\n        ncr[0][0] = 1;\n        for(int i = 1; i<=NCR_range; i++) {\n            ncr[i][0] = 1;\n            for(int j=1; j<=NCR_range; j++)\n                ncr[i][j] = ( ncr[i-1][j] + ncr[i-1][j-1])% mod ;\n        }\n    }\n\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        Cal_NCR();\n\n        int N = in.nextInt();\n        int [] colors = new int[N];\n\n        for(int i =0; i<N; i++){\n            colors[i] = in.nextInt();\n        }\n\n        int total =0;\n        long res = 1;\n        for( int i =0; i<N; i++ ){\n            res = (res * ncr[ total + colors[i] - 1][colors[i] -1])% mod;\n            total+= colors[i];\n        }\n        out.println(res);\n\n    }\n\n}\n\nclass InputReader {\n\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "//ricurb\nimport java.util.Scanner;\n\npublic class kyoya{\n\t\n\tpublic static void main(String args[]) {\n\n\t\tint k;\n\t\tint k2;\n\t\tint suma = 0;\n\t\tlong arrc[][];\n\t\tint modulo = 1000000007;\n\t\tlong out = 1;\n\n\t\tScanner n = new Scanner(System.in);\n\t\tk = n.nextInt();\n\n\t\tarrc = new long[1001][1001];\n\t\tfor (int i=0; i<=1000; i++) arrc[i][0] = 1;\n\t\t\tfor (int i=1; i<=1000; i++)\n\t\t\t\tfor (int j=1; j<=i; j++)\n\t\t\t\t\tarrc[i][j]=(arrc[i-1][j]+arrc[i-1][j-1])%modulo;\n\t\t\n\t\tfor (int i=1; i<=k; i++){\n\t\t\tk2 = n.nextInt();\n\t\t\tout = (out*arrc[k2-1+suma][k2-1])%modulo;\n\t\t\tsuma += k2;\n\t\t}\n\t\t\n\t\tSystem.out.println(out);\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "def com(n , m) :\n    ans = 1\n    for i in range(m) :\n        ans *= n-i\n    for i in range(m) :\n        ans /= i+1\n    return ans % (10**9+7)\n\ndef solve(n , m) :\n    return com(n+m-1 , n-1)\n\nn = input()\na = []\nfor i in range(n) :\n    a.append(int(input()))\n\nb = [0]\nfor i in range(n) :\n    b.append(b[i]+a[i])\n\nF = 1\nfor i in range(n) :\n    F = F * solve(b[i]+1 , a[i]-1)\n    F %= 10**9+7\n\nprint F\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[1005];\nconst int MOD = 1e9 + 7;\nlong long fact[1000001];\nlong long MyPow(long long a, long long b) {\n  long long ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * a % MOD;\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nlong long C(int n, int m) {\n  if (m > n || m < 0) return 0;\n  long long a = fact[n], b = fact[n - m] * fact[m] % MOD;\n  return a * MyPow(b, MOD - 2) % MOD;\n}\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < 1000001; ++i) fact[i] = fact[i - 1] * i % MOD;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n  int sum = arr[0];\n  long long ans = 1;\n  for (int i = 1; i < n; ++i) {\n    sum += arr[i];\n    ans = ans * C(sum - 1, arr[i] - 1) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long fact[1000001];\nlong long ifact[1000001];\nlong long pow(long long a, long long b, long long mod) {\n  if (b == 0) return 1;\n  long long temp = pow(a, b / 2, mod);\n  temp *= temp;\n  temp %= mod;\n  if (b % 2) {\n    return (temp * a) % mod;\n  }\n  return temp;\n}\nvoid calfact(int n) {\n  fact[0] = 1;\n  int i;\n  for (i = 1; i <= n; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n  }\n  long long ilast = (i * fact[i - 1]) % mod;\n  ilast = pow(ilast, mod - 2, mod);\n  ifact[n] = (ilast * (n + 1)) % mod;\n  for (i = n - 1; i >= 0; i--) {\n    ifact[i] = ((i + 1) * ifact[i + 1]) % mod;\n  }\n}\nlong long nCr(long long n, long long r) {\n  return (((fact[n] * ifact[r]) % mod) * ifact[n - r]) % mod;\n}\nint a[1004];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int i, j, k, m, x, t, y, n, flag;\n  cin >> k;\n  for (i = 0; i < k; i++) cin >> a[i];\n  calfact(1000000);\n  long long ans = 1;\n  long long sum = a[0];\n  for (i = 1; i < k; i++) {\n    ans *= nCr(a[i] - 1 + sum, sum);\n    ans %= mod;\n    sum += a[i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys, math\nfrom sys import stdin, stdout\nrem = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 6)\ntake = lambda: map(int, raw_input().split())\n\ndef help(n,r):\n    num=n+r-1\n    den=r-1\n    q=(fact[num]*pow(fact[den],rem-2,rem))%rem*(pow(fact[num-den],rem-2,rem))\n    #print num,den,q%rem\n    return q%rem\n\n\nfact=[1]\nfor i in range(1,3000):\n    fact.append((fact[-1]*i)%rem)\n\nk=input()\nans=1\nprev=1\nfor i in range(k):\n    x=input()\n    ans*=help(x-1,prev)\n    ans%=rem\n    #print prev,x-1\n    prev+=x\nprint ans\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Kyoya_and_Colored_Balls {\n\n\tpublic static void main(String[] args) {\n\t\tint lim = 1000;\n\t\tint[][] dp = new int[lim+1][lim+1];\n\t\tint mod = (int)1e9 + 7;\n\t\tfor(int i = 0; i <= lim; i++)\n\t\t{\n\t\t\tfor(int j = 0; j <= lim; j++)\n\t\t\t{\n\t\t\t\tif(i == 0) \n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i > j) continue;\n\t\t\t\tdp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod;\n\t\t\t}\n\t\t}\n\t\tScanner in = new Scanner (System.in);\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tarr[i] = in.nextInt();\n\t\t\tsum += arr[i];\n\t\t}\n\t\tin.close();\n\t\tlong ways = 1;\n\t\tfor(int i = n-1; i > 0; i--)\n\t\t{\n\t\t\tways = (ways*dp[arr[i] - 1][sum-1])%mod;\n\t\t\tsum -= arr[i];\n\t\t}\n\t\tSystem.out.println(ways);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            long c[][]=new long[1001][1001];\n            long mod=1000000007;\n            for(int i=0;i<=1000;i++)\n            {\n                  for(int j=0;j<=i;j++)\n                  {\n                        if(j==0)\n                         c[i][j]=1;\n                        else\n                         c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n                  }\n            }\n            \n            long x=1;\n            int n=Integer.parseInt(br.readLine());\n            int S=0;\n            for(int i=0;i<n;i++)\n            {\n                  int u=Integer.parseInt(br.readLine());\n                  if(u!=0)\n                   x=(x*c[S+u-1][u-1])%mod;\n                  S+=u;\n            }\n            System.out.println(x);\n      }\n}"
        },
        {
            "language": 1,
            "solution": "import math\n\n\nncol = int(raw_input())\n#print ncol\ncol = []\nn = 0\nfor i in range(0,ncol):\n    col.append(int(raw_input()))\n    n += col[i]\n#print n\n\nm = 1\nlength = col[0]\nfor i in range(1,ncol):\n    k2 = col[i]\n    m *= math.factorial(length+k2-1)/(math.factorial(k2-1)*math.factorial(length))\n    length += k2\nm = m%1000000007\nprint m       \n"
        },
        {
            "language": 3,
            "solution": "import math\nMOD = 1000000007\nMAXN = 1005\n\ndef fac(n, k):\n    res = 1\n    for i in range(n + 1 - k, n + 1):\n        res *= i\n    return res\n\nk = int(input())\nsum = 0\nans = 1\nfor i in range(0, k):\n    num = int(input())\n    sum += num\n    ans = ans * fac(sum - 1, num - 1) // fac(num - 1, num - 1)\nprint (ans % MOD)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long c[2000000] = {}, i, m = 1000000007, n, k, j, p[1001][1001] = {},\n          a[1001] = {};\nint main() {\n  long long ans = 1, f[2000] = {}, h, y[1001] = {};\n  f[1] = 1;\n  for (i = 0; i < 1001; i++) {\n    p[i][0] = 1;\n    p[0][i] = 1;\n  }\n  for (i = 1; i < 1001; i++) {\n    for (j = 1; j < 1001; j++) {\n      p[i][j] = (p[i - 1][j] + p[i][j - 1]) % m;\n    }\n  }\n  cin >> k;\n  cin >> a[1];\n  y[1] = a[1];\n  for (i = 2; i <= k; i++) {\n    cin >> a[i];\n    y[i] = a[i] + y[i - 1];\n  }\n  for (i = 2; i <= k; i++) {\n    h = p[y[i] - a[i]][a[i] - 1];\n    ans *= h;\n    ans %= m;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 3010, mod = 1e9 + 7;\nlong long k, c[N], s[N], f[N][N], dp[N];\nvoid init() {\n  for (long long i = 0; i <= N - 10; i++) f[i][i] = f[i][0] = 1;\n  for (long long i = 2; i <= N - 10; i++)\n    for (long long j = 1; j < i; j++)\n      f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;\n}\nsigned main() {\n  scanf(\"%lld\", &k);\n  for (long long i = 1; i <= k; i++)\n    scanf(\"%lld\", &c[i]), s[i] = s[i - 1] + c[i];\n  init();\n  dp[1] = 1;\n  for (long long i = 2; i <= k; i++)\n    dp[i] = (dp[i - 1] * f[s[i - 1] + c[i] - 1][c[i] - 1]) % mod;\n  printf(\"%lld\", dp[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1e9 + 7;\nint k, c[1000];\nlong long int perm[1001];\nlong long int ans;\nlong long int extgcd(long long int a, long long int b, long long int &x,\n                     long long int &y) {\n  long long int g = a;\n  x = 1;\n  y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlong long int mod_inverse(long long int a, long long int m = MOD) {\n  long long int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\nlong long int nCr(int n, int r) {\n  return (((perm[n] * mod_inverse(perm[r])) % MOD) * mod_inverse(perm[n - r])) %\n         MOD;\n}\nint main(void) {\n  int i, j;\n  scanf(\"%d\", &k);\n  for (i = 0; i < k; i++) {\n    scanf(\"%d\", c + i);\n  }\n  perm[0] = 1;\n  for (i = 1; i < 1001; i++) {\n    perm[i] = (perm[i - 1] * i) % MOD;\n  }\n  ans = 1;\n  for (i = k - 1; i >= 1; i--) {\n    int sum = 0;\n    for (j = i - 1; j >= 0; j--) {\n      sum += c[j];\n    }\n    ans = (ans * nCr(sum + c[i] - 1, c[i] - 1)) % MOD;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\nll add_mod(ll a, ll b) { return (((a + b) % MOD) + MOD) % MOD; }\nll multiply_mod(ll a, ll b) { return (((a * b) % MOD) + MOD) % MOD; }\nll pow(ll x, ll n, int m) {\n  if (n == 0) return 1;\n  ll a = pow(x, n / 2, m);\n  a = a * a % m;\n  if (n % 2 == 1) a = a * x % m;\n  return a;\n}\nll divide_mod(ll a, ll b) { return multiply_mod(a, pow(b, MOD - 2, MOD)); }\nconst int MAXN = 1010;\nint c[MAXN];\nll factorial[MAXN];\nvoid compute_factorial() {\n  factorial[0] = 1;\n  for (int i = 1; i < MAXN; i++) {\n    factorial[i] = multiply_mod(i, factorial[i - 1]);\n  }\n}\nint main() {\n  ll k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) {\n    cin >> c[i];\n    c[i]--;\n  }\n  ll res = 1;\n  int num_before = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int j = 0; j < c[i]; j++) {\n      res = multiply_mod(res, num_before + 1);\n      num_before++;\n    }\n    num_before++;\n  }\n  compute_factorial();\n  for (int i = 1; i <= k; i++) {\n    res = divide_mod(res, factorial[c[i]]);\n  }\n  cout << res << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class balls {\n    static int [] array; \n    static int n; \n    static int [] length;\n    static long [][] dp; \n    static int mod = 1000000007; \n    static long binomial(int n, int m){\n        if(m==0 || m==n){\n            return 1; \n        }\n        if(dp[n][m]!=0){\n            return dp[n][m]; \n        }\n        return dp[n][m]= (binomial(n-1, m-1) + binomial(n-1, m))%mod; \n    }\n    \npublic static void main(String[] args) throws NumberFormatException, IOException {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    n = Integer.parseInt(bf.readLine());\n    array = new int[n];\n    dp = new long [1001][1001]; \n    int l = 0; \n    long val =1; \n    int totalBalls = 0; \n    for(int i =0; i<n; i++){\n        array[i] = Integer.parseInt(bf.readLine());\n        val=(val*(binomial(array[i]+totalBalls-1, array[i]-1)))%mod; \n        totalBalls+=array[i]; \n    }\n    System.out.println(val);\n}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1003][1003];\nlong long arr[1003];\nlong long sum[1003];\nlong long cc(long long n, long long r) {\n  if (r == 0 || r == n) return 1;\n  if (dp[n][r] != -1) return dp[n][r] % 1000000007;\n  return dp[n][r] =\n             (cc(n - 1, r - 1) % 1000000007 + cc(n - 1, r) % 1000000007) %\n             1000000007;\n}\nlong long solve(long long k) {\n  if (k == 1) return 1;\n  return (solve(k - 1) % 1000000007 * cc(sum[k] - 1, arr[k] - 1) % 1000000007) %\n         1000000007;\n}\nint main() {\n  for (int i = 0; i < 1003; i++) {\n    for (int j = 0; j < 1003; j++) {\n      arr[j] = 0;\n      sum[j] = 0;\n      dp[i][j] = -1;\n    }\n  }\n  long long k;\n  cin >> k;\n  for (int i = 1; i <= k; i++) cin >> arr[i];\n  sum[1] = arr[1];\n  for (int i = 2; i <= k; i++) {\n    sum[i] = arr[i] + sum[i - 1];\n  }\n  cout << solve(k) % 1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class cb {\n\t\n    InputStream is;\n    PrintWriter out; \n \n\tstatic int mod=(int)(1e9+7);\n\tstatic long mx=Integer.MIN_VALUE;\n\tstatic long ans=0;\n\tstatic int nCrModp(int n, int r) \n    { \n    \n        int C[]=new int[r+1]; \n        Arrays.fill(C,0); \n      \n        C[0] = 1;\n        \n        for (int i = 1; i <= n; i++) \n        { \n            \n            for (int j = Math.min(i, r); j > 0; j--) \n      \n               \n                C[j] = (C[j] + C[j-1])%mod; \n        } \n        return C[r]; \n    } \n\t\n    void solve()\n    {\n\t\tint n=ni();\n\t\tint a[]=na(n);\n\t\tlong dp[]=new long[n+1];\n\t\tdp[1]=1;\n\t\tint total=a[0];\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=nCrModp(total-1+a[i-1],a[i-1]-1);\n\t\t\ttotal+=a[i-1];\n\t\t\t\t\n\t\t}\n\t\tlong ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans=((ans%mod)*(dp[i]%mod))%mod;\n\t\tout.println(ans);\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t\n\t\n \n \n \tstatic class pair\n\t{\n\t\tlong k,v;\n\t\tpublic pair(long k,long v)\n\t\t{\n\t\t\tthis.k=k;\n\t\t\tthis.v=v;\n\t\t}\n\t}\n\t\n\tpublic static long [][] multiply(long a[][],long b[][])\n\t{\n\t\tlong mul[][]=new long[2][2];\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tmul[i][j]=0;\n\t\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\t\tmul[i][j]=(mul[i][j]+(a[i][k]*b[k][j]))%mod;\n\t\t\t}\n\t\t}\n\t\treturn mul;\n\t}\n\t\n\t/* Matrix Exponention*/\n\tpublic static long [][] power(long [][] mat,int n)\n\t{\n\t\tlong res[][]=new long[2][2];\n\t\tres[0][0]=1;res[1][1]=1;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif(n%2==1)\n\t\t\t\tres=multiply(res,mat);\n\t\t\tmat=multiply(mat,mat);\n\t\t\tn/=2;\n\t\t}\n\t\treturn res;\n\t}\n\t  \n\t  \n\t  \n\t\n    //---------- I/O Template ----------\n    \n    public static void main(String[] args) { new cb().run(); }\n    void run() { \n        is = System.in; \n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  //no input \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n \n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] na(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool cheak(int x, int y, int xMax, int yMax) {\n  return x >= 0 && y >= 0 && xMax > x && yMax > y;\n}\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nconst int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1},\n          dy[8] = {0, -1, 0, 1, -1, 1, -1, 1};\nconst int mod = 1000000007;\nconst int INF = 1e9;\nconst int M = 1001;\nlong long C[M][M];\nint main() {\n  C[0][0] = C[1][1] = C[1][0] = 1;\n  for (int i = 2; i < M; i++) {\n    for (int j = 0; j <= i; ++j) {\n      long long l = j >= i ? 0 : C[i - 1][j];\n      long long r = j > 0 ? C[i - 1][j - 1] : 0;\n      C[i][j] = (l + r) % mod;\n    }\n  }\n  int k;\n  cin >> k;\n  int c[1001];\n  int sum = 0;\n  int ans = 1;\n  for (long long(i) = (0); i < (k); (i)++) {\n    cin >> c[i];\n  }\n  for (long long(i) = (0); i < (k); (i)++) sum += c[i];\n  for (int i = k - 1; i >= 1; i--) {\n    ans = (ans * C[sum - 1][c[i] - 1]) % mod;\n    sum -= c[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  int64_t k;\n  int64_t n = 0;\n  std::cin >> k;\n  std::array<std::array<int64_t, 1001>, 1001> m;\n  for (int64_t j = 0; j < 1001; ++j) {\n    m[0][j] = 0;\n  }\n  m[0][0] = 1;\n  for (int64_t n = 1; n < 1001; ++n) {\n    for (int64_t k = 0; k < 1001; ++k) {\n      if (k == 0) {\n        m[n][k] = 1;\n      } else if (k == 1) {\n        m[n][k] = n;\n      } else if (k > n) {\n        m[n][k] = 0;\n      } else {\n        m[n][k] = (m[n - 1][k - 1] + m[n - 1][k]) % 1000000007;\n      }\n    }\n  }\n  std::array<int64_t, 1001> arr;\n  for (int64_t i = 0; i < k; ++i) {\n    int64_t k_i;\n    std::cin >> k_i;\n    arr[i] = k_i;\n  }\n  int64_t res = 1;\n  int64_t sum = 0;\n  for (int64_t i = 0; i < k; ++i) {\n    int64_t kl = arr[i];\n    auto ck = m[sum + kl - 1][kl - 1];\n    res = (ck * res) % 1000000007;\n    sum += kl;\n  }\n  std::cout << res << std::endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n\"\"\"\nCodeforces Round #309 (Div. 2)\n\nProblem 554 C. Kyoya and Colored Balls\n\n@author yamaton\n@date 2015-08-17\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\nLARGE_NUMBER = 1000000007\n\n@functools.lru_cache(maxsize=None)\ndef binomial(n, k):\n    \"\"\"\n    >>> binomial(4, 0)\n    1\n    >>> binomial(4, 1)\n    4\n    >>> binomial(4, 2)\n    6\n    >>> binomial(4, 3)\n    4\n    >>> binomial(4, 4)\n    1\n    \"\"\"\n    if n < k:\n        return 0\n    elif n < 2 * k:\n        return binomial(n, n - k)\n    else:\n        numer = functools.reduce(operator.mul, range(n, n - k, -1), 1)\n        denom = functools.reduce(operator.mul, range(k, 0, -1), 1)\n        return numer // denom\n\n\ndef solve(xs):\n    n = len(xs)\n    for i in range(n):\n        if i == 0:\n            counts = 1\n        counts *= binomial(sum(xs[:i+1]) - 1, xs[i] - 1) \n        counts %= LARGE_NUMBER\n    return counts\n\n\n@functools.lru_cache(maxsize=None)\ndef helper(xs, separators):\n    print_stderr(xs, separators)\n    if xs:\n        k = xs[-1]\n        ys = xs[:-1]        \n        result = []\n        for i in range(k + 1):\n            coeff = binomial(i + (separators - 1), i)\n            out = coeff * helper(ys, separators + i - 1)\n            result.append(out)\n        return sum(result) % LARGE_NUMBER\n    else:\n        return 1\n\n\ndef print_stderr(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n = int(input())\n    xs = [int(input()) for _ in range(n)]\n    result = solve(xs)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxk = 1000 + 5;\nconst long long mod = 1000000007;\nlong long fac[maxk];\nint a[maxk];\nvoid extgcd(long long a, long long& x, long long b, long long& y,\n            long long& d) {\n  if (!b) {\n    x = 1, y = 0;\n    d = a;\n    return;\n  }\n  extgcd(b, y, a % b, x, d);\n  y -= x * (a / b);\n}\nlong long inv(long long val) {\n  long long a = val, x, b = mod, y, d;\n  extgcd(a, x, b, y, d);\n  return ((x % mod) + mod) % mod;\n}\ninline long long C(long long n, long long m) {\n  return (((fac[n] * inv(fac[n - m])) % mod) * inv(fac[m])) % mod;\n}\ninline long long H(long long n, long long m) { return C(n + m - 1, m); }\nint main() {\n  fac[0] = 1;\n  for (long long i = 1; i < maxk; i++) fac[i] = (i * fac[i - 1]) % mod;\n  int k;\n  long long ans = 1, total = 0;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) scanf(\"%d\", a + i);\n  for (int i = 0; i < k; total += a[i], i++)\n    (ans *= H(total + 1, a[i] - 1)) %= mod;\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 1,
            "solution": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2015 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\nimport math\nimport fractions\n\nmod = 1000000007\nmaxn = 1010\n\nn = int(input())\n\ncomb = [[0 for j in range(maxn)] for i in range(maxn)]\n\nfor i in range(maxn):\n    comb[i][0] = 1\n    for j in range(1, maxn):\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod\n\ncolors = []\nfor i in range(n):\n    colors.append(int(input()))\n\nres = 1\ntotal = 0\n\nfor i in range(n):\n    res = (res * comb[total+colors[i]-1][colors[i]-1]) % mod\n    total += colors[i]\n\nprint(res)    \n"
        },
        {
            "language": 3,
            "solution": "nCr = [[0 for i in range(1001)] for j in range(1001)]\nnCr[0][0] = 1\nfor i in range(1,1001):\n    nCr[i][0] = 1\n    for j in range(1,i+1):\n        nCr[i][j] = (nCr[i-1][j] + nCr[i-1][j-1]) % 1000000007\nn = int(input())\ndata = []\nfor i in range(n):\n    data.append(int(input()))\nans = 1\ntotal = 0\nfor i in range(n):\n    ans = ( ans * nCr[total + data[i] - 1][data[i] - 1] ) % 1000000007\n    total += data[i]\n    \nprint(int(ans))\n    "
        },
        {
            "language": 4,
            "solution": "import java.util.* ;\nimport java.io.* ;\n\npublic class KyoyaColoredBalls \n{\n    static long MOD = (long)1e9+7 ;\n    static boolean debug = false ;\n    public static void main(String args[]) throws Exception \n    {\n        BufferedReader bro = new BufferedReader(new InputStreamReader(System.in)) ;\n        int n = Integer.parseInt(bro.readLine());\n        int init = Integer.parseInt(bro.readLine()) ;\n        long sum = init, ans = 1L ;\n        for(int i=1;i<n;i++)\n        {\n            int k = Integer.parseInt(bro.readLine()) ;\n            long G = sum+1 ;\n            long upto = Math.min(G,k-1) ;\n            long temp = 0 ;\n            for(long g=1;k>1 && g<=upto;g++)\n            {\n                temp = (temp+(combi(G,g)*combi(k-2,g-1))%MOD)%MOD ;\n            }\n            sum += k ;\n            ans  = (ans*(temp==0?1L:temp))%MOD ;\n            if(debug)\n            {\n                System.out.println(\"temp :\"+temp);\n                System.out.println(\"i :\"+i+\" ans :\"+ans);\n            }\n        }\n        System.out.println(ans);\n\n    }\n    static long combi(long a,long b)\n    {\n        long ans = 1L ;\n        for(long k=1L;k<=b;k++)\n        {\n            // ans = (ans*a--) ;\n            // ans  = ans/k ;\n            ans = ((ans*a--)%MOD*modInverse(k, MOD))%MOD ;\n        }\n        if(debug)\n        {\n            System.out.println(\"ans :\"+ans);\n        }\n        return ans%MOD ;\n    }\n    static long modInverse(long a,long m)\n    {\n        long[] x = new long[2] ;\n        long gcd = gcdExtended(a, m, x) ;\n        return (x[0]+MOD)%MOD ;\n    }\n    static long gcdExtended(long a,long b,long[] x)\n    {\n        if(a==0)\n        {\n            x[0] = 0 ;\n            x[1] = 1 ;\n            return b ;\n        }\n        long[] x1 = new long[2] ;\n        long gcd = gcdExtended(b%a, a, x1) ;\n        x[0] = x1[1]-(b/a)*x1[0] ;\n        x[1] = x1[0] ;\n        return gcd ;\n    }\n}\n/*\n10\n100\n100\n100\n100\n100\n100\n100\n100\n100\n100\n*/"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1001;\nconst long long p = 1000000007;\nstruct gcdstruct {\n  long long y, x, d;\n};\ngcdstruct EXTENDED_EUCLID(long long a, long long b) {\n  gcdstruct aa, bb;\n  if (b == 0) {\n    aa.d = a;\n    aa.x = 1;\n    aa.y = 0;\n    return aa;\n  } else {\n    bb = EXTENDED_EUCLID(b, a % b);\n    aa.d = bb.d;\n    aa.x = bb.y;\n    aa.y = bb.x - bb.y * (a / b);\n  }\n  return aa;\n}\nlong long inverse(long long a, long long m) {\n  long long x;\n  gcdstruct aa;\n  aa = EXTENDED_EUCLID(a, m);\n  return aa.x;\n}\nlong long a[N], b[N];\nint main() {\n  long long i, j, n, sum = 0, ans = 1;\n  cin >> n;\n  for (i = 1; i < N; i++) b[i] = (inverse(i, p) + p) % p;\n  for (i = 1; i <= n; i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  for (i = n; i; i--) {\n    sum--;\n    a[i]--;\n    for (j = 1; j <= a[i]; j++) {\n      ans = (ans * sum) % p;\n      ans = (ans * b[j]) % p;\n      sum--;\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Solution\n{\n    private static boolean stdin = true;\n    private static Scanner sc;\n    private static PrintWriter wr;\n    \n    public static void main(String[] args) throws Exception\n    {\n        if (stdin)\n        {\n            sc = new Scanner(System.in);\n            wr = new PrintWriter(System.out);\n        }\n        else\n        {\n            sc = new Scanner(new File(\"input.txt\"));\n            wr = new PrintWriter(new File(\"output.txt\"));\n        }\n        \n        Run();\n        \n        sc.close();\n        wr.close();\n    }\n    \n    private static BigInteger N = BigInteger.ONE;\n    private static int nn = 0;\n    \n    private static BigInteger C(int n, int k)\n    {\n        BigInteger res, tmp = BigInteger.ONE;\n        \n        while (nn < n)\n        {\n            ++nn;\n            N = N.multiply(BigInteger.valueOf(nn));\n        }\n        \n        res = N;\n        \n        for (int i = 1; i <= k; ++i)\n            tmp = tmp.multiply(BigInteger.valueOf(i));\n        \n        for (int i = 1; i <= n - k; ++i)\n            tmp = tmp.multiply(BigInteger.valueOf(i));\n        \n        res = res.divide(tmp);\n        \n        return res;\n    }\n\n    private static void Run() throws Exception\n    {\n        int k = sc.nextInt(), n = 0;\n        BigInteger ans = BigInteger.ONE;\n        \n        for (int i = 0; i < k; ++i)\n        {\n            int cnt = sc.nextInt();\n            \n            n += cnt;\n            \n            ans = ans.multiply(C(n - 1, cnt - 1));\n        }\n        \n        BigInteger inf = BigInteger.valueOf(1000000007);\n        \n        ans = ans.subtract(ans.divide(inf).multiply(inf));\n        \n        wr.println(ans);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long com[1010][1010];\nint ball[1010];\nvoid com_init() {\n  com[0][0] = 1;\n  for (int i = 1; i < 1010; i++) {\n    com[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      com[i][j] = (com[i - 1][j] + com[i - 1][j - 1]) % mod;\n  }\n}\nlong long H(int n, int r) { return com[n + r - 1][n - 1]; }\nint main() {\n  com_init();\n  int k;\n  while (cin >> k) {\n    for (int i = 1; i <= k; i++) cin >> ball[i];\n    long long ans = 1;\n    int cur = ball[1];\n    for (int i = 2; i <= k; i++) {\n      ans = ans * H(cur + 1, ball[i] - 1) % mod;\n      cur += ball[i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class C {\n\tstatic long dp[][] = new long[1001][1001];\n\tstatic long mod = 1000000007;\n\n\tstatic long count(int len, int k) {\n\t\tif (k == 0)\n\t\t\treturn 1;\n\t\tif (len == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\treturn 0;\n\t\tif (dp[len][k] != -1)\n\t\t\treturn dp[len][k];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tans += count(len - 1, k - i);\n\t\t\tans %= mod;\n\t\t}\n\t\treturn dp[len][k] = ans;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(bf.readLine());\n\t\tint num[] = new int[n];\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < num.length; i++) {\n\t\t\tnum[i] = Integer.parseInt(bf.readLine());\n\t\t}\n\t\tlong ans = 1;\n\t\tint prevLen = num[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint m = num[i] - 1;\n\t\t\tans = ans * count(prevLen + 1, m);\n\t\t\tans %= mod;\n\t\t\tprevLen += num[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int aa[1003][1003];\nlong long int comb(int n, int m) {\n  int sum = 0;\n  if (n == 1)\n    return 1;\n  else if (m == 1 || m == n - 1)\n    return n;\n  else if (m == n || m == 0)\n    return 1;\n  else {\n    sum = sum + comb(n - 1, m) + comb(n - 1, m - 1);\n    if (sum >= 1000000007) sum = sum % 1000000007;\n  }\n  return sum;\n}\nint main() {\n  aa[0][0] = 1;\n  for (int i = 1; i < 1002; i++) {\n    aa[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      aa[i][j] = (aa[i - 1][j] + aa[i - 1][j - 1]) % 1000000007;\n    }\n  }\n  int n, j;\n  scanf(\"%d\", &n);\n  int a[n], sum = 0;\n  long long int man = 1, woman = 1;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum = sum + a[i];\n  sum--;\n  for (int i = n - 1; i >= 0; i--) {\n    j = a[i] - 1;\n    man = (man * aa[sum][j]) % 1000000007;\n    sum = sum - a[i];\n  }\n  printf(\"%I64d\", man);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "k=int(input())\nl=[int(input()) for i in range(k)]\ns=0 \nans=[0]*k \nans[0]=1 \nMOD=10**9+7 \nfact=[0]*(10**6+5)\nfact[0]=1 \nfor i in range(1,10**6+5):\n    fact[i]=(fact[i-1]%MOD*i%MOD)%MOD\ndef MI(a,MOD):\n    return pow(a,MOD-2,MOD)\ndef c(n, k):\n    if n==k or k==0:\n        return 1 \n    if n<k:\n        return 0 \n    return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\nans=1 \nsm=l[0]\nfor i in range(1,k):\n    curr=l[i]\n    ans=ans*(c(sm+curr-1,curr-1))\n    ans%=MOD \n    sm+=l[i]\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long k, c[1002], a[1002][1002], sum = 0, f[1002];\nint main() {\n  a[0][1] = 1;\n  a[1][1] = 1;\n  a[1][2] = 2;\n  for (long long i = 2; i < 1002; i++) {\n    a[0][i] = 1;\n    a[1][i] = i;\n    for (long long j = 1; j <= i; j++) {\n      a[j][i] = (a[j - 1][i - 1] + a[j][i - 1]) % 1000000007;\n    }\n  }\n  scanf(\"%I64d\", &k);\n  for (long long i = 1; i <= k; i++) {\n    scanf(\"%I64d\", &c[i]);\n  }\n  sum = c[1];\n  f[1] = 1;\n  for (long long i = 2; i <= k; i++) {\n    if (sum > 1)\n      f[i] = (f[i - 1] * a[sum][sum + c[i] - 1]) % 1000000007;\n    else if (sum == 1)\n      f[i] = (f[i - 1] * (c[i])) % 1000000007;\n    sum += c[i];\n  }\n  printf(\"%I64d\\n\", f[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int k, i, n, j;\nlong long int c[10005];\nlong long int finda(void) {\n  long long int a1 = 1;\n  for (i = 1; i <= n; i++) a1 = (a1 * i) % 1000000007;\n  for (i = 1; i <= k; i++) a1 = (a1 * c[k + 1 - i]) % 1000000007;\n  return a1;\n}\nlong long int findb() {\n  long long int b1 = 1, n1 = n;\n  for (i = 1; i <= k; i++)\n    for (j = 1; j <= c[i]; j++) b1 = (b1 * j) % 1000000007;\n  for (i = 1; i <= k; i++) {\n    b1 = (b1 * n1) % 1000000007;\n    n1 -= c[k + 1 - i];\n  }\n  return b1;\n}\nunsigned long long invert_mod(unsigned long long a, unsigned long long p) {\n  unsigned long long ex = p - 2, result = 1;\n  while (ex > 0) {\n    if (ex % 2 == 1) {\n      result = (result * a) % p;\n    }\n    a = (a * a) % p;\n    ex /= 2;\n  }\n  return result;\n}\nint main() {\n  cin >> k;\n  for (i = 1; i <= k; i++) {\n    cin >> c[i];\n    n += c[i];\n  }\n  long long int a = finda();\n  long long int b = findb();\n  long long int inv = invert_mod(b, 1000000007);\n  cout << (a * inv) % 1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::endl;\nusing std::istream;\ntemplate <typename T>\nT ioread(istream& in) {\n  T var;\n  in >> var;\n  return var;\n}\nclass Calc {\n public:\n  typedef int64_t type;\n  Calc(type divisor) : div_(divisor) {}\n  inline type multiply(type a, type b) const { return conv(a * b); }\n  inline type add(type a, type b) const { return conv(a + b); }\n\n private:\n  inline type conv(type x) const { return (x % div_); }\n  const type div_;\n};\nstatic const int MAX_BALLS = 1000;\nstatic const int MAX_N = 2 * MAX_BALLS;\nstatic const int MAX_K = MAX_BALLS;\nstatic Calc::type bc[MAX_N + 1][MAX_K + 1];\nclass WeakCompositions {\n public:\n  WeakCompositions(const Calc& calculator) : calc_(calculator) {}\n  inline Calc::type ncompos(const int n, const int k) const;\n\n private:\n  inline Calc::type combinations(const int n, const int k) const;\n  const Calc& calc_;\n};\ninline Calc::type WeakCompositions::ncompos(int n, int k) const {\n  --k;\n  n += k;\n  return combinations(n, k);\n}\ninline Calc::type WeakCompositions::combinations(int n, int k) const {\n  Calc::type& coeff = bc[n][k];\n  if (coeff) return coeff;\n  if (k == 0 || k == n) return (coeff = 1);\n  --n;\n  coeff = combinations(n, k);\n  --k;\n  coeff = calc_.add(coeff, combinations(n, k));\n  return coeff;\n}\nint main(void) {\n  using std::cin;\n  using std::cout;\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  const int K = ioread<int>(cin);\n  int nballs = 0;\n  Calc::type ncomb = 1;\n  Calc calc((Calc::type)1e9 + 7);\n  WeakCompositions wc(calc);\n  for (int color = 0; color < K; ++color) {\n    const int ci = ioread<int>(cin);\n    ncomb = calc.multiply(ncomb, wc.ncompos(ci - 1, nballs + 1));\n    nballs += ci;\n  }\n  cout << ncomb << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint C[1000 + 1][1000 + 1];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long int n;\n  cin >> n;\n  long long int i, j;\n  for (int i = 0; i <= 1000; i++) {\n    C[0][i] = 1;\n    C[i][0] = 1;\n  }\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 1; j <= 1000; j++) {\n      C[i][j] = (C[i - 1][j] + C[i][j - 1]) % MOD;\n    }\n  }\n  long long int a[n];\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  long long int ans = 1;\n  long long int sum = 0;\n  for (i = 0; i < n; i++) {\n    ans = 1LL * ans * (C[sum][a[i] - 1]) % MOD;\n    sum += a[i];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[2005][2005];\nlong long comb(long long n, long long k) {\n  if ((k == 0) || k == n) return 1;\n  if (dp[n][k] != 0) return dp[n][k];\n  long long x = comb(n - 1, k - 1) % 1000000007 + comb(n - 1, k) % 1000000007;\n  dp[n][k] = x % 1000000007;\n  x %= 1000000007;\n  return x;\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  long long ans = 1;\n  long long cnt = a[0];\n  for (long long i = 1; i < n; i++) {\n    ans *= comb(cnt + 1 + a[i] - 2, a[i] - 1);\n    cnt += a[i];\n    ans %= 1000000007;\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\nlong long modPow(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b % 2 == 0) {\n    long long x = a * a;\n    x %= 1000000007;\n    return modPow(x, b / 2);\n  }\n  return (a * modPow(a, b - 1)) % 1000000007;\n}\n"
        },
        {
            "language": 3,
            "solution": "k = int(input())\ncolors = []\nfor i in range(k) :\n    colors.append(int(input()))\n\nans = 1\naccum = colors[0]\nfor i in range(1, k):\n    for j in range(1, colors[i]):\n        ans *= (accum + j)\n    for j in range(1, colors[i]):\n        ans //= j\n    accum += colors[i]\n\nprint(ans % 1000000007)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fact[10001], invfact[10001], inv[10001];\nconst long long mod = 1000000007;\nlong long C(long long n, long long k) {\n  if (!(0 <= k && k <= n)) return 0;\n  return (((fact[n] * invfact[k]) % mod) * invfact[n - k]) % mod;\n}\nint main() {\n  fact[0] = invfact[0] = inv[1] = 1;\n  for (int i = 2; i < 10001; i++) {\n    inv[i] = mod - (mod / i) * inv[mod % i] % mod;\n  }\n  for (int i = 1; i < 10001; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    invfact[i] = (invfact[i - 1] * inv[i]) % mod;\n  }\n  int k;\n  cin >> k;\n  if (k == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n  int sum = 0;\n  vector<int> vc(k);\n  for (int i = 0; i < k; i++) {\n    cin >> vc[i];\n    sum += vc[i];\n  }\n  long long res = 1;\n  for (int i = 0; i < k; i++) {\n    sum--;\n    res = (res * C(sum, vc[k - 1 - i] - 1)) % mod;\n    sum -= vc[k - 1 - i] - 1;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class kyoya{\npublic static long mod = 1000000007;\npublic static long bi[][] = new long[1001][1001];\npublic static void main(String args[]) throws IOException{\nBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\nString tmp = \"\";\nbi[0][0]=1L;\nbi[1][0]=1L;\nbi[1][1]=1L;\nfor(int n = 2;n<1001;n++){\nbi[n][0]=1L;\nbi[n][n]=1L;\nfor(int m = 1;m<n;m++)\nbi[n][m]=(bi[n-1][m-1]+bi[n-1][m])%mod;\n}\nint tot = 0;\nint k = Integer.parseInt(lector.readLine());\nint tal[] = new int[k];\nfor(int n = 0;n<k;n++)\ntot+=(tal[k-1-n]=Integer.parseInt(lector.readLine()));\nlong res = 1L;\nfor(int n = 0;n<k;n++){\n//System.out.println((tot-1)+\" \"+(tal[n]-1));\nres=(res*bi[tot-1][tal[n]-1])%mod;\ntot-=tal[n];\n}\nSystem.out.println(res);\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst int INF = INT_MAX;\nconst int MAX_N = 1000 + 10;\nconst int MOD = 1000000007;\ntemplate <typename T>\ninline T sqr(T a) {\n  return a * a;\n};\nint sum = 0, M, K, C[MAX_N];\nlong long fact[MAX_N];\nlong long mod_pow(long long x, long long n, long long mod) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\nint main(int argc, char const *argv[]) {\n  long long ans = 1;\n  fact[0] = 1;\n  for (int i = 1; i < MAX_N; ++i) fact[i] = fact[i - 1] * i % MOD;\n  cin >> K;\n  for (int i = 0; i < K; ++i) {\n    cin >> C[i];\n    sum += C[i];\n  }\n  for (int i = K - 1; i >= 0; --i) {\n    ans *= fact[sum - 1] *\n           mod_pow(fact[C[i] - 1] * fact[sum - C[i]] % MOD, MOD - 2, MOD) % MOD;\n    ans %= MOD;\n    sum -= C[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e3 + 10;\nconst int MOD = 1e9 + 7;\nlong long fac[maxn + 10];\nlong long rfac[maxn + 10];\nlong long qpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) {\n      res = ((res * a) % MOD);\n    }\n    a = ((a * a) % MOD);\n    b >>= 1;\n  }\n  return res;\n}\nvoid init() {\n  fac[0] = fac[1] = 1;\n  for (int i = 2; i <= maxn; i++) {\n    fac[i] = ((fac[i - 1] * i) % MOD);\n  }\n  rfac[maxn] = qpow(fac[maxn], MOD - 2);\n  for (int i = maxn; i > 0; i--) {\n    rfac[i - 1] = ((rfac[i] * i) % MOD);\n  }\n}\nlong long n, sum, res = 1;\nlong long a[maxn];\nint main() {\n  ios_base::sync_with_stdio(0);\n  init();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    sum += a[i];\n  }\n  for (int i = n - 1; i > 0; i--) {\n    res =\n        ((res * ((((fac[sum - 1] * rfac[a[i] - 1]) % MOD) * rfac[sum - a[i]]) %\n                 MOD)) %\n         MOD);\n    sum -= a[i];\n  }\n  printf(\"%I64d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline long long int read() {\n  long long int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline char rch() {\n  char ch = getchar();\n  while (ch < 'a' || ch > 'z') ch = getchar();\n  return ch;\n}\nusing namespace std;\nconst unsigned long long int MOD = 1000000007;\nunsigned long long int C[1234][1234];\nvoid nck(int n, int k) {\n  int i, j;\n  for (i = 0; i <= n; i++) {\n    for (j = 0; j <= min(i, k); j++) {\n      if (j == 0 || j == i)\n        C[i][j] = 1;\n      else\n        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n    }\n  }\n}\nint main() {\n  nck(1222, 1222);\n  long long int k = read(), a[1111], total = 0;\n  unsigned long long int res = 1 % MOD;\n  for (long long int i = 0; i < k; i++) a[i] = read();\n  for (long long int i = 0; i < k; i++) {\n    res = (res * (C[total + a[i] - 1][a[i] - 1])) % MOD;\n    total += a[i];\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1001];\nunsigned long long comb[1010][1010];\nvoid init() {\n  int i, j;\n  for (i = 0; i < 1010; i++) comb[i][0] = 1;\n  for (i = 1; i < 1010; i++) {\n    for (j = 1; j <= i; j++) {\n      comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n      comb[i][j] %= 1000000007;\n    }\n  }\n}\nint main() {\n  memset(comb, 0, sizeof(comb));\n  init();\n  int n;\n  cin >> n;\n  unsigned long long dp[n + 1], s[n + 1];\n  memset(c, 0, sizeof(c));\n  s[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n    s[i] = s[i - 1] + c[i];\n  }\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    dp[i] = dp[i - 1] * comb[s[i] - 1][c[i] - 1];\n    dp[i] %= 1000000007;\n  }\n  cout << dp[n] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long use[1050][1050];\nint main() {\n  memset(use, 0, sizeof(use));\n  use[0][0] = 1;\n  for (int i = 1; i <= 1005; i++)\n    for (int j = 1; j <= i; j++) {\n      use[i][0] = 1;\n      use[i][j] = (use[i - 1][j - 1] + use[i - 1][j]) % 1000000007;\n    }\n  int w;\n  cin >> w;\n  int num[1005];\n  for (int i = 1; i <= w; i++) cin >> num[i];\n  long long ans = 1;\n  int u = 0;\n  for (int i = 1; i <= w; i++) {\n    ans = (ans * use[u + num[i] - 1][num[i] - 1]) % 1000000007;\n    u += num[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int MAX = 1005;\nlong long C[MAX][MAX];\nvoid initial() {\n  memset(C, 0, sizeof(C));\n  for (int i = 0; i < MAX; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j <= i / 2; j++)\n      C[i][j] = C[i][i - j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n  }\n}\nint main() {\n  initial();\n  int k, c[MAX];\n  while (scanf(\"%d\", &k) != EOF) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n      scanf(\"%d\", &c[i]);\n      sum += c[i];\n    }\n    long long ans = 1;\n    while (k--) {\n      ans = ans * (C[sum - 1][c[k] - 1]) % MOD;\n      sum -= c[k];\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long comb[1005][1005];\nint main() {\n  comb[0][0] = 1;\n  for (int i = 1; i <= 1000; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || j == i)\n        comb[i][j] = 1;\n      else {\n        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n        comb[i][j] %= 1000000007;\n      }\n    }\n  }\n  int n, s = 0;\n  long long ans = 1;\n  cin >> n;\n  int *a = new int[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    ans *= comb[s + a[i] - 1][a[i] - 1];\n    ans %= 1000000007;\n    s += a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1005], inc[1005], a[1005], sum[1005];\nconst long long k = 1000000007;\nlong long c(int x, int y) {\n  long long res = 1;\n  for (int i = x; i > x - y; i--) {\n    res = (res * i) % k;\n  }\n  for (int i = y; i >= 1; i--) {\n    res = (res * inc[i]) % k;\n  }\n  return res;\n}\nint main() {\n  int n;\n  cin >> n;\n  inc[1] = 1;\n  for (int i = 2; i < 1002; i++) {\n    inc[i] = k - (((k / i) * inc[k % i]) % k);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sum[0] = a[0];\n  for (int i = 1; i < n; i++) sum[i] = sum[i - 1] + a[i];\n  dp[0] = 1;\n  for (int i = 1; i < n; i++) {\n    dp[i] = c(sum[i] - 1, a[i] - 1) * dp[i - 1] % k;\n  }\n  cout << dp[n - 1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fact[2500], ifact[2500], arr[2500], su, way = 1;\nlong long pow_mod(long long A, long long B) {\n  long long res = 1;\n  while (B) {\n    if (B & 1) {\n      res = ((res * A) % 1000000007);\n    }\n    A = ((A * A) % 1000000007);\n    B >>= 1;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long i, j, N;\n  fact[0] = 1;\n  for (i = 1; i <= 2200; ++i) {\n    fact[i] = ((fact[i - 1] * i) % 1000000007);\n  }\n  ifact[2200] = pow_mod(fact[2200], 1000000007 - 2);\n  for (i = 2199; i >= 0; --i) {\n    ifact[i] = ((ifact[i + 1] * (i + 1)) % 1000000007);\n  }\n  cin >> N;\n  for (i = 0; i <= N - 1; ++i) {\n    cin >> arr[i];\n  }\n  su = arr[0];\n  for (i = 1; i <= N - 1; ++i) {\n    way = ((way * ((((fact[su + arr[i] - 1] * ifact[arr[i] - 1]) % 1000000007) *\n                    ifact[su]) %\n                   1000000007)) %\n           1000000007);\n    su += arr[i];\n  }\n  cout << way;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long a[1001], sum[1001], b[1001][1001];\nsigned main() {\n  long long k, ans = 1;\n  memset(b, 0, sizeof(b));\n  for (long long i = 1; i < 1001; i++) {\n    b[i][0] = b[i][i] = 1;\n    for (long long j = 1; j < i; j++) {\n      b[i][j] = (b[i - 1][j - 1] + b[i - 1][j]) % mod;\n    }\n  }\n  cin >> k;\n  memset(sum, 0, sizeof(sum));\n  for (long long i = 1; i <= k; i++) {\n    cin >> a[i];\n    sum[i] += sum[i - 1] + a[i];\n  }\n  for (long long i = k; i >= 1; i--) {\n    if (a[i] == 1) continue;\n    ans = (ans * b[sum[i] - 1][a[i] - 1]) % mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[1005][1005], a[1005];\nint main() {\n  int k, total = 0;\n  scanf(\"%d\", &k);\n  for (int i = 0; i < k; i++) scanf(\"%d\", &a[i]), total += a[i];\n  c[0][0] = c[1][0] = c[1][1] = 1;\n  for (int i = 2; i <= total; i++) {\n    c[i][i] = 1;\n    for (int j = 0; j < i; j++)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % 1000000007;\n  }\n  long long ans = 1;\n  for (int i = k - 1; i >= 0; i--) {\n    ans = (ans * c[total - 1][a[i] - 1]) % 1000000007;\n    total -= a[i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1001][1001];\nbool isPrime[1001];\nvector<long long> Prime;\nvoid pre1() {\n  long long i, j;\n  for (i = 2; i < 1001; i++) {\n    for (j = 2; j <= sqrt(i); j++) {\n      if (i % j == 0) {\n        isPrime[i] = false;\n        goto hell;\n      }\n    }\n    isPrime[i] = true;\n    Prime.push_back(i);\n  hell:;\n  }\n}\nlong long fpow(long long base, long long power) {\n  long long res = 1;\n  while (power > 0) {\n    if (power % 2 == 1) {\n      res *= base;\n      res %= 1000000007;\n    }\n    base = (base * base) % 1000000007;\n    power /= 2;\n    if (base < 0) {\n      base += 1000000007;\n    }\n  }\n  return res;\n}\nlong long calc(long long a, long long b) {\n  long long aa = 0, bb = b;\n  while (a / b) {\n    aa += a / b;\n    b *= bb;\n  }\n  return aa;\n}\nlong long cc(long long a, long long b) { return fpow(a, b); }\nvoid pre() {\n  memset(dp, 0, sizeof(dp));\n  memset(isPrime, false, sizeof(isPrime));\n}\nlong long nCr(long long n, long long r) {\n  long long res = 1;\n  for (long long i = 0; i < Prime.size() && Prime[i] <= n; i++) {\n    long long tmp = Prime[i];\n    long long res1, res2;\n    res1 = calc(n, tmp) - calc(n - r, tmp) - calc(r, tmp);\n    res1 = cc(tmp, res1);\n    res1 %= 1000000007;\n    res *= res1;\n    res %= 1000000007;\n    if (res < 0) {\n      res += 1000000007;\n    }\n  }\n  return res;\n}\nint main() {\n  pre();\n  pre1();\n  long long k, i, j;\n  cin >> k;\n  long long ans = 1;\n  long long sum = 0;\n  for (i = 0; i < k; i++) {\n    long long c;\n    cin >> c;\n    sum += c;\n    ans *= nCr(sum - 1, c - 1);\n    ans %= 1000000007;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-6;\nconst int maxn = 500000 + 5;\nconst long long mod = 1e9 + 7;\nconst long long p = 1e9 + 7;\nlong long arr[1000 + 5];\nlong long quick_mod(long long a, long long b) {\n  long long ans = 1;\n  a %= p;\n  while (b) {\n    if (b & 1) {\n      ans = ans * a % p;\n      b--;\n    }\n    b >>= 1;\n    a = a * a % p;\n  }\n  return ans;\n}\nlong long C(long long n, long long m) {\n  if (m > n) return 0;\n  long long ans = 1;\n  for (int i = 1; i <= m; i++) {\n    long long a = (n + i - m) % p;\n    long long b = i % p;\n    ans = ans * (a * quick_mod(b, p - 2) % p) % p;\n  }\n  return ans;\n}\nlong long Lucas(long long n, long long m) {\n  if (m == 0) return 1;\n  return C(n % p, m % p) * Lucas(n / p, m / p) % p;\n}\nint main(void) {\n  long long N;\n  cin >> N;\n  long long kd = 0;\n  long long sum = 1;\n  for (int i = (1); i <= (N); i++) {\n    cin >> arr[i];\n    arr[i] -= 1;\n    kd += arr[i];\n    sum *= Lucas(kd, arr[i]);\n    sum %= p;\n    kd += 1;\n  }\n  cout << sum << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long i, j, k, l, n, m, a[1010], c[1010][1010], f[1010];\nint main() {\n  scanf(\"%I64d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    a[i] += a[i - 1];\n  }\n  c[1][0] = c[1][1] = 1;\n  for (i = 2; i <= 1000; i++) {\n    c[i][0] = 1;\n    for (j = 1; j <= i; j++)\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % 1000000007;\n  }\n  f[1] = 1;\n  for (i = 2; i <= n; i++)\n    f[i] = (f[i - 1] * c[a[i] - 1][a[i] - a[i - 1] - 1]) % 1000000007;\n  printf(\"%I64d\\n\", f[n]);\n}\n"
        },
        {
            "language": 3,
            "solution": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nmod=10**9+7\n# sys.setrecursionlimit(10**6)\n# mxm=sys.maxsize\n# from functools import lru_cache\n\n\nfact=[1]*(1002)\nfor i in range(2,1002):\n    fact[i]=(fact[i-1]*i)%mod\n\ndef ncr(n,r):\n    num=fact[n]\n    den=(fact[n-r]*fact[r])%mod\n    return (num*(pow(den,mod-2,mod)))%mod\n\n\ndef main():\n    k=int(input())\n    dp=[0]*(k+1)\n    dp[1]=1\n    dff=0\n    m=int(input())\n    total=m\n\n    for i in range(k-1):\n        m=int(input())\n        dff=m-1\n        total+=m\n        dp[i+2]=(dp[i+1]*ncr(total-1,dff))%mod\n    \n    print(dp[k])\n        \n\n    \n\n\n\n#----------------------------------------------------------------------------------------\ndef nouse0():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse1():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse2():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class pizza {\n\tstatic final long MOD = (long) (1e9 + 7);\n\tstatic long[] fact, ifact;\n\tpublic static void main(String[] args) {\n\t\tint N = 2001;\n\t\tfact = new long[N];\n\t\tfact[0] = 1;\n\t\tfor(int i=1;i<N;i++)\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\tifact = new long[N];\n\t\tifact[N-1] = BigInteger.valueOf(fact[N-1]).modInverse(BigInteger.valueOf(MOD)).longValue();\n\t\tfor(int i=N-2;i>=0;i--)\n\t\t\tifact[i] = (ifact[i+1] * (i+1)) % MOD;\n\t\tScanner in = new Scanner(System.in);\n\t\tint k = in.nextInt();\n\t\tint cnt = 0;\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint c = in.nextInt();\n\t\t\tans *= mchoose(cnt + 1, c - 1);\n\t\t\tans %= MOD;\n\t\t\tcnt += c;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long choose(int n, int k) {\n\t\treturn (fact[n] * ifact[k] % MOD) * ifact[n-k] % MOD;\n\t}\n\n\tstatic long mchoose(int n, int k) {\n\t\treturn choose(n + k - 1, k);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int base = 1e9 + 7;\nconst int maxn = 2005;\nlong long n, a[maxn], f[maxn], c[maxn][maxn], d[maxn][maxn];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= 2000; ++i) d[0][i] = 1, c[0][i] = 1;\n  for (int i = 1; i <= 2000; ++i)\n    for (int j = 1; j <= 2000; ++j) {\n      if (j == 1)\n        c[i][j] = 1;\n      else\n        c[i][j] = d[i][j - 1];\n      d[i][j] = (d[i - 1][j] + c[i][j]) % base;\n    }\n  int num = a[1];\n  f[1] = 1;\n  for (int i = 2; i <= 2000; ++i) {\n    f[i] = (c[a[i] - 1][num + 1] * f[i - 1]) % base;\n    num += a[i];\n  }\n  cout << f[n];\n  fclose(stdin);\n  fclose(stdout);\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n/**\n *\n * @author Sourav Kumar Paul\n */\npublic class C554 {\n    public static long mod = 1000000007;\n    public static void main(String[] args) throws IOException{\n        Reader in = new Reader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        \n        long ncr[][]= new long[1005][1005];\n        ncr[0][0] = 1;\n        for(int i=1; i<=1000; i++)\n        {\n            ncr[i][0] = 1;\n            for(int j=1; j<=i; j++)\n            {\n                ncr[i][j] = (ncr[i-1][j] + ncr[i-1][j-1]) % mod;\n            }\n        }\n        int k = in.nextInt();\n        int total = 0;\n        long ans =1;\n        for(int i=0; i<k; i++)\n        {\n            int x = in.nextInt();\n            ans = (ans * ncr[total + x -1][x-1])%mod;\n            total += x;\n        }\n        \n        out.println(ans);\n        out.flush();\n        out.close();\n    }\n    public static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer st;\n\n        public Reader(InputStreamReader stream) {\n            reader = new BufferedReader(stream);\n            st = null;\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public String nextLine() throws IOException{\n            return reader.readLine();\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            in = new BufferedReader(new FileReader(\"roulette1.in\"));\n            out = new PrintWriter(new File(\"roulette1.out\"));\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n\n        tok = new StringTokenizer(\"\");\n        new C().solve();\n        out.flush();\n        out.close();\n        \n    \n    }\n\n    String nextTok() throws IOException {\n        if (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextTok());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextTok());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextTok());\n    }\n\n    static class Pair implements Comparable<Pair> {\n\n        int a;\n        int b;\n\n        public Pair( int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if (o.a < a) return 1;\n            if (o.a > a) return -1;\n            //if (o.b > b) return -1;\n            //if (o.b < b) return 1;\n            return 0;\n        }\n    }\n    \n    long MOD = 1000000007;\n\n    void solve() throws IOException {\n        int k = nextInt();\n        long mas[][] = new long[1003][1003]; \n        int c[] = new int[k];\n        for (int i = 0; i < c.length; i++) {\n            c[i] = nextInt();\n        }\n        for (int i = 0; i < 1003; i++) {\n            mas[i][0] = mas[i][i] = 1;\n            for (int j = 1; j <= i; j++) {\n                mas[i][j] = (mas[i-1][j-1]+mas[i-1][j])%MOD;\n            }\n        }\n        \n        int s = 0;\n        long ans = 1;\n        for (int i = 0; i < k; i++) {\n            s += c[i];\n            ans *= mas[s-1][c[i]-1];\n            ans %= MOD;\n        }\n        System.out.println(ans);\n    }\n\n}"
        }
    ]
}