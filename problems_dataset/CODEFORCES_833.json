{
    "name": "833_A. The Meaningless Game",
    "source": "CODEFORCES",
    "description": "<image>\n\nSlastyona and her loyal dog Pushok are playing a meaningless game that is indeed very interesting.\n\nThe game consists of multiple rounds. Its rules are very simple: in each round, a natural number k is chosen. Then, the one who says (or barks) it faster than the other wins the round. After that, the winner's score is multiplied by k2, and the loser's score is multiplied by k. In the beginning of the game, both Slastyona and Pushok have scores equal to one.\n\nUnfortunately, Slastyona had lost her notepad where the history of all n games was recorded. She managed to recall the final results for each games, though, but all of her memories of them are vague. Help Slastyona verify their correctness, or, to put it another way, for each given pair of scores determine whether it was possible for a game to finish with such result or not.\n\nInput\n\nIn the first string, the number of games n (1 \u2264 n \u2264 350000) is given.\n\nEach game is represented by a pair of scores a, b (1 \u2264 a, b \u2264 109) \u2013 the results of Slastyona and Pushok, correspondingly.\n\nOutput\n\nFor each pair of scores, answer \"Yes\" if it's possible for a game to finish with given score, and \"No\" otherwise.\n\nYou can output each letter in arbitrary case (upper or lower).\n\nExample\n\nInput\n\n6\n2 4\n75 45\n8 8\n16 16\n247 994\n1000000000 1000000\n\n\nOutput\n\nYes\nYes\nYes\nNo\nNo\nYes\n\nNote\n\nFirst game might have been consisted of one round, in which the number 2 would have been chosen and Pushok would have won.\n\nThe second game needs exactly two rounds to finish with such result: in the first one, Slastyona would have said the number 5, and in the second one, Pushok would have barked the number 3.",
    "difficulty": "A",
    "tags": [
        "math",
        "number theory"
    ],
    "rating": 1700,
    "public_test": [
        {
            "input": "6\n2 4\n75 45\n8 8\n16 16\n247 994\n1000000000 1000000\n",
            "output": "Yes\nYes\nYes\nNo\nNo\nYes\n"
        }
    ],
    "generated_test": [
        {
            "input": "1\n1062961 534\n",
            "output": "No"
        },
        {
            "input": "3\n1 1\n8 5\n1000 1331\n",
            "output": "Yes\nNo\nNo"
        },
        {
            "input": "6\n2 4\n75 45\n8 8\n16 5\n247 994\n1000000000 1000000\n",
            "output": "Yes\nYes\nYes\nNo\nNo\nYes"
        },
        {
            "input": "1\n1 1\n",
            "output": "Yes"
        },
        {
            "input": "3\n1 2\n4 5\n1000 1247\n",
            "output": "No\nNo\nNo"
        },
        {
            "input": "1\n1369 11095561\n",
            "output": "No"
        },
        {
            "input": "1\n90 65\n",
            "output": "No"
        },
        {
            "input": "1\n12004 14979606\n",
            "output": "No"
        },
        {
            "input": "1\n1 10\n",
            "output": "No"
        },
        {
            "input": "1\n1 8\n",
            "output": "No"
        },
        {
            "input": "1\n5 1\n",
            "output": "No"
        },
        {
            "input": "1\n59808 970883281\n",
            "output": "No"
        },
        {
            "input": "1\n7 12\n",
            "output": "No"
        },
        {
            "input": "1\n9907 193212989\n",
            "output": "No"
        },
        {
            "input": "1\n1751864 534\n",
            "output": "No"
        },
        {
            "input": "1\n1369 695441\n",
            "output": "No"
        },
        {
            "input": "3\n1 1\n8 5\n1000 1652\n",
            "output": "Yes\nNo\nNo"
        },
        {
            "input": "1\n90 50\n",
            "output": "No"
        },
        {
            "input": "1\n12004 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n2 10\n",
            "output": "No"
        },
        {
            "input": "1\n1 13\n",
            "output": "No"
        },
        {
            "input": "1\n59808 1147135943\n",
            "output": "No"
        },
        {
            "input": "1\n5 12\n",
            "output": "No"
        },
        {
            "input": "1\n9907 77741179\n",
            "output": "No"
        },
        {
            "input": "6\n2 4\n75 45\n8 8\n16 7\n247 994\n1000000000 1000000\n",
            "output": "Yes\nYes\nYes\nNo\nNo\nYes"
        },
        {
            "input": "1\n2682349 534\n",
            "output": "No"
        },
        {
            "input": "1\n1369 411325\n",
            "output": "No"
        },
        {
            "input": "3\n1 1\n8 5\n1000 1247\n",
            "output": "Yes\nNo\nNo"
        },
        {
            "input": "1\n90 19\n",
            "output": "No"
        },
        {
            "input": "1\n12033 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n2 19\n",
            "output": "No"
        },
        {
            "input": "1\n1 12\n",
            "output": "No"
        },
        {
            "input": "1\n1 2\n",
            "output": "No"
        },
        {
            "input": "1\n1029 1147135943\n",
            "output": "No"
        },
        {
            "input": "1\n5 21\n",
            "output": "No"
        },
        {
            "input": "1\n365 77741179\n",
            "output": "No"
        },
        {
            "input": "1\n2682349 821\n",
            "output": "No"
        },
        {
            "input": "1\n113 411325\n",
            "output": "No"
        },
        {
            "input": "3\n1 1\n4 5\n1000 1247\n",
            "output": "Yes\nNo\nNo"
        },
        {
            "input": "1\n90 1\n",
            "output": "No"
        },
        {
            "input": "1\n21331 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n2 12\n",
            "output": "No"
        },
        {
            "input": "1\n1 11\n",
            "output": "No"
        },
        {
            "input": "1\n1009 1147135943\n",
            "output": "No"
        },
        {
            "input": "1\n1 21\n",
            "output": "No"
        },
        {
            "input": "1\n347 77741179\n",
            "output": "No"
        },
        {
            "input": "1\n2075461 821\n",
            "output": "No"
        },
        {
            "input": "1\n137 411325\n",
            "output": "No"
        },
        {
            "input": "1\n169 1\n",
            "output": "No"
        },
        {
            "input": "1\n42429 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n1410 1147135943\n",
            "output": "No"
        },
        {
            "input": "1\n682 77741179\n",
            "output": "No"
        },
        {
            "input": "1\n1698406 821\n",
            "output": "No"
        },
        {
            "input": "1\n170 411325\n",
            "output": "No"
        },
        {
            "input": "3\n1 2\n4 5\n1000 1948\n",
            "output": "No\nNo\nNo"
        },
        {
            "input": "1\n37 1\n",
            "output": "No"
        },
        {
            "input": "1\n32885 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n1410 895339346\n",
            "output": "No"
        },
        {
            "input": "1\n837 77741179\n",
            "output": "No"
        },
        {
            "input": "1\n594056 821\n",
            "output": "No"
        },
        {
            "input": "1\n252 411325\n",
            "output": "No"
        },
        {
            "input": "1\n66 1\n",
            "output": "No"
        },
        {
            "input": "1\n17961 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n2817 895339346\n",
            "output": "No"
        },
        {
            "input": "1\n837 150201939\n",
            "output": "No"
        },
        {
            "input": "1\n142712 821\n",
            "output": "No"
        },
        {
            "input": "1\n252 144541\n",
            "output": "No"
        },
        {
            "input": "1\n47 1\n",
            "output": "No"
        },
        {
            "input": "1\n28408 23485980\n",
            "output": "No"
        },
        {
            "input": "1\n2819 895339346\n",
            "output": "No"
        },
        {
            "input": "1\n337 150201939\n",
            "output": "No"
        },
        {
            "input": "1\n142712 413\n",
            "output": "No"
        },
        {
            "input": "1\n252 203303\n",
            "output": "No"
        },
        {
            "input": "1\n28408 1691073\n",
            "output": "No"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long r;\nbool is_perfect_cube(long long n) {\n  r = (long long)round(cbrt(n));\n  if (r * r * r == n) return true;\n  return false;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if (is_perfect_cube((long long)a * b)) {\n      if (((long long)a + b) % r == 0)\n        printf(\"Yes\\n\");\n      else\n        printf(\"No\\n\");\n    } else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  while (n--) {\n    long long x, y, z, w;\n    scanf(\"%I64d%I64d\", &x, &y);\n    z = x * y;\n    w = pow(z, 1.0 / 3) + 0.5;\n    if (w * w * w == z && x % w == 0 && y % w == 0)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint vec[1000005];\nmap<long long, int> M;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 2; i <= 1000000; i++) {\n    if (vec[i]) continue;\n    for (int j = i; j <= 1000000; j += i) vec[j] = i;\n  }\n  for (int i = 1; i <= 1000000; i++) {\n    M[1LL * i * i * i] = i;\n  }\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    scanf(\"%lld%lld\", &a, &b);\n    long long c = a * b;\n    bool bad = 0;\n    if (M.find(c) == M.end()) {\n      bad = 1;\n    } else {\n      int x = M[c];\n      while (x != 1) {\n        int y = vec[x];\n        {\n          int A = 0, B = 0;\n          while (a % y == 0) {\n            a /= y;\n            A++;\n          }\n          while (b % y == 0) {\n            b /= y;\n            B++;\n          }\n          while (x % y == 0) x /= y;\n          if (A + B > 0) {\n            if ((A + B) % 3 == 0 && min(A, B) * 2 >= max(A, B))\n              ;\n            else\n              bad = 1;\n          }\n        }\n      }\n    }\n    puts(bad ? \"No\" : \"Yes\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nconst long long M = (long long)1e9 + 7;\nint Int() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nlong long Long() {\n  long long x;\n  scanf(\"%lld\", &x);\n  return x;\n}\nvoid Char(char *ch) { scanf(\"%s\", ch); }\ntemplate <typename t>\ninline t abs(t a) {\n  if (a >= 0) return a;\n  return -a;\n}\ntemplate <typename T>\ninline T modpow(T b, T p, T Mod) {\n  T res = 1;\n  while (p) {\n    if (p & 1) {\n      res *= b;\n      res %= Mod;\n    }\n    b *= b;\n    b %= Mod;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\ninline T ModInv(T b, T Mod) {\n  return modpow(b, Mod - 2, Mod);\n}\ntemplate <typename T>\ninline T pwr(T b, T p) {\n  T res = 1;\n  while (p) {\n    if (p & 1) {\n      res *= b;\n    }\n    b *= b;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\ninline T gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\ntemplate <typename T>\ninline void Int(T &n) {\n  n = 0;\n  int f = 1;\n  register int ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); ch = getchar()) n = (n << 3) + (n << 1) + ch - '0';\n  n = n * f;\n}\ntemplate <typename T, typename U>\ninline void Int(T &a, U &b) {\n  Int(a);\n  Int(b);\n}\ntemplate <typename T, typename U, typename W>\ninline void Int(T &a, U &b, W &c) {\n  Int(a, b);\n  Int(c);\n}\ntemplate <typename T, typename U, typename W, typename X>\ninline void Int(T &a, U &b, W &c, X &d) {\n  Int(a, b, c);\n  Int(d);\n}\nvector<int> Unique(vector<int> v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  return v;\n}\nvector<string> split(const string &s, char c) {\n  vector<string> v;\n  stringstream ss(s);\n  string x;\n  while (getline(ss, x, c)) v.emplace_back(x);\n  return move(v);\n}\nvoid err(vector<string>::iterator it) {}\ntemplate <typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n  cout << it->substr((*it)[0] == ' ', it->length()) << \" = \" << a << \" \";\n  err(++it, args...);\n}\nint main() {\n  int t = Int();\n  while (t--) {\n    long long n = Long(), m = Long();\n    if ((n == 1 and m != 1) or (n != 1 and m == 1)) {\n      puts(\"No\");\n      continue;\n    }\n    long long nm = n * m;\n    long long l = 1, r = 1000000LL;\n    int f = 0;\n    while (l <= r) {\n      long long mid = (l + r) >> 1;\n      long long d = mid * mid * mid;\n      if (d < nm) {\n        l = mid + 1;\n      } else if (d > nm) {\n        r = mid - 1;\n      } else {\n        f = 1;\n        break;\n      }\n    }\n    if (f) l = (l + r) >> 1;\n    if (l * l * l == nm and (n % l == 0) and (m % l == 0)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ChamathK\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner(inputStream);\n    FastPrinter out = new FastPrinter(outputStream);\n    TaskA solver = new TaskA();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskA {\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n      int n = in.nextInt();\n//        int[] primes = MathUtils.genPrimes(40000);\n//\n//        while (n-->0){\n//            int a = in.nextInt(), b = in.nextInt();\n//            int pi = 0;\n//            int good = 1;\n//            while (primes[pi]<= Math.sqrt(Math.max(a,b)+1)){\n//                if (a%primes[pi]==0 || b%primes[pi]==0){\n//                    int x = 0, y =0;\n//                    int p = primes[pi];\n//                    while (a%p==0){\n//                        x++; a/=p;\n//                    }\n//                    while (b%p==0){\n//                        y++;\n//                        b/=p;\n//                    }\n//\n//                    if (2*x < y || 2*y<x || (x+y)%3!=0){\n//                        good = 0;\n//                        break;\n//                    }\n//\n//\n//                }\n//\n//                pi++;\n//\n//            }\n//\n//            if (a!=1 || b!=1){\n//                good = 0;\n//            }\n//\n//            if (good == 1) {\n//                out.println(\"Yes\");\n//            } else {\n//                out.println(\"No\");\n//            }\n//\n//        }\n      while (n-- > 0) {\n        long a = in.nextLong(), b = in.nextLong();\n\n        long low = 0, high = 1000001;\n        long xx = a * b;\n\n        while (high - low > 1) {\n          long mid = (high + low) / 2;\n\n          if (mid * mid * mid >= xx) {\n            high = mid;\n          } else {\n            low = mid;\n          }\n\n        }\n\n        if (high * high * high == xx && a % high == 0 && b % high == 0) {\n          out.println(\"Yes\");\n        } else {\n          out.println(\"No\");\n        }\n\n      }\n    }\n\n  }\n\n  static class FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n      super(new InputStreamReader(is));\n    }\n\n\n    public int read() {\n      try {\n        int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n        return ret;\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n    }\n\n    public String next() {\n      StringBuilder sb = new StringBuilder();\n      int c = read();\n      while (isWhiteSpace(c)) {\n        c = read();\n      }\n      if (c < 0) {\n        return null;\n      }\n      while (c >= 0 && !isWhiteSpace(c)) {\n        sb.appendCodePoint(c);\n        c = read();\n      }\n      return sb.toString();\n    }\n\n    static boolean isWhiteSpace(int c) {\n      return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n      int c = read();\n      while (isWhiteSpace(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int ret = 0;\n      while (c >= 0 && !isWhiteSpace(c)) {\n        if (c < '0' || c > '9') {\n          throw new NumberFormatException(\"digit expected \" + (char) c\n              + \" found\");\n        }\n        ret = ret * 10 + c - '0';\n        c = read();\n      }\n      return ret * sgn;\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public String readLine() {\n      try {\n        return super.readLine();\n      } catch (IOException e) {\n        return null;\n      }\n    }\n\n  }\n\n  static class FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n      super(out);\n    }\n\n    public FastPrinter(Writer out) {\n      super(out);\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid testCase() {\n  int64_t a, b;\n  cin >> a >> b;\n  int64_t crt = cbrtl(a * b);\n  int64_t have = crt * crt * crt;\n  if ((have == (a * b)) && a % crt == 0 && b % crt == 0) {\n    cout << \"YES\" << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int64_t t;\n  cin >> t;\n  while (t--) testCase();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long cubeRoot(long long n) {\n  long long l = 0, r = 1001010, m;\n  while (l != r) {\n    m = (l + r + 1) / 2;\n    if (m * m * m > n) {\n      r = m - 1;\n    } else {\n      l = m;\n    }\n  }\n  return l;\n}\nint main() {\n  long long c, a, b, n, i, j, k, flag = 0, x, sum = 0, sum2 = 0, sr;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    scanf(\"%I64d %I64d\", &a, &b);\n    c = cubeRoot(a * b);\n    if ((c * c * c) == (a * b) && a % c == 0 && b % c == 0) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Solution {\n    static MyScanner sc;\n    private static PrintWriter out;\n    static long M2 = 1_000_000_000L + 7;\n\n    public static void main(String[] s) throws Exception {\n        StringBuilder stringBuilder = new StringBuilder();\n//        stringBuilder.append(\"100000 1000000000 10001 100000 \");\n//        for (int i = 1; i < 100000; i++) {\n//            stringBuilder.append(\" 10000 100000 \");\n//        }\n        if (stringBuilder.length() == 0) {\n            sc = new MyScanner(System.in);\n        } else {\n            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));\n        }\n\n\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n        initData();\n        solveT();\n        out.flush();\n    }\n\n\n    private static void initData() {\n\n    }\n\n    private static void solve() throws IOException {\n        long a = sc.nextInt();\n        long b = sc.nextInt();\n        out.println(v(a, b) ? \"Yes\" : \"No\");\n    }\n\n    static boolean v(long a, long b) {\n        long x = a * b;\n        long dm = Math.round(Math.pow(Math.E, Math.log(x) / 3));\n\n        if (dm * dm * dm != x) return false;\n\n        if (a % dm != 0) return false;\n        if (b % dm != 0) return false;\n\n\n        return true;\n    }\n\n\n    private static void solveT() throws IOException {\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n    }\n\n    private static long gcd(long l, long l1) {\n        if (l > l1) return gcd(l1, l);\n        if (l == 0) return l1;\n        return gcd(l1 % l, l);\n    }\n\n    private static long pow(long a, long b, long m) {\n        if (b == 0) return 1;\n        if (b == 1) return a;\n        long pp = pow(a, b / 2, m);\n        pp *= pp;\n        pp %= m;\n        return (pp * (b % 2 == 0 ? 1 : a)) % m;\n    }\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        MyScanner(BufferedReader br) {\n            this.br = br;\n        }\n\n        public MyScanner(InputStream in) {\n            this(new BufferedReader(new InputStreamReader(in)));\n        }\n\n        void findToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String next() {\n            findToken();\n            return st.nextToken();\n        }\n\n        Integer[] nab(int n) {\n            Integer[] k = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        int[] na(int n) {\n            int[] k = new int[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.fi();\n            }\n            return k;\n        }\n\n        long[] nl(int n) {\n            long[] k = new long[n];\n            for (int i = 0; i < n; i++) {\n                k[i] = sc.nextLong();\n            }\n            return k;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int fi() {\n            String t = next();\n            int cur = 0;\n            boolean n = t.charAt(0) == '-';\n            for (int a = n ? 1 : 0; a < t.length(); a++) {\n                cur = cur * 10 + t.charAt(a) - '0';\n            }\n            return n ? -cur : cur;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class A extends PrintWriter {\n\n    final static int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199 };\n\n    int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    boolean solve(int a, int b) {\n        for (int p : primes) {\n            if (p > a || p > b) {\n                break;\n            }\n\n            int x = 0, y = 0;\n\n            while (a % p == 0) {\n                a /= p;\n                ++x;\n            }\n\n            while (b % p == 0) {\n                b /= p;\n                ++y;\n            }\n\n            int s = x + y;\n\n            if (s % 3 != 0) {\n                return false;\n            }\n\n            int n = s / 3;\n\n            if (x < n || y < n) {\n                return false;\n            }\n        }\n\n        if (a == b) {\n            int q = (int) Math.pow(a, 1.0 / 3.0);\n\n            for (int d = -3; d <= 3; d++) {\n                int x = q + d;\n\n                if (x > 0 && x * x * x == a) {\n                    return true;\n                }\n            }\n        }\n        {\n            int q = (int) Math.pow(max(a, b), 1.0 / 2.0);\n\n            for (int d = -3; d <= 3; d++) {\n                int x = q + d;\n\n                if (x == min(a, b) && x * x == max(a, b)) {\n                    return true;\n                }\n            }\n        }\n\n        {\n            int g = gcd(a, b);\n            long p = a / g;\n            long q = b / g;\n\n            if (p * p * q == a && p * q * q == b) {\n                return true;\n            }\n\n        }\n\n        return a == 1 && b == 1;\n    }\n\n    void run() {\n\n        int n = nextInt();\n        for (int i = 0; i < n; i++) {\n            int a = nextInt(), b = nextInt();\n            println(solve(a, b) ? \"Yes\" : \"No\");\n        }\n\n    }\n\n    boolean skip() {\n        while (hasNext()) {\n            next();\n        }\n        return true;\n    }\n\n    int[][] nextMatrix(int n, int m) {\n        int[][] matrix = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                matrix[i][j] = nextInt();\n        return matrix;\n    }\n\n    String next() {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    boolean hasNext() {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = nextLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    int[] nextArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException err) {\n            return null;\n        }\n    }\n\n    public A(OutputStream outputStream) {\n        super(outputStream);\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n    static Random rnd = new Random();\n    static boolean OJ;\n\n    public static void main(String[] args) throws IOException {\n        OJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n        A solution = new A(System.out);\n        if (OJ) {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            solution.run();\n        } else {\n            reader = new BufferedReader(new FileReader(new File(A.class.getName() + \".txt\")));\n            long timeout = System.currentTimeMillis();\n            while (solution.hasNext()) {\n                solution.run();\n                solution.println();\n                solution.println(\"----------------------------------\");\n            }\n            solution.println(\"time: \" + (System.currentTimeMillis() - timeout));\n        }\n        solution.close();\n        reader.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int qq = sc.nextInt();\n        while (qq-- > 0) {\n            int a = sc.nextInt(), b = sc.nextInt();\n            long cubicRoot = 1L * (long)Math.pow(1L * a * b, 1.0 / 3);\n            if (cubicRoot * cubicRoot * cubicRoot != 1L * a * b) cubicRoot++;\n            if (cubicRoot * cubicRoot * cubicRoot != 1L * a * b) cubicRoot -= 2;\n            if (cubicRoot * cubicRoot * cubicRoot == 1L * a * b) out.println(gcd(a, b) % cubicRoot== 0 ? \"Yes\" : \"No\");\n            else out.println(\"No\");\n        }\n        out.flush();\n        out.close();\n    }\n\n    public static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    static class Pair implements Comparable<Pair>{\n        long a, b;\n        Pair (long aa, long bb) {\n            a = aa;\n            b = bb;\n        }\n\n        @Override\n        public int compareTo(Pair pair) {\n            return a != pair.a ? Long.compare(a, pair.a) : Long.compare(b, pair.b);\n        }\n\n        @Override\n        public String toString() {\n            return  \"(\" + a + \",\" + b + \")\";\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n        public Scanner(FileReader s) {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  map<long long, int> mp;\n  for (long long i = 1; i <= 1e6; ++i) mp[i * i * i] = i;\n  int t;\n  cin >> t;\n  while (t--) {\n    long long a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    if (mp.count(a * b) and a % mp[a * b] == 0 and b % mp[a * b] == 0)\n      printf(\"YeS\\n\");\n    else\n      printf(\"nO\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    long long a, b;\n    scanf(\"%lld%lld\", &a, &b);\n    long long l = 1, r = 1000000, x = -1;\n    while (l <= r) {\n      long long mid = (l + r) / 2;\n      if (mid * mid * mid > a * b)\n        r = mid - 1;\n      else if (mid * mid * mid < a * b)\n        l = mid + 1;\n      else {\n        x = mid;\n        break;\n      }\n    }\n    if (x == -1 || a * a % b != 0 || b * b % a != 0) {\n      printf(\"No\\n\");\n      continue;\n    }\n    printf(\"Yes\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long a = in.nextLong();\n            long b = in.nextLong();\n            long p = a * b;\n            long q = (long) Math.floor(Math.pow(p, 1.0 / 3));\n            while (q * q * q > p) --q;\n            while (q * q * q < p) ++q;\n            if (q * q * q == p) {\n                long g = gcd(a, b);\n                if (g % q == 0) {\n                    out.println(\"Yes\");\n                    return;\n                }\n            }\n            out.println(\"No\");\n        }\n\n        private long gcd(long a, long b) {\n            while (b > 0) {\n                long t = a % b;\n                a = b;\n                b = t;\n            }\n            return a;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int e = 2 * 1e6 + 7;\nlong long a[e];\nlong long bs(long long x) {\n  long long l = 0, h = 1000005;\n  while (l != h) {\n    long long m = (l + h + 1) / 2;\n    if (m * m * m > x) {\n      h = m - 1;\n    } else {\n      l = m;\n    }\n  }\n  return l;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    long long a, b;\n    scanf(\"%I64d %I64d\", &a, &b);\n    long long x = bs(a * b);\n    if (x * x * x != a * b)\n      puts(\"NO\");\n    else if (a % x == 0 && b % x == 0)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) throws Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer st;\n        for(int i = 1;i <= n;i++) {\n            st = new StringTokenizer(br.readLine());\n            long a = Integer.parseInt(st.nextToken());\n            long b = Integer.parseInt(st.nextToken());\n            long cbrt = (long) Math.cbrt(a * b);\n            if (cbrt * cbrt * cbrt != a * b || a % cbrt != 0 || b % cbrt != 0)\n                pw.println(\"No\");\n            else pw.println(\"Yes\");\n        }\n        pw.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,os,io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left , bisect_right\nimport math \ndef ii():\n    return int(input())\ndef li():\n    return list(map(int,input().split()))\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\") \nelse:\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nno = \"No\"\nyes = \"Yes\"\n\n\ndef solve():\n    a,b = li()\n    x = (pow(a*b,1/3))\n    x=round(x)\n    if x*x*x==a*b and a%x==b%x==0:\n        print(yes)\n    else:\n        print(no)\n    \n\n\n\n\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint gcd(int x, int y) {\n  while (y) {\n    x %= y;\n    swap(x, y);\n  }\n  return x;\n}\nint cube(int x) { return x * x * x; }\nint iscube(int x) {\n  int y = 0;\n  for (int l = 10; l >= 0; l--) {\n    if (cube(y + (1 << l)) <= x) {\n      y += 1 << l;\n    }\n  }\n  return cube(y) == x;\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 0, x, y; i < N; i++) {\n    scanf(\"%d%d\", &x, &y);\n    int g = gcd(x, y);\n    int a = x / g, b = y / g;\n    if (g % (1ll * a * b) == 0 && iscube(g / a / b)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long check(long long p) { return p * p * p; }\nlong long res;\nbool binary_search(long long l, long long r, long long q) {\n  long long mid = (l + r) / 2;\n  while (l <= r) {\n    mid = (l + r) / 2;\n    long long c = check(mid);\n    if (c > q) {\n      r = mid - 1;\n    } else if (c < q) {\n      l = mid + 1;\n    } else {\n      res = mid;\n      return true;\n    }\n  }\n  return false;\n}\nlong long gcd(long long a, long long b) {\n  long long c = a % b;\n  while (c) {\n    a = b;\n    b = c;\n    c = a % b;\n  }\n  return b;\n}\nint main() {\n  long long n;\n  scanf(\"%lld\", &n);\n  while (n--) {\n    long long a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    long long mn = min(a, b);\n    long long mx = max(a, b);\n    if (mn * mn < mx) {\n      puts(\"No\");\n      continue;\n    }\n    if (binary_search(1, 1e6, a * b)) {\n      if (a % res == 0 && b % res == 0) {\n        puts(\"Yes\");\n      } else {\n        puts(\"No\");\n      }\n    } else {\n      puts(\"No\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nlong long cube(long long c) {\n  long long l = 1, r = 1e6, mid;\n  while (l < r) {\n    mid = (l + r) / 2;\n    if ((mid * mid * mid) < c)\n      l = mid + 1;\n    else\n      r = mid;\n  }\n  return l;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int t = 0; t < n; t++) {\n    long long a, b;\n    scanf(\"%lld%lld\", &a, &b);\n    long long c = cube(a * b);\n    ((void)0);\n    if (c * c * c != a * b) {\n      printf(\"No\\n\");\n      continue;\n    }\n    ((void)0);\n    if (a % c == 0 and b % c == 0)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    ll a, b;\n    cin >> a >> b;\n    ll x = round(pow(a * b, 1.0 / 3.0));\n    if (pow(x, 3) == a * b && a % x == 0 && b % x == 0)\n      cout << \"YES\\n\";\n    else\n      cout << \"NO\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma 03\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long a, b;\n    cin >> a >> b;\n    long long k = floor(cbrt(a * b));\n    if (k * k * k != a * b)\n      cout << \"No\\n\";\n    else if (a % k == 0 && b % k == 0)\n      cout << \"Yes\\n\";\n    else\n      cout << \"No\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T;\nlong long a, b, x;\nint Calc(int x, int a) {\n  int cnt = 0;\n  for (; a % x == 0; a /= x, cnt++)\n    ;\n  return cnt;\n}\nbool judge(int x, int a, int b) {\n  int p = Calc(x, a), q = Calc(x, b);\n  return p + p >= q && q + q >= p;\n}\nint main() {\n  for (cin >> T; T--;) {\n    scanf(\"%lld%lld\", &a, &b), x = a * b;\n    long long p = pow(x, 1. / 3);\n    if ((p + 1) * (p + 1) * (p + 1) == x) p = p + 1;\n    if (p * p * p != x) {\n      puts(\"No\");\n      continue;\n    }\n    bool res = 1;\n    for (long long i = 2; i * i <= p; i++)\n      if (p % i == 0) {\n        for (; p % i == 0; p /= i)\n          ;\n        if (!judge(i, a, b)) {\n          res = 0;\n          break;\n        }\n      }\n    if (res && p > 1 && !judge(p, a, b)) res = 0;\n    puts(res ? \"Yes\" : \"No\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        public InputReader(InputStream st) {\n            this.stream = st;\n        } \n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        } \n        public String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        } \n    }\n    public static class Key {\n\n        private final int x;\n        private final int y;\n\n        public Key(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Key)) return false;\n            Key key = (Key) o;\n            return x == key.x && y == key.y;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n\n    }\n    static class Pair{\n        long x,y,z;\n        public Pair(long x,long y,long z){\n            this.x=x;\n            this.y=y;\n            this.z=z;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Pair)) return false;\n            Pair key = (Pair) o;\n            return x == key.x && y == key.y && z==key.z;\n        }\n    }\n    static class Pair1{\n        long x,y;\n        public Pair1(long x,long y){\n            this.x=x;\n            this.y=y;\n            \n        }\n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static long mod=998244353L,mod1=1000000007;\n    static boolean prime[]=new boolean[(int)(1e5+1)];\n    static void sieve() {\n\tArrays.fill(prime, true);\n        //pri.add(-1);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2 ; i <=(int)1e5 ; ++i) {\n            if(prime[i]) {\n                //pri.add(i);\n                int j=2*i;\n                while(j<=(int)1e5){\n                    prime[j]=false;\n                    j+=i;\n                }\n            }\n\t}\n\t\t\t\n    }\n    static ArrayList<Long> pri=new ArrayList<>();\n    public static void main(String [] args){\n        InputReader sc=new InputReader(System.in);\n        int t=sc.ni();\n        \n        while(t-->0){\n            long a=sc.nl(),b=sc.nl();\n            long m=a*b,c=-1;\n            \n            long l=1,r=1000000;\n            while(l<=r){\n                long mid=(l+r)/2;\n                long mul=mid*mid*mid;\n                if((mul)==m){\n                    c=mid;\n                    break;\n                }\n                else if(mul<m){\n                    l=mid+1;\n                }\n                else {\n                    r=mid-1;\n                }\n                \n            }\n            if(c==-1)w.println(\"NO\");\n            else if(a%c!=0||b%c!=0)w.println(\"NO\");\n            else w.println(\"YES\");\n        }\n        w.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Mmain {\n    static double eps = 0.000001, cubeRoot, rounded;\n    public static PrintWriter out;\n    public static void main(String[] args) {\n        MyScanner in = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = in.nextInt();\n        while(n-- != 0) {\n            long a, b;\n            a = in.nextLong(); b = in.nextLong();\n            cubeRoot = Math.pow(a*b, 1.0/3.0);\n            rounded = Math.ceil(cubeRoot);\n            out.println((rounded - cubeRoot <= eps && a % rounded == 0 && b % rounded == 0) ? \"Yes\" : \"No\");\n        }\n        out.close();\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\ncbrt = {i**3:i for i in range(1001)}\nn = int(input())\nall_res = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a == b:\n        all_res.append('Yes' if a in cbrt else 'No')\n        continue\n    if a > b: \n        a, b = b, a\n    r = cbrt.get(a * a // b, 0)\n    if r == 0 or a % (r * r) > 0:\n        all_res.append('No')\n        continue\n    y = a //(r * r)\n    if r * r * y == a and r * y * y == b: \n        all_res.append('Yes')\n    else:\n        all_res.append('No')\nprint('\\n'.join(all_res))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class R426A\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tlong fst =sc.nextLong();\n\t\t\tlong snd = sc.nextLong();\n\t\t\t\n\t\t\tlong mul = fst*snd;\n\t\t\tlong xy = (long)Math.round(Math.cbrt(mul));\n\t\t\tif(xy*xy*xy != mul)\n\t\t\t{\n\t\t\t\tpw.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(fst%xy != 0)\n\t\t\t{\n\t\t\t\tpw.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong y = fst/xy;\n\t\t\tlong x = fst/(y*y);\n\t\t\tif(1.0*x*x*y > 1e10 || 1.0*x*y*y > 1e10)\n\t\t\t{\n\t\t\t\tpw.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\n\t\t\tlong one = x*x*y;\n\t\t\tlong two = y*y*x;\n\t\t\t\n\t\t\tif(fst == two && snd == one)\n\t\t\t{\n\t\t\t\tpw.println(\"Yes\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpw.println(\"No\");\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\t\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\t\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\t\t\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main\n{\n    static class Reader\n\t{\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic Reader()\n\t\t{\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic Reader(String file_name) throws IOException\n\t\t{\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String readLine() throws IOException\n\t\t{\n\t\t\tbyte[] buf = new byte[2017]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1)\n\t\t\t{\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (c == '.')\n\t\t\t{\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t{\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException\n\t\t{\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\t\tprivate byte read() throws IOException\n\t\t{\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\t\tpublic void close() throws IOException\n\t\t{\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n   static long gcd(long a,long b){\n     if(b%a==0)return a;else return gcd(b%a,a);\n    }\n        public static void main(String[] args) throws IOException\n\t{\n\t\tReader in=new Reader();PrintWriter out=new PrintWriter(System.out);\n                int t=in.nextInt();\n                while(t-->0){\n                 long a=in.nextLong(),b=in.nextLong();\n                 long g=gcd(a,b);a/=g;b/=g;\n                 double q=(double)g/(double)(a*b);\n                 double cr=Math.cbrt(q);\n                 if(cr-(long)cr==0)out.println(\"Yes\");else out.println(\"No\");\n                }\n                out.flush();out.close();\n\t}\n    \n}"
        },
        {
            "language": 4,
            "solution": "//package TIM;\n\n\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        Scanner input = new Scanner(System.in);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter output = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        while (n-- > 0) {\n            String[] s = br.readLine().split(\" \");\n            int a = Integer.parseInt(s[0]);\n            int b = Integer.parseInt(s[1]);\n            long x = 1L * a * b;\n            double y = Math.cbrt(x);\n            if (a % y == 0 && b % y == 0)\n                output.println(\"Yes\");\n            else\n                output.println(\"No\");\n        }\n        br.close();\n        output.close();\n    }\n}\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int inf = 1e9 + 7;\nconst long long int modc = 998244353;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int n;\n  cin >> n;\n  while (n--) {\n    long long int a, b;\n    cin >> a >> b;\n    long long int prod = a * b, cb = round(cbrt(prod));\n    if (cb * cb * cb == prod && a % cb == 0 && b % cb == 0)\n      cout << \"Yes\\n\";\n    else\n      cout << \"No\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxh = 1e5 + 10, maxn = 350010;\nusing namespace std;\nlong long n, m, k, ps, pr[maxh];\nvector<long long> p;\nmap<pair<int, int>, int> mp;\nvoid sieve() {\n  for (long long i = 2; i < maxh; i++) {\n    if (pr[i]) continue;\n    p.push_back(i);\n    for (long long j = i * i; j < maxh; j += i) {\n      pr[j] = 1;\n    }\n  }\n  ps = p.size();\n}\nlong long gcd(long long a, long long b) { return (b == 0) ? a : gcd(b, a % b); }\nbool solve(long long a, long long b) {\n  if (mp[make_pair(a, b)]) return mp[make_pair(a, b)] - 1;\n  int c = gcd(a, b);\n  for (long long i = 0; p[i] * p[i] <= c; i++) {\n    if (c % p[i] == 0) {\n      int x = 0, y = 0;\n      while (c % p[i] == 0) c /= p[i];\n      while (a % p[i] == 0) a /= p[i], x++;\n      while (b % p[i] == 0) b /= p[i], y++;\n      if (2 * x - y < 0 || 2 * y - x < 0) return 0;\n      if ((2 * x - y) % 3 || (2 * y - x) % 3) return 0;\n      if (a > b) swap(a, b);\n      if (a * a == b) return 1;\n    } else if (a % p[i] == 0 || b % p[i] == 0)\n      return 0;\n  }\n  if (c > 1) {\n    int i = c;\n    int x = 0, y = 0;\n    while (a % i == 0) a /= i, x++;\n    while (b % i == 0) b /= i, y++;\n    if (2 * x - y < 0 || 2 * y - x < 0) return 0;\n    if ((2 * x - y) % 3 || (2 * y - x) % 3) return 0;\n  }\n  if (a > 1 || b > 1) return 0;\n  return 1;\n}\nint main() {\n  sieve();\n  scanf(\"%I64d\", &n);\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    scanf(\"%I64d %I64d\", &a, &b);\n    int as = solve(a, b);\n    mp[make_pair(a, b)] = as + 1;\n    if (as)\n      printf(\"Yes\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\npublic class Main {\n\n    private static Reader in;\n    private static PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        in = new Reader(System.in);\n        out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        for (int round = 0; round < n; ++round) {\n            long a = in.nextInt();\n            long b = in.nextInt();\n            long cbrt = (long) Math.cbrt(a * b);\n            out.println( (cbrt * cbrt * cbrt == a * b && a % cbrt == 0 && b % cbrt == 0) ? \"Yes\" : \"No\" );\n        }\n\n        out.close();\n    }\n\n}\n\n/** Class for buffered reading int and double values */\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    Reader(InputStream input) {\n        init(input);\n    }\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n            new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////\n    //    RRRRRRRRR            AAA             HHH     HHH     IIIIIIIIIIIII   LLL           //\n    //    RR    RRR           AAAAA            HHH     HHH      IIIIIIIIIII    LLL           //\n    //    RR   RRR           AAAAAAA           HHH     HHH          III        LLL           //\n    //    RR  RRR           AAA   AAA          HHHHHHHHHHH          III        LLL           //\n    //    RRRRRR           AAA     AAA         HHHHHHHHHHH          III        LLL           //\n    //    RR  RRR         AAAAAAAAAAAAA        HHH     HHH          III        LLL           //\n    //    RR    RRR      AAA         AAA       HHH     HHH      IIIIIIIIIII    LLLLLLLLLLLL  //\n    //    RR     RRR    AAA           AAA      HHH     HHH     IIIIIIIIIIIII   LLLLLLLLLLLL  //\n    ///////////////////////////////////////////////////////////////////////////////////////////\n   \n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        int t=sc.i();\n        while(t-->0)\n        {\n            long a=sc.l();\n            long b=sc.l();\n            if(Math.cbrt(a*b)==(long)Math.cbrt(a*b)&&a%(long)Math.cbrt(a*b)==0&&b%(long)Math.cbrt(a*b)==0)\n            out.println(\"Yes\");\n            else\n            out.println(\"No\");\n        }\n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  map<long long, int> mp;\n  for (long long i = 1; i <= 1e6; ++i) mp[i * i * i] = i;\n  int t;\n  cin >> t;\n  while (t--) {\n    long long a, b;\n    cin >> a >> b;\n    if (mp.count(a * b) and a % mp[a * b] == 0 and b % mp[a * b] == 0)\n      cout << \"YeS\\n\";\n    else\n      cout << \"nO\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int Cube_Root(long long int x) {\n  long long int l = 1, r = 1000005;\n  while (l < r) {\n    long long int mid = (l + r) / 2;\n    if (mid * mid * mid >= x) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  if (l * l * l > x) {\n    return l - 1;\n  } else {\n    return l;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  while (n--) {\n    long long int a, b, temp;\n    scanf(\"%lld%lld\", &a, &b);\n    temp = Cube_Root(a * b);\n    if ((temp * temp * temp == a * b) && (a % temp == 0) && (b % temp == 0)) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    long long a, b;\n    scanf(\"%I64d%I64d\", &a, &b);\n    long long tmp = ceil(cbrt(a * b));\n    puts(tmp * tmp * tmp == a * b && a % tmp == 0 && b % tmp == 0 ? \"Yes\"\n                                                                  : \"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\n \nimport java.util.*;\n/*\n\n\n*/\n\n \n \n \n \n \n public class A {\n\tstatic FastReader sc=null;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\twhile(n-->0) {\n\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\tlong val=(long)a*b;\n\t\t\tlong ans=isCube(val);\n\t\t\tif(ans==-1)out.println(\"No\");\n\t\t\telse {\n\t\t\t\tif(a%ans==0 && b%ans==0)out.println(\"Yes\");\n\t\t\t\telse out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\tout.close();\n\n\t}\n\tstatic long isCube(long v) {\n\t\tlong l=1,r=(long)1e6+5;\n\t\twhile(l+1<r) {\n\t\t\tlong mid=(l+r)/2;\n\t\t\tif(mid*mid*mid>v)r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tif(v==l*l*l)return l;\n\t\treturn -1;\n\t}\n\t\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n \n\t\n\tstatic int[] reverse(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al,Collections.reverseOrder());\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\tstatic int gcd(int a,int b) {\n\t\tif(b==0)return a;\n\t\telse return gcd(b,a%b);\n\t}\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\t\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n"
        },
        {
            "language": 4,
            "solution": "//package round426;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tfor(int T = ni();T > 0;T--){\n\t\t\tlong a = nl(), b = nl();\n\t\t\tlong ab = a*b;\n\t\t\tlong c = cbrt(ab);\n\t\t\tif(c*c*c != ab){\n\t\t\t\tout.println(\"No\");\n\t\t\t}else{\n\t\t\t\tif(a % c == 0 && b % c == 0){\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static long cbrt(long n)\n\t{\n\t\tlong i = Math.max(0, (long)Math.cbrt(n)-2);\n\t\twhile(i*i*i <= n)i++;\n\t\treturn i-1;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 5;\nint t, a, b;\nvector<pair<int, int>> pa, pb;\nvector<int> pr;\nbool vis[N];\nbool val() {\n  if (a * a != b && b * b != a) return false;\n  if (pa.size() != pb.size()) return false;\n  for (int i = 0; i < pa.size(); i++) {\n    if (pa[i].first != pb[i].first) return false;\n    if ((pa[i].second + pb[i].second) % 3) return false;\n    if (2 * min(pa[i].second, pb[i].second) < max(pa[i].second, pb[i].second))\n      return false;\n  }\n  return true;\n}\nint main() {\n  for (int i = 2; i <= 1e3; i++) {\n    if (vis[i]) continue;\n    pr.push_back(i);\n    for (int j = i; j <= 1e3; j += i) vis[j] = true;\n  }\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d %d\", &a, &b);\n    pa.clear();\n    pb.clear();\n    for (int i : pr) {\n      if (a % i) continue;\n      pa.push_back({i, 0});\n      while (a % i == 0) {\n        pa.back().second++;\n        a /= i;\n      }\n    }\n    for (int i : pr) {\n      if (b % i) continue;\n      pb.push_back({i, 0});\n      while (b % i == 0) {\n        pb.back().second++;\n        b /= i;\n      }\n    }\n    if (val())\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint x, y;\nint prime[100005];\nbool is_prime[100005];\nint t;\nint sieve(int n) {\n  int p = 0;\n  for (int i = 0; i <= n; i++) is_prime[i] = true;\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; i++) {\n    if (is_prime[i]) {\n      prime[p++] = i;\n      for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n    }\n  }\n  return p;\n}\nlong long _sqr(long long x) {\n  long long l = 1, r = 1000001;\n  while (r - l > 1) {\n    long long mid = (l + r) / 2;\n    if (mid * mid * mid <= x)\n      l = mid;\n    else\n      r = mid;\n  }\n  return l;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int num = sieve(32005);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    long long s = (long long)x * y;\n    long long res = _sqr(s);\n    if (res * res * res != s || x % res != 0 || y % res != 0) {\n      puts(\"No\");\n      continue;\n    }\n    long long xx = x / res, yy = y / res;\n    if (xx * yy == res)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T;\nlong long a, b, x;\nint main() {\n  for (cin >> T; T--;) {\n    scanf(\"%lld%lld\", &a, &b), x = pow(a * b, 1. / 3);\n    if ((x + 1) * (x + 1) * (x + 1) == a * b) x++;\n    puts(x * x * x != a * b || a % x || b % x ? \"No\" : \"Yes\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 5;\nlong long dx[] = {1, -1, 0, 0};\nlong long dy[] = {0, 0, 1, -1};\nvoid solve() {\n  long long a, b;\n  cin >> a >> b;\n  long long num = a * b;\n  long long x = round(cbrt(num));\n  if (x * x * x != num)\n    cout << \"No\";\n  else {\n    if (a % x == 0 && b % x == 0)\n      cout << \"Yes\";\n    else\n      cout << \"No\";\n  }\n  return;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long q = 1;\n  cin >> q;\n  for (long long i = 0; i < q; i++) {\n    solve();\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nusing vc = vector<T>;\ntemplate <typename T, typename X>\nusing pr = pair<T, X>;\nconst long long int MOD = 1e9 + 7;\nconst long double PI = 3.14159265;\nlong long int powerWithMod(long long int base, long long int exponent,\n                           long long int modulus = LLONG_MAX) {\n  long long int result = 1;\n  base %= modulus;\n  while (exponent > 0) {\n    if (exponent % 2 == 1) result = (result * base) % modulus;\n    exponent >>= 1;\n    base = (base * base) % modulus;\n  }\n  return result;\n}\nlong long int modInverse(long long int a, long long int m = MOD) {\n  return powerWithMod(a, m - 2, m);\n}\nint n;\nlong long int a, b;\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    auto c = a * b;\n    auto y = static_cast<long long int>(std::pow(c, 1 / 3.0));\n    while (y * y * y < c) y++;\n    if (y * y * y != c or a % y or b % y)\n      cout << \"No\\n\";\n    else\n      cout << \"Yes\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic int gcd(int x,int y) {\n\t\treturn y==0?x:gcd(y,x%y);\n\t}\n\tpublic static void main(String[] args){\n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter out = new PrintWriter(System.out);\n\t\tint T=in.nextInt();\n\t\tStringBuilder ans=new StringBuilder();\n\t\twhile(T--!=0) {\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tboolean flag;\n\t\t\tlong st=(long)n*m;\n\t\t\tlong i=Math.round(Math.pow(st, 1.0/3));\n\t\t\tflag=(i*i*i==st&&n%i==0&&m%i==0?true:false);\n\t\t    ans.append(flag?\"Yes\\n\":\"No\\n\");\n\t\t}\n\t\tout.print(ans);\n\t\tout.close();\n\t}\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\navl=AvlTree()\n#-----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default='z', func=lambda a, b: min(a ,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left)/ 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid]<=key):\n            count = mid+1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n\ndef countGreater( arr,n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    c=a*b\n    l=int(c**(1/3)+0.5)\n    if l**3==a*b and a%l==0 and b%l==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n \n/**\n *\n * @author usquare\n */\n\npublic class ProblemG {\n    \n    static long mod = (int) (1e9+7);\n    static InputReader in;\n    static PrintWriter out;\n    \n    static void solve() {\n        \n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);  \n        \n        int n = in.nextInt();\n\n        while(n-- > 0){\n            long a = in.nextInt();\n            long b = in.nextInt();\n            long ab = a*b;\n            long y = get(ab);\n            if( y*y*y == ab && a%y == 0 && b%y == 0 ) out.println(\"Yes\");\n            else out.println(\"No\");\n        }\n        \n        out.close();\n        \n    }\n    \n    static long get(long x){\n        long l = 1;\n        long r = 1000005;\n        long ans = 0;\n        while(r - l >= 0){\n            long m = (r + l) >> 1;\n            if(m*m*m >= x){\n                ans = m;\n                r = m - 1;\n            }\n            else l = m + 1;\n        }\n        return ans;\n    }\n    \n    public static void main(String[] args) {\n \n        new Thread(null,new Runnable() {\n            @Override\n            public void run() {\n                try{\n                    solve();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        },\"1\",1<<26).start();\n    }\n    \n    static class Pair implements Comparable<Pair>{\n \n        int x,y;\n        int i;\n        \n\tPair (int x,int y,int i){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t\tthis.i=i;\n\t}\n \n\tPair (int x,int i){\n\t\tthis.x=x;\n\t\tthis.i=i;\n\t}\n        \n\tpublic int compareTo(Pair o) {\n            return Long.compare(this.x,o.x);\n\t\t//return 0;\n\t}\n \n            public boolean equals(Object o) {\n            if (o instanceof Pair) {\n                Pair p = (Pair)o;\n                return p.x == x && p.y == y && p.i==i;\n            }\n            return false;\n        }\n \n        @Override\n        public String toString() {\n            return x+\" \"+y+\" \"+i;\n        }\n        \n    } \n    \n    static class Merge {\n        \n        public static void sort(long inputArr[]) {\n            int length = inputArr.length;\n            doMergeSort(inputArr,0, length - 1);\n        }\n        \n        private static void doMergeSort(long[] arr,int lowerIndex, int higherIndex) {        \n            if (lowerIndex < higherIndex) {\n                int middle = lowerIndex + (higherIndex - lowerIndex) / 2;\n                doMergeSort(arr,lowerIndex, middle);\n                doMergeSort(arr,middle + 1, higherIndex);\n                mergeParts(arr,lowerIndex, middle, higherIndex);\n            }\n        }\n        \n        private static void mergeParts(long[]array,int lowerIndex, int middle, int higherIndex) {\n            long[] temp=new long[higherIndex-lowerIndex+1];\n            for (int i = lowerIndex; i <= higherIndex; i++) {\n                temp[i-lowerIndex] = array[i];\n            }\n            int i = lowerIndex;\n            int j = middle + 1;\n            int k = lowerIndex;\n            while (i <= middle && j <= higherIndex) {\n                if (temp[i-lowerIndex] < temp[j-lowerIndex]) {\n                    array[k] = temp[i-lowerIndex];\n                    i++;\n                } else {\n                    array[k] = temp[j-lowerIndex];\n                    j++;\n                }\n                k++;\n            }\n            while (i <= middle) {\n                array[k] = temp[i-lowerIndex];\n                k++;\n                i++;\n            }\n            while(j<=higherIndex){\n                array[k]=temp[j-lowerIndex];\n                k++;\n                j++;\n            }\n        }\n \n    }\n    \n    static long add(long a,long b){\n        long x=(a+b);\n        while(x>=mod) x-=mod;\n        return x;\n    }\n \n    static long sub(long a,long b){\n        long x=(a-b);\n        while(x<0) x+=mod;\n        return x;\n    }\n    \n    static long mul(long a,long b){\n        a%=mod;\n        b%=mod;\n        long x=(a*b);\n        return x%mod;\n    }\n \n    \n    static boolean isPal(String s){\n        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n                if(s.charAt(i)!=s.charAt(j)) return false;\n        }\n        return true;\n    }\n    static String rev(String s){\n\t\tStringBuilder sb=new StringBuilder(s);\n\t\tsb.reverse();\n\t\treturn sb.toString();\n    }\n    \n    static long gcd(long x,long y){\n\tif(y==0)\n\t\treturn x;\n\telse\n\t\treturn gcd(y,x%y);\n    }\n    \n    static int gcd(int x,int y){\n\tif(y==0)\n\t\treturn x;\n\telse \n\t\treturn gcd(y,x%y);\n    }\n    \n    static long gcdExtended(long a,long b,long[] x){\n        \n        if(a==0){\n            x[0]=0;\n            x[1]=1;\n            return b;\n        }\n        long[] y=new long[2];\n        long gcd=gcdExtended(b%a, a, y);\n        \n        x[0]=y[1]-(b/a)*y[0];\n        x[1]=y[0];\n        \n        return gcd;\n    }\n    \n \n    static long mulmod(long  a,long b,long m) {\n        if (m <= 1000000009) return a * b % m;\n \n        long res = 0;\n        while (a > 0) {\n            if ((a&1)!=0) {\n                res += b;\n                if (res >= m) res -= m;\n            }\n            a >>= 1;\n            b <<= 1;\n            if (b >= m) b -= m;\n        }\n        return res;\n    }\n    \n    static int abs(int a,int b){\n\treturn (int)Math.abs(a-b);\n    }\n \n    public static long abs(long a,long b){\n\treturn (long)Math.abs(a-b);\n    }\n    \n    static int max(int a,int b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n \n    static int min(int a,int b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n    \n    static long max(long a,long b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n \n    static long min(long a,long b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n \n    static long pow(long n,long p,long m){\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n          \n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n    }\n    \n    static long pow(long n,long p){\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n          \n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n    }\n    \n    static void debug(Object... o) {\n            System.out.println(Arrays.deepToString(o));\n    }\n     \n    static class InputReader {\n    \n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n                this.stream = stream;\n        }\n \n        public int snext() {\n                if (snumChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= snumChars) {\n                        curChar = 0;\n                        try {\n                                snumChars = stream.read(buf);\n                        } catch (IOException e) {\n                                throw new InputMismatchException();\n                        }\n                        if (snumChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n \n        public int nextInt() {\n                int c = snext();\n                while (isSpaceChar(c)) {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                        sgn = -1;\n                        c = snext();\n                }\n                int res = 0;\n                do {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n \n        public long nextLong() {\n                int c = snext();\n                while (isSpaceChar(c)) {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-') {\n                        sgn = -1;\n                        c = snext();\n                }\n                long res = 0;\n                do {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++) {\n                        a[i] = nextInt();\n                }\n                return a;\n        }\n \n        public long[] nextLongArray(int n) {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++) {\n                        a[i] = nextLong();\n                }\n                return a;\n        }\n \n        public String readString() {\n                int c = snext();\n                while (isSpaceChar(c)) {\n                        c = snext();\n                }\n                StringBuilder res = new StringBuilder();\n                do {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res.toString();\n        }\n \n        public String nextLine() {\n                int c = snext();\n                while (isSpaceChar(c))\n                        c = snext();\n                StringBuilder res = new StringBuilder();\n                do {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isEndOfLine(c));\n                return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) {\n                if (filter != null)\n                        return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) {\n                return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n                public boolean isSpaceChar(int ch);\n        }\n        \n    }\n}    \n "
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.buffer.readline\n \ndef gcd(a, b):\n    if a > b:\n        a, b = b, a\n    if b % a==0:\n        return a\n    return gcd(b % a, a)\n \ndef process(a, b):\n    g = gcd(a, b)\n    r = a//g\n    s = b//g\n    if g % r != 0:\n        return 'No'\n    g = g//r\n    if g % s != 0:\n        return 'No'\n    G3 = g//s\n    G = round(G3**(1/3))\n    cube = False\n    for i in range(10):\n        if (G-i)**3==G3 or (G+i)**3==G3:\n            cube = True\n            break\n    if not cube:\n        return 'No'\n    return 'Yes'\n \nn = int(input())\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    sys.stdout.write(process(a, b)+'\\n')"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst char letters[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n                        'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n                        's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\nconst int dx[] = {0, -1, 0, 1, -1, -1, 1, 1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint inline max3(int a, int b, int c) { return max(a, max(b, c)); }\nint n;\nlong long ab, a, b;\nint main() {\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%lld\", &a);\n    scanf(\"%lld\", &b);\n    ab = a * 1LL * b;\n    int l = 1, r = 1e6, mid;\n    while (l < r) {\n      mid = l + (r - l + 1) / 2;\n      if (1LL * mid * mid * mid <= ab)\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    if (1LL * r * r * r == ab && a % r == 0 && b % r == 0)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.net.Inet4Address;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF833A {\n\n    public static long getRoot(long n, int k) {\n        if (k == 0)\n            return n == 1 ? 1 : -1;\n\n        long x = (long) Math.ceil(Math.pow(n, 1.0 / k));\n        if (power(x, k) == n)\n            return x;\n        else return -1;\n    }\n\n    public static long power(long n, int p) {\n        if (p == 0)\n            return 1;\n        long h = power(n, p / 2);\n        long a = h * h;\n        if (p % 2 == 1) {\n            a *= n;\n        }\n        return a;\n    }\n\n\n    public static boolean isPowerOf(int num, int base) {\n        if (num == 0)\n            return false;\n        if (base == 1)\n            return num == 1;\n\n        while (num % base == 0) {\n            num /= base;\n        }\n        return num == 1;\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int ntest = fr.nextInt();\n\n        for (int i = 0; i < ntest; ++i) {\n            int a = fr.nextInt();\n            int b = fr.nextInt();\n            long v = (long) a * b;\n            long x = (long) Math.ceil(Math.pow(v, 1.0 / 3));\n            bw.write(x * x * x == v && a % x == 0 && b % x == 0 ? \"Yes\\n\" : \"No\\n\");\n        }\n        bw.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace chtholly {\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar()) f ^= c == '-';\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ '0');\n  return f ? x : -x;\n}\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x) {\n  x = 0;\n  int f = 1;\n  char c = getchar();\n  for (; !isdigit(c) && ~c; c = getchar()) f ^= c == '-';\n  if (!~c) return 0;\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ '0');\n  return x = f ? x : -x, 1;\n}\ntemplate <typename mitsuha>\ninline int write(mitsuha x) {\n  if (!x) return 0 & putchar(48);\n  if (x < 0) x = -x, putchar('-');\n  int bit[20], i, p = 0;\n  for (; x; x /= 10) bit[++p] = x % 10;\n  for (i = p; i; --i) putchar(bit[i] + 48);\n  return 0;\n}\ninline char fuhao() {\n  char c = getchar();\n  for (; isspace(c); c = getchar())\n    ;\n  return c;\n}\n}  // namespace chtholly\nusing namespace chtholly;\nusing namespace std;\nlong long T, a, b, t;\ninline long long gcd(long long u, long long v) {\n  for (; u && v && u != v;) {\n    swap(u, v);\n    u %= v;\n  }\n  return max(u, v);\n}\nint main() {\n  long long i, j, l, r, mid, t, ji, g, ji2;\n  cin >> T;\n  while (T--) {\n    scanf(\"%lld%lld\", &a, &b);\n    ji = ji2 = a * b;\n    a = b = gcd(a, b);\n    g = gcd(a, ji), ji /= g, a /= g;\n    a *= b;\n    g = gcd(a, ji), ji /= g, a /= g;\n    a *= b;\n    g = gcd(a, ji), ji /= g, a /= g;\n    if (ji > 1) {\n      puts(\"No\");\n      continue;\n    }\n    for (l = 1, r = 1000001; l < r;) {\n      mid = ((l + r) >> 1);\n      t = mid * mid * mid;\n      if (t < ji2)\n        l = mid + 1;\n      else\n        r = mid;\n    }\n    if (l * l * l != ji2)\n      puts(\"No\");\n    else\n      puts(\"Yes\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9;\nlong long gcd(long long a, long long b) {\n  long long c;\n  while (b) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\nint main() {\n  int t;\n  ios::sync_with_stdio(0);\n  cin >> t;\n  while (t--) {\n    long long a, b;\n    cin >> a >> b;\n    long long tmp = a * b;\n    tmp = pow(tmp, 1.0 / 3.0);\n    if (tmp * tmp * tmp != a * b) {\n      tmp++;\n    }\n    if (tmp * tmp * tmp != a * b) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    if (tmp > a || tmp > b) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    if (gcd(tmp, a) != tmp || gcd(tmp, b) != tmp) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    cout << \"Yes\" << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class CF833A\n{\n   public static void main(String[]args) throws IOException\n   {\n      BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter pw = new PrintWriter(System.out);\n      int n = Integer.parseInt(f.readLine());\n      for(int i=0;i<n;i++)\n      {\n         StringTokenizer st = new StringTokenizer(f.readLine());\n         long a = Long.parseLong(st.nextToken());\n         long b = Long.parseLong(st.nextToken());\n         long var = (long)Math.cbrt(a*b);\n         if(var*var*var==a*b&&a%var==0 && b%var==0)\n            pw.println(\"Yes\");\n         else\n            pw.println(\"No\");\n      }\n      pw.close();\n   }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                solveGame(in, out);\n            }\n        }\n\n        void solveGame(InputReader in, PrintWriter out) {\n            long a = in.nextInt();\n            long b = in.nextInt();\n\n            double x = Math.cbrt(a * b);\n            long r = Math.round(x);\n\n            if (r * r * r != a * b) {\n                out.println(\"No\");\n                return;\n            }\n\n            if ((a % r != 0) || (b % r != 0)) {\n                out.println(\"No\");\n                return;\n            }\n            out.println(\"Yes\");\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                    //tok = new StringTokenizer(in.readLine(), \", \\t\\n\\r\\f\"); //adds commas as delimeter\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = 3.1415926535897932384626433832795l;\ntemplate <typename T>\ninline auto sqr(T x) -> decltype(x * x) {\n  return x * x;\n}\ntemplate <typename T1, typename T2>\ninline bool umx(T1& a, T2 b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename T1, typename T2>\ninline bool umn(T1& a, T2 b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nconst int N = 31;\nint d[N][N];\nvector<int> p;\nbool check(int a) {\n  for (int i = 2; 1ll * i * i <= a; ++i) {\n    if (a % i == 0) return 0;\n  }\n  return 1;\n}\nset<int> sq;\nint main() {\n  cout.setf(ios::showpoint | ios::fixed);\n  cout.precision(20);\n  memset(d, 0, sizeof(d));\n  d[0][0] = 1;\n  for (int i = int(2); i < int(1000); ++i) {\n    if (check(i)) {\n      p.push_back(i);\n    }\n  }\n  for (int i = int(0); i < int(N); ++i) {\n    for (int j = int(0); j < int(N); ++j) {\n      if (!d[i][j]) continue;\n      for (int k = int(0); k < int(N); ++k) {\n        if (i + 2 * k < N && j + k < N) {\n          d[i + 2 * k][j + k] = N;\n        }\n        if (i + k < N && j + 2 * k < N) {\n          d[i + k][j + 2 * k] = N;\n        }\n      }\n    }\n  }\n  for (int i = 1; i * i <= 1000000000; ++i) {\n    if (check(i)) sq.insert(i * i);\n  }\n  int n;\n  cin >> n;\n  for (int i = int(0); i < int(n); ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    bool ok = 1;\n    for (auto prime : p) {\n      int kola = 0, kolb = 0;\n      while (a % prime == 0) {\n        a /= prime, kola++;\n      }\n      while (b % prime == 0) {\n        b /= prime, kolb++;\n      }\n      if (!d[kola][kolb]) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok &&\n        ((a == b && a == 1) || (sq.find(a) != sq.end() && 1ll * b * b == a) ||\n         (sq.find(b) != sq.end() && 1ll * a * a == b))) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            ATheMeaninglessGame solver = new ATheMeaninglessGame();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class ATheMeaninglessGame {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            String yes = \"Yes\";\n            String no = \"No\";\n            IntegerMultiWayStack stack = Factorization.factorizeRangePrime((int) 1e6);\n            for (int i = 0; i < n; i++) {\n                int a = in.readInt();\n                int b = in.readInt();\n\n                int m = find((long) a * b);\n                if (m == -1) {\n                    out.println(no);\n                    continue;\n                }\n\n                boolean valid = true;\n                for (IntegerIterator iterator = stack.iterator(m); iterator.hasNext() && valid; ) {\n                    int p = iterator.next();\n                    int c = log(p, a);\n                    int d = log(p, b);\n\n                    if (2 * c - d < 0 || (2 * c - d) % 3 != 0) {\n                        valid = false;\n                    }\n                    if (2 * d - c < 0 || (2 * d - c) % 3 != 0) {\n                        valid = false;\n                    }\n                }\n\n                out.println(valid ? yes : no);\n            }\n        }\n\n        public int log(int x, int y) {\n            int ans = 0;\n            while (y % x == 0) {\n                ans++;\n                y /= x;\n            }\n            return ans;\n        }\n\n        public int find(long n) {\n            int l = 1;\n            int r = (int) 1e6;\n            while (l < r) {\n                long m = (l + r + 1) >> 1;\n                if (m * m * m <= n) {\n                    l = (int) m;\n                } else {\n                    r = (int) (m - 1);\n                }\n            }\n            return (long) l * l * l == n ? l : -1;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class IntegerMultiWayStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntegerIterator iterator(final int queue) {\n            return new IntegerIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public IntegerMultiWayStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append(\": \");\n                for (IntegerIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class MinimumNumberWithMaximumFactors {\n        private static int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};\n\n        public static long[] maximumPrimeFactor(long n) {\n            long[] ans = new long[2];\n            ans[0] = 1;\n            for (int i = 0; i < primes.length; i++) {\n                if (DigitUtils.isMultiplicationOverflow(ans[0], primes[i], n)) {\n                    break;\n                }\n                ans[0] *= primes[i];\n                ans[1]++;\n            }\n            return ans;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static boolean isMultiplicationOverflow(long a, long b, long limit) {\n            if (limit < 0) {\n                limit = -limit;\n            }\n            if (a < 0) {\n                a = -a;\n            }\n            if (b < 0) {\n                b = -b;\n            }\n            if (a == 0 || b == 0) {\n                return false;\n            }\n            //a * b > limit => a > limit / b\n            return a > limit / b;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerMultiWayStack factorizeRangePrime(int n) {\n            int maxFactorCnt = (int) MinimumNumberWithMaximumFactors.maximumPrimeFactor(n)[1];\n            IntegerMultiWayStack stack = new IntegerMultiWayStack(n + 1, n * maxFactorCnt);\n            boolean[] isComp = new boolean[n + 1];\n            for (int i = 2; i <= n; i++) {\n                if (isComp[i]) {\n                    continue;\n                }\n                for (int j = i; j <= n; j += i) {\n                    isComp[j] = true;\n                    stack.addLast(j, i);\n                }\n            }\n            return stack;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool solve() {\n  int a, b;\n  scanf(\"%d %d\", &a, &b);\n  int both = int(floor(pow((double)a * b, 1.0 / 3) + 0.5));\n  if (both == 0) return a == 1 && b == 1;\n  if (a % both != 0 || b % both != 0) return false;\n  if ((long long)a * b != (long long)both * both * both) return false;\n  long long A = a / both;\n  long long B = b / both;\n  if (B * B * A != b || A * A * B != a) return false;\n  return true;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    if (solve())\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    int64_t x = a * (int64_t)b, y = cbrtl(x) + 0.5;\n    puts(y * y * y == x && a % y == 0 && b % y == 0 ? \"Yes\" : \"No\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b) {\n  if (a < b) swap(a, b);\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  unordered_set<int> cube;\n  for (int i = 1; i <= 1000; i++) cube.insert(i * i * i);\n  int N;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    int a, b, c, d;\n    scanf(\"%d%d\", &a, &b);\n    int t = gcd(a, b);\n    c = a / t;\n    d = b / t;\n    long long q = 1LL * c * d;\n    if (t % q != 0) {\n      printf(\"No\\n\");\n    } else {\n      int r = t / q;\n      if (cube.find(r) == cube.end())\n        printf(\"No\\n\");\n      else\n        printf(\"Yes\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nvoid solve(istream& cin, ostream& cout) {\n  int n;\n  cin >> n;\n  for (int in = (0); in < int(n); ++in) {\n    lint a, b;\n    cin >> a >> b;\n    lint c = a * b;\n    lint x = lint(pow(c, 1.0 / 3)) - 3;\n    x = max<lint>(1, x);\n    bool ok = false;\n    while (x * x * x <= c) {\n      if (x * x * x == c) {\n        ok = true;\n        break;\n      }\n      x++;\n    }\n    if (ok && a % x == 0 && b % x == 0) {\n      cout << \"Yes\\n\";\n    } else {\n      cout << \"No\\n\";\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve(cin, cout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> cube;\nint main() {\n  int t, u, v;\n  long long int x;\n  for (long long int i = 1; i <= 1000000; i++) cube.push_back(i * i * i);\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d %d\", &u, &v);\n    x = (long long int)u * v;\n    int p = lower_bound(cube.begin(), cube.end(), x) - cube.begin() + 1;\n    if (cube[p - 1] != x)\n      puts(\"No\");\n    else {\n      if ((u % p) || (v % p))\n        puts(\"No\");\n      else\n        puts(\"Yes\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Wolfgang Beyer\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                solveGame(in, out);\n            }\n        }\n\n        void solveGame(InputReader in, PrintWriter out) {\n            long a = in.nextInt();\n            long b = in.nextInt();\n\n            double x = Math.cbrt(a * b);\n            long r = Math.round(x);\n\n            if (r * r * r != a * b) {\n                out.println(\"No\");\n                return;\n            }\n\n            long s = a / r;\n            long p = b / r;\n            //if (s * r != a || p * r !=)\n            if ((a % r != 0) || (b % r != 0)) {\n                out.println(\"No\");\n                return;\n            }\n            out.println(\"Yes\");\n\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                    //tok = new StringTokenizer(in.readLine(), \", \\t\\n\\r\\f\"); //adds commas as delimeter\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 9;\nconst int mod = 1e9 + 7;\nint n, m, k;\nconst int MX = 1000010;\nint sito[MX + 5];\nvector<int> primes;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int a, b;\n    cin >> a >> b;\n    long long int ilo = a * b;\n    long long int x = 1, y = MX;\n    while (x < y) {\n      long long int sr = (x + y) / 2;\n      if (sr * sr * sr < ilo)\n        x = ++sr;\n      else\n        y = sr;\n    }\n    bool odp = 1;\n    if (x * x * x != ilo)\n      odp = 0;\n    else {\n      if (a % x != 0) odp = 0;\n      if (b % x != 0) odp = 0;\n    }\n    if (odp)\n      cout << \"Yes\\n\";\n    else\n      cout << \"No\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\nimport java.util.Queue;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class A implements Runnable{\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    private final static Random rnd = new Random();\n    private final static String fileName = \"\";\n\n    private final static long MODULO = 1000 * 1000 * 1000 + 7;\n\n    private void solve() {\n        int tests = readInt();\n        while (tests --> 0) {\n            long a = readLong();\n            long b = readLong();\n\n            long c = a * b;\n            long cbrt = cbrtLong(c);\n\n            boolean answer = (\n                    cbrt != -1\n                    && a % cbrt == 0\n                    && b % cbrt == 0\n            );\n\n            out.println(answer ? \"YES\" : \"NO\");\n        }\n    }\n\n    long cbrtLong(long n) {\n        long res = 0;\n        for (long bit = 20; bit >= 0; --bit) {\n            long next = (res | (1L << bit));\n            if (next * next * next <= n) {\n                res = next;\n            }\n        }\n\n        return (res * res * res == n ? res : -1);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long add(long a, long b) { return (a + b) % MODULO; }\n    private static long subtract(long a, long b) { return add(a, MODULO - b) % MODULO; }\n    private static long mult(long a, long b) { return (a * b) % MODULO; }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final boolean ONLINE_JUDGE = !new File(\"input.txt\").exists();\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = false;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new A(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (ONLINE_JUDGE){\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new OutputWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new OutputWriter(fileName + \".out\");\n            }\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine(), delim);\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        int sign = 1;\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return sign * result;\n                    throw new NumberFormatException();\n                }\n\n                if (j == '-') {\n                    if (started) throw new NumberFormatException();\n                    sign = -sign;\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return sign * result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    @Deprecated\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    private static class GraphBuilder {\n\n        final int size;\n        final List<Integer>[] edges;\n\n        static GraphBuilder createInstance(int size) {\n            List<Integer>[] edges = new List[size];\n            for (int v = 0; v < size; ++v) {\n                edges[v] = new ArrayList<>();\n            }\n\n            return new GraphBuilder(edges);\n        }\n\n        private GraphBuilder(List<Integer>[] edges) {\n            this.size = edges.length;\n            this.edges = edges;\n        }\n\n        public void addEdge(int from, int to) {\n            addDirectedEdge(from, to);\n            addDirectedEdge(to, from);\n        }\n\n        public void addDirectedEdge(int from, int to) {\n            edges[from].add(to);\n        }\n\n        public int[][] build() {\n            int[][] graph = new int[size][];\n            for (int v = 0; v < size; ++v) {\n                List<Integer> vEdges = edges[v];\n                graph[v] = castInt(vEdges);\n            }\n\n            return graph;\n        }\n    }\n\n    private final static int ZERO_INDEXATION = 0, ONE_INDEXATION = 1;\n\n    private int[][] readUnweightedGraph(int vertexNumber, int edgesNumber) {\n        return readUnweightedGraph(vertexNumber, edgesNumber, ONE_INDEXATION, false);\n    }\n\n    private int[][] readUnweightedGraph(int vertexNumber, int edgesNumber,\n                                        int indexation, boolean directed\n    ) {\n        GraphBuilder graphBuilder = GraphBuilder.createInstance(vertexNumber);\n        for (int i = 0; i < edgesNumber; ++i) {\n            int from = readInt() - indexation;\n            int to = readInt() - indexation;\n\n            if (directed) graphBuilder.addDirectedEdge(from, to);\n            else graphBuilder.addEdge(from, to);\n        }\n\n        return graphBuilder.build();\n    }\n\n    private static class Edge {\n        int to;\n        int w;\n\n        Edge(int to, int w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n\n    private Edge[][] readWeightedGraph(int vertexNumber, int edgesNumber) {\n        return readWeightedGraph(vertexNumber, edgesNumber, ONE_INDEXATION, false);\n    }\n\n    private Edge[][] readWeightedGraph(int vertexNumber, int edgesNumber,\n                                       int indexation, boolean directed) {\n        @SuppressWarnings(\"unchecked\")\n        List<Edge>[] graph = new List[vertexNumber];\n        for (int v = 0; v < vertexNumber; ++v) {\n            graph[v] = new ArrayList<>();\n        }\n\n        while (edgesNumber --> 0) {\n            int from = readInt() - indexation;\n            int to = readInt() - indexation;\n            int w = readInt();\n\n            graph[from].add(new Edge(to, w));\n            if (!directed) graph[to].add(new Edge(from, w));\n        }\n\n        Edge[][] graphArrays = new Edge[vertexNumber][];\n        for (int v = 0; v < vertexNumber; ++v) {\n            graphArrays[v] = graph[v].toArray(new Edge[0]);\n        }\n\n        return graphArrays;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<A.IntIndexPair>() {\n\n            @Override\n            public int compare(A.IntIndexPair indexPair1, A.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<A.IntIndexPair>() {\n\n            @Override\n            public int compare(A.IntIndexPair indexPair1, A.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static IntIndexPair[] from(int[] array) {\n            IntIndexPair[] iip = new IntIndexPair[array.length];\n            for (int i = 0; i < array.length; ++i) {\n                iip[i] = new IntIndexPair(array[i], i);\n            }\n\n            return iip;\n        }\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants andTo functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    int[] getDivisors(int value) {\n        List<Integer> divisors = new ArrayList<>();\n        for (int divisor = 1; divisor * divisor <= value; ++divisor) {\n            if (value % divisor == 0) {\n                divisors.add(divisor);\n                if (divisor * divisor != value) {\n                    divisors.add(value / divisor);\n                }\n            }\n        }\n\n        return castInt(divisors);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n/////////////////////////////////////////////////////////////////////\n\n    private interface MultiSet<ValueType> {\n\n        int size();\n\n        void inc(ValueType value);\n        boolean dec(ValueType value);\n\n        int count(ValueType value);\n    }\n\n    private static abstract class MultiSetImpl\n            <ValueType, MapType extends Map<ValueType, Integer>>\n            implements MultiSet<ValueType> {\n\n        protected final MapType map;\n        protected int size;\n\n        protected MultiSetImpl(MapType map) {\n            this.map = map;\n            this.size = 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void inc(ValueType value) {\n            int count = count(value);\n            map.put(value, count + 1);\n\n            ++size;\n        }\n\n        public boolean dec(ValueType value) {\n            int count = count(value);\n            if (count == 0) return false;\n\n            if (count == 1) map.remove(value);\n            else map.put(value, count - 1);\n\n            --size;\n            return true;\n        }\n\n        public int count(ValueType value) {\n            Integer count = map.get(value);\n            return (count == null ? 0 : count);\n        }\n    }\n\n    private static class HashMultiSet<ValueType>\n            extends MultiSetImpl<ValueType, Map<ValueType, Integer>> {\n\n        public static <ValueType> MultiSet<ValueType> createMultiSet() {\n            Map<ValueType, Integer> map = new HashMap<>();\n            return new HashMultiSet<>(map);\n        }\n\n        HashMultiSet(Map<ValueType, Integer> map) {\n            super(map);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private interface SortedMultiSet<ValueType> extends MultiSet<ValueType> {\n\n        ValueType min();\n        ValueType max();\n\n        ValueType pollMin();\n        ValueType pollMax();\n\n        ValueType lower(ValueType value);\n        ValueType floor(ValueType value);\n\n        ValueType ceiling(ValueType value);\n        ValueType higher(ValueType value);\n    }\n\n    private static abstract class SortedMultiSetImpl<ValueType>\n            extends MultiSetImpl<ValueType, NavigableMap<ValueType, Integer>>\n            implements SortedMultiSet<ValueType> {\n\n        SortedMultiSetImpl(NavigableMap<ValueType, Integer> map) {\n            super(map);\n        }\n\n        @Override\n        public ValueType min() {\n            return (size == 0 ? null : map.firstKey());\n        }\n\n        @Override\n        public ValueType max() {\n            return (size == 0 ? null : map.lastKey());\n        }\n\n        @Override\n        public ValueType pollMin() {\n            ValueType first = min();\n            if (first != null) dec(first);\n            return first;\n        }\n\n        @Override\n        public ValueType pollMax() {\n            ValueType last = max();\n            dec(last);\n            return last;\n        }\n\n        @Override\n        public ValueType lower(ValueType value) {\n            return map.lowerKey(value);\n        }\n\n        @Override\n        public ValueType floor(ValueType value) {\n            return map.floorKey(value);\n        }\n\n        @Override\n        public ValueType ceiling(ValueType value) {\n            return map.ceilingKey(value);\n        }\n\n        @Override\n        public ValueType higher(ValueType value) {\n            return map.higherKey(value);\n        }\n    }\n\n    private static class TreeMultiSet<ValueType>\n            extends SortedMultiSetImpl<ValueType> {\n\n        public static <ValueType> SortedMultiSet<ValueType> createMultiSet() {\n            NavigableMap<ValueType, Integer> map = new TreeMap<>();\n            return new TreeMultiSet<>(map);\n        }\n\n        TreeMultiSet(NavigableMap<ValueType, Integer> map) {\n            super(map);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int register(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n\n        int getId(KeyType key) {\n            return get(key);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class SortedIdMapper<ValueType extends Comparable<ValueType>> {\n\n        private final List<ValueType> values;\n\n        public SortedIdMapper() {\n            this.values = new ArrayList<>();\n        }\n\n        void addValue(ValueType value) {\n            values.add(value);\n        }\n\n        IdMap<ValueType> build() {\n            Collections.sort(values);\n\n            IdMap<ValueType> ids = new IdMap<ValueType>();\n\n            for (int index = 0; index < values.size(); ++index) {\n                ValueType value = values.get(index);\n                if (index == 0 || values.get(index - 1).compareTo(value) != 0) {\n                    ids.register(value);\n                }\n            }\n\n            return ids;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] castInt(List<Integer> list) {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static long[] castLong(List<Long> list) {\n        long[] array = new long[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    /**\n     * Generates list with keys 0..<n\n     * @param n - exclusive limit of sequence\n     */\n    private static List<Integer> order(int n) {\n        List<Integer> sequence = new ArrayList<>();\n        for (int i = 0; i < n; ++i) {\n            sequence.add(i);\n        }\n\n        return sequence;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    interface Rmq {\n        int getMin(int left, int right);\n        int getMinIndex(int left, int right);\n    }\n\n    private static class SparseTable implements Rmq {\n\n        private static final int MAX_BIT = 20;\n\n        int n;\n        int[] array;\n\n        SparseTable(int[] array) {\n            this.n = array.length;\n            this.array = array;\n        }\n\n        int[] lengthMaxBits;\n        int[][] table;\n\n        int getIndexOfLess(int leftIndex, int rightIndex) {\n            return (array[leftIndex] <= array[rightIndex])\n                    ? leftIndex\n                    : rightIndex;\n        }\n\n        SparseTable build() {\n            this.lengthMaxBits = new int[n + 1];\n            lengthMaxBits[0] = 0;\n            for (int i = 1; i <= n; ++i) {\n                lengthMaxBits[i] = lengthMaxBits[i - 1];\n                int length = (1 << lengthMaxBits[i]);\n                if (length + length <= i) ++lengthMaxBits[i];\n            }\n\n            this.table = new int[MAX_BIT][n];\n            table[0] = castInt(order(n));\n\n            for (int bit = 0; bit < MAX_BIT - 1; ++bit) {\n                for (int i = 0, j = (1 << bit); j < n; ++i, ++j) {\n                    table[bit + 1][i] = getIndexOfLess(\n                            table[bit][i], table[bit][j]\n                    );\n                }\n            }\n\n            return this;\n        }\n\n        @Override\n        public int getMinIndex(int left, int right) {\n            int length = (right - left + 1);\n\n            int bit = lengthMaxBits[length];\n            int segmentLength = (1 << bit);\n\n            return getIndexOfLess(\n                    table[bit][left], table[bit][right - segmentLength + 1]\n            );\n        }\n\n        @Override\n        public int getMin(int left, int right) {\n            return array[getMinIndex(left, right)];\n        }\n    }\n\n    private static Rmq createRmq(int[] array) {\n        return new SparseTable(array).build();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    interface Lca {\n        Lca build(int root);\n        int lca(int a, int b);\n\n        int height(int v);\n    }\n\n    private static class LcaRmq implements Lca {\n\n        int n;\n        int[][] graph;\n\n        LcaRmq(int[][] graph) {\n            this.n = graph.length;\n            this.graph = graph;\n        }\n\n        int time;\n\n        int[] order;\n        int[] heights;\n        int[] first;\n\n        Rmq rmq;\n\n        @Override\n        public LcaRmq build(int root) {\n            this.order = new int[n + n];\n            this.heights = new int[n];\n\n            this.first = new int[n];\n            Arrays.fill(first, -1);\n\n            this.time = 0;\n            dfs(root, 0);\n\n            int[] orderedHeights = new int[n + n];\n            for (int i = 0; i < order.length; ++i) {\n                orderedHeights[i] = heights[order[i]];\n            }\n\n            this.rmq = createRmq(orderedHeights);\n            return this;\n        }\n\n        void dfs(int from, int height) {\n            first[from] = time;\n            order[time] = from;\n            heights[from] = height;\n            ++time;\n\n            for (int to : graph[from]) {\n                if (first[to] == -1) {\n                    dfs(to, height + 1);\n\n                    order[time] = from;\n                    ++time;\n                }\n            }\n        }\n\n        @Override\n        public int lca(int a, int b) {\n            int aFirst = first[a], bFirst = first[b];\n            int left = min(aFirst, bFirst), right = max(aFirst, bFirst);\n\n            int orderIndex = rmq.getMinIndex(left, right);\n            return order[orderIndex];\n        }\n\n        @Override\n        public int height(int v) {\n            return heights[v];\n        }\n    }\n\n    private static class LcaBinary implements Lca {\n\n        private static final int MAX_BIT = 20;\n\n        int n;\n        int[][] graph;\n\n        int[] h;\n        int[][] parents;\n\n        LcaBinary(int[][] graph) {\n            this.n = graph.length;\n            this.graph = graph;\n        }\n\n        @Override\n        public Lca build(int root) {\n            this.h = new int[n];\n\n            this.parents = new int[MAX_BIT][n];\n            Arrays.fill(parents[0], -1);\n\n            Queue<Integer> queue = new ArrayDeque<>();\n\n            queue.add(root);\n            add(root, root);\n\n            while (queue.size() > 0) {\n                int from = queue.poll();\n                for (int to : graph[from]) {\n                    if (parents[0][to] == -1) {\n                        add(from, to);\n                        queue.add(to);\n                    }\n                }\n            }\n\n            return this;\n        }\n\n        void add(int parent, int v) {\n            h[v] = h[parent] + 1;\n            parents[0][v] = parent;\n            for (int bit = 0; bit < MAX_BIT - 1; ++bit) {\n                parents[bit + 1][v] = parents[bit][parents[bit][v]];\n            }\n        }\n\n        @Override\n        public int lca(int a, int b) {\n            if (h[a] < h[b]) {\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n\n            int delta = h[a] - h[b];\n            for (int bit = MAX_BIT - 1; bit >= 0; --bit) {\n                if (delta >= (1 << bit)) {\n                    delta -= (1 << bit);\n                    a = parents[bit][a];\n                }\n            }\n\n            if (a == b) return a;\n\n            for (int bit = MAX_BIT - 1; bit >= 0; --bit) {\n                int nextA = parents[bit][a], nextB = parents[bit][b];\n                if (nextA != nextB) {\n                    a = nextA;\n                    b = nextB;\n                }\n            }\n\n            return parents[0][a];\n        }\n\n        @Override\n        public int height(int v) {\n            return h[v];\n        }\n    }\n\n    private static Lca createLca(int[][] graph, int root) {\n        return new LcaRmq(graph).build(root);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class BiconnectedGraph {\n\n        int n;\n        int[][] graph;\n\n        BiconnectedGraph(int[][] graph) {\n            this.n = graph.length;\n            this.graph = graph;\n        }\n\n        int time;\n        int[] tin, up;\n\n        boolean[] used;\n\n        BiconnectedGraph build() {\n            calculateTimes();\n            condensateComponents();\n\n            return this;\n        }\n\n        void calculateTimes() {\n            this.tin = new int[n];\n            this.up = new int[n];\n\n            this.time = 0;\n\n            this.used = new boolean[n];\n            timeDfs(0, -1);\n        }\n\n        void timeDfs(int from, int parent) {\n            used[from] = true;\n\n            up[from] = tin[from] = time;\n            ++time;\n\n            for (int to : graph[from]) {\n                if (to == parent) continue;\n\n                if (used[to]) {\n                    up[from] = min(up[from], tin[to]);\n                } else {\n                    timeDfs(to, from);\n                    up[from] = min(up[from], up[to]);\n                }\n            }\n        }\n\n        int[] components;\n        int[][] componentsGraph;\n\n        int component(int v) { return components[v]; }\n\n        int[][] toGraph() {\n            return componentsGraph;\n        }\n\n        void condensateComponents() {\n            this.components = new int[n];\n            Arrays.fill(components, -1);\n\n            for (int v = 0; v < n; ++v) {\n                if (components[v] == -1) {\n                    componentsDfs(v, v);\n                }\n            }\n\n            GraphBuilder graphBuilder = GraphBuilder.createInstance(n);\n\n            Set<Point> edges = new HashSet<>();\n            for (int from = 0; from < n; ++from) {\n                int fromComponent = components[from];\n\n                for (int to : graph[from]) {\n                    int toComponent = components[to];\n                    if (fromComponent == toComponent) continue;\n\n                    Point edge = new Point(fromComponent, toComponent);\n                    if (edges.add(edge)) graphBuilder.addDirectedEdge(fromComponent, toComponent);\n                }\n            }\n\n            this.componentsGraph = graphBuilder.build();\n        }\n\n        void componentsDfs(int from, int color) {\n            components[from] = color;\n            for (int to : graph[from]) {\n                if (components[to] != -1) continue;\n\n                if (tin[from] >= up[to] && tin[to] >= up[from]) {\n                    componentsDfs(to, color);\n                }\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class VertexBiconnectedGraph {\n\n        static class Edge {\n            int to;\n            int index;\n\n            Edge(int to, int index) {\n                this.to = to;\n                this.index = index;\n            }\n        }\n\n        int n, m;\n        List<Edge>[] graph;\n        List<Edge> edges;\n\n        VertexBiconnectedGraph(int n) {\n            this.n = n;\n            this.m = 0;\n\n            this.graph = new List[n];\n            for (int v = 0; v < n; ++v) {\n                graph[v] = new ArrayList<>();\n            }\n\n            this.edges = new ArrayList<>();\n        }\n\n        void addEdge(int from, int to) {\n            Edge fromToEdge = new Edge(to, m);\n            Edge toFromEdge = new Edge(from, m + 1);\n\n            edges.add(fromToEdge);\n            edges.add(toFromEdge);\n\n            graph[from].add(fromToEdge);\n            graph[to].add(toFromEdge);\n\n            m += 2;\n        }\n\n        int time;\n\n        boolean[] used;\n        int[] tin, up;\n        int[] parents;\n\n        boolean[] isArticulation;\n\n        boolean[] findArticulationPoints() {\n            this.isArticulation = new boolean[n];\n\n            this.used = new boolean[n];\n            this.parents = new int[n];\n            Arrays.fill(parents, -1);\n\n            this.tin = new int[n];\n            this.up = new int[n];\n\n            this.time = 0;\n\n            for (int v = 0; v < n; ++v) {\n                if (!used[v]) {\n                    articulationDfs(v, -1);\n                }\n            }\n\n            return isArticulation;\n        }\n\n        void articulationDfs(int from, int parent) {\n            used[from] = true;\n            parents[from] = parent;\n\n            ++time;\n            up[from] = tin[from] = time;\n\n            int childrenCount = 0;\n\n            for (Edge e : graph[from]) {\n                int to = e.to;\n\n                if (to == parent) continue;\n\n                if (used[to]) {\n                    up[from] = min(up[from], tin[to]);\n                } else {\n                    ++childrenCount;\n\n                    articulationDfs(to, from);\n                    up[from] = min(up[from], up[to]);\n                    if (up[to] >= tin[from] && parent != -1) {\n                        isArticulation[from] = true;\n                    }\n                }\n            }\n\n            if (parent == -1 && childrenCount > 1) {\n                isArticulation[from] = true;\n            }\n        }\n\n        int[] edgeColors;\n        int maxEdgeColor;\n\n        int[] paintEdges() {\n            this.edgeColors = new int[m];\n            Arrays.fill(edgeColors, -1);\n\n            this.maxEdgeColor = -1;\n\n            this.used = new boolean[n];\n\n            for (int v = 0; v < n; ++v) {\n                if (!used[v]) {\n                    ++maxEdgeColor;\n                    paintDfs(v, maxEdgeColor, -1);\n                }\n            }\n\n            return edgeColors;\n        }\n\n        void paintEdge(int edgeIndex, int color) {\n            if (edgeColors[edgeIndex] != -1) return;\n\n            edgeColors[edgeIndex] = edgeColors[edgeIndex ^ 1] = color;\n        }\n\n        void paintDfs(int from, int color, int parent) {\n            used[from] = true;\n\n            for (Edge e : graph[from]) {\n                int to = e.to;\n                if (to == parent) continue;\n\n                if (!used[to]) {\n                    if (up[to] >= tin[from]) {\n                        int newColor = ++maxEdgeColor;\n                        paintEdge(e.index, newColor);\n                        paintDfs(to, newColor, from);\n                    } else {\n                        paintEdge(e.index, color);\n                        paintDfs(to, color, from);\n                    }\n                } else if (up[to] <= tin[from]){\n                    paintEdge(e.index, color);\n                }\n            }\n        }\n\n        Set<Integer>[] collectVertexEdgeColors() {\n            Set<Integer>[] vertexEdgeColors = new Set[n];\n            for (int v = 0; v < n; ++v) {\n                vertexEdgeColors[v] = new HashSet<>();\n                for (Edge e : graph[v]) {\n                    vertexEdgeColors[v].add(edgeColors[e.index]);\n                }\n            }\n\n            return vertexEdgeColors;\n        }\n\n        VertexBiconnectedGraph build() {\n            findArticulationPoints();\n            paintEdges();\n            createComponentsGraph();\n\n            return this;\n        }\n\n        int[][] componentsGraph;\n\n        void createComponentsGraph() {\n            Set<Integer>[] vertexEdgeColors = collectVertexEdgeColors();\n\n            int edgeColorShift = vertexEdgeColors.length;\n            int size = vertexEdgeColors.length + maxEdgeColor + 1;\n\n            GraphBuilder graphBuilder = GraphBuilder.createInstance(size);\n            for (int v = 0; v < vertexEdgeColors.length; ++v) {\n                for (int edgeColor : vertexEdgeColors[v]) {\n                    graphBuilder.addEdge(v, edgeColor + edgeColorShift);\n                }\n            }\n\n            this.componentsGraph = graphBuilder.build();\n        }\n\n        int[][] toGraph() {\n            return componentsGraph;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class DSU {\n\n        int[] sizes;\n\n        int[] ranks;\n        int[] parents;\n\n        static DSU createInstance(int size) {\n            int[] sizes = new int[size];\n            Arrays.fill(sizes, 1);\n\n            return new DSU(sizes);\n        }\n\n        DSU(int[] sizes) {\n            this.sizes = sizes;\n\n            int size = sizes.length;\n\n            this.ranks = new int[size];\n            Arrays.fill(ranks, 1);\n\n            this.parents = castInt(order(size));\n        }\n\n        int get(int v) {\n            if (v == parents[v]) return v;\n            return parents[v] = get(parents[v]);\n        }\n\n        boolean union(int a, int b) {\n            a = get(a);\n            b = get(b);\n\n            if (a == b) return false;\n\n            if (ranks[a] < ranks[b]) {\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n\n            parents[b] = a;\n            sizes[a] += sizes[b];\n\n            if (ranks[a] == ranks[b]) ++ranks[a];\n\n            return true;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\nfrom math import pow\n# ------------------------------\n\n\ndef main():\n    for _ in range(N()):\n        a, b = RL()\n        mt = a*b\n        res = round(pow(mt, 1/3))\n\n        if res**3==mt and a%res==0 and b%res==0:\n            print('Yes')\n        else:\n            print('No')\n\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid boost() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nlong long cubic_root(long long x) {\n  long long l = 0, r = 2000005;\n  while (l != r) {\n    long long m = (l + r + 1) / 2;\n    if (m * m * m > x)\n      r = m - 1;\n    else\n      l = m;\n  }\n  return l;\n}\nint main(void) {\n  boost();\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long a, b, flag = 0;\n    cin >> a >> b;\n    long long x = a * b;\n    long long n = cubic_root(x);\n    long long t1 = n * n * n;\n    if (t1 != x) {\n      flag = 1;\n    }\n    if (flag)\n      cout << \"NO\"\n           << \"\\n\";\n    else {\n      if (a % n == 0 && b % n == 0) {\n        cout << \"YES\"\n             << \"\\n\";\n      } else\n        cout << \"NO\"\n             << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a * b / gcd(a, b); }\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int64_t random_long(long long l = LLONG_MIN, long long r = LLONG_MAX) {\n  uniform_int_distribution<int64_t> generator(l, r);\n  return generator(rng);\n}\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long inf = 1e18;\nconst int32_t M = 1e9 + 7;\nconst int32_t MM = 998244353;\nbool isPowerOfTwo(long long x) { return x && (!(x & (x - 1))); }\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nconst int N = 2e6 + 1;\nvoid solve() {\n  long long a, b;\n  cin >> a >> b;\n  long long target = a * b;\n  long long l = 0;\n  long long r = 1e6, mid, d;\n  bool k = false;\n  while (l <= r) {\n    mid = l + (r - l) / 2;\n    d = mid * mid * mid;\n    if (d == target) {\n      k = true;\n      break;\n    }\n    if (d < target) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  if (k == true && a % mid == 0 && b % mid == 0) {\n    cout << \"Yes\"\n         << \"\\n\";\n  } else {\n    cout << \"No\"\n         << \"\\n\";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  if (a.second == b.second) return a.first < b.first;\n  return a.second < b.second;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long m, a, ans, c, g, d;\n  cin >> m;\n  while (m--) {\n    cin >> a >> c;\n    ans = 0;\n    for (int b = 1e6; b >= 1; b /= 2) {\n      while ((ans + b) * (ans + b) * (ans + b) <= c * a) ans += b;\n    }\n    if (ans * ans * ans == c * a) {\n      if (c % ans == 0 && a % ans == 0)\n        cout << \"yes\";\n      else\n        cout << \"no\";\n    } else\n      cout << \"no\";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class codeforces{\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\t\tpublic StringTokenizer tokenizer;\n \n\t\t\tpublic InputReader() {\n\t\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\ttokenizer = null;\n\t\t\t}\n \n\t\t\tpublic String next() {\n\t\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn tokenizer.nextToken();\n\t\t\t}\n \n\t\t\tpublic int nextInt() {\n\t\t\t\treturn Integer.parseInt(next());\n\t\t\t}\n \n\t\t\tpublic long nextLong() {\n\t\t\t\treturn Long.parseLong(next());\n\t\t\t}\n \n\t\t\tpublic double nextDouble() {\n\t\t\t\treturn Double.parseDouble(next());\n\t\t\t}\n \n\t\t\tpublic String nextLine() {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n \n\t\t\tpublic String nextParagraph() {\n\t\t\t\tString line = null;\n\t\t\t\tString ans = \"\";\n\t\t\t\ttry {\n\t\t\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\t\t\tans += line;\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n \n\tstatic void printArray(int ar[]){\n\t\tfor(int x:ar)\n\t\t\tSystem.out.print(x+\" \");\n\t}\n\tstatic boolean checkCondition(int a,int b){\n\t\tint max = Math.max(a,b);\n\t\tint c=a|b;\n\t\tif(c <= max)\n\t\t\treturn true;\n\t\telse return false;\n\t}\n\tpublic static long gcd(long a,long b){\n\t\tif(b==0)\n\t\t\treturn a;\n\t\treturn gcd(b,a%b);\n\t}\n\tpublic static void main(String args[]){\n\t\tInputReader sc=new InputReader();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tint t=sc.nextInt();\n\t \tfor(int z=1;z<=t;z++){\n\t \t\tlong a=sc.nextLong();\n\t \t\tlong b=sc.nextLong();\n\t \t\tlong val = a*b;\n\t \t\tlong cbrt = (long)Math.floor(Math.pow(val,1.0/3));\n\t \t\twhile(cbrt*cbrt*cbrt < val)cbrt++;\n\t \t\twhile(cbrt*cbrt*cbrt > val)cbrt--;\n\t \t\tif(cbrt*cbrt*cbrt == val){\n\t \t\t\tlong g = gcd(a,b);\n\t \t\t\tif(g%(cbrt) == 0){\n\t \t\t\t\tpw.println(\"Yes\");\n\t \t\t\t\tcontinue;\n\t \t\t\t}\n\t \t\t}\n\t \t\tpw.println(\"No\");\n \t\t}\n\t\tpw.close();\n\t}\n} "
        },
        {
            "language": 3,
            "solution": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\navl=AvlTree()\n#-----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default='z', func=lambda a, b: min(a ,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left)/ 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid]<=key):\n            count = mid+1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n\ndef countGreater( arr,n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    #c=a*b\n    l=int((a*b)**(1/3)+0.5)\n    if l**3==a*b and a%l==0 and b%l==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 16;\nint lpf[N];\nvoid init() {\n  memset(lpf, -1, sizeof(lpf));\n  for (int n = 2; n < N; n++) {\n    if (lpf[n] == -1) {\n      lpf[n] = n;\n      if (n < N / n) {\n        for (int m = n * n; m < N; m += n) {\n          if (lpf[m] == -1) lpf[m] = n;\n        }\n      }\n    }\n  }\n}\ninline int cbrt(long long n) {\n  int lo = 1, hi = 1000000;\n  while (lo <= hi) {\n    int mi = (lo + hi) / 2;\n    long long tmp = mi * 1LL * mi * mi;\n    if (tmp < n)\n      lo = mi + 1;\n    else if (tmp > n)\n      hi = mi - 1;\n    else\n      return mi;\n  }\n  return -1;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout << setprecision(32);\n  init();\n  int n;\n  cin >> n;\n  while (n--) {\n    long long a, b;\n    cin >> a >> b;\n    int x = cbrt(a * b);\n    if (x == -1) {\n      cout << \"No\" << '\\n';\n    } else {\n      bool flg = true;\n      while (x > 1) {\n        int p = lpf[x];\n        while (x % p == 0) {\n          x /= p;\n        }\n        int cnt1 = 0;\n        int cnt2 = 0;\n        while (a % p == 0) {\n          a /= p;\n          cnt1++;\n        }\n        while (b % p == 0) {\n          b /= p;\n          cnt2++;\n        }\n        int x = (cnt1 + cnt2) / 3;\n        if (x > cnt1 || x > cnt2) {\n          flg = false;\n          break;\n        }\n      }\n      if (flg)\n        cout << \"Yes\" << '\\n';\n      else\n        cout << \"No\" << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution\n{\n      \n       public static void main(String []args) throws IOException\n       {\n        BufferedReader br = new BufferedReader( \n                              new InputStreamReader(System.in)); \n  \n        StringTokenizer st = new StringTokenizer(br.readLine()); \n       int t = Integer.parseInt(st.nextToken());\n       StringBuffer str = new StringBuffer(\"\");\n       while(t-- > 0)\n       {\n              st = new StringTokenizer(br.readLine());\n              long a = Long.parseLong(st.nextToken());\n              long b = Long.parseLong(st.nextToken());\n             \n              long x = a*b;\n              long xx = (long)Math.cbrt(x);\n              if(xx*xx*xx != x)\n              xx = -1;\n              if(xx != -1 && a%xx == 0 && b%xx == 0)\n              str.append(\"YES\");\n              \n              else\n              str.append(\"NO\");\n              \n              str.append(System.lineSeparator());\n       }\n       System.out.println(str);\n       }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n//        long start = System.currentTimeMillis();\n//        dp = new int[2 * MAXGAME][2 * MAXGAME];\n//        dp[0][0] = 1;\n//        for (int i = 0; i < MAXGAME; ++i) {\n//            for (int x = 2 * MAXGAME - 1; x >= 0; --x)\n//                for (int y = 2 * MAXGAME - 1; y >= 0; --y)\n//                    if (dp[x][y] == 1) {\n//                        if (x + 1 < 2 * MAXGAME && y + 2 < 2 * MAXGAME) dp[x + 1][y + 2] = 1;\n//                        if (x + 2 < 2 * MAXGAME && y + 1 < 2 * MAXGAME) dp[x + 2][y + 1] = 1;\n//                    }\n//        }\n//\n//        int maxprime = (int) Math.sqrt(1e9) + 2;\n//        int nprime = 0;\n//        int[] prime = new int[3500];\n//        for (int i = 2; i < maxprime; ++i)\n//            if (IntMath.isPrime(i)) {\n//                prime[nprime++] = i;\n//            }\n//        int q = in.nextInt();\n//        int a, b;\n//        int c1, c2;\n//\n//        for (int i = 0; i < q; ++i) {\n//            a = in.nextInt();\n//            b = in.nextInt();\n//            boolean ok = true;\n//            //BigInteger.probablePrime()\n//            if (IntMath.isPrime(a) && IntMath.isPrime(b)) {\n//                ok = false;\n//            } else\n//                for (int j = 0; j < nprime; ++j) {\n//                    c1 = 0;\n//                    c2 = 0;\n//                    while (a % prime[j] == 0) {\n//                        c1++;\n//                        a /= prime[j];\n//                    }\n//                    while (b % prime[j] == 0) {\n//                        c2++;\n//                        b /= prime[j];\n//                    }\n//                    if (dp[c1][c2] == 0) {\n//                        ok = false;\n//                        break;\n//                    }\n//                    if (a == 1 || b == 1) break;\n//                }\n//            out.println(ok && ((a == 1) && (b == 1)) ? \"Yes\" : \"No\");\n//        }\n//        //System.err.println(nprime);\n//        System.err.println(\"time : \" + (System.currentTimeMillis() -start) + \" miliseconds\");\n\n            //HashSet<Long> _3 = new HashSet<>();\n            long[] t = new long[1000000];\n            for (int i = 1; i <= 1000000; ++i) t[i - 1] = (1l * i * i * i);\n            int q = in.nextInt();\n            long a, b;\n            for (int i = 0; i < q; ++i) {\n                a = in.nextInt();\n                b = in.nextInt();\n\n                int vt = Arrays.binarySearch(t, a * b);\n                if (a == 1 && b == 1) out.println(\"Yes\");\n                else {\n                    if (vt < 0 || (a % (vt + 1) != 0) || b % (vt + 1) != 0) {\n                        out.println(\"No\");\n                    } else {\n                        out.println(\"Yes\");\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long a, i, x, y;\n  scanf(\"%I64d \", &a);\n  while (a--) {\n    scanf(\"%I64d %I64d\", &x, &y);\n    i = ceil(cbrt(x * y));\n    if (x % i == 0 && y % i == 0 && (x * y) % i == 0) {\n      printf(\"Yes\\n\");\n    } else\n      printf(\"No\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t-- > 0) {\n    long long a, b;\n    cin >> a >> b;\n    string res = \"No\\n\";\n    long long raiz = cbrt(a * b);\n    for (long long i = max(1LL, raiz - 2); i < raiz + 2; ++i) {\n      if (a * b == i * i * i && a % i == 0 && b % i == 0) {\n        res = \"Yes\\n\";\n        break;\n      }\n    }\n    cout << res;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\n\tFastReader in = new FastReader();\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t\twork();\n\t\tout.flush();\n\t}\n\tlong mod=998244353;\n\tlong gcd(long a,long b) {\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\tvoid work() {\n\t\tint n=in.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong a=in.nextLong();\n\t\t\tlong b=in.nextLong();\n\t\t\tlong c=find(a*b);\n\t\t\tif(c==-1||a%c!=0||b%c!=0) {\n\t\t\t\tout.println(\"NO\");\n\t\t\t}else {\n\t\t\t\tout.println(\"YES\");\n\t\t\t}\n\t\t}\n\t}\n\tprivate long find(long num) {\n\t\tlong l=1,r=1000001;\n\t\twhile(l<r) {\n\t\t\tlong m=(l+r)/2;\n\t\t\tif(m*m*m<num) {\n\t\t\t\tl=m+1;\n\t\t\t}else if(m*m*m>num){\n\t\t\t\tr=m;\n\t\t\t}else {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\t\n\n\n\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic String next() \n\t{\n\t\tif(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long pow3(long long a, long long b, long long m = 1000000007) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % m;\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return res;\n}\nvoid solve() {\n  long long a, b;\n  scanf(\"%lld %lld\", &a, &b);\n  long long s = 0, e = 1e6 + 1;\n  while (s < e) {\n    long long m = (s + e) / 2;\n    if (m * m * m < a * b)\n      s = m + 1;\n    else\n      e = m;\n  }\n  if (s * s * s == a * b && a % s == 0 && b % s == 0)\n    printf(\"Yes\\n\");\n  else\n    printf(\"No\\n\");\n}\nint main() {\n  int q = 1;\n  scanf(\"%d\", &q);\n  while (q--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nmap<T, long long int> factorize(T x) {\n  map<T, long long int> res;\n  for (long long int i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n      res[i]++;\n    }\n  }\n  if (x != 1) res[x]++;\n  return res;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int qq;\n  cin >> qq;\n  while (qq--) {\n    long long int a, b;\n    cin >> a >> b;\n    if (a * a % b || b * b % a) {\n      printf(\"No\\n\");\n      continue;\n    }\n    long long int left = 0, right = 1e6 + 1;\n    while (right - left > 1) {\n      long long int mid = (left + right) / 2;\n      if (mid * mid * mid <= a * b) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    if (left * left * left == a * b) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int a, long long int b, long long int m) {\n  long long int ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = ((ans % m) * (a % m)) % m;\n    }\n    a = ((a % m) * (a % m)) % m;\n    b = b >> 1;\n  }\n  return ans;\n}\nlong long int powe(long long int a, long long int b) {\n  long long int ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans = a * ans;\n    }\n    a = a * a;\n    b = b >> 1;\n  }\n  return ans;\n}\nlong long int ncr(long long int n, long long int r) {\n  r = ((r < n - r) ? (r) : (n - r));\n  long long int ans = 1;\n  for (int i = 0; i < r; i++) {\n    ans *= (n - i);\n    ans /= (i + 1);\n  }\n  return ans;\n}\nlong long int spf[1000005];\nvoid sieve() {\n  long long int n = 1000002;\n  for (int i = 2; i <= n; i += 2) {\n    spf[i] = 2;\n  }\n  for (int i = 3; i <= n; i += 2) {\n    spf[i] = i;\n  }\n  for (int i = 3; i * i <= n; i += 2) {\n    if (spf[i] == i) {\n      for (int j = i * i; j <= n; j += i) {\n        if (spf[j] == j) {\n          spf[j] = i;\n        }\n      }\n    }\n  }\n}\nset<long long int> calc(long long int n) {\n  long long int newn = n;\n  set<long long int> facors;\n  while (n % 2 == 0) {\n    facors.insert(2);\n    n = n / 2;\n  }\n  for (int i = 3; i * i <= n; i += 2) {\n    while (n % i == 0) {\n      facors.insert(i);\n      n = n / i;\n    }\n  }\n  if (n > 1) {\n    facors.insert(n);\n  }\n  set<long long int> x1;\n  for (auto i : facors) {\n    if (newn / i >= 2) x1.insert(newn - i + 1);\n  }\n  return x1;\n}\nvoid solve() {\n  long long int a, b;\n  cin >> a >> b;\n  long long int c = cbrt(a * b);\n  if (c * c * c < a * b) {\n    c++;\n  }\n  if (c * c * c == a * b) {\n    if (a % c != 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n    if (b % c != 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n  } else {\n    cout << \"NO\\n\";\n    return;\n  }\n  cout << \"YES\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int t = 1;\n  cin >> t;\n  while (t > 0) {\n    solve();\n    t--;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.*;\n\n\n\n\npublic class C \n{\n    \n    public static void main(String[] args) throws IOException \n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = Integer.parseInt(br.readLine());\n        while( n-->0 )\n        {\n            String []str = br.readLine().split(\" \");\n            int a = Integer.parseInt(str[0]);\n            int b = Integer.parseInt(str[1]);\n            long c = 1L*a*b ;\n            double res = Math.cbrt(c);\n            if( a%res == 0 && b%res == 0 )\n                out.println(\"YES\");\n            else\n                out.println(\"NO\");\n        }\n        br.close();\n        out.close();  \n    }\n\n\t\n\t\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long int a, b;\n  cin >> a >> b;\n  long long int prod = a * b;\n  long long int l = 1;\n  long long int r = 1e6;\n  long long int mid;\n  while (l <= r) {\n    mid = (l + r) / 2;\n    if (mid * mid * mid == prod) {\n      break;\n    }\n    if (mid * mid * mid < prod) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  if (mid * mid * mid == prod && a % mid == 0 && b % mid == 0) {\n    cout << \"YES\"\n         << \"\\n\";\n  } else {\n    cout << \"NO\"\n         << \"\\n\";\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  ll a, b, x, y, m;\n  while (n--) {\n    cin >> a >> b;\n    x = 0, y = 1000000;\n    while (x <= y) {\n      m = x + (y - x) / 2;\n      if (m * m * m == a * b) {\n        x = m;\n        break;\n      }\n      if (m * m * m > a * b)\n        y = m - 1;\n      else\n        x = m + 1;\n    }\n    if (a % x or b % x)\n      printf(\"No\\n\");\n    else\n      printf(\"Yes\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class TheMeaninglessGame {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    static class Solver {\n\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            for (int i = 0; i < n; i++) {\n                long a = inp.nextLong();\n                long b = inp.nextLong();\n                long c = a * b;\n                long x = (long) Math.pow(c, 1/3.0f);\n                if (x * x * x == c) {\n                    if (a % x == 0 && b % x == 0) {\n                        out.println(\"Yes\");\n                        continue;\n                    }\n                } else if ((x + 1) * (x + 1) * (x + 1) == c) {\n                    if (a % (x + 1) == 0 && b % (x + 1) == 0) {\n                        out.println(\"Yes\");\n                        continue;\n                    }\n                }\n                out.println(\"No\");\n            }\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int T;\n  cin >> T;\n  int cnt = 1;\n  while (T--) {\n    long long A, B, C;\n    scanf(\"%lld %lld\", &A, &B);\n    C = A * B;\n    long long sm = (long long)(pow(C, 1 / 3.0) + 0.5);\n    if (sm * sm * sm != C || sm > min(A, B) || A % sm || B % sm)\n      printf(\"No\\n\");\n    else\n      printf(\"Yes\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, j, k, x, y, w, path_w, m, a[100500];\nint gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); }\nint main() {\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &x, &y);\n    int g = gcd(x, y);\n    int dlfjl = x / g, y1 = y / g;\n    if (y % (1LL * y1 * y1 * dlfjl) != 0 ||\n        x % (1LL * dlfjl * dlfjl * y1) != 0) {\n      printf(\"No\\n\");\n      continue;\n    }\n    y /= (1LL * y1 * y1 * dlfjl);\n    x /= (1LL * dlfjl * dlfjl * y1);\n    if (x != y) {\n      printf(\"No\\n\");\n      continue;\n    }\n    int tmp = exp(1. / 3 * log(x));\n    tmp--;\n    while (1LL * tmp * tmp * tmp < x) tmp++;\n    if (tmp * tmp * tmp == x)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * @author Finn Lidbetter\n */\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\n\npublic class C2 {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringBuilder sb = new StringBuilder();\n\n    int n = Integer.parseInt(br.readLine());\n    for (int i=0; i<n; i++) {\n      String[] s = br.readLine().split(\" \");\n      long a = Long.parseLong(s[0]);\n      long b = Long.parseLong(s[1]);\n\n      if (a==1 && b==1) {\n        sb.append(\"Yes\\n\");\n      } else if (a==1 || b==1) {\n        sb.append(\"No\\n\");\n      } else {\n        long ab = a*b;\n        double cbrt = Math.pow(ab, (1.0/3.0));\n        long xy = (long) cbrt;\n        if ((xy+1)*(xy+1)*(xy+1)==ab) {\n          xy++;\n        }\n        if (xy*xy*xy!=ab) {\n          sb.append(\"No\\n\");\n        } else {\n          // a=x^2y\n          // b=xy^2\n          long x3 = (a*a)/b;\n          if ((a*a)%b!=0) {\n            sb.append(\"No\\n\");\n          } else {\n            cbrt = Math.pow(x3, (1.0/3.0));\n            long x = (long) cbrt;\n            if ((x+1)*(x+1)*(x+1)==x3) {\n              x++;\n            }\n            if (x*x*x!=x3) {\n              sb.append(\"No\\n\");\n            } else {\n              long y= a/(x*x);\n              if (x*x*y==a && x*y*y==b) {\n                sb.append(\"Yes\\n\");\n              } else {\n                sb.append(\"No\\n\");\n              }\n            }\n          }\n        }\n      }\n    }\n    System.out.print(sb);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package TIM;\n\n\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.*;\n\n\npublic class Main {\n    static Scanner input = new Scanner(System.in);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter output = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n\n        int n = Integer.parseInt(br.readLine());\n        while (n-- > 0) {\n            String[] s = br.readLine().split(\" \");\n            int a = Integer.parseInt(s[0]);\n            int b = Integer.parseInt(s[1]);\n            long x = 1L * a * b;\n            double y = Math.cbrt(x);\n            if (a % y == 0 && b % y == 0)\n                output.println(\"Yes\");\n            else\n                output.println(\"No\");\n        }\n        br.close();\n        output.close();\n    }\n}\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    long long x, y, le = 1, ri = 1e6, mi, o;\n    scanf(\"%lld%lld\", &x, &y);\n    while (le + 1 < ri) {\n      mi = (le + ri) >> 1;\n      if (mi * mi * mi > x * y)\n        ri = mi;\n      else\n        le = mi;\n    }\n    if (le * le * le == x * y)\n      o = le;\n    else\n      o = ri;\n    if (o * o * o != x * y) {\n      puts(\"No\");\n      continue;\n    }\n    if (x % o == 0 && y % o == 0)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package TIM;\n\n\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.*;\n\n\npublic class Main {\n    static Scanner input = new Scanner(System.in);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n\n        int n = Integer.parseInt(br.readLine());\n        while (n-- > 0) {\n            String[] s = br.readLine().split(\" \");\n            int a = Integer.parseInt(s[0]);\n            int b = Integer.parseInt(s[1]);\n            long x = 1L * a * b;\n            double y = Math.cbrt(x);\n            if (a % y == 0 && b % y == 0)\n                pw.println(\"Yes\");\n            else\n                pw.println(\"No\");\n        }\n        //br.close();\n        pw.close();\n    }\n}\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kucingterbang\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A833 solver = new A833();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A833 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                long a = in.nextInt();\n                long b = in.nextInt();\n                double cbrt = Math.cbrt(a * b);\n                if (cbrt % 1 == 0 && a % cbrt == 0 && b % cbrt == 0) out.println(\"Yes\");\n                else out.println(\"No\");\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bin(long long a, long long b) {\n  long long t = a * b;\n  long long l = 1, h = 1E6, m;\n  while (l <= h) {\n    m = (l + h) / 2;\n    if (m * m * m == t) return m;\n    if (m * m * m > t) {\n      h = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  long long a, b;\n  int n, i, c = 0;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld %lld\", &a, &b);\n    c = bin(a, b);\n    if (c && a % c == 0 && b % c == 0)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fileio() {}\nvector<vector<long long int>> g;\nlong long int cube_root(long long int x) {\n  long long int lo = 0, hi = 1e6 + 10;\n  while (lo <= hi) {\n    long long int m = (lo + hi) / 2;\n    long long int val = m * m * m;\n    if (val == x) return m;\n    if (val > x) {\n      hi = m - 1;\n    } else {\n      lo = m + 1;\n    }\n  }\n  return -1;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  fileio();\n  long long int t;\n  cin >> t;\n  while (t-- > 0) {\n    long long int a, b;\n    cin >> a >> b;\n    long long int x = a * b;\n    long long int c = cube_root(x);\n    if (c == -1) {\n      cout << \"NO\";\n      cout << '\\n';\n      continue;\n    }\n    if (a % c != 0 or b % c != 0) {\n      cout << \"NO\";\n      cout << '\\n';\n      continue;\n    }\n    cout << \"YES\";\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a, b, c, x;\nint n;\nlong long s3(long long x) {\n  long long l = 1, r = 1e6, res = -1;\n  while (l <= r) {\n    long long mid = (l + r) >> 1, val = mid * mid * mid;\n    if (val == x) return mid;\n    if (val < x) l = mid + 1;\n    if (val > x) r = mid - 1;\n  }\n  return -1;\n}\nint main() {\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%I64d%I64d\", &a, &b);\n    c = a * b;\n    x = s3(c);\n    if (x != -1 && a % x == 0 && b % x == 0)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Hello {\n    public static void main(String args[]) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        long n = in.nextLong();\n\n        long a, b;\n        for (int i = 0; i < n; i++) {\n            a = in.nextLong();\n            b = in.nextLong();\n            long p = Math.round(Math.pow(a * b, (1 / 3.0)));\n            if (p * p * p != a * b || a % p != 0 || b % p != 0) {\n                out.println(\"NO\");\n            } else {\n                out.println(\"YES\");\n            }\n        }\n        out.close();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "import io\nimport os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nt = int(input())\n\nfor tc in range(t):\n\n    a, b = map(int, input().split())\n\n    cbrt = round(pow(a*b, 1/3))\n\n    if pow(cbrt, 3) == a*b:\n        if a % cbrt == b % cbrt == 0:\n            print(\"Yes\")\n            continue\n\n    print(\"No\")"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long rt3(long long x) {\n  long long l = 0, r = 1e6;\n  for (int i = 0; i < 30; i++) {\n    long long h = (l + r) / 2;\n    if (h * h * h < x) {\n      l = h;\n    } else {\n      r = h;\n    }\n  }\n  return r;\n}\nlong long min(long long a, long long b) { return a < b ? a : b; }\nbool possible(long long a, long long b) {\n  long long t = rt3(a * b);\n  if (t * t * t != a * b) {\n    return false;\n  } else if (a % t != 0) {\n    return false;\n  } else if (b % t != 0) {\n    return false;\n  }\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    cin >> a >> b;\n    if (possible(a, b)) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long GCD(long long x, long long y) {\n  while (y != 0) {\n    long long t = x % y;\n    x = y;\n    y = t;\n  }\n  return x;\n}\nlong long n, a, b;\nlong long cs;\nbool calc() {\n  scanf(\"%lld %lld\", &a, &b);\n  long long g = GCD(a, b);\n  long long p = a / g;\n  long long q = b / g;\n  long long pq = p * q;\n  bool ret = (g % pq == 0);\n  if (ret) {\n    long long r = g / pq;\n    long long i = 1;\n    while (i * i * i < r) {\n      i++;\n    }\n    if (i * i * i == r) return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%lld\", &n);\n  while (cs < n) {\n    cs++;\n    bool ans = calc();\n    if (ans)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9 + 9;\nconst long long N = 500500;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  vector<long long> cube;\n  for (long long i = 1; i <= 1e6; i++) {\n    cube.push_back(i * i * i);\n  }\n  long long T;\n  cin >> T;\n  while (T--) {\n    long long a, b;\n    cin >> a >> b;\n    bool ok = false;\n    auto it = lower_bound((cube).begin(), (cube).end(), a * b);\n    if (it != cube.end()) {\n      long long cr = (it - cube.begin() + 1);\n      if (a % cr == 0 && b % cr == 0) {\n        ok = true;\n      }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXR = 1000005;\nlong long cubic_root(long long x) {\n  long long l = 0, r = MAXR;\n  while (l != r) {\n    long long m = (l + r + 1) / 2;\n    if (m * m * m > x)\n      r = m - 1;\n    else\n      l = m;\n  }\n  return l;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    long long x = cubic_root(a * b);\n    if (x * x * x != a * b)\n      puts(\"No\");\n    else if (a % x == 0 && b % x == 0)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 5;\nint t;\nlong long a, b;\nlong long cubic_root(long long x) {\n  long long lo = 1, hi = 1e6, mid;\n  while (lo < hi) {\n    mid = (lo + hi) / 2;\n    if (mid * mid * mid < x)\n      lo = mid + 1;\n    else\n      hi = mid;\n  }\n  return lo;\n}\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%lld %lld\", &a, &b);\n    long long crt = cubic_root(a * b);\n    if (crt * crt * crt == a * b && a % crt == 0 && b % crt == 0)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Abc {\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n        int n=sc.nextInt();\n        StringBuilder sb=new StringBuilder();\n        while (n-->0) {\n            long a = sc.nextInt(), b = sc.nextInt();\n            if (a % Math.cbrt(a * b) == 0 && b % Math.cbrt(a * b) == 0) {\n                sb.append(\"YES\\n\");\n            } else sb.append(\"NO\\n\");\n        }\n        System.out.print(sb);\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    boolean isCube(long val) {\n        long cb = (long)cbrt(val);\n\n        return (cb * cb * cb == val);\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int t = sc.nextInt();\n\n        for(int x = 0; x < t; ++x) {\n            long a = sc.nextLong();\n            long b = sc.nextLong();\n            long val = a * b;\n\n            if(isCube(val) && a % (long)cbrt(val) == 0 && b % (long)cbrt(val) == 0)\n                w.println(\"Yes\");\n            else\n                w.println(\"No\");\n        }\n\n        w.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007LL;\nlong long base = 37;\nlong long large = 1000000000000000000LL;\nbool iscube(int x) {\n  int low = 1;\n  int high = 1000;\n  int mid;\n  int ans = 1;\n  while (low <= high) {\n    mid = (low + high) / 2;\n    if (mid * mid * mid <= x) {\n      ans = mid;\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return ans * ans * ans == x;\n}\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x % y);\n}\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    int d = gcd(a, b);\n    int aa = a / d;\n    int bb = b / d;\n    if (d % (aa * bb) == 0 && iscube(d / aa / bb)) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint test = nextInt();\n\t\twhile (test-->0) {\n\t\t\tlong a = nextLong();\n\t\t\tlong b = nextLong();\n\t\t\tlong g = gcd(a, b);\n\t\t\ta /= g;\n\t\t\tb /= g;\n\t\t\tif (g % (a*b)==0) {\n\t\t\t\tg /= (a*b);\n\t\t\t\tlong pow_3 = power3(g);\n\t\t\t\tif (pow_3*pow_3*pow_3==g)\n\t\t\t\t\tpw.println(\"Yes\");\n\t\t\t\telse\n\t\t\t\t\tpw.println(\"No\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tpw.println(\"No\");\n\t\t}\n\t\tpw.close();\n\t}\n\tprivate static long power3(long x) {\n\t\tlong left = 1, right = 10000;\n\t\twhile (right-left > 1) {\n\t\t\tlong mid = (left+right) / 2;\n\t\t\tif (mid*mid*mid <= x)\n\t\t\t\tleft = mid;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\treturn left;\n\t}\n\tprivate static long gcd(long a, long b) {\n\t\tif (b==0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool vis[100010];\nint pr[100010], e;\nvoid Shai() {\n  vis[1] = true;\n  for (long long i = 2; i <= 1000ll; i++) {\n    if (!vis[i]) {\n      pr[++e] = i;\n      for (long long j = i * i; j <= 1000ll; j += i) {\n        vis[j] = true;\n      }\n    }\n  }\n}\nint n, cnta[100010];\nint main() {\n  Shai();\n  int x, y;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    int X = x;\n    for (int j = 1; j <= e; ++j) {\n      if (X % pr[j] == 0) {\n        while (X % pr[j] == 0) {\n          X /= pr[j];\n          ++cnta[j];\n        }\n      }\n    }\n    bool lose = 0;\n    for (int j = 1; j <= e; ++j) {\n      int cntb = 0;\n      if (y % pr[j] == 0) {\n        while (y % pr[j] == 0) {\n          y /= pr[j];\n          ++cntb;\n        }\n      }\n      if ((cnta[j] + cntb) % 3 != 0) {\n        lose = 1;\n        break;\n      } else if (min(cnta[j], cntb) * 2 < max(cnta[j], cntb)) {\n        lose = 1;\n        break;\n      }\n    }\n    if (!(X == 1 && y == 1) && !((long long)min(X, y) * (long long)min(X, y) ==\n                                 (long long)max(X, y))) {\n      lose = 1;\n    }\n    for (int j = 1; j <= e; ++j) {\n      cnta[j] = 0;\n    }\n    if (!lose)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long x, y, m;\ndouble ret;\nint main() {\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%lld %lld\", &x, &y);\n    ret = pow((double)(x * y), 1.0 / 3.0);\n    m = round(ret);\n    if (m * m * m != (x * y) || x % m || y % m)\n      puts(\"No\");\n    else\n      puts(\"Yes\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    q = a * b\n    t = round(q ** (1 / 3))\n    if t * t * t == q and a % t == b % t == 0:\n        print('YES')\n    else:\n\n        print('NO')\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b, k, u, v;\nmap<int, bool> OK;\nint GCD(int a, int b) { return b == 0 ? a : GCD(b, a % b); }\nvoid solve() {\n  scanf(\"%d%d\", &a, &b);\n  k = GCD(a, b);\n  u = a / k;\n  v = b / k;\n  if (k % u != 0) {\n    puts(\"No\");\n    return;\n  } else\n    k /= u;\n  if (k % v != 0) {\n    puts(\"No\");\n    return;\n  } else\n    k /= v;\n  if (!OK[k]) {\n    puts(\"No\");\n    return;\n  }\n  puts(\"Yes\");\n}\nvoid init() {\n  for (int i = 1; i <= 1000; i++) OK[i * i * i] = true;\n}\nint main() {\n  init();\n  int nT;\n  scanf(\"%d\", &nT);\n  while (nT--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskA {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint numTests = in.nextInt();\n\t\t\tfor (int test = 0; test < numTests; test++) {\n\t\t\t\tlong a = in.nextInt();\n\t\t\t\tlong b = in.nextInt();\n\t\t\t\tboolean ans = true;\n\t\t\t\tif ((a * a) % b != 0 || !isCube(a * a / b)) {\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t\tif ((b * b) % a != 0 || !isCube(b * b / a)) {\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t\tout.println(ans ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isCube(long n) {\n\t\t\tlong x = (long) Math.pow(n, 1.0 / 3.0) - 2;\n\t\t\tx = Math.max(x, 0);\n\t\t\twhile (x * x * x < n) {\n\t\t\t\t++x;\n\t\t\t}\n\t\t\treturn x * x * x == n;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0);\n  int number;\n  std::cin >> number;\n  while (number--) {\n    int a, b;\n    std::cin >> a >> b;\n    int const c = (int)std::round(std::cbrt(a * (int64_t)b));\n    std::cout << ((int64_t)c * c * c == (int64_t)a * b and a % c == 0 and\n                          b % c == 0\n                      ? \"Yes\\n\"\n                      : \"No\\n\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        public InputReader(InputStream st) {\n            this.stream = st;\n        } \n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        } \n        public String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        } \n    }\n    public static class Key {\n\n        private final int x;\n        private final int y;\n\n        public Key(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Key)) return false;\n            Key key = (Key) o;\n            return x == key.x && y == key.y;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n\n    }\n    static class Pair{\n        long x,y,z;\n        public Pair(long x,long y,long z){\n            this.x=x;\n            this.y=y;\n            this.z=z;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Pair)) return false;\n            Pair key = (Pair) o;\n            return x == key.x && y == key.y && z==key.z;\n        }\n    }\n    static class Pair1{\n        long x,y;\n        public Pair1(long x,long y){\n            this.x=x;\n            this.y=y;\n            \n        }\n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static long mod=998244353L,mod1=1000000007;\n    \n    static ArrayList<Long> pri=new ArrayList<>();\n    public static void main(String [] args){\n        InputReader sc=new InputReader(System.in);\n        int t=sc.ni();\n        \n        while(t-->0){\n            long a=sc.nl(),b=sc.nl();\n            long m=a*b;\n            double c=Math.cbrt(a*b);\n            long x=(long)c;\n            \n            \n            if(x!=c)w.println(\"NO\");\n            else if(a%x!=0||b%x!=0)w.println(\"NO\");\n            else w.println(\"YES\");\n        }\n        w.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ff(long long a) {\n  long long le = 1, ri = 1000010;\n  while (le <= ri) {\n    long long mi = (le + ri) / 2;\n    if (mi * mi * mi > a)\n      ri = mi - 1;\n    else\n      le = mi + 1;\n  }\n  return ri;\n}\nint main() {\n  int _;\n  scanf(\"%d\", &_);\n  while (_--) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    long long xy = ff((long long)a * b);\n    long long x = a / xy;\n    long long y = b / xy;\n    if (a == x * x * y && b == x * y * y)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long pwr(long long base, long long p, long long mod = (1000000007LL)) {\n  long long ans = 1;\n  while (p) {\n    if (p & 1) ans = (ans * base) % mod;\n    base = (base * base) % mod;\n    p /= 2;\n  }\n  return ans;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nconst int N = 1000002;\nint sieve[N], prime_facs[N];\nint main() {\n  for (int i = 2; i < N; i++)\n    if (sieve[i] == 0) {\n      for (int j = i; j < N; j += i) {\n        sieve[j] = 1;\n        if (prime_facs[j] == 0) prime_facs[j] = i;\n      }\n    }\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    long long a, b;\n    scanf(\"%lld%lld\", &a, &b);\n    long long prod = a * b;\n    long long lo = 1, hi = 1000 * 1000 + 1, ans = 0;\n    ans = cbrt(prod);\n    while (ans * ans * ans < prod) ans++;\n    while (ans * ans * ans > prod) ans--;\n    if (ans * ans * ans != prod) {\n      printf(\"No\\n\");\n      continue;\n    }\n    bool bad = false;\n    while (ans != 1) {\n      int p = prime_facs[ans];\n      int c1 = 0, c2 = 0, c3 = 0;\n      while (a % p == 0) {\n        a /= p;\n        c1++;\n      }\n      while (b % p == 0) {\n        b /= p;\n        c2++;\n      }\n      while (ans % p == 0) {\n        ans /= p;\n        c3++;\n      }\n      if ((2 * c1 - c2) % 3 != 0 || (2 * c1 < c2)) bad = true;\n      swap(c1, c2);\n      if ((2 * c1 - c2) % 3 != 0 || (2 * c1 < c2)) bad = true;\n      if (bad) break;\n    }\n    if (!bad)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "  //  package com.company;\n    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.lang.reflect.Array;\n    import java.util.*;\n    public class Main {\n\n        public static void main(String[] args) throws IOException {\n         //   Scanner s = new Scanner(System.in);\n            BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n             StringBuilder sb = new StringBuilder();\n    int n=Integer.parseInt(s.readLine());\n    for(int i=0;i<n;i++){\n        String[] str=s.readLine().trim().split(\"\\\\s+\");\n        double a=Double.parseDouble(str[0]);double b=Double.parseDouble(str[1]);double x=Math.cbrt(a*b);\n        if(x==Math.floor(x)&&a%x==0&&b%x==0){\n            sb.append(\"YES\\n\");\n        }else\n            sb.append(\"NO\\n\");\n    }\n            System.out.println(sb.toString());\n        }\n         static double power(double x, long y, int p) {\n            double res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1)\n                    res = (res * x) % p;\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n        public static void fracion(double x) {\n            String a = \"\" + x;\n            String spilts[] = a.split(\"\\\\.\"); // split using decimal\n            int b = spilts[1].length(); // find the decimal length\n            int denominator = (int) Math.pow(10, b); // calculate the denominator\n            int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n            // 1.2*10 = 12\n            int gcd = gcd(numerator, denominator); // Find the greatest common\n            // divisor bw them\n            String fraction = \"\" + numerator / gcd + \"/\" + denominator / gcd;\n            // System.out.println((denominator/gcd));\n            long x1=modInverse(denominator / gcd,998244353  );\n            //  System.out.println(x1);\n            System.out.println((((numerator / gcd )%998244353 *(x1%998244353  ))%998244353  ) );\n        }static int max=Integer.MIN_VALUE;\nstatic int max1=Integer.MIN_VALUE;static int[] ans;static long[][] dp;static int[][] c;\n        public static int dfs(int papa, int i, ArrayList<Integer>[] h, int[] vis) {\n\n             vis[i] = 1;\n               if(papa!=-1){\n                   dp[i-1][0]=Math.min(dp[i-1][0],c[0][i-1]+Math.min(dp[papa-1][1],dp[papa-1][2]));\n                   dp[i-1][1]=Math.min(dp[i-1][1],c[1][i-1]+Math.min(dp[papa-1][0],dp[papa-1][2]));\n                   dp[i-1][2]=Math.min(dp[i-1][2],c[2][i-1]+Math.min(dp[papa-1][1],dp[papa-1][0]));\n\n               }else{\n                   dp[i-1][0]=c[i-1][0];\n                   dp[i-1][1]=c[i-1][1];\n                   dp[i-1][2]=c[i-1][2];\n\n               }\n             for(Integer j:h[i]){\n                      if(vis[j]==0){\n                          dfs(i,j,h,vis);\n                      }\n             }ans[i]+=1;if(ans[i]>max){\n                 max=ans[i];max1=i;\n            }\n          return ans[i];\n        }\n\n\n\n        public static void bfs(int i, HashMap<Integer, Integer>[] h, int[] vis, int len, int papa) {\n            Queue<Integer> q = new LinkedList<Integer>();\n            q.add(i);\n\n        }\n\n\n        static int i(String a) {\n            return Integer.parseInt(a);\n        }\n\n        static long l(String a) {\n            return Long.parseLong(a);\n        }\n\n        static String[] inp() throws IOException {\n            BufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n            return s.readLine().trim().split(\"\\\\s+\");\n        }\n\n\n        static int gcd(int a, int b) {\n            if (b == 0)\n                return a;\n            return gcd(b, a % b);\n        }\n        static long modInverse(int a, int m)\n        {\n\n\n            {\n                // If a and m are relatively prime, then modulo inverse\n                // is a^(m-2) mode m\n                return (power(a, m - 2, m));\n            }\n        }\n\n        // To compute x^y under modulo m\n        static long power(int x, int y, int m)\n        {\n            if (y == 0)\n                return 1;\n\n            long p = power(x, y / 2, m) % m;\n            p = (p * p) % m;\n\n            if (y % 2 == 0)\n                return p;\n            else\n                return (x * p) % m;\n        }\n\n        // Function to return gcd of a and b\n\n    }\n    class Student\n    {\n        int l,r;\n\n        public Student(int l, int r) {\n            this.l = l;\n            this.r = r;\n\n        }\n    // Constructor\n\n\n        // Used to print student details in main()\n        public String toString()\n        {\n            return this.l+\" \";\n        }\n    }\n\n    class Sortbyroll implements Comparator<Student>\n    {\n        // Used for sorting in ascending order of\n        // roll number\n        public int compare(Student a, Student b){\n            return a.l-b.l;\n        }\n    }"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long a, b;\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    long long c = a * b;\n    bool ok = false;\n    long long left = 1, right = 1000001;\n    long long ans;\n    while (left <= right) {\n      long long mid = (left + right) / 2;\n      long long now = mid * mid * mid;\n      if (now == c) {\n        ans = mid;\n        ok = 1;\n        break;\n      }\n      if (now > c) right = mid - 1;\n      if (now < c) left = mid + 1;\n    }\n    if (!ok) {\n      cout << \"No\" << '\\n';\n    } else {\n      if (a % ans == 0 && b % ans == 0) {\n        cout << \"Yes\" << '\\n';\n      } else\n        cout << \"No\" << '\\n';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = int(1e6) + 5;\nlong long cubic_root(long long x) {\n  long long l = 0, r = INF, med, answ;\n  while (l <= r) {\n    med = l + (r - l) / 2;\n    if (med * med * med >= x) {\n      answ = med;\n      r = med - 1;\n    } else {\n      l = med + 1;\n    }\n  }\n  return answ;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, a, b, x;\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    x = cubic_root(a * b);\n    if (1ll * x * x * x == 1ll * a * b && a % x == 0 && b % x == 0) {\n      cout << \"Yes\\n\";\n    } else {\n      cout << \"No\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\n/**\n * Created by Katushka on 05.02.2020.\n */\npublic class TheMeaninglessGame {\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int g = gcd(a, b);\n\n            int rest = (a / g) * (b / g);\n            if (g % rest == 0) {\n                long gg = g / rest;\n                long cbrt = Math.round(Math.cbrt(gg));\n                if (cbrt * cbrt * cbrt == gg) {\n                    out.println(\"Yes\");\n                } else {\n                    out.println(\"No\");\n                }\n            } else {\n                out.println(\"No\");\n            }\n\n            \n        }\n        \n        out.close();\n    }\n\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a, b, c[1234567], d[1234567], c1[1234][1234], e[1234567], n, j, i, l,\n    r, x, y, k, ans;\nbool used[1234567];\nlong long T;\nchar ch[1234][1234];\nlong long vis[1234][1234];\nvector<long long> v[1234567], v1;\nstring s1[1234567];\nint main() {\n  cin >> T;\n  while (T--) {\n    scanf(\"%lld%lld\", &x, &y);\n    n = x * y;\n    a = pow(n, 1.0 / 3) + 0.5;\n    if (a * a * a != n || x % a > 0 || y % a > 0) {\n      puts(\"NO\");\n    } else\n      puts(\"YES\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (ch < '0' || '9' < ch) f |= ch == '-', ch = getchar();\n  while ('0' <= ch && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\nint q[31709], tot;\nbool b[31709];\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\nint main() {\n  for (int i = 2; i <= 31700; i++)\n    if (!b[i]) {\n      q[++tot] = i;\n      for (int a = i + i; a <= 31700; a += i) b[a] = true;\n    }\n  int T = read();\n  while (T--) {\n    int a = read(), b = read(), c = gcd(a, b);\n    bool F = true;\n    if (c == 1 && a + b != 2) {\n      puts(\"No\");\n      continue;\n    }\n    if (c == a && a == b) {\n      for (int o = 1; o <= tot; o++)\n        if (q[o] > 1000)\n          break;\n        else if (a % q[o] == 0 && b % q[o] == 0) {\n          int aa = 0, bb = 0;\n          while (a % q[o] == 0) a /= q[o], aa++;\n          while (b % q[o] == 0) b /= q[o], bb++;\n          if (aa < bb) swap(aa, bb);\n          int tmp = aa - bb;\n          aa -= tmp + tmp, bb -= tmp;\n          if (aa < 0 || aa % 3 != 0) {\n            F = false;\n            break;\n          }\n        } else if ((a % q[o] == 0) != (b % q[o] == 0)) {\n          F = false;\n          break;\n        } else if ((a == 1) != (b == 1)) {\n          F = false;\n          break;\n        } else if ((a == 1) && (b == 1))\n          break;\n      if (a != 1 || b != 1) F = false;\n      puts(F ? \"Yes\" : \"No\");\n      continue;\n    }\n    for (int o = 1; o <= tot; o++)\n      if (a % q[o] == 0 && b % q[o] == 0) {\n        int aa = 0, bb = 0;\n        while (a % q[o] == 0) a /= q[o], aa++;\n        while (b % q[o] == 0) b /= q[o], bb++;\n        if (aa < bb) swap(aa, bb);\n        int tmp = aa - bb;\n        aa -= tmp + tmp, bb -= tmp;\n        if (aa < 0 || aa % 3 != 0) {\n          F = false;\n          break;\n        }\n      } else if ((a % q[o] == 0) != (b % q[o] == 0)) {\n        F = false;\n        break;\n      } else if ((a == 1) != (b == 1)) {\n        F = false;\n        break;\n      } else if ((a == 1) && (b == 1))\n        break;\n    if (a != 1 || b != 1) F = false;\n    puts(F ? \"Yes\" : \"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class game{\n   public static void main(String[] args)throws IOException{\n      BufferedReader b = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter pw = new PrintWriter(System.out);\n      StringTokenizer st =new StringTokenizer(b.readLine());\n      int n = Integer.parseInt(st.nextToken());\n      for(int i=0; i<n; i++){\n         st = new StringTokenizer(b.readLine());\n         long a = Long.parseLong(st.nextToken());\n         long c = Long.parseLong(st.nextToken());\n   \n         if(Math.round(Math.cbrt(a*c)) ==Math.cbrt(a*c)&& (a/Math.cbrt(a*c)==a/(long)Math.cbrt(a*c))&& (c/Math.cbrt(a*c)==c/(long)Math.cbrt(a*c))){\n            pw.println(\"Yes\");\n         }else{\n            pw.println(\"No\");\n         }\n      }\n      pw.close();\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    long long int a, b;\n    cin >> a >> b;\n    long long int p = a * b;\n    long long int st = 1;\n    long long int en = 1e6;\n    long long int ans = -1;\n    while (st <= en) {\n      long long int mid = st + en;\n      mid /= 2;\n      long long int check = mid * mid * mid;\n      if (check < p) {\n        st = mid + 1;\n      } else if (check == p) {\n        ans = mid;\n        break;\n      } else\n        en = mid - 1;\n    }\n    if (ans != -1 && a % ans == 0 && b % ans == 0) {\n      cout << \"YES\\n\";\n    } else\n      cout << \"NO\\n\";\n  }\n  cerr << \"Time elapsed : \" << clock() * 1000.0 / CLOCKS_PER_SEC << \"ms\"\n       << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        public InputReader(InputStream st) {\n            this.stream = st;\n        } \n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        } \n        public String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        } \n    }\n    public static class Key {\n\n        private final int x;\n        private final int y;\n\n        public Key(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Key)) return false;\n            Key key = (Key) o;\n            return x == key.x && y == key.y;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n\n    }\n    static class Pair{\n        long x,y,z;\n        public Pair(long x,long y,long z){\n            this.x=x;\n            this.y=y;\n            this.z=z;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Pair)) return false;\n            Pair key = (Pair) o;\n            return x == key.x && y == key.y && z==key.z;\n        }\n    }\n    static class Pair1{\n        long x,y;\n        public Pair1(long x,long y){\n            this.x=x;\n            this.y=y;\n            \n        }\n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static long mod=998244353L,mod1=1000000007;\n    \n    static ArrayList<Long> pri=new ArrayList<>();\n    public static void main(String [] args){\n        InputReader sc=new InputReader(System.in);\n        int t=sc.ni();\n        TreeMap<Long,Long> map=new TreeMap<>();\n        for(long i=1;i<=1000000;i++){\n            long x=i*i*i;\n            map.put(x, i);\n        }\n        while(t-->0){\n            long a=sc.nl(),b=sc.nl();\n            long m=a*b;\n            double c=Math.cbrt(a*b);\n            long x=(long)c;\n            \n            \n            if(x!=c)w.println(\"NO\");\n            else if(a%x!=0||b%x!=0)w.println(\"NO\");\n            else w.println(\"YES\");\n        }\n        w.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  while (n--) {\n    long long a, b;\n    scanf(\"%lld%lld\", &a, &b);\n    long long c = cbrt(a * b);\n    long long aa = a / c;\n    long long bb = b / c;\n    if (aa * aa * bb == a && bb * bb * aa == b) {\n      puts(\"Yes\");\n    } else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXR = 1000005;\nlong long cubic_root(long long x) {\n  long long l = 0, r = MAXR;\n  while (l != r) {\n    long long m = (l + r + 1) / 2;\n    if (m * m * m > x)\n      r = m - 1;\n    else\n      l = m;\n  }\n  return l;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    long long a, b;\n    scanf(\"%I64d %I64d\", &a, &b);\n    long long x = cubic_root(a * b);\n    if (x * x * x != a * b)\n      puts(\"No\");\n    else if (a % x == 0 && b % x == 0)\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = (0); i < (n); i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    int ret = -1;\n    for (int l = 1, r = 1000000, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1)\n      if (1ll * mid * mid * mid >= 1ll * a * b)\n        r = (ret = mid) - 1;\n      else\n        l = mid + 1;\n    if (!~ret || 1ll * ret * ret * ret != 1ll * a * b) {\n      printf(\"No\\n\");\n      continue;\n    }\n    if (a % ret != 0 || b % ret != 0) {\n      printf(\"No\\n\");\n    } else {\n      printf(\"Yes\\n\");\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\npublic class Prac{     \n    static class InputReader { \n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        public InputReader(InputStream st) {\n            this.stream = st;\n        } \n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n            c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        } \n        public int[] nia(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        } \n        public String rs() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                    c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        } \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        } \n    }\n    public static class Key {\n\n        private final int x;\n        private final int y;\n\n        public Key(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Key)) return false;\n            Key key = (Key) o;\n            return x == key.x && y == key.y;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            return result;\n        }\n\n    }\n    static class Pair{\n        long x,y,z;\n        public Pair(long x,long y,long z){\n            this.x=x;\n            this.y=y;\n            this.z=z;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Pair)) return false;\n            Pair key = (Pair) o;\n            return x == key.x && y == key.y && z==key.z;\n        }\n    }\n    static class Pair1{\n        long x,y;\n        public Pair1(long x,long y){\n            this.x=x;\n            this.y=y;\n            \n        }\n    }\n    static PrintWriter w = new PrintWriter(System.out);\n    static long mod=998244353L,mod1=1000000007;\n    \n    static ArrayList<Long> pri=new ArrayList<>();\n    public static void main(String [] args){\n        InputReader sc=new InputReader(System.in);\n        int t=sc.ni();\n        TreeMap<Long,Long> map=new TreeMap<>();\n        for(long i=1;i<=1000000;i++){\n            long x=i*i*i;\n            map.put(x, i);\n        }\n        while(t-->0){\n            long a=sc.nl(),b=sc.nl();\n            long m=a*b,c=-1;\n            if(map.containsKey(m)){\n                c=map.get(m);\n            }\n            \n            if(c==-1)w.println(\"NO\");\n            else if(a%c!=0||b%c!=0)w.println(\"NO\");\n            else w.println(\"YES\");\n        }\n        w.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.text.DecimalFormat;\nimport java.lang.reflect.Array;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\npublic class Codeforces{\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic long MOD = (long)(1e9+7);\n\tstatic long MOD2 = MOD*MOD;\n\t//static long MOD = 998244353;\n\tstatic FastReader sc = new FastReader();\n\tstatic int pInf = Integer.MAX_VALUE;\n\tstatic int nInf = Integer.MIN_VALUE;\n\tpublic static void main(String[] args){\n\t\tint test = 1;\n\t\ttest = sc.nextInt();\n\t\twhile(test-->0){\n\t\t\tlong a = sc.nextLong();\n\t\t\tlong b = sc.nextLong();\n\t\t\tif(b>a) {\n\t\t\t\tlong t = a;\n\t\t\t\ta = b;\n\t\t\t\tb = t;\n\t\t\t}\n\t\t\tlong p = a*b;\n\t\t\tlong s = 1;\n\t\t\tlong e = 2000001;\n\t\t\tlong ans = -1;\n\t\t\twhile(s<=e) {\n\t\t\t\tlong m = s+(e-s)/2;\n\t\t\t\tlong t  = m*m*m;\n\t\t\t\tif(t==p) {\n\t\t\t\t\tans = m;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(t>p) {\n\t\t\t\t\te = m-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts = m+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans!=-1 && a%ans==0 && b%ans==0) {\n\t\t\t\tout.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(\"No\");\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static Map<Integer, Integer> solve(int n){\n\t\tint t = n;\n\t\tMap<Integer, Integer> A = new HashMap<Integer, Integer>();\n\t\tfor(int i = 2; i <= Math.max(Math.sqrt(n), 2); i++) {\n\t\t\tif(t%i==0) {\n\t\t\t\tint count = 0;\n\t\t\t\twhile(t%i==0) {\n\t\t\t\t\tt = t/i;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tA.put(i, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn A;\n\t}\n\t\n\t\n\tpublic static long solve(long a, long b, long x, long y, long n) {\n\t\tif(a-x<n) {\n\t\t\tn = n-(a-x);\n\t\t\ta = x;\n\t\t\tb = Math.max(y, b-n);\n\t\t}\n\t\telse {\n\t\t\ta = a-n;\n\t\t}\n\t\treturn a*b;\n\t}\n\tpublic static int lowerBound(int key, ArrayList<Integer> A) {\n\t\tint s = 0;\n\t\tint e = A.size()-1;\n\t\tif(e==-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tint ans = -1;\n\t\twhile(s<=e) {\n\t\t\tint m = s+(e-s)/2;\n\t\t\tif(A.get(m)>=key) {\n\t\t\t\tans = m;\n\t\t\t\te = m-1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = m+1;\n\t\t\t}\n\t\t}\n\t\treturn ans==-1?s:ans;\n\t}\n\tpublic static int upperBound(int key, ArrayList<Integer> A) {\n\t\tint s = 0;\n\t\tint e = A.size()-1;\n\t\tif(e==-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tint ans = -1;\n\t\twhile(s<=e) {\n\t\t\tint m = s+(e-s)/2;\n\t\t\tif(A.get(m)>key) {\n\t\t\t\tans = m;\n\t\t\t\te = m-1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = m+1;\n\t\t\t}\n\t\t}\n\t\treturn ans==-1?s:ans;\n\t}\n\tpublic static long c2(long n) {\n\t\tif((n&1)==0) {\n\t\t\treturn mul(n/2, n-1);\n\t\t}\n\t\telse {\n\t\t\treturn mul(n, (n-1)/2);\n\t\t}\n\t}\n\tpublic static long mul(long a, long b){\n\t    return ((a%MOD)*(b%MOD))%MOD;\n\t}\n\tpublic static long add(long a, long b){\n\t    return ((a%MOD)+(b%MOD))%MOD;\n\t}\n\tpublic static long sub(long a, long b){\n\t    return ((a%MOD)-(b%MOD))%MOD;\n\t}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Integer.lowestOneBit(i)   Equals k where k is the position of the first one in the binary\n//Integer.highestOneBit(i)  Equals k where k is the position of the last one in the binary\n//Integer.bitCount(i)       returns the number of one-bits\n//Collections.sort(A,(p1,p2)->(int)(p2.x-p1.x)) To sort ArrayList in descending order wrt values of x.\n//            Arrays.parallelSort(a,new Comparator<TPair>() {\n//      \t\tpublic int compare(TPair a,TPair b) {\n//        \t\t\tif(a.y==b.y) return a.x-b.x;\n//        \t\t\treturn b.y-a.y;\n//        \t\t}\n//        \t});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//PrimeFactors    \n    public static ArrayList<Long> primeFactors(long n) {\n        ArrayList<Long> arr = new ArrayList<>();\n        if (n % 2 == 0)\n            arr.add((long) 2);\n        while (n % 2 == 0)\n            n /= 2;\n        for (long i = 3; i <= Math.sqrt(n); i += 2) {\n            int flag = 0;\n            while (n % i == 0) {\n                n /= i;\n                flag = 1;\n            }\n            if (flag == 1)\n                arr.add(i);\n        }\n        if (n > 2)\n            arr.add(n);\n        return arr;\n    }\n//Pair Class\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint y;\n\t\tint len;\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.len = y-x+1;\n\t\t}\n\t\t/*@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x==o.x){\n\t\t\t    return (this.y-o.y);\n\t\t\t}\n\t\t\treturn (this.x-o.x);\n\t\t}*/\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.len==o.len) {\n\t\t\t\treturn this.x-o.x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn o.len-this.len;\n\t\t\t}\n\t\t}\n\t}\n\tstatic class TPair implements Comparable<TPair>{\n\t\tint two;\n\t\tint three;\n\t\tint prime;\n\t\tpublic TPair(int two, int three, int prime) {\n\t\t\tthis.two = two;\n\t\t\tthis.three = three;\n\t\t\tthis.prime = prime;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(TPair o) {\n\t\t\tif(this.three==o.three){\n\t\t\t    return (this.two-o.two);\n\t\t\t}\n\t\t\treturn -1*(this.three-o.three);\n\t\t}\n\t}\n//nCr\n\tstatic long ncr(long n, long k) {\n        long ret = 1;\n        for (long x = n; x > n - k; x--) {\n            ret *= x;\n            ret /= (n - x + 1);\n        }\n\n        return ret;\n    }\n\tstatic long finextDoubleMMI_fermat(long n,int M)\n    {\n        return fastExpo(n,M-2);\n    }\n \n    static long nCrModPFermat(int n, int r, int p) \n    { \n        if (r == 0) \n            return 1; \n        long[] fac = new long[n+1]; \n        fac[0] = 1;           \n        for (int i = 1 ;i <= n; i++) \n            fac[i] = fac[i-1] * i % p;       \n        return (fac[n]* finextDoubleMMI_fermat(fac[r], p)% p * finextDoubleMMI_fermat(fac[n-r], p) % p) % p; \n    }\n//Kadane's Algorithm    \n    static long maxSubArraySum(ArrayList<Long> a) { \n    \tif(a.size()==0) {\n    \t\treturn 0;\n    \t}\n    \tlong max_so_far = a.get(0); \n    \tlong curr_max = a.get(0); \n    \tfor (int i = 1; i < a.size(); i++) { \n           curr_max = Math.max(a.get(i), curr_max+a.get(i)); \n           max_so_far = Math.max(max_so_far, curr_max); \n    \t} \n    \treturn max_so_far; \n    } \n//Shuffle Sort\n    static final Random random=new Random();\n\tstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n//Merge Sort\n\tstatic void merge(long arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        long L[] = new long [n1];\n        long R[] = new long [n2];\n \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n \n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void sort(long arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            // Find the middle point\n            int m = (l+r)/2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr , m+1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n//Brian Kernighans Algorithm\n    static long countSetBits(long n){\n        if(n==0) return 0;\n        return 1+countSetBits(n&(n-1));\n    }\n//Factorial\n    static long factorial(long n){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 6;\n        return n*factorial(n-1);\n    }\n//Euclidean Algorithm\n    static long gcd(long A,long B){\n        if(B==0) return A;\n        return gcd(B,A%B);\n    }\n//Modular Exponentiation\n    static long fastExpo(long x,long n){\n        if(n==0) return 1;\n        if((n&1)==0) return fastExpo((x*x)%MOD,n/2)%MOD;\n        return ((x%MOD)*fastExpo((x*x)%MOD,(n-1)/2))%MOD;\n    }\n//AKS Algorithm\n    static boolean isPrime(long n){\n        if(n<=1) return false;\n        if(n<=3) return true;\n        if(n%2==0 || n%3==0) return false;\n        for(int i=5;i<=Math.sqrt(n);i+=6)\n            if(n%i==0 || n%(i+2)==0) return false;\n        return true;\n    }\n//Reverse an array\n    static <T> void reverse(T arr[],int l,int r){\n    \tCollections.reverse(Arrays.asList(arr).subList(l, r));\n    }\n  //Print array\n    static void print1d(int arr[]) {\n    \tout.println(Arrays.toString(arr));\n    }\n    static void print2d(int arr[][]) {\n    \tfor(int a[]: arr) out.println(Arrays.toString(a));\n    }\n//Sieve of eratosthenes\n    static int[] findPrimes(int n){\n        boolean isPrime[]=new boolean[n+1];\n        ArrayList<Integer> a=new ArrayList<>();\n        int result[];\n        Arrays.fill(isPrime,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        for(int i=2;i*i<=n;++i){\n            if(isPrime[i]==true){\n                for(int j=i*i;j<=n;j+=i) isPrime[j]=false;\n            }\n        }\n        for(int i=0;i<=n;i++) if(isPrime[i]==true) a.add(i);\n        result=new int[a.size()];\n        for(int i=0;i<a.size();i++) result[i]=a.get(i);\n        return result;\n        \n    }\n//Indivisual factors of all nos till n\n    static ArrayList<Integer>[] indiFactors(int n){\n    \tArrayList<Integer>[] A = new ArrayList[n+1];\n    \tfor(int i = 0; i <= n; i++) {\n    \t\tA[i] = new ArrayList<>();\n    \t}\n    \tint[] sieve = new int[n+1];\n    \tfor(int i=2;i<=n;i++) {\n       \t\tif(sieve[i]==0) {\n       \t\t\tfor(int j=i;j<=n;j+=i) if(sieve[j]==0) {\n       \t\t\t\t//sieve[j]=i;\n       \t\t\t\tA[j].add(i);\n       \t\t\t}\n       \t\t}\n       \t}\n    \treturn A;\n    }\n//Segmented Sieve\n    static boolean[] segmentedSieve(long l, long r){\n    \tboolean[] segSieve = new boolean[(int)(r-l+1)];\n    \tArrays.fill(segSieve, true);\n    \tint[] prePrimes = findPrimes((int)Math.sqrt(r));\n    \tfor(int p:prePrimes) {\n    \t\tlong low = (l/p)*p;\n    \t\tif(low < l) {\n    \t\t\tlow += p;\n    \t\t}\n    \t\tif(low == p) {\n    \t\t\tlow += p;\n    \t\t}\n    \t\tfor(long j = low; j<= r; j += p) {\n    \t\t\tsegSieve[(int) (j-l)] = false;\n    \t\t}\n    \t}\n    \tif(l==1) {\n    \t\tsegSieve[0] = false;\n    \t}\n    \treturn segSieve;\n    }\n//Euler Totent function\n    static long countCoprimes(long n){\n        ArrayList<Long> prime_factors=new ArrayList<>();\n        long x=n,flag=0;\n        while(x%2==0){\n            if(flag==0) prime_factors.add(2L);\n            flag=1;\n            x/=2;\n        }\n        for(long i=3;i*i<=x;i+=2){\n            flag=0;\n            while(x%i==0){\n                if(flag==0) prime_factors.add(i);\n                flag=1;\n                x/=i;\n            }\n        }\n        if(x>2) prime_factors.add(x);\n        double ans=(double)n;\n        for(Long p:prime_factors){\n            ans*=(1.0-(Double)1.0/p);\n        }\n        return (long)ans;\n    }\n\tstatic long modulo = (long)1e9+7;\n\tpublic static long modinv(long x){\n\t    return modpow(x, modulo-2);\n\t}\n\tpublic static long modpow(long a, long b){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    long x = modpow(a, b/2);\n\t    x = (x*x)%modulo;\n\t    if(b%2==1){\n\t        return (x*a)%modulo;\n\t    }\n\t    return x;\n\t}\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.cbrt;\n\npublic class TestTemplate {\n  void solve(int T, FastScanner fs) {\n    long a = fs.nextInt();\n    long b = fs.nextInt();\n    if (a == 1 && b == 1) {\n      out.println(\"yes\");\n      return;\n    }\n    if (a == 1 || b == 1) {\n      out.println(\"no\");\n      return;\n    }\n    double ab = a * b;\n    double res = cbrt(ab);\n    int int_part = (int) res;\n    if (res-int_part > 0) {\n      out.println(\"no\");\n      return;\n    }\n    if (a%int_part != 0 || b%int_part != 0) {\n      out.println(\"no\");\n    } else {\n      out.println(\"yes\");\n    }\n  }\n  static PrintWriter out = new PrintWriter(System.out);\n  void go() {\n    FastScanner fs=new FastScanner();\n    int t = fs.nextInt();\n    for(int i=1; i<=t; i++) {\n      solve(i,fs);\n    }\n    out.flush();\n  }\n  static class FastScanner {\n    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st=new StringTokenizer(\"\");\n    String next() {\n      while (!st.hasMoreTokens())\n        try {\n          st=new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n  public static void main(String[] args) {\n    new TestTemplate().go();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class A {\n  void solve(int T) {\n    long a = nextInt();\n    long b = nextInt();\n    if (a == 1 && b == 1) {\n      out.println(\"yes\");\n      return;\n    }\n    if (a == 1 || b == 1) {\n      out.println(\"no\");\n      return;\n    }\n    double ab = a * b;\n    double res = cbrt(ab);\n    int int_part = (int) res;\n    if (res-int_part > 0) {\n      out.println(\"no\");\n    } else if (a%int_part != 0 || b%int_part != 0) {\n      out.println(\"no\");\n    } else {\n      out.println(\"yes\");\n    }\n  }\n  static int nextInt() {\n    return Integer.parseInt(next());\n  }\n  static String next() {\n    while (!st.hasMoreTokens()) {\n      try {\n        st=new StringTokenizer(br.readLine());\n      } catch (Exception e) {}\n    }\n    return st.nextToken();\n  }\n  static PrintWriter out = new PrintWriter(System.out);\n  static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  static StringTokenizer st = new StringTokenizer(\"\");\n  public static void main(String[] a) {\n    int t = nextInt();\n    for(int i=1; i<=t; i++) {\n      new A().solve(i);\n    }\n    out.flush();\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T>\nostream& operator<<(ostream& s, const vector<T>& v) {\n  s << \"[\";\n  for (int i = 0; i < v.size(); i++) s << (i == 0 ? \"\" : \", \") << v[i];\n  s << \"]\";\n  return s;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    ll a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    ll ok = 0, ng = 1500000LL;\n    while (ng - ok > 1) {\n      ll mid = (ng + ok) / 2;\n      if (mid * mid * mid <= a * b) {\n        ok = mid;\n      } else {\n        ng = mid;\n      }\n    }\n    ll c = ok;\n    if (c * c * c == a * b && a % c == 0 && b % c == 0) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\n \n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nfor t in range (int(input())):\n    a,b=map(int,input().split())\n    p=a*b\n    #print(p)\n    c=int(round(p**(1./3)))\n    #print (c)\n    if c**3==p and a%c==0 and b%c==0:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskA solver = new TaskA();\n    int testCount = Integer.parseInt(in.next());\n    for (int i = 1; i <= testCount; i++) {\n      solver.solve(i, in, out);\n    }\n    out.close();\n  }\n\n  static class TaskA {\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int a = in.nextInt();\n      int b = in.nextInt();\n      long d = IntegerUtils.gcd(a, b);\n      long xPrime = a / d;\n      long yPrime = b / d;\n      long xyOverG2 = xPrime * yPrime;\n      if (xyOverG2 > a || xyOverG2 > b) {\n        out.printLine(\"No\");\n        return;\n      }\n      long aOverG3 = xyOverG2 * xPrime;\n      if (a % aOverG3 != 0) {\n        out.printLine(\"No\");\n        return;\n      }\n      long g3 = a / aOverG3;\n      long l = 0, r = (long) (1.1E6);\n      while (r - l > 1) {\n        long t = (l + r) / 2;\n        if (t * t * t <= g3) {\n          l = t;\n        } else {\n          r = t;\n        }\n      }\n      if (l * l * l != g3) {\n        out.printLine(\"No\");\n        return;\n      }\n      long g = l;\n      long x = xPrime * g, y = yPrime * g;\n      if (x > a || x > b || y > a || y > b) {\n        out.printLine(\"No\");\n        return;\n      }\n      long xy = x * y;\n      if (xy > a || xy > b) {\n        out.printLine(\"No\");\n        return;\n      }\n      long x2y = xy * x, xy2 = xy * y;\n      if (x2y != a || xy2 != b) {\n        out.printLine(\"No\");\n        return;\n      }\n      out.printLine(\"Yes\");\n    }\n\n  }\n\n  static class IntegerUtils {\n\n    public static int gcd(int x, int y) {\n      if (y == 0) {\n        return x;\n      }\n      return gcd(y, x % y);\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public String nextToken() {\n      int c = readSkipSpace();\n      StringBuilder sb = new StringBuilder();\n      while (!isSpace(c)) {\n        sb.append((char) c);\n        c = read();\n      }\n      return sb.toString();\n    }\n\n    public String next() {\n      return nextToken();\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a * b / gcd(a, b); }\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int64_t random_long(long long l = LLONG_MIN, long long r = LLONG_MAX) {\n  uniform_int_distribution<int64_t> generator(l, r);\n  return generator(rng);\n}\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long inf = 1e18;\nconst int32_t M = 1e9 + 7;\nconst int32_t MM = 998244353;\nbool isPowerOfTwo(long long x) { return x && (!(x & (x - 1))); }\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nconst int N = 2e6 + 1;\nvoid solve() {\n  long long a, b;\n  cin >> a >> b;\n  long long target = a * b;\n  long long l = 1;\n  long long r = 1e6, mid, d;\n  bool k = false;\n  while (l <= r) {\n    mid = l + (r - l) / 2;\n    d = mid * mid * mid;\n    if (d == target) {\n      k = true;\n      break;\n    }\n    if (d < target) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  if (k == true && a % mid == 0 && b % mid == 0) {\n    cout << \"Yes\"\n         << \"\\n\";\n  } else {\n    cout << \"No\"\n         << \"\\n\";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a * b / gcd(a, b); }\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int64_t random_long(long long l = LLONG_MIN, long long r = LLONG_MAX) {\n  uniform_int_distribution<int64_t> generator(l, r);\n  return generator(rng);\n}\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst long long inf = 1e18;\nconst int32_t M = 1e9 + 7;\nconst int32_t MM = 998244353;\nbool isPowerOfTwo(long long x) { return x && (!(x & (x - 1))); }\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nconst int N = 2e6 + 1;\nvoid solve() {\n  long long a, b;\n  cin >> a >> b;\n  long long target = a * b;\n  long long l = 1;\n  long long r = 1e6, mid, d;\n  bool k = false;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    d = mid * mid * mid;\n    if (d == target) {\n      k = true;\n      break;\n    }\n    if (d < target) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  if (k == true && a % mid == 0 && b % mid == 0) {\n    cout << \"Yes\"\n         << \"\\n\";\n  } else {\n    cout << \"No\"\n         << \"\\n\";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\n\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\navl=AvlTree()\n#-----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default='z', func=lambda a, b: min(a ,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left)/ 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid]<=key):\n            count = mid+1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\n\n\ndef countGreater( arr,n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\nfor i in range(int(input())):\n    a,b=map(int,input().split())\n    c=a*b\n    l=int(c**(1./3)+0.5)\n    if l**3==a*b and a%l==0 and b%l==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class R426A\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tlong fst =sc.nextLong();\n\t\t\tlong snd = sc.nextLong();\n\t\t\t\n\t\t\tlong mul = fst*snd;\n\t\t\tlong xy = (long)Math.round(Math.cbrt(mul));\n\t\t\tif(1l*xy*xy*xy != mul)\n\t\t\t{\n\t\t\t\tpw.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tlong y = fst/xy;\n\t\t\tlong x = fst/(y*y);\n\t\t\tif(1.0*x*x*y > 1e10 || 1.0*x*y*y > 1e10)\n\t\t\t{\n\t\t\t\tpw.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\n\t\t\tlong one = x*x*y;\n\t\t\tlong two = y*y*x;\n\t\t\t\n\t\t\tif(fst == two && snd == one)\n\t\t\t{\n\t\t\t\tpw.println(\"Yes\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpw.println(\"No\");\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\t\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\t\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\t\t\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class First {\n    private static final Scanner sc = new Scanner(System.in);\n    private static final PrintWriter pw = new PrintWriter(System.out);\n    private static StringBuffer ans = new StringBuffer();\n\n    public static void main(String[] args) throws Exception {\n        int t = sc.nextInt();\n        for (int z = 0; z < t; z++) {\n            long a = sc.nextLong(), b = sc.nextLong();\n            long x = (long) Math.cbrt(a * b);\n            if (x * x * x == a * b && a % x == 0 && b % x == 0) ans.append(\"Yes\\n\");\n            else ans.append(\"No\\n\");\n        }\n        pw.print(ans);\n        sc.close();\n        pw.close();\n    }\n}\n\nclass Scanner {\n    private final BufferedReader br;\n    private StringTokenizer st;\n\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        st = new StringTokenizer(\"\");\n    }\n\n    public String next() throws IOException {\n        if (!st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public void close() throws IOException {\n        br.close();\n    }\n}\n\nclass PrintWriter {\n    private final BufferedOutputStream pw;\n\n    public PrintWriter(OutputStream out) {\n        pw = new BufferedOutputStream(out);\n    }\n\n    public void print(Object o) throws IOException {\n        pw.write(o.toString().trim().getBytes());\n        pw.flush();\n    }\n\n    public void println(Object o) throws IOException {\n        print(o + \"\\n\");\n    }\n\n    public void close() throws IOException {\n        pw.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double EPS = 1e-9, PI = acos(-1.);\nconst long long LINF = 0x3f3f3f3f3f3f3f3f, LMOD = 1011112131415161719ll;\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nconst int N = 1e6 + 10;\nmap<long long, long long> rt;\nint q;\nlong long a, b;\nint main() {\n  for (long long i = 1; i < N; i++) rt[i * i * i] = i;\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%lld%lld\", &a, &b);\n    long long r = rt[a * b];\n    printf(\"%s\\n\", r and a % r == 0 and b % r == 0 ? \"Yes\" : \"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Practice1 {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=input.nextInt();\n        while(T-->0)\n        {\n            long a=input.nextInt();\n            long b=input.nextInt();\n            long p=a*b;\n            long c=(long)Math.cbrt(p);\n            long p1=(c*c*c);\n            if(p1!=p)\n            {\n                out.println(\"NO\");\n            }\n            else\n            {\n                if(a%c==0 && b%c==0)\n                {\n                    out.println(\"YES\");\n                }\n                else\n                {\n                    out.println(\"NO\");\n                }\n            }\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long GCD(long long x, long long y) {\n  if (y == 0) return x;\n  return GCD(y, x % y);\n}\nlong long n, a, b;\nlong long cs;\nbool calc() {\n  scanf(\"%lld %lld\", &a, &b);\n  long long g = GCD(a, b);\n  long long p = a / g;\n  long long q = b / g;\n  long long pq = p * q;\n  bool ret = (g % pq == 0);\n  if (ret) {\n    long long r = g / pq;\n    long long i = 1;\n    while (i * i * i < r) {\n      i++;\n    }\n    if (i * i * i == r) return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%lld\", &n);\n  while (cs < n) {\n    cs++;\n    bool ans = calc();\n    if (ans)\n      printf(\"Yes\\n\");\n    else\n      printf(\"No\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunsigned long long mod = 1e9 + 7;\nlong long MOD = 998244353;\nunsigned long long ncr(long long n, long long k) {\n  if (k > n) return 1ll * 0;\n  unsigned long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n    res = res;\n  }\n  return res;\n}\nbool prime(unsigned long long num) {\n  bool flag = true;\n  for (unsigned long long i = 2; i * i <= num; i++) {\n    if (num % i == 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\nlong long ipow(long long base, long long exp) {\n  if (exp == 0) return 1ll * 1;\n  long long result = 1;\n  for (;;) {\n    if (exp & 1) {\n      result *= base;\n      result = result % MOD;\n    }\n    exp >>= 1;\n    if (!exp) break;\n    base *= base;\n    base = base % MOD;\n  }\n  return result % MOD;\n}\nlong long abs(long long a, long long b) {\n  if ((a - b) > 0)\n    return (a - b);\n  else\n    return (b - a);\n}\nlong long add(long long a, long long b) {\n  a += b;\n  if (a >= MOD)\n    a -= MOD;\n  else if (a < 0)\n    a += MOD;\n  return a;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long der(long long k) {\n  long long res = 0;\n  long long fact = 1;\n  for (long long i = 2; i <= k; i++) fact *= i;\n  long long s = 1;\n  long long j = 1;\n  for (long long i = 2; i <= k; i++) {\n    j = j * i;\n    long long first = (fact / j) * s;\n    res += first;\n    s = s * (-1);\n  }\n  return res;\n}\nvector<long long> p;\nvector<long long> _prime(long long a) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= a; i++) {\n    if (a % i == 0) {\n      v.push_back(i);\n      while (a % i == 0) a /= i;\n    }\n  }\n  if (a != 1) v.push_back(a);\n  return v;\n}\nlong long cubic_root(long long x) {\n  long long l = 0, r = 1000000;\n  while (l != r) {\n    long long m = (l + r + 1) / 2;\n    if (m * m * m > x)\n      r = m - 1;\n    else\n      l = m;\n  }\n  return l;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  while (n--) {\n    long long a, b;\n    cin >> a >> b;\n    long long c = a * b;\n    long long k = cubic_root(c);\n    bool flag = false;\n    if (k * k * k == c && a % k == 0 && b % k == 0) flag = true;\n    if (flag == true) {\n      cout << \"YES\\n\";\n    } else {\n      cout << \"NO\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class TheMeaninglessGame833A {\n\n    public static long MAXR = 1000005;\n\n    public static long cubicRoot(int x) {\n        long l = 0, r = MAXR;\n        while (l != r) {\n            long m = (l + r + 1) / 2;\n            if (m * m * m > x)\n                r = m - 1;\n            else\n                l = m;\n        }\n        return l;\n    }\n\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder answer = new StringBuilder();\n        for (int i = 0; i < T; i++) {\n            st = new StringTokenizer(br.readLine());\n            long a = Long.parseLong(st.nextToken());\n            long b = Long.parseLong(st.nextToken());\n            long c = (long) Math.cbrt(a * b * 1.0);\n            if (c * c * c == a * b && (a % c == 0 && b % c == 0)) {\n                answer.append(\"Yes\\n\");\n            } else {\n                answer.append(\"No\\n\");\n            }\n        }\n        System.out.println(answer);\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class meangame {\n   public static void main(String[] args) throws IOException {\n      BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter out = new PrintWriter(System.out);\n      StringTokenizer st = new StringTokenizer(f.readLine());\n      \n      int n = Integer.parseInt(st.nextToken());\n      for (int i = 0; i < n; i++) {\n         st = new StringTokenizer(f.readLine());\n         long a = Long.parseLong(st.nextToken());\n         int b = Integer.parseInt(st.nextToken());\n         if ((int)(Math.cbrt(a*b)) == Math.cbrt(a*b) && ((int)(a/Math.cbrt(a*b)) == a/Math.cbrt(a*b) && (int)(b/Math.cbrt(a*b)) == b/Math.cbrt(a*b))) {\n            out.println(\"Yes\");\n         }\n         else {\n            out.println(\"No\");\n         }\n      }\n      out.close();\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long a, i, x, y;\n  scanf(\"%I64d \", &a);\n  while (a--) {\n    scanf(\"%I64d %I64d\", &x, &y);\n    i = ceil(cbrt(x * y));\n    if (x % i == 0 && y % i == 0 && (x * y) == i * i * i) {\n      printf(\"Yes\\n\");\n    } else\n      printf(\"No\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, a, b;\nbool check(long long x) {\n  long long l = 0, r = 1000000;\n  while (l != r) {\n    long long m = (l + r + 1) / 2;\n    if (m * m * m > x) {\n      r = m - 1;\n    } else {\n      l = m;\n    }\n  }\n  bool ok = (l * l * l == a * b);\n  return (ok && !(a % l) && !(b % l));\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    if (check(a * b)) {\n      cout << \"Yes\\n\";\n    } else {\n      cout << \"No\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author warez80\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tint testCount = Integer.parseInt(in.next());\n\t\tfor (int i = 1; i <= testCount; i++)\n\t\t\tsolver.solve(i, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskA {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tlong a = in.nextLong();\n\t\t\tlong b = in.nextLong();\n\t\t\tlong ab = a * b;\n\t\t\tlong lo = 0;\n\t\t\tlong hi = 100;\n\t\t\twhile (hi * hi * hi < ab) {\n\t\t\t\tlo = hi + 1;\n\t\t\t\thi <<= 1;\n\t\t\t}\n\t\t\twhile (lo <= hi) {\n\t\t\t\tlong mid = ((hi ^ lo) >>> 1) + (lo & hi);\n\t\t\t\tlong cube = mid * mid * mid;\n\t\t\t\tif (cube < ab) {\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t} else if (cube > ab) {\n\t\t\t\t\thi = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (a % mid == 0 && b % mid == 0) {\n\t\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(\"No\");\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate byte[] buffer = new byte[1 << 10];\n\t\tprivate int bp;\n\t\tprivate int br;\n\t\tprivate InputStream is;\n\t\tprivate boolean empty;\n\t\tprivate boolean skipLF;\n\n\t\tpublic FastScanner(InputStream in) {\n\t\t\tis = in;\n\t\t}\n\n\t\tprivate byte r() {\n\t\t\tif (empty) throw new UnknownError();\n\t\t\tif (bp == br) try {\n\t\t\t\tbr = is.read(buffer, bp = 0, 1 << 10);\n\t\t\t\tif (br == -1) buffer[0] = -1;\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t\tif (bp >= buffer.length || buffer[bp] == -1) {\n\t\t\t\tempty = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buffer[bp++];\n\t\t}\n\n\t\tprivate byte rnw() {\n\t\t\tskipLF = false;\n\t\t\tbyte c;\n\t\t\tdo c = r(); while (c <= ' ');\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = rnw();\n\t\t\tboolean neg = c == '-';\n\t\t\tif (neg) c = r();\n\t\t\tdo ret = (ret << 3) + (ret << 1) + c - '0'; while ((c = r()) >= '0' && c <= '9');\n\t\t\tif (neg) return -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate static byte[] expand(byte[] b) {\n\t\t\tbyte[] newa = new byte[b.length << 1];\n\t\t\tSystem.arraycopy(b, 0, newa, 0, b.length);\n\t\t\treturn newa;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tbyte c = rnw(), buf[] = new byte[64];\n\t\t\tint cnt = 0;\n\t\t\tdo {\n\t\t\t\tif (c <= ' ') break;\n\t\t\t\tif (cnt == buf.length) buf = expand(buf);\n\t\t\t\tbuf[cnt++] = c;\n\t\t\t} while ((c = r()) != -1);\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    long long a, b;\n    cin >> a >> b;\n    long long pro = (a * b);\n    long long c = cbrt((long double)(pro));\n    if (c * c * c != pro)\n      cout << \"No\" << '\\n';\n    else if (a % c == 0 && b % c == 0)\n      cout << \"Yes\" << '\\n';\n    else\n      cout << \"No\" << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long x, y;\nlong long gcd(long long x, long long y) {\n  if (!y) return x;\n  return gcd(y, x % y);\n}\nbool check() {\n  double x2 = log(x), y2 = log(y);\n  double t1 = (2 * y2 - x2) / 3, t2 = (2 * x2 - y2) / 3;\n  t1 = exp(t1);\n  t2 = exp(t2);\n  long long s1 = (t1 + 0.5), s2 = t2 + 0.5;\n  if (fabs(t1 - s1) < 1e-6 && fabs(t2 - s2) < 1e-6) return 1;\n  return 0;\n}\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%lld%lld\", &x, &y);\n    if (check())\n      puts(\"Yes\");\n    else\n      puts(\"No\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    long long x, y;\n    scanf(\"%I64d%I64d\", &x, &y);\n    long long t = x * y;\n    bool flag = false;\n    long long l = 1, r = 1e6 + 10, m;\n    while (l <= r) {\n      m = (l + r) / 2;\n      if (m * m * m == t) {\n        flag = true;\n        break;\n      } else if (m * m * m > t) {\n        r = m - 1;\n      } else {\n        l = m + 1;\n      }\n    }\n    if (flag) {\n      if (x % m != 0 || y % m != 0)\n        puts(\"NO\");\n      else\n        puts(\"Yes\");\n    } else\n      puts(\"No\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll MOD = 1000000007;\nll INF = 1LL << 60;\nll HI = 1000005;\nll cubic_root(ll x) {\n  ll lo = 0, hi = HI;\n  while (lo < hi) {\n    ll m = lo + ((hi - lo + 1) / 2);\n    if (m * m * m > x)\n      hi = m - 1;\n    else\n      lo = m;\n  }\n  return lo;\n}\nll a, b, ab, cuberoot;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int n;\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    ab = a * b;\n    cuberoot = cubic_root(ab);\n    if (cuberoot * cuberoot * cuberoot != ab) {\n      cout << \"No\\n\";\n      continue;\n    }\n    if (a % cuberoot == 0 && b % cuberoot == 0) {\n      cout << \"Yes\\n\";\n      continue;\n    }\n    cout << \"No\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxk = 1005;\nstring mul(string a, string b) {\n  int res[Maxk];\n  memset(res, 0, sizeof(res));\n  reverse(a.begin(), a.end());\n  reverse(b.begin(), b.end());\n  for (int i = 0; i < a.length(); i++) {\n    for (int j = 0; j < b.length(); j++) {\n      res[i + j] += (a[i] - '0') * (b[j] - '0');\n    }\n  }\n  for (int i = 0; i < Maxk; i++) {\n    if (res[i] >= 10) {\n      res[i + 1] += (res[i] / 10);\n      res[i] %= 10;\n    }\n  }\n  string ret;\n  bool flag = false;\n  for (int i = Maxk - 1; i >= 0; i--) {\n    if (flag || res[i]) {\n      flag = true;\n      ret = ret + (char)(res[i] + '0');\n    }\n  }\n  if (ret == \"\") ret = \"0\";\n  return ret;\n}\nstring add(string a, string b) {\n  if (a.length() < b.length()) swap(a, b);\n  while (a.length() != b.length()) {\n    b = '0' + b;\n  }\n  for (int i = a.length() - 1; i >= 0; i--) {\n    a[i] += (b[i] - '0');\n    if (a[i] > '9' && i) {\n      a[i] -= 10;\n      a[i - 1]++;\n    }\n  }\n  if (a[0] > '9') {\n    a[0] -= 10;\n    a = '1' + a;\n  }\n  return a;\n}\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  for (int i = 0; i < t; i++) {\n    long long a, b;\n    a = (long long)read();\n    b = (long long)read();\n    long long c = a * b;\n    long long l = 0, r = 2e6;\n    while (r - l > 1) {\n      long long mid = (l + r) >> 1;\n      if (mid * mid * mid < c) {\n        l = mid;\n      } else {\n        r = mid;\n      }\n    }\n    long long v;\n    if (l * l * l == c) {\n      v = l;\n    } else if (r * r * r == c) {\n      v = r;\n    } else {\n      printf(\"No\\n\");\n      continue;\n    }\n    if (a % v == 0 && b % v == 0) {\n      printf(\"Yes\\n\");\n    } else {\n      printf(\"No\\n\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long t, a, b;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    scanf(\"%lld%lld\", &a, &b);\n    long long m = pow(a * b, (1.0 / 3)) + 0.5;\n    puts((m * m * m != a * b || a % m || b % m) ? \"No\" : \"Yes\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nint getbit(T s, int i) {\n  return (s >> i) & 1;\n}\ntemplate <class T>\nT onbit(T s, int i) {\n  return s | (T(1) << i);\n}\ntemplate <class T>\nT offbit(T s, int i) {\n  return s & (~(T(1) << i));\n}\ntemplate <class T>\nint cntbit(T s) {\n  return __builtin_popcount(s);\n}\ntemplate <class T>\ninline T gcd(T a, T b) {\n  T r;\n  while (b != 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\nlong long n, a, b;\nlong long fin(long long x) {\n  long long l = 0, r = 1e6;\n  while (l != r) {\n    long long mid = (l + r + 1) >> 1;\n    if (mid * mid * mid <= x) {\n      l = mid;\n    } else\n      r = mid - 1;\n  }\n  return l;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  while (n--) {\n    cin >> a >> b;\n    if (a > b) swap(a, b);\n    long long z = fin(a * b);\n    if (z * z * z != a * b)\n      cout << \"No\\n\";\n    else if (a % z == 0 && b % z == 0)\n      cout << \"Yes\\n\";\n    else\n      cout << \"No\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  while (n--) {\n    long long int a, b;\n    scanf(\"%lld %lld\", &a, &b);\n    double t = pow(a * b, 1.0 / 3);\n    long long int x = t + 0.0001;\n    if (x * x * x == a * b && a % x == 0 && b % x == 0)\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n}\n"
        }
    ]
}