{
    "name": "505_B. Mr. Kitayuta's Colorful Graph",
    "source": "CODEFORCES",
    "description": "Mr. Kitayuta has just bought an undirected graph consisting of n vertices and m edges. The vertices of the graph are numbered from 1 to n. Each edge, namely edge i, has a color ci, connecting vertex ai and bi.\n\nMr. Kitayuta wants you to process the following q queries.\n\nIn the i-th query, he gives you two integers \u2014 ui and vi.\n\nFind the number of the colors that satisfy the following condition: the edges of that color connect vertex ui and vertex vi directly or indirectly.\n\nInput\n\nThe first line of the input contains space-separated two integers \u2014 n and m (2 \u2264 n \u2264 100, 1 \u2264 m \u2264 100), denoting the number of the vertices and the number of the edges, respectively.\n\nThe next m lines contain space-separated three integers \u2014 ai, bi (1 \u2264 ai < bi \u2264 n) and ci (1 \u2264 ci \u2264 m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i \u2260 j, (ai, bi, ci) \u2260 (aj, bj, cj).\n\nThe next line contains a integer \u2014 q (1 \u2264 q \u2264 100), denoting the number of the queries.\n\nThen follows q lines, containing space-separated two integers \u2014 ui and vi (1 \u2264 ui, vi \u2264 n). It is guaranteed that ui \u2260 vi.\n\nOutput\n\nFor each query, print the answer in a separate line.\n\nExamples\n\nInput\n\n4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n\n\nOutput\n\n2\n1\n0\n\n\nInput\n\n5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n\n\nOutput\n\n1\n1\n1\n1\n2\n\nNote\n\nLet's consider the first sample. \n\n<image> The figure above shows the first sample. \n\n  * Vertex 1 and vertex 2 are connected by color 1 and 2. \n  * Vertex 3 and vertex 4 are connected by color 3. \n  * Vertex 1 and vertex 4 are not connected by any single color. ",
    "difficulty": "B",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "graphs"
    ],
    "rating": 1400,
    "public_test": [
        {
            "input": "5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n2\n"
        },
        {
            "input": "4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "2\n1\n0\n"
        }
    ],
    "generated_test": [
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "0\n0\n1\n0\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "6 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n2\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "6 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 2\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n1\n1\n1\n2\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 2\n",
            "output": "2\n2\n2\n2\n2\n"
        },
        {
            "input": "2 3\n1 2 3\n1 2 2\n2 2 1\n1\n1 2\n",
            "output": "2\n"
        },
        {
            "input": "5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "4 5\n1 4 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 2\n2 3 1\n2 3 3\n2 1 3\n3\n1 2\n3 4\n1 4\n",
            "output": "2\n0\n0\n"
        },
        {
            "input": "6 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 2\n5 1\n2 5\n1 5\n1 6\n",
            "output": "2\n1\n1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 3\n2 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "4 5\n1 4 1\n1 2 2\n2 3 1\n2 1 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "2\n0\n2\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n2 4 1\n2\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n2 4 1\n1\n1 2\n3 4\n1 4\n",
            "output": "0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n4 3 2\n3 4 2\n5\n1 5\n5 2\n2 3\n2 5\n1 4\n",
            "output": "1\n1\n0\n1\n0\n"
        },
        {
            "input": "8 7\n1 5 2\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n5 5 1\n4 5 2\n1 1 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "0\n0\n2\n0\n0\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 3\n2 3 1\n1 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n0\n0\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 2\n2 3 1\n2 3 3\n2 1 3\n3\n1 2\n3 1\n1 4\n",
            "output": "2\n2\n0\n"
        },
        {
            "input": "6 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 6 2\n3 4 2\n5\n1 2\n5 1\n2 5\n1 5\n1 6\n",
            "output": "2\n1\n1\n1\n1\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n4 3 3\n2 4 1\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n2\n0\n"
        },
        {
            "input": "4 5\n1 4 1\n1 2 2\n2 3 1\n2 1 3\n3 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "2\n1\n1\n"
        },
        {
            "input": "5 7\n2 1 1\n2 5 1\n3 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n4\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n2\n2\n2\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n2 1 1\n2\n1 2\n3 4\n1 4\n",
            "output": "1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n5 5 1\n4 5 2\n1 1 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n2 4\n",
            "output": "0\n0\n2\n0\n1\n"
        },
        {
            "input": "4 5\n2 2 1\n2 1 2\n2 3 1\n2 3 3\n4 4 1\n1\n1 2\n3 4\n1 4\n",
            "output": "1\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 3\n1 3 1\n1 3 3\n2 4 3\n3\n1 2\n3 4\n2 4\n",
            "output": "1\n0\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 5 3\n3 3 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "1\n1\n2\n2\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 2 2\n1 2 1\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 3\n2 3\n1 4\n",
            "output": "1\n1\n1\n1\n0\n"
        },
        {
            "input": "5 7\n1 5 2\n2 5 1\n3 5 2\n4 5 1\n1 3 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n1\n1\n2\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 4\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n0\n1\n0\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 3\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n5 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 3\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 2\n",
            "output": "2\n2\n2\n2\n2\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "4 5\n1 3 1\n1 1 3\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 2\n5 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 2\n2 3 1\n4 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n2 4 1\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n3 5 3\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 2\n",
            "output": "1\n1\n1\n1\n2\n"
        },
        {
            "input": "5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n2 1 1\n2 5 1\n3 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "5 5\n1 3 1\n1 1 3\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 2\n5 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n4 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 2\n2 3\n2 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "5 7\n1 5 2\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "5 7\n2 1 1\n2 5 1\n3 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 2\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "5 5\n1 3 1\n1 1 3\n2 3 1\n4 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "8 7\n1 5 2\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "5 5\n1 3 1\n1 1 3\n2 3 2\n4 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "4 5\n1 3 1\n1 1 3\n2 3 2\n4 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "7 5\n1 3 1\n1 1 3\n2 3 2\n4 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "0\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n3 5\n1 5\n1 4\n",
            "output": "0\n0\n1\n0\n1\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 3\n1 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n4 5\n1 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 5 2\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 4\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n3 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 4\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 2 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 3\n2 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 2\n5 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n3 5\n1 5\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n1 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 2\n2 3\n2 5\n1 4\n",
            "output": "2\n2\n1\n2\n1\n"
        },
        {
            "input": "5 7\n1 5 2\n2 5 1\n3 5 1\n4 5 1\n1 2 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n1\n1\n1\n"
        },
        {
            "input": "4 5\n2 2 1\n1 1 2\n2 3 1\n2 3 3\n4 4 1\n1\n1 2\n3 4\n1 4\n",
            "output": "0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n3 3 2\n3 4 2\n5\n1 5\n5 2\n2 3\n2 5\n1 4\n",
            "output": "1\n1\n0\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 4 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n3 5\n1 5\n1 4\n",
            "output": "0\n0\n1\n0\n1\n"
        },
        {
            "input": "4 5\n1 2 2\n1 1 3\n1 3 1\n1 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n0\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 5 2\n3 3 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n2\n2\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 2\n2 4 1\n2 3 3\n2 1 3\n3\n1 2\n3 1\n1 4\n",
            "output": "2\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 1\n2 1 1\n1 5 1\n4 2 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 3\n2 3\n1 4\n",
            "output": "1\n1\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 5 2\n2 5 1\n3 5 1\n4 5 1\n1 3 1\n2 3 1\n3 4 2\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "2\n2\n1\n1\n1\n"
        },
        {
            "input": "5 7\n1 1 2\n2 1 1\n1 5 1\n4 5 2\n1 2 2\n3 3 2\n3 4 2\n5\n1 5\n5 2\n2 3\n2 5\n1 4\n",
            "output": "1\n1\n0\n1\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n1 5 1\n4 5 2\n1 2 2\n2 5 3\n3 3 4\n5\n1 5\n5 1\n2 5\n2 5\n1 4\n",
            "output": "1\n1\n2\n2\n0\n"
        },
        {
            "input": "5 7\n1 5 2\n2 5 1\n3 5 2\n4 5 1\n1 3 1\n2 3 1\n3 4 2\n5\n1 5\n5 2\n2 5\n2 5\n1 4\n",
            "output": "2\n1\n1\n1\n2\n"
        },
        {
            "input": "4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n2 4\n",
            "output": "2\n1\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 1 2\n2 3 1\n2 3 3\n2 3 3\n3\n1 2\n3 4\n1 4\n",
            "output": "1\n0\n0\n"
        },
        {
            "input": "5 7\n1 1 1\n2 5 1\n3 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 3\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "4 5\n1 2 1\n1 2 3\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n",
            "output": "2\n1\n1\n"
        },
        {
            "input": "7 7\n1 1 1\n2 5 1\n5 5 1\n4 5 2\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n",
            "output": "1\n1\n2\n1\n1\n"
        },
        {
            "input": "6 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n5 4 2\n5\n1 2\n5 1\n2 5\n1 5\n1 4\n",
            "output": "2\n1\n1\n1\n1\n"
        }
    ],
    "solution": [
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Solution_505B {\n    public static boolean[][][] colorMatrix;\n    public static boolean[] used;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String strings[] = reader.readLine().split(\" \");\n        int nodes = Integer.parseInt(strings[0]);   //\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u0433\u0440\u0430\u0444\u0430\n        int edges = Integer.parseInt(strings[1]);   // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440 \u0433\u0440\u0430\u0444\u0430\n\n         colorMatrix = new boolean[edges + 1][nodes + 1][nodes + 1];\n         used = new boolean[nodes + 1];\n\n        for (int i = 1; i <= edges; i++) {\n            String edge[] = reader.readLine().split(\" \");\n            int apex1 = Integer.parseInt(edge[0]);\n            int apex2 = Integer.parseInt(edge[1]);\n            int color = Integer.parseInt(edge[2]);\n\n            colorMatrix[color][apex1][apex2] = true;\n            colorMatrix[color][apex2][apex1] = true;\n        }\n\n        int requests = Integer.parseInt(reader.readLine());\n        for (int i = 0; i < requests; i++) {\n            String edge[] = reader.readLine().split(\" \");\n            int apex1 = Integer.parseInt(edge[0]);\n            int apex2 = Integer.parseInt(edge[1]);\n            int num = 0;\n\n            for (int j = 1; j <= edges; j++) {\n                used = new boolean[nodes + 1];\n                DFS(j, apex1, nodes);\n                if (used[apex2])\n                    num++;\n            }\n\n            System.out.println(num);\n        }\n    }\n\n    public static void DFS(int color, int v, int nodes) {\n        used[v] = true; // \u043f\u043e\u043c\u0435\u0447\u0430\u0435\u043c \u0432\u0435\u0440\u0448\u0438\u043d\u0443\n        for (int nv = 1; nv <= nodes; nv++) // \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0435\u0440\u0448\u0438\u043d\u044b\n            if (!used[nv] && colorMatrix[color][v][nv]) // \u0435\u0441\u043b\u0438 \u0432\u0435\u0440\u0448\u0438\u043d\u0430 \u043d\u0435 \u043f\u043e\u043c\u0435\u0447\u0435\u043d\u0430, \u0438 \u0441\u043c\u0435\u0436\u043d\u0430 \u0441 \u0442\u0435\u043a\u0443\u0449\u0435\u0439\n                DFS(color, nv, nodes); // \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043e\u0442 \u043d\u0435\u0435 DFS\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n# coding=utf-8\n\nn, m = map(int, raw_input().split())\nmp = [[set() for j in range(n)] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    if c not in mp[a][b]:\n        mp[a][b].add(c)\n        mp[b][a].add(c)\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            mp[i][j] |= (mp[i][k] & mp[k][j])\nq = input()\nfor i in range(q):\n    u, v = map(int, raw_input().split())\n    u -= 1\n    v -= 1\n    print len(mp[u][v]) if mp[u][v] else 0\n"
        },
        {
            "language": 3,
            "solution": "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        parent = {}\n        parent = dfs_visit(v, graph[c], parent)\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int y) {\n  long long int res = 1;\n  x = x;\n  while (y > 0) {\n    if (y & 1) res = (res * x);\n    y = y >> 1;\n    x = (x * x);\n  }\n  return res;\n}\nlong long int logtwo(long long int n) {\n  if (n == 1) return 0;\n  return logtwo(n / 2) + 1;\n}\nvector<long long int> adj[105][105];\nlong long int vis[105][105];\nvoid dfs(int par, long long int col) {\n  for (auto child : adj[par][col]) {\n    if (vis[child][col]) continue;\n    vis[child][col] = vis[par][col];\n    dfs(child, col);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    long long int N, M;\n    cin >> N >> M;\n    for (long long int i = 0; i < M; i++) {\n      long long int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      adj[a][c].push_back(b);\n      adj[b][c].push_back(a);\n    }\n    for (long long int i = 0; i < 105; i++) {\n      long long int c = 1;\n      for (long long int j = 0; j < N; j++) {\n        if (vis[j][i]) continue;\n        vis[j][i] = c++;\n        dfs(j, i);\n      }\n    }\n    long long int Q;\n    cin >> Q;\n    while (Q--) {\n      long long int x, y;\n      cin >> x >> y;\n      long long int ans = 0;\n      x--;\n      y--;\n      for (long long int i = 0; i < 105; i++) {\n        if (vis[x][i] && vis[x][i] == vis[y][i]) ans++;\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n  cerr << \"Time : \" << 1000 * (long double)clock() / (long double)CLOCKS_PER_SEC\n       << \"ms\\n\";\n  ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5 + 100, M = 1e6 + 100, SQ = sqrt(2e5), LG = 23, base = 2,\n          second = 1e2 + 100;\nconst long long mod = 1e9 + 7, MOD = 1e9 + 9, Inf = 9223372036854775807;\nconst long long INF = 1e9, inf = 1e18, super_inf = ~0ull / 4;\nconst long double Pi = (22 * 1.0) / (7 * 1.0);\nusing namespace std;\nlong long n, m, ans, a, b, c, q;\nvector<pair<long long, long long> > v[second];\nbool mark[second];\nvoid dfs(long long a, long long b, int c) {\n  mark[a] = 1;\n  for (auto x : v[a]) {\n    if (!mark[x.first] and x.second == c) dfs(x.first, b, c);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  ;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++)\n    cin >> a >> b >> c, v[a].push_back(make_pair(b, c)),\n        v[b].push_back(make_pair(a, c));\n  cin >> q;\n  while (q--) {\n    cin >> a >> b;\n    ans = 0;\n    for (int i = 1; i <= m; i++) {\n      fill(mark, mark + second, 0);\n      dfs(a, b, i);\n      if (mark[b]) ans++;\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\n\npublic class graph {\n    static ArrayList<ArrayList<int[]>> graph=new ArrayList<>();\n    static HashSet<Integer> hs=new HashSet<>();\n    static int ct=0;\n    public static void dfs(int s,int targ,int lc,boolean[] vd){\n        if(s==targ){\n            hs.add(lc);\n            ct++;\n            return ;\n        }\n\n        for(int[] nbr:graph.get(s)){\n\n            if(!vd[nbr[0]] && (nbr[1]==lc || lc==-1)){\n                vd[nbr[0]]=true;\n                dfs(nbr[0], targ, nbr[1], vd);\n                vd[nbr[0]]=false;\n            }\n        }\n    }\n    public static void main(String[] args) throws Exception{\n                InputStreamReader ip=new InputStreamReader(System.in);\n                BufferedReader br = new BufferedReader(ip);\n        \t\t// int n = Integer.parseInt(br.readLine());\n        \t\t// StringBuilder sb = new StringBuilder();\n                // ArrayList<Integer> list=new ArrayList<>();\n        \n                String[] strs=(br.readLine()).trim().split(\" \");\n                \n                int n=Integer.parseInt(strs[0]);\n                int m=Integer.parseInt(strs[1]);\n\n                for(int i=0;i<=n;i++){ graph.add(new ArrayList<>());}\n              \n\n               for(int i=0;i<m;i++){\n                strs=(br.readLine()).trim().split(\" \");\n                int u=Integer.parseInt(strs[0]);\n                int v=Integer.parseInt(strs[1]);\n                int w=Integer.parseInt(strs[2]);\n\n                (graph.get(u)).add(new int[]{v,w});\n                (graph.get(v)).add(new int[]{u,w});\n               }\n               \n               int q=Integer.parseInt(br.readLine());\n\n               boolean[] vd=new boolean[n+1];\n               for(int i=0;i<q;i++){\n                strs=(br.readLine()).trim().split(\" \");\n                int u=Integer.parseInt(strs[0]);\n                int v=Integer.parseInt(strs[1]);\n                ct=0;\n                hs=new HashSet<>();\n                vd[u]=true;\n                dfs(u,v,-1,vd);\n                vd[u]=false;\n                // ans+=ct;\n                System.out.println(hs.size());\n               }\n\n               \n    }\n\n}\n\n\n//     static long mod=10000_00007;\n//     // Approach\n//     // Property: Look at one tree and take its diameter. Name its endpoints A and B. \n//     //For each vertex u from this component, p[u]\u2009=\u2009A or p[u]\u2009=\u2009B. It's easy to prove that.\n//     //We can just count number of different elements in P and divide it by two.\n//    //Special case : Isolated vertices (those with p[i]\u2009=\u2009i).\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n// \t\t// StringBuilder sb = new StringBuilder();\n//         ArrayList<Integer> list=new ArrayList<>();\n\n//         String[] strs=(br.readLine()).trim().split(\" \");\n\n//         int[] arr=new int[n];\n//         HashSet<Integer> hs=new HashSet<>();\n\n//         long ans=0;\n//         for(int i=0;i<n;i++){\n//             int val=Integer.parseInt(strs[i]);\n//             if(val==(i+1)){ans++;}\n//             else{hs.add(val);}\n//         }\n//         ans+=(hs.size()/2);\n//         System.out.println(ans);\n//     }\n// }\n\n\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n//         ArrayList<Integer> list=new ArrayList<>();\n\n//         if(n%4==0 || n%4==2){\n//             for(int i=1;i<=n;i++){\n//                 if(i%4==1 || i%4==0){\n//                    list.add(i); // System.out.print(i+\" \");\n//                 }\n//             }\n//         }else if(n%4==1){\n//             for(int i=1;i<=(1+(n/4));i++){\n//                 list.add(i);//System.out.print(i+\" \");\n//             }\n//             for(int i=((n-(n/4))+1);i<=(n);i++){\n//                 list.add(i);// System.out.print(i+\" \");\n//             }\n//         }else if(n%4==3){\n//             for(int i=1;i<=((n/4));i++){\n//                 list.add(i);// System.out.print(i+\" \");\n//             }\n//             for(int i=((n-(n/4)));i<=(n);i++){\n//                 list.add(i); //System.out.print(i+\" \");\n//             }\n//         }\n//         if(n%4==0 || n%4==3){System.out.println(0);}\n//         else{System.out.println(1);}\n        \n//         System.out.print(list.size()+\" \");\n//         for(int val:list){System.out.print(val+\" \");}\n//         System.out.println();\n//     }\n// }\n\n\n\n\n\n\n    // public static int find(int a,int[] p){\n    //     if(a!=p[a]){return p[a]=find(p[a], p);}\n    //     else{return a;}\n    // }\n    // public static int findrank(int a,int[] p,int [] r){\n    //     if(a!=p[a]){return findrank(p[a], p,r);}\n    //     else{return r[a];}\n    // }\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \t// int t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \t// while (t-- > 0) {\n    //         String[] str = (br.readLine()).trim().split(\" \");\n    //         int n = Integer.parseInt(str[0]);\n    //         int m=Integer.parseInt(str[1]);\n    //         int[] parent=new int[n+1];\n    //         int[] rank=new int[n+1];\n    //         for(int i=0;i<=n;i++){parent[i]=i; rank[i]=1;}\n\n    //         for(int i=0;i<m;i++){\n    //             str = (br.readLine()).trim().split(\" \");\n\n    //             int k=Integer.parseInt(str[0]);\n\n    //             for(int j=2;j<str.length;j++){\n    //                 int a=Integer.parseInt(str[j-1]);\n    //                 int b=Integer.parseInt(str[j]);\n    //                 int la=find(a, parent),lb=find(b, parent);\n    //                 if(la!=lb){\n    //                     if(rank[la]<rank[lb]){int tmp=la; la=lb; lb=tmp;}\n\n    //                     rank[la]+=rank[lb];\n    //                     parent[lb]=la;\n    //                 }\n    //             }\n    //         }\n\n    //         for(int i=1;i<=n;i++){\n    //             int ans=findrank(i,parent,rank);\n    //             System.out.print(ans+\" \");  //\" r=\"+rank[i]+\"  \"\n    //         }\n    //         System.out.println();\n    //     }\n    // }\n\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n//             String[] str = (br.readLine()).trim().split(\" \");\n//             int n = Integer.parseInt(str[0]);\n//             int m=Integer.parseInt(str[1]);\n//             int k = Integer.parseInt(str[2]);\n            \n//             int[][] arr=new int[m][3];\n\n//             for(int i=0;i<m;i++){\n//                 str = (br.readLine()).trim().split(\" \");\n//                 arr[i][0]=Integer.parseInt(str[0]);\n//                 arr[i][1]=Integer.parseInt(str[1]);\n//                 arr[i][2]=Integer.parseInt(str[2]);\n//             }\n            \n//             if(k==0){\n//                 System.out.println(-1); \n//                 return;\n//             }\n\n//             boolean[] flr=new boolean[n+1];\n//             str = (br.readLine()).trim().split(\" \");\n//             for(int i=0;i<k;i++){\n//                 int idx=Integer.parseInt(str[i]);\n//                 flr[idx]=true;\n//             }\n\n//             int ans=Integer.MAX_VALUE;\n\n//             for(int i=0;i<m;i++){\n//                 if((flr[arr[i][0]] && !flr[arr[i][1]]) || (!flr[arr[i][0]] && flr[arr[i][1]])){\n//                     ans=Math.min(ans,arr[i][2]);\n//                 }\n//             }\n\n//             if(ans==Integer.MAX_VALUE){\n//                 System.out.println(-1);\n//             }else{\n//                 System.out.println(ans);\n//             }\n//         // }\n//     }\n// }\n\n\n\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \tint t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \twhile (t-- > 0) {\n    //         int n = Integer.parseInt(br.readLine());\n    //         String str = (br.readLine()).trim();\n\n    //         int cw=0,acw=0,bh=0;\n    //         int ans=0;\n    //         for(int i=0;i<n;i++){\n    //             if(str.charAt(i)=='-'){\n    //                 if(str.charAt(((i-1)+n)%n)==str.charAt(i)){\n    //                     ans++;\n    //                 }else{\n    //                     ans+=2;\n    //                 }\n    //                 bh++;\n    //             }else if(str.charAt(i)=='>'){\n    //                 cw++;\n    //             }else{\n    //                 acw++;\n    //             }\n    //         }\n\n    //         if(acw==n || cw==n || bh==n){\n    //             System.out.println(n);\n    //         }else if((acw+bh)==n || (cw+bh)==n){\n    //             System.out.println(n);\n    //         }else{\n    //             System.out.println(ans);\n    //         }\n    //     }\n    //     }\n\n    // }\n\n\n//      public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n// \t\t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n//             int n = Integer.parseInt(arrp[0]);\n//             int m= Integer.parseInt(arrp[1]);\n            \n//             String[] str = (br.readLine()).trim().split(\" \");\n//             int[] cost=new int[n+1];\n//             for(int i=0;i<n;i++){\n//                 cost[i+1]=Integer.parseInt(str[i]);\n//             }\n//             long ans=0;\n//             for(int i=0;i<m;i++){\n//                 str = (br.readLine()).trim().split(\" \");\n\n//                 int u=Integer.parseInt(str[0]);\n//                 int v=Integer.parseInt(str[1]);\n//                 ans+=Math.min(cost[u],cost[v]);\n//             }\n\n//             System.out.println(ans);\n//         // }\n//     }\n// } \n    \n//     public static long binexp(long a,long b){\n//         long res=1;\n//         while(b>0){\n//             if((b&1)==1){\n//                 res=res*a;  res=res%mod;\n//             }\n//             a=a*a; a=a%mod;\n//             b>>=1;\n//         }\n//         return res;\n//     }\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n//         // StringBuilder sb = new StringBuilder();\n        \n//         long fact=1;\n//         for(int i=1;i<=n;i++){\n//             fact=((long)(fact*(long)(i)));\n//             fact=fact%mod;\n//         }\n\n//         long ump=binexp(2, n-1);//(long)(Math.pow(2, n-1));\n//         ump=ump%mod;\n//         long ans=fact-ump;\n//         if(ans<0){ans+=mod;}\n//         System.out.println(ans);\n//     }\n// }\n\n\n\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \t// int t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \t// while (t-- > 0) {\n\t// \t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n    //         int n = Integer.parseInt(arrp[0]);\n    //         int m= Integer.parseInt(arrp[1]);\n            \n    //         boolean[] invalid=new boolean[n+1];\n    //         for(int i=0;i<m;i++){\n    //             String[] pr = (br.readLine()).trim().split(\" \");\n    //             int val=Integer.parseInt(pr[0]);\n    //             invalid[val]=true;\n    //             val=Integer.parseInt(pr[1]);\n    //             invalid[val]=true;\n    //         }\n    //         int valid=-1;\n    //         for(int i=1;i<=n;i++){\n    //             if(!invalid[i]){valid=i; break;}\n    //         }            \n\n    //         System.out.println(n-1);\n    //         for(int i=1;i<=n;i++){\n    //             if(i!=valid){System.out.println(valid+\" \"+i);}\n    //         }\n    //     }\n    // }\n\n\n\n  //Q1  \n//     static int mcost=0;\n//     public static void dfs(ArrayList<ArrayList<Integer>> graph,int s,boolean[] visited,int[] cost){\n//         mcost=Math.min(mcost,cost[s-1]);\n//         visited[s]=true;\n//         for(int nbr:graph.get(s)){\n//             if(visited[nbr]==false){\n//                 dfs(graph,nbr,visited,cost);\n//             }\n//         }\n//     }\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n// \t\t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n//             int n = Integer.parseInt(arrp[0]);\n//             int m= Integer.parseInt(arrp[1]);\n            \n//             String[] strs = (br.readLine()).trim().split(\" \");\n//             int[] cost=new int[n];\n//             ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\n//             graph.add(new ArrayList<>());\n//             for(int i=0;i<n;i++){\n//                 cost[i]=Integer.parseInt(strs[i]);\n//                 graph.add(new ArrayList<>());\n//             }\n\n            \n//             for(int i=0;i<m;i++){\n//                 arrp = (br.readLine()).trim().split(\" \");\n//                 int u = Integer.parseInt(arrp[0]);\n//                 int v= Integer.parseInt(arrp[1]);\n\n//                 (graph.get(u)).add(v);\n//                 (graph.get(v)).add(u);\n//             }\n\n//             //dfs\n//             boolean[] visited=new boolean[n+1];\n//             long ans=0;\n//             for(int i=1;i<=n;i++){\n//                 if(visited[i]==false){\n//                     mcost=Integer.MAX_VALUE;\n//                     dfs(graph,i,visited,cost);\n//                     ans+=mcost;\n//                 }\n//             }\n\n//             System.out.println(ans);\n//         // }\n//     }\n// }\n\n\n"
        },
        {
            "language": 3,
            "solution": "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <19/Feb/2019 06:31:16 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n#\tQuestion Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\nN = 105\ngraph = [[] for _ in range(N)]\ncomponent = [0] * N\nvisited = [False] * N\n#cnt = 0\n#v = 0\n#n, m = 0, 0\n#ans = 0\n\n\ndef explore(node):\n    global cnt\n    visited[node] = True\n    component[node] = cnt\n    for neighbour, color in graph[node]:\n        if visited[neighbour] == False:\n            explore(neighbour)\n\n\ndef dfs(n):\n    global cnt\n    cnt = 0\n    for i in range(1, n + 1):\n        if visited[i] == False:\n            cnt += 1\n            explore(i)\n\n\ndef explore_o(node, c):\n    global ans, s\n    visited[node] = True\n    for neighbour, color in graph[node]:\n        if visited[neighbour] == False and color == c:\n            if neighbour == v:\n                s.add(color)\n            explore_o(neighbour, c)\n\n\ndef dfs_o(u):\n    global visited, ans, flag, s\n    ans = 0\n    s = set()\n    for neighbour, color in graph[u]:\n        visited = [False] * N\n        visited[u] = True\n        flag = 0\n        if neighbour == v:\n            s.add(color)\n            continue\n        explore_o(neighbour, color)\n    return len(s)\n\n\ndef main():\n    global n, m\n    n, m = get_ints()\n    for _ in range(m):\n        u, x, c = get_ints()\n        graph[u].append((x, c))\n        graph[x].append((u, c))\n    dfs(n)\n    global v\n    for tc in range(int(input())):\n        u, v = get_ints()\n        if component[u] != component[v]:\n            print(0)\n            continue\n        print(dfs_o(u))\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mxn = 233;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) f = c == '-' ? -1 : 1, c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long ksm(long long a, long long b, long long mod) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long inv2(long long a, long long mod) { return ksm(a, mod - 2, mod); }\nvoid exgcd(long long a, long long b, long long &x, long long &y, long long &d) {\n  if (!b) {\n    d = a;\n    x = 1;\n    y = 0;\n  } else {\n    exgcd(b, a % b, y, x, d);\n    y -= x * (a / b);\n  }\n}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint n, m, d[mxn][mxn][mxn];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  ;\n  cin >> n >> m;\n  int u, v, c;\n  for (int i = 1; i <= m; ++i) {\n    cin >> u >> v >> c;\n    d[c][v][u] = d[c][u][v] = 1;\n  }\n  for (int c = 1; c <= m; ++c)\n    for (int k = 1; k <= n; ++k)\n      for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n          d[c][i][j] = d[c][j][i] = max(d[c][i][j], d[c][i][k] & d[c][k][j]);\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> u >> v;\n    int res = 0;\n    for (int i = 1; i <= m; ++i)\n      if (d[i][u][v]) res++;\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\n\ndef dfs(start , color):\n\n    for i in g[start]:\n        if not vis[i[0]] and i[1] == color :\n            vis[i[0]] = True\n            dfs(i[0] , i[1])\n\n\n\nn , m = map(int,input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a , b , c = map(int,input().split())\n    g[a - 1].append((b - 1, c))\n    g[b-1].append((a-1 , c))\n\nq = int(input())\nres = [0]*q\nfor i in range(q):\n    u , v = map(int,input().split())\n\n    for j in range(1 , m + 1):\n        vis = [False] * n\n        dfs(u - 1  , j)\n        if vis[v - 1]:\n            res[i] +=1\n\n#print(res)\n\nfor i in res:\n    print(i)\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CodeforcesRound286 {\t\n\tstatic class ProblemB {\n\t\tstatic void Run() {\n\t\t\tIO.Initialization();\n\t\t\t\n\t\t\t\n\t\t\tSolve(IO.reader, IO.writer);\n\t\t\t\n\t\t\t\n\t\t\tIO.Close();\n\t\t}\n\t\t\n\t\tstatic class Graph {\n\t\t\tstatic int n, m;\n\t\t\tstatic LinkedList<AdjacencyList>[] graph = new LinkedList[101];\n\t\t\t\n\t\t\tstatic void Initialization() {\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tgraph[i] = new LinkedList();\n\t\t\t}\n\t\t\t\n\t\t\tstatic void Edge(int u, int v, int c) {\n\t\t\t\tAdjacencyList<Integer> Forward = new AdjacencyList(), Backward = new AdjacencyList();\n\t\t\t\tForward.v = v;\n\t\t\t\tForward.c = c;\n\t\t\t\tBackward.v = u;\n\t\t\t\tBackward.c = c;\n\t\t\t\tgraph[u].addLast(Forward);\n\t\t\t\tgraph[v].addLast(Backward);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tstatic class AdjacencyList<Integer> {\n\t\t\tint v, c;\n\t\t}\n\t\t\n\t        static int BFS(int s, int f) {\n\t        \tArrayDeque<Integer> Q = new ArrayDeque();\n\t                int res = 0;\n\t                int[][] id = new int[101][101];\n\t                for (AdjacencyList E : Graph.graph[s])\n\t                \tid[s][E.c] = 1;\n\t                \n\t                \n\t                Q.addLast(s);\n\t                \n\t                \n\t                while (!Q.isEmpty()) {\n\t                \tint u = (int)Q.pollFirst();\n\t                \tfor (AdjacencyList E : Graph.graph[u]) \n\t                \t\tif (id[E.v][E.c] == 0 && id[u][E.c] == 1) {\n\t                \t\t\tid[E.v][E.c] = 1;\n\t                \t\t\tQ.addLast(E.v);\n\t                \t\t}\n\t                }\n\t                \n\t                \n\t                for (int i = 1; i <= Graph.m; i++)\n\t                \tres += id[f][i];\n\t              \n\t                \n\t            \treturn res;\n\t        }\n\t        \n\t\tstatic int Query(int u, int v) {\n\t\t\treturn BFS(u, v);\n\t\t}\n                \n\t\tstatic void Solve(Scanner reader, PrintWriter writer) {\n\t\t\tGraph.n = reader.nextInt();\n\t\t\tGraph.m = reader.nextInt();\n\t\t\tGraph.Initialization();\n\t\t\tfor (int i = 0; i < Graph.m; i++) {\n\t\t\t\tint a = reader.nextInt(), b = reader.nextInt(), c = reader.nextInt();\n\t\t\t\tGraph.Edge(a, b, c);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t        \n\t\t\tint q = reader.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tint u = reader.nextInt(), v = reader.nextInt();\n\t\t\t\twriter.println(Query(u, v));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tProblemB.Run();\n\t}\n\t\n\tstatic class IO {\n\t\tstatic Scanner reader;\n\t\tstatic PrintWriter writer;\n\t\t\n\t\tstatic void Initialization() {\n\t\t\treader = new Scanner(System.in);\n\t\t\twriter = new PrintWriter(System.out);\n\t\t}\n\t\t\n\t\tstatic void Close() {\n\t\t\twriter.flush();\n\t\t}\n\t}\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n     \n     public static void main(String []args){\n            Scanner sc = new Scanner(System.in);\n            \n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            \n            DSU[] colors = new DSU[m + 1];\n            \n            for(int i = 1 ; i <= m ; i++){\n                colors[i] = new DSU(n+1);\n            }\n            for(int i = 1 ; i <= m; i++){\n               \n                int ai = sc.nextInt();\n                int bi = sc.nextInt();\n                int ci = sc.nextInt();\n                \n                DSU obj = colors[ci];\n                obj.unite(ai,bi);\n            \n                \n            }\n            \n            int q = sc.nextInt();\n            \n            while(q > 0){\n                \n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int res = 0;\n                \n                for(int i = 1 ; i <= m ; i++){\n                \n                    DSU curr = colors[i];\n                   \n                    if(curr.same(a,b)){\n                        res++;\n                    }\n                \n                \n                }\n                 System.out.println(res);\n                q--;\n            }\n            \n           \n      \n     }\n     \n     \n}\nclass DSU{\n    \n    int[] root;\n    int[] size;\n    \n    public DSU(int n){\n        root = new int[n];\n        Arrays.fill(root , -1);\n        size = new int[n];\n        Arrays.fill(size , 1);\n    }\n    \n    public int find(int x){\n        \n        if(root[x] == -1){\n            return x;\n        }\n        \n        return (root[x] = find(root[x]));\n    }\n    \n    public void unite(int a , int b){\n        \n        int rootA = find(a);\n        int rootB  = find(b);\n        \n        if(rootA == rootB){\n            return;\n            \n        }\n        \n        if(size[rootA] >= size[rootB]){\n            \n            root[rootB] = rootA;\n            size[rootA] += size[rootB];\n        }\n        else{\n            root[rootA] = rootB;\n            size[rootB] += size[rootA];\n        }\n        \n       \n    }\n    \n    public boolean same(int a , int b){\n        return find(a) == find(b);\n    }\n    \n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n}\n\nclass TaskD {\n\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t}\n\n}\n\nclass TaskA {\n\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tString str = in.next();\n\n\t\tfor (int i = 0; i <= str.length(); ++i) {\n\t\t\tfor (char ch = 'a'; ch <= 'z'; ++ch) {\n\n\t\t\t\tif (isPolindrome(append(str, i, ch))) {\n\t\t\t\t\tout.println(append(str, i, ch));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"NA\");\n\n\t}\n\n\tprivate boolean isPolindrome(String append) {\n\t\tint size = append.length();\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tif (size % 2 == 1) {\n\t\t\tl = size / 2;\n\t\t\tr = size / 2;\n\t\t} else {\n\t\t\tl = size / 2 - 1;\n\t\t\tr = size / 2;\n\t\t}\n\n\t\twhile (l >= 0) {\n\t\t\tif (append.charAt(l) != append.charAt(r)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tl--;\n\t\t\tr++;\n\t\t}\n\t\tif (l >= 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate String append(String str, int index, char ch) {\n\t\tif (index == str.length()) {\n\t\t\treturn str + ch;\n\t\t}\n\t\tchar[] nstr = new char[str.length() + 1];\n\t\tnstr[index] = ch;\n\t\tfor (int i = 0; i < index; ++i) {\n\t\t\tnstr[i] = str.charAt(i);\n\t\t}\n\n\t\tfor (int i = index + 1; i < nstr.length; ++i) {\n\t\t\tnstr[i] = str.charAt(i - 1);\n\t\t}\n\n\t\treturn new String(nstr);\n\t}\n\n}\n\nclass TaskB {\n\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out)\n\t\t\tthrows IOException {\n\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tList<Integer>[][] adj = new List[n][m];\n\t\tfor (int i = 0; i < n; ++i) {\t\t\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tadj[i][j] = new LinkedList<Integer>();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tint c = in.nextInt()-1;\n\t\t\tadj[u][c].add(v);\n\t\t\tadj[v][c].add(u);\n\n\t\t}\n\n\t\tint q = in.nextInt();\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tout.println(colors(adj, u, v));\n\t\t}\n\t}\n\n\tprivate int colors(List<Integer>[][] adj, int u, int v) {\n\t\tint result = 0;\n\n\t\tfor (int c = 0; c < adj[0].length; ++c) {\n\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\tSet<Integer> visited = new HashSet<Integer>();\n\t\t\tq.add(u);\n\t\t\tboolean breakIt = false;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tInteger current = q.poll();\n\t\t\t\tif(visited.contains(current)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (Integer neigh : adj[current][c]) {\n\t\t\t\t\tif (neigh == v) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t\tbreakIt = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tq.add(neigh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(breakIt){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvisited.add(current);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n\nclass Edge {\n\n\tint color;\n\tint index;\n\n\tpublic Edge(int color, int index) {\n\t\tsuper();\n\t\tthis.color = color;\n\t\tthis.index = index;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Edge [color=\" + color + \", index=\" + index + \"]\";\n\t}\n\n}\n\nclass TaskC {\n\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t}\n\n}\n\nclass InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool visited[100], colors[100];\nvector<vector<pair<int, int>>> adj_list(100);\nunordered_map<int, bool> M;\nint n, m, a, b, c;\nbool dfs(int start, int end, int color = -1) {\n  if (visited[start]) return 0;\n  if (start == end) return 1;\n  visited[start] = 1;\n  int len = adj_list[start].size();\n  int ans = 0;\n  for (int i = 0; i < len; i++) {\n    if (color == -1 || color == adj_list[start][i].second)\n      if (dfs(adj_list[start][i].first, end, adj_list[start][i].second))\n        M[adj_list[start][i].second] = 1;\n  }\n  visited[start] = 0;\n  return 0;\n}\nint main() {\n  memset(visited, 0, sizeof(visited));\n  memset(colors, 0, sizeof(colors));\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    a--;\n    b--;\n    c--;\n    adj_list[a].push_back({b, c});\n    adj_list[b].push_back({a, c});\n  }\n  cin >> c;\n  while (c--) {\n    cin >> a >> b;\n    a--;\n    b--;\n    dfs(a, b);\n    cout << M.size() << '\\n';\n    M.clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int Max = 1e5 + 5;\nconst long long IFN = 1e18 + 5;\ninline void norm(long long &a) {\n  a %= mod;\n  (a < 0) && (a += mod);\n}\ninline long long modAdd(long long a, long long b) {\n  a %= mod, b %= mod;\n  norm(a), norm(b);\n  return (a + b) % mod;\n}\ninline long long modSub(long long a, long long b) {\n  a %= mod, b %= mod;\n  norm(a), norm(b);\n  return (a - b) % mod;\n}\ninline long long modMul(long long a, long long b) {\n  a %= mod, b %= mod;\n  norm(a), norm(b);\n  return (a * b) % mod;\n}\nvoid F_I_O() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}\nbool ok = false;\nvector<bool> check(104, false);\nvector<pair<int, int> > v[102 + 1];\nbool dfs(int u, int r, int u1) {\n  check[u] = true;\n  if (u == u1) {\n    return true;\n  }\n  for (int i = 0; i < v[u].size(); i++) {\n    int c = v[u][i].first;\n    int d = v[u][i].second;\n    if (d == r && !check[c]) {\n      if (dfs(c, r, u1)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    int a, b, c;\n    for (int j = 0; j < m; j++) {\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      c--;\n      v[a].push_back(make_pair(b, c));\n      v[b].push_back(make_pair(a, c));\n    }\n    int q;\n    cin >> q;\n    int u, u1;\n    for (int i = 0; i < q; i++) {\n      cin >> u >> u1;\n      u--;\n      u1--;\n      ok = false;\n      int ans = 0;\n      for (int j = 0; j < 100; j++) {\n        for (int k = 0; k < 101; k++) {\n          check[k] = false;\n        }\n        if (dfs(u, j, u1)) {\n          ans++;\n        }\n      }\n      cout << ans << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = numeric_limits<int>::max();\nconst long long linf = numeric_limits<long long>::max();\nconst int max_n = 101;\nint n, m, q;\nbool g[max_n][max_n][max_n], visited[max_n];\nbool dfs(int st, int end, int col, int par = -1) {\n  if (st == end) return true;\n  if (visited[st]) return false;\n  visited[st] = true;\n  bool ret = false;\n  for (int i = 0; i < (max_n); ++i) {\n    if (g[st][i][col] && i != par) ret |= dfs(i, end, col, st);\n  }\n  return ret;\n}\nint main() {\n  int u, v, c;\n  cin >> n;\n  cin >> m;\n  for (int i = 0; i < (m); ++i) {\n    cin >> u, cin >> v, cin >> c;\n    g[u][v][c] = true;\n    g[v][u][c] = true;\n  }\n  cin >> q;\n  for (int i = 0; i < (q); ++i) {\n    cin >> u, cin >> v;\n    c = 0;\n    for (int j = (1); j < (m + 1); ++j) {\n      fill(visited, visited + max_n, false);\n      c += dfs(u, v, j);\n    }\n    cout << c << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n        static int c,s,dest,prev;\n        static ArrayList<pair>[] arr;\n        static boolean[] vis,colour;\n\n    public static void main(String[] args) throws IOException {\n        Scanner scanner = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        //============================================//\n        //answer here:\n        int n=scanner.nextInt(), m=scanner.nextInt();\n        arr=new ArrayList[n];\n        for (int i=0; i<n; i++) arr[i]=new ArrayList<>();\n        for (int i=0; i<m; i++){\n            int u=scanner.nextInt()-1, v=scanner.nextInt()-1, cost=scanner.nextInt();\n            arr[u].add(new pair(v,cost));\n            arr[v].add(new pair(u,cost));\n        }\n        int q=scanner.nextInt();\n        while (q-->0){\n            colour=new boolean[n+9];\n           s=scanner.nextInt()-1;\n           dest=scanner.nextInt()-1;\n           for (pair u: arr[s]){\n//               if (colour[u.cost]) continue;\n//               vis=new boolean[n];\n//               vis[s]=true;\n//               prev=u.cost;\n//               colour[u.cost]=true;\n//               dfs(u);\n               if (!colour[u.cost]){\n                   vis=new boolean[n];\n                   colour[u.cost]=true;\n                   dfs(s,dest,u.cost);\n\n               }\n           }\n           out.println(c);\n\n           c=0;\n        }\n\n        //=============================================//\n        out.close();\n    }\n    static void dfs(int s,int dest,int col){\n        vis[s]=true;\n        if (s==dest) {\n            c++;\n            return;\n        }\n        for (pair v: arr[s]){\n            if (!vis[v.to] && v.cost==col) {\n                dfs(v.to,dest,col);\n            }\n        }\n    }\n}\n\nclass Scanner {\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream system) {\n        br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public Scanner(String file) throws Exception {\n        br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n        return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n        return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n        Thread.sleep(3000);\n    }\n\n    int[] readArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}\n\nclass pair implements Comparable<pair> {\n    int to;\n    int cost;\n\n    public pair(int to, int cost) {\n        this.to=to;\n        this.cost=cost;\n    }\n\n    public int compareTo(pair o) {\n        return 0;\n    }\n    public String toString(){\n        return this.to+\" \"+this.cost;\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long Ceil(long long a, long long b) {\n  if (a % b == 0)\n    return a / b;\n  else\n    return a / b + 1;\n}\nlong long factorial(long long n) {\n  if (n == 0) return 1;\n  return (n * factorial(n - 1)) % 1000000007;\n}\nlong long isPalindrome(string &str) {\n  long long diff = 0;\n  long long j = str.length() - 1;\n  for (long long i = 0; i < j; i++, j--) {\n    if (str[i] != str[j]) {\n      diff++;\n    }\n  }\n  return diff;\n}\nvector<pair<long long, long long>> v[102];\nvector<bool> vis(102);\nbool dfs(long long src, long long target, long long col) {\n  vis[src] = true;\n  if (src == target) return true;\n  for (auto x : v[src]) {\n    if (vis[x.first] == false && x.second == col) {\n      if (dfs(x.first, target, col)) return true;\n    }\n  }\n  return false;\n}\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 0; i < m; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    v[b].push_back({a, c});\n  }\n  long long q;\n  cin >> q;\n  for (long long i = 0; i < q; i++) {\n    long long u, v;\n    cin >> u >> v;\n    long long ans = 0;\n    for (long long i = 1; i <= 100; i++) {\n      for (long long i = 0; i < 102; i++) vis[i] = false;\n      if (dfs(u, v, i)) ans++;\n    }\n    cout << ans << endl;\n  }\n}\nint32_t main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > g[110];\nint seen[110][110];\nint c[110];\nint ans;\nvoid dfs(int s, int end, int color) {\n  if (s == end && c[color] == 0) {\n    c[color] = 1;\n    ans++;\n    return;\n  }\n  for (int i = 0; i < (int)g[s].size(); i++) {\n    if ((color == 0 || color == g[s][i].second) &&\n        seen[s][g[s][i].first] == 0 && seen[g[s][i].first][s] == 0) {\n      seen[s][g[s][i].first] = 1;\n      seen[g[s][i].first][s] = 1;\n      dfs(g[s][i].first, end, g[s][i].second);\n      seen[s][g[s][i].first] = 0;\n      seen[g[s][i].first][s] = 0;\n    }\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  int temp1, temp2, temp3;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", &temp1, &temp2, &temp3);\n    g[temp1].push_back(pair<int, int>(temp2, temp3));\n    g[temp2].push_back(pair<int, int>(temp1, temp3));\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d %d\", &temp1, &temp2);\n    dfs(temp1, temp2, 0);\n    printf(\"%d\\n\", ans);\n    ans = 0;\n    for (int i = 0; i < 110; i++)\n      for (int j = 0; j < 110; j++) seen[i][j] = 0;\n    for (int i = 0; i < 110; i++) c[i] = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n/**\n * Created by \u041f\u0435\u0442\u0440\u0443\u0447\u0430 on 08.02.2015.\n */\npublic class Main {\n    public static void main(String[] args){\n        Task a=new Task();\n        a.solve();\n\n    }\n\n\n\n}\n\n\n\n\n\nclass Task{\n    public void solve(){\n     Scanner s=new Scanner(System.in);\n       int n=s.nextInt();\n       int m=s.nextInt();\n       int [][][] graph=new int [n][n][m];\n       for(int i=0;i<m;i++){\n           int a=s.nextInt()-1;\n           int b=s.nextInt()-1;\n           int color=s.nextInt()-1;\n           graph[a][b][color]=graph[b][a][color]=1;\n\n\n       }\n        int q=s.nextInt();\n\n        for(int j=0;j<q;j++){\n        int u=s.nextInt()-1;\n        int v=s.nextInt()-1;\n        int ans=0;\n            for(int k=0;k<m;k++){\n                int[] visited=new int [100];\n                dfs(u,k,graph,visited,n);\n                if(visited[v]==1) ans++;\n\n\n\n\n\n            }\n            System.out.println(ans);\n\n\n\n\n\n        }\n\n\n\n\n\n\n\n\n\n    }\n    public void dfs(int u,int color,int [][][] graph,int [] visited,int n){\n        visited[u]=1;\n        for(int i=0;i<n;i++){\n            if(graph[u][i][color]==1 && visited[i]!=1){\n                dfs(i,color,graph,visited,n);\n\n            }\n        }\n\n\n    }\n\n\n\n\n\n\n\n\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nimport os\nfrom io import BytesIO, IOBase\nimport sys\n\n# region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict\n\n\nn, m = map(int, input().split())\ngraphs = defaultdict(lambda : defaultdict(list))\nfor _ in range(m):\n    a,b,c = map(int, input().split())\n    graphs[c][a].append(b)\n    graphs[c][b].append(a)\n\nseen = set()\ndef dfs(curr, orig, color):\n    if curr in seen:\n        return\n    seen.add(curr)\n    for new in graphs[color][curr]:\n        if new != orig:\n            dfs(new, curr, color)\n\nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n    found = 0\n    for c in graphs.keys():\n        seen.clear()\n        dfs(a,-1,c)\n        if b in seen:\n            found += 1\n\n    print(found)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> arr[100][100];\nbool colored_dfs(int u, int v, int c, vector<vector<int> > &adj,\n                 vector<bool> &visited) {\n  bool success = false;\n  if (u == v) return true;\n  for (int n : adj[u]) {\n    for (int color : arr[u][n]) {\n      if ((color == c) && (!visited[n])) {\n        visited[n] = true;\n        success = colored_dfs(n, v, c, adj, visited);\n        if (success) return true;\n      }\n    }\n  }\n  return success;\n}\nint dfs(int u, int v, vector<vector<int> > &adj) {\n  int ans = 0;\n  vector<bool> visited;\n  vector<bool> color_used(101, false);\n  for (int n : adj[u]) {\n    for (int c : arr[u][n]) {\n      if (color_used[c]) continue;\n      visited.resize(adj.size());\n      visited[u] = true;\n      visited[n] = true;\n      if (colored_dfs(n, v, c, adj, visited)) {\n        ans++;\n        color_used[c] = true;\n      }\n      visited.clear();\n    }\n  }\n  return ans;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int> > adj(n, vector<int>());\n  int a, b, c;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    a--;\n    b--;\n    arr[a][b].push_back(c);\n    arr[b][a].push_back(c);\n    int flag = 0;\n    for (int i : adj[a]) {\n      if (i == b) {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag) continue;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  int q;\n  cin >> q;\n  vector<int> ans(q, 0);\n  for (int i = 0; i < q; i++) {\n    cin >> a >> b;\n    a--;\n    b--;\n    ans[i] = dfs(a, b, adj);\n  }\n  for (int i : ans) cout << i << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//coderadi\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class A {\n\tstatic ArrayList<ArrayList<Edge>> a;\n\tstatic boolean[] vis;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\ta = new ArrayList<ArrayList<Edge>>(n+1);\n\t\tfor(int i=0; i<n+1; i++)a.add(new ArrayList<Edge>());\n\t\tint m = sc.nextInt();\n\t\tint mm = m;\n\t\twhile(mm-- > 0){\n\t\t\tint u = sc.nextInt(), v = sc.nextInt(), c = sc.nextInt();\n\t\t\ta.get(u).add(new Edge(v, c));\n\t\t\ta.get(v).add(new Edge(u, c));\n\t\t}\n\n\t\tint q = sc.nextInt();\n\t\twhile(q-- > 0){\n\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\tint ans = 0;\n\t\t\tfor(int i=1; i<=m; i++){\n\t\t\t\tvis = new boolean[n+1];\n\t\t\t\tif(dfs(a, b, i))\n\t\t\t\t\tans++;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic boolean dfs(int s, int t, int c){\n\t\tif(s == t)\n\t\t\treturn true;\n\t\tvis[s] = true;\n\t\tIterator<Edge> it = a.get(s).iterator();\n\t\twhile(it.hasNext()){\n\t\t\tEdge temp = it.next();\n\t\t\tif(temp.c == c && !vis[temp.v]){\n\t\t\t\tboolean flag = dfs(temp.v, t, c);\n\t\t\t\tif(flag)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n\nclass Edge{\n\tint v, c;\n\tEdge(int v, int c){\n\t\tthis.v = v; this.c = c;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\n\ndef main():\n    n, m = map(int, input().split())\n    edges = defaultdict(lambda: defaultdict(list))\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        d = edges[c]\n        d[a].append(b)\n        d[b].append(a)\n\n    def dfs(t):\n        chain.add(t)\n        dd = color.get(t, ())\n        for y in dd:\n            if y not in chain:\n                dfs(y)\n\n    res = []\n    chain = set()\n    for _ in range(int(input())):\n        a, b = map(int, input().split())\n        x = 0\n        for color in edges.values():\n            chain.clear()\n            dfs(a)\n            if b in chain:\n                x += 1\n        res.append(str(x))\n    print('\\n'.join(res))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 1,
            "solution": "# here we go\nnvertices, nedges = map(int,raw_input().split())\nmatrix = [[[] for j in xrange(nvertices+1)] for x in xrange(nvertices+1)]\nvisitados = []\n\ndef visita(r, t,cor):\n\tif r == t:\n\t\tif cor not in colors: colors.append(cor)\n\tif r in visitados:\n\t\treturn False\n\telse: visitados.append(r)\n\tfor i in range(1,nvertices+1):\n\t\tif len(matrix[r][i]) >0:\n\t\t\tif cor in matrix[r][i]:\n\t\t\t\tvisita(i,t,cor)\t\t\t\n\t\t\t\nfor i in xrange(nedges):\n\ta,b,c = map(int,raw_input().split())\n\tif c not in matrix[a][b]:\n\t\tmatrix[a][b].append(c)\n\t\tmatrix[b][a].append(c)\n\t\t\nq= int(raw_input())\nfor i in xrange(q):\n\tcolors = []\n\tu,v = map(int,raw_input().split())\n\tfor kor in range(1,101):\n\t\tvisitados = []\n\t\tvisita(u,v,kor)\n\tprint len(colors)\n\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint par[105][105];\nint sz[105][105];\nint getpar(int x, int c) {\n  if (par[c][x] == x) {\n    return x;\n  }\n  return par[c][x] = getpar(par[c][x], c);\n}\nvoid dsu(int a, int b, int c) {\n  a = getpar(a, c);\n  b = getpar(b, c);\n  if (a == b) {\n    return;\n  }\n  if (sz[c][a] < sz[c][b]) {\n    swap(a, b);\n  }\n  par[c][b] = a;\n  sz[c][a] += sz[c][b];\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < 105; i++) {\n    for (int j = 0; j < 105; j++) {\n      par[i][j] = j;\n      sz[i][j] = 1;\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    dsu(a, b, c);\n  }\n  int k;\n  cin >> k;\n  for (int i = 0; i < k; i++) {\n    int a, b;\n    cin >> a >> b;\n    int ans = 0;\n    int x, y;\n    for (int j = 0; j < 105; j++) {\n      x = getpar(a, j);\n      y = getpar(b, j);\n      if (x == y) {\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic long mod = (long) (1e9+7);\n    static final long N = (long) (1e15);\n   \n\tpublic static void main(String[] args) {\n\t\tFastReader sc = new FastReader();\n\t\t\n\t\t  int n = sc.nextInt();\n\t\t  int m = sc.nextInt();\n\t\t  DJSet[] dsu = new DJSet[m+1];\n\t\t  for(int i=0;i<=m;++i) dsu[i] = new DJSet(n+1);\n\t\t  for(int i=1;i<=m;++i) {\n\t\t\t  int u = sc.nextInt();\n\t\t\t  int v = sc.nextInt();\n\t\t\t  int c = sc.nextInt();\n\t\t\t  dsu[c].union(u, v);\n\t\t  }\n\t\t  \n\t\t  int q = sc.nextInt();\n\t\t  while(q-->0) {\n\t\t\t  int ans = 0;\n\t\t\t  int u = sc.nextInt();\n\t\t\t  int v = sc.nextInt();\n\t\t\t  for(int i=1;i<=m;++i) {\n\t\t\t\t  if(dsu[i].find(u) == dsu[i].find(v)) ++ans;\n\t\t\t  }\n\t\t\t  out.println(ans);\n\t\t  }\n\t\t   out.close();\t\t\t\n\t\t}\n\n\tstatic class DJSet\n\t{ \n\t    int[] rank, parent; \n\t    int n; \n\t  \n\t    // Constructor \n\t    public DJSet(int n) \n\t    { \n\t        rank = new int[n]; \n\t        parent = new int[n]; \n\t        this.n = n; \n\t        makeSet(); \n\t    } \n\t  \n\t    // Creates n sets with single item in each \n\t    void makeSet() \n\t    { \n\t        for (int i=0; i<n; i++) \n\t        { \n\t            // Initially, all elements are in \n\t            // their own set. \n\t            parent[i] = i; \n\t        } \n\t    } \n\t  \n\t    \n\t    int find(int x) \n\t    { \n\t        \n\t        if (parent[x]!=x) \n\t        { \n\t             \n\t            parent[x] = find(parent[x]); \n\t  \n\t           \n\t        } \n\t  \n\t        return parent[x]; \n\t    } \n\t  \n\t    \n\t    void union(int x, int y) \n\t    { \n\t       \n\t        int xRoot = find(x), yRoot = find(y); \n\t  \n\t        \n\t        if (xRoot == yRoot) \n\t            return; \n\t  \n\t        \n\t        if (rank[xRoot] < rank[yRoot]) \n\t  \n\t          \n\t            parent[xRoot] = yRoot; \n\t  \n\t      \n\t        else if (rank[yRoot] < rank[xRoot]) \n\t   \n\t            parent[yRoot] = xRoot; \n\t  \n\t        else \n\t        { \n\t           \n\t            parent[yRoot] = xRoot; \n\t  \n\t            rank[xRoot] = rank[xRoot] + 1; \n\t        } \n\t    } \n\t} \n\t}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\ndef color_path(graph, n, m, u, v, c):\n    # 1 if there is a path form u to v\n    # where all the edges have color c.\n    # 0 otherwise.\n    stack = [u]\n    visited = [False] * (n + 1)\n    while len(stack) > 0:\n        x = stack.pop()\n        visited[x] = True\n        for y, cy in graph[x]:\n            if not visited[y] and cy == c:\n                stack.append(y)\n        if x == v:\n            return 1\n    return 0\n\nn, m = map(int, input().split())\n\ngraph = defaultdict(list)\ncolors = set()\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n    colors.add(c)\n\nfor _ in range(int(input())):\n    u, v = map(int, input().split())\n    total = 0\n    for c in colors:\n        total += color_path(graph, n, m, u, v, c)\n    print(total)"
        },
        {
            "language": 3,
            "solution": "# aadiupadhyay\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\ndef st(): return list(sys.stdin.readline().strip())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef mp(): return map(int, sys.stdin.readline().split())\ndef inp(): return int(sys.stdin.readline())\ndef pr(n): return sys.stdout.write(str(n)+\"\\n\")\ndef prl(n): return sys.stdout.write(str(n)+\" \")\n\n\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\nn, m = mp()\nd = defaultdict(list)\nfor _ in range(m):\n    a, b, c = mp()\n    d[(a, c)].append(b)\n    d[(b, c)].append(a)\nQ = inp()\nv = [0 for i in range(n+1)]\nfor i in range(Q):\n    x, y = mp()\n    ans = 0\n    for j in range(1, m+1):\n        q = deque()\n        q.append((x, j))\n        copy_visited = list(v)\n        copy_visited[x] = 1\n        while q:\n            a, b = q.popleft()\n            if a == y:\n                ans += 1\n                break\n            for k in d[(a, b)]:\n                if not copy_visited[k]:\n                    copy_visited[k] = 1\n                    q.append((k, b))\n    print(ans)\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter as cntr\nfrom math import inf\ndef cin():\n\treturn map(int, input().split(' '))\ndef dfs(graph, src, dest, color):\n\tglobal count, visited\n\tif src == dest:\n\t\tcount += 1\n\n\t\treturn 0\n\tfor v in range(n):\n\t\tif graph[src][v] and visited[v]==False and color in graph[src][v]:\n\t\t\tl = graph[src][v]\n\n\t\t\tfor j in l:\n\t\t\t\tif color == j:\n\t\t\t\t\tvisited[v] = True\n\t\t\t\t\t\n\t\t\t\t\tdfs(graph, v, dest, color)\nn, m = cin()\nkita = [[0 for i in range(n)] for i in range(n)]\nclrs = [[]for i in range(n)]\nfor i in range(m):\n\ta, b, c = cin()\n\ta -= 1\n\tb -= 1\n\tif kita[a][b] == 0:\n\t\tkita[a][b] = [c]\n\t\tkita[b][a] = [c]\n\telse:\n\t\tkita[a][b].append(c)\n\t\tkita[b][a].append(c)\n\tclrs[a].append(c)\n\tclrs[b].append(c)\nq = int(input())\nfor i in range(q):\n\tcount = 0\n\tu,v = cin()\n\tu -= 1\n\tv -= 1\n\tll = set(clrs[u])\n\t#print(ll)\n\tfor jj in ll:\n\t\tvisited = [False for i in range(n)]\n\t\tvisited[u] = True\n\t\tdfs(kita, u, v, jj)\n\t\t\n\n\n\tprint(count)\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[2000005] = {0};\nvoid factorial() {\n  fac[0] = 1;\n  fac[1] = 1;\n  for (long long i = 2; i < 200005; i++)\n    fac[i] = ((i % 1000000007) * (fac[i - 1] % 1000000007)) % 1000000007;\n}\nlong long power(long long n, long long m) {\n  long long p = 1;\n  if (m == 0) return 1;\n  p = (power(n, m / 2) % 1000000007);\n  p = (p % 1000000007 * p % 1000000007) % 1000000007;\n  return (m & 1 ? ((p % 1000000007 * n % 1000000007) % 1000000007)\n                : (p % 1000000007));\n}\nlong long ncr(long long n, long long r) {\n  return ((fac[n] * power(fac[r], 1000000007 - 2)) % 1000000007 *\n          power(fac[n - r], 1000000007 - 2)) %\n         1000000007;\n}\nvector<pair<long long, long long> > graph[102];\nlong long n, m;\nlong long cnt = 0;\nvoid dfs(long long x, long long y, long long col) {\n  long long used[102] = {0};\n  queue<long long> q;\n  q.push(x);\n  used[x] = 1;\n  while (!q.empty()) {\n    long long z = q.front();\n    q.pop();\n    for (long long i = 0; i < graph[z].size(); i++) {\n      pair<long long, long long> p = graph[z][i];\n      if (!used[p.first]) {\n        if (p.first == y && p.second == col) {\n          ++cnt;\n          return;\n        }\n        if (p.second == col) {\n          q.push(p.first);\n          used[p.first] = 1;\n        }\n      }\n    }\n  }\n}\nvoid ram5564() {\n  cin >> n >> m;\n  while (m--) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    graph[a].push_back(make_pair(b, c));\n    graph[b].push_back(make_pair(a, c));\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    long long x, y;\n    cin >> x >> y;\n    cnt = 0;\n    for (long long i = 1; i < 101; i++) {\n      dfs(x, y, i);\n    }\n    cout << cnt << \"\\n\";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) ram5564();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static Node[]list=new Node[101];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlist[i]=new Node();\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint u=in.nextInt()-1;\n\t\t\tint v=in.nextInt()-1;\n\t\t\tint c=in.nextInt();\n\t\t\t\n\t\t\tlist[u].colors.add(c);\n\t\t\tlist[u].sosedi.add(v);\n\t\t\t\n\t\t\tlist[v].colors.add(c);\n\t\t\tlist[v].sosedi.add(u);\n\t\t}\n\t\tint q=in.nextInt();\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint a=in.nextInt()-1;\n\t\t\tint b=in.nextInt()-1;\n\t\t\tSystem.out.println(BFS(a,b));\n\t\t}\n\n\t}\n\tpublic static int BFS(int a,int b)\n\t{\n\t\tint res=0;\n\t\tQueue<pole> q=new LinkedList<pole>();\n\t\tboolean[][]visited=new boolean[102][102];\n\t\tboolean v[]=new boolean[102];\n\t\tArrays.fill(v, false);\n\t\t\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++)\n\t\t\t\tvisited[i][j]=false;\n\t\tfor(int i=0;i<list[a].sosedi.size();i++)\n\t\t{\n\t\t\tq.add(new pole(list[a].sosedi.get(i),list[a].colors.get(i)));\n\t\t}\n\t\t\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tpole tmp=q.poll();\n\t\t\t\n\t\t\tif(visited[tmp.x][tmp.c]) continue;\n\t\t\tif(v[tmp.c]) continue;\n\t\t\tvisited[tmp.x][tmp.c]=true;\n\t\t\tif(tmp.x==b)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t\tv[tmp.c]=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<list[tmp.x].sosedi.size();i++)\n\t\t\t{\n\t\t\t\tif(list[tmp.x].colors.get(i)==tmp.c)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tq.add(new pole(list[tmp.x].sosedi.get(i),list[tmp.x].colors.get(i)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\nclass pole\n{\n\tpublic int x;\n\tpublic int c;\n\tpublic pole(int x,int c)\n\t{\n\t\tthis.x=x;\n\t\tthis.c=c;\n\t}\n}\nclass Node\n{\n\tpublic ArrayList<Integer> colors;\n\tpublic ArrayList<Integer> sosedi;\n\tpublic Node()\n\t{\n\t\tsosedi=new ArrayList<Integer>();\n\t\tcolors=new ArrayList<Integer>();\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[][][] color = new int[n + 1][n + 1][m + 1];\n        int[][] d = new int[n + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            color[a][b][c] = 1;\n            color[b][a][c] = 1;\n            d[a][b]++;\n            d[b][a]++;\n        }\n\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                if (i == k)\n                    continue;\n                for (int j = 1; j <= n; j++) {\n                    if (k == j)\n                        continue;\n                    for (int l = 1; l < m; l++) {\n                        if (color[i][k][l] == 1 && color[k][j][l] == 1 && color[i][j][l] == 0 && color[j][i][l] == 0) {\n                            d[i][j]++;\n                            d[j][i]++;\n                            color[i][j][l] = 1;\n                            color[j][i][l] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        int q = in.nextInt();\n\n        for (int i = 0; i < q; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            out.println(d[x][y]);\n        }\n\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\ndef dfs(node,b,graph,colour,vis):\n    if node==b:\n        return True\n    vis[node] = True\n    for i in graph[node]:\n        if not vis[i[0]]:\n            if i[1]==colour:\n                if dfs(i[0],b,graph,i[1],vis):\n                    return True\n    return False\nn,m = map(int,input().split())\ngraph = defaultdict(list)\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    graph[a].append([b,c])\n    graph[b].append([a,c])\nq = int(input())\nvisited = [False]*(n+1)\nfor i in range(q):\n    a,b = map(int,input().split())\n    ans = 0\n    for i in range(101):\n        vis = visited[:]\n        if dfs(a,b,graph,i,vis):\n            ans+=1\n    print(ans)\n        \n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Ques2{\n    static ArrayList []a;\n    static ArrayList []temp;\n    \n    static boolean []v;\n    static int []color=new int[101];\n    //static int temp[][]=new int[101][101];\n    public static void dfs(int i,int clr){\n                \n        v[i]=true;\n        //System.out.println(v[i]+\"\\t\"+i);\n        for(int j=0;j<a[i].size();j++){\n            int t=(Integer)a[i].get(j);\n            //System.out.println(t);\n            for(int k=0;k<temp[i].size();k++)\n                 {\n                    int xx=(Integer)temp[i].get(j);\n                    if(!v[t] && xx==clr)\n                      dfs(t,clr);\n                  }\n            \n\n        }\n    \n\n\n    }\n\n    public static void main(String[] args){\n        Scanner s=new Scanner(System.in);\n        int n=s.nextInt();\n        int m=s.nextInt();\n        a=new ArrayList [n];\n        for(int i=0;i<a.length;i++)\n            a[i]=new ArrayList<Integer>();\n           \n            temp=new ArrayList [101];  \n        for(int i=0;i<101;i++)\n            temp[i]=new ArrayList<Integer>();    \n        \n        \n        for(int i=0;i<m;i++)\n        {\n            int x=s.nextInt();\n            int y=s.nextInt();\n            int c=s.nextInt();\n            a[x-1].add(y-1);\n            a[y-1].add(x-1);\n            color[c]=1;\n            temp[x-1].add(c);\n            temp[y-1].add(c);\n            //temp[y-1][x-1]=c;\n        }\n\n        v=new boolean[n];\n        int test=s.nextInt();\n        for(int query=1;query<=test;query++){\n        int u=s.nextInt()-1;\n        int v1=s.nextInt()-1;\n        int ans=0;\n        for(int j=0;j<101;j++){\n        //for(int i=0;i<a.length;i++){\n           \n            if (color[j]==1)\n                           {\n                             dfs(u,j);\n                               if (v[v1])\n                               {\n                                  ans=ans+1;\n                                  //System.out.println(\"saurabh\"+j);\n                                  \n                                  \n                                  }\n                                  for (int k=0; k<n; k++)\n                                       v[k]=false;          \n                               \n                            }\n             //}\n             \n               }\n           System.out.println(ans);\n}\n        \n\n    }\n\n\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\ndef dfs(x,y,z):\n\tif x==y:return True\n\tg[x]=1\n\tfor p in cl[x]:\n\t\tif p[1]==z and g[p[0]]==0 and dfs(p[0],y,z):return True\n\treturn False\nn,m=R()\ncl=[[] for i in range(n)]\nfor i in range(m):\n\ta,b,c=R()\n\tcl[a-1].append([b-1,c-1])\n\tcl[b-1].append([a-1,c-1])\nq=I()\ns=[0]*q\nfor i in range(q):\n\tu,v=R()\n\tfor j in range(100):\n\t\tg=[0]*(n)\n\t\tif dfs(u-1,v-1,j):s[i]+=1\nfor i in s:print(i)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int>> adj[101];\nbool vis[101] = {false};\nbool check = false;\nbool dfs(int node, int vi, int color) {\n  vis[node] = true;\n  if (node == vi) {\n    return true;\n  }\n  for (auto childnode : adj[node]) {\n    if (!vis[childnode.first] && childnode.second == color) {\n      if (dfs(childnode.first, vi, color)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  long long nodes, edges;\n  cin >> nodes >> edges;\n  long long ans = 0;\n  for (int i = 0; i < edges; i++) {\n    long long f, s, t;\n    cin >> f >> s >> t;\n    adj[f].push_back({s, t});\n    adj[s].push_back({f, t});\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int ui, vi;\n    cin >> ui >> vi;\n    int ans = 0;\n    for (int j = 1; j <= edges; j++) {\n      memset(vis, false, sizeof(vis));\n      ans += dfs(ui, vi, j);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n\n\npublic class Main {\n    static Scanner input = new Scanner(System.in);\n    final static double EPS = 1e-8;\n    static char[][] arr1;\n    static ArrayList<ArrayList<Pair>> graph;\n    static boolean[] vis;\n    static int n; \n    static int m; \n    static ArrayList<Integer> lengths;\n    static Stack<Integer> s = new Stack<>();\n    static ArrayList<Integer> topo;\n    static int count;\n    static int arr[];\n    static char[] charArr;\n    static String word;\n    static int[] d;\n \n    public static class Pair{\n    \tint x;\n    \tint y;\n    \t\n    \tpublic Pair(int x, int y) {\n    \t\tthis.x = x;\n    \t\tthis.y = y;\n\t\t}\n    \t@Override\n    \tpublic String toString() {\n    \t\treturn \"(\" + x + \", \" + y + \")\";\n    \t}\n    } \n    \n  \n    \n    //throws Throwable {\n\t//Scanner input = new Scanner(new FileReader(\"input.txt\"));\n\t//PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\t\n\n    public static boolean dfs(Pair start, int target, int color) {\n    \tint node = start.x;\n    \tint nodeColor = start.y;\n    \t\n    \tif (nodeColor != -1 && (vis[node] || nodeColor != color))\n    \t\treturn false;\n    \tif (node == target)\n    \t\treturn true;\n    \t\n    \tvis[node] = true;\n    \t\n    \tArrayList<Pair> children = graph.get(node);\n\n    \tfor (int i = 0; i < children.size(); i++) {\n    \t\tPair child = children.get(i);\n    \t\t\n    \t\tif (!vis[child.x]) \n    \t\t\tif (dfs(child, target, color))\n    \t\t\t\treturn true;\n    \t}\n    \t\n    \treturn false;\t\n    }\n    \n   \n    public static void main(String[] args) {\n    \t\n    \t/*\n    \tArrayList <HashSet<Integer>> graph = new ArrayList<HashSet<Integer>>(m);\n    \tfor (int i = 0; i < m; i++)\n    \t\tgraph.add(new HashSet<Integer>());\n    \t\n    \tfor (int i = 0; i < m; i++) {\n    \t\tint a = input.nextInt();\n    \t\tint b = input.nextInt();\n    \t\tint c = input.nextInt() - 1;\n    \t\t\n    \t\tHashSet<Integer> h = graph.get(c);\n    \t\t\n    \t\th.add(a);\n    \t\th.add(b);\n    \t}\n    \n    \t\n    \tint q = input.nextInt();\n    \t\n    \tfor (int i = 0; i < q; i++) {\n    \t\tint u = input.nextInt();\n    \t\tint v = input.nextInt();\n    \t\t\n    \t\tint count = 0;\n    \t\t\n    \t\tfor (int j = 0; j < m; j++) {\n        \t\tHashSet<Integer> h = graph.get(j);\n        \t\tif (h.contains(u) && h.contains(v))\n        \t\t\tcount++;\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(count);\t\n    \t}\n    \t\n    \t\n    \t\n   */\n    \tint n = input.nextInt();\n    \tint m = input.nextInt();\n    \t\n    \tgraph = new ArrayList<ArrayList<Pair>>(n + 1);\n    \t\n    \tfor (int i = 0; i < n + 1; i++)\n    \t\tgraph.add(new ArrayList<Pair>());\n    \t//System.out.println(graph);\n    \t\n    \tfor (int i = 0; i < m; i++) {\n    \t\tint a = input.nextInt();\n    \t\tint b = input.nextInt();\n    \t\tint c = input.nextInt();\n    \t\t\n    \t\tgraph.get(a).add(new Pair(b, c));\n    \t\tgraph.get(b).add(new Pair(a, c));\n    \t}\n    \t//System.out.println(graph);\n\n    \t\n    \t\n    \tint q = input.nextInt();\n    \t\n    \tfor (int i = 0; i < q; i++) {\n    \t\tint u = input.nextInt();\n    \t\tint v = input.nextInt();\n    \t\t\n    \t\tvis = new boolean[n + 1];\n    \t\tint count = 0;\n    \t\tfor (int j = 0; j <= m; j++) {\n    \t\t\n    \t\t\tif (dfs(new Pair(u, -1), v, j))\n    \t\t\t\tcount++;\n    \t\t\t\n    \t\t\tArrays.fill(vis, false);\n    \t\t}\n    \t\tSystem.out.println(count);\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n  \t\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class cf3 implements Runnable {\n\t\n\tlong gcd(long a,long b)\n    {\n    \tif(a==0)\n    \t\treturn b;\n    \telse\n    \t\treturn gcd(b%a,a);\n    }\n\tclass ed{\n\t\t\n\t\tint v;\n\t\tint c;\n\t\t\n\t\ted(int a,int b)\n\t\t{\n\t\t\tv=a;\n\t\t\tc=b;\n\t\t}\n\t}\n\t\n\tint[] vis;\n\tArrayList<ed> al[];\n\tint cnt=0;\n\tint dest=0;\n\t\n\tvoid dfs(int x,int col)\n\t{\n\t\tvis[x]=1;\n\t\tif(x==dest)\n\t\t{\n\t\t\tcnt=1;\n\t\t\tvis[x]=0;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<al[x].size();i++)\n\t\t{\n\t\t\ted e=al[x].get(i);\n\t\t\tif(e.c==col && vis[e.v]==0)\n\t\t\t\tdfs(e.v,e.c);\n\t\t}\n\t}\n\tpublic void run(){\n\t\tInputReader in =  new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\t\n\t\tal=new ArrayList[n+1];\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tal[i]=new ArrayList<ed>();\n\t\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x=in.nextInt();\n\t\t\tint y=in.nextInt();\n\t\t\tint col=in.nextInt();\n\t\t\tal[x].add(new ed(y,col));\n\t\t\tal[y].add(new ed(x,col));\n\t\t}\n\t\t\n\t\tint q=in.nextInt();\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint x=in.nextInt();\n\t\t\tint y=in.nextInt();\n\t\t\tdest=y;\n\t\t\tint tcount=0;\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tvis=new int[n+1];\n\t\t\t\tcnt=0;\n\t\t\t\tdfs(x,j);\n\t\t\t\t//w.println(x+\" \"+y+\" \"+j+\" \"+cnt);\n\t\t\t\ttcount+=cnt;\n\t\t\t}\n\t\t\t\n\t\t\tw.println(tcount);\n\t\t}\n\t\tw.close();\n\t\t\t\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf3(),\"cf3\",1<<26).start();\n\t}\n }   \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nconst int maxn = 120;\nvector<pair<int, int> > e[maxn];\nint ans, vis[maxn], flag, book[maxn];\nvoid dfs(int second, int t, int cur) {\n  if (flag) return;\n  if (second == t) {\n    ans++;\n    flag = 1;\n    return;\n  }\n  for (auto i : e[second]) {\n    if (vis[i.first] || i.second != cur) continue;\n    vis[i.first] = 1;\n    dfs(i.first, t, cur);\n    vis[i.first] = 0;\n  }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  int x, y, z;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y >> z;\n    e[x].push_back({y, z});\n    e[y].push_back({x, z});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    ans = 0;\n    cin >> x >> y;\n    memset(book, 0, sizeof(book));\n    for (auto i : e[x]) {\n      if (book[i.second]) continue;\n      book[i.second] = 1;\n      flag = 0;\n      memset(vis, 0, sizeof(vis));\n      vis[x] = 1;\n      dfs(x, y, i.second);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# 505B\nfrom collections import defaultdict\n\n__author__ = 'artyom'\n\nread = lambda: map(int, input().split())\nall_edges = defaultdict(list)\nn, m = read()\nfor _ in range(m):\n  a, b, c = read()\n  all_edges[c].append((a, b))\n\ngraphs = []\n\n\ndef root(components, x, l=0):\n  return (x, l) if components[x] == x else root(components, components[x], l + 1)\n\n\ndef connected_components(edges):\n  components = [i for i in range(n + 1)]\n  for u, v in edges:\n    ru, lu = root(components, u)\n    rv, lv = root(components, v)\n    if ru != rv:\n      if lu < lv:\n        components[ru] = rv\n      else:\n        components[rv] = ru\n  return components\n\n\nfor c, edges in all_edges.items():\n  graphs.append(connected_components(edges))\n\n\ndef count_in_same_component(u, v):\n  count = 0\n  for graph in graphs:\n    if root(graph, u)[0] == root(graph, v)[0]:\n      count += 1\n  return count\n\n\nans = ''\nfor __ in range(int(input())):\n  u, v = read()\n  ans += str(count_in_same_component(u, v)) + '\\n'\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "class Union:\n\n    def __init__(self, size):\n        self.ancestor = [i for i in range(size+1)]\n\n    def find(self, node):\n\n        if self.ancestor[node] == node:\n            return node\n\n        self.ancestor[node] = self.find(self.ancestor[node])\n        return self.ancestor[node]\n\n    def merge(self, a, b):\n        a, b = self.find(a), self.find(b)\n        self.ancestor[a] = b\n\n\nn, m = map(int, input().split())\nunions = [Union(n) for _ in range(m+1)]\ngraph = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n    unions[c].merge(a, b)\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    ans = 0\n    for i in range(1, m+1):\n        ans += unions[i].find(a) == unions[i].find(b)\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int num, pre;\n  Node(int _num = 0, int _pre = 0) {\n    num = _num;\n    pre = _pre;\n  }\n};\nint flag = 0;\nint cnt = 0;\nvector<bool> vi;\nvoid dfs(vector<vector<vector<int> > > &arc, int n, int u, int v, int c,\n         int pre) {\n  vi[u] = true;\n  int ii = 0, jj = 0;\n  if (u == v) {\n    cnt++;\n    flag = 1;\n    return;\n  }\n  for (jj = 1; jj <= n; jj++) {\n    if (flag == 1) break;\n    if (vi[jj] == false &&\n        find(arc[u][jj].begin(), arc[u][jj].end(), c) != arc[u][jj].end()) {\n      dfs(arc, n, jj, v, c, u);\n    }\n  }\n}\nint main() {\n  int n = 0, m = 0;\n  while (cin >> n >> m) {\n    vector<int> v_tmp;\n    vector<vector<vector<int> > > arc(n + 1,\n                                      vector<vector<int> >(n + 1, v_tmp));\n    int i = 0, j = 0;\n    for (i = 1; i <= m; i++) {\n      int a = 0, b = 0, c = 0;\n      cin >> a >> b >> c;\n      arc[a][b].push_back(c);\n      arc[b][a].push_back(c);\n    }\n    int q = 0;\n    cin >> q;\n    int ii = 0, jj = 0, kk = 0;\n    for (i = 0; i < q; i++) {\n      int u = 0, v = 0;\n      cin >> u >> v;\n      if (u > v) {\n        int tmp = u;\n        u = v;\n        v = tmp;\n      }\n      cnt = 0;\n      for (ii = 1; ii <= m; ii++) {\n        vector<bool> visited(n + 1, false);\n        Node uu(u, -1);\n        queue<Node> que;\n        que.push(uu);\n        visited[u] = true;\n        flag = 0;\n        while (!que.empty() && flag == 0) {\n          Node f = que.front();\n          que.pop();\n          for (jj = 1; jj <= n; jj++) {\n            if (visited[jj] == false &&\n                find(arc[f.num][jj].begin(), arc[f.num][jj].end(), ii) !=\n                    arc[f.num][jj].end()) {\n              if (jj == v) {\n                cnt++;\n                flag = 1;\n                break;\n              }\n              {\n                Node vv(jj, f.num);\n                que.push(vv);\n                visited[jj] = true;\n              }\n            }\n          }\n        }\n      }\n      cout << cnt << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B{\n\tstatic int n,m;\n\tstatic List<Integer>[] adj;\n\tstatic boolean[] visited;\n\t\n\tstatic void dfs(int u)\n\t{\n\t\tvisited[u] = true;\n\t\tfor(int i:adj[u])\n\t\t{\n\t\t\tif(visited[i] == false)\n\t\t\t{\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = fs.nextInt(); m = fs.nextInt();\n\t\tint[][] store = new int[m][3];\n\t\tSet<Integer> colors = new HashSet();\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint u = fs.nextInt()-1; int v = fs.nextInt()-1; int c = fs.nextInt();\n\t\t\tstore[i][0] = c; store[i][1]= u; store[i][2] = v;\n\t\t\tcolors.add(c);\n\t\t}\n\t\tint q = fs.nextInt();\n\t\tfor(int qq=0;qq<q;qq++)\n\t\t{\n\t\t\tint u = fs.nextInt()-1; int v = fs.nextInt()-1;\n\t\t\tint ans = 0;\n\t\t\tfor(int c:colors)\n\t\t\t{\n\t\t\t\tadj = new ArrayList[n];\n\t\t\t\tfor(int i=0;i<n;i++)adj[i] = new ArrayList();\n\t\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\t{\n\t\t\t\t\tif(store[i][0] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\tadj[store[i][1]].add(store[i][2]);\n\t\t\t\t\t\tadj[store[i][2]].add(store[i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited = new boolean[n];\n\t\t\t\tdfs(u);\n\t\t\t\tif(visited[v] == true)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\tpublic static int[] sort(int[] arr)\n\t{\n\t\tList<Integer> temp = new ArrayList();\n\t\tfor(int i:arr)temp.add(i);\n\t\tCollections.sort(temp);\n\t\tint start = 0;\n\t\tfor(int i:temp)arr[start++]=i;\n\t\treturn arr;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\nimport random\nimport operator\nfrom collections import defaultdict\nfrom fractions import Fraction, gcd\nfrom decimal import Decimal, getcontext\nfrom itertools import product, permutations, combinations\ngetcontext().prec = 100\n\nMOD = 10**9 + 7\nINF = float(\"+inf\")\n\nedges = defaultdict(lambda: defaultdict(set))\n\nn, m = map(int, raw_input().split())\nfor _ in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    edges[a][b].add(c)\n    edges[b][a].add(c)\n\n\ndef dfs(u, color):\n    visited.add(u)\n    for t in edges[u]:\n        if t in visited:\n            continue\n        if color not in edges[u][t]:\n            continue\n        if t == v:\n            return 1\n        if dfs(t, color):\n            return 1\n    return 0\n\nq = int(raw_input())\nfor _ in xrange(q):\n    u, v = map(int, raw_input().split())\n    count = 0\n    for c in xrange(m + 1):\n        visited = set()\n        if dfs(u, c):\n            count += 1\n    print count\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<bool> cUsed(111, false);\nstd::vector<bool> visited(111, false);\nstd::vector<std::vector<std::vector<int> > > g(\n    111, std::vector<std::vector<int> >(111));\nvoid dfs(int c, int u) {\n  if (visited[u]) return;\n  visited[u] = 1;\n  for (int i = 0; i < g[c][u].size(); ++i) {\n    int v = g[c][u][i];\n    dfs(c, v);\n  }\n}\nint main() {\n  int n, m, q;\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    cUsed[c] = 1;\n    g[c][a].push_back(b);\n    g[c][b].push_back(a);\n  }\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int u, v, ans = 0;\n    cin >> u >> v;\n    for (int c = 1; c <= 100; ++c) {\n      if (!cUsed[c]) continue;\n      fill(visited.begin(), visited.end(), 0);\n      dfs(c, u);\n      if (visited[v]) {\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nlong long gcd(long long a, long long b) {\n  if (a == 0)\n    return b;\n  else\n    return gcd(b % a, a);\n}\nlong long power(long long base, long long exp, long long mod = 1000000007) {\n  long long ans = 1;\n  while (exp) {\n    if (exp & 1) ans = (ans * base) % mod;\n    exp >>= 1, base = (base * base) % mod;\n  }\n  return ans;\n}\nvector<pair<int, int> > v[1000];\nbool visited[1000];\nint check = 0;\nint h[1000];\nvoid dfs(int x, int y, int clr) {\n  visited[x] = 1;\n  for (int i = 0; i < (int)v[x].size(); i += 1) {\n    if (v[x][i].second == clr && visited[v[x][i].first] == 0) {\n      if (v[x][i].first == y) check = 1;\n      dfs(v[x][i].first, y, clr);\n    }\n  }\n}\nint main() {\n  int n, m, x, y, q, clr, ans = 0;\n  cin >> n >> m;\n  for (int i = 0; i < m; i += 1) {\n    cin >> x >> y >> clr;\n    v[x].push_back(make_pair(y, clr));\n    v[y].push_back(make_pair(x, clr));\n    h[clr]++;\n  }\n  cin >> q;\n  while (q--) {\n    cin >> x >> y;\n    ans = 0;\n    for (clr = 1; clr <= m; clr++) {\n      if (h[clr]) {\n        check = 0;\n        memset(visited, 0, sizeof(visited));\n        dfs(x, y, clr);\n        if (check) ans++;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces.cfr286div2;\n\nimport java.util.Scanner;\n\n/**\n * Created by bistrashkin on 1/21/15.\n */\npublic class B {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        boolean[][][] connected = new boolean[m+1][n+1][n+1];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            connected[c][a][b] = true;\n            connected[c][b][a] = true;\n        }\n        for (int c = 1; c <= m; c++) {\n            for (int k = 1; k <= n; k++) {\n                for (int i = 1; i <= n; i++) {\n                    for (int j = 1; j <= n; j++) {\n                        if (connected[c][i][k] && connected[c][k][j]) {\n                            connected[c][i][j] = true;\n                        }\n                    }\n                }\n            }\n        }\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int count = 0;\n            for (int c = 1; c <= m; c++) {\n                if (connected[c][u][v]) {\n                    count++;\n                }\n            }\n            System.out.println(count);\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef main():\n    n = 0\n    m = 0\n    queries = []\n\n    for i, line in enumerate(sys.stdin):\n        if i < 1:\n            n, m = map(int, line.split())\n            d = [[0] * n for x in range(n)]\n            for row in d:\n                for index, col in enumerate(row):\n                    row[index] = set()\n            continue\n        if i <= m:\n            u, v, c = map(int, line.split())\n            d[u-1][v-1].add(c)\n            d[v-1][u-1].add(c)\n            continue\n        if i == m + 1:\n            continue\n        u, v = map(int, line.split())\n        queries.append((u, v, ))\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = d[i][j].union(d[i][k].intersection(d[k][j]))\n\n    for u, v in queries:\n        print len(d[u-1][v-1])\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 103;\nvector<pair<int, int>> v[maxn];\nint vis[maxn];\nbool dfs(int start, int des, int x) {\n  if (vis[start]) return 0;\n  if (start == des) return 1;\n  vis[start] = 1;\n  for (auto e : v[start]) {\n    if (e.second == x) {\n      if (dfs(e.first, des, x)) return 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  int n, m;\n  int x, y, z;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y >> z;\n    v[x].push_back({y, z});\n    v[y].push_back({x, z});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> x >> y;\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n      memset(vis, 0, sizeof(vis));\n      if (dfs(x, y, i)) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * User: dmitry\n */\npublic class Main {\n    public static InputStream is = System.in;\n    public static BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    public static StringTokenizer stok;\n\n    public static String next() {\n        String nxt;\n        try {\n            if (stok != null && stok.hasMoreElements()) return stok.nextToken();\n            if ((nxt = br.readLine()) != null) {\n                stok = new StringTokenizer(nxt);\n                if (stok.hasMoreElements()) return stok.nextToken();\n            } else return null;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n\n    public static byte[][][] gr = new byte[101][101][101];\n\n    public static void main(String[] args) {\n        int n = nextInt();\n        int m = nextInt();\n        Map<Integer, Set<Integer>> verCol = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n\n            Integer a = nextInt();\n            Integer b = nextInt();\n            Integer col = nextInt();\n            if (verCol.get(a) == null) {\n                verCol.put(a, new HashSet<Integer>());\n            }\n            if (verCol.get(b) == null) {\n                verCol.put(b, new HashSet<Integer>());\n            }\n            verCol.get(a).add(col);\n            verCol.get(b).add(col);\n            gr[a][b][col] = 1;\n            gr[b][a][col] = 1;\n        }\n\n        int q = nextInt();\n        int[][] reqs = new int[q][2];\n        for (int i = 0; i < q; i++) {\n            reqs[i][0] = nextInt();\n            reqs[i][1] = nextInt();\n        }\n        long ct = System.currentTimeMillis();\n        HashSet<Integer> commanCols = new HashSet<>();\n        for (int i = 0; i < q; i++) {\n            int cnt = 0;\n            int u = reqs[i][0];\n            int v = reqs[i][1];\n            commanCols.clear();\n            if (verCol.get(u) == null) verCol.put(u, new HashSet<Integer>());\n            if (verCol.get(v) == null) verCol.put(v, new HashSet<Integer>());\n            commanCols.addAll(verCol.get(u));\n            commanCols.addAll(verCol.get(v));\n            for (Integer cmCol : commanCols) {\n                if (check(u, v, cmCol)) cnt++;\n            }\n            System.out.println(cnt);\n        }\n        //System.out.println(System.currentTimeMillis() - ct);\n    }\n\n    public static LinkedList<Integer> que = new LinkedList<>();\n\n    private static boolean check(int u, int v, int cmCol) {\n        que.clear();\n        que.add(u);\n\n        byte[] metk = new byte[101];\n\n        while (!que.isEmpty()) {\n            Integer vert = que.pollFirst();\n            metk[vert] = 1;\n            if (vert == v) return true;\n            for (int i = 0; i < 101; i++) {\n                if (gr[vert][i][cmCol] == 1 && vert != i && metk[i] != 1) que.add(i);\n\n            }\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n    @SuppressWarnings(\"unchecked\")\n    public static void solution(BufferedReader reader, PrintWriter writer)\n            throws IOException {\n        In in = new In(reader);\n        Out out = new Out(writer);\n        int n = in.nextInt(), m = in.nextInt();\n        boolean[][][] g = new boolean[n + 1][n + 1][m + 1];\n        for (int i = 0; i < m; i++) {\n            int u = in.nextInt(), v = in.nextInt(), c = in.nextInt();\n            g[u][v][c] = g[v][u][c] = true;\n        }\n        for (int k = 1; k <= n; k++)\n            for (int i = 1; i <= n; i++)\n                for (int j = 1; j <= n; j++)\n                    for (int c = 1; c <= m; c++)\n                        if (g[i][k][c] && g[k][j][c])\n                            g[i][j][c] = true;\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int u = in.nextInt(), v = in.nextInt(), cnt = 0;\n            for (int c = 1; c <= m; c++)\n                if (g[u][v][c])\n                    cnt++;\n            out.println(cnt);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, writer);\n        writer.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public int[] nextIntArray1(int n) throws IOException {\n            int[] a = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public int[] nextIntArraySorted(int n) throws IOException {\n            int[] a = nextIntArray(n);\n            Random r = new Random();\n            for (int i = 0; i < n; i++) {\n                int j = i + r.nextInt(n - i);\n                int t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        public long[] nextLongArray1(int n) throws IOException {\n            long[] a = new long[n + 1];\n            for (int i = 1; i <= n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        public long[] nextLongArraySorted(int n) throws IOException {\n            long[] a = nextLongArray(n);\n            Random r = new Random();\n            for (int i = 0; i < n; i++) {\n                int j = i + r.nextInt(n - i);\n                long t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            return a;\n        }\n    }\n\n    protected static class Out {\n        private PrintWriter writer;\n        private static boolean local = System\n                .getProperty(\"ONLINE_JUDGE\") == null;\n\n        public Out(PrintWriter writer) {\n            this.writer = writer;\n        }\n\n        public void print(char c) {\n            writer.print(c);\n        }\n\n        public void print(int a) {\n            writer.print(a);\n        }\n\n        public void println(String s) {\n            writer.println(s);\n        }\n\n        public void println(int a) {\n            writer.println(a);\n        }\n\n        public void println(long a) {\n            writer.println(a);\n        }\n\n        public void println(Object[] os) {\n            for (int i = 0; i < os.length; i++) {\n                writer.print(os[i]);\n                writer.print(' ');\n            }\n            writer.println();\n        }\n\n        public void println(int[] a) {\n            for (int i = 0; i < a.length; i++) {\n                writer.print(a[i]);\n                writer.print(' ');\n            }\n            writer.println();\n        }\n\n        public void println(long[] a) {\n            for (int i = 0; i < a.length; i++) {\n                writer.print(a[i]);\n                writer.print(' ');\n            }\n            writer.println();\n        }\n\n        public static void db(Object... objects) {\n            if (local)\n                System.out.println(Arrays.deepToString(objects));\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic final class ColorFullGraph\n{\tstatic int s,t;\n\tstatic boolean b[];\n\tstatic int c=0;\t\n\tstatic ArrayList<CGraph>[] arr;\n\tstatic ArrayList<Integer> f;\npublic static void main(String[] args) \n{\n\t\tScanner br=new Scanner(System.in);\n\t\tint n=br.nextInt();\n\t\tint m=br.nextInt();\n\t\t\n\t\tarr=new ArrayList[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tarr[i]=new ArrayList<CGraph>();\n\t\t f=new ArrayList<Integer>();\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a=br.nextInt();\n\t\t\tint b=br.nextInt();\n\t\t\tint c=br.nextInt();\n\t\t\tarr[a].add(new CGraph(b,c));\n\t\t\tarr[b].add(new CGraph(a,c));\n\t\t\t\n\t\t}\n\t\tint q=br.nextInt();\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tc=0;\n\t\t\tf.clear();\n\t\t\ts=br.nextInt();//source vertex\n\t\t\tt=br.nextInt();// target vertex\n\t\t\tfor(CGraph g:arr[s])\n\t\t\t{\n\t\t\tb=new boolean[n+1];\n\t\t\tint color=g.c();\n\t\t\tint v=g.v();\n\t\t\t\n\t\t\tif(!f.contains(color) &&  dfs(s,color))\n\t\t\t{c++;\n\t\t\tf.add(color);\n\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\t\n\t}\n\tpublic static boolean dfs(int u,int col)\n\t{\tboolean m=false;\n\t\tb[u]=true;\n\t\tif(u==t)\n\t\t\treturn true;\n\t\tfor(CGraph graph:arr[u])\n\t\t{\n\t\t\tint color=graph.c();\n\t\t\tint v=graph.v();\n\t\t\tif(!b[v] && color==col )\n\t\t\t{\n\t\t\tif(dfs(v,color))\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\nclass CGraph\n{\n\tprivate int v,c;\n\tpublic CGraph(int v,int c)\n\t{\n\t\tthis.v=v;\n\t\tthis.c=c;\n\t}\n\tpublic int v()\n\t{\n\t\treturn this.v;\n\t}\n\tpublic int c()\n\t{\n\t\treturn this.c;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\nparent_history = {}\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        if c in parent_history and v in parent_history[c]:\n            parent = parent_history[c]\n        else:\n            parent = {}\n            parent = dfs_visit(v, graph[c], parent)\n            parent_history[c] = parent\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))"
        },
        {
            "language": 4,
            "solution": "/**\n * #dfs #graph\n */\n\nimport java.util.Scanner;\nimport java.util.ArrayList;\npublic class ColorfulGraph {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Node>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            graph.get(a-1).add(new Node(b-1, c-1));\n            graph.get(b-1).add(new Node(a-1, c-1));\n        }\n\n        // query\n        int q = sc.nextInt();\n        for(int k = 0; k < q; k++) \n        {\n            int res = 0;\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            \n            // interate each color\n            for(int i = 0 ; i < m; ++i) {\n                boolean[] visited = new boolean[101];\n                if(dfs(u-1, i, v-1, visited, graph)) {\n                    ++res;\n                }\n            }\n            System.out.println(res);\n        }\n    }\n\n    private static boolean dfs(int v, int col, int dst, boolean[] visited, ArrayList<ArrayList<Node>> graph){\n        visited[v]= true;\n        if(v == dst) {\n            return true;\n        }\n        for(int i = 0; i < graph.get(v).size(); i++) {\n            Node neighbour = graph.get(v).get(i);\n            if(neighbour.color == col && !visited[neighbour.idx])\n            {\n                if(dfs(neighbour.idx, col, dst, visited, graph)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\nclass Node {\n    int idx;\n    int color;\n    Node(int idx, int color) {\n        this.idx = idx;\n        this.color = color;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\n/**\n *\n * @author \u0442\u0430\u043d\u044f\n */\npublic class KF {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws IOException {\n        B jk = new B();\n    }\n}\n\nclass B {\nclass Point{\nint v;\nint c;\n\n        public Point(int vi, int ci) {\n            c=ci;\n            v=vi;\n        }\n    }\n    PrintWriter out = new PrintWriter(System.out);\n    Scanner in = new Scanner(System.in);\n    int n=in.nextInt();\n    int m=in.nextInt();\n    ArrayList<Point> list[]= new ArrayList[n+1];\n   \n  B(){\nfor(int i=0;i<=n;i++){\nlist[i]= new ArrayList<Point>();\n}\nfor (int i=0;i<m;i++){\n    int st =in.nextInt();\n    int end=in.nextInt();\n    int c=in.nextInt();\nlist[st].add(new Point(end, c));\nlist[end].add(new Point(st, c));\n}\nint q=in.nextInt();\nfor(int i=0;i<q;i++){\nint st=in.nextInt();\nint end =in.nextInt();\nTreeSet<Integer>zwet = new TreeSet<>();\nint count=0;\nfor(int j=0;j<list[st].size();j++){\nif(!zwet.contains(list[st].get(j).c)){\nif(BFS(list[st].get(j).c, st, end)){\ncount++;\n}\nzwet.add(list[st].get(j).c);\n}\n}\nout.println(count);\nout.flush();\n}\n\n      }\n  \n  boolean BFS(int c, int v, int end){\n  boolean used[]= new boolean[n+1];\n  used[v]= true;\n  ArrayList<Integer>q= new ArrayList<>();\n  q.add(v);\n  while(!q.isEmpty()){\n      v=q.get(0);\n  for(int i=0;i<list[v].size();i++){\n  if(list[v].get(i).c==c){\n      if(used[list[v].get(i).v]==false){\n  q.add(list[v].get(i).v);\n      used[list[v].get(i).v]=true;\n      }\n  \n  if(list[v].get(i).v==end){\n  return true;\n  }\n  }\n  }\n q.remove(0);\n\n  }\n  return false;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import defaultdict\n\ndef dfs(G, u, v):\n    to_visit = [u]\n    visited = set()\n    while to_visit:\n        c = to_visit.pop()\n        if c in visited:\n            continue\n        for n in G[c]:\n            if n == v:\n                return 1\n            if n not in visited:\n                to_visit.append(n)\n        visited.add(c)\n    return 0\n\nn, m = map(int, raw_input().split())\nG = {}\nfor _ in range(m):\n    a, b, c = map(int, raw_input().split())\n    if c not in G:\n        G[c] = defaultdict(list)\n    G[c][a].append(b)\n    G[c][b].append(a)\ncolors = G.keys()\nq = int(raw_input())\nfor _ in range(q):\n    u, v = map(int, raw_input().split())\n    cnt = 0\n    for c in colors:\n        cnt += dfs(G[c], u, v)\n    print cnt\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#'%.9f'%ans\n##########################################################\nfrom collections import defaultdict\ndef dfs(s,f):\n    if s==v:\n        return True\n    vis[s]=1\n\n\n    for i in g[s]:\n        if vis[i[0]]==0 and i[1]==f:\n            if(dfs(i[0],f)):\n                return True\n\n    return False\n\n\n\n\n\n\n#for _ in range(int(input())):\n#n = int(input())\nn,m = map(int, input().split())\ng=[[] for i in range(n+2)]\nfor i in range(m):\n    u,v,d = map(int, input().split())\n    g[u].append([v,d])\n    g[v].append([u,d])\nq= int(input())\nfor _ in range(q):\n    u, v= map(int, input().split())\n    cnt=0\n    for i in range(1,101):\n        vis=[0]*101\n        if (dfs(u,i)):\n            cnt+=1\n    print(cnt)\n\n\n    #g=[[] for i in range(n+1)]\n    #arr = list(list(map(int, input().split())))\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\n\ndef dfs(g, u, visited=None):\n    if visited is None:\n        visited = set()\n\n    visited.add(u)\n    for node in g[u]:\n        if node not in visited:\n            dfs(g, node, visited)\n\n    return visited\n\n\ndef main():\n    n, m = map(int, input().split())\n    graphs = {}\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        if c not in graphs:\n            graphs[c] = defaultdict(list)\n        graphs[c][a].append(b)\n        graphs[c][b].append(a)\n\n    num_queries = int(input())\n    for _ in range(num_queries):\n        u, v = map(int, input().split())\n        ans = 0\n        for g in graphs.values():\n            if v in dfs(g, u):\n                ans += 1\n\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 105;\nvector<pair<int, int>> v[maxn];\nint vis[maxn];\nbool dfs(int start, int des, int x) {\n  if (vis[start]) return 0;\n  if (start == des) return 1;\n  vis[start] = 1;\n  for (auto e : v[start]) {\n    if (e.second == x) {\n      if (dfs(e.first, des, x)) return 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  int n, m;\n  int x, y, z;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y >> z;\n    v[x].push_back({y, z});\n    v[y].push_back({x, z});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> x >> y;\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n      memset(vis, 0, sizeof(vis));\n      if (dfs(x, y, i)) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] a = new int[m];\n\t\tint[] b = new int[m];\n\t\tint[] c = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\tc[i] = sc.nextInt();\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tint[] u = new int[q];\n\t\tint[] v = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tu[i] = sc.nextInt();\n\t\t\tv[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.print(solve(n, a, b, c, u, v));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int n, int[] a, int[] b, int[] c, int[] u, int[] v) {\n\t\tint m = a.length;\n\n\t\tint[][] colorToParents = new int[m + 1][n + 1];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint root1 = findRoot(colorToParents[c[i]], a[i]);\n\t\t\tint root2 = findRoot(colorToParents[c[i]], b[i]);\n\n\t\t\tif (root1 != root2) {\n\t\t\t\tcolorToParents[c[i]][root2] = root1;\n\t\t\t}\n\t\t}\n\n\t\treturn IntStream.range(0, u.length)\n\t\t\t\t.mapToObj(i -> String.valueOf(Arrays.stream(colorToParents)\n\t\t\t\t\t\t.filter(parents -> findRoot(parents, u[i]) == findRoot(parents, v[i])).count()))\n\t\t\t\t.collect(Collectors.joining(\"\\n\"));\n\t}\n\n\tstatic int findRoot(int[] parents, int node) {\n\t\tint root = node;\n\t\twhile (parents[root] != 0) {\n\t\t\troot = parents[root];\n\t\t}\n\n\t\tint p = node;\n\t\twhile (p != root) {\n\t\t\tint next = parents[p];\n\t\t\tparents[p] = root;\n\n\t\t\tp = next;\n\t\t}\n\n\t\treturn root;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1004;\nvector<pair<long long, long long>> gr[N];\nlong long vis[N] = {};\nbool dfs(long long curr, long long &col, long long &dest) {\n  vis[curr] = 1;\n  if (curr == dest) return true;\n  bool ans = 0;\n  for (auto x : gr[curr]) {\n    if (!vis[x.first] and x.second == col) {\n      ans = ans or dfs(x.first, col, dest);\n    }\n  }\n  return ans;\n}\nvoid solve(long long tc) {\n  long long n, m;\n  cin >> n >> m;\n  long long x, y, c;\n  for (long long i = 0; i < m; i++) {\n    cin >> x >> y >> c;\n    gr[x].push_back({y, c});\n    gr[y].push_back({x, c});\n  }\n  long long q;\n  cin >> q;\n  for (long long i = 0; i < q; i++) {\n    cin >> x >> y;\n    long long ans = 0;\n    for (long long j = 1; j <= m; j++) {\n      memset(vis, 0, sizeof(vis));\n      vis[x] = 1;\n      ans += dfs(x, j, y);\n    }\n    cout << ans << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve(1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nstruct edge {\n  int v, color;\n  edge(int iv, int ic) {\n    v = iv;\n    color = ic;\n  }\n};\nvector<edge> G[maxn];\nbool vis[maxn];\nset<int> sc;\nint n, m, q;\nint ans, s, t;\nbool dfs(int k, int color) {\n  vis[k] = true;\n  if (k == t) {\n    return true;\n  }\n  for (int i = 0; i < G[k].size(); i++) {\n    int co = G[k][i].color, v = G[k][i].v;\n    if (co == color && !vis[v]) {\n      if (dfs(v, co)) return true;\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> m;\n  int a, b, c;\n  memset(G, 0, sizeof(G));\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    G[a].push_back(edge(b, c));\n    G[b].push_back(edge(a, c));\n  }\n  cin >> q;\n  while (q--) {\n    sc.clear();\n    scanf(\"%d%d\", &s, &t);\n    ans = 0;\n    for (int i = 0; i < G[s].size(); i++) {\n      int co = G[s][i].color;\n      int v = G[s][i].v;\n      memset(vis, false, sizeof(vis));\n      vis[s] = true;\n      if (dfs(v, co)) sc.insert(co);\n    }\n    printf(\"%d\\n\", sc.size());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/python\n\nfrom collections import deque\nfrom collections import defaultdict as dd\n\ndef ir():\n    return int(raw_input())\n\ndef ia():\n    line = raw_input()\n    line = line.split()\n    return map(int, line)\n\nN = 105\nclass CC(object):\n    def __init__(self):\n        self.id = [i for i in range(N)]\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    def find(self, p):\n        id = self.id\n        while id[p]!=p:\n            p = id[p]\n        return p\n    def union(self, p, q):\n        p = self.find(p)\n        q = self.find(q)\n        self.id[p] = self.id[q]\n    \nn, m = ia()\n\nG = dd(CC)\n\nfor i in range(m):\n    a, b, c = ia()\n    G[c].union(a, b)\n\nq = ir()\nfor i in range(q):\n    u, v = ia()\n    ans = 0\n    for c in G.values():\n        if c.connected(u, v): ans += 1\n    print ans\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid prn(bool space, Arg1&& arg1) {\n  cout << arg1;\n  if (space)\n    cout << \" \";\n  else\n    cout << \"\\n\";\n}\ntemplate <typename Arg1, typename... Args>\nvoid prn(bool space, Arg1&& arg1, Args&&... args) {\n  prn(space, arg1);\n  prn(space, args...);\n}\nconst long long mod = 1000000007;\nconst long long MOD = 998244353;\nconst long long inf = 1e18;\nconst long long MAX = 2e5 + 1;\ninline long long add(long long a, long long b) {\n  return ((a % mod) + (b % mod)) % mod;\n}\ninline long long sub(long long a, long long b) {\n  return ((a % mod) - (b % mod) + mod) % mod;\n}\ninline long long mul(long long a, long long b) {\n  return ((a % mod) * (b % mod)) % mod;\n}\nvector<long long> fac(1e6);\nlong long pwr(long long x, long long n) {\n  x = x % mod;\n  if (!n) return 1;\n  if (n & 1)\n    return mul(x, pwr(mul(x, x), (n - 1) / 2));\n  else\n    return pwr(mul(x, x), n / 2);\n}\nlong long modinv(long long n) { return pwr(n, mod - 2); }\nlong long inv(long long i) {\n  if (i == 1) return 1;\n  return (mod - (mod / i) * inv(mod % i) % mod) % mod;\n}\nlong long ncr(long long n, long long r) {\n  long long ans = 1;\n  if (r != 0 && r != n) {\n    ans = fac[n] * modinv(fac[r]) % mod * modinv(fac[n - r]) % mod;\n  }\n  return ans;\n}\nvoid pre() {\n  fac[0] = 1;\n  for (int i = 1; i < (int)fac.size(); i++) {\n    fac[i] = (fac[i - 1] * i) % mod;\n  }\n}\nbool isPowerOfTwo(int x) { return x && (!(x & (x - 1))); }\nvector<pair<int, int> > g[101];\nint check;\nvector<bool> vis;\nint starta, enda;\nvoid dfs(int a, int color) {\n  vis[a] = true;\n  if (a == enda) {\n    check = 1;\n    return;\n  }\n  for (auto x : g[a]) {\n    if (!vis[x.first] && x.second == color) {\n      dfs(x.first, color);\n    }\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  int maxa = -1;\n  for (int i = 0; i < m; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    maxa = max(maxa, c);\n    g[x].push_back({y, c});\n    g[y].push_back({x, c});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> starta >> enda;\n    int ans = 0;\n    for (int i = 1; i <= maxa; i++) {\n      vis.assign(n + 1, false);\n      check = 0;\n      dfs(starta, i);\n      ans += check;\n    }\n    cout << ans << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <19/Feb/2019 06:31:43 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n#\tQuestion Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return map(int, sys.stdin.readline().split())\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\nN = 105\ngraph = [[] for _ in range(N)]\ncomponent = [0] * N\nvisited = [False] * N\n\n\ndef explore(node):\n    global cnt\n    visited[node] = True\n    component[node] = cnt\n    for neighbour, color in graph[node]:\n        if visited[neighbour] == False:\n            explore(neighbour)\n\n\ndef dfs(n):\n    global cnt\n    cnt = 0\n    for i in range(1, n + 1):\n        if visited[i] == False:\n            cnt += 1\n            explore(i)\n\n\ndef explore_o(node, c):\n    global ans, s\n    visited[node] = True\n    for neighbour, color in graph[node]:\n        if visited[neighbour] == False and color == c:\n            if neighbour == v:\n                s.add(color)\n            explore_o(neighbour, c)\n\n\ndef dfs_o(u):\n    global visited, ans, flag, s\n    ans = 0\n    s = set()\n    for neighbour, color in graph[u]:\n        visited = [False] * N\n        visited[u] = True\n        flag = 0\n        if neighbour == v:\n            s.add(color)\n            continue\n        explore_o(neighbour, color)\n    return len(s)\n\n\ndef main():\n    global n, m\n    n, m = get_ints()\n    for _ in range(m):\n        u, x, c = get_ints()\n        graph[u].append((x, c))\n        graph[x].append((u, c))\n    dfs(n)\n    global v\n    for tc in range(int(input())):\n        u, v = get_ints()\n        if component[u] != component[v]:\n            print(0)\n            continue\n        print(dfs_o(u))\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n\n    static int [][] p;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                                            //(new FileReader(\"input.in\"));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n\n        tk = new StringTokenizer(in.readLine());\n        int n = parseInt(tk.nextToken()),m = parseInt(tk.nextToken());\n        \n        p = new int[m][n];\n        for(int i=0; i<m; i++) \n            for(int j=0; j<n; j++) \n                p[i][j] = j;\n        \n        while(m-- > 0) {\n            tk = new StringTokenizer(in.readLine());\n            int a = parseInt(tk.nextToken())-1,b = parseInt(tk.nextToken())-1,c = parseInt(tk.nextToken())-1;\n            a = find(a,c);\n            b = find(b,c);\n            \n            if(a != b) {\n                p[c][a] = b;\n            }\n        }\n        \n        int q = parseInt(in.readLine());\n        \n        while(q-- > 0) {\n            tk = new StringTokenizer(in.readLine());\n            int a = parseInt(tk.nextToken())-1,b = parseInt(tk.nextToken())-1;\n            \n            int ans = 0;\n            for(int i=0; i<p.length; i++) {\n                int x = find(a,i);\n                int y = find(b,i);\n                \n                if(x==y) {\n                    ans++;\n                }\n            }\n            \n            out.append(ans).append(\"\\n\");\n        }\n        \n        System.out.print(out);\n    }\n    \n    static int find(int u,int i) {\n        if(p[i][u]==u)\n            return u;\n        return p[i][u] = find(p[i][u],i);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B {\n\tstatic Node[] nodes;\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t// BufferedReader in = new BufferedReader(new FileReader(\"test.in\"));\n\t\tPrintStream out = System.out;\n\t\tString line = in.readLine();\n\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(\" \")));\n\t\tint m = Integer.parseInt(line.substring(line.lastIndexOf(\" \") + 1));\n\t\tHashSet<Integer> possibleColors = new HashSet<Integer>();\n\t\tnodes = new Node[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tnodes[i] = new Node(i);\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tString[] strs = in.readLine().split(\" \");\n\t\t\tint a = Integer.parseInt(strs[0]);\n\t\t\tint b = Integer.parseInt(strs[1]);\n\t\t\tint c = Integer.parseInt(strs[2]);\n\t\t\ta--; b--;\n\t\t\tEdge e = new Edge(a, b, c);\n\t\t\tnodes[a].edges.add(e);\n\t\t\tnodes[b].edges.add(e);\n\t\t\tpossibleColors.add(c);\n\t\t}\n\t\tline = in.readLine();\n\t\tint q = Integer.parseInt(line);\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tline = in.readLine();\n\t\t\tint u = Integer.parseInt(line.substring(0, line.indexOf(\" \")));\n\t\t\tint v = Integer.parseInt(line.substring(line.lastIndexOf(\" \") + 1));\n\t\t\tu--; v--;\n\t\t\tint ct = 0;\n\t\t\tfor(Integer c : possibleColors) {\n\t\t\t\tif(canReach(u, v, c)) {\n\t\t\t\t\tct++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ct);\n\t\t}\n\t}\n\tstatic boolean canReach(int u, int v, int c) {\n\t\tArrayList<Integer> list1 = new ArrayList<Integer>();\n\t\tboolean[] vis = new boolean[nodes.length];\n\t\tlist1.add(u);\n\t\twhile(!list1.isEmpty()) {\n\t\t\tArrayList<Integer> list2 = new ArrayList<Integer>();\n\t\t\tfor(Integer i : list1) {\n\t\t\t\tfor(Edge e : nodes[i].edges) {\n\t\t\t\t\tif(e.u != i) {\n\t\t\t\t\t\tint tmp = e.u;\n\t\t\t\t\t\te.u = e.v;\n\t\t\t\t\t\te.v = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tif(e.c == c && !vis[e.v]) {\n\t\t\t\t\t\tlist2.add(e.v);\n\t\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\t\tif(e.v == v) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist1 = list2;\n\t\t}\n\t\treturn vis[v];\n\t}\n\tstatic class Node {\n\t\tHashSet<Edge> edges = new HashSet<Edge>();\n\t\tint id;\n\t\tNode(int i) {\n\t\t\tid = i;\n\t\t}\n\t}\n\tstatic class Edge {\n\t\tint u, v, c;\n\t\tEdge(int i, int j, int k) {\n\t\t\tu = i; v = j; c = k;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\n\npublic class b {\n\tstatic class Edge implements Comparable<Edge>\n\t{\n\t\tint  dest;int col;\n\n\t    public Edge(int  d,int c)\n\t    {\n\t        this.dest = d;\n\t        this.col = c;\n\t       \n\t    }\n\t   \n\t    public int compareTo(Edge edge)\n\t    {\n\t    \t//== is not compared so that duplicate values are not eliminated. \n\t    \treturn (this.col < edge.col) ? -1: 1;\n\t    }\n\t}\n\tstatic ArrayList<Edge> adj[];\n\tstatic boolean visited[];\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\tint s,d,c;\n\tadj = new ArrayList[n];\n\tfor (int i = 0; i <n; i++) {\n\t\tadj[i]=new ArrayList<Edge>();\n\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ts= in.nextInt() - 1;\n\t\t\td = in.nextInt() - 1;\n\t\t\tc = in.nextInt();\n\t\t\tadj[s].add(new Edge(d, c));\n\t\t\tadj[d].add(new Edge(s, c));\n\t\t}\n\t\t\n\n\t\tint tc = in.nextInt();\n\t\tint src, dest;\n\t\tfor (int ii = 0; ii < tc; ii++) {\n\n\t\t\tsrc = in.nextInt() - 1;\n\t\t\tdest = in.nextInt() - 1;\n\t\t\tint count = 0;\n\t\t\tfor (int i = 1; i <= m; i++) {\n\n\t\t\t\t\n\t\t\t\tvisited = new boolean[n];\n\t\t\t\tdfs(src,i);\n\t\t\t\tif (visited[dest]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\n\t}\n\n\tstatic void dfs(int vertex,int c) {\n\t\tvisited[vertex] = true;\n\t\tfor (int i = 0; i < adj[vertex].size(); i++) {\n\t\t\tif (!visited[adj[vertex].get(i).dest]&&adj[vertex].get(i).col==c) {\n\t\t\t\tdfs(adj[vertex].get(i).dest,c);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Test {\n\tstatic int n;\n\tstatic int m;\n\tstatic int count;\n\tstatic int[] fix;\n\tstatic ArrayList<Integer>[][] graph;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tgraph = new ArrayList[m+1][n+1];\n\t\tfix = new int[n+1];\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tgraph[i][j] = new ArrayList<Integer>();\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tgraph[c][a].add(b);\n\t\t\tgraph[c][b].add(a);\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 1; i <= q; i++) {\n\t\t\tint q1 = sc.nextInt();\n\t\t\tint q2 = sc.nextInt();\n\t\t\tcount = 0;\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tfix = new int[n+1];\n\t\t\t\tdfs(q1, q2, j);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic static void dfs(int a, int b, int c) {\n\t\tif (fix[a] == 1) return;\n\t\tif (a == b) {\n\t\t\tfix[a] = 1;\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tfix[a] = 1;\n\t\tfor (int i = 0; i < graph[c][a].size(); i++)\n\t\t\tdfs(graph[c][a].get(i), b, c);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CF286B {\n\n\tstatic boolean mx[][][];\n\tstatic int n;\n\tstatic int m;\n\tstatic int a;\n\tstatic int b;\n\tstatic int count;\n\n\tstatic boolean mark[];\n\n\tstatic void justBFS(int v, int c) {\n\t\tint[] queue = new int[n]; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\tint qH = 0; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\tint qT = 0; // \ufffd\ufffd\ufffd\ufffd\ufffd\n\n\t\t/* <\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd v> */\n\t\tmark[v] = true; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\tqueue[qT++] = v; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\n\t\twhile (qH < qT) { // \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\n\t\t\tv = queue[qH++]; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\t\tfor (int nv = 0; nv < n; nv++) { // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\t\t\tif (!mark[nv] && mx[c][v][nv]) { \n\t\t\t\t\tif (nv==b){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t/* <\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd nv> */\n\t\t\t\t\tmark[nv] = true; // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\n\t\t\t\t\tqueue[qT++] = nv; // \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void justDFS(int v, int c) {\n\t\tmark[v] = true;\n\t\tfor (int nv = 0; nv < n; nv++) {\n\t\t\tif (!mark[nv] && mx[c][v][nv]) {\n\t\t\t\tif (nv == a) {\n\t\t\t\t\tcount++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tjustDFS(nv, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tm = scan.nextInt();\n\t\tmx = new boolean[m][n][n];\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint uu = scan.nextInt() - 1;\n\t\t\tint vv = scan.nextInt() - 1;\n\t\t\tint cc = scan.nextInt() - 1;\n\t\t\tmx[cc][uu][vv] = true;\n\t\t\tmx[cc][vv][uu] = true;\n\t\t}\n\t\tint q = scan.nextInt();\n\t\tfor (int ii = 0; ii < q; ii++) {\n\t\t\ta = scan.nextInt() - 1;\n\t\t\tb = scan.nextInt() - 1;\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmark = new boolean[n];\n\t\t\t\tjustBFS(a, i);\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 1,
            "solution": "\nN, M = [int(x) for x in raw_input().split(' ')]\nf = [list(range(N)) for _ in range(M)]\ndef find(f, x):\n    if x != f[x]:\n        f[x] = find(f, f[x])\n    return f[x]\nres = 0\nfor _ in range(M):\n    a, b, c = [int(x)-1 for x in raw_input().split(' ')]\n    fa, fb = find(f[c], a), find(f[c], b)\n    f[c][fb] = fa\nQ = [int(x) for x in raw_input().split(' ')][0]\nfor _ in range(Q):\n    a, b = [int(x)-1 for x in raw_input().split(' ')]\n    res = 0\n    for i in range(M):\n        fa, fb = find(f[i], a), find(f[i], b)\n        if fa == fb:\n            res += 1\n    print(res)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[110][110] = {0};\nvector<int> adj[110][110];\nint vis[110];\nvoid dfs(int parent, int u, int color) {\n  vis[u] = 1;\n  ans[parent][u]++;\n  for (int v = 0; v < (int)adj[u][color].size(); v++) {\n    if (!vis[adj[u][color][v]]) {\n      dfs(parent, adj[u][color][v], color);\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  set<int> s[110];\n  for (int i = 0; i < m; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    adj[x][c].push_back(y);\n    adj[y][c].push_back(x);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      memset(vis, 0, sizeof(vis));\n      if ((int)adj[i][j].size() > 0) {\n        dfs(i, i, j);\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int x, y;\n    cin >> x >> y;\n    cout << ans[x][y] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class MrKitayutasColorfulGraph {\n\tstatic ArrayList<HashSet<Integer>>[] superMap;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] in = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(in[0]), m = Integer.parseInt(in[1]);\n\t\tsuperMap = new ArrayList[m];\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tsuperMap[i] = new ArrayList<>();\n\t\t\tsuperMap[i].add(new HashSet<>());\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tString[] curr = br.readLine().split(\" \");\n\t\t\tint a = Integer.parseInt(curr[0])-1, b = Integer.parseInt(curr[1])-1, c = Integer.parseInt(curr[2])-1;\n\t\t\tboolean found = false;\n\t\t\tfor(int j = 0 ; j < superMap[c].size() ; j++){\n\t\t\t\tif(superMap[c].get(j).contains(a)){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tsuperMap[c].get(j).add(b);\n\t\t\t\t\tfind(c, b, j);\n\t\t\t\t}\n\t\t\t\tif(superMap[c].get(j).contains(b)){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tsuperMap[c].get(j).add(a);\n\t\t\t\t\tfind(c, a, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found){\n\t\t\t\tsuperMap[c].add(new HashSet<>());\n\t\t\t\tsuperMap[c].get(superMap[c].size()-1).add(a);\n\t\t\t\tsuperMap[c].get(superMap[c].size()-1).add(b);\n\t\t\t}\n\t\t}\n\t\tint run = Integer.parseInt(br.readLine());\n\t\tfor(int runs = 0 ; runs < run ; runs++){\n\t\t\tString[] query = br.readLine().split(\" \");\n\t\t\tint u = Integer.parseInt(query[0])-1, v = Integer.parseInt(query[1])-1, count = 0;\n\t\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\t\tfor(int j = 0 ; j < superMap[i].size() ; j++){\n\t\t\t\t\tif(superMap[i].get(j).contains(u) && superMap[i].get(j).contains(v)){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic void find(int color, int curr, int id){\n\t\tfor(int i = 0 ; i < superMap[color].size() ; i++){\n\t\t\tif(id != i && superMap[color].get(i).contains(curr)){\n\t\t\t\tsuperMap[color].get(id).addAll(superMap[color].get(i));\n\t\t\t\tsuperMap[color].remove(i);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  else\n    return a.first < b.first;\n}\nlong long exp(long long a, long long b) {\n  long long ans = 1;\n  while (b != 0) {\n    if (b % 2) ans = ans * a;\n    a = a * a;\n    b /= 2;\n  }\n  return ans;\n}\nbool has[105];\nlong long comp[105];\nbool vis[105];\nvector<pair<long long, long long> > v[105];\nvoid dfs(long long st, long long cmp) {\n  vis[st] = 1;\n  comp[st] = cmp;\n  for (long long i = (long long)0; i < (long long)v[st].size(); i++) {\n    long long to = v[st][i].first;\n    if (!vis[to]) {\n      dfs(to, cmp);\n    }\n  }\n}\nvoid dfs1(long long st, long long co) {\n  vis[st] = 1;\n  for (long long i = (long long)0; i < (long long)v[st].size(); i++) {\n    long long to = v[st][i].first;\n    long long col = v[st][i].second;\n    if (!vis[to] && co == col) {\n      dfs1(to, co);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = (long long)0; i < (long long)m; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    v[b].push_back({a, c});\n    has[c] = 1;\n  }\n  long long q;\n  cin >> q;\n  for (long long i = (long long)0; i < (long long)q; i++) {\n    long long a, b;\n    cin >> a >> b;\n    long long cnt = 0;\n    for (long long i = (long long)1; i < (long long)105; i++) {\n      if (has[i]) {\n        memset((vis), 0, sizeof((vis)));\n        dfs1(a, i);\n        if (vis[b]) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<pair<int, int>> v[101];\nbool connected[101][101][101];\nbool visited[101];\nvoid dfs(int start, int node, int color) {\n  int i;\n  visited[node] = true;\n  if (start != node) connected[start][node][color] = true;\n  for (i = 0; i < v[node].size(); i++) {\n    if (visited[v[node][i].first] == true) continue;\n    if (color == v[node][i].second)\n      dfs(start, v[node][i].first, v[node][i].second);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int i, j, a, b, c;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    v[a].emplace_back(b, c);\n    v[b].emplace_back(a, c);\n  }\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      dfs(i, i, j);\n      memset(visited, false, sizeof(visited));\n    }\n  }\n  int q, u, v;\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    cin >> u >> v;\n    int cnt = 0;\n    for (j = 1; j <= m; j++) {\n      if (connected[u][v][j] == true) cnt++;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class B {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<Integer>[][] a = new List[n][n];\n        boolean[] used = new boolean[n];\n        for (int i = 0; i < m; i++) {\n            int f = sc.nextInt() - 1;\n            int to = sc.nextInt() - 1;\n            int c = sc.nextInt();\n            if (a[f][to] == null) {\n                a[f][to] = new LinkedList<Integer>();\n                a[to][f] = new LinkedList<Integer>();\n            }\n            a[f][to].add(c);\n            a[to][f].add(c);\n        }\n        int q = sc.nextInt();\n        for (int i = 0; i < q; i++) {\n            System.out.println(solve(a, used, sc.nextInt() - 1, sc.nextInt() - 1));\n        }\n    }\n    \n    private static int solve(List<Integer>[][] a, boolean[] used, int f, int to) {\n        Set<Integer> res = new HashSet<Integer>();\n        for (int i = 0; i < a.length; i++) {\n            if (a[f][i] != null) {\n                for (int c : a[f][i]) {\n                    if (!res.contains(c)) {\n                        Arrays.fill(used, false);\n                        used[f] = true;\n                        used[i] = true;\n                        if (dfs(a, used, i, to, c)) {\n                            res.add(c);\n                        }\n                    }\n                }\n            }\n        }\n        return res.size();\n    }\n\n    private static boolean dfs(List<Integer>[][] a, boolean[] used, int f, int to, int c) {\n        if (to == f) {\n            return true;\n        }\n        for (int i = 0; i < a.length; i++) {\n            if (!used[i] && a[f][i] != null) {\n                for (int cur : a[f][i]) {\n                    if (cur == c) {\n                        used[i] = true;\n                        boolean res = dfs(a, used, i, to, c);\n                        if (res) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    \n}\n"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n \n# Universidade Federal de Campina Grande\n# Aluno: Diego Adolfo Silva de Ara\u00fajo\n# Matricula: 113210090\n# Disciplina: Algoritmos Avan\u00e7ados\n\n# Codeforces \n# Problem: 505B - B. Mr. Kitayuta's Colorful Graph\n# Time limit per test: 1 second\n# Memory limit per test: 256 megabytes\n# Input: standard input\n# Output: standard output\n\ndef answer(start, end):\n    count = 0\n    global graph\n    \n    for key in graph:\n        if u not in graph[key] or v not in graph[key]:\n            continue\n        \n        if list([path for path in dfs_paths(graph[key], start, end, [])]):\n            count += 1\n    \n    return count\n\ndef dfs_paths(graph, start, end, path):\n    if not path:\n        path.append(start)\n    \n    if start == end:\n        yield path\n    \n    for vertex in graph[start] - set(path):\n        for key in dfs_paths(graph, vertex, end, path + [vertex]):\n            yield key\n\n        \n\ngraph = {}      \nn, m = map(int, raw_input().split())\n\nfor value in xrange(m):\n    vertex, edge, color = map(int, raw_input().split())\n    \n    if not graph.has_key(color):\n        graph[color] = {}\n    \n    if not graph[color].has_key(edge):\n        graph[color][edge] = set()\n    \n    if not graph[color].has_key(vertex):\n        graph[color][vertex] = set()\n       \n    graph[color][edge].add(vertex) \n    graph[color][vertex].add(edge)\n\nnum_queries = int(raw_input())\n\nfor line in xrange(num_queries):\n    u, v = map(int, raw_input().split())\n    print answer(u, v)"
        },
        {
            "language": 3,
            "solution": "n,m = [int(x) for x in input().split()]\nedge = {}\nfor i in range (1,n+1):\n\tedge[i] = {}\n\tfor j in range (1,m+1):\n\t\tedge[i][j] = []\nfor i in range (m):\n\ta,b,c = [int(x) for x in input().split()]\n\tedge[a][c].append(b)\n\tedge[b][c].append(a)\nq = int(input())\nfor i in range (q):\n\tu,v = [int(x) for x in input().split()]\n\tcount = 0\n\tfor key in edge[u]:\n\t\tlevel = {u:0}\n\t\tfrontier = [u]\n\t\tfound = False\n\t\twhile frontier and not found:\n\t\t\tnext = []\n\t\t\tfor uu in frontier:\n\t\t\t\tfor vv in edge[uu][key]:\n\t\t\t\t\tif not(vv in level):\n\t\t\t\t\t\tif vv == v:\n\t\t\t\t\t\t\tfound = True\n\t\t\t\t\t\tlevel[vv] = 0\n\t\t\t\t\t\tnext.append(vv)\n\t\t\tfrontier = next\n\t\tif(found):\n\t\t\tcount += 1\n\tprint (count)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n    static boolean[] visited = new boolean[101];\n    static HashSet<Integer>[][] edges = new HashSet[101][101];\n    static ArrayList<Integer>[] adj = new ArrayList[101];\n\n    public static void main(String[] args) throws Exception {\n        long startTime = System.nanoTime();\n        int n = in.nextInt();\n        int m = in.nextInt();\n        ArrayList<DisjointSet<Integer>> ds = new ArrayList<>();\n        for (int i = 0; i < 101; i++) {\n            adj[i] = new ArrayList<Integer>();\n            ds.add(new DisjointSet<Integer>(new HashMap<Integer, Integer>()));\n            for (int j = 0; j < 101; j++) {\n                edges[i][j] = new HashSet<Integer>();\n            }\n        }\n\n        // Creation\n\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            ds.get(c).Union(a, b);\n        }\n\n        int q = in.nextInt();\n        while (q-- > 0) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int ans = 0;\n            for (int i = 1; i <= 100; i++) {\n                if (ds.get(i).Find(u) == ds.get(i).Find(v)) {\n                    ans++;\n                }\n            }\n\n            out.println(ans);\n        }\n        long endTime = System.nanoTime();\n        err.println(\"Execution Time : +\" + (endTime - startTime) / 1000000 + \" ms\");\n        exit(0);\n    }\n\n    static boolean dfs(int start, int end, int col) {\n        visited[start] = true;\n        if (start == end) {\n            return true;\n        }\n        for (int e : adj[start]) {\n            for (int c : edges[start][e]) {\n                if (col == c && !visited[e]) {\n                    if (dfs(e, end, c)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    // Disjoint Set Data Structure with path compression. Generic Class\n\n    static class DisjointSet<T> {\n        Map<T, T> data;\n        Map<T, Integer> rank;\n\n        public DisjointSet(Map<T, T> data) {\n            this.data = data;\n            rank = new HashMap<T, Integer>();\n        }\n\n        public void MakeSet(T a) {\n            data.put(a, a);\n            rank.put(a, 0);\n        }\n\n        public T Find(T a) {\n            if (data.get(a) == null) {\n                MakeSet(a);\n                return a;\n            }\n            if (data.get(a).equals(a)) {\n                return a;\n            } else {\n                T temp = Find(data.get(a));\n                data.put(a, temp);\n                return temp;\n            }\n        }\n\n        public void Union(T x, T y) {\n            T xRoot = Find(x);\n            T yRoot = Find(y);\n            if (xRoot.equals(yRoot)) {\n                return;\n            }\n            if (rank.get(xRoot) < rank.get(yRoot)) {\n                data.put(yRoot, xRoot);\n            } else if (rank.get(xRoot) > rank.get(yRoot)) {\n                data.put(xRoot, yRoot);\n            } else {\n                data.put(xRoot, yRoot);\n                rank.put(xRoot, rank.get(xRoot) + 1);\n            }\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static void exit(int a) {\n        out.close();\n        err.close();\n        System.exit(a);\n    }\n\n    static InputStream inputStream = System.in;\n    static OutputStream outputStream = System.out;\n    static OutputStream errStream = System.err;\n    static InputReader in = new InputReader(inputStream);\n    static PrintWriter out = new PrintWriter(outputStream);\n    static PrintWriter err = new PrintWriter(errStream);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100003;\nint n, m;\nvector<unordered_set<int> > colores;\nvector<unordered_map<int, int> > cual;\nmap<pair<int, int>, int> queries;\nint rep(int v, int col) {\n  if (cual[col][v] != v) cual[col][v] = rep(cual[col][v], col);\n  return cual[col][v];\n}\nvoid unir(int u, int v, int col) { cual[col][rep(u, col)] = rep(v, col); }\nint query(int u, int v) {\n  if (queries.find({u, v}) != queries.end()) return queries[{u, v}];\n  int ans = 0;\n  for (int col : colores[u])\n    if (colores[v].find(col) != colores[v].end() and\n        cual[col][u] == cual[col][v])\n      ++ans;\n  return queries[{u, v}] = ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  colores = vector<unordered_set<int> >(n, unordered_set<int>());\n  cual = vector<unordered_map<int, int> >(MAXN, unordered_map<int, int>());\n  vector<pair<int, int> > que;\n  que.reserve(2 * n);\n  for (int i = 0; i < m; ++i) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    --u, --v;\n    que.push_back({u, c});\n    que.push_back({v, c});\n    colores[u].insert(c), colores[v].insert(c);\n    if (cual[c].find(u) == cual[c].end()) cual[c][u] = u;\n    if (cual[c].find(v) == cual[c].end()) cual[c][v] = v;\n    unir(u, v, c);\n  }\n  for (auto q : que) rep(q.first, q.second);\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    if (colores[u].size() > colores[v].size()) swap(u, v);\n    cout << query(u, v) << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "def find(c,x):\n\tif reach[c][x]==x:\n\t\treturn x\n\telse:\n\t\treach[c][x]=find(c,reach[c][x])\n\t\treturn reach[c][x]\n\ndef connect(c,a,b):\n\taa=find(c,a)\n\tbb=find(c,b)\n\tif aa==bb:\n\t\treturn\n\telse:\n\t\treach[c][aa]=reach[c][bb]\n\nglobal reach\nreach=[[j for j in range(200)] for i in range(200)]\n\n[n,m]=[int(n) for n in raw_input().split(' ')]\nfor i in range(m):\n\t[a,b,c]=[int(n) for n in raw_input().split(' ')]\n\tconnect(c,a,b)\n\nq=int(raw_input())\nfor i in range(q):\n\tcount=0\n\t[u,v]=[int(n) for n in raw_input().split(' ')]\n\tfor j in range(m+1):\n\t\ta=find(j,u)\n\t\tb=find(j,v)\n\t\tif a==b:\n\t\t\tcount+=1\n\tprint count"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TB {\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner in=new FastScanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint i,j,n,m,a,b,c,q,u,v;\n\t\tn=in.nextInt();\n\t\tm=in.nextInt();\n\t\tboolean[][][] g=new boolean[n+1][n+1][101];\n\t\t\n\t\tfor(i=0;i<m;i++){\n\t\t\ta=in.nextInt();\n\t\t\tb=in.nextInt();\n\t\t\tc=in.nextInt();\n\t\t\tg[a][b][c]=true;\n\t\t\tg[b][a][c]=true;\n\t\t}\n\t\tq=in.nextInt();\n\t\tfor(i=0;i<q;i++){\n\t\t\tu=in.nextInt();\n\t\t\tv=in.nextInt();\n\t\t\tint res=0;\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tboolean[] visited=new boolean[n+1];\n\t\t\t\tif(dfs(u, v, n, g, visited,j))\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic boolean dfs(int u,int v,int n,boolean[][][] g,boolean[] visited,int color){\n\t\tvisited[u]=true;\n\t\tif(u==v){\n\t\t\treturn true;\n\t\t}\n\t\tboolean res=false;\n\t\tfor(int i=1;i<n+1;i++){\n\t\t\tif(i!=u&&!visited[i]&&g[u][i][color]){\n\t\t\t\tres=dfs(i, v, n, g, visited, color);\n\t\t\t\tif(res)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic class FastScanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(){br=new BufferedReader(new InputStreamReader(System.in));}\n\t\tString nextToken(){\n\t\t\twhile(st==null||!st.hasMoreElements())\n\t\t\t\ttry{st=new StringTokenizer(br.readLine());}catch(Exception e){}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt(){return Integer.parseInt(nextToken());}\n\t\tlong nextLong(){return Long.parseLong(nextToken());}\n\t\tdouble nextDouble(){return Double.parseDouble(nextToken());}\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom collections import Counter\n\ndef mi(s):\n    return map(int, s.strip().split())\n\ndef lmi(s):\n    return list(mi(s))\n\ndef mf(f, s):\n    return map(f, s)\n\ndef lmf(f, s):\n    return list(mf(f, s))\n\ndef path(graph, u, v, color, visited):\n    if u == v:\n        return True\n    elif u in visited:\n        return False\n\n    visited.add(u)\n    for child, c in graph[u]:\n        if color == c and path(graph, child, v, color, visited):\n            return True\n    return False\n\ndef main(graph, queries, colors):\n    ans = []\n    for u, v in queries:\n        c = 0\n        for color in colors:\n            if path(graph, u, v, color, set()):\n                c += 1\n        ans.append(c)\n\n    for n in ans:\n        print(n)\n\nif __name__ == \"__main__\":\n    queries = []\n    colors = set()\n    for e, line in enumerate(sys.stdin.readlines()):\n        if e == 0:\n            n, ed = mi(line)\n            graph = defaultdict(list)\n            for i in range(1, n + 1):\n                graph[i]\n            k = 0\n        elif ed > 0:\n            a, b, c = mi(line)\n\n            # Undirected graph.\n            graph[a].append((b, c))\n            graph[b].append((a, c))\n            colors.add(c)\n            ed -= 1\n        elif ed == 0:\n            ed -= 1\n            continue\n        else:\n            queries.append(lmi(line))\n    main(graph, queries, colors)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputReader in = new InputReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int test_cases = 1;\n        Solver s = new Solver();\n        for (int i = 1; i <= test_cases; i++) {\n            s.solve(i, in, out);\n        }\n        out.close();\n    }\n}\n\nclass Solver {\n    static class Pair {\n        int edge, color;\n\n        Pair(int e, int c) {\n            edge = e;\n            color = c;\n        }\n    }\n    ArrayList<Pair>[] v;\n    int ans = 0;\n    boolean[] visited;\n    void solve(int test_number, InputReader in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        v = new ArrayList[n];\n        visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            v[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < m; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            int c = in.nextInt();\n            v[x].add(new Pair(y, c));\n            v[y].add(new Pair(x, c));\n        }\n        int q = in.nextInt();\n        for (int hh = 0; hh < q; hh++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            ans = 0;\n            int tt = 0;\n            HashSet<Integer> colors = new HashSet<>();\n            for (int i = 0; i < v[x].size(); i++) {\n                if (colors.contains(v[x].get(i).color)) continue;\n                Arrays.fill(visited, false);\n                visited[x] = true;\n                dfs(x, y, v[x].get(i).edge, v[x].get(i).color);\n                if (ans != tt) {\n                    colors.add(v[x].get(i).color);\n                    tt = ans;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    private void dfs(int start, int end, int current, int color) {\n        if (end == current) {\n            ++ans;\n        }\n        visited[current] = true;\n        for (Pair x : v[current]) {\n            if (x.color == color && !visited[x.edge]) {\n                dfs(start, end, x.edge, color);\n            }\n        }\n    }\n}\n\n\nclass InputReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public InputReader()\n    {\n        br = new BufferedReader(new\n                InputStreamReader(System.in));\n    }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try\n            {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException  e)\n            {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try\n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\n\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\nimport javafx.scene.layout.Priority;\n\npublic class Soly {\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        try (PrintWriter or = new PrintWriter(System.out)) {\n                int n =in.nextInt(),m=in.nextInt();\n                DJSU[] ds= new DJSU[m];\n               for (int i = 0; i < m; i++) ds[i]=new DJSU(n);\n            \n                for (int i = 1; i <= m; i++) {\n                 int a=in.nextInt()-1,b=in.nextInt()-1,c=in.nextInt()-1;\n                 ds[c].merge(a, b);\n            }\n                int q=in.nextInt();\n                \n                while (q-->0) {         \n                    int ans=0;\n                int u=in.nextInt()-1,v=in.nextInt()-1;\n                    for (int i = 0; i < m; i++)if(ds[i].sameset(u, v))++ans;\n                    or.println(ans);\n            }\n                \n        }\n    }\n\n    static class DJSU {\n        int[] size;\n        public DJSU(int n) {\n            size=new int[n+1];\n            Arrays.fill(size, -1);\n        }\n        int find(int x){\n            if(size[x]<0)return x;\n            return size[x]=find(size[x]);\n        }\n        void merge(int a,int b){\n            int ra=find(a);int rb=find(b);\n            if(ra==rb)return;\n            if(size[ra]<size[rb]){\n                size[ra]+=size[rb];\n                size[rb]=ra;\n            }\n            else{\n                 size[rb]+=size[ra];\n                size[ra]=rb;\n            }\n        }\n        boolean sameset(int a,int b){\n             int ra=find(a);int rb=find(b);\n            if(ra==rb)return true;\n            return false;\n        }\n\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++) {\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec) {\n                        f *= 10;\n                    }\n                }\n            }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n}\n\nclass Pair8 {\n\n    int index;\n    long value;\n\n    // int min;\n    public Pair8(int index, long value) {\n        this.value = value;\n        this.index = index;\n        //min = m;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans;\nint n, m, q;\nint a, b, c;\nstruct st {\n  int P[110];\n  int sz[110];\n  void init() {\n    for (int i = 1; i <= n; i++) P[i] = i, sz[i] = 1;\n  }\n  int ata(int x) {\n    if (x == P[x]) return x;\n    return P[x] = ata(P[x]);\n  }\n  void uni(int x, int y) {\n    x = ata(x);\n    y = ata(y);\n    if (x == y) return;\n    if (sz[x] < sz[y]) swap(x, y);\n    sz[x] += sz[y], sz[y] = 0, P[y] = x;\n  }\n} T[110];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= 100; i++) T[i].init();\n  for (int i = 1; i <= m; i++) {\n    cin >> a >> b >> c;\n    T[c].uni(a, b);\n  }\n  cin >> q;\n  while (q--) {\n    cin >> a >> b;\n    int ans = 0;\n    for (int i = 1; i <= 100; i++) ans += (T[i].ata(a) == T[i].ata(b));\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\ndef DFS(d,a,visited):\n\n\tvisited[a] = 1\n\tif a in d:\n\t\tfor i in d[a]:\n\n\t\t\tif visited[i] == 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tDFS(d,i,visited)\n\n\nn,m = map(int,input().split())\n\nl = [defaultdict(list) for i in range(m+1)]\n\nfor i in range(m):\n\ta,b,c = map(int,input().split())\n\n\tl[c][a].append(b)\n\tl[c][b].append(a)\n\nq = int(input())\n\nfor i in range(q):\n\ta,b = map(int,input().split())\n\tr = 0\n\tfor j in l:\n\t\tvisited = [0 for i in range(n+1)]\n\t\t\n\t\tDFS(j,a,visited)\n\n\t\tif visited[a] == 1 and visited[b] == 1:\n\t\t\tr = r + 1\n\n\tprint(r)\n\n"
        },
        {
            "language": 3,
            "solution": "def solve():\n    def dfs(c):\n        if c == v:\n            return True\n\n        r = False\n\n        for i in range(1, n+1):\n            if g[w][c][i] and i not in p:\n                p[i] = c\n                r |= dfs(i)\n\n        return r\n\n    n, m = map(int, input().split())\n    g = [[[False for j in range(n+1)] for i in range(n+1)] for _ in range(m+1)]\n\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        g[w][u][v] = True\n        g[w][v][u] = True\n\n    for _ in range(int(input())):\n        u, v = map(int, input().split())\n        res = 0\n\n        for w in range(1, m+1):\n            p = dict()\n            p[u] = -1\n            res += dfs(u)\n\n        print(res)\n\nsolve()\n"
        },
        {
            "language": 1,
            "solution": "n,m=map(int,raw_input().split())\ncolour=[]\nfor i in range(m+1):\n    colour.append([])\n    for j in range(n+1):\n        colour[i].append([])\nfor i in range(1,m+1):\n    s,e,c=map(int,raw_input().split())\n    colour[c][s].append(e)\n    colour[c][e].append(s)\nq=input()\ndef dfs(s,e,c):\n    global colour,done\n    for i in range(len(colour[c][s])):\n        if e==colour[c][s][i]:\n            return 1\n        if colour[c][s][i] not in done:\n            done.append(colour[c][s][i])\n            if dfs(colour[c][s][i],e,c)==1:\n                return 1\n    return 0\nfor i in range(q):\n    ans=0\n    s,e=map(int,raw_input().split())\n    for j in range(1,m+1):\n        done=[s]\n        ans+=dfs(s,e,j)\n    print ans\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque\n\ndef bfs(g,s,c):\n    visited = set()\n    q = deque([s])\n    while len(q) > 0:\n        v = q.pop()\n        visited.add(v)\n        for adj,adj_c in g[v]:\n            if adj_c == c and adj not in visited and adj not in q:\n                q.append(adj)\n    return visited\n    \ndef con_components(g,c):\n    visited = set()\n    components = []\n    for s in g.keys():\n        if s not in visited:\n            nodes = bfs(g,s,c)\n            components.append(nodes)\n            visited |= nodes\n    return components\n\ndef main():\n    n,m = map(int, input().split())\n    g = defaultdict(list)\n    colors = set()\n    for _ in range(m):\n        a,b,c = map(int, input().split())\n        g[a].append((b,c))\n        g[b].append((a,c))\n        colors.add(c)\n    components = {c:con_components(g,c) for c in colors}\n    \n    q = int(input())\n    for _ in range(q):\n        u,v = map(int, input().split())\n        ct = 0\n        for c in colors:\n            for comp in components[c]:\n                if u in comp and v in comp:\n                    ct += 1\n        print(ct)\n    \n\nif __name__ == '__main__':\n    main()   "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int c1, n, m;\nbool check[int(10e5)];\nvector<pair<long long int, long long int>> v[int(10e5)];\nint ans;\nvoid flush() {\n  ans = 0;\n  for (int i = 0; i < 101; i++) check[i] = 0;\n}\nvoid dfs(long long int start, long long int end, long long int c) {\n  check[start] = 1;\n  if (start == end) {\n    ans = 1;\n  }\n  for (auto i : v[start]) {\n    if (!check[i.first] && c == i.second) dfs(i.first, end, c);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    long long int a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    v[b].push_back({a, c});\n  }\n  long long int q;\n  cin >> q;\n  while (q--) {\n    int x, y, count1 = 0;\n    cin >> x >> y;\n    for (int i = 1; i <= m; i++) {\n      dfs(x, y, i);\n      if (ans) {\n        count1++;\n      }\n      flush();\n    }\n    cout << count1 << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        int[][][] graph = new int[m+1][n+1][n+1];\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            graph[c][a][b] = 1;\n            graph[c][b][a] = 1;\n        }\n\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n\n            int count = 0;\n            for (int c = 1; c <= m; c++) {\n                boolean[] vis = new boolean[n+1];\n                if (dfs(u, v, c, vis, graph)) {\n                    count++;\n                }\n            }\n            out.println(count);\n        }\n    }\n\n\n    private boolean dfs(int u, int v, int c, boolean[] vis, int[][][] g) {\n        if (u == v) {\n            return true;\n        }\n\n        vis[u] = true;\n        for (int x = 1; x < g[0].length; x++) {\n            if (!vis[x] && g[c][u][x] == 1) {\n                if (dfs(x, v, c, vis, g)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new PrintWriter(System.out));\n       \n        String[] ln1 = br.readLine().split(\" \");\n        \n        int n = Integer.parseInt(ln1[0]);\n        int m = Integer.parseInt(ln1[1]);\n        \n        Graph G = new Graph(n,m);\n        \n        for(int i=0;i<m;i++){\n            \n            String[] ln2 = br.readLine().split(\" \");\n            \n            int a = Integer.parseInt(ln2[0]);\n            int b = Integer.parseInt(ln2[1]);\n            int c = Integer.parseInt(ln2[2]);\n            \n            G.addEdge(a,b,c);\n            G.addEdge(b,a,c);\n        }\n        \n        int Q = Integer.parseInt(br.readLine());\n        for(int q=0;q<Q;q++){\n            String[] ln3 = br.readLine().split(\" \");\n            \n            int u = Integer.parseInt(ln3[0]);\n            int v = Integer.parseInt(ln3[1]);\n            u-=1;v-=1;\n            \n            int ct = 0;\n            \n            for(int i=1;i<=100;i++){\n                \n                int[] seen = new int[n];\n                \n                if(G.dfs(u,i,v,seen))  ct++;\n            }\n            \n            System.out.println(ct);\n            \n        }\n        \n        //G.check();\n        \n        \n    }\n\n    \n\n    private static class Graph {\n\n        int[] last;\n        int[] to;\n        int[] next;\n        int[] color;\n        \n        int edgeId = -1;\n        \n        int cnt=-1;\n        boolean yes = false;\n        int c = -1;\n        int p = -1;\n        int root = -1;\n        private int end;\n        \n        public Graph(int n,int m) {\n            this.last = new int[n];\n            this.to=new int[200*m];\n            this.next=  new int[200*m];\n            this.color = new int[200*m];\n            for(int i=0;i<n;i++){\n                this.last[i] = -1;\n            }\n            \n        }\n\n        private void addEdge(int a, int b, int c) {\n            \n            a-=1;b-=1;\n            this.edgeId+=1;\n            this.to[edgeId] = b;\n            this.next[edgeId] = this.last[a];\n            this.last[a] = edgeId;\n            this.color[edgeId] = c;\n        }\n\n        private void dfss() {\n            \n            int[] seen = new int[this.last.length];\n            \n            for(int i=0;i<seen.length;i++){\n                if(seen[i]==0){\n                    \n                    seen[i]=1;\n                    for(int id = last[i]; id!=-1; id=next[id]){\n                        int v = to[id];\n                        //System.out.println(\"From \"+i+\" to \"+v+\" with color of \"+color[id]);\n                    }\n                }\n            }\n        }\n\n        private void check(int u, int v) {\n            \n            int[] seen = new int[this.last.length];\n            \n           // System.out.println(\"Starting with \"+u+\" Destination is \"+v);\n            \n            this.cnt = 0;\n            this.p=u;\n            checkUtil(u,v,seen);\n           // System.out.println(\"Made \"+this.cnt);\n            System.out.println(this.cnt);\n           // System.exit(0);\n        }\n\n        private void checkUtil(int u,int v, int[] seen) {\n            \n            seen[u]=1;\n            \n           \n            for(int id=last[u]; id!=-1; id=next[id]){\n                \n                int s = this.to[id];\n                \n                if(this.p==u)   this.c=-1;\n                \n                int c = this.color[id];\n                \n                if(this.c == -1){\n                    \n                    this.c = c;\n                    \n                    //System.out.println(\"Changed color to \"+c);\n                    \n                }\n                \n                if(s==v && this.c==c){\n                    this.cnt+=1;seen[s]=1;\n                }\n                \n                else if(s!= v && seen[s]==0 && this.c==c){\n                    \n                   // System.out.println(\"traversing edges \");\n                    \n                    checkUtil(s,v,seen);\n                }\n                \n                \n            }\n            \n            \n            \n        }\n\n        \n\n        private void dfsUtil(int u, int[] seen) {\n           // System.out.println(\"on \"+u);\n            \n            seen[u]=1;\n            for(int id=last[u];id!=-1;id=next[id]){\n                \n                if(this.root == u){//init\n                    //System.out.println(\"starting over with root color destination \"+u+\" \"+this.color[id]+\" \"+this.end);\n                    this.c = this.color[id];\n                    seen = new int[this.last.length];\n                    seen[u]=1;\n                }\n                \n                int v = to[id];\n                //System.out.println(\"connection to \"+v);\n                if(seen[v]==1)  continue;\n                if(v==this.end && seen[v]==0 && this.color[id]==this.c){\n                    //System.out.println(\"success at \"+root+\" \"+v+\" with color \"+this.color[id]);\n                    this.cnt+=1;\n                    //System.out.println(\"reached destination\");\n                   // return;\n                }\n                \n                dfsUtil(v,seen);\n            }\n        }\n\n        private boolean dfs(int u, int col, int dst, int[] seen) {\n            \n            seen[u]=1;\n            if(u==dst)  return true;\n            for(int id=this.last[u]; id!=-1; id=this.next[id]){\n                int v =this.to[id];\n                if(this.color[id]==col && seen[v]==0){\n                    if(dfs(v,col,dst,seen))return true;\n                }\n            }\n            \n            return false;\n        }\n    }//graph class\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k;\nvoid A();\nvoid B();\nvoid C();\nvoid D();\nvoid E();\nint main() {\n  B();\n  return 0;\n}\nstruct edge {\n  int to, w;\n  edge(int to, int w) : to(to), w(w) {}\n};\nvector<edge> graph[101];\nint vst[101];\nbool dfs(int node, int dest, int col) {\n  if (node == dest) return true;\n  vst[node] = 1;\n  for (int i = 0; i < (int)graph[node].size(); i++) {\n    edge to = graph[node][i];\n    if (!vst[to.to] && col == to.w) {\n      if (dfs(to.to, dest, col)) return true;\n    }\n  }\n  return false;\n}\nvoid B() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  int a, b, c;\n  for (i = 0; i <= m - 1; i++) {\n    scanf(\"%d %d\", &a, &b);\n    scanf(\"%d\", &c);\n    graph[a].push_back(edge(b, c));\n    graph[b].push_back(edge(a, c));\n  }\n  int color[m + 1];\n  int dp[n + 1][n + 1];\n  memset(dp, -1, sizeof dp);\n  int q;\n  scanf(\"%d\", &q);\n  for (i = 0; i <= q - 1; i++) {\n    scanf(\"%d %d\", &a, &b);\n    if (dp[a][b] == -1) {\n      for (j = 0; j <= m; j++) color[j] = 0;\n      int ans = 0;\n      for (j = 0; j <= (int)graph[a].size() - 1; j++) {\n        if (color[graph[a][j].w] == 0) {\n          for (k = 0; k <= n; k++) vst[k] = 0;\n          if (dfs(graph[a][j].to, b, graph[a][j].w)) {\n            color[graph[a][j].w] = 1;\n            ans++;\n          }\n        }\n      }\n      printf(\"%d\\n\", ans);\n      dp[a][b] = dp[b][a] = ans;\n    } else\n      printf(\"%d\\n\", dp[a][b]);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\n\ngraphs = [[[] for _ in range(n)] for _ in range(m)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graphs[c - 1][a - 1].append(b - 1)\n    graphs[c - 1][b - 1].append(a - 1)\n\nused = None\n\n\ndef dfs(vertex, color):\n    used[vertex] = True\n    for nei in graphs[color][vertex]:\n        if not used[nei]:\n            dfs(nei, color)\n\n\nq = int(input())\n\nfor _ in range(q):\n    u, v = map(int, input().split())\n    c = 0\n    for _color in range(m):\n        used = [False] * n\n        dfs(u - 1, _color)\n        if used[v - 1]:\n            c += 1\n    print(c)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.lang.Math.*;\npublic class Main {\n    static Vertice [] node ;\n    static int[] value ;\n    static int[] visited ;\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        node = new Vertice[n+1];\n        for(int i=1;i<=n;i++){\n            node[i] = new Vertice(m);\n        }\n        for(int i =0;i<m;i++){\n            int a= in.nextInt();\n            int b= in.nextInt();\n            int c = in.nextInt();\n            node[a].connected[c].add(b);\n            node[b].connected[c].add(a);\n        }\n        int q = in.nextInt();\n        for(int i=0;i<q;i++){\n            value = new int[n+1];\n            int a = in.nextInt();\n            int b = in.nextInt();\n            LinkedList<Integer> queue = new LinkedList<>();\n            for(int j =1;j<=m;j++){\n                if(node[a].connected[j].size()>0){\n                    visited = new int[n+1];\n                    visited[a]=1;\n                    dfs(a,j);\n                }\n\n            }\n            out.println(value[b]);\n        }\n        out.close();\n    }\n    static class Vertice{\n        ArrayList<Integer>[] connected ;\n        private Vertice(int m){\n            connected = new ArrayList[m+1];\n            for(int i=0;i<=m;i++){\n                connected[i] = new ArrayList<>();\n            }\n        }\n    }\n    static void dfs(int ids ,int color){\n        value[ids]+=1;\n        for(int v:node[ids].connected[color]){\n            if (visited[v]==0){\n                visited[v]=1;\n                dfs(v,color);\n            }\n        }\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> vec_splitter(string s) {\n  s += ',';\n  vector<string> res;\n  while (!s.empty()) {\n    res.push_back(s.substr(0, s.find(',')));\n    s = s.substr(s.find(',') + 1);\n  }\n  return res;\n}\nvoid debug_out(vector<string> __attribute__((unused)) args,\n               __attribute__((unused)) int idx,\n               __attribute__((unused)) int LINE_NUM) {\n  cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n  if (idx > 0)\n    cerr << \", \";\n  else\n    cerr << \"Line(\" << LINE_NUM << \") \";\n  stringstream ss;\n  ss << H;\n  cerr << args[idx] << \" = \" << ss.str();\n  debug_out(args, idx + 1, LINE_NUM, T...);\n}\nint gcd(int a, int b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nint lcm(int a, int b) { return (a * b) / gcd(a, b); }\nint dx8[] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy8[] = {1, -1, 1, -1, 0, 0, -1, 1};\nint dx4[] = {0, 0, 1, -1};\nint dy4[] = {1, -1, 0, 0};\nconst long long MOD = 1000000007;\ndouble sq(double x) { return x * x; }\ntemplate <typename T>\ninline T Bigmod(T base, T power, T MOD) {\n  T ret = 1;\n  while (power) {\n    if (power & 1) ret = (ret * base) % MOD;\n    base = (base * base) % MOD;\n    power >>= 1;\n  }\n  return ret;\n}\ninline void normal(long long &a) {\n  a %= MOD;\n  (a < 0) && (a += MOD);\n}\ninline long long modMul(long long a, long long b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  return (a * b) % MOD;\n}\ninline long long modAdd(long long a, long long b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  return (a + b) % MOD;\n}\ninline long long modSub(long long a, long long b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  a -= b;\n  normal(a);\n  return a;\n}\ninline long long modPow(long long b, long long p) {\n  long long r = 1;\n  while (p) {\n    if (p & 1) r = modMul(r, b);\n    b = modMul(b, b);\n    p >>= 1;\n  }\n  return r;\n}\ninline long long modInverse(long long a) { return modPow(a, MOD - 2); }\ninline long long modDiv(long long a, long long b) {\n  return modMul(a, modInverse(b));\n}\nbool sortinrev(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.first > b.first);\n}\nconst int maxn = 104;\nvector<int> edj[maxn][maxn];\nvoid solution() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edj[a][c].push_back(b);\n    edj[b][c].push_back(a);\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n      queue<int> q;\n      q.push(a);\n      int vis[maxn];\n      memset(vis, 0, sizeof(vis));\n      vis[a] = 1;\n      bool got = 0;\n      while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int j = 0; j < (int)edj[u][i].size(); j++) {\n          int v = edj[u][i][j];\n          if (vis[v] == 0) {\n            if (v == b) {\n              got = 1;\n              break;\n            }\n            q.push(v);\n            vis[v] = 1;\n          }\n        }\n        if (got) {\n          break;\n        }\n      }\n      if (got) ans++;\n    }\n    cout << ans << endl;\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  int t;\n  t = 1;\n  while (t--) {\n    solution();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class R286D2B {\n    private static final String LNSP = System.getProperty(\"line.separator\");\n    private static final int INF = (int) (1e9);\n\n    public static void main(String args[]) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        String[] tokens;\n        line = br.readLine();\n        tokens = line.split(\" \");\n        int n = Integer.parseInt(tokens[0]);\n        int m = Integer.parseInt(tokens[1]);\n        int[] a = new int[m];\n        int[] b = new int[m];\n        int[] c = new int[m];\n        for (int i = 0; i < m; i++) {\n            line = br.readLine();\n            tokens = line.split(\" \");\n            a[i] = Integer.parseInt(tokens[0]) - 1;\n            b[i] = Integer.parseInt(tokens[1]) - 1;\n            c[i] = Integer.parseInt(tokens[2]) - 1;\n        }\n        line = br.readLine();\n        tokens = line.split(\" \");\n        int q = Integer.parseInt(tokens[0]);\n        int[] u = new int[q];\n        int[] v = new int[q];\n        for (int i = 0; i < q; i++) {\n            line = br.readLine();\n            tokens = line.split(\" \");\n            u[i] = Integer.parseInt(tokens[0]) - 1;\n            v[i] = Integer.parseInt(tokens[1]) - 1;\n        }\n\n        int[] ret = new int[q];\n        for (int j = 0; j < m; j++) {   // for each color\n            int[][] dist = getDistanceMatrix(n);\n            for (int i = 0; i < m; i++) {\n                if (c[i] == j) {\n                    dist[a[i]][b[i]] = 1;\n                    dist[b[i]][a[i]] = 1;\n                }\n            }\n            warshallFloyd(dist);\n            for (int i = 0; i < q; i++) {   // for each q\n                if (dist[u[i]][v[i]] != INF) {\n                    ++ret[i];\n                }\n            }\n        }\n        System.out.println(Arrays.toString(ret).replaceAll(\"[\\\\[\\\\]]\", \"\").replaceAll(\", \", LNSP));\n    }\n\n    private static void warshallFloyd(int[][] dist) {\n        int n = dist.length;\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n\n    private static int[][] getDistanceMatrix(int n) {\n        int[][] ret = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                ret[i][j] = INF;\n            }\n        }\n        return ret;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nconst long long MAX = 101;\nconst double PI = 3.1415926;\nclass Disjoint_Sets {\n public:\n  long long* parent;\n  long long* size;\n  long long n;\n  void Initialise() {\n    parent = new long long[n];\n    size = new long long[n];\n    for (int i = 0; i < n; i++) parent[i] = i;\n    for (int i = 0; i < n; i++) size[i] = 1;\n  }\n  void merge(long long a, long long b) {\n    long long parent_a = find(a);\n    long long parent_b = find(b);\n    if (parent_a == parent_b) return;\n    if (size[parent_a] < size[parent_b]) {\n      parent[parent_a] = parent_b;\n      size[parent_b] += size[parent_a];\n      size[parent_a] = 0;\n    } else {\n      parent[parent_b] = parent_a;\n      size[parent_a] += size[parent_b];\n      size[parent_b] = 0;\n    }\n  }\n  long long find(long long a) {\n    if (parent[a] == a) {\n      return a;\n    }\n    parent[a] = find(parent[a]);\n    return parent[a];\n  }\n};\nDisjoint_Sets allColor[MAX];\nint N, m;\nvector<pair<long long, long long> > adj[MAX];\nbool visited[MAX];\nvoid dfs(long long s) {\n  visited[s] = 1;\n  for (pair<long long, long long> x : adj[s]) {\n    allColor[x.second].merge(s, x.first);\n    if (!visited[x.first]) dfs(x.first);\n  }\n}\nvoid dfsPre() {\n  for (int i = 0; i < N; ++i)\n    if (!visited[i]) dfs(i);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> m;\n  memset(visited, 0, sizeof(visited));\n  for (int i = 0; i < MAX; ++i) {\n    allColor[i].n = N;\n    allColor[i].Initialise();\n  }\n  for (int i = 0; i < m; ++i) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    x--;\n    y--;\n    c--;\n    adj[x].push_back(make_pair(y, c));\n    adj[y].push_back(make_pair(x, c));\n  }\n  dfsPre();\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    int counter = 0;\n    for (int j = 0; j < MAX; ++j)\n      if (allColor[j].find(x) == allColor[j].find(y)) counter++;\n    cout << counter << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\ndef connectedComponents(root, visited, graph, c, comp):\n    visited[root] = 1\n    comp[root] = c\n    for i in graph[root]:\n        if visited[i] == 0:\n            connectedComponents(i, visited, graph, c, comp)\n    return\n\nn, m = map(int, input().split())\ngraphs = [defaultdict(list) for i in range(m + 1)]\nvert = defaultdict(set)\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    graphs[c][u].append(v)\n    graphs[c][v].append(u)\n    vert[c].add(v)\n    vert[c].add(u)\n\ncomponents = [[0 for i in range(n + 1)]for i in range(m + 1)]\n\nfor i in range(1, m + 1):\n    c = 0\n    visited = [0 for i in range(n + 1)]\n    for r in graphs[i].keys():\n        if visited[r] == 0:\n            c += 1\n            connectedComponents(r, visited, graphs[i], c, components[i])\n\n# for i in components:\n#     print(i)\nq = int(input())\nfor i in range(q):\n    u, v = map(int, input().split())\n    ans = 0\n    for j in range(1, m + 1):\n        if components[j][u] == components[j][v] and components[j][u] != 0:\n            ans += 1\n    print(ans)"
        },
        {
            "language": 3,
            "solution": "v, e = map(int, input().split())\n\n\ngraphs = [ [set([i]) for i in range(1, v + 1)] for _ in range(101) ]\n\ndef getSet(sets, vertex):\n    for s in sets:\n        if vertex in s: return s\n\nfor _ in range(e):\n    a, b, c = map(int, input().split())\n    sa = getSet(graphs[c], a)\n    sb = getSet(graphs[c], b)\n    if sa.isdisjoint(sb):\n        sa |= sb\n        graphs[c].remove(sb)\n\nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n\n    c = 0\n    for graph in graphs:\n        sa = getSet(graph, a)\n        sb = getSet(graph, b)\n\n        if not sa.isdisjoint(sb): c += 1\n\n    print(c)"
        },
        {
            "language": 3,
            "solution": "f = lambda: map(int, input().split())\nn, m = f()\np = [list(range(n + 1)) for x in range(m + 1)]\ndef g(c, x):\n    if x != p[c][x]: p[c][x] = g(c, p[c][x])\n    return p[c][x]\nfor i in range(m):\n    a, b, c = f()\n    p[c][g(c, a)] = g(c, b)\nfor j in range(int(input())):\n    a, b = f()\n    print(sum(g(i, a) == g(i, b) for i in range(m + 1)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long M = 1e9 + 7;\nconst long long N = 1e3 + 10;\nconst long long IM = 1e15 + 37;\nconst long long PI = 3.14159265;\nvoid PV(vector<long long> v) {\n  for (long long i = 0; i < v.size(); i++) cout << v[i] << \" \";\n  cout << \"\\n\";\n}\nvoid PA(long long v[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cout << v[i] << \" \";\n  cout << \"\\n\";\n}\nvoid IN(long long a[], long long n, long long x = 0) {\n  for (long long i = x; i < n + x; i++) cin >> a[i];\n}\ninline void PP(long long n) { cout << n; }\ninline void PP(long long n, long long m) { cout << n << \" \" << m << \"\\n\"; }\ninline void PP(long long n, long long m, long long q) {\n  cout << n << \" \" << m << \" \" << q << \"\\n\";\n}\ninline void PP(long long n, long long m, long long q, long long u) {\n  cout << n << \" \" << m << \" \" << q << \" \" << u << \"\\n\";\n}\ninline void op() {}\nlong long n, k;\nvector<pair<long long, long long> > v[N];\nmap<pair<long long, long long>, long long> m;\nmap<long long, long long> z;\nlong long ans = 0;\nvoid dfs(long long x, long long y, long long col = -1) {\n  m[{x, col}]++;\n  if (x == y && z[col] == 0) {\n    ans++;\n    z[col]++;\n    return;\n  }\n  for (auto i : v[x]) {\n    long long f = i.first;\n    long long s = i.second;\n    if (col == -1) {\n      m[{x, s}]++;\n      dfs(f, y, s);\n    } else {\n      if (col == s && !m[{f, s}]) {\n        dfs(f, y, s);\n      }\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  op();\n  long long i, j, x, y, u, l;\n  {\n    i = j = x = y = u = l = 0;\n    cin >> n >> k;\n    for (long long i = 0; i < k; i++) {\n      cin >> x >> y >> u;\n      v[x].push_back({y, u});\n      v[y].push_back({x, u});\n    }\n    cin >> l;\n    while (l--) {\n      m.clear();\n      ans = 0;\n      z.clear();\n      cin >> x >> y;\n      dfs(x, y);\n      cout << (ans) << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nfrom collections import defaultdict\nimport itertools\n\nMAXNUM = math.inf\nMINNUM = -1 * math.inf\n\n\ndef getInt():\n    return int(sys.stdin.readline().rstrip())\n\n\ndef getInts():\n    return map(int, sys.stdin.readline().rstrip().split(\" \"))\n\n\ndef getString():\n    return sys.stdin.readline().rstrip()\n\n\ndef printOutput(ans):\n    sys.stdout.write()\n    pass\n\n\ndef dfs(a, b, edgeList):\n\n    total = 0\n    cLook = set()\n\n    for nxt, col in edgeList[a]:\n        if col not in cLook:\n            explored = dict()\n            explored[a] = True\n            explored[nxt] = True\n            if dfs_helper(nxt, b, edgeList, col, explored) == 1:\n                cLook.add(col)\n                total += 1\n\n    return total\n\n\ndef dfs_helper(cur, goal, edgeList, color, explored):\n\n    if cur == goal:\n        return 1\n\n    for nxt, col in edgeList[cur]:\n        if col == color and nxt not in explored:\n            explored[nxt] = True\n            if dfs_helper(nxt, goal, edgeList, color, explored) == 1:\n                return 1\n            del explored[nxt]\n\n    return 0\n\n\ndef solve(n, m, edgeList, queries):\n    for a, b in queries:\n        print(dfs(a, b, edgeList))\n\n\ndef readinput():\n    n, m = getInts()\n    edgeList = defaultdict(list)\n    for _ in range(m):\n        a, b, c = getInts()\n        edgeList[a].append((b, c))\n        edgeList[b].append((a, c))\n\n    queries = []\n    q = getInt()\n    for _ in range(q):\n        queries.append(tuple(getInts()))\n    (solve(n, m, edgeList, queries))\n\n\nreadinput()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class MrKitayutaColorfulGraph {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\n\t\tUnionFind[] s = new UnionFind[m];\n\t\tfor (int i = 0; i < m; i++)\n\t\t\ts[i] = new UnionFind(n);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint c = sc.nextInt() - 1;\n\t\t\ts[c].unionSet(u, v);\n\t\t}\n\n\t\tint q = sc.nextInt();\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint sum = 0;\n\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (s[j].isSameSet(u, v))\n\t\t\t\t\tsum++;\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] p;\n\t\tint[] rank;\n\n\t\tpublic UnionFind(int n) {\n\t\t\tp = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tint findSet(int i) {\n\t\t\treturn (p[i] == i) ? i : (p[i] = findSet(p[i]));\n\t\t}\n\n\t\tboolean isSameSet(int i, int j) {\n\t\t\treturn findSet(i) == findSet(j);\n\t\t}\n\n\t\tvoid unionSet(int i, int j) {\n\t\t\tif (!isSameSet(i, j)) {\n\t\t\t\tint x = findSet(i);\n\t\t\t\tint y = findSet(j);\n\n\t\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\t\tp[y] = x;\n\t\t\t\t} else {\n\t\t\t\t\tp[x] = y;\n\t\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\t\trank[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long vis[101] = {0};\nlong long d[212345] = {0};\nvector<vector<vector<long long> > > v(101, vector<vector<long long> >(101));\nvoid dfs(long long c, long long k) {\n  vis[k] = 1;\n  for (int i = 0; i < v[c][k].size(); i++)\n    if (!vis[v[c][k][i]]) dfs(c, v[c][k][i]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  long long a, b, c1;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b >> c1;\n    v[c1][a].push_back(b);\n    v[c1][b].push_back(a);\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    cin >> a >> b;\n    long long cnt = 0;\n    for (int i = 1; i < m + 1; i++) {\n      memset(vis, 0, sizeof vis);\n      ;\n      dfs(i, a);\n      if (vis[b]) cnt++;\n    }\n    cout << cnt << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v[102];\nbool mark[102], dp[102];\nint ans[102];\nvoid dfs(int x, int c) {\n  mark[x] = 1;\n  for (int i = 0; i < v[x].size(); i++) {\n    int child = v[x][i].first;\n    int col = v[x][i].second;\n    if (!mark[child] && col == c) {\n      dp[child] = 1;\n      dfs(child, c);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int fi, se, c;\n    cin >> fi >> se >> c;\n    v[se].push_back(make_pair(fi, c));\n    v[fi].push_back(make_pair(se, c));\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int fi, se;\n    cin >> fi >> se;\n    for (int j = 1; j <= m; j++) {\n      dfs(fi, j);\n      if (dp[se]) ans[i]++;\n      memset(mark, 0, sizeof mark);\n      memset(dp, 0, sizeof dp);\n    }\n  }\n  for (int i = 0; i < q; i++) cout << ans[i] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class TaskC {\n\n\n    static class Edge implements Comparable<Edge> {\n        int v,cost;\n\n\n        public Edge( int x, int y) {\n            this.v = x;\n            this.cost = y;\n        }\n\n        public int compareTo(Edge o) {\n            if (cost  == o.cost)\n                return v - o.v;\n            return v - o.v;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            Edge edge = (Edge) o;\n            return v == edge.v &&\n                   cost == edge.cost;\n        }\n\n\n        public String toString() {\n            return  v+\" \"+ cost;\n        }\n    }\n    static int n,h;\n    static long sum = 0;\n    static ArrayList<Edge>[]adjList;\n    static int reaches;\n    static boolean[]vis;\n    static HashSet<Integer> set;\n\n\n    static void dfs(int u ,int v, int c)\n    {\n        vis[u] = true;\n        if(u == v)\n        {\n            set.add(c);\n            vis[u] = false;\n            return;\n        }\n        for (Edge e : adjList[u])\n        {\n            if(c == -1)\n                dfs(e.v , v , e.cost);\n            else if(!vis[e.v] && e.cost == c)\n                dfs(e.v , v , c);\n        }\n        if(c != -1)\n            vis[u] = false;\n    }\n\n\n\n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        adjList = new ArrayList[n];\n        for (int i = 0 ; i < n ; i++)\n            adjList[i] = new ArrayList<>();\n\n        for (int i = 0 ; i < m ; i++)\n        {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            int c = sc.nextInt();\n\n            adjList[u].add(new Edge(v,c));\n            adjList[v].add(new Edge(u,c));\n\n        }\n\n\n        int q = sc.nextInt();\n\n        while (q-- > 0)\n        {\n\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n\n            vis = new boolean[n];\n\n            set = new HashSet<>();\n            dfs(u , v , -1);\n         //   System.out.println(set);\n            pw.println(set.size());\n        }\n        pw.close();\n    }\n    static class Point implements Comparable<Point>\n    {\n        int x ,y , idx;\n\n        public Point(int x, int y,int idx) {\n            this.x = x;\n            this.y = y;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            if (x == o.x) {\n                if (y == o.y)\n                    return idx - o.idx;\n                return y - o.y;\n            }\n            return x - o.x;\n        }\n\n        @Override\n        public String toString() {\n            return \"Point{\" +\n                    \"x=\" + x +\n                    \", y=\" + y +\n                    \", idx=\" + idx +\n                    '}';\n        }\n    }\n\n    static class Circle implements Comparable<Circle>\n    {\n        int x , radius;\n        public Circle(int x , int r)\n        {\n            this.x = x;\n            this.radius = r;\n        }\n\n        public boolean isInside(Point p)\n        {\n            return Math.sqrt((p.x - x)*(p.x - x) + (p.y)*(p.y)) <= radius;\n        }\n\n        @Override\n        public String toString() {\n            return \"Circle{\" +\n                    \"x=\" + x +\n                    \", radius=\" + radius +\n                    '}';\n        }\n\n        @Override\n        public int compareTo(Circle o) {\n            return x - o.x;\n        }\n    }\n\n    private static long gcd(long a, long b) {\n        if( b == 0)\n            return a;\n        return gcd(b  , a%b);\n    }\n\n    static long lcm(int a, int b)\n    {\n        return (a*b)/gcd(a, b);\n    }\n\n\n    private  static int dis(int xa , int ya , int xb , int yb)\n    {\n        return (xa-xb)*(xa - xb) + (ya- yb)*(ya-yb);\n    }\n\n\n    static class Pair implements Comparable<Pair> {\n        int x,y;\n\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            if (y  == o.y)\n                return x - o.x;\n            return y - o.y;\n\n        }\n\n        public double dis(Pair a){\n\n            return (a.x - x)*(a.x - x) + (a.y-y)*(a.y-y);\n        }\n\n        public String toString() {\n            return  x+\" \"+ y;\n        }\n        public boolean overlap(Pair a)\n        {\n            if((this.x >= a.x && this.x <= a.y) || (a.x >= this.x && a.x <= this.y)) return true;\n            return false;\n\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean check() {\n            if (!st.hasMoreTokens())\n                return false;\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public double nextDouble() {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() {\n            try {\n                return br.ready();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * FackBookCup A.problem Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        String str = in.next();\n        for(int i=0;i<=str.length();i++)\n        {\n            String tmp=str.substring(0,i);\n            String tmp1=str.substring(i,str.length());\n\n            //System.out.println(tmp1);\n            for(int j=0;j<26;j++)\n            {\n                String res=tmp+(char)('a'+j)+tmp1;\n                //System.out.println(res);\n                if(checkPalindrome(res))\n                {\n                    out.println(res);\n                    return ;\n                }\n            }\n        }\n        out.println(\"NA\");\n\n    }\n\n    public boolean checkPalindrome(String str) {\n        boolean flag = true;\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != str.charAt(str.length() - i - 1)) {\n                flag = false;\n            }\n\n        }\n        return flag;\n    }\n}\nclass TaskB {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int array[][][]=new int[110][110][110];\n        int n=in.nextInt();\n        int m=in.nextInt();\n        for(int i=0;i<m;i++){\n            int a=in.nextInt();\n            int b=in.nextInt();\n            int c=in.nextInt();\n            array[a-1][b-1][c-1]=1;\n            array[b-1][a-1][c-1]=1;\n        }\n//      for(int i=0;i<n;i++)\n//          for(int j=0;j<n;j++)\n//          {\n//              for(int k=0;k<n;k++)\n//              {\n//                  //System.out.print(array[i][j][k]);\n//                  if(i==0&&j==1&&k==0)\n//                  {\n//                      System.out.println(array[i][j][k]);\n//                  }\n//              }\n//              System.out.println();\n//          }\n        for(int k=0;k<n;k++)\n        {\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                for(int q=0;q<m;q++)\n                {\n                    if(i==k||j==k||i==j)\n                        continue;\n                    if(array[i][k][q]==1&&array[k][j][q]==1)\n                   {\n                        array[i][j][q]=1;\n                        array[j][i][q]=1;\n                    }\n                }\n            }\n        }\n        \n        }\n        \n        int q=in.nextInt();\n        for(int k=0;k<q;k++)\n        {\n            int a,b;\n            a=in.nextInt();\n            b=in.nextInt();\n            int cnt=0;\n            for(int i=0;i<m;i++)\n                if(array[a-1][b-1][i]==1)\n                {\n                    cnt++;\n                }\n            out.println(cnt);\n        }\n        \n\n    }\n\n    \n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n \n# Universidade Federal de Campina Grande\n# Aluno: Diego Adolfo Silva de Ara\u00fajo\n# Matricula: 113210090\n# Disciplina: Algoritmos Avan\u00e7ados\n\n# Codeforces \n# Problem: 505B - B. Mr. Kitayuta's Colorful Graph\n# Time limit per test: 1 second\n# Memory limit per test: 256 megabytes\n# Input: standard input\n# Output: standard output\n\ndef answer(start, end):\n    count = 0\n    global graph\n    \n    for key in graph:\n        if u not in graph[key] or v not in graph[key]:\n            continue\n        \n        if list([path for path in dfs_paths(graph[key], start, end, [])]):\n            count += 1\n    \n    return count\n\ndef dfs_paths(graph, start, end, path=list()):\n    if not path:\n        path.append(start)\n    \n    if start == end:\n        yield path\n    \n    for vertex in graph[start] - set(path):\n        for key in dfs_paths(graph, vertex, end, path + [vertex]):\n            yield key\n\n        \n\ngraph = {}      \nn, m = map(int, raw_input().split())\n\nfor value in xrange(m):\n    vertex, edge, color = map(int, raw_input().split())\n    \n    if not graph.has_key(color):\n        graph[color] = {}\n    \n    if not graph[color].has_key(edge):\n        graph[color][edge] = set()\n    \n    if not graph[color].has_key(vertex):\n        graph[color][vertex] = set()\n       \n    graph[color][edge].add(vertex) \n    graph[color][vertex].add(edge)\n\nnum_queries = int(raw_input())\n\nfor line in xrange(num_queries):\n    u, v = map(int, raw_input().split())\n    print answer(u, v)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 102;\nvector<pair<int, int> > adj[max_n];\nbool vis[max_n];\nbool dfs(int st, int des, int c) {\n  if (vis[st]) return 0;\n  if (st == des) return 1;\n  vis[st] = 1;\n  for (pair<int, int> it : adj[st]) {\n    if (it.second == c) {\n      if (dfs(it.first, des, c)) return 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j, k, n, m, x, y, z;\n  cin >> n >> m;\n  int c;\n  for (i = 0; i < m; i++) {\n    cin >> x >> y >> c;\n    x--;\n    y--;\n    adj[x].push_back(make_pair(y, c));\n    adj[y].push_back(make_pair(x, c));\n  }\n  int q;\n  cin >> q;\n  for (j = 1; j <= q; j++) {\n    cin >> x >> y;\n    x--;\n    y--;\n    k = 0;\n    for (i = 1; i <= m; i++) {\n      memset(vis, 0, sizeof(vis));\n      if (dfs(x, y, i)) k++;\n    }\n    cout << k << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n/**\n *\n * @author alanl\n */\npublic class Main{\n    static BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    static int ans = 0, n, m;\n    static Set<Integer>s;\n    static ArrayList<edge>adj[];\n    public static void main(String[] args) throws IOException{\n        n = readInt();\n        m = readInt();\n        adj = new ArrayList[n+1];\n        for(int i = 1; i<=n; i++)adj[i] = new ArrayList();\n        for(int i = 0; i<m; i++){\n            int a = readInt(), b = readInt(), w = readInt();\n            adj[a].add(new edge(b, w));\n            adj[b].add(new edge(a, w));\n        }\n        int q = readInt();\n        for(int i = 0; i<q; i++){\n            int a = readInt(), b = readInt();\n            ans = 0;\n            s = new HashSet();\n            dfs(a, b, -1, new boolean[n+1]);\n            println(s.size());\n        }\n    }\n    static void dfs(int u, int end, int cur, boolean[]vis){\n        if(u==end){\n            s.add(cur);\n            return;\n        }\n        vis[u] = true;\n        if(cur==-1){\n            for(edge e:adj[u]){\n                if(!vis[e.v]){\n                    dfs(e.v, end, e.w, vis);\n                }\n            }\n        }\n        else{\n            for(edge e:adj[u]){\n                if(!vis[e.v] && e.w==cur){\n                    dfs(e.v, end, cur, vis);\n                }\n            }\n        }\n        vis[u] = false;\n    }\n    static class edge{\n        int v, w;\n        edge(int v0, int w0){\n            v = v0;\n            w = w0;\n        }\n    }\n    static String next () throws IOException {\n        while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(input.readLine().trim());\n        return st.nextToken();\n    }\n    static long readLong () throws IOException {\n        return Long.parseLong(next());\n    }\n    static int readInt () throws IOException {\n        return Integer.parseInt(next());\n    }\n    static double readDouble () throws IOException {\n        return Double.parseDouble(next());\n    }\n    static char readChar () throws IOException {\n        return next().charAt(0);\n    }\n    static String readLine () throws IOException {\n        return input.readLine().trim();\n    }\n    static void print(Object b) {\n        System.out.print(b);\n    }\n    static void println(Object b) {\n        System.out.println(b);\n    }\n    static void println() {\n        System.out.println();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package tpkg;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\n\npublic class Codeforce {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static int N,M,Q;\n\tpublic static boolean mat[][][];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] retcolours;\n\t\tInputStreamReader in=new InputStreamReader(System.in);\n\t    BufferedReader br=new BufferedReader(in);\t\n\n\t    try {\n\t\t\tString a=br.readLine();\n\t\t\tString[] firsttk = a.split(\" \");\n\t\t\tN = Integer.parseInt(firsttk[0]);\n\t\t\tM = Integer.parseInt(firsttk[1]);\n\t\t\tmat = new boolean[M+1][N+1][N+1];\n\t\t\tfor (int i=0;i<=M;i++)\n\t\t\t{\n\t\t\t\tfor (int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tArrays.fill(mat[i][j], false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0; i<M;i++)\n\t\t\t{\n\t\t\t\tString aa=br.readLine();\n\t\t\t\t//System.out.println(\"Line is \" + aa);\n\t\t\t\tString[] line = aa.split(\" \");\n\t\t\t\tint x,y,c;\n\t\t\t\tx = Integer.parseInt(line[0]);\n\t\t\t\ty = Integer.parseInt(line[1]);\n\t\t\t\tc = Integer.parseInt(line[2]);\n\t\t\t\tmat[c][x][y] = true;\n\t\t\t\tmat[c][y][x] = true;\n\t\t\t}\n\t\t\t\n\t\t\tString qq=br.readLine();\n\t\t\tQ = Integer.parseInt(qq);\n\t\t\tretcolours = new int[Q];\n\t\t\t\n\t\t\tfor (int i=0; i<Q;i++)\n\t\t\t{\n\t\t\t\tString aa=br.readLine();\n\t\t\t\tString[] line = aa.split(\" \");\n\t\t\t\tint x,y;\n\t\t\t\tx = Integer.parseInt(line[0]);\n\t\t\t\ty = Integer.parseInt(line[1]);\n\t\t\t\tint noOfGraphConnected = howmanyGraphsConnected(x,y);\n\t\t\t\tSystem.out.println(noOfGraphConnected);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static int howmanyGraphsConnected(int x, int y)\n\t{\n\t\tint ret = 0;\n\t\tfor (int i=1; i<=M; i++)\n\t\t{\n\t\t\tboolean cflag = isConnected(i,x,y );\n\t\t\tif ( cflag )\n\t\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t\n\tpublic static boolean isConnected( int c, int x, int y )\n\t{\n\t\tboolean cflag = false;\n\t\tLinkedList<Integer> Q = new LinkedList<Integer>();\n\t\tQ.add(x);\n\t\tHashSet<Integer> visited = new HashSet<Integer>();\n\t\tvisited.add(x);\n\t\twhile ( !Q.isEmpty() )\n\t\t{\n\t\t\tint cur = Q.remove();\n\t\t\tif ( cur == y )\n\t\t\t{\n\t\t\t\tcflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i<=N;i++)\n\t\t\t{\n\t\t\t\tif ( mat[c][cur][i] && !visited.contains(i) )\n\t\t\t\t{\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\tvisited.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cflag;\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        int n;\n        int m;\n        ArrayList<Edge>[] adj;\n        int[][] visited;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.ni();\n            m = in.ni();\n            adj = new ArrayList[n + 1];\n            for (int i = 1; i <= n; i++)\n                adj[i] = new ArrayList<>();\n            int max_colors = m + 1;\n            while (m-- > 0) {\n                int a = in.ni();\n                int b = in.ni();\n                int c = in.ni();\n                adj[a].add(new Edge(b, c));\n                adj[b].add(new Edge(a, c));\n            }\n            int q = in.ni();\n            while (q-- > 0) {\n                int u = in.ni();\n                int v = in.ni();\n                visited = new int[n + 1][max_colors];\n                Iterator<Edge> iterator = adj[u].iterator();\n                while (iterator.hasNext()) {\n                    Edge temp = iterator.next();\n                    visited[temp.dest][temp.color] = 1;\n                    DFS(temp.dest, temp.color);\n                }\n                int count = 0;\n                for (int i = 0; i < max_colors; i++)\n                    count += visited[v][i];\n                out.println(count);\n            }\n        }\n\n        void DFS(int source, int color) {\n            Iterator<Edge> iterator = adj[source].iterator();\n            while (iterator.hasNext()) {\n                Edge temp = iterator.next();\n                if (visited[temp.dest][temp.color] == 0 && color == temp.color) {\n                    visited[temp.dest][temp.color] = 1;\n                    DFS(temp.dest, temp.color);\n                }\n            }\n        }\n\n        class Edge {\n            int dest;\n            int color;\n\n            Edge(int a, int b) {\n                dest = a;\n                color = b;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String n() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(n());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\timport java.io.*;\n\timport java.util.*;\n\timport java.math.*;\n\t\n\tpublic class Kruskal {\n\t\t\t\tprivate static InputStream stream;\n\t\t\t\tprivate static byte[] buf = new byte[1024];\n\t\t\t\tprivate static int curChar;\n\t\t\t\tprivate static int numChars;\n\t\t\t\tprivate static SpaceCharFilter filter;\n\t\t\t\tprivate static PrintWriter pw;\n\t\t\t\n\t\t\t\tpublic static void main(String args[]) throws Exception {\n\t\t\t\t\tInputReader(System.in);\n\t\t\t\t\tpw = new PrintWriter(System.out);\n\t\t\t\t\t//ans();\n\t\t\t       \n\t\t\t            soln();\n\t\t\t     \n\t\t\t        \n\t\t\t\t\tpw.close();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\n\t\t\t\t// To Get Input\n\t\t\t\t// Some Buffer Methods\n\t\t\t \n\t\t\t\tpublic static void InputReader(InputStream stream1) {\n\t\t\t\t\tstream = stream1;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static boolean isWhitespace(int c) {\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static boolean isEndOfLine(int c) {\n\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static int read() {\n\t\t\t\t\tif (numChars == -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= numChars) {\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (numChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static int nextInt() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static long nextLong() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t}\n\t\t\t\t\tlong res = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static String nextToken() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo {\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static String nextLine() {\n\t\t\t\t\tint c = read();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = read();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo {\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = read();\n\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static int[] nextIntArray(int n) {\n\t\t\t\t\tint[] arr = new int[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tarr[i] = nextInt();\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static int[][] next2dArray(int n, int m) {\n\t\t\t\t\tint[][] arr = new int[n][m];\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t\tprivate static char[][] nextCharArray(int n,int m){\n\t\t\t\t\tchar [][]c=new char[n][m];\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tString s=nextLine();\n\t\t\t\t\t\tfor(int j=0;j<s.length();j++){\n\t\t\t\t\t\t\tc[i][j]=s.charAt(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static long[] nextLongArray(int n) {\n\t\t\t\t\tlong[] arr = new long[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tarr[i] = nextLong();\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static void pArray(int[] arr) {\n\t\t\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\t\t\tpw.print(arr[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tpw.println();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static void pArray(long[] arr) {\n\t\t\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\t\t\tpw.print(arr[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tpw.println();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static void pArray(boolean[] arr) {\n\t\t\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\t\t\tpw.print(arr[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tpw.println();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate static boolean isSpaceChar(int c) {\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn isWhitespace(c);\n\t\t\t\t}\n\t\t\t \n\t\t\t\tprivate interface SpaceCharFilter {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t\tprivate static void soln(){\n\t\t\t\tint n=nextInt();\n\t\t\t\n\t\t\t\tint m=nextInt();\n\t\t\t\tint col=-1;\n\t\t\t\tGraph g=new Graph(n);\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tint u=nextInt();\n\t\t\t\t\tint v=nextInt();\n\t\t\t\t\tint w=nextInt();\n\t\t\t\t\tcol=Math.max(col, w);\n\t\t\t\t\tg.addEdge(u, v, w);\n\t\t\t\t\tg.addEdge(v, u, w);\n\t\t\t\t}\n\t\t\t\tint q=nextInt();\n\t\t\t\twhile(q-->0){\n\t\t\t\t\tint u=nextInt();\n\t\t\t\t\tint v=nextInt();\n\t\t\t\t\tlong c=0;\n\t\t\t\t\tfor(int i=1;i<=col;i++){\n\t\t\t\t\t\tif(g.dfs(u,v,i))\n\t\t\t\t\t\t\tc++;\n\n\t\t\t\t\t}\n\t\t\t\t\tpw.println(c);\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tclass Dsu{\n\t\t\t\tprivate int rank[], parent[] ,n;\n\t\t\t\t\n\t\t\t\tDsu(int size){\n\t\t\t\t\tthis.n=size+1;\n\t\t\t\t\trank=new int[n];\n\t\t\t\t\tparent=new int[n];\n\t\t\t\tmakeSet();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid makeSet(){\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tparent[i]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint find(int x){\n\t\t\t\t\tif(parent[x]!=x){\n\t\t\t\t\t\t\n\t\t\t\t\t\tparent[x]=find(parent[x]);\n\t\t\t\t\t}\n\t\t\t\t\treturn parent[x];\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tvoid union(int x,int y){\n\t\t\t\t\tint xRoot=find(x);\n\t\t\t\t\tint yRoot=find(y);\n\t\t\t\t\t\n\t\t\t\t\tif(xRoot==yRoot)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(rank[xRoot]<rank[yRoot]){\n\t\t\t\t\tparent[xRoot]=yRoot;\t\n\t\t\t\t\t}else if(rank[yRoot]<rank[xRoot]){\n\t\t\t\t\t\tparent[yRoot]=xRoot;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent[yRoot]=xRoot;\n\t\t\t\t\t\trank[xRoot]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t \n\t\t\t}\n\t\t\tclass Pair implements Comparable<Pair>{\n\t\t\t\n\t\t\t\tint v,w;\n\t\t\t\t Pair(int to,int dist) {\n\t\t\t\t\t v=to;\n\t\t\t\t\t w=dist;\n\t\t\t\t\t// TODO Auto-generated constructor stub\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic int compareTo(Pair arg0) {\n\t\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\treturn w-arg0.w;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tclass Graph{\n\t\t\t\tprivate int V,ans=0;\n\t\t\t\tprivate boolean Visited[];\n\t\t\t\tprivate LinkedList<Node> adj[];\n\t\t\t\tprivate StringBuilder sb=new StringBuilder();\n\t\t\t\tGraph(int V){\n\t\t\t\t\tthis.V=V++;\n\t\t\t\t\t\n\t\t\t\t\tadj=new LinkedList[V];\n\t\t\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\t\t\tadj[i]=new LinkedList<Node>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid addEdge(int u,int v,int w){\n\t\t\t\t\tadj[u].add(new Node(v,w));\n\t\t\t\t}\n\t\t\t\tpublic boolean dfs(int startVertex,int end,int col){\n\t\t\t\t\tVisited=new boolean[V+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!Visited[startVertex]){\n\t\t\t\t\t\treturn dfsUtil(startVertex, end, col);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic boolean dfsUtil(int startVertex,int end,int col){\n\t\t\t\t\tVisited[startVertex]=true;\n\t\t\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\t\t\tst.push(startVertex);\n\t\t\t\t\tint di=Integer.MAX_VALUE;\n\t\t\t\t\tint temp=0;\n\t\t\t\t\twhile(!st.isEmpty()){\n\t\t\t\t\t\tint top=st.pop();\n\t\t\t\t\t\t//temp=top;\n\t\t\t\t\t\tIterator<Node> i=adj[top].listIterator();\n\t\t\t\t\t\twhile(i.hasNext()){\n\t\t\t\t\t\t\tNode ne=i.next();\n\t\t\t\t\t\t\tint n=ne.v;\n\t\t\t\t\t\t\t//di=Math.min(di, ne.dia);\n\t\t\t\t\t\t\tif(!Visited[n] && ne.dia==col){\n\t\t\t\t\t\t\t\tst.push(n);\n\t\t\t\t\t\t\t\tVisited[n]=true;\n\t\t\t\t\t\t\tif(n==end){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tclass Node{\n\t\t\t\tint v,dia;\n\t\t\t\tNode(int to,int dist){\n\t\t\t\t\tv=to;\n\t\t\t\t\tdia=dist;\n\t\t\t\t}\n\t\t\t\tpublic int getV() {\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tpublic int getDia() {\n\t\t\t\t\treturn dia;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\n\t\t\n\t\n\t\t\n\t\t\n\t "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n     \n    public class B {\n  \n    \tstatic int N, E;\n    \tstatic ArrayList<Integer>[][] adjList;\n    \tstatic boolean[] vis;\n    \t\n    \tpublic static void main(String[] args) throws IOException{\n     \n    \t\tScanner sc = new Scanner(System.in);\n    \t\tPrintWriter out = new PrintWriter(System.out);\n    \t\tN = sc.nextInt(); E = sc.nextInt();\n    \t\tadjList = new ArrayList[E][N];\n    \t\tfor(int i = 0; i < E; i++)\n    \t\t\tfor(int j = 0; j < N; j++)\n    \t\t\t\tadjList[i][j] = new ArrayList<>();\n    \t\tfor(int i = 0; i < E; i++)\n    \t\t{\n    \t\t\tint u = sc.nextInt()-1, v = sc.nextInt()-1, c = sc.nextInt()-1;\n    \t\t\tadjList[c][u].add(v);\n    \t\t\tadjList[c][v].add(u);\n    \t\t}\n    \t\t\n    \t\tint q = sc.nextInt();\n    \t\twhile(q --> 0)\n    \t\t{\n    \t\t\tint u = sc.nextInt()-1, v = sc.nextInt()-1, ans = 0;\n    \t\t\tfor(int i = 0; i < E; i++)\n    \t\t\t{\n    \t\t\t\tvis = new boolean[N];\n    \t\t\t\tans += dfs(u, v, i)? 1 : 0;\n    \t\t\t}\n    \t\t\tout.println(ans);\n    \t\t}\n    \t\tout.flush();\n    \t}\n    \t\n    \tstatic boolean dfs(int u, int t, int c)\n    \t{\n    \t\tif(u == t) return true;\n    \t\tvis[u] = true;\n    \t\tboolean ans = false;\n    \t\tfor(int v : adjList[c][u])\n    \t\t\tif(!vis[v])\n    \t\t\t\tans |= dfs(v, t, c);\n    \t\treturn ans;\n    \t}\n    \t\n    \tstatic class Scanner \n    \t{\n    \t\tStringTokenizer st;\n    \t\tBufferedReader br;\n     \n    \t\tpublic Scanner(InputStream System){\tbr = new BufferedReader(new InputStreamReader(System));\t}\n    \t\tpublic String next() throws IOException \n    \t\t{\n    \t\t\twhile (st == null || !st.hasMoreTokens()) \n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\treturn st.nextToken();\n    \t\t}\n    \t\tpublic String nextLine()throws IOException{return br.readLine();}\n    \t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n    \t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\n    \t\tpublic char nextChar()throws IOException{return next().charAt(0);}\n    \t\tpublic Long nextLong()throws IOException{return Long.parseLong(next());}\n    \t\tpublic boolean ready() throws IOException{return br.ready();}\n    \t\tpublic void waitForInput(){for(long i = 0; i < 3e9; i++);}\n    \t}\n    }"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class MrKitayutasColorfulGraph {\n\t\n\tstatic class Pair {\n\t\tint node, c;\n\t\t\n\t\tPair (int n, int cc){\n\t\t\tnode = n;\n\t\t\tc = cc;\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Pair> [] graph;\n\tstatic boolean [] vis;\n\t\n\tstatic int dfs (int u, int c, int des){\n\t\tvis[u] = true;\n\t\tif(des == u)\n\t\t\treturn 1;\n\t\tint ans = 0;\n\t\tfor(Pair v : graph[u]){\n\t\t\tif(!vis[v.node] && v.c == c)\n\t\t\t\tans += dfs(v.node, c, des);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tgraph = new ArrayList[n];\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tgraph[i] = new ArrayList<>();\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint u = sc.nextInt() - 1, v = sc.nextInt() - 1, c = sc.nextInt();\n\t\t\tgraph[u].add(new Pair(v, c));\n\t\t\tgraph[v].add(new Pair(u, c));\n\t\t}\n\t\tint q = sc.nextInt();\n\t\twhile(q-- > 0){\n\t\t\tint u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 1;i <= m;i++){\n\t\t\t\tvis = new boolean[n];\n\t\t\t\tans += dfs(u, i, v);\n\t\t\t}\n\t\t\tpw.println(ans);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class MyScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic MyScanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q;\nvector<pair<int, int>> ar[100001];\nvoid insert(int a, int b, int c) {\n  ar[a].push_back(make_pair(b, c));\n  ar[b].push_back(make_pair(a, c));\n}\nint vis[100001];\nint dfs(int a, int b, int c) {\n  vis[a] = 1;\n  if (a == b) return 1;\n  int x = (int)(ar[a].size());\n  for (int i = 0; i < x; i++)\n    if (vis[ar[a][i].first] != 1 && ar[a][i].second == c)\n      if (dfs(ar[a][i].first, b, c) == 1) return 1;\n  return 0;\n}\nint main() {\n  int a, b, c;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d\", &a);\n    scanf(\"%d\", &b);\n    scanf(\"%d\", &c);\n    insert(a, b, c);\n  }\n  scanf(\"%d\", &q);\n  for (int t = 0; t < q; t++) {\n    scanf(\"%d\", &a);\n    scanf(\"%d\", &b);\n    int ans = 0;\n    for (int i = 1; i < m + 1; i++) {\n      for (int j = 0; j < n + 1; j++) vis[j] = 0;\n      ans += dfs(a, b, i);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool mat[100][100][100];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL), cout.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b, --c;\n    mat[a][b][c] = 1;\n    mat[b][a][c] = 1;\n  }\n  for (int col = 0; col < m; ++col) {\n    for (int k = 0; k < n; ++k) {\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if ((mat[i][k][col] && mat[k][j][col])) {\n            mat[i][j][col] = 1;\n          }\n        }\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    cout << accumulate(mat[a][b], mat[a][b] + m, 0) << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Program {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n\n    static final int Mod = 1000000007;\n    static final double inf = 10000000000.0;\n    \n    class edge\n    {\n    \tint to, color, nextEdge;\n    }\n    int n, m;\n    edge[] g;\n    int[] s;\n\tint edgeno = 0;\n\n    \n    int solve(int u, int v)\n    {\n    \tint ans = 0;\n    \tfor(int c = 1; c <= m; c++)\n    \t{\n    \t\tboolean[] vis = new boolean[n];\n    \t\tStack<Integer> stack = new Stack<>();\n    \t\tstack.push(u);\n    \t\tvis[u] = true;\n    \t\twhile(!stack.isEmpty())\n    \t\t{\n    \t\t\tint p = stack.peek();\n    \t\t\tif (p == v)\n    \t\t\t{\n    \t\t\t\tans++;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tfor(int i = s[p]; i != -1; i = g[i].nextEdge)\n    \t\t\tif (c == g[i].color && !vis[g[i].to])\n    \t\t\t{\n    \t\t\t\tstack.push(g[i].to);\n    \t\t\t\tvis[g[i].to] = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tif (stack.peek() == p)\n    \t\t\t\tstack.pop();\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n    \n    void addEdge(int x, int y, int c)\n    {\n\t\tg[edgeno] = new edge();\n\t\tg[edgeno].to = y;\n\t\tg[edgeno].color = c;\n\t\tg[edgeno].nextEdge = s[x];\n\t\ts[x] = edgeno++;\n    }\n\n    void solve() throws IOException {\n    \t\n    \tn = nextInt();\n    \tm = nextInt();\n    \tg = new edge[m*2];\n    \ts = new int[n];\n    \tArrays.fill(s, -1);\n    \tfor(int i = 0; i < m; i++)\n    \t{\n    \t\tint x, y, c;\n    \t\tx = nextInt()-1;\n    \t\ty = nextInt()-1;\n    \t\tc = nextInt();\n    \t\taddEdge(x, y, c);\n    \t\taddEdge(y, x, c);\n    \t}\n    \tint q = nextInt();\n    \twhile(q-- > 0)\n    \t{\n    \t\tint u, v;\n    \t\tu = nextInt()-1;\n    \t\tv = nextInt()-1;\n    \t\tout.println(solve(u, v));\n    \t}\n    }\n\n    Program() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Program();\n    }\n\n    String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n\n    String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 1,
            "solution": "def dfs(Map,u,v,color):\n    count=0\n    for c in color:\n        visited=[0 for i in range(110)]\n        l=[]\n        l.append(u)\n        visited[u]=1\n        while len(l)!=0:\n            temp=l[len(l)-1]\n            flag=1\n            for i in range(len(Map[0])):\n                if c in Map[temp][i] and visited[i]==0:\n                    visited[i]=1\n                    l.append(i)\n                    flag=0\n            if flag:\n                l.pop()\n        if visited[v]:\n            count+=1\n\n    return count\n\nif __name__ == '__main__':\n    R=lambda:map(int,raw_input().split())\n    n,m=R()\n    Map=[[[] for i in range(110)] for i in range(110)]\n    color=[]\n    for i in range(m):\n        a,b,c=R()\n        Map[a][b].append(c)\n        Map[b][a].append(c)\n        if c not in color:\n            color.append(c)\n    q=int(raw_input())\n    ans=[]\n    for i in range(q):\n        u,v=R()\n        ans.append(dfs(Map,u,v,color))\n\n    for i in ans:\n        print i\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n    static boolean[] visited = new boolean[101];\n    static HashSet<Integer>[][] edges = new HashSet[101][101];\n    static ArrayList<Integer>[] adj = new ArrayList[101];\n\n    public static void main(String[] args) throws Exception {\n        long startTime = System.nanoTime();\n        int n = in.nextInt();\n        int m = in.nextInt();\n        for (int i = 0; i < 101; i++) {\n            adj[i] = new ArrayList<Integer>();\n            for (int j = 0; j < 101; j++) {\n                edges[i][j] = new HashSet<Integer>();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            edges[a][b].add(c);\n            edges[b][a].add(c);\n            adj[a].add(b);\n            adj[b].add(a);\n        }\n\n        int q = in.nextInt();\n        while (q-- > 0) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int ans = 0;\n            for (int i = 1; i <= 100; i++) {\n                if (dfs(u, v, i)) {\n                    ans++;\n                }\n                visited = new boolean[101];\n            }\n\n            out.println(ans);\n        }\n        long endTime = System.nanoTime();\n        err.println(\"Execution Time : +\" + (endTime - startTime) / 1000000 + \" ms\");\n        exit(0);\n    }\n\n    static boolean dfs(int start, int end, int col) {\n        visited[start] = true;\n        if (start == end) {\n            return true;\n        }\n        for (int e : adj[start]) {\n            for (int c : edges[start][e]) {\n                if (col == c && !visited[e]) {\n                    if (dfs(e, end, c)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static void exit(int a) {\n        out.close();\n        err.close();\n        System.exit(a);\n    }\n\n    static InputStream inputStream = System.in;\n    static OutputStream outputStream = System.out;\n    static OutputStream errStream = System.err;\n    static InputReader in = new InputReader(inputStream);\n    static PrintWriter out = new PrintWriter(outputStream);\n    static PrintWriter err = new PrintWriter(errStream);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class KitayutasColorfulGraph {\n\n    /**\n     * @param args\n     * @throws IOException\n     */\n    \n    static class Pair {\n        int x, y;\n        public Pair(int xx, int yy) {\n            x = xx;\n            y = yy;\n        }\n    }\n    \n    static ArrayList<Pair>[] g;\n    \n    static boolean vis[];\n    \n    public static int dfs(int u, int v, int c) {\n        if (vis[u])\n            return 0;\n        vis[u] = true;\n        if (u == v)\n            return 1;\n        int res = 0;\n        for (int i = 0; i < g[u].size(); i++) {\n            if (g[u].get(i).y == c)\n                res += dfs(g[u].get(i).x, v, c);\n        }\n        return res;\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        \n        g = new ArrayList[n];\n        \n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<Pair>();\n\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            st = new StringTokenizer(bf.readLine());\n            a = Integer.parseInt(st.nextToken()) - 1;\n            b = Integer.parseInt(st.nextToken()) - 1;\n            c = Integer.parseInt(st.nextToken()) - 1;\n            g[a].add(new Pair(b, c));\n            g[b].add(new Pair(a, c));\n        }\n        \n        \n        int q = Integer.parseInt(bf.readLine());\n        \n        while (q-- > 0) {\n            st = new StringTokenizer(bf.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            int res = 0;\n            for (int i = 0; i <= m; i++) {\n                vis = new boolean[n];\n                res += dfs(a, b, i);\n            }\n            System.out.println(res);\n        }\n        \n        \n\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "def get_connected_matrix(adjacency_matrix):\n    n = len(adjacency_matrix)\n    non_visited_vertices = set(i for i in range(n))\n    cluster_numbers = [0] * n\n    cluster_number = 1\n\n    def traverse(u):\n        non_visited_vertices.remove(u)\n        cluster_numbers[u] = cluster_number\n        for v in range(n):\n            if v in non_visited_vertices:\n                if adjacency_matrix[u][v]:\n                    traverse(v)\n\n    while non_visited_vertices:\n        vertex = non_visited_vertices.pop()\n        non_visited_vertices.add(vertex)\n        traverse(vertex)\n        cluster_number += 1\n\n    connected_matrix = [[False] * n for _ in range(n)]\n\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n            connected_matrix[u][v] = connected_matrix[v][u] = (cluster_numbers[u] == cluster_numbers[v])\n\n    return connected_matrix\n\n\ndef main():\n    n, m = [int(t) for t in input().split()]\n\n    matrices = [[[False] * n for _ in range(n)] for _ in range(m)]\n\n    for _ in range(m):\n        a, b, c = [int(t) - 1 for t in input().split()]\n        matrices[c][a][b] = True\n        matrices[c][b][a] = True\n\n    connected_matrices = [get_connected_matrix(matrix) for matrix in matrices]\n\n    q = int(input())\n    for _ in range(q):\n        u, v = [int(t) - 1 for t in input().split()]\n        total_connection = sum(1 for connected_matrix in connected_matrices if connected_matrix[u][v])\n        print(total_connection)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// dsu solution\n\npublic class recc505b_3 {\n    static BufferedReader __in;\n    static PrintWriter __out;\n    static StringTokenizer input;\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new InputStreamReader(System.in));\n        __out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        r();\n        int n = ni(), m = ni();\n        DSU[] dsu = new DSU[m];\n        for(int i = 0; i < m; ++i) {\n            dsu[i] = new DSU(n);\n        }\n        for(int i = 0; i < m; ++i) {\n            r();\n            int a = ni() - 1, b = ni() - 1, c = ni() - 1;\n            dsu[c].union(a, b);\n        }\n        int q = ri();\n        while(q --> 0) {\n            r();\n            int u = ni() - 1, v = ni() - 1, ans = 0;\n            for(int i = 0; i < m; ++i) {\n                if(dsu[i].find(u) == dsu[i].find(v)) {\n                    ++ans;\n                }\n            }\n            prln(ans);\n        }\n\n        close();\n    }\n\n    static class DSU {\n        int[] par, sz;\n\n        DSU(int n) {\n            par = new int[n];\n            sz = new int[n];\n            for(int i = 0; i < n; ++i) {\n                make(i);\n            }\n        }\n\n        void make(int v) {\n            par[v] = v;\n            sz[v] = 1;\n        }\n\n        int find(int v) {\n            if(v == par[v]) {\n                return v;\n            } else {\n                par[v] = find(par[v]);\n                return par[v];\n            }\n        }\n\n        void union(int u, int v) {\n            int a = find(u), b = find(v);\n            if(a != b) {\n                if(sz[a] < sz[b]) {\n                    int swap = a;\n                    a = b;\n                    b = swap;\n                }\n                par[b] = a;\n                sz[a] += sz[b];\n            }\n        }\n    }\n\n    // references\n    // IBIG = 1e9 + 7\n    // IRAND ~= 3e8\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IRAND = 327859546;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static int minstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static long minstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static int maxstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static long maxstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int floori(double d) {return (int)d;}\n    static int ceili(double d) {return (int)ceil(d);}\n    static long floorl(double d) {return (long)d;}\n    static long ceill(double d) {return (long)ceil(d);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); __out.println(iter.next());}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}"
        },
        {
            "language": 1,
            "solution": "# here we go again\nnvertices, nedges = map(int,raw_input().split())\nmatrix = [[[] for j in xrange(nvertices+1)] for x in xrange(nvertices+1)]\nvisitados = []\n\ndef visita(r, t,cor):\n\tif r == t:\n\t\tif cor not in colors: colors.append(cor)\n\tif r in visitados:\n\t\treturn False\n\telse: visitados.append(r)\n\tfor i in range(1,nvertices+1):\n\t\tif len(matrix[r][i]) >0:\n\t\t\tif cor in matrix[r][i]:\n\t\t\t\tvisita(i,t,cor)\t\t\t\n\t\t\t\nfor i in xrange(nedges):\n\ta,b,c = map(int,raw_input().split())\n\tif c not in matrix[a][b]:\n\t\tmatrix[a][b].append(c)\n\t\tmatrix[b][a].append(c)\n\t\t\nq= int(raw_input())\nfor i in xrange(q):\n\tcolors = []\n\tu,v = map(int,raw_input().split())\n\tfor kor in range(1,101):\n\t\tvisitados = []\n\t\tvisita(u,v,kor)\n\tprint len(colors)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<int, int>>> v;\nint visited[100];\nvoid dfs(int i, int final, int color) {\n  if (i == final) {\n    visited[final] = 1;\n    return;\n  }\n  visited[i] = 1;\n  for (auto j : v[i]) {\n    if (visited[j.first] == 0 && j.second == color) {\n      dfs(j.first, final, color);\n    }\n  }\n}\nint solve(int x, int y, int c) {\n  memset(visited, 0, sizeof(visited));\n  dfs(x, y, c);\n  if (visited[y] == 1) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  v.resize(n);\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[b - 1].push_back({a - 1, c - 1});\n    v[a - 1].push_back({b - 1, c - 1});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n      ans = ans + solve(x - 1, y - 1, i);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\ngraph = []\nedges = {}\nvertex_edges = {}\nqueries = []\nvisited = [False] * n\n\n\ndef dfs(u, edge):\n    if (not visited[u]):\n        visited[u] = True\n        for i in range(len(graph)):\n            vertex_1 = (min(graph[i][1], u + 1), max(graph[i][1], u + 1))\n            vertex_2 = (min(graph[i][0], u + 1), max(graph[i][0], u + 1))\n\n            if (graph[i][0] == u + 1 and vertex_1 in edges and edge in edges[vertex_1]):\n                dfs(graph[i][1] - 1, edge)\n            if (graph[i][1] == u + 1 and vertex_2 in edges and edge in edges[vertex_2]):\n                dfs(graph[i][0] - 1, edge)\n\n\nfor i in range(m):\n    a, b, c = map(int, raw_input().split())\n    graph.append((a, b))\n    vertex = (min(a, b), max(a, b))\n\n    if (vertex in edges):\n        edges[vertex].append(c)\n    else:\n        edges[vertex] = [c]\n\n    if (a in vertex_edges):\n        vertex_edges[a].append(c)\n    else:\n        vertex_edges[a] = [c]\n\n    if (b in vertex_edges):\n        vertex_edges[b].append(c)\n    else:\n        vertex_edges[b] = [c]\n\nq = input()\n\nfor i in range(q):\n    u, v = map(int, raw_input().split())\n    count = 0\n\n    if (u in vertex_edges):\n        vertex_edges[u] = list(set(vertex_edges[u]))\n\n        for j in vertex_edges[u]:\n            visited = [False] * n\n            dfs(u - 1, j)\n            if (visited[v - 1]):\n                count += 1\n\n    print(count)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> graph[1001][1001];\nlong long n, m;\nbool found = false;\nvector<bool> visited(1001);\nvoid dfs(long long src, long long des, long long color) {\n  if (found) {\n    return;\n  }\n  if (src == des) {\n    found = true;\n    return;\n  }\n  visited[src] = true;\n  for (vector<long long>::iterator it = graph[color][src].begin();\n       it != graph[color][src].end(); it++) {\n    if (visited[*it] == false) {\n      dfs(*it, des, color);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  for (long long i = 0; i <= 101; i++) {\n    for (long long j = 0; j <= 101; j++) {\n      graph[i][j].clear();\n    }\n  }\n  cin >> n >> m;\n  for (long long i = 1; i <= m; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    graph[c][a].push_back(b);\n    graph[c][b].push_back(a);\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    long long a, b;\n    cin >> a >> b;\n    long long ans = 0;\n    for (long long color = 0; color <= 100; color++) {\n      for (long long i = 0; i <= n; i++) {\n        visited[i] = false;\n      }\n      found = false;\n      dfs(a, b, color);\n      if (found) ans++;\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "# http://codeforces.com/contest/505/problem/B\nclass Node:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.neighs = {}\n\n\tdef dfs_color(self, f, t, nodes, visited):\n\t\t# if self.n in visited:\n\t\t\t# return visited[self.n]\n\t\tvisited.add(self.n)\n\t\tconnected = set()\n\n\t\tfor neigh, colors_to_neigh in self.neighs.items():\n\t\t\tif neigh == f or neigh in visited:\n\t\t\t\tcontinue\n\t\t\tcolors = colors_to_neigh if neigh == t else nodes[neigh].dfs_color(self.n,t,nodes, visited)\n\t\t\tconnected.update(colors.intersection(colors_to_neigh))\n\t\t# visited[self.n] = connected\n\t\tvisited.remove(self.n)\n\t\treturn connected\n\n\tdef dfs_colored_path(self, cc, nodes, visited):\n\t\tvisited.add(self.n)\n\t\tfor neigh, colors_to_neigh in self.neighs.items():\n\t\t\tif neigh in visited or cc not in colors_to_neigh:\n\t\t\t\tcontinue\n\t\t\tnodes[neigh].dfs_colored_path(cc, nodes, visited)\n\t\treturn visited\n\n\tdef search_with_color(self, t, nodes):\n\t\tcolors_to_explore = set()\n\t\tcolors = set()\n\n\t\tfor neigh, colors_to_neigh in self.neighs.items():\n\t\t\tcolors_to_explore.update(colors_to_neigh)\n\n\t\tfor color in colors_to_explore:\n\t\t\tcities = self.dfs_colored_path(color, nodes, set())\n\t\t\tif t in cities:\n\t\t\t\tcolors.add(color)\n\t\treturn len(colors)\n\n\n\nn, m = [int(n) for n in input().split()]\n# edges = [int(n) for _ in range(m) for input().split()]\nedges = []\nwhile m:\n\tedge = [int(n) for n in input().split()]\n\tedges.append(edge)\n\tm-=1\n\n\nnodes = [Node(i) for i in range(n+1)]\nfor f, t, c in edges:\n\tif t not in nodes[f].neighs:\n\t\tnodes[f].neighs[t] = set() \n\tnodes[f].neighs[t].add(c)\n\n\tf,t = t,f\n\tif t not in nodes[f].neighs:\n\t\tnodes[f].neighs[t] = set() \n\tnodes[f].neighs[t].add(c)\n\nqs = int(input())\n\nfor q in range(qs):\n\t# visited = set()\n\tf, t = [int(n) for n in input().split()]\n\t# print(len(nodes[f].dfs_color(f, t, nodes, visited)))\n\tprint(nodes[f].search_with_color(t, nodes))\n"
        },
        {
            "language": 1,
            "solution": "V, E = [int(s) for s in raw_input().split(\" \")]\ngraph = [[set() for _ in xrange(V+1)] for _ in xrange(V+1)]\nfor _ in xrange(E):\n    src, dst, color = [int(s) for s in raw_input().split(\" \")]\n    graph[src][dst].add(color)\n    graph[dst][src].add(color)\nfor k in xrange(1, V+1):\n    for i in xrange(1, V+1):\n        for j in xrange(1, V+1):\n            ij = graph[i][j]\n            ik = graph[i][k]\n            kj = graph[k][j]\n            ijk = ik & kj\n            graph[i][j] = ij | ijk\nQ = int(raw_input())\nfor _ in xrange(Q):\n    src, dst = [int(s) for s in raw_input().split(\" \")]\n    print len(graph[src][dst])"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\nn, m = map(int, input().split())\nd = [defaultdict(list) for i in range(1+m)]\n\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    d[c][a].append(b)\n    d[c][b].append(a)\n    \nq = int(input())\n\nfor _ in range(q):\n    u, v = map(int, input().split())\n    ct = 0\n    \n    for adj in d:\n        vst = [0]*(n+1)\n        q = [u]\n        \n        while q:\n            e = q.pop()\n            \n            if e == v:\n                ct += 1\n                break\n            else:\n                vst[e] = 1\n                for j in adj[e]:\n                    if not vst[j]:\n                        q.append(j)\n                        \n    print(ct)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint used[101];\nvector<pair<int, int>> g[101];\nint s[101];\nint n, cnt = 0, m, j, ind = 0;\nvoid dfs(int x, int y, int p) {\n  cnt = 0;\n  used[x] = 1;\n  if (x == y) {\n    cnt++;\n    ind = 1;\n    return;\n  }\n  for (int k = 0; k < g[x].size(); k++) {\n    if (used[g[x][k].first] == 0) {\n      if (g[x][k].second == p && ind != 1) {\n        dfs(g[x][k].first, y, p);\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int u, v, r, i = 0; i < m; i++) {\n    cin >> u >> v >> r;\n    g[u].push_back({v, r});\n    g[v].push_back({u, r});\n  }\n  cin >> j;\n  for (int h, f, b = 1; b <= j; b++) {\n    cin >> h >> f;\n    cnt = 0;\n    for (int i = 1; i <= m; i++) {\n      memset(used, 0, sizeof(used));\n      ind = 0;\n      dfs(h, f, i);\n      s[b] = s[b] + cnt;\n    }\n  }\n  for (int i = 1; i <= j; i++) cout << s[i] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class CF_500B {\n    public static void main(String[] args) throws IOException {\n        new CF_500B().solve();\n    }\n\n    int root(int[]p , int i){\n        if (p[i]==i) return i;\n        else return p[i]=root(p, p[i]);\n    }\n    \n    void fillConnections(ArrayList<ArrayList<Integer>> gr, boolean[][]connect){\n        int[] p=new int[connect.length];\n        for (int i=0;i<p.length;i++)\n            p[i]=i;\n        for (int i=0;i<gr.size();i++)\n            for (Integer nb:gr.get(i))\n                p[root(p,nb)]=root(p,i);\n        for (int i=0;i<connect.length;i++)\n            for (int j=i+1;j<connect.length;j++)\n                if (root(p,i)==root(p, j))\n                    connect[i][j]=connect[j][i]=true;\n    }\n    \n    \n    void solve() throws IOException{\n        \n        InputStream in = System.in;\n        PrintStream out = System.out;\n\n//        in = new FileInputStream(\"in.txt\");\n//        out = new PrintStream(\"out.txt\");\n\n        Scanner sc=new Scanner(in);        \n        int n=sc.nextInt(), m=sc.nextInt();\n        boolean[][][] con=new boolean[m][n][n];\n        HashMap<Integer, ArrayList<ArrayList<Integer>>> totalGr=\n                new HashMap<Integer, ArrayList<ArrayList<Integer>>>();\n        for (int t=0;t<m;t++){\n            int a=sc.nextInt()-1, b=sc.nextInt()-1, c=sc.nextInt()-1;\n            if (!totalGr.containsKey(c)){\n                ArrayList<ArrayList<Integer>> gr=new ArrayList<ArrayList<Integer>>();\n                for (int i=0;i<n;i++)\n                    gr.add(new ArrayList<Integer>());\n                totalGr.put(c, gr);\n            }\n            totalGr.get(c).get(a).add(b);\n            totalGr.get(c).get(b).add(a);\n        }\n        for (Integer c:totalGr.keySet())\n            fillConnections(totalGr.get(c),con[c]);\n        \n        int q=sc.nextInt();\n        for (int t=0;t<q;t++){\n            int u=sc.nextInt()-1, v=sc.nextInt()-1, count=0;\n//            System.out.println(u+\" \"+v);\n\n            \n            for (Integer c:totalGr.keySet())\n                if (con[c][u][v])\n                    count++;\n            out.println(count);\n        }\n            \n            \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(vector<pair<int, int> > adj[], vector<bool>& visited, int u, int c) {\n  visited[u] = true;\n  vector<pair<int, int> >::iterator it1;\n  for (it1 = adj[u].begin(); it1 != adj[u].end(); it1++) {\n    if (!visited[(*it1).first] && (*it1).second == c) {\n      dfs(adj, visited, (*it1).first, c);\n    }\n  }\n}\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int> > adj[101];\n  while (m--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    int ans = 0;\n    for (int i = 1; i <= 100; i++) {\n      vector<bool> visited(101, false);\n      dfs(adj, visited, x, i);\n      if (visited[y]) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, m, k;\nmap<long long int, long long int> m2;\nmap<int, int> m3;\nlong long int vis[101];\nvector<int> v2;\nlong long int x, y, c;\nint co = 0;\nvector<pair<long long int, long long int> > v[101];\nbool a[101];\nvoid dfs(int x1, int ci) {\n  if (x1 == y) {\n    co = 1;\n    return;\n  }\n  vis[x1] = 1;\n  for (int j = 0; j < v[x1].size(); j++) {\n    if (!vis[v[x1][j].first] && v[x1][j].second == ci) {\n      dfs(v[x1][j].first, ci);\n    }\n  }\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> x >> y >> c;\n    a[c] = 1;\n    v[x].push_back(make_pair(y, c));\n    v[y].push_back(make_pair(x, c));\n  }\n  int q;\n  cin >> q;\n  int c2;\n  for (int i = 1; i <= q; i++) {\n    cin >> x >> y;\n    c2 = 0;\n    for (int j = 1; j <= 100; j++) {\n      if (a[j] == 1) {\n        memset(vis, 0, sizeof(vis));\n        co = 0;\n        dfs(x, j);\n        if (co == 1) c2 += 1;\n      }\n    }\n    cout << c2 << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "class DisjointSet:      #only support query, NO construction supported\n    def __init__(self, n):\n        self.num_sets   = n         #--@union\n        self.parents    = list(range(n))\n        self.ranks      = [0] * n\n        self.sizes      = [1] * n   #used@union: size of set@root! 0 if NOT repsentive\n \n    def __str__(self):\n        return '%s'%self.parents\n\n    def __repr__(self):\n        return '%s'%self.parents\n\n    def find(self,j): #no compress\n        while self.parents[j]!=j:\n            j   = self.parents[j]\n        return j\n\n    def union(self,i,j):\n        i   = self.find(i)\n        j   = self.find(j)\n        if i == j:\n            return False\n        rd  = self.ranks[i] - self.ranks[j]\n        if   rd == 0:       # Increment repr0's rank if both nodes have same rank\n            self.ranks[i] += 1\n        elif rd <  0:       # Swap to ensure that repr0's rank >= repr1's rank\n            i, j = j, i\n        self.parents[j]  = i   #merge\n        self.sizes[i]   += self.sizes[j]\n        self.sizes[j]    = 0\n        self.num_sets   -= 1\n        return True\n\ndef main():\n    n,m =  list(map(int,input().split())) #100,100\n    el  = [list(map(int,input().split())) for _ in range(m)]\n    q   = int(input())\n    vl  = [list(map(int,input().split())) for _ in range(q)] \n\n    dl  = [DisjointSet(n) for _ in range(m)]\n    for a,b,c in el:\n        dl[c-1].union(a-1,b-1)\n    [print(sum([d.find(u-1)==d.find(v-1) for d in dl])) for u,v in vl]\n\nmain()\n\n'''\nimport cProfile\ncProfile.run(\"main()\")\n'''\n"
        },
        {
            "language": 3,
            "solution": "def iterative_bfs(graph, start, path=[]):\n  '''iterative breadth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if not v in path:\n      path=path+[v]\n      q=q+graph[v]\n  return path\n\ndx = {}\nnodes, edges = map(int, input().split(' '))\nfor c in range(edges+1):\n    graph = {}\n    for i in range(nodes):\n      graph[i] = []\n    dx[c] = graph\n\n\nfor i in range(edges):\n  a, b, c = map(int, input().split(' '))\n  dx[c][a-1].append(b-1)\n  dx[c][b-1].append(a-1)\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split(' '))\n    t = 0\n    for i in dx:\n        graph = dx[i]\n        \n        if b-1 in iterative_bfs(graph, a-1):\n            t += 1\n    print(t)"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tEdge[] edges = new Edge[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\t\n\t\t\tedges[i] = new Edge(u, v, c);\n\t\t}\n\t\t\n\t\tArrays.sort(edges);\n\t\t\n\t\tint[][] res = new int[n+1][n+1];\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tLinkedList<Integer>[] G = new LinkedList[n+1];\n\t\tboolean[] visited = new boolean[n+1];\n\t\tint pos = 0;\n\t\twhile(pos < m) {\n\t\t\tint c = edges[pos].c;\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tG[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\t\n\t\t\tvisited = new boolean[n+1];\n\t\t\t\n\t\t\twhile(pos < m && edges[pos].c == c) {\n\t\t\t\tint u = edges[pos].u;\n\t\t\t\tint v = edges[pos].v;\n\t\t\t\tG[u].add(v);\n\t\t\t\tG[v].add(u);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int v = 1; v <= n; v++) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tLinkedList<Integer> cc = bfs(G, v, visited);\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < cc.size(); k++) {\n\t\t\t\t\t\tfor (int kk = k + 1; kk < cc.size(); kk++) {\n\t\t\t\t\t\t\tint a = cc.get(k);\n\t\t\t\t\t\t\tint b = cc.get(kk);\n\t\t\t\t\t\t\tres[a][b]++;\n\t\t\t\t\t\t\tres[b][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = sc.nextInt();\n\t\twhile(k-- > 0) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tSystem.out.println(res[u][v]);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static LinkedList<Integer> bfs(LinkedList<Integer>[] G, int s, boolean[] visited) {\n\t\tLinkedList<Integer> cc = new LinkedList<Integer>();\n\t\tcc.addLast(s);\n\t\tvisited[s] = true;\n\t\tLinkedList<Integer> Q = new LinkedList<Integer>();\n\t\tQ.addLast(s);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint u = Q.removeFirst();\n\t\t\tfor (int v : G[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t\tQ.addLast(v);\n\t\t\t\t\tcc.addLast(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cc;\n\t}\n\t\n\tpublic static class Edge implements Comparable<Edge> {\n\t\tint u, v, c;\n\t\t\n\t\tEdge(int u, int v, int c) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn Integer.compare(c, e.c);\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%d, %d, %d)\", u, v, c);\n\t\t}\n\t\t\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<pair<int, int>> adj[4004];\nint vis[4004];\nbool dfs(int u, int col, int v) {\n  vis[u] = 1;\n  if (u == v) return true;\n  for (pair<int, int> p : adj[u]) {\n    if (vis[p.first] or p.second != col) {\n      continue;\n    }\n    if (dfs(p.first, col, v)) {\n      return true;\n    }\n  }\n  return false;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back({b, c});\n    adj[b].push_back({a, c});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int l, r;\n    cin >> l >> r;\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n      memset(vis, 0, sizeof(vis));\n      ans += dfs(l, i, r);\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 105;\nstruct Dsu {\n  int arr[maxn];\n  void init(int n) {\n    for (int i = 0; i <= n; i++) {\n      arr[i] = i;\n    }\n  }\n  int fnd(int x) { return arr[x] == x ? x : arr[x] = fnd(arr[x]); }\n  void join(int x, int y) {\n    x = fnd(x);\n    y = fnd(y);\n    if (x != y) arr[x] = y;\n  }\n  bool check(int x, int y) { return fnd(x) == fnd(y); }\n} dsu[maxn];\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= m; i++) dsu[i].init(n);\n  int u, v, c;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", &u, &v, &c);\n    dsu[c].join(u, v);\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    scanf(\"%d %d\", &u, &v);\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n      ans += dsu[i].check(u, v);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class c>\nstruct rge {\n  c b, e;\n};\ntemplate <class c>\nrge<c> range(c i, c j) {\n  return rge<c>{i, j};\n}\ntemplate <class c>\nauto dud(c* x) -> decltype(cerr << *x, 0);\ntemplate <class c>\nchar dud(...);\nstruct debug {\n  template <class c>\n  debug& operator<<(const c&) {\n    return *this;\n  }\n};\nint siz[105][105];\npair<int, int> par[105][105];\nvoid make_set(int i, int x) {\n  par[i][x].first = i, par[i][x].second = x;\n  siz[i][x] = 1;\n}\npair<int, int> find_set(pair<int, int> p) {\n  if (par[p.first][p.second].first == p.first &&\n      par[p.first][p.second].second == p.second) {\n    return p;\n  }\n  return par[p.first][p.second] = find_set(par[p.first][p.second]);\n}\nvoid union_set(int c, int a, int b) {\n  pair<int, int> x, y;\n  x.first = c;\n  x.second = find_set({c, a}).second;\n  y.first = c;\n  y.second = find_set({c, b}).second;\n  if (x != y) {\n    if (siz[c][x.second] < siz[c][y.second]) {\n      swap(x, y);\n    }\n    siz[c][x.second] += siz[c][y.second];\n    par[c][y.second] = par[c][x.second];\n  }\n}\nvoid tcase(int Tcase) {\n  int n, m, a, b, c, q;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n      make_set(i, j);\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    union_set(c, a, b);\n  }\n  scanf(\"%d\", &q);\n  while (q--) {\n    int cnt = 0;\n    scanf(\"%d %d\", &a, &b);\n    for (int i = 1; i <= m; i++) {\n      if (find_set({i, a}) == find_set({i, b})) {\n        cnt++;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n}\nint main() {\n  int T = 1;\n  for (int Tcase = 1; Tcase <= T; Tcase++) {\n    tcase(Tcase);\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sets import Set\n\nvisited = []\ngraph = {}\ncores = Set()\n\ndef has_c_path(u, v, c):\n  visited[u] = True\n  if u == v: return 1\n  for x in graph[u]:\n    if x[1] != c: continue\n    if visited[x[0]] == True: continue\n    resp = has_c_path(x[0], v, c)\n    if resp == 1 : return 1\n    \n  return 0 \n\ns = raw_input().split(\" \")\nn = int(s[0])\nm = int(s[1])\n\nfor i in range(1, n+1):\n  graph[i] = []\n\nfor i in range(m):\n  s = raw_input().split(\" \")\n  a = int(s[0])\n  b = int(s[1])\n  c = int(s[2])\n  cores.add(c)\n  graph[b].append((a, c))\n  graph[a].append((b, c))\n\nq = int(raw_input())\nfor i in range(q):\n  ans = 0\n  s = raw_input().split(\" \")\n  u = int(s[0])\n  v = int(s[1])\n  for cor in cores:\n    visited = [False] * (n + 1)\n    result = has_c_path(u, v, cor)\n    ans += result\n  print ans\n  \n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CFS505B {\n\n\tpublic final static String IN_FILE = \"test/CFS505B.in\";\n\tpublic final static String OUT_FILE = \"test/CFS505B.out\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// InputStream in = new FileInputStream(IN_FILE);\n\t\t//\n\t\t// @SuppressWarnings(\"resource\")\n\t\t// PrintStream out = new PrintStream(OUT_FILE);\n\n\t\tInputStream in = System.in;\n\t\tPrintStream out = System.out;\n\n\t\tScanner IN = new Scanner(in);\n\n\t\tint n = IN.nextInt();\n\t\tint m = IN.nextInt();\n\n\t\tint[][][] G = new int[n + 1][n + 1][m + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tArrays.fill(G[i][j], 0);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = IN.nextInt();\n\t\t\tint b = IN.nextInt();\n\t\t\tint c = IN.nextInt();\n\n\t\t\tG[a][b][c] = 1;\n\t\t\tG[b][a][c] = 1;\n\t\t}\n\n\t\tint q = IN.nextInt();\n\t\tint[] u = new int[q];\n\t\tint[] v = new int[q];\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tu[i] = IN.nextInt();\n\t\t\tv[i] = IN.nextInt();\n\t\t}\n\n\t\tIN.close();\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int l = 1; l <= m; l++) {\n\t\t\t\t\t\tif (G[i][k][l] == 1 && G[k][j][l] == 1) {\n\t\t\t\t\t\t\tG[i][j][l] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (G[u[i]][v[i]][j] == 1) {\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(t);\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int[] used;\n    static int[][][] g;\n    static int ver;\n    static int n;\n\n    static int dfs(int u, int v, int c) {\n        if(u == v) return 1;\n        int ans = 0;\n        used[u] = ver;\n        for (int i = 0; i < n; i++) {\n            if(used[i] != ver && g[u][i][c] == 1) {\n                ans = Math.max(ans, dfs(i, v, c));\n            }\n        }\n        return ans;\n    }\n\n    void solve() throws IOException {\n        n = nextInt();\n        int m = nextInt();\n        g = new int[n][n][m + 2];\n        for (int i = 0; i < m; i++) {\n            int a = nextInt() - 1;\n            int b = nextInt() - 1;\n            int c = nextInt();\n            g[a][b][c] = 1;\n            g[b][a][c] = 1;\n        }\n        int q = nextInt();\n        used = new int[n];\n        Arrays.fill(used, -1);\n        for (int i = 0; i < q; i++) {\n            int u = nextInt() - 1;\n            int v = nextInt() - 1 ;\n            int ans = 0;\n            for (int j = 1; j <= m; j++) {\n                ans += dfs(u, v, j);\n                ver++;\n            }\n            System.out.println(ans);\n        }\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            solve();\n            out.close();\n            br.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(239);\n        }\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String line = br.readLine();\n            if (line == null) {\n                return null;\n            }\n            st = new StringTokenizer(line);\n        }\n        return st.nextToken();\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
        },
        {
            "language": 1,
            "solution": "from collections import *\n\nclass UnionRank:\n  def __init__(self, n):\n    self.n       = n\n    self.parent  = range(n+1)\n    self.rank    = [0]*(n+1)\n    self.sizes   = [1]*(n+1)\n\n  def union(self, x, y):\n    xRoot = self.find(x)\n    yRoot = self.find(y)\n    if (xRoot == yRoot): return 0\n\n    newRoot = xRoot if self.rank[xRoot] > self.rank[yRoot] else yRoot\n    otherRoot = xRoot if newRoot==yRoot else yRoot\n    \n    result = self.sizes[newRoot]*self.sizes[otherRoot]\n    self.parent[otherRoot] = newRoot\n    self.sizes [newRoot] += self.sizes[otherRoot]\n    if self.rank[xRoot] == self.rank[yRoot]:\n      self.rank[newRoot] += 1\n\n    return result\n\n  def find(self, x):\n    start = x\n    path = []\n\n    while self.parent[start] != start:\n      path.append(start)\n      start = self.parent[start]\n\n    for elt in path:\n      self.parent[elt] = start\n\n    return start\n\n  def same(self, x, y):\n    return self.find(x)==self.find(y)\n\n  def sets(self):\n    sets = defaultdict(set)\n    for i in xrange(1,self.n+1):\n      sets[self.find(i)].add(i)\n    return sets.values()\n\nn,m = map(int, raw_input().split())\ncolor = [UnionRank(n) for _ in xrange(101)]\nfor i in xrange(m):\n  a,b,c = map(int, raw_input().split())\n  color[c].union(a,b)\n\nfor i in xrange(int(raw_input())):\n  a,b = map(int, raw_input().split())\n  print sum(color[c].same(a,b) for c in xrange(101))\n"
        },
        {
            "language": 3,
            "solution": "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\nparent_history = {}\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        if c in parent_history:\n            if v in parent_history[c]:\n                parent = parent_history[c]\n                if u in parent:\n                    x += 1\n            elif u in parent_history[c]:\n                parent = parent_history[c]\n                if v in parent:\n                    x += 1\n            else:\n                parent = {}\n                parent = dfs_visit(v, graph[c], parent)\n                if len(parent_history[c]) < len(parent):\n                    parent_history[c] = parent\n                if u in parent:\n                    x += 1\n        else:\n            parent = {}\n            parent = dfs_visit(v, graph[c], parent)\n            parent_history[c] = parent\n            if u in parent:\n                x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<pair<int, int>> g[105];\nint vis[105];\nbool dfs(int str, int col, int dst) {\n  vis[str] = 1;\n  if (str == dst) return 1;\n  for (int i = 0; i < g[str].size(); i++) {\n    if (g[str][i].second == col && !vis[g[str][i].first]) {\n      if (dfs(g[str][i].first, col, dst)) return true;\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> m;\n  int a, b, c;\n  for (int i = 1; i <= m; i++) {\n    cin >> a >> b >> c;\n    g[a].push_back(make_pair(b, c));\n    g[b].push_back(make_pair(a, c));\n  }\n  int q;\n  cin >> q;\n  for (int t = 1; t <= q; t++) {\n    int u, v;\n    cin >> u >> v;\n    int ans = 0;\n    for (int i = 1; i <= 100; i++) {\n      memset(vis, 0, sizeof(vis));\n      if (dfs(u, i, v)) ans++;\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct node {\n  int x;\n  struct node* next;\n};\nstruct node* adj[105][105];\nint v[105][105];\nint cc;\nvoid DFS(int u, int w) {\n  v[w][u] = cc;\n  struct node* temp = adj[w][u];\n  while (temp) {\n    if (v[w][temp->x] == 0) {\n      DFS(temp->x, w);\n    }\n    temp = temp->next;\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < 105; i++) {\n    for (int j = 0; j < 105; j++) {\n      adj[i][j] = NULL;\n      v[i][j] = 0;\n    }\n  }\n  int v1, v2, w;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &v1, &v2, &w);\n    v1--;\n    v2--;\n    w--;\n    struct node* temp = (struct node*)malloc(sizeof(struct node));\n    temp->x = v2;\n    temp->next = adj[w][v1];\n    adj[w][v1] = temp;\n    struct node* tmp = (struct node*)malloc(sizeof(struct node));\n    tmp->x = v1;\n    tmp->next = adj[w][v2];\n    adj[w][v2] = tmp;\n  }\n  for (int i = 0; i < m; i++) {\n    cc = 0;\n    for (int j = 0; j < n; j++) {\n      if (v[i][j] == 0) {\n        cc++;\n        DFS(j, i);\n      }\n    }\n  }\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d%d\", &v1, &v2);\n    v1--;\n    v2--;\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n      if (v[i][v1] == v[i][v2] && v[i][v1] != 0 && v[i][v2] != 0) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n#from fractions import *\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n#-------------------------code---------------------------#\n#vsInput()\n\ndef bfs(adj,s,k):\n    #print(adj)\n    vis={i:False for i in adj}\n    vis[s]=True\n    qu=[s]\n    while(len(qu)!=0):\n        e=qu.pop(0)\n        if(e==k):return True\n        for i in adj[e]:\n            if(vis[i]!=True):\n                qu.append(i)\n                vis[i]=True\n    return False\n\nn,m=value()\nadj={i:defaultdict(list) for i in range(1,m+1)}\nfor i in range(m):\n    s,d,c=value()\n    adj[c][s].append(d)\n    adj[c][d].append(s)\n#print(adj[1].keys())\nfor i in range(Int()):\n    s,d=value()\n    ans=0\n    for i in range(1,m+1):\n        if(s in adj[i].keys() and bfs(adj[i],s,d)):\n            ans+=1\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> adj[101];\nset<pair<long long int, long long int>> color[101];\nlong long int visited[101];\nlong long int x;\nvoid dfs(long long int a, long long int b, long long int c) {\n  visited[a] = 1;\n  if (a == b) {\n    x = 1;\n  }\n  for (long long int i = 0; i < adj[a].size(); i++) {\n    if (visited[adj[a][i]] == 0 &&\n        color[c].find({a, adj[a][i]}) != color[c].end()) {\n      dfs(adj[a][i], b, c);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int i, j, k, l, m, n, p, t, a, b, c, q;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n    color[c].insert({a, b});\n    color[c].insert({b, a});\n  }\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    cin >> a >> b;\n    p = 0;\n    for (j = 1; j <= m; j++) {\n      x = 0;\n      dfs(a, b, j);\n      p += x;\n      memset(visited, 0, sizeof(visited));\n    }\n    cout << p << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class _505B_Mr_Kitayuta_s_Colorful_Graph{\nstatic Lista A[];\nstatic int x,y,c;\nstatic boolean Encon;\n    public static void  calcula(int i){\n    \tA[i].M[x][c]= true;\n    \tif(i!=y){\n    \tif(!A[i].t){  \n    \tA[i].t=true;\n             if(!A[i].M[y][c]){\n            \tfor (int j = 0; j < A[i].colour[c].size() && !Encon; j++){\n\t\t\t\t\tint h = A[i].colour[c].remove();\n\t\t\t\t\tA[i].colour[c].add(h);\n\t\t\t\t\t\n\t\t\t\t\tcalcula(h);\n\t\t\t\t}\n            \tif(Encon)A[i].M[y][c]= true;\n             }else{\n            \t Encon=true;\n             }\n             A[i].t=false;\n    \t  }\n    \t}else \n    \tEncon= true;\n    }\n\tpublic static void main(String[] args){\n     Scanner leer = new Scanner(System.in);\n     int n = leer.nextInt();\n     int m = leer.nextInt();\n     A = new Lista[n+1];\n     for (int i = 1; i <=n; i++) \n\t\tA[i]= new Lista(n,m);\n     \n     for (int i = 0; i < m; i++){\n\t\t x = leer.nextInt();\n\t\t y = leer.nextInt();\n\t\t c = leer.nextInt();\n\t\t A[x].add(y);\n\t\t A[y].add(x);\n\t }    \n     int q = leer.nextInt();\n     for (int i = 0; i < q; i++){\n\t\tx= leer.nextInt();\n\t\ty= leer.nextInt();\n\t    int h;\n\t    if(y<x){h=y;y=x;x=h;}\n\t    h=0;\n\t    for (int j = 0; j < A[x].C.size(); j++){\n\t\t\tc = A[x].C.remove();\n\t\t\tA[x].C.add(c);\n\t\t\tEncon=false;\n\t\t\tcalcula(x);\n\t\t\tif(Encon)h++;\n\t\t}\n\t    System.out.println(h);\n     }\n\t}\n\tstatic class Lista{\n\t\tLinkedList<Integer> colour[];\n\t\tLinkedList<Integer> C;\n\t\tboolean M[][];\n\t\tboolean t;\n\t\tpublic Lista(int n, int m){\n\t\t\tcolour= new LinkedList[m+1];\n\t\t\tM= new boolean[n+1][m+1];\n\t\t\tC= new LinkedList<Integer>();\n\t\t\tt = false;\n\t\t}\n\t\tpublic void add(int h){\n\t\t\tif(colour[c]==null)\n\t\t\t{\tcolour[c]= new LinkedList<Integer>();\n\t\t\t    C.add(c);\n\t\t\t}\n\t\t\tcolour[c].add(h);\n\t\t\tM[h][c]=true;\n\t\t}\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> v;\nvector<vector<pair<int, int>>> g;\nvector<int> used;\nint N, M;\nvoid dfs(int i, int j, int I, int m) {\n  if (i == j) v[I][j]++;\n  used[i] = 1;\n  for (auto u : g[i]) {\n    if (!used[u.second] && m == u.first) dfs(u.second, j, I, m);\n  }\n}\nint main() {\n  cin >> N >> M;\n  g.resize(N + 1);\n  used.resize(N + 1);\n  v.resize(N + 1, vector<int>(N + 1));\n  for (int i = 0; i < M; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[a].push_back({c, b});\n    g[b].push_back({c, a});\n  }\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if (i == j) continue;\n      for (int f = 1; f <= M; f++) {\n        used.assign(N + 1, 0);\n        dfs(i, j, i, f);\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n    cout << v[a][b] << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[2000005] = {0};\nvoid factorial() {\n  fac[0] = 1;\n  fac[1] = 1;\n  for (long long i = 2; i < 200005; i++)\n    fac[i] = ((i % 1000000007) * (fac[i - 1] % 1000000007)) % 1000000007;\n}\nlong long power(long long n, long long m) {\n  long long p = 1;\n  if (m == 0) return 1;\n  p = (power(n, m / 2) % 1000000007);\n  p = (p % 1000000007 * p % 1000000007) % 1000000007;\n  return (m & 1 ? ((p % 1000000007 * n % 1000000007) % 1000000007)\n                : (p % 1000000007));\n}\nlong long ncr(long long n, long long r) {\n  return ((fac[n] * power(fac[r], 1000000007 - 2)) % 1000000007 *\n          power(fac[n - r], 1000000007 - 2)) %\n         1000000007;\n}\nvector<pair<long long, long long> > graph[102];\nlong long n, m;\nlong long cnt = 0;\nlong long used[101] = {0};\nvoid dfs(long long x, long long y, long long col) {\n  used[x] = 1;\n  if (x == y) {\n    ++cnt;\n    return;\n  }\n  for (long long i = 0; i < graph[x].size(); i++) {\n    pair<long long, long long> p = graph[x][i];\n    if (p.second == col && !used[p.first]) {\n      dfs(p.first, y, col);\n    }\n  }\n  return;\n}\nvoid ram5564() {\n  cin >> n >> m;\n  while (m--) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    graph[a].push_back(make_pair(b, c));\n    graph[b].push_back(make_pair(a, c));\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    long long x, y;\n    cin >> x >> y;\n    cnt = 0;\n    for (long long i = 1; i < 101; i++) {\n      memset(used, 0, sizeof(used));\n      dfs(x, y, i);\n    }\n    cout << cnt << \"\\n\";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) ram5564();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 5;\nconst long long int inf64 = 1e18 + 5;\nconst int MAX = 105;\nbool vis[MAX];\nvector<int> adj[MAX][MAX];\nvoid dfs(int x, int col) {\n  vis[x] = true;\n  for (auto v : adj[col][x]) {\n    if (!vis[v]) dfs(v, col);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q, i, j, a, b, c;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    adj[c][a].push_back(b);\n    adj[c][b].push_back(a);\n  }\n  cin >> q;\n  while (q--) {\n    cin >> a >> b;\n    int ans = 0;\n    for (i = 1; i <= m; i++) {\n      memset(vis, false, sizeof vis);\n      dfs(a, i);\n      ans += vis[b];\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), m = scn.nextInt();\n\t\tDisJointSet[] dj = new DisJointSet[m];\n\t\tArrays.setAll(dj, i -> new DisJointSet(n));\n\t\t\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint u = scn.nextInt() - 1, v = scn.nextInt() - 1, w = scn.nextInt() - 1;\n\t\t\tdj[w].union(u, v);\n\t\t}\n\t\t\n\t\tfor(int i = scn.nextInt(); i > 0; i--) {\n\t\t\tint u = scn.nextInt() - 1, v = scn.nextInt() - 1, ans = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(dj[j].isSame(u, v)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tclass DisJointSet {\n\t\tint[] table, rank, count;\n\t\tint size;\n\n\t\tDisJointSet(int size) {\n\t\t\tthis.table = new int[size];\n\t\t\tthis.rank = new int[size];\n\t\t\tthis.count = new int[size];\n\t\t\tthis.size = size;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tthis.table[i] = i;\n\t\t\t\tthis.rank[i] = 1;\n\t\t\t\tthis.count[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int node) {\n\t\t\tif (table[node] == node) {\n\t\t\t\treturn node;\n\t\t\t} else {\n\t\t\t\treturn table[node] = root(table[node]);\n\t\t\t}\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y)\n\t\t\t\tthis.size--;\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\ttable[x] = y;\n\t\t\t\tcount[y] += count[x];\n\t\t\t} else if (rank[x] > rank[y]) {\n\t\t\t\ttable[y] = x;\n\t\t\t\tcount[x] += count[y];\n\t\t\t} else if (x != y) {\n\t\t\t\ttable[y] = x;\n\t\t\t\tcount[x] += count[y];\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 27).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t\tarr[j] = arr[i] ^ arr[j];\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def gerarGrafo(cor):\n    adjancencias = {}\n    for aresta in arestas:\n        if aresta[2] == cor:\n            if adjancencias.get(aresta[0]) == None:\n                adjancencias[aresta[0]] = []\n            if adjancencias.get(aresta[1]) == None:\n                adjancencias[aresta[1]] = []\n            adjancencias[aresta[0]].append(aresta[1])\n            adjancencias[aresta[1]].append(aresta[0])\n    return adjancencias\n\ndef dfs(u, w, adjacencias):\n    pilha = [u]\n    visitados = {u: 1}\n    existeCaminhoUV = False\n    if adjacencias.get(u) == None or adjacencias.get(w) == None:\n        return existeCaminhoUV\n    \n    while len(pilha) > 0:\n        vertice = pilha.pop()\n        for v in adjacencias[vertice]:\n            if visitados.get(v) == None:\n                visitados[v] = 1\n                pilha.append(v)\n    if visitados.get(w) != None:\n        existeCaminhoUV = True\n    return existeCaminhoUV\n    \n\nentrada = input().split()\nn = int(entrada[0])\nm = int(entrada[1])\ncores = set()\narestas = []\n\ni = 0\nwhile i < m:\n    aresta = input().split()\n    cores.add(aresta[2])\n    arestas.append(aresta)\n    i += 1\n\nq = int(input())\nparesVertices = []\n\ni = 0\nwhile i < q:\n    paresVertices.append(input().split())\n    i += 1\n\nres = [0] * q\nfor cor in cores:\n    grafo = gerarGrafo(cor)\n    i = 0\n    for par in paresVertices:\n        if dfs(par[0], par[1], grafo):\n            res[i] += 1\n        i += 1\n\nfor e in res:\n    print(e)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6;\nvector<pair<int, int> > v[N];\nint vis[N], a[N];\nvoid dfs(int x, int y, int c) {\n  if (vis[x]) return;\n  vis[x] = 1;\n  if (x == y) a[c] = 1;\n  for (auto i : v[x]) {\n    if ((!vis[i.first]) && i.second == c) dfs(i.first, y, c);\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    v[b].push_back({a, c});\n  }\n  int q;\n  cin >> q;\n  for (int i = 1; i <= q; ++i) {\n    int l, r, f = 0;\n    cin >> l >> r;\n    for (auto j : v[l]) {\n      dfs(l, r, j.second);\n      memset(vis, 0, sizeof(vis));\n    }\n    for (int i = 1; i <= m; ++i) f += a[i];\n    cout << f;\n    cout << \"\\n\";\n    memset(a, 0, sizeof(a));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m=map(int,input().split())\nINF=10**18\nd=[[[INF]*n for j in range(n)] for i in range(m)]\nedges=[[[] for i in range(n)] for i in range(m)]\nfor _ in range(m):\n  a,b,c=map(int,input().split())\n  a-=1\n  b-=1\n  c-=1\n  edges[c][a].append(b)\n  edges[c][b].append(a)\n  d[c][a][b]=d[c][b][a]=1\nfor color in range(m):\n  for s in range(n):\n    q=[s]\n    visited=[False]*n\n    visited[s]=True\n    while q:\n      node=q.pop(0)\n      visited[node]=True\n      for to in edges[color][node]:\n        if visited[to]:\n          continue\n        d[color][s][to]=d[color][to][s]=1\n        q.append(to)\nQ=int(input())\nfor _ in range(Q):\n  u,v=map(int,input().split())\n  u-=1\n  v-=1\n  ans=0\n  for color in range(m):\n    if d[color][u][v]<INF:\n      ans+=1\n  print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct uf {\n  static const int MAXN = 105;\n  int par[MAXN];\n  int size[MAXN];\n  void init() {\n    memset(par, -1, sizeof(par));\n    for (int i = 0; i < (MAXN); ++i) size[i] = 1;\n  }\n  int root(int a) {\n    if (par[a] == -1) return a;\n    return par[a] = root(par[a]);\n  }\n  void unite(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return;\n    if (size[a] < size[b]) swap(a, b);\n    par[b] = a;\n    size[a] += size[b];\n  }\n  bool same(int a, int b) { return root(a) == root(b); }\n};\nuf u_[105];\nint n, m;\nint main() {\n  for (int i = 0; i < (100); ++i) u_[i].init();\n  cin >> n >> m;\n  for (int i = 0; i < (m); ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a;\n    --b;\n    --c;\n    u_[c].unite(a, b);\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int res = 0;\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    for (int i = 0; i < (100); ++i)\n      if (u_[i].same(u, v)) ++res;\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q, a, b, c, s, t;\nbool v[105];\nvector<int> adj[105][105];\nint dp[105][105][105];\nint dfs(int par, int cur, int t, int cg) {\n  v[cur] = true;\n  if (cur == t) return 1;\n  for (int x : adj[cur][cg]) {\n    if (!v[x])\n      if (dfs(cur, x, t, cg)) return 1;\n  }\n  return 0;\n}\nint main() {\n  memset(dp, 0, sizeof dp);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    adj[a][c].push_back(b);\n    adj[b][c].push_back(a);\n  }\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d\", &s, &t);\n    int ans = 0;\n    for (int j = 1; j <= m; j++) {\n      memset(v, 0, sizeof v);\n      ans += dfs(0, s, t, j);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aldo Culquicondor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            DisjointSet[] set = new DisjointSet[m];\n            for (int i = 0; i < m; ++i)\n                set[i] = new DisjointSet(n);\n            int u, v, c;\n            for (int i = 0; i < m; ++i) {\n                u = in.nextInt() - 1;\n                v = in.nextInt() - 1;\n                c = in.nextInt() - 1;\n                set[c].join(u, v);\n            }\n            int q = in.nextInt();\n            while (q-- > 0) {\n                u = in.nextInt() - 1;\n                v = in.nextInt() - 1;\n                c = 0;\n                for (int i = 0; i < m; ++i)\n                    if (set[i].same(u, v))\n                        ++c;\n                out.println(c);\n            }\n        }\n\n    }\n\n    static class DisjointSet {\n        private int[] pi;\n        private int[] rank;\n\n        public DisjointSet(int size) {\n            pi = new int[size];\n            rank = new int[size];\n            Arrays.fill(rank, 0);\n            for (int i = 0; i < size; ++i)\n                pi[i] = i;\n        }\n\n        public int find(int x) {\n            return pi[x] = (x == pi[x] ? x : find(pi[x]));\n        }\n\n        public void join(int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (rank[x] < rank[y]) {\n                pi[x] = y;\n            } else if (rank[x] > rank[y]) {\n                pi[y] = x;\n            } else {\n                pi[x] = y;\n                ++rank[y];\n            }\n        }\n\n        public boolean same(int x, int y) {\n            return find(x) == find(y);\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<int, int>>> v(505);\nint vis[1000];\nbool ch;\nvoid dfs(int s, int c, int la) {\n  vis[s] = 1;\n  for (auto i : v[s]) {\n    if (!vis[i.first] && i.second == c) {\n      if (i.first == la) ch = 1;\n      dfs(i.first, c, la);\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back(make_pair(b, c));\n    v[b].push_back(make_pair(a, c));\n  }\n  int ans = 0;\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int a, b;\n    cin >> a >> b;\n    for (int j = 1; j <= 500; j++) {\n      dfs(a, j, b);\n      if (ch == 1) ans++;\n      ch = 0;\n      memset(vis, 0, sizeof vis);\n    }\n    cout << ans << endl;\n    ans = 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = map(int, input().split())\nl = []\nfor i in range(m):\n    a,b,c = map(int, input().split())\n    if len(l) <= c-1:\n        for i in range(c-len(l)):\n            l.append([])\n    p = l[c-1]\n    m = []\n    for i in range(len(p)):\n        if a in p[i] or b in p[i]:\n            m.append(i)\n    new = [a,b]\n    for i in range(len(m)):\n        new = new + p[m[i]]\n    for i in range(len(m)):\n        p.pop(m[i]-i)\n    p.append(new)\n    l[c-1] = p\nq = int(input())\nfor i in range(q):\n    counter = 0\n    u,v = map(int, input().split())\n    for j in range(len(l)):\n        yes = 0\n        for k in range(len(l[j])):\n            if yes == 0 and u in l[j][k] and v in l[j][k]:\n                yes = 1\n                counter += 1\n    print(counter)\n"
        },
        {
            "language": 4,
            "solution": "/*\nID: wilbs43\nLANG: JAVA7\nSTATUS: incomplete\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class CF505B {\n\tstatic int n, m;\n//\tstatic TreeMap<Integer, TreeSet<Integer>> adj;\n\tstatic TreeMap<Integer, ArrayList<int[]>> edges;\n\n\tpublic static void main(String[] args) throws IOException {\n\t//\tScanner in = new Scanner(new File(\"CF505B.in\"));\n\t\tScanner in = new Scanner(System.in);\n\t\tString line0[] = in.nextLine().split(\" \");\n\t\tn = Integer.parseInt(line0[0]);\n\t\tm = Integer.parseInt(line0[1]);\n//\t\tSystem.out.println(n + \" \" + m);\n//\t\tadj = new TreeMap<Integer, TreeSet<Integer>>();\n\t\tedges = new TreeMap<Integer, ArrayList<int[]>>();\n\t\tfor (int i = 0; i <= m+2; i++) {\n\t\t\tedges.put(i, new ArrayList<int[]>());\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString line1[] = in.nextLine().split(\" \");\n\t\t\tint st = Integer.parseInt(line1[0]);\n\t\t\tint en = Integer.parseInt(line1[1]);\n\t\t\tint col = Integer.parseInt(line1[2]);\n\t\t\tint[] edge = { st, en };\n\t\t\tedges.get(col).add(edge);\n\t\t}\n//\t\tfor (int i = 0; i < edges.size(); i++) {\n//\t\t\tfor (int[] el : edges.get(i)) {\n//\t\t\t\tSystem.out.print(Arrays.toString(el));\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint quer = Integer.parseInt(in.nextLine());\n\t\tfor (int i = 0; i < quer; i++) {\n\t\t\tString line3[] = in.nextLine().split(\" \");\n\t\t\tint st = Integer.parseInt(line3[0]);\n\t\t\tint en = Integer.parseInt(line3[1]);\n\t\t\tint ct = 0;\n\t\t\tfor(int j = 0 ; j<= m+2; j++) {\n\t\t\t\tif(check(st,en,j)) {\n\t\t\t\t\tct++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ct);\n\t\t}\n\t\t\t\t\n\t}\n\n\tstatic boolean[] reached;\n\n\tpublic static boolean check(int st, int en, int col) {\n\t\treached = new boolean[n+2];\n\t\ttrav(st, col);\n\t\treturn reached[en];\n\t}\n\n\tpublic static void trav(int cur, int col) {\n\t//\tSystem.out.println(cur+\" Color:\"+col);\n\t\tif(reached[cur]) return;\n\t\treached[cur] = true;\n\t\tfor(int[] edge: edges.get(col)) {\n\t\t\tif(edge[0] == cur)\n\t\t\t\ttrav(edge[1],col);\n\t\t\telse if(edge[1] == cur) {\n\t\t\t\ttrav(edge[0],col);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "//################################################################################################################\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Set;\n\n//################################################################################################################\npublic class R286D2B {\n\tpublic static void main(String[] args) {\n\t\tR286D2B b = new R286D2B();\n\t\tInputReader1 reader = b.new InputReader1(System.in);\n\t\tOutputWriter writer = b.new OutputWriter(System.out);\n\t\t// think about the brute-force approach\n\t\t// read input\n\t\t// code boundary conditions\n\t\tint n = reader.readInt();\n\t\tint m = reader.readInt();\n\t\tList<List<Set<Integer>>> graph = new ArrayList<List<Set<Integer>>>();\n\t\tSet<Integer> uc = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tList<Set<Integer>> tmp = new ArrayList<Set<Integer>>();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\ttmp.add(new HashSet<Integer>());\n\t\t\t}\n\t\t\tgraph.add(tmp);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint ai = reader.readInt() - 1;\n\t\t\tint bi = reader.readInt() - 1;\n\t\t\tint ci = reader.readInt();\n\t\t\tif (!uc.contains(ci)) {\n\t\t\t\tuc.add(ci);\n\t\t\t}\n\t\t\tgraph.get(ai).get(bi).add(ci);\n\t\t\tgraph.get(bi).get(ai).add(ci);\n\t\t}\n\t\tint[][] count = new int[n][n];\n\t\tfor (int ci : uc) {\n\t\t\tboolean[][] exists = new boolean[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (graph.get(i).get(j).contains(ci)) {\n\t\t\t\t\t\texists[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\texists[i][j] = (exists[i][j] || (exists[i][k] && exists[j][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (exists[i][j]) {\n\t\t\t\t\t\tcount[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint q = reader.readInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint ui = reader.readInt() - 1;\n\t\t\tint vi = reader.readInt() - 1;\n\t\t\twriter.println(count[ui][vi]);\n\t\t}\n\t\treader.close();\n\t\twriter.close();\n\t}\n\n\tclass InputReader1 {\n\t\t// private final boolean finished = false;\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader1(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int peek() {\n\t\t\tif (numChars == -1)\n\t\t\t\treturn -1;\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint length = readInt();\n\t\t\tif (length < 0)\n\t\t\t\treturn null;\n\t\t\tbyte[] bytes = new byte[length];\n\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\tbytes[i] = (byte) read();\n\t\t\ttry {\n\t\t\t\treturn new String(bytes, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\treturn new String(bytes);\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate String readLine0() {\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tint c = read();\n\t\t\twhile (c != '\\n' && c != -1) {\n\t\t\t\tif (c != '\\r')\n\t\t\t\t\tbuf.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\n\t\tpublic String readLine() {\n\t\t\tString s = readLine0();\n\t\t\twhile (s.trim().length() == 0)\n\t\t\t\ts = readLine0();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\t\tif (ignoreEmptyLines)\n\t\t\t\treturn readLine();\n\t\t\telse\n\t\t\t\treturn readLine0();\n\t\t}\n\n\t\tpublic BigInteger readBigInteger() {\n\t\t\ttry {\n\t\t\t\treturn new BigInteger(readString());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tpublic char readCharacter() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\tpublic double readDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isExhausted() {\n\t\t\tint value;\n\t\t\twhile (isSpaceChar(value = peek()) && value != -1)\n\t\t\t\tread();\n\t\t\treturn value == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\n\t\tpublic boolean readBoolean() {\n\t\t\treturn readInt() == 1;\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tclass OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream stream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\tstream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\twriter.println(s);\n\t\t}\n\n\t\tpublic void println(int x) {\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void print(int x) {\n\t\t\twriter.print(x);\n\t\t}\n\n\t\tpublic void println(long x) {\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void printSpace() {\n\t\t\twriter.print(\" \");\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> conn[105];\nint mark[105];\nvoid dfs(int u, int c) {\n  mark[u] = true;\n  int sz = conn[u].size();\n  for (int i = 0; i < sz; i += 2) {\n    int v = conn[u][i], x = conn[u][i + 1];\n    if (!mark[v] and x == c) dfs(v, c);\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    conn[a].push_back(b);\n    conn[a].push_back(c);\n    conn[b].push_back(a);\n    conn[b].push_back(c);\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    int res = 0;\n    for (int i = 1; i <= m; ++i) {\n      memset(mark, 0, sizeof mark);\n      dfs(u, i);\n      if (mark[v]) res++;\n    }\n    printf(\"%d\\n\", res);\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "l=map(int,raw_input().split())\ndict={}\ncount=[0]\n\n\nfor i in range(l[1]):\n    edge=map(int,raw_input().split())\n    if edge[2] in dict:\n        dict[edge[2]].append([edge[0],edge[1]])\n    else:\n        dict[edge[2]]=[[edge[0],edge[1]]]\nz=input()\n\nfor k in dict.keys():\n    adj_list=[]\n    for i in range(l[0]+1):\n        adj_list.append([])\n    for v in dict[k]:\n        adj_list[v[0]].append(v[1])\n        adj_list[v[1]].append(v[0])\n    dict[k]=adj_list\n\n\ndef search_DFS(G,s,d):\n    if(colour[s]==0):\n        colour[s]=1\n    for i in G[s]:\n        if(colour[i]==0):\n            colour[i]=1\n            if(i==d):\n                count[0]+=1\n                return None\n            search_DFS(G,i,d)\n\n\nfor j in range(z):\n    go=map(int,raw_input().split())\n    for k in dict.keys():\n        colour=[]\n        for i in range(l[0]+1):\n            colour.append(0)\n        search_DFS(dict[k],go[0],go[1])\n    print count[0]\n    count[0]=0\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\npublic class Main{\n\tstatic int vertices,edges,cur;\n\tstatic List<Integer>[][] adjlist;\n\tstatic int[][] comp;\n\tstatic int max=101;\n\tstatic boolean[] visited;\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputReader ir=new InputReader(System.in);\n\t\tOutputWriter ow=new OutputWriter(System.out);\n\t\tvertices=ir.readInt();\n\t\tedges=ir.readInt();\n\t\tintialize();\n\t\tfor(int i=0;i<edges;++i)\n\t\t\taddEdge(ir.readInt(),ir.readInt(),ir.readInt());\n\t\tint queries=ir.readInt();\n\t\tdfs();\n\t\twhile(queries-->0){\n             int v1=ir.readInt();\n             int v2=ir.readInt();\n             int colors=0;\n             for(int i=1;i<comp.length;++i)\n             \tif(comp[i][v1]==comp[i][v2])\n             \t\t++colors;\n             ow.printLine(colors);\n\t\t}\n\t\tow.flush();\n\t\tow.close();\t\t\n\t}\n\tstatic void intialize(){\n\t\tadjlist=(List<Integer>[][])new List[max][];\n\t\tfor(int i=1;i<adjlist.length;++i){\n\t\t\tadjlist[i]=(List<Integer>[])new List[vertices+1];\n\t\t\tfor(int j=1;j<vertices+1;++j)\n\t\t\t\tadjlist[i][j]=new ArrayList<Integer>();\n\t\t}\n\t}\n\tstatic void addEdge(int u,int v,int c){\n\t\tadjlist[c][v].add(u);\n\t\tadjlist[c][u].add(v);\n\t}\n\tstatic void dfs()\n\t{\n       comp=new int[101][vertices+1];\n       for(int i=1;i<comp.length;++i){\n       \tvisited=new boolean[vertices+1];\n       \tcur=0;\n       \tfor(int j=1;j<vertices+1;++j){\n       \tif(!visited[j]){\n       \t\t++cur;\n       \t\tdfs(j,i);\n       \t}\n       }\n       }\n\t}\n\tstatic void dfs(int v,int c)\n\t{\n\t\tif(visited[v])\n\t\t\treturn;\n\t\tvisited[v]=true;\n\t\tcomp[c][v]=cur;\n\t\tfor(int i=0;i<adjlist[c][v].size();++i)\n\t\t\tdfs(adjlist[c][v].get(i),c);\n\t}\n\t  static  class InputReader {     \n    \tprivate InputStream stream;\n    \tprivate byte[] buf = new byte[1024];\n    \tprivate int curChar;\n    \tprivate int numChars;\n    \tprivate SpaceCharFilter filter;\n     \n    \tpublic InputReader(InputStream stream) {\n    \t\tthis.stream = stream;\n    \t\t}     \n    \tpublic int read() {\n    \t\tif (numChars == -1)\n    \t\t    throw new InputMismatchException();\n    \t\tif (curChar >= numChars) {\n    \t\t\tcurChar = 0;\n    \t\ttry {\n    \t\t\t\tnumChars = stream.read(buf);\n    \t\t\t} catch (IOException e) {\n    \t\t\t\tthrow new InputMismatchException();\n    \t\t\t}\n    \t\tif (numChars <= 0)\n    \t\t\treturn -1;\n    \t\t\t}\n    \t\t\treturn buf[curChar++];\n    \t\t}     \n    \tpublic int readInt() {\n    \t    int c = read();\n    \t\twhile (isSpaceChar(c))\n    \t\t\t\tc = read();\n    \t\tint sgn = 1;\n    \t\tif (c == '-') {\n    \t\t\tsgn = -1;\n    \t\t\tc = read();\n    \t}\n    \t\t\tint res = 0;\n    \t\t\tdo {\n    \t\t\t\tif (c < '0' || c > '9')\n    \t\t\t\t\tthrow new InputMismatchException();\n    \t\t\t\tres *= 10;\n    \t\t\t\tres += c - '0';\n    \t\t\t\tc = read();\n    \t\t\t} while (!isSpaceChar(c));\n    \t\t\treturn res * sgn;\n    \t\t}     \n    \t\tpublic String readString() {\n    \t\t\tint c = read();\n    \t\t\twhile (isSpaceChar(c))\n    \t\t\t\tc = read();\n    \t\t\tStringBuilder res = new StringBuilder();\n    \t\t\tdo {\n    \t\t\t\tres.appendCodePoint(c);\n    \t\t\t\tc = read();\n    \t\t\t} while (!isSpaceChar(c));\n    \t\t\treturn res.toString();\n    \t\t}     \n    \t\tpublic boolean isSpaceChar(int c) {\n    \t\t\tif (filter != null)\n    \t\t\t\treturn filter.isSpaceChar(c);\n    \t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    \t\t}     \n    \t\tpublic String next() {\n    \t\t\treturn readString();\n    \t\t}     \n    \t\tpublic interface SpaceCharFilter {\n    \t\t\tpublic boolean isSpaceChar(int ch);\n    \t\t}\n    \t}     \n   static class OutputWriter {\n    \t\tprivate final PrintWriter writer;     \n    \t\tpublic OutputWriter(OutputStream outputStream) {\n    \t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    \t\t}    \n    \t\tpublic OutputWriter(Writer writer) {\n    \t\t\tthis.writer = new PrintWriter(writer);\n    \t\t}     \n    \t\tpublic void print(Object...objects) {\n    \t\t\tfor (int i = 0; i < objects.length; i++) {\n    \t\t\t\tif (i != 0)\n    \t\t\t\t\twriter.print(' ');\n    \t\t\t\twriter.print(objects[i]);\n    \t\t\t}\n    \t\t}     \n    \t\tpublic void printLine(Object...objects) {\n    \t\t\tprint(objects);\n    \t\t\twriter.println();\n    \t\t}     \n    \t\tpublic void close() {\n    \t\t\twriter.close();\n    \t\t}     \n    \t\tpublic void flush() {\n    \t\t\twriter.flush();\n    \t\t}\n        }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nbool c[101][101][101];\nbool bfs(int u, int v, int p) {\n  queue<int> q;\n  bool visit[101] = {false};\n  q.push(u);\n  visit[u] = true;\n  while (!q.empty()) {\n    int cur = q.front();\n    q.pop();\n    for (int i = 1; i <= n; i++)\n      if (c[p][cur][i]) {\n        if (!visit[i]) {\n          visit[i] = true;\n          q.push(i);\n        }\n      }\n  }\n  return visit[v];\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    int a, b, t;\n    scanf(\"%d %d %d\", &a, &b, &t);\n    c[t][a][b] = c[t][b][a] = true;\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int s, e;\n    int cnt = 0;\n    scanf(\"%d %d\", &s, &e);\n    for (int i = 1; i <= m; i++) {\n      if (bfs(s, e, i)) cnt++;\n    }\n    printf(\"%d\\n\", cnt);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by ankeet on 12/31/16.\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class B505 {\n\n    static FastReader in = null;\n    static PrintWriter out = null;\n\n    public static int find(int[] P, int x){\n\n        return P[x]==x?x:(P[x] = find(P, P[x]));\n    }\n\n    public static void union(int[] P, int p, int q) {\n        P[find(P, p)] = find(P, q);\n    }\n\n    public static void solve()\n    {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        HashMap<Integer, int[]> hm = new HashMap<>();\n        for(int i=0; i<m; i++){\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int c = in.nextInt();\n            if(!hm.containsKey(c)){\n                int[] set = new int[n+1];\n                for(int j=0; j<=n; j++) set[j] = j;\n                union(set, a, b);\n                hm.put(c, set);\n            }\n            else{\n                union(hm.get(c), a, b);\n            }\n        }\n\n        int q = in.nextInt();\n        while(q-->0){\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int ct = 0;\n            for(int c: hm.keySet()){\n                if(find(hm.get(c), u) == find(hm.get(c), v)){\n                    ct++;\n                }\n            }\n            out.println(ct);\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        in = new FastReader(System.in);\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n        out.close();\n\n    }\n\n    static class FastReader {\n\n        BufferedReader read;\n        StringTokenizer tokenizer;\n\n        public FastReader(InputStream in)\n        {\n            read = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String next()\n        {\n            while(tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try{\n                    tokenizer = new StringTokenizer(read.readLine());\n                }catch(Exception e){\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public String nextLine(){\n\n            try\n            {\n                return read.readLine();\n            }\n            catch(Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArr(int n)\n        {\n            int[] a = new int[n];\n            for(int i=0; i<n; ++i)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] nextLongArr(int n)\n        {\n            long[] a = new long[n];\n            for(int i=0; i<n; ++i)\n            {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000;\nvector<pair<int, int> > vec[maxn];\nvector<int> v;\nbool check[maxn];\nbool ans = 0;\nvoid dfs(int s, int e, int c) {\n  check[s] = 1;\n  if (ans == 1) return;\n  if (s == e) {\n    ans = 1;\n    return;\n  }\n  for (int i = 0; i < vec[s].size(); i++) {\n    if (vec[s][i].second == c && !check[vec[s][i].first]) {\n      dfs(vec[s][i].first, e, c);\n    }\n  }\n  return;\n}\nint main() {\n  int n, m, d, f, g, maxe_c = 0;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> f >> g >> d;\n    vec[f].push_back(make_pair(g, d));\n    vec[g].push_back(make_pair(f, d));\n    maxe_c = max(maxe_c, d);\n  }\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> f >> g;\n    int col = 0;\n    for (int j = 0; j <= maxe_c; j++) {\n      ans = false;\n      for (int s = 1; s <= n; s++) check[s] = 0;\n      dfs(f, g, j);\n      if (ans) col++;\n    }\n    v.push_back(col);\n  }\n  for (int i = 0; i < v.size(); i++) cout << v[i] << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys, os.path\nfrom collections import*\nfrom copy import*\nimport math\nmod=10**9+7\nif(os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")   \n\ndef dfs(x,y,z):\n    vis[x]=1\n    if(x==y):\n        return\n    for v in adj[x]:\n        if(vis[v[0]]):\n            continue\n        if(v[1]==z):\n            dfs(v[0],y,z)\n\nadj=defaultdict(list)\nn,m=map(int,input().split())\ns=set()\nfor i in range(m):\n    a,b,c=map(int,input().split())\n    adj[a].append((b,c))\n    adj[b].append((a,c))\n    s.add(c)\n\nq=int(input())\nfor i in range(q):\n    x,y=map(int,input().split())\n    count=0\n    for j in s:\n        vis=[0 for i in range(n+1)]\n        dfs(x,y,j)\n        if(vis[y]):\n            count+=1\n    print(count)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.text.*;\nimport java.awt.Point;\n\nimport static java.util.Arrays.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Double.*;\nimport static java.lang.Long.*;\nimport static java.lang.Short.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.util.Collections.*;\n\npublic class B {\n\n\tprivate Scanner in;\n\tprivate StringTokenizer st;\n\tprivate PrintWriter out;\n\n\tprivate DecimalFormat fmt = new DecimalFormat(\"0.0000000000\");\n\n\tprivate List<Edge>[] g;\n\tprivate HashSet<Integer> vis;\n\tpublic void solve() throws Exception {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tg = new List[n + 1];\n\n\t\tfor (int i=1; i<=n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tint c = in.nextInt();\n\n\t\t\tg[u].add(new Edge(v, c));\n\t\t\tg[v].add(new Edge(u, c));\n\t\t}\n\n\t\tint q = in.nextInt();\n\t\tvis = new HashSet<Integer>();\n\n\t\twhile (q --> 0) {\n\t\t\tvis.clear();\n\t\t\tint counter = 0;\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tvis.add(u);\n\n\t\t\tfor (int i = 1; i<= m; i++) {\n\t\t\t\tif (dfs(i, u, v)) {\n\t\t\t\t\tcounter ++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(counter);\n\t\t}\n\t}\n\n\tprivate boolean dfs(int color, int u, int dest) {\n\t\tif (u == dest) {\n\t\t\treturn true;\n\t\t}\n\n\t\tboolean ret = false;\n\t\tfor (Edge e : g[u]) {\n\n\t\t\tif (e.color == color && !vis.contains(e.node)) {\n\t\t\t\tvis.add(e.node);\n\t\t\t \tret |= dfs(color, e.node, dest);\n\t\t\t\tvis.remove(e.node);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate class Edge {\n\t\tint color;\n\t\tint node;\n\n\t\tpublic Edge(int node, int color) {\n\t\t\tthis.color = color;\n\t\t\tthis.node = node;\n\t\t}\n\t}\n\n\tpublic B() {\n\t\tthis.in = new Scanner(System.in);\n\t\tthis.out = new PrintWriter(System.out);\n\t}\n\n\tpublic void end() {\n\t\ttry {\n\t\t\tthis.out.flush();\n\t\t\tthis.out.close();\n\t\t\tthis.in.close();\n\t\t} catch (Exception e){\n\t\t\t//do nothing then :)\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tB solver = new B();\n\t\tsolver.solve();\n\t\tsolver.end();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<int, int>>> adjlist;\nint vertices, edges, ans;\nvector<int> visited;\nvector<int> colorchk;\nvector<vector<int>> storedans;\nvoid print() {\n  int count = 0;\n  for (auto &i : adjlist) {\n    cout << \"For vertex \" << count << endl;\n    count++;\n    for (auto &j : i) {\n      cout << j.first << \" \" << j.second << endl;\n    }\n    cout << endl;\n  }\n}\nvoid dfs(int current, int destination, int color) {\n  if (colorchk[color]) return;\n  if (current == destination) {\n    ans++;\n    colorchk[color] = 1;\n    return;\n  }\n  visited[current] = 1;\n  for (auto &i : adjlist[current]) {\n    if (i.second == color && !visited[i.first]) {\n      dfs(i.first, destination, color);\n    }\n  }\n}\nint main() {\n  int vtx1, vtx2, color;\n  cin >> vertices >> edges;\n  adjlist.assign(vertices + 1, vector<pair<int, int>>());\n  for (int i = 0; i < edges; i++) {\n    cin >> vtx1 >> vtx2 >> color;\n    adjlist[vtx1].push_back({vtx2, color});\n    adjlist[vtx2].push_back({vtx1, color});\n  }\n  storedans.assign(vertices + 1, vector<int>());\n  for (auto &i : storedans) {\n    i.assign(vertices + 1, -1);\n  }\n  int query;\n  cin >> query;\n  while (query--) {\n    cin >> vtx1 >> vtx2;\n    if (storedans[vtx1][vtx2] != -1) {\n      cout << storedans[vtx1][vtx2] << endl;\n    } else {\n      ans = 0;\n      colorchk.assign(edges + 1, 0);\n      for (auto &i : adjlist[vtx1]) {\n        if (!colorchk[i.second]) {\n          visited.assign(vertices + 1, 0);\n          dfs(vtx1, vtx2, i.second);\n        }\n      }\n      storedans[vtx1][vtx2] = ans;\n      storedans[vtx2][vtx1] = ans;\n      cout << storedans[vtx1][vtx2] << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nmx = [[0x00] * n for i in range(n)]\nused = None\n\ndef dfs(cur, trg, color):\n    if cur == trg:\n        return True\n    if not used[cur]:\n        used[cur] = True\n        for i in range(n):\n            if mx[cur][i] & color:\n                if dfs(i, trg, color):\n                    return True\n    return False\n\nfor i in range(m):\n    a, b, c = map(lambda s: int(s) - 1, input().split())\n    mx[a][b] |= 1 << c\n    mx[b][a] |= 1 << c\n\nq = int(input())\nfor i in range(q):\n    u, v = map(lambda s: int(s) - 1, input().split())\n    result = 0\n    for j in range(m):\n        used = [False] * n\n        if dfs(u, v, 1 << j):\n            result += 1\n    print(result)\n"
        },
        {
            "language": 3,
            "solution": "n,m=map(int,input().split())\ng=[[] for _ in range(n)]\nfor _ in range(m):\n    a,b,c=map(int,input().split())\n    g[a-1].append((b-1,c-1))\n    g[b-1].append((a-1,c-1))\ndef dfs(x,c,t):\n    if x==t:return True\n    v[x]=1\n    for j in g[x]:\n        if j[1]==c and v[j[0]]==0:\n            if dfs(j[0],c,t):return True\n    return False\nq=int(input())\no=[0]*q\nv=[]\nfor i in range(q):\n    f,y=map(int,input().split())\n    for c in range(100):\n        v=[0]*n\n        if dfs(f-1,c,y-1):o[i]+=1\nprint('\\n'.join(list(map(str,o))))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[110][110];\nint root(int k, int i) {\n  return (c[k][i] < 0 ? i : c[k][i] = root(k, c[k][i]));\n}\nvoid un(int k, int i, int j) {\n  i = root(k, i);\n  j = root(k, j);\n  if (i == j) return;\n  if (c[k][i] > c[k][j]) swap(i, j);\n  c[k][i] += c[k][j];\n  c[k][j] = i;\n}\nint same(int k, int i, int j) {\n  if (root(k, i) == root(k, j)) return 1;\n  return 0;\n}\nint main() {\n  memset(c, -1, sizeof(c));\n  int n, m;\n  cin >> n >> m;\n  int i, j, a, b;\n  while (m--) {\n    cin >> i >> j >> a;\n    un(a, i, j);\n  }\n  cin >> m;\n  while (m--) {\n    cin >> i >> j;\n    int t = 0;\n    for (int k = 1; k < 101; ++k) {\n      if (same(k, i, j)) ++t;\n    }\n    cout << t << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nconst int inf = 2000000000;\nconst long long infLL = 9000000000000000000;\ninline bool checkBit(long long n, int i) { return n & (1LL << i); }\ninline long long setBit(long long n, int i) {\n  return n | (1LL << i);\n  ;\n}\ninline long long resetBit(long long n, int i) { return n & (~(1LL << i)); }\nint dx[] = {0, 0, +1, -1};\nint dy[] = {+1, -1, 0, 0};\ninline bool EQ(double a, double b) { return fabs(a - b) < 1e-9; }\ninline bool isLeapYear(long long year) {\n  return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);\n}\ninline void normal(long long &a) {\n  a %= 1000000007;\n  (a < 0) && (a += 1000000007);\n}\ninline long long modMul(long long a, long long b) {\n  a %= 1000000007, b %= 1000000007;\n  normal(a), normal(b);\n  return (a * b) % 1000000007;\n}\ninline long long modAdd(long long a, long long b) {\n  a %= 1000000007, b %= 1000000007;\n  normal(a), normal(b);\n  return (a + b) % 1000000007;\n}\ninline long long modSub(long long a, long long b) {\n  a %= 1000000007, b %= 1000000007;\n  normal(a), normal(b);\n  a -= b;\n  normal(a);\n  return a;\n}\ninline long long modPow(long long b, long long p) {\n  long long r = 1;\n  while (p) {\n    if (p & 1) r = modMul(r, b);\n    b = modMul(b, b);\n    p >>= 1;\n  }\n  return r;\n}\ninline long long modInverse(long long a) { return modPow(a, 1000000007 - 2); }\ninline long long modDiv(long long a, long long b) {\n  return modMul(a, modInverse(b));\n}\nvector<pair<int, int> > adjlist[110];\nbool vis[110];\nint c;\nint t;\nint yes = 0;\nvoid dfs(int u) {\n  vis[u] = 1;\n  if (u == t) {\n    yes = 1;\n    return;\n  }\n  int l = adjlist[u].size();\n  for (int j = 0; j < l; ++j) {\n    pair<int, int> v = adjlist[u][j];\n    if (yes == 1) return;\n    if (!vis[v.first] && v.second == c) dfs(v.first);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0, x, y, z; i < m; ++i) {\n    cin >> x >> y >> z;\n    adjlist[x].emplace_back(make_pair(y, z));\n    adjlist[y].emplace_back(make_pair(x, z));\n  }\n  int q;\n  cin >> q;\n  for (int i = 0, x, y; i < q; ++i) {\n    int ans = 0;\n    memset(vis, 0, sizeof(vis));\n    cin >> x >> y;\n    for (int j = 1; j <= 100; ++j) {\n      c = j;\n      t = y;\n      memset(vis, 0, sizeof(vis));\n      dfs(x);\n      ans += yes;\n      yes = 0;\n    }\n    cout << ans << '\\n';\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "def judge(c,u,v):\n    connect = set(G[c][u])\n    visited = set([])\n    while 1:\n        for i in connect-visited:\n            connect |= set(G[c][i])\n            visited.add(i)\n        if connect == visited: break\n    return True if u in connect and v in connect else False\n\nn,m = map(int,raw_input().split())\nG = [[[] for _ in range(n)] for __ in range(m)]\nfor loop in range(m):\n    a,b,c = map(int,raw_input().split())\n    a -= 1; b -= 1; c -= 1\n    G[c][b].append(a)\n    G[c][a].append(b)\nq = int(raw_input())\nfor loop in range(q):\n    u,v = map(int,raw_input().split())\n    u -= 1; v -= 1\n    ans = 0\n    for i in range(m):\n        if judge(i,u,v):\n            ans += 1\n    print ans"
        },
        {
            "language": 4,
            "solution": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Set;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.LinkedList;\nimport java.util.HashSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    private boolean marked[];\n    private Edge edgeTo[];\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int N = in.nextInt();\n        int M = in.nextInt();\n\n        Graph G = new Graph(N);\n\n        for (int i = 0; i < M; i++) {\n            G.addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());\n        }\n\n        int Q = in.nextInt();\n        for (int i = 0; i < Q; i++) {\n            int s = in.nextInt() - 1;\n            int d = in.nextInt() - 1;\n            int cnt = 0;\n            for (Integer col : colors(G.adj[s])) {\n                marked = new boolean[N];\n                edgeTo = new Edge[N];\n                dfs(G, s, d, col);\n                if (edgeTo[d] != null) {\n                    cnt++;\n                }\n            }\n\n            out.println(cnt);\n        }\n    }\n\n    private Set<Integer> colors(List<Edge> edges) {\n        HashSet<Integer> ans = new HashSet<Integer>();\n        for (Edge e : edges) {\n            ans.add(e.color);\n        }\n        return ans;\n    }\n\n    private void dfs(Graph G, int v, int d, int color) {\n        marked[v] = true;\n        for (Edge e : G.adj[v]) {\n            if (e.color != color) continue;\n            int w = e.other(v);\n            if (marked[w]) continue;\n            edgeTo[w] = e;\n            dfs(G, w, d, color);\n        }\n    }\n\n\n    private class Graph {\n        private final int V;\n        private List<Edge> adj[];\n\n        public Graph(int V) {\n            this.V = V;\n            adj = (List<Edge>[]) new LinkedList[V];\n            for (int v = 0; v < V; v++) {\n                adj[v] = new LinkedList<Edge>();\n            }\n        }\n\n        public void addEdge(int v, int w, int color) {\n            Edge e = new Edge(v, w, color);\n            adj[v].add(e);\n            adj[w].add(e);\n        }\n    }\n\n    private class Edge {\n        private int v;\n        private int w;\n        private int color;\n\n\n        public Edge(int v, int w, int color) {\n            this.v = v;\n            this.w = w;\n            this.color = color;\n        }\n\n        public int other(int x) {\n            return x == v ? w : v;\n        }\n    }\n\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n//\tpublic static final double EPS = 1e-9;\n//\tpublic static final int MOD = 1000000009;\n//\tpublic static final double PI = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679;\n//\tpublic static final int DX[] = {1, -1, 0, 0};\n//\tpublic static final int DY[] = {0, 0, 1, -1};\n//\tpublic static final int sievesize = (int) (1e6);\n//\tpublic static boolean[] prime;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\t\n\t\tArrayList<LinkedList<Pair<Integer, Integer>>> g;\n\t\tboolean[] vis;\n\t\t\n\t\tpublic boolean dfs(int u, int v, int c) {\n\t\t\tvis[u] = true;\n\t\t\tif (u == v) return true;\n\t\t\tfor (Pair<Integer, Integer> p : g.get(u)) {\n\t\t\t\tif (!vis[p.first] && p.second == c)\n\t\t\t\t\tif (dfs(p.first, v, c)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void solve(int testNumber, InputReader in, OutputWriter out) throws IOException {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tg = new ArrayList<>();\n\t\t\tfor (int i = 0; i <= n; i++) g.add(new LinkedList<>());\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint a = in.nextInt(), b = in.nextInt(), c = in.nextInt();\n\t\t\t\tLinkedList<Pair<Integer, Integer>> l = g.get(a);\n\t\t\t\tl.add(new Pair<Integer, Integer>(b, c));\n\t\t\t\tl = g.get(b);\n\t\t\t\tl.add(new Pair<Integer, Integer>(a, c));\n\t\t\t}\n\t\t\tint q = in.nextInt();\n\t\t\twhile (q-- > 0) {\n\t\t\t\tint res = 0;\n\t\t\t\tint u = in.nextInt(), v = in.nextInt();\n\t\t\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\t\t\tvis = new boolean[n + 1];\n\t\t\t\t\tif (dfs(u, v, i)) res++;\n\t\t\t\t}\n\t\t\t\tout.println(res, \"\\n\");\n\t\t\t}\n\t\t}\n\n//\t\tstatic class Node {\n//\t\t\tString name;\n//\t\t\tLinkedList<Node> list;\n//\t\t\t\n//\t\t\tpublic Node(String name) {\n//\t\t\t\tthis.name = name;\n//\t\t\t\tlist = new LinkedList<>();\n//\t\t\t}\n//\t\t}\n        \n\t\tstatic class Pair<T1, T2> {   \t\n\t      \tT1 first;\n\t      \tT2 second;\n\t\t        \t\n\t\t    public Pair(T1 first, T2 second) {\n\t    \t\tthis.first = first;\n\t\t\t\tthis.second = second;\n\t\t\t}\n\t    }\n\t\t\n//\t\tpublic void sieve() {\n//\t\t\tprime = new boolean[sievesize + 1];\n//\t\t\tArrays.fill(prime, true);\n//\t\t    for(int x = 2; x * x < sievesize; x++) { \n//\t\t    \tif(prime[x])\n//\t\t    \t\tfor(int y = x * 2; y < sievesize; y += x) \n//\t\t    \t\t\tprime[y] = false; \n//\t\t    }\n//\t\t} \n\n//\t\tpublic int[] shuffle(int arr[], Random gen) {\n//\t\t\tfor (int i = arr.length - 1; i > 0; i--) {\n//\t            int index = gen.nextInt(i + 1);\n//\t            int temp = arr[index];\n//\t            arr[index] = arr[i];\n//\t            arr[i] = temp;\n//\t\t\t}\n//\t\t\treturn arr;\n//\t\t}\n\t\n//\t\tpublic boolean triangle(long a, long b, long c) {\n//\t\t    return ((a+b) > c && (b+c) >a && (a+c) > b);\n//\t\t}\n\t\n//\t\tpublic boolean isPerfectSquare(long n) {\n//\t\t\tif (n < 0) return false;\n//\t\t    long test = (long) (Math.sqrt(n) + 0.5);\n//\t\t    return test*test == n;\n//\t\t}\n\t\n//\t\tpublic int isnum(char s) {\n//\t\t\tif(s=='1' || s=='2' || s=='3' || s=='4' || s=='5' || s=='6' || s=='7' || s=='8' || s=='9' || s=='0')  return 1; \n//\t\t\treturn 0;\n//\t\t}\n\t\n//\t\tpublic long nextPowerOf2(long n) {\n//\t\t    n--;\n//\t\t    n |= n >> 1;\n//\t\t    n |= n >> 2;\n//\t\t    n |= n >> 4;\n//\t\t    n |= n >> 8;\n//\t\t    n |= n >> 16;\n//\t\t    n++;\n//\t\t    return n;\n//\t\t}\n\t\n//\t\tpublic int gcd(int a, int b) {\n//\t\t    int t; \n//\t\t    while (b > 0){ \n//\t\t    \ta = a % b; \n//\t\t    \tt = a; \n//\t\t    \ta = b; \n//\t\t    \tb = t; \n//\t\t    }\n//\t\t    return a;\n//\t\t}\n\t\t\n//\t\tpublic int lcm(int x, int y) {\n//\t\t\tint a = Math.max(x, y);\n//\t\t\twhile (true) {\n//\t\t\t\tif (a % x == 0 && a % y == 0) return a;\n//\t\t\t\ta++;\n//\t\t\t}\n//\t\t}\n\t\n//\t\tpublic static int findGcdArray(int[] arr) {\n//\t\t\tint min = Integer.MAX_VALUE;\n//\t\t\tfor (int i = 0; i < arr.length; i++)\n//\t\t\t\tmin = Math.min(min, arr[i]);\n//\t\t\twhile (min > 1) {\n//\t\t\t\tint i = 0, s = 0;\n//\t\t\t\twhile (i < arr.length) {\n//\t\t\t\t\ts += arr[i] % min;\n//\t\t\t\t\ti++;\n//\t\t\t\t}\n//\t\t\t\tif (s == 0) return min;\n//\t\t\t\tmin--;\n//\t\t\t}\n//\t\t\treturn 1;\n//\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tprivate void tokenize() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\ttokenize();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic char nextChar() {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t\t\n\t\tpublic float nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int size) {\n\t\t\ttokenize();\n\t\t\tint[] arr=new int[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Integer.parseInt(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int size) {\n\t\t\ttokenize();\n\t\t\tlong[] arr=new long[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Long.parseLong(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic float[] nextFloatArray(int size) {\n\t\t\ttokenize();\n\t\t\tfloat[] arr=new float[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Float.parseFloat(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int size) {\n\t\t\ttokenize();\n\t\t\tdouble[] arr=new double[size];\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\ttokenize();\n\t\t\t\tarr[i] = Double.parseDouble(tokenizer.nextToken());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic String[] nextStringArray(int size) throws IOException {\n\t\t\tString[] arr=new String[size];\n\t\t\tfor(int i = 0; i < size; i++) \n\t\t\t\tarr[i] = reader.readLine();\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic char[] nextCharArray(int size) throws IOException {\n\t\t\treturn reader.readLine().toCharArray();\n\t\t}\n\t}\n\n\tstatic class OutputWriter {\n\t\tpublic PrintWriter pw;\n\n\t\tpublic OutputWriter(OutputStream stream) {\n\t\t\tpw = new PrintWriter(stream);\n\t\t}\n\t\t\n\t\tpublic void println(Object... obj) {\n\t\t\tif (obj.length == 0) pw.println();\n\t\t\telse {\n\t\t\t\tString delimiter = (String) obj[obj.length - 1];\n\t\t\t\tfor (int i = 0 ; i < obj.length - 2; i++) {\n\t\t\t\t\tpw.print(obj[i]);\n\t\t\t\t\tpw.print(delimiter);\n\t\t\t\t}\n\t\t\t\tpw.println(obj[obj.length - 2]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tpw.close();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tpw.flush();\n\t\t}\n\n\t\tpublic void printStringArray(String[] arr) {\n\t\t\tfor(int i = 0; i < arr.length; i++)\n\t\t\t\tpw.println(arr[i]);\n\t\t}\n\t\t\n\t\tpublic void printBooleanArray(boolean[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printIntArray(int[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printLongArray(long[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printCharArray(char[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printFloatArray(float[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\n\t\tpublic void printDoubleArray(double[] arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr[i] + \" \");\n\t\t}\n\t\t\n\t\tpublic void printIntArrayList(ArrayList<Integer> arr, int a , int b) {\n\t\t\tfor(int i = a; i < b; i++)\n\t\t\t\tpw.print(arr.get(i) + \" \");\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.DecimalFormat;\n\npublic class Tree {\n   \n    static class InputReader {\n \n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n \n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n \n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t \t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n \n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n \n\t\tpublic int[] nia(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = ni();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic String rs() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n \n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n \n\t}\n    static PrintWriter w = new PrintWriter(System.out);\n   \n    static ArrayList<Integer> edge[];\n    static ArrayList<Integer> color[][];\n    static PriorityQueue<Integer> pq[];\n    static long mod=1000000007;\n    static double num=0;\n    public static void bfs(ArrayList<Integer> arr[],boolean visited[],int root){\n         \n      \n    } \n    \n    static int min=Integer.MAX_VALUE;\n    public static boolean dfs(int i,int v,int col,boolean visited[],int parent,boolean count){\n      visited[i]=true;\n        if(i==v)\n          count= true;\n      else{\n          \n          Iterator itr=edge[i].iterator();\n          while(itr.hasNext()){\n              int a=(int)itr.next();\n              if(color[i][a].contains(col)&&!visited[a]&&a!=parent){\n                  \n                  count=dfs(a,v,col,visited,i,count);\n                  if(count)\n                      return count;\n              }\n          }\n            \n      }\n        return count;    \n    \n    } \n    \n    public static void main(String[] args) {\n         InputReader sc=new InputReader(System.in);\n     DecimalFormat df=new DecimalFormat(\"0.000000000000000\");\n  \n        int n=sc.ni();\n        int m=sc.ni();\n      edge=new ArrayList[n+1];\n      color=new ArrayList[n+1][n+1];\n      for(int i=1;i<=n;i++){\n          for(int j=1;j<=n;j++){\n              color[i][j]=new ArrayList<Integer>();\n          }\n      }\n      for(int i=1;i<=n;i++)\n          edge[i]=new ArrayList<Integer>();\n      for(int i=0;i<m;i++){\n          int a=sc.ni();\n          int  b=sc.ni();\n          int c=sc.ni();\n          color[a][b].add(c);\n          color[b][a].add(c);\n          if(!edge[a].contains(b))\n             edge[a].add(b);\n         if(!edge[b].contains(a))\n             edge[b].add(a);\n      }\n      \n    int q=sc.ni();\n    while(q-->0){\n         \n        int ans=0;\n        int u=sc.ni();\n        int v=sc.ni();\n         \n        for(int i=1;i<=m;i++){\n            boolean count=false;\n            boolean visited[]=new boolean[n+1];\n            if(dfs(u,v,i,visited,u,count))\n                      ans++;\n        }\n        System.out.println(ans);\n     }    \n        w.close();\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n\ndef make(n):\n  m = {}\n  for i in range(n):\n    m[i] = i\n  return m\n\ndef union(m, a, b):\n  pa = find(m, a)\n  pb = find(m, b)\n  m[pa] = pb\n\ndef find(m, a):\n  if m[a] == a:\n    return a\n  else:\n    ans = find(m, m[a])\n    m[a] = ans\n    return ans\n\nN, M = map(int, sys.stdin.readline().split())\nms = []\nfor _ in range(M):\n  m = make(N)\n  ms.append(m)\n\nfor _ in range(M):\n  sys.stdin.readline\n  a, b, c = map(lambda f: int(f)-1, sys.stdin.readline().split())\n  union(ms[c], a, b)\n\nQ = int(sys.stdin.readline())\nfor _ in range(Q):\n  u, v = map(lambda f: int(f)-1, sys.stdin.readline().split())\n  ans = 0\n  for m in ms:\n    if find(m, u) == find(m, v):\n      ans += 1\n  print ans\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing pr = pair<int, int>;\nusing vp = vector<pr>;\nusing vvp = vector<vp>;\nusing vi = vector<int>;\nint N;\nvoid dfs(vvp& g, vi& vis, int& fl, int fin, int col, int nd) {\n  if (nd == fin) {\n    fl = 1;\n    return;\n  }\n  if (fl) return;\n  vis[nd] = 1;\n  for (auto& pr : g[nd]) {\n    if (pr.second == col)\n      if (!vis[pr.first]) dfs(g, vis, fl, fin, col, pr.first);\n  }\n}\nint get_num_colors(vvp& g, int u, int v) {\n  int ans = 0;\n  set<int> c;\n  for (auto& pr : g[u]) c.insert(pr.second);\n  for (auto x : c) {\n    vi vis(N + 1);\n    int fl = 0;\n    dfs(g, vis, fl, v, x, u);\n    ans += fl;\n  }\n  return ans;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  N = n;\n  vvp g(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[a].push_back({b, c});\n    g[b].push_back({a, c});\n  }\n  int q;\n  cin >> q;\n  map<pr, int> mp;\n  for (int i = 0; i < q; i++) {\n    int u, v;\n    cin >> u >> v;\n    if (mp.count({u, v})) {\n      int ans = mp[{u, v}];\n      cout << ans << endl;\n    } else {\n      int ans = get_num_colors(g, u, v);\n      mp[{u, v}] = ans;\n      mp[{v, u}] = ans;\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class recc505b_2 {\n    static BufferedReader __in;\n    static PrintWriter __out;\n    static StringTokenizer input;\n\n    static List<List<P>> g = new ArrayList<>();\n    static boolean[] vis;\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new InputStreamReader(System.in));\n        __out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        r();\n        int n = ni(), m = ni();\n        vis = new boolean[n];\n        for(int i = 0; i < n; ++i) {\n            g.add(new ArrayList<>());\n        }\n        for(int i = 0; i < m; ++i) {\n            r();\n            int a = ni() - 1, b = ni() - 1, c = ni() - 1;\n            g.get(a).add(new P(b, c));\n            g.get(b).add(new P(a, c));\n        }\n        int q = ri();\n        for(int i = 0; i < q; ++i) {\n            r();\n            int u = ni() - 1, v = ni() - 1;\n            int ans = 0;\n            for(int j = 0; j < m; ++j) {\n                fill(vis, false);\n                if(dfs(u, v, j)) {\n                    ++ans;\n                }\n            }\n            prln(ans);\n        }\n\n        close();\n    }\n\n    static boolean dfs(int a, int b, int c) {\n        if(a == b) {\n            return true;\n        } else {\n            vis[a] = true;\n            for(P p : g.get(a)) {\n                if(!vis[p.a] && p.b == c) {\n                    if(dfs(p.a, b, c)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    static class P {\n        int a, b;\n\n        P(int a_, int b_) {\n            a = a_;\n            b = b_;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" + \"a = \" + a + \", b = \" + b + '}';\n        }\n\n        public boolean equalsSafe(Object o) {\n            if(this == o) return true;\n            if(o == null || getClass() != o.getClass()) return false;\n            P p = (P)o;\n            return a == p.a && b == p.b;\n        }\n\n        public boolean equalsUnchecked(Object o) {\n            P p = (P)o;\n            return a == p.a && b == p.b;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return equalsUnchecked(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(a, b);\n        }\n    }\n\n    // references\n    // IBIG = 1e9 + 7\n    // IRAND ~= 3e8\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IRAND = 327859546;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static int minstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}\n    static long minstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static int maxstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}\n    static long maxstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int floori(double d) {return (int)d;}\n    static int ceili(double d) {return (int)ceil(d);}\n    static long floorl(double d) {return (long)d;}\n    static long ceill(double d) {return (long)ceil(d);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); __out.println(iter.next());}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[109][109];\nvector<int> w;\nbool mark[1000];\nvoid dfs(int v, int c) {\n  mark[v] = true;\n  for (int i = 0; i < adj[c][v].size(); i++) {\n    int u = adj[c][v][i];\n    if (!mark[u]) dfs(u, c);\n  }\n}\nint main() {\n  int n, m;\n  int v, u, c;\n  int i, j;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    cin >> v >> u >> c;\n    v--, u--, c--;\n    if (!mark[c]) {\n      mark[c] = true;\n      w.push_back(c);\n    }\n    adj[c][v].push_back(u);\n    adj[c][u].push_back(v);\n  }\n  int t, q;\n  vector<int> tt;\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    t = 0;\n    cin >> v >> u;\n    v--, u--;\n    for (j = 0; j < w.size(); j++) {\n      fill(mark, mark + n, false);\n      dfs(v, w[j]);\n      if (mark[u]) t++;\n    }\n    tt.push_back(t);\n  }\n  for (int i = 0; i < q; i++) cout << tt[i] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tint n, m;\n\t\tBufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n\t\tStringTokenizer tok = new StringTokenizer (br.readLine ());\n\t\tn = Integer.parseInt (tok.nextToken ());\n\t\tm = Integer.parseInt (tok.nextToken ());\n\t\tboolean[][][] edge = new boolean[n + 1][n + 1][m + 1];\n\t\tArrayList<Set<Integer>>[] groups = new ArrayList[m + 1];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ttok = new StringTokenizer (br.readLine ());\n\t\t\tint a, b, c;\n\t\t\ta = Integer.parseInt (tok.nextToken ());\n\t\t\tb = Integer.parseInt (tok.nextToken ());\n\t\t\tc = Integer.parseInt (tok.nextToken ());\n\t\t\tif (groups[c] == null) groups[c] = new ArrayList<Set<Integer>> ();\n\t\t\tedge[a][b][c] = true;\n\t\t\tedge[b][a][c] = true;\n\t\t}\n\t\tfor (int c = 1; c <= m; c++) {\n\t\t\tif (groups[c] == null) continue;\n\t\t\tboolean[] used = new boolean[n + 1];\n\t\t\tfor (int a = 1; a <= n; a++) {\n\t\t\t\tif (!used[a]) {\n\t\t\t\t\tSet<Integer> s = new HashSet<Integer> ();\n\t\t\t\t\tLinkedList<Integer> q = new LinkedList<Integer> ();\n\t\t\t\t\tq.add (a);\n\t\t\t\t\twhile (!q.isEmpty ()) {\n\t\t\t\t\t\tint p = q.pop();\n\t\t\t\t\t\tused[p] = true;\n\t\t\t\t\t\ts.add (p);\n\t\t\t\t\t\tfor (int b = 1; b <= n; b++) {\n\t\t\t\t\t\t\tif (edge[p][b][c] && !used[b]) {\n\t\t\t\t\t\t\t\tq.add (b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgroups[c].add (s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint queries = Integer.parseInt (br.readLine());\n\t\tfor (int i = 0; i < queries; i++) {\n\t\t\tint count = 0;\n\t\t\ttok = new StringTokenizer (br.readLine());\n\t\t\tint a = Integer.parseInt (tok.nextToken ());\n\t\t\tint b = Integer.parseInt (tok.nextToken ());\n\t\t\tfor (int c = 1; c <= m; c++) {\n\t\t\t\tif (groups[c] == null) continue;\n\t\t\t\tfor (Set<Integer> s : groups[c]) {\n\t\t\t\t\tif (s.contains (a) && s.contains (b)) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println (count);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author pandusonu\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] edge = new int[m][3];\n            for (int i = 0; i < m; i++) {\n                edge[i] = in.readIntArray(3);\n            }\n            int q = in.readInt();\n            for (int i = 0; i < q; i++) {\n                int u = in.readInt();\n                int v = in.readInt();\n                int count = 0;\n                for (int j = 0; j <= m; j++) {\n                    if (dfs(u, v, j, edge)) {\n                        count++;\n                    }\n                }\n                out.println(count);\n            }\n        }\n\n        public boolean dfs(int curr, int v, int color, int[][] edge) {\n            if (curr == v)\n                return true;\n            boolean ret = false;\n            for (int i = 0; i < edge.length; i++) {\n                if (edge[i][2] == color) {\n                    int[] jmp = {edge[i][0], edge[i][1], edge[i][2]};\n                    if (edge[i][1] == curr) {\n                        edge[i][1] = edge[i][2] = -1;\n                        ret = ret || dfs(edge[i][0], v, color, edge);\n                    }\n                    if (edge[i][0] == curr) {\n                        edge[i][0] = edge[i][2] = -1;\n                        ret = ret || dfs(edge[i][1], v, color, edge);\n                    }\n                    edge[i][0] = jmp[0];\n                    edge[i][1] = jmp[1];\n                    edge[i][2] = jmp[2];\n                }\n            }\n            return ret;\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            try {\n                if (curChar >= numChars) {\n                    curChar = 0;\n                    numChars = stream.read(buf);\n                    if (numChars <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            return (int) readLong();\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1) throw new RuntimeException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += (c - '0');\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? (-res) : (res);\n        }\n\n        public int[] readIntArray(int size) {\n            int[] arr = new int[size];\n            for (int i = 0; i < size; i++) arr[i] = readInt();\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "def read_array(n):\n    return [map(int, raw_input().split()) for x in xrange(n)]\n\n\ndef search(v, end, edges, used):\n    if v in used:\n        return False\n    used[v] = True\n    filtered_edges = (x for x in edges if v in x[:2])\n    for e in filtered_edges:\n        if e[0] == end or e[1] == end:\n            return True\n        result = search(e[1], end, edges, used) or search(e[0], end, edges, used)\n        if result:\n            return result\n    return False\n\n\ndef main():\n    n, m = map(int, raw_input().split())\n    edge = read_array(m)\n    colors = dict()\n    for e in edge:\n        colors.setdefault(e[2], []).append(e)\n    q = input()\n    query = read_array(q)\n    for item in query:\n        result = sum(int(search(item[0], item[1], colors[c], {})) for c in colors.iterkeys())\n        print result\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 3,
            "solution": "n, m = list(map(int,input().split()))\np = [ [ i for i in range(n) ] for j in range(m)]\ndef f(ci,xi):\n  if xi==p[ci][xi]: return xi\n  p[ci][xi] = f(ci,p[ci][xi])\n  return p[ci][xi]\ndef uni(ci,xi,yi):\n  p[ci][f(ci,xi)]=f(ci,yi)\nfor i in range(m):\n  a, b, c = list(map(int,input().split()))\n  uni(c-1,a-1,b-1)\nfor i in range(int(input())):\n  a, b = list(map(int,input().split()))\n  print(sum(1 if f(i,a-1) == f(i,b-1) else 0 for i in range(m)))\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\n/**\n * @author madi.sagimbekov\n */\npublic class C505B {\n\n    private static BufferedReader in;\n    private static BufferedWriter out;\n\n    private static List<int[]>[] list;\n    private static int[] arr;\n    private static int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    private static boolean[] used;\n\n    private static int u = 0, v = 0, n = 0, m = 0;\n    private static Set<Integer> colors;\n\n    public static void main(String[] args) throws IOException {\n        open();\n\n        arr = readInts();\n        n = arr[0];\n        m = arr[1];\n\n        list = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            list[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < m; i++) {\n            arr = readInts();\n            list[arr[0]].add(new int[]{arr[1], arr[2]});\n            list[arr[1]].add(new int[]{arr[0], arr[2]});\n        }\n\n        int t = readInt();\n        while (t-- > 0) {\n            arr = readInts();\n            u = arr[0];\n            v = arr[1];\n            used = new boolean[n + 1];\n            colors = new HashSet<>();\n            dfs(u, v, -1);\n            out.write(colors.size() + \"\\n\");\n        }\n\n        close();\n    }\n\n    private static void dfs(int u, int v, int color) {\n        if (u == v) {\n            colors.add(color);\n            return;\n        }\n\n        used[u] = true;\n\n        for (int[] child : list[u]) {\n            if (!used[child[0]]) {\n                if (color == -1 || color == child[1]) {\n                    dfs(child[0], v, child[1]);\n                }\n            }\n        }\n\n        used[u] = false;\n    }\n\n    private static int[] readInts() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    private static int readInt() throws IOException {\n        return Integer.parseInt(in.readLine());\n    }\n\n    private static long[] readLongs() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n    }\n\n    private static long readLong() throws IOException {\n        return Long.parseLong(in.readLine());\n    }\n\n    private static double[] readDoubles() throws IOException {\n        return Stream.of(in.readLine().split(\" \")).mapToDouble(Double::parseDouble).toArray();\n    }\n\n    private static double readDouble() throws IOException {\n        return Double.parseDouble(in.readLine());\n    }\n\n    private static String readString() throws IOException {\n        return in.readLine();\n    }\n\n    private static List<Integer>[] buildAdjacencyList(int n, int m) throws IOException {\n        List<Integer>[] list = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            list[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < m; i++) {\n            int[] e = readInts();\n            list[e[0]].add(e[1]);\n            list[e[1]].add(e[0]);\n        }\n\n        return list;\n    }\n\n    private static void open() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new BufferedWriter(new OutputStreamWriter((System.out)));\n    }\n\n    private static void close() throws IOException {\n        out.flush();\n        out.close();\n        in.close();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2e9;\nconst long long LINF = 2e18;\nvoid inv(bool e);\nbool brute;\nint cnt_tests = 1;\nint n, m;\nconst int N = 200;\nvector<pair<int, int> > graph[N];\nvector<pair<int, int> > qs;\nvoid inp() {\n  cin >> n >> m;\n  int v, u, c;\n  for (int i = 0; i < m; i++) {\n    cin >> v >> u >> c;\n    graph[v].push_back({u, c});\n    graph[u].push_back({v, c});\n  }\n  int t;\n  cin >> t;\n  qs.resize(t);\n  for (int i = 0; i < t; i++) {\n    cin >> v >> u;\n    qs[i] = {v, u};\n  }\n}\nbool used[N];\nvoid dfs(int v, int c) {\n  used[v] = true;\n  for (auto e : graph[v]) {\n    if (!used[e.first] && e.second == c) dfs(e.first, c);\n  }\n}\ninline void clear_used() {\n  for (int i = 0; i < N; i++) used[i] = false;\n}\nint calc(int v, int u) {\n  int ans = 0;\n  for (int i = 1; i <= m; i++) {\n    clear_used();\n    dfs(v, i);\n    if (used[u]) ans++;\n  }\n  return ans;\n}\nvoid solve() {\n  for (auto x : qs) {\n    printf(\"%d\\n\", calc(x.first, x.second));\n  }\n}\nvoid stress() {}\nvoid run();\nint main() {\n  if (0) {\n    freopen(\"stack.in\", \"r\", stdin);\n    freopen(\"stack.out\", \"w\", stdout);\n  }\n  brute = false;\n  for (int i = 0; (i < cnt_tests); i++) {\n    run();\n  }\n  cerr << '\\n' << \"Time: \" << clock() / 1000.0 << \" ms\";\n  return 0;\n}\nvoid run() {\n  if (!brute) {\n    inp();\n  } else {\n    stress();\n  }\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long int>> v, v1;\nlong long int fsfs(long long int a, long long int c) {\n  if (v[c][a] == a) {\n    return a;\n  }\n  v[c][a] = fsfs(v[c][a], c);\n  return v[c][a];\n}\nvoid alwani(long long int a, long long int b, long long int c) {\n  long long int x = fsfs(a, c);\n  long long int y = fsfs(b, c);\n  if (x != y) {\n    if (v1[c][x] < v1[c][y]) {\n      swap(x, y);\n    } else {\n      v1[c][x]++;\n    }\n    v[c][y] = v[c][x];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, m, a, b, c;\n  cin >> n >> m;\n  v.resize(m + 1);\n  v1.resize(m + 1);\n  for (long long i = (1); i < (m + 1); i++) {\n    v[i].resize(n + 1);\n    v1[i].resize(n + 1, 1);\n    iota(v[i].begin(), v[i].end(), 0ll);\n  }\n  for (long long i = (0); i < (m); i++) {\n    cin >> a >> b >> c;\n    alwani(a, b, c);\n  }\n  long long int q;\n  cin >> q;\n  for (long long i = (0); i < (q); i++) {\n    cin >> a >> b;\n    long long int sum = 0;\n    for (long long j = (1); j < (m + 1); j++) {\n      if (fsfs(a, j) == fsfs(b, j)) {\n        sum++;\n      }\n    }\n    cout << sum << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass step {\n public:\n  int s;\n  int d;\n  int c;\n  bool isused;\n  bool consists(int a);\n  int getopposite(int a);\n  ~step() { isused = false; }\n};\nint step::getopposite(int a) { return (a == s) ? d : s; }\nbool step::consists(int a) {\n  if (isused) return false;\n  return ((a == s) || (a == d));\n}\nbool isthereway(int source, int dest, step* step_array, int array_size) {\n  for (int i = 0; i < array_size; i++) {\n    if (step_array[i].consists(source)) {\n      if (step_array[i].getopposite(source) == dest) return true;\n      step_array[i].isused = true;\n      if (isthereway(step_array[i].getopposite(source), dest, step_array,\n                     array_size))\n        return true;\n    }\n  }\n  return false;\n}\nint main() {\n  int n, m, res, reqs, s, d, c, color_num = 0;\n  cin >> n >> m;\n  step routes[m];\n  for (int i = 0; i < m; i++) {\n    cin >> s >> d >> c;\n    if (c > color_num) color_num = c;\n    routes[i].s = s;\n    routes[i].d = d;\n    routes[i].c = c;\n    routes[i].isused = false;\n  }\n  cin >> reqs;\n  step requests[reqs];\n  for (int i = 0; i < reqs; i++) {\n    cin >> s >> d;\n    requests[i].s = s;\n    requests[i].d = d;\n  }\n  int sizes[color_num];\n  step* arr;\n  for (int r = 0; r < reqs; r++) {\n    res = 0;\n    for (int i = 1; i <= color_num; i++) {\n      sizes[i] = 0;\n      int k = 0;\n      for (int j = 0; j < m; j++) {\n        if (routes[j].c == i) sizes[i]++;\n      }\n      arr = new step[sizes[i]];\n      for (int j = 0; j < m; j++) {\n        if (routes[j].c == i) arr[k++] = routes[j];\n      }\n      if (isthereway(requests[r].s, requests[r].d, arr, sizes[i])) res++;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint ans;\nusing namespace std;\nconst int maxn = 1e3;\nvector<int> v[maxn][maxn];\nvector<int> color[maxn];\nbool b[maxn], col[maxn];\nint n, m;\nvoid empt() {\n  for (int i = 1; i <= n; i++) b[i] = 0;\n}\nvoid empT() {\n  for (int i = 1; i <= n; i++) col[i] = 0;\n}\nvoid dfs(int c, int x) {\n  for (int i = 0; i < v[c][x].size(); i++) {\n    if (!b[v[c][x][i]]) {\n      b[v[c][x][i]] = 1;\n      dfs(c, v[c][x][i]);\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  int a, s, d;\n  for (int i = 1; i <= m; i++) {\n    cin >> a >> s >> d;\n    v[d][s].push_back(a);\n    v[d][a].push_back(s);\n    color[a].push_back(d);\n    color[s].push_back(d);\n  }\n  int q;\n  cin >> q;\n  for (int i = 1; i <= q; i++) {\n    ans = 0;\n    cin >> a >> s;\n    empT();\n    for (int j = 0; j < color[a].size(); j++) {\n      if (!col[color[a][j]]) {\n        empt();\n        b[a] = 1;\n        dfs(color[a][j], a);\n        if (b[s]) ans++;\n        col[color[a][j]] = 1;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def dfs(place,target):\n    vis[place]=True\n    if target==place:total[0]+=1;return()\n    anyAdj=0\n    for i in j[place]:\n        if not vis[i]:anyAdj=1;dfs(i,target)\n    if anyAdj==0:return()\n\nv,e=map(int,input().split())\nedges=[]\nfor i in range(e):edges.append(list(map(int,input().split())))\ncolors=[]\nfor i in edges:colors.append(i[2])\ncolors=list(set(colors))\ncolorAdjs=[]\nfor i in colors:\n    colorAdjs.append([[] for w in range(v)])\n    for j in edges:\n        if j[2]==i:\n            colorAdjs[-1][j[0]-1].append(j[1]-1)\n            colorAdjs[-1][j[1]-1].append(j[0]-1)\nq=int(input())\nfor i in range(q):\n    total=[0]\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    for j in colorAdjs:\n        vis=[False]*v\n        dfs(a,b)\n    print(total[0])\n"
        },
        {
            "language": 3,
            "solution": "class CodeforcesTask505BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n_m = []\n        self.edges = []\n        self.q = 0\n        self.queries = []\n\n    def read_input(self):\n        self.n_m = [int(x) for x in input().split(\" \")]\n        for x in range(self.n_m[1]):\n            self.edges.append([int(y) for y in input().split(\" \")])\n        self.q = int(input())\n        for x in range(self.q):\n            self.queries.append([int(y) for y in input().split(\" \")])\n\n    def process_task(self):\n        graphs = [[[] for x in range(self.n_m[0])] for c in range(self.n_m[1])]\n        for edge in self.edges:\n            graphs[edge[2] - 1][edge[0] - 1].append(edge[1])\n            graphs[edge[2] - 1][edge[1] - 1].append(edge[0])\n        results = []\n        for query in self.queries:\n            to_visit = [(query[0], c) for c in range(self.n_m[1])]\n            used = set()\n            visited = [[False] * self.n_m[0] for x in range(self.n_m[1])]\n            while to_visit:\n                visiting = to_visit.pop(-1)\n\n                if visiting[1] not in used and not visited[visiting[1]][visiting[0] - 1]:\n                    visited[visiting[1]][visiting[0] - 1] = True\n                    if visiting[0] == query[1]:\n                        used.add(visiting[1])\n                    else:\n                        to_visit.extend([(x, visiting[1]) for x in graphs[visiting[1]][visiting[0] - 1]])\n            colors = len(used)\n            results.append(colors)\n        self.result = \"\\n\".join([str(x) for x in results])\n\n    def get_result(self):\n        return self.result\n\n\nif __name__ == \"__main__\":\n    Solution = CodeforcesTask505BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tstatic BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic StringTokenizer datos = new StringTokenizer(\"\");\n\t\n\tpublic static String next() throws IOException {\n\t\twhile (!datos.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\tdatos = new StringTokenizer(s);\n\t\t}\n\t\treturn datos.nextToken();\n\t}\n\t\n\tpublic static Integer nextInt() throws IOException {\n\t\tString s = next();\n\t\treturn s == null ? null : Integer.parseInt(s);\n\t}\n\tpublic static Long nextLong() throws IOException {\n\t\tString s = next();\n\t\treturn s == null ? null : Long.parseLong(s);\n\t}\n\t\n\tstatic List<Node>[] graph;\n\tstatic boolean visitados[];\n\t\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tgraph = new List[n];\n\t\tfor(int i=0;i<n;i++) graph[i] = new ArrayList<Node>();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u = nextInt()-1;\n\t\t\tint v = nextInt()-1;\n\t\t\tint c = nextInt();\n\t\t\tgraph[u].add(new Node(v, c));\n\t\t\tgraph[v].add(new Node(u, c));\n\t\t}\n\t\tint q = nextInt();\n\t\twhile(q-->0){\n\t\t\tint u = nextInt()-1;\n\t\t\tint v = nextInt()-1;\n\t\t\tint res = 0;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tvisitados = new boolean[n];\n\t\t\t\tif(dfs(u, v, i)) res++;\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tpublic static boolean dfs(int node, int goal, int color)\n\t{\n\t\tif(node == goal) return true;\n\t\tvisitados[node] = true;\n\t\tList<Node> edges = graph[node];\n\t\tfor(Node n : edges){\n\t\t\tif(n.color == color && !visitados[n.id]){\n\t\t\t\tif(dfs(n.id, goal, color)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass Node\n{\n\tint id;\n\tint color;\n\t\n\tpublic Node(int i, int c)\n\t{\n\t\tid = i;\n\t\tcolor = c;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\ne, g = {}, {x: set() for x in range(1, n + 1)}\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    e[(a, b)] = e[(b, a)] = e.get((a, b), set()) | {c}\n    g[a].add(b)\n    g[b].add(a)\nfor _ in range(int(input())):\n    a, b = map(int, input().split())\n    ans = 0\n    for color in range(1, m + 1):\n        vis = [0] * (n + 1)\n        q = [a]\n        while q:\n            \n            v = q.pop()\n            if v == b:\n                \n                ans += 1\n                break\n            vis[v] = 1\n            for i in g[v]:\n                if not vis[i] and color in e[(v, i)]:\n                    q.append(i)\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Task {\n\t\n\tclass Pair {\n\t\tint from, to, color;\n\t}\n\t\n\tstatic final int MaxN = 110;\n\t\n\tPair[] edge = new Pair[2*MaxN];\n\tBoolean[] visited = new Boolean[MaxN];\n\tSet<Integer> s = new HashSet<Integer>();\n\tint n, m;\n\t\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tedge[i] = new Pair();\n\t\t\tedge[i].from = in.nextInt();\n\t\t\tedge[i].to = in.nextInt();\n\t\t\tedge[i].color = in.nextInt();\n\t\t\tedge[i+m] = new Pair();\n\t\t\tedge[i+m].from = edge[i].to;\n\t\t\tedge[i+m].to = edge[i].from;\n\t\t\tedge[i+m].color = edge[i].color;\n\t\t}\n\t\tint q = in.nextInt();\n\t\tfor(int i=0; i<q; ++i) {\n\t\t\tint from = in.nextInt();\n\t\t\tint to = in.nextInt();\n\t\t\tfor(int j=0; j<=n; ++j) visited[j] = false;\n\t\t\ts.clear();\n\t\t\tdfs(from, to, -1);\n\t\t\tout.println(s.size());\n\t\t}\n\t}\n\t\n\tvoid dfs(int from, int to, int lastcolor) {\n\t\tif(visited[from]) return;\n\t\tvisited[from] = true;\n\t\tfor(int i=0; i<2*m; ++i) {\n\t\t\tif(edge[i].from!=from) continue;\n\t\t\tif(edge[i].to==to) {\n\t\t\t\tif(edge[i].color==lastcolor || lastcolor==-1) s.add(edge[i].color);\n\t\t\t} else {\n\t\t\t\tif(edge[i].color==lastcolor || lastcolor==-1 ) dfs(edge[i].to, to, edge[i].color);\n\t\t\t}\n\t\t}\n\t\tvisited[from] = false;\n\t}\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint fx[] = {0, 0, +1, -1};\nint fy[] = {+1, -1, 0, 0};\nusing namespace std;\nconst int maX = 1e3 + 1;\nvector<long long> Graph[maX], cost[maX];\nlong long visit[maX];\nlong long color[maX];\nlong long cc = 0;\nvoid dfs(long long x, long long y, long long z) {\n  visit[x] = 1;\n  if (x == z) return;\n  for (long long i = 0; i < Graph[x].size(); i++) {\n    long long u = Graph[x][i];\n    if (visit[u] == 0 && cost[x][i] == y) {\n      cc++;\n      dfs(u, y, z);\n    }\n  }\n}\nint main() {\n  long long n, m, i, j, k = 0;\n  cin >> n >> m;\n  for (i = 1; i <= m; i++) {\n    long long x, y, z;\n    cin >> x >> y >> z;\n    Graph[x].push_back(y);\n    Graph[y].push_back(x);\n    cost[x].push_back(z);\n    cost[y].push_back(z);\n    color[z] = 1;\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    k = 0;\n    long long x, y;\n    cin >> x >> y;\n    for (i = 1; i <= m; i++) {\n      memset(visit, 0, sizeof(visit));\n      if (color[i]) {\n        dfs(x, i, y);\n        if (visit[y]) {\n          k += 1;\n        }\n      }\n    }\n    cout << k << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author revanth\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BMrKitayutasColorfulGraph solver = new BMrKitayutasColorfulGraph();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BMrKitayutasColorfulGraph {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt(), x, y, z;\n            DSU[] graph = new DSU[101];\n            for (int i = 1; i <= 100; i++)\n                graph[i] = new DSU(n);\n            while (m-- > 0) {\n                x = in.nextInt();\n                y = in.nextInt();\n                z = in.nextInt();\n                graph[z].union(x, y);\n            }\n            int q = in.nextInt();\n            while (q-- > 0) {\n                x = in.nextInt();\n                y = in.nextInt();\n                z = 0;\n                for (int i = 1; i <= 100; i++) {\n                    if (graph[i].root(x) == graph[i].root(y))\n                        z++;\n                }\n                out.println(z);\n            }\n        }\n\n    }\n\n    static class DSU {\n        public int[] root;\n        public int[] size;\n\n        public DSU(int n) {\n            root = new int[n + 1];\n            size = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                root[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public int root(int i) {\n            while (root[i] != i) {\n                root[i] = root[root[i]];\n                i = root[i];\n            }\n            return i;\n        }\n\n        public void union(int x, int y) {\n            int ra = root(x);\n            int rb = root(y);\n            if (ra == rb)\n                return;\n            if (size[ra] < size[rb]) {\n                root[ra] = root[rb];\n                size[rb] += size[ra];\n            } else {\n                root[rb] = root[ra];\n                size[ra] += size[rb];\n            }\n            return;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\t\t\n\ndef vecinos(v,colorList,pase):\n\tif not pase[v]:\n\t\tpase[v] = True\n\t\tfor x in colorList[v]:\n\t\t\tvecinos(x,colorList,pase)\n\t\n\nn,m = map(int,sys.stdin.readline().split())\n\nlistByColor = [[[] for fruta in range(n)] for fruta in range(m)]\n\nfor fruta in range(m):\n\ta,b,c = map(int,sys.stdin.readline().split())\n\tlistByColor[c-1][a-1].append(b-1)\n\tlistByColor[c-1][b-1].append(a-1)\n\nq = int(sys.stdin.readline())\n\nfor fruta in range(q):\n\tu,v = map(int,sys.stdin.readline().split())\n\tcounter = 0\n\tfor colorList in listByColor:\n\t\tpase = [False for frutta in range(n)]\n\t\tvecinos(v-1,colorList,pase)\n\t\tif pase[u-1]:\n\t\t\tcounter += 1\n\tprint counter\n\n\n\t\n\t\n\n\t\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\n# sys.stdin = open('in')\n\n\nclass Dsu:\n    def __init__(self):\n        self.__sz = {}\n        self.__parent = {}\n\n    def parent(self, a):\n        if (a not in self.__parent) or (a == self.__parent[a]):\n            return a\n        else:\n            self.__parent[a] = self.parent(self.__parent[a])\n            return self.__parent[a]\n\n    def connect(self, a, b):\n        p1 = self.parent(a)\n        p2 = self.parent(b)\n\n        if p2 != p1:\n            if p1 not in self.__sz:\n                self.__sz[p1] = 1\n            if p2 not in self.__sz:\n                self.__sz[p2] = 1\n\n            sz1 = self.__sz[p1]\n            sz2 = self.__sz[p2]\n\n            if sz1 >= sz2:\n                self.__parent[p2] = p1\n                self.__sz[p1] += self.__sz[p2]\n            else:\n                self.__parent[p1] = p2\n                self.__sz[p2] += self.__sz[p1]\n\n    def connected(self, a, b):\n        return self.parent(a) == self.parent(b)\n\n\n# reading input\nn, m = [int(i) for i in input().split(' ')]\ng = {}\nchoice = {}\nfor j in range(m):\n    a, b, c = [int(i) for i in input().split(' ')]\n    if c not in g:\n        g[c] = Dsu()\n    g[c].connect(a, b)\n    if a not in choice:\n        choice[a] = []\n    if b not in choice:\n        choice[b] = []\n    choice[a].append(c)\n    choice[b].append(c)\n\n# compute output\nq = int(input())\nmem = {}\nfor j in range(q):\n    a, b = [int(i) for i in input().split(' ')]\n    if a not in choice or b not in choice:\n        print('0')\n        continue\n\n    if a in mem and type(mem[a]) == dict and b in mem[a]:\n        s = mem[a][b]\n    else:\n        options = set.intersection(set(choice[a]), set(choice[b]))\n        s = 0\n        for c in options:\n            s += int(g[c].connected(a, b))\n        if a not in mem:\n            mem[a] = {}\n        if b not in mem:\n            mem[b] = {}\n        mem[a][b] = mem[b][a] = s\n    print(s)"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nd = {}\nadj = [[] for i in range(1 + n)]\nd = [[[-1 for k in range(101)] for j in range(1 + n)] for i in range(n + 1)]\n\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n    d[a][b][c] = 1\n    d[b][a][c] = 1\n    # d[(a, b)] = d.get((a, b), []) + [c]\n    # d[(b, a)] = d.get((b, a), []) + [c]\nvisited = [0] * (n + 1)\n\ndef dfs(u, target, c):\n    if u == target:\n        return True\n    visited[u] = 1\n    for v in adj[u]:\n        if visited[v] == 0 and d[u][v][c] == 1:\n            if dfs(v, target, c):\n                return True\n    return False\n\n\n\nfor _ in range(int(input())):\n    u, v = map(int, input().split())\n    res = 0\n    for i in range(1, 101):\n        visited = [0] * (n + 1)\n        if dfs(u, v, i):\n            res += 1\n    print(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> nei[105][105];\nbool mark[105];\nbool DFS(int root, int color, int dest) {\n  bool res = (root == dest);\n  mark[root] = true;\n  for (int i = 0; i < nei[root][color].size(); i++)\n    if (!mark[nei[root][color][i]])\n      res |= DFS(nei[root][color][i], color, dest);\n  return res;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int C = 0;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    nei[a][c].push_back(b);\n    nei[b][c].push_back(a);\n    C = max(C, c);\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n    int count = 0;\n    for (int col = 1; col <= C; col++) {\n      memset(mark, 0, sizeof(mark));\n      if (DFS(a, col, b)) count++;\n    }\n    cout << count << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = list(map(int,input().split()))\np = [ [ i for i in range(n) ] for j in range(m)]\ndef f(ci,xi):\n  if xi==p[ci][xi]: return xi\n  p[ci][xi] = f(ci,p[ci][xi])\n  return p[ci][xi]\ndef uni(ci,xi,yi):\n  p[ci][f(ci,xi)]=f(ci,yi)\nfor i in range(m):\n  a, b, c = list(map(int,input().split()))\n  uni(c-1,a-1,b-1)\nfor i in range(int(input())):\n  a, b = list(map(int,input().split()))\n  print(sum(1 if f(i,a-1) == f(i,b-1) else 0 for i in range(m)))\n"
        },
        {
            "language": 3,
            "solution": "\nfrom collections import defaultdict\n\n\ndef dfs(i,col):\n    bool[i-1] = True\n\n\n    for j in hash1[i]:\n\n        if j[1] == col:\n          if bool[j[0]-1] == False:\n            dfs(j[0],col)\n\n\n\n\n\n\n\n\n\n\nn,m = map(int,input().split())\n\n\nhash1 = defaultdict(list)\nhash2 = defaultdict(set)\nfor i in range(m):\n\n    a,b,c = map(int,input().split())\n    hash1[a].append([b,c])\n    hash2[a].add(c)\n    hash1[b].append([a,c])\n    hash2[b].add(c)\n\nq = int(input())\nans = []\n\nfor i in range(q):\n\n\n    a,b = map(int,input().split())\n\n\n    count = 0\n    for j in hash2[a]:\n        bool = [False]*n\n        dfs(a,j)\n\n        if bool[b-1] == True:\n            count+=1\n\n    ans.append(count)\n\n\nprint(*ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long>> adj[101];\nlong long vis[101];\nlong long sum;\nvoid dfs(long long n, long long des, long long c) {\n  vis[n] = 1;\n  if (n == des) {\n    sum++;\n    return;\n  }\n  for (auto x : adj[n]) {\n    long long ch = x.first;\n    long long col = x.second;\n    if (vis[ch] == 0 && col == c) {\n      dfs(ch, des, c);\n    }\n  }\n}\nvoid icchhipadey() {\n  long long n, m;\n  cin >> n >> m;\n  long long a, b, c;\n  long long q;\n  for (int i = 1; i <= n; i++) vis[i] = 0;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    adj[a].push_back({b, c});\n    adj[b].push_back({a, c});\n  }\n  cin >> q;\n  long long ans = 0;\n  for (int i = 0; i < q; i++) {\n    cin >> a >> b;\n    ans = 0;\n    for (long long col = 1; col <= 100; col++) {\n      sum = 0;\n      for (int j = 1; j <= n; j++) {\n        vis[j] = 0;\n      }\n      dfs(a, b, col);\n      ans += sum;\n    }\n    cout << ans << endl;\n  }\n}\nint main() { icchhipadey(); }\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\n# n: numero de vertices\n# m: numero de arestas\nmatriz = [[[] for j in xrange(n + 1)] for i in xrange(n + 1)]\nvis = []\n\nfor i in xrange(m):\n\ta, b, c = map(int, raw_input().split())\n\tif c not in matriz[a][b]:\n\t\tmatriz[a][b].append(c)\n\t\tmatriz[b][a].append(c)\n\n\ndef dfs(u, v, c):\n\tif u in vis: return False\n\tif u == v: \n\t\tif c not in cores: cores.append(c)\n\telse: vis.append(u)\n\tfor i in xrange(1, n + 1):\n\t\tif len(matriz[u][i]) > 0:\n\t\t\tif c in matriz[u][i]:\n\t\t\t\tdfs(i, v, c)\n\t\t\t\t\nqueries = input()\nfor i in xrange(queries):\n\tcores = []\n\tu, v = map(int, raw_input().split())\n\tfor c in xrange(1, 101):\n\t\tvis = []\n\t\tdfs(u, v, c)\n\tprint len(cores)\n"
        },
        {
            "language": 1,
            "solution": "def dfs(node, node_search, color):\n    marked[node] = True\n\n    if node == node_search:\n        return True\n\n    for u, c in grafo[node]:\n        if c == color and not marked[u]:\n            if dfs(u, node_search, color):\n                return True\n\n    return False\n\n\nn, m = map(int, raw_input().split())\n\ngrafo = [[] for i in xrange(n + 1)]\n\nfor edgs in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    grafo[a].append((b, c))\n    grafo[b].append((a, c))\n\nn_q = int(raw_input())\nfor q in xrange(n_q):\n    u, v = map(int, raw_input().split())\n\n    colors = 0\n    for c in xrange(1, 101):\n        marked = [False] * (n + 1)\n        if (dfs(u, v, c)):\n            colors += 1\n\n    print colors"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int> > adj[n + 1];\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int st, en;\n    cin >> st >> en;\n    bool visited[n + 1][m + 1];\n    for (int i = 0; i <= n; i++)\n      for (int j = 0; j <= m; j++) visited[i][j] = false;\n    bool color[m + 1];\n    for (int i = 0; i <= m; i++) color[i] = true;\n    int cnt = 0;\n    for (int i = 0; i < adj[st].size(); i++) {\n      pair<int, int> f = adj[st][i];\n      int col = f.second;\n      int star = f.first;\n      if ((!visited[star][col]) && (color[col])) {\n        visited[star][col] = true;\n        queue<int> q;\n        q.push(star);\n        while (!q.empty()) {\n          int u = q.front();\n          if (u == en) {\n            cnt++;\n            color[col] = false;\n            break;\n          }\n          q.pop();\n          for (int j = 0; j < adj[u].size(); j++) {\n            pair<int, int> ins = adj[u][j];\n            if ((!visited[ins.first][ins.second]) && (ins.second == col)) {\n              visited[ins.first][ins.second] = true;\n              q.push(ins.first);\n            }\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.*;\n\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    int p[][];\n    int size[][];\n\n\n    void make(int v, int c) {\n        p[c][v] = v;\n        size[c][v] = 1;\n    }\n\n    int find(int v, int c) {\n        if (v == p[c][v]) {\n            return v;\n        }\n        return p[c][v] = find(p[c][v], c);\n    }\n\n    void union(int a, int b, int c) {\n        a = find(a, c);\n        b = find(b, c);\n        if (a != b) {\n            if (size[c][a] < size[c][b]) {\n                int t = b;\n                b = a;\n                a = t;\n            }\n\n            p[c][b] = a;\n            size[c][a] += size[c][b];\n        }\n    }\n\n    void solve() {\n        int n = scanner.nextInt(), m = scanner.nextInt();\n        p = new int[m][n];\n        size = new int[m][n];\n\n        for (int i = 0 ; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                make(i, j);\n            }\n        }\n        for (int i = 0 ; i < m; i++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1, c = scanner.nextInt() - 1;\n            union(u, v, c);\n        }\n\n        int q = scanner.nextInt();\n\n        for (int i = 0; i < q; i++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;\n            int ans = 0;\n            for (int j = 0; j < m; j++) {\n                int a = find(u, j);\n                int b = find(v, j);\n                if (a == b) {\n                    ans ++;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch(IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "# Something \nnvertices, nedges = map(int,raw_input().split())\nmatrix = [[[] for j in xrange(nvertices+1)] for x in xrange(nvertices+1)]\nvisitados = []\n\ndef visita(r, t,cor):\n\tif r == t:\n\t\tif cor not in colors: colors.append(cor)\n\tif r in visitados:\n\t\treturn False\n\telse: visitados.append(r)\n\tfor i in range(1,nvertices+1):\n\t\tif len(matrix[r][i]) >0:\n\t\t\tif cor in matrix[r][i]:\n\t\t\t\tvisita(i,t,cor)\t\t\t\n\t\t\t\nfor i in xrange(nedges):\n\ta,b,c = map(int,raw_input().split())\n\tif c not in matrix[a][b]:\n\t\tmatrix[a][b].append(c)\n\t\tmatrix[b][a].append(c)\n\t\t\nq= int(raw_input())\nfor i in xrange(q):\n\tcolors = []\n\tu,v = map(int,raw_input().split())\n\tfor kor in range(1,101):\n\t\tvisitados = []\n\t\tvisita(u,v,kor)\n\tprint len(colors)\n\t"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    static boolean[][][] graph;\n    static boolean[] used;\n    static int n;\n\n    public static void main(String[] args) {\n\t    Scanner cin = new Scanner(System.in);\n        n = cin.nextInt();\n        int m = cin.nextInt();\n        graph = new boolean[n][n][m];\n        used = new boolean[n];\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            a = cin.nextInt() - 1;\n            b = cin.nextInt() - 1;\n            c = cin.nextInt() - 1;\n            graph[a][b][c] = true;\n            graph[b][a][c] = true;\n        }\n        int q = cin.nextInt();\n        for (int i = 0; i < q; i++) {\n            int u = cin.nextInt() - 1, v = cin.nextInt() - 1;\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (dfs(u, v, j)) {\n                    ++cnt;\n                }\n            }\n            System.out.println(cnt);\n        }\n        cin.close();\n    }\n\n    private static boolean dfs(int u, int v, int j) {\n\n        Arrays.fill(used, false);\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(u);\n        used[u] = true;\n        while (!q.isEmpty()) {\n            int f = q.poll();\n            for (int i = 0; i < n; i++) {\n                if (graph[f][i][j] && !used[i]) {\n                    used[i] = true;\n                    q.add(i);\n                }\n            }\n        }\n        return used[v];\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "\nfrom collections import deque ,defaultdict\n\n\ndef dfs(node , c):\n\n    for i in g[node]:\n        if not visited[i[0]] and i[1] == c :\n            visited[i[0]] = True\n            dfs(i[0] , i[1])\n\n\n\nn , m = map(int,input().split())\n\ng = defaultdict(list)\ncols = deque()\n#g = [[] for  i in range(n + 1)]\n\nfor i in range(m):\n    u , v , c = map(int,input().split())\n    g[u].append([v , c])\n    g[v].append([u , c])\n    cols.append(c)\n\n\nq = int(input())\nans = deque()\nfor i in range(q):\n    x , y = map(int,input().split())\n    cnt = 0\n    for j in range(1 , m + 1 ):\n        visited = [False]*(n + 1)\n\n        dfs(x , j)\n        if visited[y] == True:\n            cnt +=1\n    ans.append(cnt)\n\n\nfor i in ans:\n    print(i)\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tString[] str = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(str[0]);\n\t\tint m = Integer.parseInt(str[1]);\n\t\tboolean[][][] edge = new boolean[n][n][m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tstr = br.readLine().split(\" \");\n\t\t\tedge[Integer.parseInt(str[0])-1][Integer.parseInt(str[1])-1][Integer.parseInt(str[2])-1] = true;\n\t\t\tedge[Integer.parseInt(str[1])-1][Integer.parseInt(str[0])-1][Integer.parseInt(str[2])-1] = true;\n\t\t}\n\t\tint q = Integer.parseInt(br.readLine());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tstr = br.readLine().split(\" \");\n\t\t\tpw.println(analyze(n, m, Integer.parseInt(str[0])-1, Integer.parseInt(str[1])-1, edge));\n\t\t}\n\t\t\n\t\tpw.close();\n\t\tbr.close();\n\t}\n\t\n\tprivate static int analyze(int n, int m, int a, int b, boolean[][][] edge) {\n\t\tint answer = 0;\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tboolean[] f = new boolean[n];\n\t\t\tint[] q = new int[n];\n\t\t\tint qt = 0, qb = 0;\n\t\t\tf[a] = true;\n\t\t\tq[qt++] = a;\n\t\t\twhile (qt != qb) {\n\t\t\t\tint t = q[qb++];\n\t\t\t\tif (t == b) { answer++; break; }\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i == t) continue;\n\t\t\t\t\tif (edge[t][i][c] && !f[i]) {\n\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\tq[qt++] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Solution {\n\t\n\tstatic int answer;\n\tstatic int[] mark;\n\tstatic int n, m;\n\tstatic int[][][] edges;\n\t\n\tstatic void dfs(int v, int finish, int color) {\n\t\t\tmark[v] = 1;\n\t\t\tif (v == finish) {\n\t\t\t\tanswer++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edges[v][color][i] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (mark[i] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdfs(i, finish, color);\n\t\t\t}\n\t\t}\n\n\tpublic static void main(String[] args) {\n\t\t Scanner scanner = new Scanner(System.in);\n\t\t n = scanner.nextInt();\n\t\t m = scanner.nextInt();\n\t\t \n\t\t edges = new int[n][m][n];\n\t\t \n\t\t for (int i = 0; i < m; i++) {\n\t\t\t int a = scanner.nextInt() - 1;\n\t\t\t int b = scanner.nextInt() - 1;\n\t\t\t int c = scanner.nextInt() - 1;\n\t\t\t \n\t\t\t edges[a][c][b] = 1;\n\t\t\t edges[b][c][a] = 1;\n\t\t }\n\t\t \n\t\t int q = scanner.nextInt();\n\n\t\t for (int i = 0; i < q; i++) {\n\t\t\t int u = scanner.nextInt() - 1;\n\t\t\t int v = scanner.nextInt() - 1;\n\t\t\t \n\t\t\t answer = 0;\n\t\t\t \n\t\t\t for (int j = 0; j < m; j++) {\n\t\t\t\tmark = new int[n];\n\t\t\t\tdfs(u, v, j); \n\t\t\t }\n\t\t\t \n\t\t\t System.out.println(answer);\n\t\t }\n\t\t \n\t\t scanner.close();\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author gaidash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BCvetnoiGrafMisteraKitayuta solver = new BCvetnoiGrafMisteraKitayuta();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BCvetnoiGrafMisteraKitayuta {\n        private BCvetnoiGrafMisteraKitayuta.Vertex[] vs;\n\n        private void addEdge(int u, int v, int color) {\n            for (BCvetnoiGrafMisteraKitayuta.Edge edge : vs[u].outgo) {\n                if (edge.dest == v) {\n                    edge.colors.add(color);\n                    for (BCvetnoiGrafMisteraKitayuta.Edge edge2 : vs[v].outgo) {\n                        if (edge2.dest == u) {\n                            edge2.colors.add(color);\n                            return;\n                        }\n                    }\n                    throw new RuntimeException();\n                }\n            }\n            vs[u].outgo.add(new BCvetnoiGrafMisteraKitayuta.Edge(v, color));\n            vs[v].outgo.add(new BCvetnoiGrafMisteraKitayuta.Edge(u, color));\n        }\n\n        private int bfs(int start, int end, int color) {\n            boolean[] visited = new boolean[vs.length];\n            LinkedList<Integer> q = new LinkedList<>();\n            q.addLast(start);\n            visited[start] = true;\n            while (!q.isEmpty()) {\n                int cur = q.pollFirst();\n                if (cur == end) {\n                    return 1;\n                }\n                for (BCvetnoiGrafMisteraKitayuta.Edge edge : vs[cur].outgo) {\n                    if (edge.colors.contains(color) && !visited[edge.dest]) {\n                        visited[edge.dest] = true;\n                        q.addLast(edge.dest);\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int nVertices = in.nextInt();\n            int nEdges = in.nextInt();\n            vs = new BCvetnoiGrafMisteraKitayuta.Vertex[nVertices];\n            for (int i = 0; i < nVertices; i++) {\n                vs[i] = new BCvetnoiGrafMisteraKitayuta.Vertex();\n            }\n            for (int i = 0; i < nEdges; i++) {\n                addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());\n            }\n            int q = in.nextInt();\n            while (q-- > 0) {\n                int start = in.nextInt() - 1;\n                int end = in.nextInt() - 1;\n                int ret = 0;\n                for (int color = 1; color <= nEdges; color++) {\n                    ret += bfs(start, end, color);\n                }\n                out.println(ret);\n            }\n        }\n\n        private static class Vertex {\n            private ArrayList<BCvetnoiGrafMisteraKitayuta.Edge> outgo = new ArrayList<>();\n\n        }\n\n        private static class Edge {\n            private int dest;\n            private HashSet<Integer> colors = new HashSet<>();\n\n            private Edge(int dest, int color) {\n                this.dest = dest;\n                colors.add(color);\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class kita{\npublic static long mod = 1000000007;\npublic static int dx[] = {-1,0,1,0,-1,-1,1,1,-1};//primero ady, despues esq\npublic static int dy[] = {0,1,0,-1,1,1,-1,-1};\npublic static int ds[][];\npublic static void main(String args[]) throws IOException{\nStringBuilder sb = new StringBuilder(\"\");\nBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\nString tmp[] = lector.readLine().split(\" \");\n//int cas = Integer.parseInt(lector.readLine());\nint nn = Integer.parseInt(tmp[0]);\nint mm = Integer.parseInt(tmp[1]);\nds = new int[mm][nn];\nfor(int n = 0;n<mm;n++)\nfor(int m = 0;m<nn;m++)\nds[n][m]=m;\nfor(int n =0;n<mm;n++){\ntmp = lector.readLine().split(\" \");\nint tt[] = new int[3];\nfor(int m = 0;m<3;m++)\ntt[m]=Integer.parseInt(tmp[m])-1;\nunion(tt[0],tt[1],tt[2]);\n}\nint q = Integer.parseInt(lector.readLine());\nfor(int n = 0;n<q;n++){\nint res = 0;\ntmp= lector.readLine().split(\" \");\nfor(int m = 0;m<mm;m++)\nif(find(Integer.parseInt(tmp[0])-1,m)==find(Integer.parseInt(tmp[1])-1,m))\nres++;\nsb.append(res+\"\\n\");\n}\nSystem.out.print(sb);\n}\npublic static int find(int a,int b){\nreturn ds[b][a]==a?a:find(ds[b][a],b);\n}\npublic static void union(int a,int b,int c){\nint pa = find(a,c);\nint pb = find(b,c);\nds[c][pb]=pa;\n}\n}\nclass p implements Comparable{\npublic int a;\npublic p(int a){\nthis.a = a;\n}\npublic String toString(){\nreturn \"\";\n}\npublic int compareTo(Object o){\np pp = (p)o;\nreturn (int)Math.signum(a-pp.a);\n}\n}\n//sergio1\n"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\nfrom copy import deepcopy\n\n\ndef is_reachable(u, v, node_dic):\n    now = u\n    cons = set([])\n    nex = [u]\n    while 1:\n        nax = []\n        for n in nex:\n            cons.add(n)\n            if v in node_dic[n]:\n                return True\n            else:\n                for node in node_dic[n]:\n                    if not node in cons:\n                        nax.append(node)\n        nex = nax\n        if not nex:\n            break\n    return False\n\ndef main():\n    edges = []\n    color_node_dic = defaultdict(lambda: defaultdict(list))\n    n, m = map(int, raw_input().split(' '))\n    colors = set([])\n    nodes = set([])\n    for _ in xrange(m):\n        a, b, c = map(int, raw_input().split(' '))\n        edges.append((a, b, c))\n        colors.add(c)\n    for edge in edges:\n        color_node_dic[edge[2]][edge[0]].append(edge[1])\n        color_node_dic[edge[2]][edge[1]].append(edge[0])\n        nodes.add(edge[0])\n        nodes.add(edge[1])\n\n    q = input()\n    for _ in xrange(q):\n        u, v = map(int, raw_input().split(' '))\n        ans = 0\n        for color, node_dic in color_node_dic.iteritems():\n            if is_reachable(u, v, node_dic):\n                ans += 1\n            else:\n                pass\n        print ans\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int find(long long int par[], long long int i) {\n  if (par[i] == i) {\n    return i;\n  }\n  long long int x = find(par, par[i]);\n  par[i] = x;\n  return par[i];\n}\nvoid un(long long int par[], long long int i, long long int j) {\n  long long int si = find(par, i);\n  long long int sj = find(par, j);\n  if (si == sj) {\n    return;\n  }\n  par[si] = sj;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, m;\n  cin >> n >> m;\n  vector<vector<pair<int, int>>> ed(101);\n  long long int a, b, c;\n  while (m-- != 0) {\n    cin >> a >> b >> c;\n    a--;\n    b--;\n    ed[c].push_back(make_pair(a, b));\n  }\n  long long int par[n][101];\n  for (long long int i = 0; i < 101; i++) {\n    long long int tpar[n];\n    for (long long int j = 0; j < n; j++) {\n      tpar[j] = j;\n    }\n    for (auto z : ed[i]) {\n      un(tpar, z.first, z.second);\n    }\n    for (long long int j = 0; j < n; j++) {\n      find(tpar, j);\n    }\n    for (long long int j = 0; j < n; j++) {\n      par[j][i] = tpar[j];\n    }\n  }\n  long long int q;\n  cin >> q;\n  long long int u, v, ans;\n  while (q-- != 0) {\n    ans = 0;\n    cin >> u >> v;\n    u--;\n    v--;\n    for (long long int i = 0; i < 101; i++) {\n      if (par[u][i] == par[v][i]) {\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 105;\nconst int mod = 1e9 + 7;\nvector<pair<long long, long long> > v[N];\nbool visit[N];\nbool dfs(int a, int b, int color) {\n  if (a == b) return true;\n  visit[a] = true;\n  bool ans = false;\n  for (auto it : v[a]) {\n    if (it.second == color and !visit[it.first]) {\n      ans |= dfs(it.first, b, color);\n    }\n  }\n  return ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int n, m, q;\n  cin >> n >> m;\n  for (int i = int(1); i <= int(m); i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[a].push_back({b, c});\n    v[b].push_back({a, c});\n  }\n  cin >> q;\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    int ans = 0;\n    for (int i = int(1); i <= int(m); i++) {\n      memset(visit, false, sizeof visit);\n      if (dfs(a, b, i)) ans++;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\ndef bfs(v, n, a, b):\n    res = set()\n    # use dp to speed up\n    for startn, c in v[a]:\n        if (c in res): continue\n        visited = [0] * (n + 1)\n        q = deque()\n        q.append(startn)\n        visited[a] = 1\n        visited[startn] = 1\n        while (q):\n            cur = q.popleft()\n            if (cur == b): break\n            for nb, nbc in v[cur]:\n                if (nbc != c): continue\n                if (visited[nb]): continue\n                q.append(nb)\n                visited[nb] = 1\n        if (cur == b): res.add(c)\n    return len(res)\n\nn, m = map(int, raw_input().split())\nv = [[] for _ in xrange(n + 1)]\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    v[a].append((b, c))\n    v[b].append((a, c))\nq = input()\nfor i in xrange(q):\n    a, b = map(int, raw_input().split())\n    print bfs(v, n, a, b)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n/**\n * Created by WiNDWAY on 8/27/16.\n */\n\npublic class Codeforces_round_286_div_2_MrKitayutaColorfulGraph {\n\n    public static void main(String[] args) {\n        FScanner input = new FScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out), true);\n        int n = input.nextInt();\n        int m = input.nextInt();\n        HashMap<Integer, DisjointSet> map = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            int u = input.nextInt();\n            int v = input.nextInt();\n            int c = input.nextInt();\n            DisjointSet currentSet;\n            if (!map.containsKey(c)) {\n                currentSet = new DisjointSet();\n            } else {\n                currentSet = map.get(c);\n            }\n            if (!currentSet.map.containsKey(u)) {\n                currentSet.createSet(u);\n            }\n            if (!currentSet.map.containsKey(v)) {\n                currentSet.createSet(v);\n            }\n            currentSet.unionSet(u, v);\n            map.put(c, currentSet);\n        }\n        int q = input.nextInt();\n        for (int i = 0; i < q; i++) {\n            int colors = 0;\n            int u = input.nextInt();\n            int v = input.nextInt();\n            for (int color : map.keySet()) {\n                DisjointSet currentSet = map.get(color);\n                int findU = currentSet.findSet(u);\n                if (findU != -1 && findU == currentSet.findSet(v)) {\n                    colors++;\n                }\n            }\n            out.println(colors);\n        }\n        out.close();\n    }\n\n    public static PrintWriter out;\n\n    public static class FScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        private String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n\n    static class DisjointSet {\n\n        HashMap<Integer, Node> map;\n\n        public DisjointSet() {\n            map = new HashMap<>();\n        }\n\n        public void createSet(int data) {\n            Node node = new Node(data, 0);\n            node.parent = node;\n            map.put(data, node);\n        }\n\n        public int findSet(int data) {\n            if (!map.containsKey(data)) {\n                return -1;\n            } else {\n                int parentData = map.get(data).parent.data;\n                if (parentData == data) {\n                    return data;\n                } else {\n                    return findSet(parentData);\n                }\n            }\n        }\n\n        public boolean unionSet(int firstSet, int secondSet) {\n            int firstParentID = findSet(firstSet);\n            int secondParentID = findSet(secondSet);\n            Node firstParent = map.get(firstParentID);\n            Node secondParent = map.get(secondParentID);\n\n            // If they are part of same set do nothing\n            if (firstParentID == secondParentID) {\n                return false;\n            }\n\n            if (firstParent.rank > secondParent.rank) {\n                secondParent.parent = firstParent;\n            } else if (firstParent.rank < secondParent.rank) {\n                firstParent.parent = secondParent;\n            } else {\n                firstParent.rank++;\n                secondParent.parent = firstParent;\n            }\n            map.put(firstParentID, firstParent);\n            map.put(secondParentID, secondParent);\n\n            return true;\n        }\n\n        static class Node {\n            int data;\n            Node parent;\n            int rank;\n\n            public Node(int data, int rank) {\n                this.data = data;\n                this.rank = rank;\n            }\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > x[105];\nint n, m;\nint vis[105];\nvoid dfs(int s, int c) {\n  if (vis[s]) return;\n  vis[s] = true;\n  for (int i = 0; i < x[s].size(); i++)\n    if (x[s][i].second == c) dfs(x[s][i].first, c);\n  return;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    x[a].push_back(make_pair(b, c));\n    x[b].push_back(make_pair(a, c));\n  }\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    int a, b;\n    cin >> a >> b;\n    int cnt = 0;\n    for (int i = 1; i <= m; i++) {\n      memset(vis, 0, sizeof(vis));\n      dfs(a, i);\n      cnt += vis[b];\n    }\n    cout << cnt << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int,raw_input().split())\ngraphs = {}\n\ndef connect(graph,key,val):\n  if key not in graph:\n    graph[key] = set()    \n  if val not in graph:\n    graph[val] = set()\n  graph[key].add(val)    \n  graph[val].add(key)\n\n\ndef getConnectedSet(graph,key):\n  graphSet = set()\n  graphSet.add(key)\n  pLen = 0\n  while(pLen != len(graphSet)):\n    pLen = len(graphSet)\n    for g in graphSet:\n      graphSet = graphSet.union(graph[g])\n  return graphSet\n    \n\ndef getConnectedSets(graph):\n  graphSets = []\n  for g in graph:\n    found = False\n    for s in graphSets:\n      if g in s:\n        found = True\n        continue\n    if not found:\n      graphSets.append(getConnectedSet(graph,g))\n  return graphSets\n\nfor i in range(m):\n  key,val,gr = map(int,raw_input().split())\n  if gr not in graphs:\n    graphs[gr]=dict()\n  connect(graphs[gr],key,val)\n  #graphs[gr].add(key)\n  #graphs[gr].add(val)\n\nfor g in graphs:\n  graphs[g] = getConnectedSets(graphs[g])\n\no = int(raw_input())\nfor i in range(o):\n  cnt = 0\n  j,k = map(int,raw_input().split())\n  for gr in graphs:\n    for g in graphs[gr]:\n      if j in g and k in g:\n        cnt += 1\n        break\n\n  print(cnt)\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    n, m = map(int, input().split())\n    edges = {_: {} for _ in range(1, m + 1)}\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        d = edges[c]\n        l = d.get(a)\n        if l:\n            l.append(b)\n        else:\n            d[a] = [b]\n        l = d.get(b)\n        if l:\n            l.append(a)\n        else:\n            d[b] = [a]\n\n    def dfs(t):\n        unused[t] = False\n        for y in dcolor.get(t, ()):\n            if unused[y]:\n                dfs(y)\n\n    res = []\n    n += 1\n    unused = [True] * n\n    for _ in range(int(input())):\n        a, b = map(int, input().split())\n        x = 0\n        for dcolor in edges.values():\n            for j in range(n):\n                unused[j] = True\n            dfs(a)\n            if not unused[b]:\n                x += 1\n        res.append(str(x))\n    print('\\n'.join(res))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Task {\n    \n    static int mainColor;\n    static ArrayList<Edge>[] g;\n    static boolean[] used;\n\n    class Edge {\n        int from, to, color;\n        Edge (int from, int to, int color) {\n            this.from = from;\n            this.to = to;\n            this.color = color;\n        }\n    }\n    \n    public void solve(InputReader scn, PrintWriter pw) {\n        int n = scn.nextInt(), m = scn.nextInt();\n        g = (ArrayList<Edge>[])(new ArrayList[n + 2]);\n        used = new boolean[n + 2];\n        for (int i = 1; i <= n; i++) g[i] = new ArrayList<Edge>();\n        for (int i = 0; i < m; i++) {\n            int from = scn.nextInt(), to = scn.nextInt(), color = scn.nextInt();\n            g[from].add(new Edge(from, to, color));\n            g[to].add(new Edge(to, from, color));\n        }\n        int q = scn.nextInt();\n        for (int i = 0; i < q; i++) {\n            int from = scn.nextInt(), to = scn.nextInt();\n            int res = 0;\n            for (int color = 1; color <= m; color++) {\n                Arrays.fill(used, false);\n                mainColor = color;\n                dfs(from);\n                if (used[to] == true) res++;                \n            }\n            pw.println(res);\n        }\n    }\n    \n    void dfs(int ver) {\n        used[ver] = true;\n        int len = g[ver].size();\n        for (int i = 0; i < len; i++) {\n            int to = g[ver].get(i).to;\n            int color = g[ver].get(i).color;\n            if (color != mainColor) continue;\n            if (used[to] == true) continue;\n            dfs(to);\n        }\n    }\n    \n }\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long binomialCoeff(long long n, long long k) {\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (long long i = 0; i < k; ++i) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nstruct MyComp {\n  bool operator()(const pair<int, int>& x, const pair<int, int>& y) const {\n    return x.second > y.second || (x.second == y.second && x.first > y.first);\n  }\n};\nlong long M = 1e9 + 7;\nlong long mods(long long a, long long b) {\n  a = a % M;\n  b = b % M;\n  return (a + b) % M;\n}\nlong long modp(long long a, long long b) {\n  a = a % M;\n  b = b % M;\n  return (a * b) % M;\n}\nvector<pair<int, int> > adj[105];\nvector<int> visited(105);\nbool dfs(int s, int t, int c) {\n  visited[s] = 1;\n  if (s == t) return true;\n  for (auto u : adj[s]) {\n    if (visited[u.first] == 0 && u.second == c) {\n      if (dfs(u.first, t, c)) return true;\n    }\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    adj[x].push_back({y, c});\n    adj[y].push_back({x, c});\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    for (int i = 1; i <= n; i++) visited[i] = 0;\n    int a, b;\n    cin >> a >> b;\n    int count = 0;\n    for (int i = 1; i <= m; i++) {\n      for (int i = 1; i <= n; i++) visited[i] = 0;\n      if (dfs(a, b, i)) count++;\n    }\n    cout << count << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n \n# Universidade Federal de Campina Grande\n# Aluno: Diego Adolfo Silva de Ara\u00fajo\n# Matricula: 113210090\n# Disciplina: Algoritmos Avan\u00e7ados\n\n# Codeforces \n# Problem: 505B - B. Mr. Kitayuta's Colorful Graph\n# Time limit per test: 1 second\n# Memory limit per test: 256 megabytes\n# Input: standard input\n# Output: standard output\n\ndef answer(start, end):\n    count = 0\n    global graph\n    \n    for key in graph:\n        if start not in graph[key] or end not in graph[key]:\n            continue\n        \n        if list([path for path in dfs_paths(graph[key], start, end, [])]):\n            count += 1\n    \n    return count\n\ndef dfs_paths(graph, start, end, path):\n    if not path:\n        path.append(start)\n    \n    if start == end:\n        yield path\n    \n    for vertex in graph[start] - set(path):\n        for key in dfs_paths(graph, vertex, end, path + [vertex]):\n            yield key\n\n        \n\ngraph = {}      \nn, m = map(int, raw_input().split())\n\nfor value in xrange(m):\n    vertex, edge, color = map(int, raw_input().split())\n    \n    if not graph.has_key(color):\n        graph[color] = {}\n    \n    if not graph[color].has_key(edge):\n        graph[color][edge] = set()\n    \n    if not graph[color].has_key(vertex):\n        graph[color][vertex] = set()\n       \n    graph[color][edge].add(vertex) \n    graph[color][vertex].add(edge)\n\nnum_queries = int(raw_input())\n\nfor line in xrange(num_queries):\n    u, v = map(int, raw_input().split())\n    print answer(u, v)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\t\n\tstatic ArrayList<Integer>[][] adj;\n\tstatic TreeSet<Integer> inPath;\n//\tstatic int queryAnswer;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tString[] split = f.readLine().split(\"\\\\s+\");\n\t\tint n = Integer.parseInt(split[0]), m = Integer.parseInt(split[1]);\n\t\t\n\t\tadj = new ArrayList[n+1][n+1];\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 0; j <= n; j++) {\n\t\t\t\tadj[i][j] = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tsplit = f.readLine().split(\"\\\\s+\");\n\t\t\tint u = Integer.parseInt(split[0]), v = Integer.parseInt(split[1]), c = Integer.parseInt(split[2]);\n\t\t\tadj[u][v].add(c);\n\t\t\tadj[v][u].add(c);\n\t\t}\n\t\tint q = Integer.parseInt(f.readLine());\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tboolean[][] V = new boolean[n+1][n+1];\n\t\t\tinPath = new TreeSet<Integer>();\n\t\t\tsplit = f.readLine().split(\"\\\\s+\");\n\t\t\tint u = Integer.parseInt(split[0]), v = Integer.parseInt(split[1]);\n\t\t\tV[u][u] = true;\n//\t\t\tSystem.out.println(Arrays.toString(V[u]));\n\t\t\tdfs(u, v, -1, V);\n\t\t\tSystem.out.println(inPath.size());\n\t\t}\n\t}\n\t\n\tstatic boolean dfs(int at, int target, int curColor, boolean[][] V) {\n//\t\tSystem.out.printf(\"At Node %d target %d\\n\", at, target);\n\t\tif(at == target) {\n//\t\t\tSystem.out.printf(\"Target found with color %d. Returning true\\n\", curColor);\n\t\t\treturn true;\n\t\t}\n\t\tint n = V.length-1;\n//\t\tSystem.out.println(\"VArray: \" + Arrays.toString(V[at]));\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif(V[at][i]) continue;\n//\t\t\tSystem.out.printf(\"Node %d to %d not previously visited using this color with size %d\\n\", at, i, adj[at][i].size());\n\t\t\tV[at][i] = V[i][at] = true;\n\t\t\tfor(int j = 0; j < adj[at][i].size(); j++) {\n\t\t\t\tint c = adj[at][i].get(j);\n\t\t\t\tif(curColor == -1) {\n//\t\t\t\t\tSystem.out.println(\"DFSing on color \" + c);\n\t\t\t\t\tboolean increment = dfs(i, target, c, V);\n\t\t\t\t\tif(increment) inPath.add(c);\n//\t\t\t\t\telse System.out.printf(\"DFS on color %d did not work!\\n\", c);\n\t\t\t\t} else if(curColor == c) {\n//\t\t\t\t\tSystem.out.println(\"Chain continuing on color \" + c);\n\t\t\t\t\tboolean increment = dfs(i, target, curColor, V);\n\t\t\t\t\tif(increment) inPath.add(curColor);\n//\t\t\t\t\telse System.out.printf(\"DFS on color %d did not work!\\n\", c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tV[at][i] = V[i][at] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n}\n\nclass Edge {\n\tint src, des, c;\n\tpublic Edge(int s, int d, int c) {\n\t\tsrc = s;\n\t\tdes = d;\n\t\tthis.c = c;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn src + \" \" + des + \" \" + c;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class ColorGraph {\n    static List<List<Point>> graph;\n    public static void main(String[] args) {\n        MyReader mr = new MyReader();\n\n        int n = mr.nextInt();\n        int m = mr.nextInt();\n\n        graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int a = mr.nextInt();\n            int b = mr.nextInt();\n            int c = mr.nextInt();\n\n            graph.get(a).add(new Point(b,c));\n            graph.get(b).add(new Point(a,c));\n        }\n\n//        System.out.println(graph);\n        int q= mr.nextInt();\n        StringBuilder ans= new StringBuilder();\n\n        for (int i = 0; i < q; i++) {\n            int a = mr.nextInt();\n            int b = mr.nextInt();\n            Set<Integer> colorVisited = new HashSet<>();\n            int res = 0;\n            for(Point p : graph.get(a))if(!colorVisited.contains(p.y)){\n                Set<Integer> visited = new HashSet<>();\n\n                visited.add(a);\n                if(dfs(p, b,visited, colorVisited))res++;\n            }\n\n            ans.append(res+\"\\n\");\n        }\n\n        ans.deleteCharAt(ans.length() - 1);\n        System.out.println(ans);\n\n\n\n    }\n\n    private static boolean dfs(Point p, int b, Set<Integer> visited,Set<Integer> colorVisited) {\n        if(p.x == b){\n            colorVisited.add(p.y);\n            return true;\n        }\n\n        for (Point n : graph.get(p.x))if(!visited.contains(n.x) && !colorVisited.contains(p.y)){\n            if(n.y == p.y){\n                visited.add(n.x);\n                if(dfs(n,b,visited,colorVisited))return true;\n            }\n        }\n\n        return false;\n    }\n\n    static class MyReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        MyReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String res = \"\";\n            try {\n                res = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return res;\n        }\n\n        Integer[] nextIntArray(int n) {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n\n            return arr;\n        }\n\n        Long[] nextLongArray(int n) {\n            Long[] arr = new Long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n\n            return arr;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] arr = new String[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = next();\n            }\n            return arr;\n        }\n    }\n\n    static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n}\n\n\n"
        },
        {
            "language": 1,
            "solution": "\nvisited = {}\n\ndef dfs(L,a,b):\n    if (a == b):\n        return 1\n    visited[a] = 1\n    c = False\n    for i in L[a]:\n        if (visited.has_key(i)):\n            continue\n        else:\n            c = c or dfs(L,i,b)\n    return c\n\n\n\ndef main():\n    global visited\n    n, m = [int(i) for i in raw_input().split()]\n    L = [[[] for j in range(n)] for i in range(m)]\n    for i in range(m):\n        a, b, c = [int(i) for i in raw_input().split()]\n        a -= 1\n        b -= 1\n        c -= 1\n        L[c][a].append(b)\n        L[c][b].append(a)\n    q = input()\n    for i in range(q):\n        count = 0\n        a, b = [int(i) for i in raw_input().split()]\n        a -= 1\n        b -= 1\n        for j in range(m):\n            visited = {}\n            if dfs(L[j], a, b):\n                count += 1\n        print count\n\n\n\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200;\nint n, m, u, v, c, q, cnt, mark[maxn];\nvector<int> g[maxn][maxn];\nvoid dfs(int w, int col) {\n  mark[w] = 1;\n  if (w == v) cnt++;\n  for (int i = 0; i < g[w][col].size(); i++) {\n    if (!mark[g[w][col][i]]) {\n      dfs(g[w][col][i], col);\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v >> c;\n    g[v][c].push_back(u);\n    g[u][c].push_back(v);\n  }\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> u >> v;\n    cnt = 0;\n    for (int j = 0; j < maxn; j++) {\n      memset(mark, 0, sizeof mark);\n      dfs(u, j);\n    }\n    cout << cnt << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "R=lambda:map(int,raw_input().split())\nRs=lambda:raw_input().split()\nn,m=R()\nmat=[[set() for j in range(n)] for i in range(n)]\nfor i in range(m):\n    a,b,c=R()\n    mat[a-1][b-1].add(c)\n    mat[b-1][a-1].add(c)\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            mat[i][j]=mat[i][j]|(mat[i][k]&mat[k][j])\nq=input()\nfor i in range(q):\n    x,y=R()\n    print len(mat[x-1][y-1])"
        },
        {
            "language": 3,
            "solution": "class Solution:\n    def __init__(self, n, m, edges):\n        self.n = n\n        self.m = m\n        self.edges = [[[] for _ in range(m+1)] for _ in range(n+1)]\n        for _from, _to, _color in edges:\n            self.edges[_from][_color].append(_to)\n            self.edges[_to][_color].append(_from)\n        self.id = 0\n\n    def initialize(self):\n        self.discovered = [[0]*(self.n+1) for i in range(self.m+1)]\n\n    def bfs(self, x0, color):\n        self.id += 1\n        stack = [x0]\n        while stack:\n            n = stack.pop()\n            if not self.discovered[color][n]:\n                self.discovered[color][n] = self.id\n                for neigh in self.edges[n][color]:\n                    stack.append(neigh)\n\ndef solve(graph, colors, u, v):\n    counter = 0\n    for color in colors:\n        if not graph.discovered[color][u] and not graph.discovered[color][v]:\n            graph.bfs(u, color)\n        if graph.discovered[color][u] == graph.discovered[color][v]:\n            counter += 1\n    return counter\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    colors = set()\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        colors.add(c)\n        edges.append((a, b, c))\n    graph = Solution(n, m, edges)\n    graph.initialize()\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        print(solve(graph, colors, u, v))\n\nif __name__ == '__main__':\n    main()\n        \n\n    \n        \n"
        },
        {
            "language": 3,
            "solution": "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\nparent_history = {}\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        if c in parent_history:\n            if v in parent_history[c]:\n                parent = parent_history[c]\n            else:\n                parent = {}\n                parent = dfs_visit(v, graph[c], parent)\n                if len(parent_history[c]) < len(parent):\n                    parent_history[c] = parent\n        else:\n            parent = {}\n            parent = dfs_visit(v, graph[c], parent)\n            parent_history[c] = parent\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\nif __name__ == \"__main__\":\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String args[]) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        SolverB.InputReader in = new SolverB.InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        SolverB solver = new SolverB();\n        int testCount = 1;\n        for (int i = 1; i <= testCount; i++) {\n            solver.solve(in, out);\n        }\n        out.close();\n    }\n}\n\nclass Graph {\n    List<Integer> edges[];\n    int n;\n\n    Graph(List<Integer> edges[], int n) {\n        this.edges = edges;\n        this.n = n;\n    }\n\n    public int bfs(final int u, final int v) {\n        int visited[] = new int[n+1];\n\n        Queue<Integer> q = new LinkedList<>();\n        q.add(u);\n        visited[u] = 1;\n\n        while (!q.isEmpty()) {\n            int x = q.poll();\n\n            for (int y : edges[x]) {\n                if (visited[y] == 0) {\n                    q.add(y);\n                    visited[y] = 1;\n                }\n            }\n        }\n\n        return visited[v];\n    }\n}\n\nclass SolverB {\n\n    public void solve(InputReader in, PrintWriter out) {\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        List<Integer> edges[][] = new ArrayList[m+1][n+1];\n\n        for (int i=1; i<=m; i++) {\n            for (int j=1; j<=n; j++) {\n                edges[i][j] = new ArrayList<>();\n            }\n        }\n\n        for (int i=0; i<m; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n            int c = in.nextInt();\n\n            edges[c][u].add(v);\n            edges[c][v].add(u);\n        }\n\n        Graph graph[] = new Graph[m+1];\n        for (int i=1; i<=m; i++) {\n            graph[i] = new Graph(edges[i], n);\n        }\n\n        int q = in.nextInt();\n\n        for (int i=0; i<q; i++) {\n            int u = in.nextInt();\n            int v = in.nextInt();\n\n            int s = 0;\n            for (int j=1; j<=m; j++) {\n                s += graph[j].bfs(u, v);\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "#code by aanchaltiwari__\ndef dfs(x, y, color):\n    visited = [False for i in range(n + 1)]\n    visited[x] = True\n    stack = [x]\n    while stack:\n        node = stack.pop()\n        for child, childcolor in g[node]:\n            if visited[child] == False and childcolor == color:\n                visited[child] = True\n                stack.append(child)\n    if visited[y] == True:\n        return True\n    return False\n\n\nn, m = map(int, input().split())\ng = {i: [] for i in range(1, n + 1)}\ns = set()\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    s.add(c)\n    g[u].append([v, c])\n    g[v].append([u, c])\ns = list(s)\n# print(g)\n# print(s)\nans = [[0 for i in range(n+1)]for j in range(n+1)]\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        for c in s:\n            if i != j:\n                if dfs(i, j, c):\n                    ans[i][j] += 1\n# print(ans)\nq = int(input())\nfor i in range(q):\n    u, v = map(int, input().split())\n    print(ans[u][v])\n"
        },
        {
            "language": 3,
            "solution": "def DFS(start, color):\n    global isUsed\n    isUsed[start] = True\n    for i in graph[start]:\n        if not isUsed[i[0]] and i[1] == color:\n            DFS(i[0], color)\n\nn, m = tuple(map(int, input().split()))\n\ngraph = [[] for i in range(n)]\n\nfor i in range(m):\n    a, b, c = tuple(map(int, input().split()))\n    graph[a - 1].append((b - 1, c))\n    graph[b - 1].append((a - 1, c))\n\nq = int(input())\nanswers = [0] * q\nfor i in range(q):\n    u, v = tuple(map(int, input().split()))\n    for j in range(1, m + 1):\n        isUsed = [False] * n\n        DFS(u - 1, j)\n        if isUsed[v - 1]:\n            answers[i] += 1\n\nprint(\"\\n\".join(map(str, answers)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2000000000;\nconst double pi = acos(-1.0);\nint G[105][105][105], cc[105][105], vis[105];\nint n, m;\nvoid DFS(int c, int u, int ctr) {\n  vis[u] = 1;\n  cc[c][u] = ctr;\n  for (int i = 1; i < n + 1; i++) {\n    if (!vis[i] && (G[c][u][i] == 1)) {\n      DFS(c, i, ctr);\n    }\n  }\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  while (cin >> n >> m) {\n    memset(G, 0, sizeof(G));\n    memset(cc, 0, sizeof(cc));\n    int a, b, c;\n    for (int i = 0; i < m; i++) {\n      cin >> a >> b >> c;\n      G[c][a][b] = 1;\n      G[c][b][a] = 1;\n    }\n    for (int i = 1; i < m + 1; i++) {\n      memset(vis, 0, sizeof(vis));\n      int ct = 1;\n      for (int j = 1; j < n + 1; j++) {\n        if (!vis[j]) {\n          DFS(i, j, ct);\n          ct++;\n        }\n      }\n    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n      cin >> a >> b;\n      int ans = 0;\n      for (int j = 1; j < m + 1; j++)\n        if ((cc[j][a] == cc[j][b]) && (cc[j][a] >= 1)) ans++;\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def find(num, color):\n    while dsu[color][num] != num:\n        num = dsu[color][num]\n    return num\n\ninp = lambda : map(int, input().split())\nn, m = inp()\ndsu = [[i for i in range(n + 1)] for _ in range(101)]\nfor i in range(m):\n    x, y, z = inp()\n    x1 = find(x, z)\n    y1 = find(y, z)\n    if x1 != y1:\n        dsu[z][x1] = y1\nq = int(input())\nfor i in range(q):\n    x, y = inp()\n    ans = 0\n    for j in range(101):\n        if find(x, j) == find(y, j):\n            ans += 1\n    print(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n\npublic class bfs_dfs {\n\t\n\tpublic static boolean[] vis;\n\t\n\tpublic static ArrayList<pair>[] v;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args)\n\t {\n\t\tscanner in = new scanner();\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tv = new ArrayList[n+1];\n\t\tfor(int i = 0;i<=n;i++)\n\t\t\tv[i] = new ArrayList<>();\n\t\tfor(int i = 0;i<m;i++)\n\t\t{\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tv[a].add(new pair(b,c));\n\t\t\tv[b].add(new pair(a,c));\n\t\t}\n\t\tint q = in.nextInt();\n\t\tfor(int i = 0;i<q;i++)\n\t\t{\n\t\t\tint str = in.nextInt();\n\t\t\tint dest = in.nextInt();\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 1;j<=m;j++)\n\t\t\t{\n\t\t\t\t vis = new boolean[n+1];\n\t\t\t\tdfs(str,j);\n\t\t\t\tif(vis[dest]) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void dfs(int str,int color)\n\t{\n\t\tvis[str] = true;\n\t\t\tfor(pair i : v[str])\n\t\t\t{\n\t\t\t\tif( !vis[i.next] && i.color==color)\n\t\t\t\t{\n\t\t\t\t\tdfs(i.next,color);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nclass pair\n{\n\tint next;\n\tint color;\n\tpublic pair(int next,int color)\n\t{\n\t\tthis.next = next;\n\t\tthis.color = color;\n\t}\n}\nclass scanner\n{\n\t BufferedReader br;\n\t StringTokenizer st;\n\t\n\tpublic scanner()\n\t{\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tst = null;\n\t}\n\tpublic String next()\n\t{\n\t\twhile(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tcatch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt()\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\tpublic long nextLong()\n\t{\n    \treturn\tLong.parseLong(next());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class B {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner scan = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = scan.nextInt(), m = scan.nextInt();\n\t\tTreeSet<Integer>[][] a = new TreeSet[n][n];\n\t\tfor(int i = 0; i < n; i++)for(int j = 0; j < n; j++)a[i][j] = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x = scan.nextInt()-1, y = scan.nextInt()-1, c = scan.nextInt()-1;\n\t\t\ta[x][y].add(c);\n\t\t\ta[y][x].add(c);\n\t\t}\n\t\tint k = scan.nextInt();\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tint s = scan.nextInt()-1, e = scan.nextInt()-1;\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\tboolean[][][] v = new boolean[n][n][m];\n\t\t\tTreeSet<Integer> colors = new TreeSet<>();\n\t\t\tq.add(s); q.add(-1);\n\t\t\tint t = 0;\n\t\t\twhile(!q.isEmpty() && t < 100){\n\t\t\t\tt++;\n\t\t\t\tint cur = q.poll(), color = q.poll();\n\t\t\t\tif(cur == e) {\n\t\t\t\t\tcolors.add(color);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfor(int c : a[cur][j]){\n\t\t\t\t\t\tif((color == -1 || c == color) && !v[cur][j][c]){\n\t\t\t\t\t\t\tv[cur][j][c] = true;\n\t\t\t\t\t\t\tv[j][cur][c] = true;\n\t\t\t\t\t\t\tq.add(j);\n\t\t\t\t\t\t\tq.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(colors.size());\n\t\t}\n\t\tout.close();\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = \"\";\n\t\t\ttry {line = br.readLine();} \n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn line;\n\t\t}\n\n\t\tpublic int[] nextArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\n/**\n * Date: 18-01-2015\n * Time: 14:21\n */\npublic class MrKitayutasColorfulGraph {\n    private static ArrayList<Integer>[][] colors;\n    private static int n;\n    private static HashSet<Integer> colorsUsed;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        colorsUsed = new HashSet<>();\n\n        n = in.nextInt();\n\n        colors = new ArrayList[n+1][n+1];\n\n        for (int i = 0; i < n + 1; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                colors[i][j] = new ArrayList<>();\n            }\n        }\n\n        int m = in.nextInt();\n\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();\n\n            colorsUsed.add(c);\n            colors[a][b].add(c);\n            colors[b][a].add(c);\n        }\n\n        int q = in.nextInt();\n\n        for (int i = 0; i < q; i++) {\n            int u = in.nextInt(), v = in.nextInt();\n            System.out.println(answerQuery(u, v));\n        }\n    }\n\n    private static int answerQuery(int u, int v) {\n        int res = 0;\n        for (int c : colorsUsed) {\n            if (isConnected(u, v, c)) res++;\n        }\n\n        return res;\n    }\n\n    private static boolean isConnected(int u, int v, int c) {\n        Queue<Integer> next = new ConcurrentLinkedQueue<>();\n        HashSet<Integer> visited = new HashSet<>();\n        next.add(u);\n        visited.add(u);\n        while (!next.isEmpty()) {\n            int t = next.remove();\n\n            if (t == v) return true;\n\n            for (int i = 0; i < n + 1; i++) {\n                for (int col : colors[t][i]) {\n                    if (col == c && !visited.contains(i)) {\n                        next.add(i);\n                        visited.add(i);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 120 + 7;\nconst long long INF = 1e9;\nconst long long mod = 1e9 + 7;\nint n;\nint m;\nint k;\nint used[N];\nvector<pair<int, int> > g[N];\nvoid dfs(int v, int c) {\n  used[v] = 1;\n  for (auto to : g[v]) {\n    if (!used[to.first] && to.second == c) {\n      dfs(to.first, c);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    g[x].push_back({y, z});\n    g[y].push_back({x, z});\n  }\n  cin >> k;\n  while (k--) {\n    int x, y;\n    cin >> x >> y;\n    map<int, int> T;\n    for (auto to : g[x]) {\n      dfs(x, to.second);\n      if (used[y]) {\n        T[to.second]++;\n      }\n      for (int i = 1; i <= n; i++) {\n        used[i] = 0;\n      }\n    }\n    cout << T.size() << endl;\n    T.clear();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = input().split(' ')\nl = []\nfor x in range(int(m)):\n    l.append(list(range(int(n))))\nfor x in range(int(m)):\n    p = input().split(' ')\n    newl = l[int(p[2])-1]\n    a,i = max(newl[int(p[0])-1],newl[int(p[1])-1]),min(newl[int(p[0])-1],newl[int(p[1])-1])\n    for y in range(len(newl)):\n        if newl[y] == a:\n            newl[y] = i\n    l[int(p[2])-1] = newl\nq = int(input())\nput = []\nfor x in range(q):\n    out = 0\n    a,b = input().split(' ')\n    for n in l:\n        if n[int(a)-1] == n[int(b)-1]:\n            out += 1\n    put.append(out)\nfor x in put:\n    print(x)\n"
        },
        {
            "language": 3,
            "solution": "import queue\n\nn, m = map(int, input().strip().split())\n\nadj = [[] for i in range(n + 1)]\n\ndef doable(s, t, c):\n\tglobal adj, n, m\n\tq = queue.Queue()\n\tvisited = [False for i in range(n + 1)]\n\n\tq.put(s)\n\tvisited[s] = True\n\twhile not q.empty():\n\t\tu = q.get()\n\t\tfor v in adj[u]:\n\t\t\tif v[1] == c and not visited[v[0]]:\n\t\t\t\tq.put(v[0])\n\t\t\t\tvisited[v[0]] = True\n\treturn visited[t]\n\n\nmaxc = 0\nfor _ in range(m):\n\tu, v, c = map(int, input().strip().split())\n\tadj[u].append((v, c))\n\tadj[v].append((u, c))\n\tmaxc = max(maxc, c)\n\nq = int(input())\n\nfor _ in range(q):\n\tu, v = map(int, input().strip().split())\n\tans = 0\n\tfor color in range(1, maxc + 1):\n\t\tif (doable(u, v, color)):\n\t\t\tans += 1\n\tprint(ans)\n\t"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\n\ndef find(node, color):\n    x = []\n    while colors[color][node] > 0:\n        x.append(node)\n        node = colors[color][node]\n    for i in x:\n        colors[color][i] = node\n    return node\n\ndef union(node1, node2, color):\n    if node1 != node2:\n        if colors[color][node1] > colors[color][node2]:\n            node1, node2 = node2, node1\n        colors[color][node1] += colors[color][node2]\n        colors[color][node2] = node1\n\nn, m = map(int, stdin.readline().strip().split())\ncolors = [[-1 for i in range(n+1)] for j in range(m+1)]\nfor __ in range(m):\n    a, b, c = map(int, stdin.readline().strip().split())\n    union(find(b, c), find(a, c), c)\nq = int(stdin.readline().strip())\noutputs = []\nfor __ in range(q):\n    count = 0\n    a, b = map(int, stdin.readline().strip().split())\n    for i in range(1, m+1):\n        if find(a, i) == find(b, i):\n            count += 1\n    outputs.append(count)\nfor output in outputs:\n    stdout.write(f'{output}\\n')\n\n"
        },
        {
            "language": 1,
            "solution": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\nfrom copy import deepcopy\n\n\ndef is_reachable(u, v, node_dic):\n    # node_dic\u306b\u57fa\u3065\u304d\uff0cu\u304b\u3089v\u306b\u9053\u304c\u3042\u308b\u304b\u3092\u30c1\u30a7\u30c3\u30af\n    now = u\n    cons = set([])\n    nex = [u]\n    while 1:\n        nax = []\n        for n in nex:\n            cons.add(n)\n            if v in node_dic[n]:\n                return True\n            else:\n                for node in node_dic[n]:\n                    if not node in cons:\n                        nax.append(node)\n        nex = nax\n        if not nex:\n            break\n    return False\n\ndef main():\n    edges = []\n    color_node_dic = defaultdict(lambda: defaultdict(list))\n    n, m = map(int, raw_input().split(' '))\n    colors = set([])\n    nodes = set([])\n    for _ in xrange(m):\n        a, b, c = map(int, raw_input().split(' '))\n        edges.append((a, b, c))\n        colors.add(c)\n    for edge in edges:\n        color_node_dic[edge[2]][edge[0]].append(edge[1])\n        color_node_dic[edge[2]][edge[1]].append(edge[0])\n        nodes.add(edge[0])\n        nodes.add(edge[1])\n\n    q = input()\n    for _ in xrange(q):\n        u, v = map(int, raw_input().split(' '))\n        ans = 0\n        for color, node_dic in color_node_dic.iteritems():\n            if is_reachable(u, v, node_dic):\n                ans += 1\n            else:\n                pass\n        print ans\n            # \u5230\u9054\u53ef\u80fd\u304b\uff1f\n            # nex = []\n            # for node in node_dic[u]:\n            #     cons = set([u])\n            #     nex.append((node, cons))\n            #     while nex:\n            #         if nn[0] == v:\n            #             \n            #         for nn in nex:\n            #             print node_dic[nn[0]]\n            #         break\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool uax(T &a, const T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\nbool uin(T &a, const T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n  in >> p.first >> p.second;\n  return in;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n  out << p.first << ' ' << p.second;\n  return out;\n}\nconst int B = 300;\nint n, m, q;\nmap<pair<int, int>, pair<int, int>> k;\nvector<vector<pair<int, int>>> g;\nmap<pair<int, int>, int> ans;\nint fp(int x, int z) {\n  if (k.find(make_pair(x, z)) == k.end()) {\n    k[make_pair(x, z)] = make_pair(x, 1);\n    return x;\n  }\n  if (k[make_pair(x, z)].first == x) {\n    return x;\n  } else {\n    return k[make_pair(x, z)].first = fp(k[make_pair(x, z)].first, z);\n  }\n}\nvoid un(int x, int y, int z) {\n  x = fp(x, z);\n  y = fp(y, z);\n  if (x != y) {\n    pair<int, int> kx = k[make_pair(x, z)], ky = k[make_pair(y, z)];\n    if (kx.second < ky.second) {\n      swap(x, y);\n      swap(kx, ky);\n    }\n    k[make_pair(y, z)].first = x;\n    if (ky.second == kx.second) {\n      k[make_pair(x, z)].second++;\n    }\n  }\n}\nbool cmp(pair<int, int> a, pair<int, int> b) {\n  a = make_pair(a.second, a.first);\n  b = make_pair(b.second, b.first);\n  return a < b;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  g.resize(n);\n  int x, y, z;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y >> z;\n    x--;\n    y--;\n    z--;\n    g[x].push_back(make_pair(y, z));\n    g[y].push_back(make_pair(x, z));\n    un(x, y, z);\n  }\n  for (int i = 0; i < n; i++) {\n    sort(g[i].begin(), g[i].end(), cmp);\n  }\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> x >> y;\n    x--;\n    y--;\n    if (g[x].size() > g[y].size()) {\n      swap(x, y);\n    }\n    if (ans.find(make_pair(x, y)) != ans.end()) {\n      cout << ans[make_pair(x, y)] << \"\\n\";\n      continue;\n    }\n    int ret = 0;\n    if (g[x].size() == 0) {\n      cout << ret << \"\\n\";\n      ans[make_pair(x, y)] = ret;\n      continue;\n    }\n    if (fp(x, g[x][0].second) == fp(y, g[x][0].second)) {\n      ret++;\n    }\n    for (int j = 1; j < g[x].size(); j++) {\n      if (g[x][j].second == g[x][j - 1].second) {\n        continue;\n      }\n      if (fp(x, g[x][j].second) == fp(y, g[x][j].second)) {\n        ret++;\n      }\n    }\n    cout << ret << \"\\n\";\n    ans[make_pair(x, y)] = ret;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Solution_505B {\n    static boolean[] used;\n    static ArrayList<Node>[] graph;\n\n    static class Node {\n        int id;\n        int color;\n\n        public Node(int id, int color) {\n            this.id = id;\n            this.color = color;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String strings[] = reader.readLine().split(\" \");\n        int nodes = Integer.parseInt(strings[0]);   //\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u0433\u0440\u0430\u0444\u0430\n        int edges = Integer.parseInt(strings[1]);   // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440 \u0433\u0440\u0430\u0444\u0430\n\n        used = new boolean[nodes];\n\n        graph = new ArrayList[nodes];\n        for(int i = 0; i < nodes; i++)\n            graph[i] = new ArrayList<Node>();\n\n        // \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u0441\u043c\u0435\u0436\u043d\u043e\u0441\u0442\u0438\n        for (int i = 1; i <= edges; i++) {\n            String edge[] = reader.readLine().split(\" \");\n            int node1 = Integer.parseInt(edge[0]) - 1;\n            int node2 = Integer.parseInt(edge[1]) - 1;\n            int color = Integer.parseInt(edge[2]);\n\n            graph[node1].add(new Node(node2, color));\n            graph[node2].add(new Node(node1, color));\n        }\n\n        // \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043f\u043e \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043f\u0443\u0442\u0435\u0439 \u0432 \u0433\u0440\u0430\u0444\u0435 \u043c\u0435\u0436\u0434\u0443 \u0432\u0435\u0440\u0448\u0438\u043d\u0430\u043c\u0438\n        int requests = Integer.parseInt(reader.readLine());\n        for (int i = 0; i < requests; i++) {\n            String edge[] = reader.readLine().split(\" \");\n            int node1 = Integer.parseInt(edge[0]) - 1;\n            int node2 = Integer.parseInt(edge[1]) - 1;\n            int num = 0;\n\n            // \u0432\u044b\u0437\u043e\u0432 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u0443\u0442\u0435\u0439 - \u043f\u043e\u0438\u0441\u043a \u0432 \u0433\u043b\u0443\u0431\u0438\u043d\u0443 \u043f\u043e \u043c\u0430\u0442\u0440\u0438\u0446\u0435 \u0441\u043c\u0435\u0436\u043d\u043e\u0441\u0442\u0438\n            for (int j = 1; j <= edges; j++) {\n                used = new boolean[nodes];  // \u043e\u0431\u043d\u0443\u043b\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u043a \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d\n                if ( dfs(j, node1, node2) )\n                    num++;\n            }\n\n            System.out.println(num);\n        }\n    }\n\n    // \u041f\u043e\u0438\u0441\u043a \u0432 \u0433\u043b\u0443\u0431\u0438\u043d\u0443 (Depth-first search, DFS) \u0437\u0430\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u0432 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c:\n    // \u0444\u0438\u043a\u0441\u0438\u0440\u0443\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0432\u0435\u0440\u0448\u0438\u043d\u0443, \u043f\u043e\u043c\u0435\u0447\u0430\u0435\u043c \u0435\u0435 \u043a\u0430\u043a \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u043d\u0443\u044e,\n    // \u0438 \u043f\u043e\u043a\u0430 \u0435\u0441\u0442\u044c \u0441\u043c\u0435\u0436\u043d\u044b\u0435 \u0441 \u043d\u0435\u0439 \u043d\u0435 \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u043d\u044b\u0435 \u0432\u0435\u0440\u0448\u0438\u043d\u044b, \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0438\u0445 \u043e\u0431\u0445\u043e\u0434\u0438\u043c.\n    // \u0414\u043b\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u0432\u0435\u0440\u0448\u0438\u043d\u0430 \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u0430, \u043e\u0431\u044b\u0447\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0444\u043b\u0430\u0433\u043e\u0432.\n    public static boolean dfs(int color, int node1, int node2) { // \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 - \u0446\u0432\u0435\u0442 \u0440\u0435\u0431\u0440\u0430\n\n        if(node1 == node2) return true;\n        used[node1] = true;\n        ArrayList<Node> edges = graph[node1];\n        for(Node edge : edges){\n            // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0446\u0432\u0435\u0442 && \u043c\u0435\u0442\u043a\u0443 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043e\u0439 \u0432\u0435\u0440\u0449\u0438\u043d\u044b\n            // \u0435\u0441\u043b\u0438 \u043d\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u0430 - \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u044b\u0439 \u0432\u044b\u0437\u043e\u0432 \u043c\u0435\u0442\u043e\u0434\u0430 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438\n            // \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0431\u0430\u0437\u043e\u0432\u043e\u0439 - \u0441\u0432\u044f\u0437\u0430\u043d\u0430\u044f \u043d\u0435 \u043e\u0431\u043e\u0439\u0434\u0435\u043d\u043d\u0430\u044f \u0432\u0435\u0440\u0448\u0438\u043d\u0430\n            if(edge.color == color && !used[edge.id]){\n                if(dfs(color, edge.id, node2)) return true;\n            }\n        }\n        return false;\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "n, m = [int(i) for i in raw_input().split()]\n# n, m = 4, 5\ngraph = {}\ncolors = set()\nfor i in range(1, n + 1):\n\tgraph[i] = {}\n# data = [(1, 2, 1), (1, 2, 2), (2, 3, 1), (2, 3, 3), (2, 4, 3)]\nfor i in range(m):\n\ta, b, c = [int(i) for i in raw_input().split()]\n\t# a, b, c = data[i]\n\tcolors.add(c)\n\tif c in graph[a]:\n\t\tgraph[a][c].append(b)\n\telse:\n\t\tgraph[a][c] = [b]\n\tif c in graph[b]:\n\t\tgraph[b][c].append(a)\n\telse:\n\t\tgraph[b][c] = [a]\nq = int(raw_input())\n\ndef dfs(u, v, c):\n\tvisited, stack = set(), [u]\n\twhile stack:\n\t\tnode = stack.pop()\n\t\tif node not in visited:\n\t\t\tvisited.add(node)\n\t\t\tif c in graph[node]:\n\t\t\t\tfor neighbor in graph[node][c]:\n\t\t\t\t\tif neighbor == v:\n\t\t\t\t\t\treturn True\n\t\t\t\t\tstack.append(neighbor)\n\treturn False\n# print graph\nfor i in range(q):\n\tu, v = [int(i) for i in raw_input().split()]\n\tcount = 0\n\tfor c in colors:\n\t\tif dfs(u, v, c):\n\t\t\tcount += 1\n\tprint count\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXX = 1e2 + 10;\nint T, n, m, ans;\nvector<pair<int, int> > adj[MAXX];\nbool vis[MAXX];\nvoid dfs(int v, int c) {\n  vis[v] = 1;\n  for (auto x : adj[v])\n    if (x.second == c && !vis[x.first]) dfs(x.first, x.second);\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v, c;\n    cin >> u >> v >> c, --v, --u;\n    adj[v].push_back({u, c}), adj[u].push_back({v, c});\n  }\n  cin >> T;\n  while (T--) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--, ans = 0;\n    for (int i = 1; i <= 100; i++) {\n      fill(vis, vis + MAXX, 0);\n      dfs(v, i);\n      ans += vis[u];\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > adj[102];\nset<int> s;\nbool vis[102];\nint des;\nvoid dfs(int u, int path) {\n  if (u == des) {\n    s.insert(path);\n    return;\n  }\n  if (vis[u]) {\n    return;\n  }\n  vis[u] = true;\n  for (int i = 0; i < adj[u].size(); i++) {\n    int v = adj[u][i].first, c = adj[u][i].second;\n    if (c == path && !vis[v]) {\n      dfs(v, path);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back(make_pair(b, c));\n    adj[b].push_back(make_pair(a, c));\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    s.clear();\n    des = v;\n    for (int i = 1; i <= m; i++) {\n      memset(vis, false, sizeof(vis));\n      dfs(u, i);\n    }\n    cout << s.size() << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class KitayutaColorfulGraph505B\n{\n    public static class DisjointSet\n    {\n        private int[] id;  // id[i] is the parent of i\n\n        /**\n         * Constructor for objects of class DisjointSet (N disjoint elements to start with)\n         */\n        public DisjointSet(int N)\n        {\n            id = new int[N];\n            for (int i=0; i<N; i++)\n            {\n                id[i] = i;\n            }\n        }\n\n        private int root(int i)\n        {\n            while (i != id[i])\n            {\n                i = id[i];\n            }\n            return i;\n        }\n\n        public boolean find(int p, int q)  // Are they in the same set?\n        {\n            return root(p) == root(q);\n        }\n\n        public void union(int p, int q)\n        {\n            int i = root(p);\n            int j = root(q);\n            id[i] = j;\n        }\n    }\n    \n    public static void main(String[] args) \n    {\n        // Set up scanner\n        Scanner sc = new Scanner(System.in); \n        // System.out.println(\"Enter n\");    // Number of vertices\n        int n = sc.nextInt();\n        // System.out.println(\"Enter m\");    // Number of edges AND COLORS\n        int m = sc.nextInt();\n        \n        // IDEA:  Have an array of disjoint sets, one for each color\n        DisjointSet[] arr = new DisjointSet[m+1];  // Zero based\n        for (int i=1; i<=m; i++)\n        {\n            arr[i] = new DisjointSet(n);    // n disjoint objects in each set to start with\n        }\n        \n        // Enter all the edges\n        for (int i=0; i<m; i++)\n        {\n            // System.out.println(\"Enter a\");\n            int a = sc.nextInt();\n            // System.out.println(\"Enter b\");\n            int b = sc.nextInt();\n            // System.out.println(\"Enter c\");\n            int c = sc.nextInt();\n            \n            DisjointSet ds = arr[c];     // Get the set for that color\n            ds.union(a-1, b-1);       // Subtract since DisjointSet is zero-based\n        }\n        \n        // Now get the queries\n        // System.out.println(\"Input number of queries\");\n        int q = sc.nextInt();\n        for (int i=0; i<q; i++)\n        {\n            // System.out.println(\"Input first vertex\");\n            int u = sc.nextInt();\n            // System.out.println(\"Input second vertex\");\n            int v = sc.nextInt();\n            int thisanswer = 0;\n            for (int j=1; j<=m; j++)    // Loop over all colors\n            {\n                DisjointSet ds = arr[j];\n                if (ds.find(u-1, v-1))\n                {\n                    thisanswer++;\n                }\n            }\n            System.out.println(thisanswer);\n        }\n    }\n}\n                \n            \n            \n        \n        \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> adj[101];\nset<pair<long long int, long long int>> color[101];\nlong long int visited[101];\nlong long int x;\nvoid bfs(long long int a, long long int b, long long int c) {\n  queue<long long int> q;\n  q.push(a);\n  while (!q.empty()) {\n    long long int p = q.front();\n    q.pop();\n    if (p == b) {\n      x = 1;\n      visited[p] = 1;\n    }\n    if (visited[p]) continue;\n    visited[p] = 1;\n    for (long long int i = 0; i < adj[p].size(); i++) {\n      if (color[c].find({p, adj[p][i]}) != color[c].end()) {\n        q.push(adj[p][i]);\n      }\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int i, j, k, l, m, n, p, t, a, b, c, q;\n  cin >> n >> m;\n  set<pair<long long int, long long int>> s;\n  for (i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    if (s.find({a, b}) == s.end()) {\n      s.insert({a, b});\n      adj[a].push_back(b);\n      adj[b].push_back(a);\n    }\n    color[c].insert({a, b});\n    color[c].insert({b, a});\n  }\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    cin >> a >> b;\n    p = 0;\n    for (j = 1; j <= m; j++) {\n      x = 0;\n      bfs(a, b, j);\n      p += x;\n      memset(visited, 0, sizeof(visited));\n    }\n    cout << p << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/**\n * @author grozhd\n */\npublic class Problem2 {\n\n    static int n;\n    static int m;\n\n    static int[][] colorCC;\n\n\n    public static void main(String[] args) {\n        read();\n    }\n\n    private static void connect(int a, int b, int c) {\n        int ccNum1 = colorCC[c][a];\n        int ccNum2 = colorCC[c][b];\n        for (int i = 1; i <= n ; i++) {\n            if (colorCC[c][i] == ccNum2) {\n                colorCC[c][i] = ccNum1;\n            }\n        }\n    }\n\n    private static int connected(int a, int b) {\n        int res = 0;\n        for (int c = 1; c <= m; c++) {\n            if (colorCC[c][a] == colorCC[c][b]) {\n                res++;\n            }\n\n        }\n        return res;\n    }\n\n    private static void read() {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n            String[] s = reader.readLine().split(\" \");\n            n = Integer.parseInt(s[0]);\n            m = Integer.parseInt(s[1]);\n\n            colorCC = new int[m + 1][n + 1];\n\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= n; j++) {\n                    colorCC[i][j] = j;\n                }\n            }\n\n            // read edges\n            for (int i = 0; i < m; i++) {\n                s = reader.readLine().split(\" \");\n                int a = Integer.parseInt(s[0]);\n                int b = Integer.parseInt(s[1]);\n                int c = Integer.parseInt(s[2]);\n                connect(a, b, c);\n            }\n\n            int q = Integer.parseInt(reader.readLine());\n\n            for (int i = 0; i < q; i++) {\n                s = reader.readLine().split(\" \");\n                int a = Integer.parseInt(s[0]);\n                int b = Integer.parseInt(s[1]);\n                System.out.println(connected(a, b));\n            }\n            \n            \n\n\n        } catch (Exception e) {\n\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = list(map(int,input().split(\" \")))\nMeow =[]\nfor i in range(101):\n    Meow.append([])\n    for j in range(n+1):\n        Meow[i].append(j)\n\ndef root(N,C):\n    while(Meow[C][N]!=N):\n        Meow[C][N] = Meow[C][Meow[C][N]];\n        N=Meow[C][N]\n    return N\n\ndef union(A,B,C):\n    p = root(A,C)\n    q = root(B,C)\n    Meow[C][p]=q\n   \nfor i in range(m):\n    a,b,c = list(map(int,input().split(\" \")))\n    union(a,b,c)\n    \nq = int(input())\nfor i in range(q):\n    a,b = list(map(int,input().split(\" \")))\n    cnt=0;\n    for i in range(1,101):\n        if(root(a,i)==root(b,i)):\n            cnt+=1\n    print(cnt)\n    \n    "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\n\npublic class B {\nstatic LinkedList<Integer> [][]g;\nstatic boolean v[];\nstatic boolean col[];\nstatic int n;\n    public static void main(String[] args) throws Exception{\n        n=in();\n     int m=in();\n     v=new boolean [n+1];\n     g=new LinkedList [n+1][n+1];\n     col=new boolean[m+2];\n     for (int i=0;i<m;i++){\n         int t1=in();\n         int t2=in();\n         int c=in();\n        if ( g[t1][t2]==null)g[t1][t2]=new LinkedList<>();\n         if (g[t2][t1]==null)g[t2][t1]=new LinkedList<>();\n         g[t1][t2].add(c);\n         g[t2][t1].add(c);\n     }\nStringBuilder b=new StringBuilder();\nint q=in();\nfor (int i=0;i<q;i++){\n    b.append(dfs(in(),in(),0)+\"\\n\");\n     v=new boolean [n+1];\n     col=new boolean[m+2];\n}\nSystem.out.println(b);\n    }\n\n    private static int  dfs(int i, int j, int c) {\n    //  System.out.println(i+\" \"+j);\n        if (i==j){\n            if (col[c])return 0;\n            else{\n                col[c]=true;\n                return 1;\n            }\n            \n        }\n        if (v[i]){\n            \n            return 0;\n        }\n        int r=0;\n        v[i]=true;\n        for (int k=0;k<g[i].length;k++){\n            if (g[i][k]!=null)\n            for (int t:g[i][k])\n            if (t!=0 && (t==c || c==0)){\n                r+=dfs(k,j,t);\n            }\n        }\n        v[i]=false;\n        return r;\n    }\n\n    static BufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static int in() throws IOException{\n        if (st==null || !st.hasMoreTokens()){\n            st=new StringTokenizer(buf.readLine());\n        }\n        return Integer.parseInt(st.nextToken());\n    }\n    static long ll() throws IOException{\n        if (st==null || !st.hasMoreTokens()){\n            st=new StringTokenizer(buf.readLine());\n        }\n        return Long.parseLong(st.nextToken());\n    }\n    static String str() throws IOException{\n        if (st==null || !st.hasMoreTokens()){\n            st=new StringTokenizer(buf.readLine());\n        }\n        return (st.nextToken());\n    }\n        static double dub() throws IOException{\n            if (st==null || !st.hasMoreTokens()){\n                st=new StringTokenizer(buf.readLine());\n            }\n            return Double.parseDouble(st.nextToken());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\n public:\n  int v;\n  vector<int> neighbours, colors;\n  Node(int v) { v = v; }\n};\nbool dfs(Node **arr, int color, bool *visited, int cur, int dest) {\n  if (cur == dest) return true;\n  visited[cur] = true;\n  bool found = false;\n  for (int i = 0; i < arr[cur]->neighbours.size(); i++) {\n    if (arr[cur]->colors[i] == color && !visited[arr[cur]->neighbours[i]]) {\n      found = dfs(arr, color, visited, arr[cur]->neighbours[i], dest);\n    }\n    if (found) {\n      visited[cur] = false;\n      return true;\n    }\n  }\n  visited[cur] = false;\n  return false;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Node *arr[n + 1];\n  for (int i = 0; i <= n; i++) arr[i] = new Node(i);\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    arr[a]->neighbours.push_back(b);\n    arr[a]->colors.push_back(c);\n    arr[b]->neighbours.push_back(a);\n    arr[b]->colors.push_back(c);\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int u, v;\n    cin >> u >> v;\n    bool visited[n + 1];\n    memset(visited, 0, (n + 1) * sizeof(bool));\n    int colors[m + 1];\n    memset(colors, 0, (m + 1) * sizeof(int));\n    int num = 0;\n    for (int i = 0; i < arr[u]->neighbours.size(); i++) {\n      if (!colors[arr[u]->colors[i]]) {\n        if (dfs(arr, arr[u]->colors[i], visited, arr[u]->neighbours[i], v))\n          num++;\n        colors[arr[u]->colors[i]] = 1;\n      }\n    }\n    cout << num << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,os,io\nimport math,bisect,operator\ninf,mod = float('inf'),10**9+7\n# sys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby,accumulate\nfrom heapq import heapify,heappop,heappush\nfrom collections import deque,Counter,defaultdict\nI = lambda : int(sys.stdin.buffer.readline())\nNeo = lambda : list(map(int, sys.stdin.buffer.readline().split()))\n\nn,m = Neo()\nColor = defaultdict(set)\n\nG = defaultdict(set)    \n\nC = set()\n\ndef addEdge(a,b):\n    G[a].add(b)\n    G[b].add(a)\n    \ndef addColor(a,b,c):\n    Color[(a,b)].add(c)\n    Color[(b,a)].add(c)\n    C.add(c)\n    \nfor i in range(m):\n    a,b,c = Neo()\n    addColor(a,b,c)\n    addEdge(a,b)\n    \nvis = [False]*(n+1)\nAns = []\n    \ndef fun(node,dest,vis,grp):\n    if not grp:\n        return\n    if node == dest:\n        for i in grp:\n            Ans.append(i)\n        return\n    vis[node] = True\n    for i in G.get(node,[]):\n        if not vis[i]:\n            newvis = vis.copy()\n            z = grp.intersection(Color[node,i])\n            fun(i,dest,newvis,z)\n\nfor i in range(I()):\n    a,b = Neo()\n    vis = [False]*(n+1)\n    grp = C.copy()\n    fun(a,b,vis,grp)\n    print(len(set(Ans)))\n    Ans =[]"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n    static class Reader {\n        private BufferedReader br;\n        private StringTokenizer token;\n        protected Reader(FileReader obj) {\n            br = new BufferedReader(obj, 32768);\n            token = null;\n        }\n        protected Reader() {\n            br = new BufferedReader(new InputStreamReader(System.in), 32768);\n            token = null;\n        }\n        protected String next() {\n            while(token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (Exception e) {e.printStackTrace();}\n            } return token.nextToken();\n        }\n        protected int nextInt() {return Integer.parseInt(next());}\n        protected long nextLong() {return Long.parseLong(next());}\n        protected double nextDouble() {return Double.parseDouble(next());}\n    }\n    static class Node<T> {\n        Node parent;\n        int rank, setSize;\n        T data;\n    }\n    static class DisjointSets<T> {\n        private HashMap<T, Node> hm = new HashMap<>();\n        int numOfSets = 0;\n        private void makeSet(T data) {\n            if (isPresent(data)) return;\n            Node node = new Node();\n            node.parent = node;\n            node.rank = 0;\n            node.data = data;\n            node.setSize = 1;\n            hm.put(data, node);\n            numOfSets++;\n        }\n        private void union(T data1, T data2) {\n            if (!isPresent(data1)) makeSet(data1);\n            if (!isPresent(data2)) makeSet(data2);\n            Node parent1 = findSet(hm.get(data1)), parent2 = findSet(hm.get(data2));\n            if (parent1.data == parent2.data) return;\n            if (parent1.rank >= parent2.rank) {\n                parent1.rank = parent1.rank == parent2.rank ? parent1.rank+1 : parent1.rank;\n                parent2.parent = parent1;\n                parent1.setSize += parent2.setSize;\n            } else {\n                parent1.parent = parent2;\n                parent2.setSize += parent1.setSize;\n            }\n            numOfSets--;\n        }\n        private Node findSet(Node node) {\n            Node parent = node.parent;\n            if (parent == node) return parent;\n            node.parent = findSet(node.parent);\n            return node.parent;\n        }\n        private boolean isPresent(T data) {\n            return hm.containsKey(data);\n        }\n        private boolean inSameSet(T data1, T data2) {\n            return isPresent(data1) && isPresent(data2) && (findSet(hm.get(data1)) == findSet(hm.get(data2)));\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt(), m = in.nextInt();\n        HashMap<Integer, DisjointSets> map = new HashMap<>();\n        for (int i=0; i<m; i++) {\n            int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();\n            if (map.containsKey(c)) {\n                map.get(c).union(a, b);\n            } else {\n                DisjointSets<Integer> ds = new DisjointSets<>();\n                ds.union(a, b); map.put(c, ds);\n            }\n        }\n        int q = in.nextInt();\n        while (q-->0) {\n            int u = in.nextInt(), v = in.nextInt();\n            int ans = 0;\n            for (Map.Entry<Integer, DisjointSets> entry: map.entrySet()) {\n                if (entry.getValue().inSameSet(u, v)) ans++;\n            }\n            out.printf(\"%d\\n\", ans);\n        }\n        out.close();\n    }\n}"
        },
        {
            "language": 1,
            "solution": "#\n# Uian Sol Gorgonio <sol.uian@gmail.com>\n# Jun 12 2015\n# Mr. Kitayuta's Colorful Graph\n# http://codeforces.com/problemset/problem/505/B\n#\n# graph\n#\n\n\ndef dfs(node, wanted, color):\n    visited[node] = True\n\n    if node == wanted:\n        return True\n\n    for u, c in graph[node]:\n        if c == color and not visited[u]:\n            if dfs(u, wanted, color):\n                return True\n\n    return False\n\n\nn, m = map(int, raw_input().split())\n\ngraph = [[] for i in xrange(n + 1)]\nfor edgs in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\nn_queries = int(raw_input())\nfor query in xrange(n_queries):\n    u, v = map(int, raw_input().split())\n    \n    n_colors = 0 \n    for color in xrange(1, 101):\n        visited = [False] * (n + 1)\n        if (dfs(u, v, color)):\n            n_colors += 1\n\n    print n_colors\n"
        },
        {
            "language": 3,
            "solution": "class Graph(object):\n    def __init__(self, num_nodes):\n        self.num_nodes = num_nodes\n        self.adj_list = {}\n\n    def __add_directional_edge(self, a, b, c):\n        if a in self.adj_list:\n            if b in self.adj_list[a]:\n                if c not in self.adj_list[a][b]:\n                    self.adj_list[a][b].append(c)\n            else:\n                self.adj_list[a][b] = []\n                self.adj_list[a][b].append(c)\n        else:\n            self.adj_list[a] = {}\n            self.adj_list[a][b] = []\n            self.adj_list[a][b].append(c)\n\n    def add_edge(self, a, b, c):\n        self.__add_directional_edge(a, b, c)\n        self.__add_directional_edge(b, a, c)\n\n    def print_graph(self):\n        print(self.adj_list)\n\n\ndef tc():\n    g = readGraph()\n    #  g.print_graph()\n    for k in range(1, g.num_nodes + 1):\n        for i in range(1, g.num_nodes + 1):\n            for j in range(1, g.num_nodes + 1):\n                l1 = g.adj_list.get(i, {}).get(k, [])\n                l2 = g.adj_list.get(k, {}).get(j, [])\n                for color in l1:\n                    if color in l2:\n                        g.add_edge(i,j,color)\n    #  g.print_graph()\n    return g\n\n\ndef readGraph():\n    n, m = map(int, input().split())\n    g = Graph(n)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        g.add_edge(a,b,c)\n    return g\n\n\ndef read_query():\n    q = int(input())\n    q_list = []\n    for _ in range(q):\n        u,v = map(int, input().split())\n        q_list.append((u,v))\n    return q_list\n\n\ndef solve_query(g, q_list):\n    for u,v in q_list:\n        if u in g.adj_list:\n            if v in g.adj_list[u]:\n                print(len(g.adj_list[u][v]))\n            else:\n                print(\"0\")\n        else:\n            print(\"0\")\n\n\ndef main():\n    g = tc()\n    q_list = read_query()\n    solve_query(g, q_list)\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n *\n * @author Reza\n */\npublic class B {\n\n    static int pset[];\n    static int size[];\n    static int setsNum;\n    static int result[][];\n\n    static TreeMap<String, TreeSet<Integer>> tm;\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer strt = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(strt.nextToken());\n        int m = Integer.parseInt(strt.nextToken());\n\n        result = new int[m][n];\n        tm = new TreeMap<String, TreeSet<Integer>>();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tm.put((i) + \" \" + (j), new TreeSet<Integer>());\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            StringTokenizer stt = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(stt.nextToken());\n            int b = Integer.parseInt(stt.nextToken());\n            int c = Integer.parseInt(stt.nextToken());\n            tm.get((a - 1) + \" \" + (b - 1)).add(c - 1);\n        }\n\n        for (int i = 0; i < m; i++) {\n            pset = new int[n];\n            size = new int[n];\n            initSet();\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    if (tm.get(j + \" \" + k).contains(i)) {\n                        unionSet(j, k);\n                    }\n                }\n            }\n            result[i]=pset.clone();\n        }\n        int q=Integer.parseInt(br.readLine());\n        for (int i = 0; i < q; i++) {\n            StringTokenizer stt=new StringTokenizer(br.readLine());\n            int u=Integer.parseInt(stt.nextToken());\n            int v=Integer.parseInt(stt.nextToken());\n            int number=0;\n            for (int j = 0; j < m; j++) {\n                pset=result[j];\n                if(isSame(u-1, v-1)){\n                    number++;\n                }\n            }\n            System.out.println(number);\n        }\n\n    }\n\n    public static void initSet() {\n        setsNum = pset.length;\n        for (int i = 0; i < pset.length; i++) {\n            pset[i] = i;\n        }\n        Arrays.fill(size, 1);\n    }\n\n    public static int findSet(int i) {\n        return (pset[i] == i) ? i : (pset[i] = findSet(pset[i]));\n    }\n\n    public static void unionSet(int i, int j) {\n        if (findSet(i) != findSet(j)) {\n            pset[findSet(i)] = findSet(j);\n            setsNum--;\n        }\n    }\n\n    public static boolean isSame(int i, int j) {\n        if (findSet(i) == findSet(j)) {\n            return true;\n        }\n        return false;\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class MainF {\n\tpublic static void main(String[] args) {\n\t\tint n, m, i;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\t\n\t\t// a disjoint set for each graph of a certain color\n\t\tDisjointSet[] coloredGraphs = new DisjointSet[m];\n\t\t\n\t\tfor(i = 0; i < m; i++){\n\t\t\tint start = sc.nextInt();\n\t\t\tint end = sc.nextInt();\n\t\t\tint color = sc.nextInt();\n\t\t\tcolor--; // to make index start at 0\n\t\t\t\n\t\t\tif(coloredGraphs[color] == null){\n\t\t\t\tcoloredGraphs[color] = new DisjointSet(n);\n\t\t\t\tcoloredGraphs[color].initialize();\n\t\t\t}\n\t\t\t\n\t\t\t// add the edge to the set -- find if not equal then merge\n\t\t\tif(coloredGraphs[color].find(start-1) != coloredGraphs[color].find(end-1))\n\t\t\t\tcoloredGraphs[color].merge(start-1, end-1);\n\t\t}\n\t\t\n\t\tString output = \"\";\n\t\t\n\t\tint queries = sc.nextInt();\n\t\t\n\t\tfor(i = 0; i < queries; i++){\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\t\t\t\n\t\t\tint answer = 0, j = 0;\n\t\t\t\n\t\t\tfor(j = 0; j < m; j++){\n\t\t\t\tif(coloredGraphs[j] != null){\n\t\t\t\t\tif(coloredGraphs[j].find(u-1) == coloredGraphs[j].find(v-1))\n\t\t\t\t\t\tanswer++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\toutput += (answer + \"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(output);\n\n\t}\n}\n\nclass DisjointSet {\n\tprivate int[] parents;\n\tprivate int[] rank;\n\tboolean initialized;\n\n\tpublic DisjointSet(int size) {\n\t\tparents = new int[size];\n\t\trank = new int[size];\n\t\tinitialized = false;\n\t}\n\n\tpublic void makeSet(int element) {\n\t\tparents[element] = element;\n\t\trank[element] = 0;\n\t}\n\n\tvoid merge(int first, int second) {\n\t\tint parentX = find(first);\n\t\tint parentY = find(second);\n\n\t\tif (rank[parentX] >= rank[parentY])\n\t\t\tparents[parentY] = parentX;\n\t\telse if (rank[parentX] < rank[parentY])\n\t\t\tparents[parentX] = parentY;\n\n\t\tif (rank[parentX] == rank[parentY])\n\t\t\trank[parentY]++;\n\t}\n\n\tint find(int element) {\n\t\tif (parents[element] == element)\n\t\t\treturn element;\n\t\treturn find(parents[element]);\n\t}\n\n\tboolean hasParent(int element) {\n\t\treturn parents[element] == element ? false : true;\n\t}\n\n\tpublic void initialize() {\n\t\tint length = parents.length;\n\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tparents[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t\tinitialized = true;\n\t}\n\n}\n\nclass Edge implements Comparable<Edge> {\n\tint start, end, cost;\n\n\tpublic Edge(int start, int end, int cost) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int getCost() {\n\t\treturn this.cost;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\tif(this.cost > o.cost)\n\t\t\treturn 1;\n\t\telse if(this.cost == o.cost)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -1;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nSince neither the graph nor the number of queries is too large, for each \nquery you can simply count the number of the \"good\" colors \n(the colors that satisfies the condition) by checking if each color is \n\"good\". To do that, you can perform Depth First Search (or Breadth First Search)\nand verify whether you can reach vi from ui traversing only the edges of that \ncolor. If you prefer using Union-Find, it will also do the job.\n\"\"\"\nfrom collections import defaultdict\n\n\ndef dfs(graph, start, end, visited, color):\n    q = [start]\n    while q:\n        node = q.pop()\n        visited[node] = True\n\n        if node == end:\n            break\n\n        for v in graph[color][node]:\n            if not visited[v]:\n                q.append(v)\n\n\ndef has_path(graph, start, end, visited, color):\n    for i in range(len(visited)):\n        visited[i] = False\n\n    dfs(graph, start, end, visited, color)\n    return visited[end]\n\n\nn, m = map(int, input().split())\n    \ngraph = defaultdict(lambda: defaultdict(list))\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n\n    graph[c][a].append(b)\n    graph[c][b].append(a)\n\nvisited = [False] * n\n    \nq = int(input())\n\nfor _ in range(q):\n    u, v = map(int,input().split())\n    u -= 1\n    v -= 1\n    ans = 0\n\n    for c in graph.keys():\n        if has_path(graph, u, v, visited, c):\n            ans += 1\n\n    print(ans)\n"
        },
        {
            "language": 1,
            "solution": "def dfs(u,v, g,visited,c):\n\tif u==v:\n\t\treturn True\n\n\tvisited[u] = True\n\t\n\tfor n in g[u]:\n\t\tif c in g[u][n] and n not in visited:\n\t\t\tt = dfs(n,v,g,visited,c)\n\t\t\tif t:\n\t\t\t\treturn True\n\n\treturn False\n\n\n\ninp = raw_input().strip().split()\n\nn = int(inp[0])\nm = int(inp[1])\n\ng ={}\n\nfor i in xrange(m):\n\ta,b,c = raw_input().strip().split()\n\n\tif (int(a)) not in g:\n\t\tg[int(a)] ={}\n\n\tif int(b) not in g[int(a)]:\n\t\tg[int(a)][int(b)] = {}\n\n\tg[int(a)][int(b)][c] = True\n\n\ta,b=b,a\n\n\tif (int(a)) not in g:\n\t\tg[int(a)] ={}\n\n\tif int(b) not in g[int(a)]:\n\t\tg[int(a)][int(b)] = {}\n\n\tg[int(a)][int(b)][c] = True\n\n\nq= int(raw_input().strip())\n\nfor i in xrange(q):\n\tu,v =raw_input().strip().split()\n\tu=int(u)\n\tv=int(v)\n\t\n\tcolors= {}\n\n\tif u in g:\n\t\tfor n in g[u]:\n\t\t\tfor c in g[u][n]:\n\t\t\t\tvisited ={}\n\t\t\t\tif dfs(n,v,g,visited,c):\n\t\t\t\t\tcolors[c] = True\n\n\tprint len(colors)\n\n"
        },
        {
            "language": 1,
            "solution": "[n, m] = map(int, raw_input().split())\ndist = []\nfor x in range(n):\n    dist.append([0] * n)\n\nfor x in range(m):\n    [a, b, c] = map(int, raw_input().split())\n    dist[a-1][b-1] |= 1<<c\n    dist[b-1][a-1] |= 1<<c\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            dist[i][j] = dist[i][j] | (dist[i][k] & dist[k][j])\n            \n\ndef popcnt(n):\n    if n == 0:\n        return 0\n    return 1+popcnt(n&(n-1))\n\nq = int(raw_input())\nfor x in range(q):\n    [a, b] = map(int, raw_input().split())\n    print popcnt(dist[a-1][b-1])"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid FJ() {}\nvector<pair<int, int> > V[107];\nbool visit[107];\nbool bfs(int u, int v, int c) {\n  list<int> Q;\n  Q.push_back(u);\n  memset(visit, false, sizeof(visit));\n  visit[u] = true;\n  while (!Q.empty()) {\n    int s = Q.front();\n    Q.pop_front();\n    for (typeof((V[s]).begin()) it = (V[s].begin()); it != V[s].end(); it++) {\n      if (it->first == v && it->second == c) return true;\n      if (!visit[it->first] && it->second == c) {\n        visit[it->first] = true;\n        Q.push_back(it->first);\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  FJ();\n  int n;\n  scanf(\"%d\", &n);\n  int m;\n  scanf(\"%d\", &m);\n  vector<int> cnt;\n  map<int, int> mp;\n  for (int i = 0; i < m; i++) {\n    int u;\n    scanf(\"%d\", &u);\n    int v;\n    scanf(\"%d\", &v);\n    int c;\n    scanf(\"%d\", &c);\n    V[u].push_back(make_pair(v, c));\n    V[v].push_back(make_pair(u, c));\n    if (mp[c] == 0) cnt.push_back(c);\n    mp[c]++;\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  for (int i = 0; i < Q; i++) {\n    int u;\n    scanf(\"%d\", &u);\n    int v;\n    scanf(\"%d\", &v);\n    int R = 0;\n    for (typeof((cnt).begin()) it = (cnt.begin()); it != cnt.end(); it++)\n      if (bfs(u, v, *it)) R++;\n    printf(\"%d\\n\", R);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CF286B {\n\tprivate FastScanner in;\n\tprivate PrintWriter out;\n\n\tpublic void solve() throws IOException {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[][] graph = new int[103][103];\n\t\tfor (int i = 1; i <= m; i++){\n\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\tgraph[i][j] = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= m; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tgraph[c][getParent(c, a, graph)] = getParent(c, b, graph);\n\t\t}\n\t\tint q = in.nextInt();\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tint res = 0;\n\t\t\tfor (int j = 1; j <= m; j++){\n\t\t\t\tif (getParent(j, u, graph) == getParent(j, v, graph)){\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t}\n\n\tpublic static int getParent(int x, int y, int[][] graph){\n\t\tif (graph[x][y] != y){\n\t\t\tgraph[x][y] = getParent(x, graph[x][y], graph);\n\t\t}\n\t\treturn graph[x][y];\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew CF286B().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate class FastScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "class ufds:\n    def __init__(self):\n        self.rank = dict()\n        self.value = dict()\n\n    def union(self,a,b):\n        x,y = self.findSet(a),self.findSet(b)\n        if self.rank[x] > self.rank[y]:\n            self.value[y] = x\n        else:\n            self.value[x] = y\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n            \n    def findSet(self,x):#Path Compression\n        if x != self.value[x]:\n            self.value[x] = self.findSet(self.value[x])\n        return self.value[x]\n            \n    def sameSet(self,a,b):\n        return self.findSet(a) == self.findSet(b)\n    \n    def createKey(self,x):\n        self.rank.update({x:0})\n        self.value.update({x:x})\n    \na = list(map(int,input().split()))\nsize = a[0]\ngraph = dict()\nfor i in range(a[1]):\n    b = list(map(int,input().split()))\n    color = b[2]\n    if color not in graph.keys():\n        graph.update({color:ufds()})\n        for i in range(size):\n            graph[color].createKey(i+1)\n    graph[color].union(b[0],b[1])\nfor i in range(int(input())):\n    b = list(map(int,input().split()))\n    counter = 0\n    for j in graph.keys():\n        if graph[j].sameSet(b[0],b[1]):\n            counter+=1\n    print(counter)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long int, long long int>> adj[101];\nlong long int color[101];\nbool visited[101];\nbool bfs(long long int s, long long int e, long long int c) {\n  queue<long long int> q;\n  q.push(s);\n  while (!q.empty()) {\n    long long int d = q.front();\n    q.pop();\n    if (d == e) {\n      return true;\n    }\n    for (auto x : adj[d]) {\n      if (!visited[x.first] && x.second == c) {\n        q.push(x.first);\n        visited[x.first] = true;\n      }\n    }\n  }\n  return false;\n}\nvoid reset() {\n  for (long long int i = 1; i <= 100; i++) visited[i] = false;\n}\nvoid runcases(long long int T) {\n  long long int n, m;\n  cin >> n >> m;\n  long long int x, y, c;\n  for (long long int i = 0; i < m; i++) {\n    cin >> x >> y >> c;\n    color[c] = 1;\n    adj[x].push_back({y, c});\n    adj[y].push_back({x, c});\n  }\n  long long int q;\n  cin >> q;\n  for (long long int i = 0; i < q; i++) {\n    cin >> x >> y;\n    long long int ans = 0;\n    for (long long int j = 1; j <= m; j++) {\n      reset();\n      if (color[j]) {\n        if (bfs(x, y, j)) {\n          ans++;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int T = 1;\n  for (long long int t = 1; t <= T; t++) {\n    runcases(t);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\ngraph = [[[-1] for x in range(n + 1)] for i in range(n + 1)]\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    if graph[a][b] != [-1]:\n        graph[a][b].append(c)\n    else:\n        graph[a][b] = [c]\n\n\ndef bfs(start, end, color):\n    neighbors, visited = [start], set()\n    while neighbors:\n        current, neighbors = neighbors, []\n        for each in current:\n            for i in range(1, n + 1):\n                if (color in graph[i][each] or color in graph[each][i]) and i not in visited:\n                    visited.add(i)\n                    if i == end:\n                        return True\n                    neighbors.append(i)\n    return False\n\n\nq = int(input())\nfor _ in range(q):\n    u, v = map(int, input().split())\n    starting_colors, colors = set(), 0\n    for i in range(1, n + 1):\n        if graph[i][u] != [-1]:\n            starting_colors.update(graph[i][u])\n        elif graph[u][i] != [-1]:\n            starting_colors.update(graph[u][i])\n\n    for each_color in starting_colors:\n        if bfs(u, v, each_color):\n            colors += 1\n    print(colors)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class CodeforcesB505 {\n\tpublic static void main(String[] args){\n\t\tScanner br = new Scanner(System.in);\n\t\tint n = br.nextInt();\n\t\tint m = br.nextInt();\n\t\tDisjointSet[] ds = new DisjointSet[m];\n\t\tfor(int i = 0;i<m;i++){\n\t\t\tds[i] = new DisjointSet(n);\n\t\t}\n\t\t\n\t\tfor(int i = 0;i<m;i++){\n\t\t\tint s = br.nextInt()-1;\n\t\t\tint e = br.nextInt()-1;\n\t\t\tint c = br.nextInt()-1;\n\t\t\tds[c].union(s, e);\n\t\t}\n\t\t\n\t\tint q = br.nextInt();\n\t\tfor(int i = 0;i<q;i++){\n\t\t\tint s = br.nextInt()-1;\n\t\t\tint e = br.nextInt()-1;\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 0;j<m;j++){\n\t\t\t\tif(ds[j].find(s) == ds[j].find(e)){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static class DisjointSet{\n\t\tint[] map;\n\t\tpublic DisjointSet(int n){\n\t\t\tmap = new int[n+1];\n\t\t\tArrays.fill(map, -1);\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(map[x] < 0) return x;\n\t\t\treturn map[x] = find(map[x]);\n\t\t}\n\t\tpublic void union(int a, int b){\n\t\t\tint roota = find(a);\n\t\t\tint rootb = find(b);\n\t\t\tif(roota == rootb) return;\n\t\t\tif(map[roota] < map[rootb]){\n\t\t\t\tmap[roota] += map[rootb];\n\t\t\t\tmap[rootb] = roota;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[rootb]+=map[roota];\n\t\t\t\tmap[roota] = rootb;\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = map(int,input().split())\nadj = [[] for _ in range(n)]\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    a-=1\n    b-=1\n    adj[a].append([b,c])\n    adj[b].append([a,c])\n\ndef dfs(v,c,u,vis):\n    ans = []\n    vis[v] = True\n    if v==u:\n        return [c]\n    for i in adj[v]:\n        if vis[i[0]] or i[1]!=c:\n            continue\n        ans += dfs(i[0],c,u,vis)\n    return ans\n\nq = int(input())\n\nwhile q>0:\n    q-=1\n    a,b = map(int,input().split())\n    a-=1\n    b-=1\n    ans = []\n    for i in adj[a]:\n        vis = [False]*n\n        vis[a] = True\n        ans += dfs(i[0],i[1],b,vis)\n    print(len(set(ans)))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n        static int c,s,dest,prev;\n        static ArrayList<pair>[] arr;\n        static boolean[] vis,colour;\n\n    public static void main(String[] args) throws IOException {\n        Scanner scanner = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        //============================================//\n        //answer here:\n        int n=scanner.nextInt(), m=scanner.nextInt();\n        arr=new ArrayList[n];\n        for (int i=0; i<n; i++) arr[i]=new ArrayList<>();\n        for (int i=0; i<m; i++){\n            int u=scanner.nextInt()-1, v=scanner.nextInt()-1, cost=scanner.nextInt();\n            arr[u].add(new pair(v,cost));\n            arr[v].add(new pair(u,cost));\n        }\n        int q=scanner.nextInt();\n        while (q-->0){\n            colour=new boolean[n+9];\n           s=scanner.nextInt()-1;\n           dest=scanner.nextInt()-1;\n           for (pair u: arr[s]){\n               if (!colour[u.cost]) {\n                   colour[u.cost] = true;\n                   vis = new boolean[n];\n                   prev = u.cost;\n                   dfs(s);\n               }\n           }\n           out.println(c);\n\n           c=0;\n        }\n\n        //=============================================//\n        out.close();\n    }\n    static void dfs(int s){\n        vis[s]=true;\n        if (s==dest){\n            c++;\n            return;\n        }\n        for (pair v: arr[s]){\n            if (!vis[v.to] && v.cost==prev) {\n                dfs(v.to);\n            }\n        }\n    }\n}\n\nclass Scanner {\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream system) {\n        br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public Scanner(String file) throws Exception {\n        br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n        return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n        return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n        Thread.sleep(3000);\n    }\n\n    int[] readArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}\n\nclass pair implements Comparable<pair> {\n    int to;\n    int cost;\n\n    public pair(int to, int cost) {\n        this.to=to;\n        this.cost=cost;\n    }\n\n    public int compareTo(pair o) {\n        return 0;\n    }\n    public String toString(){\n        return this.to+\" \"+this.cost;\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "\nn, m = map(int, raw_input().split(' '))\nadj = {i:{x:[] for x in range(m)} for i in range(n)}\nfor _ in range(m):\n   i, j, k = [int(v)-1 for v in raw_input().split(' ')]\n   adj[i][k].append(j)\n   adj[j][k].append(i)\n\nseen = set()\ndef dfs(i, tar, c):\n   if i == tar:\n      return True\n   seen.add(i)\n   for j in adj[i][c]:\n      if j not in seen and dfs(j, tar, c):\n         return True\n   return False\n\nq = int(raw_input())\nfor _ in range(q):\n   i, j = [int(v)-1 for v in raw_input().split(' ')]\n   res = 0\n   for c in range(m):\n      seen = set()\n      if dfs(i, j, c):\n         res += 1\n   print res\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nvector<pair<ll, ll>> adj[100];\nvector<bool> vis(100, 0);\nbool dfs(ll u, ll v, ll col) {\n  vis[u] = 1;\n  if (u == v) return 1;\n  for (auto edge : adj[u]) {\n    if (edge.second == col && !vis[edge.first]) {\n      if (dfs(edge.first, v, col)) return 1;\n    }\n  }\n  return 0;\n}\nvoid solveCP311() {\n  ll n, m;\n  cin >> n >> m;\n  for (ll i = 0; i < m; i++) {\n    ll u, v, c;\n    cin >> u >> v >> c;\n    u--, v--, c--;\n    adj[u].push_back({v, c});\n    adj[v].push_back({u, c});\n  }\n  ll q;\n  cin >> q;\n  while (q--) {\n    ll u, v;\n    cin >> u >> v;\n    u--, v--;\n    ll ans = 0;\n    for (ll col = 0; col < 100; col++) {\n      for (ll i = 0; i < 100; i++) vis[i] = 0;\n      if (dfs(u, v, col)) ans++;\n    }\n    cout << ans << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ll t = 1;\n  while (t--) {\n    solveCP311();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def path(edges, current, end, closed):\n\tif end in current:\n\t\treturn True\n\tclosed.append(current)\n\tchilds = [n for n in edges if n not in closed and (current[0] in n or current[1] in n)]\n\tif len(childs)==0:\n\t\treturn False\n\tfor c in childs:\n\t\tif end in c:\n\t\t\treturn True\n\tfor c in childs:\n\t\tif path(edges, c, end, closed):\n\t\t\treturn True\n\n\treturn False\n\nif __name__ == '__main__':\n\tn,m = [int(x) for x in raw_input().split()]\n\tedgesByColour = {}\n\tfor i in xrange(m):\n\t\tedge = [int(x) for x in raw_input().split()]\n\t\tedgesByColour.setdefault(edge[2], []).append(edge[:2])\n\tq = int(raw_input())\n\tqueries = []\n\tfor i in xrange(q):\n\t\tqueries += [[int(x) for x in raw_input().split()]]\n\tresults = ''\n\n\tfor start,end in queries:\n\t\tres = 0\n\t\tfor colour in edgesByColour:\n\t\t\tstartNodes = [n for n in edgesByColour[colour] if start in n]\n\t\t\tif len(startNodes) > 0:\n\t\t\t\tfor n in startNodes:\n\t\t\t\t\tif path(edgesByColour[colour], n, end, []):\n\t\t\t\t\t\tres += 1\n\t\t\t\t\t\tbreak\n\t\tresults += '{}\\n'.format(res)\n\tprint results[:-1]"
        },
        {
            "language": 3,
            "solution": "def dfs(u1,v1,c):\n\tret = False\n\tused[u1-1] = True\n\tfor i,edge in enumerate(e):\n\t\tif edge[2] != c:\n\t\t\tcontinue\n\t\tt = None\n\t\tif u1 == edge[0]:\n\t\t\tt = edge[1]\n\t\telif u1 == edge[1]:\n\t\t\tt = edge[0]\n\t\tif t and not used[t-1]:\n\t\t\tif t == v1:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tret |= dfs(t,v1,c)\n\treturn ret\n\n\n\nn,m = map(int,input().split())\ne = [list(map(int,input().split())) for i in range(m)]\nused = [False for i in range(n)]\nq = int(input())\na = []\nfor i in range(q):\n\tu,v = map(int,input().split())\n\tans = 0\n\tfor c in range(1,m+1):\n\t\tif dfs(u,v,c):\n\t\t\tans += 1\n\t\tused = [False for i in range(n)]\n\ta += [ans]\nfor i in a:\n\tprint(i)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint color[105][105];\nvector<int> G[105][105];\nint id[105];\nbool vis[105];\nvoid dfs(int x, int c) {\n  vis[x] = true;\n  id[x] = c;\n  for (int i = 0; i < G[c][x].size(); i++) {\n    int nuevo = G[c][x][i];\n    if (!vis[nuevo]) {\n      dfs(nuevo, c);\n    }\n  }\n}\nint main() {\n  int n, m, a, b, c, q;\n  memset(vis, false, sizeof vis);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    --a;\n    --b;\n    --c;\n    G[c][a].push_back(b);\n    G[c][b].push_back(a);\n  }\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d%d\", &a, &b);\n    --a;\n    --b;\n    int cnt = 0;\n    for (int j = 0; j < m; j++) {\n      memset(vis, false, sizeof vis);\n      dfs(a, j);\n      if (vis[b]) ++cnt;\n    }\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class cf1 {\n    static long mod = (long)1e9 + 7;\n    static long mod1 = 998244353;\n    static FastScanner f;\n    static PrintWriter pw = new PrintWriter(System.out);\n    static Scanner S = new Scanner(System.in);\n    static long x0; static long y0;\n    static int inf = (int)(1e9) + 5;\n    static long oo = Long.MAX_VALUE;\n    static double eps = (double)1e-4;\n\n    static HashMap<Integer , ArrayList<Edge>> g;\n\n    static class Edge {\n        int node , color;\n        public Edge(int node , int color) {\n            this.node = node;\n            this.color = color;\n        }\n    }\n\n    static boolean ok , vis[];\n\n    static void dfs(int src , int des , int c) {\n        vis[src] = true;\n        if (src == des) {\n            ok = true;\n            return;\n        }\n        for (Edge e : g.get(src)) {\n            if (!vis[e.node] && e.color == c) {\n                dfs(e.node , des , c);\n            }\n        }\n    }\n\n    public static void solve() {\n        int n = f.ni(); int m = f.ni();\n        g = new HashMap<>();\n        ok = false;\n        for (int i = 1; i <= n; ++i) g.put(i , new ArrayList<Edge>());\n\n        for (int i = 1; i <= m; ++i) {\n            int u = f.ni(); int v = f.ni(); int c = f.ni();\n            g.get(u).add(new Edge(v , c));\n            g.get(v).add(new Edge(u , c));\n        }\n\n        int q = f.ni();\n        for (int i = 1; i <= q; ++i) {\n            int u = f.ni(); int v = f.ni();\n            int cnt = 0;\n            for (int j = 1; j <= m; ++j) {\n                vis = new boolean[n + 1];\n                dfs(u , v , j);\n                if (ok) ++cnt;\n                ok = false;\n            }\n            pn(cnt);\n        }\n               \n    }   \n\n    public static void main(String[] args)throws NumberFormatException , IOException {   \n        init();\n        boolean tc = false;\n        int t = tc ? f.ni() : 1;\n        while(t --> 0) solve();\n        pw.flush(); \n        pw.close();  \n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    public static void init()throws IOException{if(System.getProperty(\"ONLINE_JUDGE\")==null){f=new FastScanner(\"\");}else{f=new FastScanner(System.in);}}\n    public static class FastScanner {\n        BufferedReader br;StringTokenizer st;\n        FastScanner(InputStream stream){try{br=new BufferedReader(new InputStreamReader(stream));}catch(Exception e){e.printStackTrace();}}\n        FastScanner(String str){try{br=new BufferedReader(new FileReader(\"!a.txt\"));}catch(Exception e){e.printStackTrace();}}\n        String next(){while(st==null||!st.hasMoreTokens()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}\n        String nextLine()throws IOException{return br.readLine();}int ni(){return Integer.parseInt(next());}long nl(){return Long.parseLong(next());}double nd(){return Double.parseDouble(next());}\n    }\n    public static void pn(Object o){pw.println(o);}\n    public static void p(Object o){pw.print(o);}\n    public static void pni(Object o){pw.println(o);pw.flush();}\n    static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    static long exgcd(long a,long b){if(b==0){x0=1;y0=0;return a;}long temp=exgcd(b,a%b);long t=x0;x0=y0;y0=t-a/b*y0;return temp;}\n    static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    static long mpow(long a,long b){long res=1;while(b>0l){if((b&1)==1l)res=((res%mod)*(a%mod))%mod;b>>=1l;a=((a%mod)*(a%mod))%mod;}return res;}\n    static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    static int log2(int x){return (int)(Math.log(x)/Math.log(2));}\n    static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> res=new HashSet<Long>();for(Long i:ff)if(isPrime(i))res.add(i);return res;}\n    static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> res=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))res.add(i);return res;}\n    static int[] inpint(int n){int arr[]=new int[n+1];for(int i=1;i<=n;++i){arr[i]=f.ni();}return arr;}\n    static long[] inplong(int n){long arr[] = new long[n+1];for(int i=1;i<=n;++i){arr[i]=f.nl();}return arr;}\n    static boolean ise(int x){return ((x&1)==0);}static boolean ise(long x){return ((x&1)==0);}\n    static int gnv(char c){return Character.getNumericValue(c);}//No. of integers less than equal to i in ub\n    static int log(long x){return x==1?0:(1+log(x/2));} static int log(int x){return x==1?0:(1+log(x/2));}\n    static int upperbound(int a[],int i){int lo=0,hi=a.length-1,mid=0;int count=0;while(lo<=hi){mid=(lo+hi)/2;if(a[mid]<=i){count=mid+1;lo=mid+1;}else hi=mid-1;}return count;}\n    static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(ArrayList<Integer> a){Collections.sort(a);}//!Precompute fact in ncr()!\n    static int nextPowerOf2(int n){int count=0;if(n>0&&(n&(n-1))==0)return n;while(n!=0){n>>=1;count += 1;}return 1<<count;} \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q;\nint f[110];\nint d[110][110];\nbool used[110];\nvector<pair<int, int> > v[110];\nint getf(int x) {\n  if (x == f[x])\n    return x;\n  else\n    return f[x] = getf(f[x]);\n}\nvoid comb(int x, int y) {\n  int xroot = getf(x), yroot = getf(y);\n  f[xroot] = yroot;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  memset(used, false, sizeof(used));\n  for (int i = 0, x, y, z; i < m; i++) {\n    scanf(\"%d %d %d\", &x, &y, &z);\n    v[x].push_back(make_pair(y, z));\n    used[z] = true;\n  }\n  memset(d, 0, sizeof(d));\n  for (int c = 0; c <= m; c++)\n    if (used[c]) {\n      for (int i = 1; i <= n; i++) f[i] = i;\n      for (int i = 1; i <= n; i++)\n        for (int j = 0; j < v[i].size(); j++)\n          if (v[i][j].second == c) comb(i, v[i][j].first);\n      for (int i = 1; i <= n; i++) getf(i);\n      for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n          if (f[i] == f[j]) d[i][j]++, d[j][i]++;\n    }\n  scanf(\"%d\", &q);\n  for (int i = 0, u, v; i < q; i++) {\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", d[u][v] / 2);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nbool imam[105][105][105];\nvector<pair<int, int> > graf[105];\nint rjesenje = 0;\nbool vis[105];\nvoid dfs(int p, int k, int boja) {\n  vis[p] = true;\n  if (p == k) return;\n  for (int i = 0; i < graf[p].size(); i++)\n    if (graf[p][i].second == boja && !vis[graf[p][i].first])\n      dfs(graf[p][i].first, k, boja);\n  return;\n}\nvoid solve(int a, int b) {\n  rjesenje = 0;\n  for (int i = 1; i <= m; i++) {\n    memset(vis, false, sizeof vis);\n    dfs(a, b, i);\n    if (vis[b]) rjesenje++;\n  }\n}\nint main() {\n  int q;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    if (imam[a][b][c]) continue;\n    graf[a].push_back(make_pair(b, c));\n    graf[b].push_back(make_pair(a, c));\n    imam[a][b][c] = imam[b][a][c] = true;\n  }\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    rjesenje = 0;\n    solve(a, b);\n    printf(\"%d\\n\", rjesenje);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint i, j, k, n, m, s, t, x, y, a[110][110];\nint aaaa(int p, int c) { return a[p][c] == p ? p : a[p][c] = aaaa(a[p][c], c); }\nvoid q(int p1, int p2, int c) {\n  int x, y;\n  x = aaaa(p1, c);\n  y = aaaa(p2, c);\n  if (x != y) {\n    a[x < y ? a[p2][c] : a[p1][c]][c] = x < y ? x : y;\n  }\n}\nint main() {\n  s = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      a[i][j] = i;\n    }\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &x, &y, &t);\n    q(x, y, t);\n  }\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      a[i][j] = aaaa(a[i][j], j);\n    }\n  }\n  scanf(\"%d\", &t);\n  while (t--) {\n    s = 0;\n    scanf(\"%d%d\", &x, &y);\n    for (i = 1; i <= m; i++) {\n      if (a[x][i] == a[y][i]) s++;\n    }\n    printf(\"%d\\n\", s);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n\npublic class Main_Round286Div2_B {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\n\t\tUnionFind[] uf = new UnionFind[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tuf[i] = new UnionFind(n);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\t\n\t\t\tuf[c - 1].union(a - 1, b - 1);\n\t\t}\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint ret = 0;\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (uf[j].same(u - 1, v - 1)) {\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ret);\n\t\t}\n\n\t\tsc.close();\n\t}\n\n\tprivate static class UnionFind {\n\t\tint[] parent;\n\n\t\tUnionFind(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint find(int x) {\n\t\t\tif (parent[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn parent[x] = find(parent[x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tvoid union(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x != y) {\n\t\t\t\tparent[x] = y;\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t\t// \u7570\u306a\u308b\u96c6\u5408\u306e\u6570\n\t\t@SuppressWarnings(\"unused\")\n\t\tint count() {\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tif (find(i) == i) {\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.lang.reflect.Array;\nimport java.util.Scanner;\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\npublic class main implements Runnable {\n\n    static ArrayList<pair> adj[];\n\n    static void Check2(int n) {\n        adj = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            adj[i] = new ArrayList<>();\n        }\n\n    }\n    /*\n    static void add(int i, int j) {\n        adj[i].add(j);\n        adj[j].add(i);\n    }\n*/\n\n\n    public static void main(String[] args) {\n        new Thread(null, new main(), \"Check2\", 1 << 26).start();// to increse stack size in java\n    }\n    static long mod = (long) (1e9 + 7);\n    public void run() {\n                                /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n        //Scanner in=new Scanner(System.in);\n\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n=in.nextInt();\n        int m=in.nextInt();\n        int a[][][]=new int[n+1][n+1][m+1];\n        for(int i=0;i<m;i++){\n\n            int d=in.nextInt();\n            int b=in.nextInt();\n            int c=in.nextInt();\n            a[d][b][c]=1;\n            a[b][d][c]=1;\n        }\n        HashSet <Integer> set=new HashSet<>();\n        int v[][]=new int[n+1][n+1];\n        ArrayList <Integer> list=new ArrayList<>();\n        int v2[][][]=new int[n+1][n+1][m+1];\n        for (int c=1;c<=m;c++) {\n            for (int i = 1; i <= n; i++) {\n                set.clear();\n                list.clear();\n                set.add(i);\n                list.add(i);\n                dfs(i,set,a,c,n,list);\n\n                for(int ie=0;ie<list.size();ie++){\n\n                    for(int j=0;j<list.size();j++){\n\n                        if(v2[list.get(ie)][list.get(j)][c]==0) {\n                            v[list.get(ie)][list.get(j)]++;\n                            v2[list.get(ie)][list.get(j)][c]=1;\n                        }\n                    }\n\n                }\n            }\n\n\n        }\n        int q=in.nextInt();\n        while (q-->0){\n            int u=in.nextInt();\n            int v3=in.nextInt();\n            w.println(v[u][v3]);\n        }\n\n\n        w.close();\n    }\n\n    static void dfs(int i,HashSet <Integer> set,int a[][][],int color,int n,ArrayList <Integer> list){\n\n        for(int j=1;j<=n;j++){\n            if(a[i][j][color]==1&&!set.contains(j)){\n                set.add(j);\n                list.add(j);\n                dfs(j,set,a,color,n,list);\n            }\n        }\n\n    }\n    static class pair {\n            int y,color;\n            pair(int a,int b){\n                y=a;\n                color=b;\n            }\n    }\n\n    static long power(long x,long y){\n        if(y==0)return 1%mod;\n        if(y==1)return x%mod;\n\n\n        long res=1;\n        x=x%mod;\n        while(y>0){\n\n\n            if((y%2)!=0){\n                res=(res*x)%mod;\n            }\n\n\n            y=y/2;\n            x=(x*x)%mod;\n        }\n\n\n        return res;\n\n\n\n    }\n\n\n    static  int gcd(int a,int b){\n\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n\n    static  void sev(int a[],int n){\n\n        for(int i=2;i<=n;i++)a[i]=i;\n        for(int i=2;i<=n;i++){\n\n            if(a[i]!=0){\n                for(int j=2*i;j<=n;){\n\n                    a[j]=0;\n                    j=j+i;\n                }\n            }\n\n        }\n\n    }\n\n\n\n    static class node{\n\n        int y;\n        int val;\n\n        node(int a,int b){\n\n            y=a;\n            val=b;\n\n        }\n\n\n    }\n\n    static class InputReader\n    {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt()\n        {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do\n            {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n\n\n\n\n\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\npublic class B505 \n{\n    public static boolean dfs(int u,int v,Map<Integer,ArrayList<Integer>> adj,int n)\n    {\n        boolean visit[]=new boolean[n+1];\n        visit[u]=true;\n        Stack st=new Stack();\n        st.push(u);\n        while(st.size()!=0)\n        {\n            Integer a=(Integer)st.pop();\n            for(int i:adj.get(a))\n            {\n                if(!visit[i])\n                {\n                    visit[i]=true;\n                    st.push(i);\n                }\n            }\n        }\n        return visit[v];\n    }\n    public static void main(String args[])throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String s[]=br.readLine().trim().split(\" \");\n        int n=Integer.parseInt(s[0]);\n        int m=Integer.parseInt(s[1]);\n        Map<Integer,Map<Integer,ArrayList<Integer>>> adj=new HashMap<>();\n        for(int i=1;i<=m;i++)\n        {\n            adj.put(i,new HashMap<>());\n        }\n        for(int i=1;i<=m;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                adj.get(i).put(j,new ArrayList<>());\n            }\n        }\n        for(int i=1;i<=m;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            int x=Integer.parseInt(s[0]);\n            int y=Integer.parseInt(s[1]);\n            int c=Integer.parseInt(s[2]);\n            adj.get(c).get(x).add(y);\n            adj.get(c).get(y).add(x);\n        }\n        int q=Integer.parseInt(br.readLine());\n        for(int z=1;z<=q;z++)\n        {\n            s=br.readLine().trim().split(\" \");\n            int beg=Integer.parseInt(s[0]);\n            int end=Integer.parseInt(s[1]);\n            int tot=0;\n            for(int i=1;i<=m;i++)\n            {\n                boolean res=dfs(beg,end,adj.get(i),n);\n                if(res==true)\n                    tot++;\n            }\n            System.out.println(tot);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000 + 10;\nvector<int> a[N][N];\nbool mark[N][N] = {false};\nint rang[N][N] = {0};\nvoid dfs(int c, int v, int model) {\n  mark[c][v] = true;\n  rang[c][v] = model;\n  for (int i = 0; i < a[c][v].size(); i++) {\n    if (!mark[c][a[c][v][i]]) dfs(c, a[c][v][i], model);\n  }\n}\nvector<int> ra;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, temp, m;\n  cin >> n >> m;\n  int u, v, c;\n  for (int i = 0; i < m; i++) {\n    cin >> u >> v >> c;\n    ra.push_back(c);\n    a[c][u].push_back(v);\n    a[c][v].push_back(u);\n  }\n  sort(ra.begin(), ra.end());\n  ra.resize(unique(ra.begin(), ra.end()) - ra.begin());\n  int ans = 0;\n  for (int i = 0; i < ra.size(); i++) {\n    int k = 1;\n    for (int j = 1; j <= n; j++) {\n      if (!mark[ra[i]][j]) {\n        dfs(ra[i], j, k++);\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> u >> v;\n    int ans = 0;\n    for (int j = 0; j < ra.size(); j++) {\n      if (rang[ra[j]][u] == rang[ra[j]][v]) ans++;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math,sys\n#from itertools import permutations, combinations;import heapq,random;\nfrom collections import defaultdict,deque\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\ndef I():return (int(sys.stdin.readline()))\ndef In():return(map(int,sys.stdin.readline().split()))\ndef Sn():return sys.stdin.readline().strip()\n#sys.setrecursionlimit(1500)\ndef dict(a):\n    d={} \n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n    return d\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return -1\ndef dfs(gp,st,end,v,x):\n    q=deque([st])\n    while q:\n        node=q.pop()\n        v[node]=1\n        for i in gp[node]:\n            if (not v[i[0]]) and (i[1]==x):\n                q.appendleft(i[0])\n    return v[end]\ndef main():\n    try:\n        n,m=In()\n        gp=defaultdict(list)\n        d=defaultdict(set)\n        for x in range(m):\n            a,b,c=In()\n            gp[a].append((b,c))\n            gp[b].append((a,c))\n            d[a].add(c)\n            d[b].add(c)\n        for i in range(I()):\n            st,end=In()\n            cnt=0\n            for x in d[st]:\n                v=[0]*(n+1)\n                if dfs(gp,st,end,v,x):\n                    cnt+=1\n            print(cnt)\n\n    except:\n        pass\n        \nM = 998244353\nP = 1000000007\n \nif __name__ == '__main__':\n    # for _ in range(I()):main()\n    for _ in range(1):main()\n#        *******************    All The Best    *******************   #"
        },
        {
            "language": 3,
            "solution": "def dfs(p, f, gr, used):\n\tif p == f:\n\t\treturn 1\n\tif used[p]:\n\t\treturn 0\n\tused[p] = 1\n\tfor v in gr[p]:\n\t\tif dfs(v, f, gr, used):\n\t\t\treturn 1\n\treturn 0\n\ndef check(gr, u, v):\n\tused = [0] * len(gr)\n\treturn dfs(u, v, gr, used)\n\nn, m = (int(x) for x in input().split())\ncgr = [[[] for j in range(n)] for _ in range(m)]\nfor i in range(m):\n\ta, b, c = (int(x) for x in input().split())\n\tc -= 1\n\ta -= 1\n\tb -= 1\n\tcgr[c][a].append(b)\n\tcgr[c][b].append(a)\nq = int(input())\nfor i in range(q):\n\tu, v = (int(x) for x in input().split())\n\tans = 0\n\tfor gr in cgr:\n\t\tans += check(gr, u - 1, v - 1)\n\tprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\nusing namespace std;\nconst long long N = 1e6 + 5;\nvoid pairsort(long long a[], long long b[], long long n) {\n  pair<long long, long long> pairt[n];\n  for (long long i = 0; i < n; i++) {\n    pairt[i].first = a[i];\n    pairt[i].second = b[i];\n  }\n  sort(pairt, pairt + n);\n  for (long long i = 0; i < n; i++) {\n    a[i] = pairt[i].first;\n    b[i] = pairt[i].second;\n  }\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long isPrime(long long n) {\n  if (n < 2) return 0;\n  if (n < 4) return 1;\n  if (n % 2 == 0 or n % 3 == 0) return 0;\n  for (long long i = 5; i * i <= n; i += 6)\n    if (n % i == 0 or n % (i + 2) == 0) return 0;\n  return 1;\n}\nlong long C(long long n, long long r) {\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i <= r; i++) {\n    ans *= n - r + i;\n    ans /= i;\n  }\n  return ans;\n}\nlong long mod = 1e9 + 7;\nlong long modexpo(long long x, long long p) {\n  long long res = 1;\n  x = x % mod;\n  while (p) {\n    if (p % 2) res = res * x;\n    p >>= 1;\n    x = x * x % mod;\n    res %= mod;\n  }\n  return res;\n}\nlong long n, m, x, y, c, vis[105][105], cnt, q, ans;\nvector<long long> v[105][105];\nvoid dfs(long long x, long long y) {\n  vis[x][y] = cnt;\n  for (auto &i : v[x][y])\n    if (!vis[i][y]) dfs(i, y);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  for (long long i = 1; i <= m; i++)\n    cin >> x >> y >> c, v[x][c].push_back(y), v[y][c].push_back(x);\n  for (long long i = 1; i <= n; i++)\n    for (long long j = 1; j <= m; j++)\n      if (!vis[i][j]) cnt++, dfs(i, j);\n  cin >> q;\n  while (q--) {\n    cin >> x >> y, ans = 0;\n    for (long long i = 1; i <= m; i++) ans += (vis[x][i] == vis[y][i]);\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class B505 {\n    public static void main(String args[])\n    {\n        Scanner scan = new Scanner(System.in);\n        int nodes = scan.nextInt();\n        int edges = scan.nextInt();\n\n        ArrayList<ArrayList<Edge>> aList = new ArrayList<>();\n\n        for(int i = 0; i < nodes; i++)\n            aList.add(new ArrayList<Edge>());\n\n        for(int i = 0; i < edges; i++)\n        {\n            int from = scan.nextInt();\n            int to = scan.nextInt();\n            int color = scan.nextInt();\n            aList.get(from - 1).add(new Edge(to, color));\n            aList.get(to - 1).add(new Edge(from, color));\n        }\n        \n        int numQueries = scan.nextInt();\n        for(int i = 0; i < numQueries; i++)\n        {\n            int source = scan.nextInt();\n            int dest = scan.nextInt();\n            int count = 0;\n            for(int j = 1; j <= edges; j++)\n                if(bfs(source, dest, j, aList))\n                    count++;\n            System.out.println(count);\n        }\n    }\n\n    static boolean bfs(int source, int dest, int color, ArrayList<ArrayList<Edge>> aList)\n    {\n        boolean visited[] = new boolean[aList.size()];\n        Queue<Integer> q = new LinkedList<>();\n        q.offer(source);\n        while(!q.isEmpty())\n        {\n            int current = q.poll();\n            if(!visited[current - 1])\n            {\n                visited[current - 1] = true;\n                if(current == dest)\n                    return true;\n                \n                ArrayList<Edge> list = aList.get(current - 1);\n                for(Edge e : list)\n                    if(e.color == color)\n                        q.offer(e.toId);\n            }\n        }\n        return false;\n    }\n}\n\n\tclass Edge {\n\t    int toId;\n\t    int color;\n\n\t    Edge(int toId, int color)\n        {\n            this.toId = toId;\n\t\t    this.color = color;\n\t    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (long long)1e9 + 7;\nclass DisjointSet {\n public:\n  vector<long long> rank, p;\n  DisjointSet() {}\n  DisjointSet(long long size) {\n    rank.resize(size, 0);\n    p.resize(size, 0);\n    for (long long i = 0; i < size; i++) makeSet(i);\n  }\n  void makeSet(long long x) {\n    p[x] = x;\n    rank[x] = 0;\n  }\n  bool same(long long x, long long y) { return findSet(x) == findSet(y); }\n  void unite(long long x, long long y) { link(findSet(x), findSet(y)); }\n  void link(long long x, long long y) {\n    if (rank[x] > rank[y]) {\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if (rank[x] == rank[y]) {\n        rank[y]++;\n      }\n    }\n  }\n  long long findSet(long long x) {\n    if (x != p[x]) {\n      p[x] = findSet(p[x]);\n    }\n    return p[x];\n  }\n};\nsigned main() {\n  long long n, m;\n  cin >> n >> m;\n  DisjointSet ds[m];\n  for (long long i = 0; i < m; i++) ds[i] = DisjointSet(n);\n  for (long long i = 0; i < m; i++) {\n    long long u, v, c;\n    cin >> u >> v >> c;\n    u--;\n    v--;\n    c--;\n    if (ds[c].same(u, v)) continue;\n    ds[c].unite(u, v);\n  }\n  long long q;\n  cin >> q;\n  for (long long i = 0; i < q; i++) {\n    long long u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    long long ans = 0;\n    for (long long j = 0; j < m; j++) {\n      if (ds[j].same(u, v)) ans++;\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 110;\nint n, m;\nvector<pair<int, int> > adj[MAX_N];\nbool vis[MAX_N];\nvoid dfs(int u, int c) {\n  vis[u] = 1;\n  for (pair<int, int> v : adj[u])\n    if (!vis[v.first] && v.second == c) {\n      dfs(v.first, c);\n    }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    int c;\n    cin >> c;\n    c--;\n    u--;\n    v--;\n    adj[u].push_back(make_pair(v, c));\n    adj[v].push_back(make_pair(u, c));\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    int cnt = 0;\n    for (int i = 0; i < m; i++) {\n      for (int i = 0; i < n; i++) vis[i] = 0;\n      dfs(u, i);\n      if (vis[v]) cnt++;\n    }\n    cout << cnt << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\tprivate BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') {\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) throws Exception {\n\t\tnew Thread(null, new Solution(), \"Main\", 1 << 27).start();\n\t}\n\tpublic static void initialize(int ec,int a[][],int n,int size[][])\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ta[ec][i]=i;\n\t\t\tsize[ec][i]=1;\n\t\t}\n\t}\n\tpublic static int root(int ec,int a[][],int i)\n\t{\n\t\twhile(a[ec][i]!=i)\n\t\t{\n\t\t\ta[ec][i]=a[ec][a[ec][i]];\n\t\t\ti=a[ec][i];\n\t\t}\n\t\treturn i;\n\t}\n\tpublic static boolean find(int ec,int A,int B,int a[][])\n\t{\n\t\tif(root(ec,a,A)==root(ec,a,B))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpublic static void weightedunion(int ec,int a[][],int A,int B,int size[][])\n\t{\n\t\tint root_A=root(ec, a, A);\n\t\tint root_B=root(ec, a, B);\n\t\tif(size[ec][root_A]<size[ec][root_B])\n\t\t{\n\t\t\ta[ec][root_A]=a[ec][root_B];\n\t\t\tsize[ec][root_B]+=size[ec][root_A];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[ec][root_B]=a[ec][root_A];\n\t\t\tsize[ec][root_A]+=size[ec][root_B];\n\t\t}\n\t}\n\tpublic void run() {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tint a[][]=new int[m+1][n+1];\n\t\tint size[][]=new int[m+1][n+1];\n\t\tboolean available[]=new boolean[m+1];\n\t\tArrays.fill(available, true);\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x=in.nextInt();\n\t\t\tint y=in.nextInt();\n\t\t\tint z=in.nextInt();\n\t\t\tif(available[z])\n\t\t\t\tinitialize(z, a, n, size);\n\t\t\tavailable[z]=false;\n\t\t\tweightedunion(z, a, x, y, size);\n\t\t}\n\t\tint q=in.nextInt();\n\t\twhile(q-->0)\n\t\t{\n\t\t\tint count=0;\n\t\t\tint x=in.nextInt();\n\t\t\tint y=in.nextInt();\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tif(!available[i] && find(i, x, y, a))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tw.println(count);\n\t\t}\n\t\tw.flush();\n\t\tw.close();\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nimport string\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef get_int():\n    return int(input())\n\n\ndef get_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef get_int_grid(n):\n    return [get_ints() for _ in range(n)]\n\n\ndef get_str():\n    return input().split(' ')\n\n\ndef yes_no(b):\n    if b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n    \"\"\"\n    Performs binary search\n    ----------\n    Parameters\n    ----------\n    :param good: Function used to perform the binary search\n    :param left: Starting value of left limit\n    :param right: Starting value of the right limit\n    :param delta: Margin of error, defaults value of 1 for integer binary search\n    :param right_true: Boolean, for whether the right limit is the true invariant\n    :return: Returns the most extremal value interval [left, right] which is good function evaluates to True,\n            alternatively returns False if no such value found\n    \"\"\"\n\n    limits = [left, right]\n    while limits[1] - limits[0] > delta:\n        if delta == 1:\n            mid = sum(limits) // 2\n        else:\n            mid = sum(limits) / 2\n        if good(mid):\n            limits[int(right_true)] = mid\n        else:\n            limits[int(~right_true)] = mid\n    if good(limits[int(right_true)]):\n        return limits[int(right_true)]\n    else:\n        return False\n\n\ndef prefix_sums(a, drop_zero=False):\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    if drop_zero:\n        return p[1:]\n    else:\n        return p\n\n\ndef prefix_mins(a, drop_zero=False):\n    p = [float('inf')]\n    for x in a:\n        p.append(min(p[-1], x))\n    if drop_zero:\n        return p[1:]\n    else:\n        return p\n\n\nclass DSU:\n\n    # Disjoint Set Union (Union-Find) Data Structure\n    def __init__(self, nodes):\n        # Parents\n        self.p = [i for i in range(nodes)]\n        # Ranks\n        self.r = [0 for i in range(nodes)]\n        # Sizes\n        self.s = [1 for i in range(nodes)]\n\n    def get(self, u):\n        # Recursive Returns the identifier of the set that contains u, includes path compression\n        if u != self.p[u]:\n            self.p[u] = self.get(self.p[u])\n        return self.p[u]\n\n    def union(self, u, v):\n        # Unites the sets with identifiers u and v\n        u = self.get(u)\n        v = self.get(v)\n        if u != v:\n            if self.r[u] > self.r[v]:\n                u, v = v, u\n            self.p[u] = v\n            if self.r[u] == self.r[v]:\n                self.r[v] += 1\n            self.s[v] += self.s[u]\n\n\ndef solve_b():\n    n, m = get_ints()\n    dsus = [DSU(n) for _ in range(m)]\n    for e in range(m):\n        a, b, c = get_ints()\n        dsus[c - 1].union(a - 1, b - 1)\n\n    def respond(u, v):\n        S = 0\n        for color in range(m):\n            if dsus[color].get(u - 1) == dsus[color].get(v - 1):\n                S += 1\n        return S\n\n    q = get_int()\n\n    for query in range(q):\n        u, v = get_ints()\n        print(respond(u, v))\n\n    return\n\n\nsolve_b()\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\ngraph = [[] for _ in range(105)]\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append([b,c])\n    graph[b].append([a,c])\n\n\ndef dfs(source, destination, colour):\n    if source == destination:\n        return True\n    visited[source] = True\n    for node in graph[source]:\n        if node[1] == colour and visited[node[0]] is False:\n            if dfs(node[0], destination, colour):\n                return True\n    return False\n\nfor i in range(int(input())):\n    ans = 0\n    f, y = map(int ,input().split())\n    for colour in range(1, 101):\n        visited = [False]*(n+1)\n        if dfs(f, y, colour):\n            ans += 1\n    print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputstream = System.in;\n        OutputStream outputstream = System.out;\n        InputReader in = new InputReader(inputstream);\n        PrintWriter out = new PrintWriter(outputstream);\n        TaskB solver = new TaskB();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    private boolean graph[][][] = new boolean[108][108][108];\n    private boolean visited[];\n\n    public void solve(InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        for (int i = 0; i < m; i++) {\n            int from = in.nextInt();\n            int to = in.nextInt();\n            int color = in.nextInt();\n            graph[from][to][color] = true;\n            graph[to][from][color] = true;\n        }\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int counter = 0;\n            int u = in.nextInt();\n            int v = in.nextInt();\n            for (int j = 1; j <= 100; j++) {\n                visited = new boolean[108];\n                if (dfs(u, v, j)) {\n                    counter++;\n                }\n            }\n            out.println(counter);\n        }\n    }\n\n    private boolean dfs(int u, int v, int color) {\n        visited[u] = true;\n        if (u == v) {\n            return true;\n        }\n        boolean result = false;\n        for (int i = 1; i <= 100; i++) {\n            if (graph[u][i][color] && !visited[i]) {\n                result |= dfs(i, v, color);\n            }\n        }\n        return result;\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n                \ndef shortest_dist_node(dist_so_far):\n    min_k = 99999\n    node = 0\n    for k, v in dist_so_far.iteritems():\n        if min_k > v:\n            node = k\n            min_k = v\n    return node\n\ndef dijkstra(G, v, color, colors):\n    #print 'Color',color\n    dist_so_far = {}\n    dist_so_far[v] = 0\n    final_dist = {}\n    while len(final_dist) < len(G) - 1:\n        w = shortest_dist_node(dist_so_far)\n        if w == 0:\n            #print 'final', final_dist\n            return final_dist \n        #print 'Next node', w\n        # lock it down! \n        final_dist[w] = dist_so_far[w]\n        del dist_so_far[w]\n        for x in G[w]:\n            if color not in colors[(w,x)]:\n                continue\n            #print ' Other', x, ' Color',colors[(w,x)]\n            if x not in final_dist:\n                if x not in dist_so_far:\n                    dist_so_far[x] = final_dist[w] + 1 #G[w][x]\n                elif final_dist[w] + 1 < dist_so_far[x]: #G[w][x] < dist_so_far[x]:\n                    dist_so_far[x] = final_dist[w] + 1 #G[w][x]\n    #print 'final', final_dist\n    return final_dist\n\ndef main():\n    n, m = map(int, raw_input().split())\n    colors = {}\n    adjacency = [ [] for _ in xrange(n+1)]\n\n    for _ in xrange(m):\n        start, end, color = map(int, raw_input().split())\n        if (start, end) in colors:\n            colors[(start, end)].append(color)\n            colors[(end, start)].append(color)\n        else:\n            colors[(start, end)] = [color]\n            colors[(end, start)] = [color]\n            adjacency[start].append(end)\n            adjacency[end].append(start)\n\n    #print adjacency\n    q = int(raw_input())\n    for _ in xrange(q):\n        start, end = map(int, raw_input().split())\n        cont = 0\n        colors_visited = []\n        for node in adjacency[start]:\n            for color in colors[(start, node)]:\n                if color in colors_visited:\n                    continue\n                dists = dijkstra(adjacency, start, color, colors)\n                if end in dists:\n                    cont += 1\n                    colors_visited.append(color)\n        print cont\n        \n\n\n    pass\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Graph {\n  \n  public static void main(String[] args) {\n    int n = nextInt();\n    int m = nextInt();\n        \n    int parent[][] = new int[n+1][m+1];\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= m; j++) {\n        parent[i][j]=i;\n      }\n    }\n    \n    for (int i = 0; i < m; i++) {\n      //edges\n      int from = nextInt();\n      int to = nextInt();\n      \n      int color = nextInt();\n\n      while (from != parent[from][color]) {\n        from = parent[from][color];\n      }\n      while (to != parent[to][color]) {\n        to = parent[to][color];\n      }\n      \n      \n      int min = Math.min(parent[from][color], parent[to][color]);\n      parent[from][color] = min;\n      parent[to][color] = min;\n      \n    }\n    \n    int q = nextInt();\n    for (int i = 0; i < q; i++) {\n      //queries\n      int from = nextInt();\n      int to = nextInt();\n      int count = 0;\n      for (int j=0; j <= m ;j++) {\n        \n        int parent1 = parent[from][j];\n        while (parent1 != parent[parent1][j]) {\n          parent1 = parent[parent1][j];\n        }\n        \n        int parent2 = parent[to][j];\n        while (parent2 != parent[parent2][j]) {\n          parent2 = parent[parent2][j];\n        }\n        \n        if (parent1 == parent2) {\n          count++;\n        }\n        \n      }\n      System.out.println(count);\n      \n    }\n    \n  }\n  \n  \n  \n  \n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    static {\n        reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n        tokenizer = null;\n    }\n\n    static String nextLine(){\n        try {\n            return reader.readLine();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n\n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.lang.*;\n\npublic class Main {\n    final static String fileName = \"\";\n    final static boolean useFiles = false;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputStream inputStream;\n        OutputStream outputStream;\n        if (useFiles) {\n            inputStream = new FileInputStream(fileName + \".in\");\n            outputStream = new FileOutputStream(fileName + \".out\");\n        } else {\n            inputStream = System.in;\n            outputStream = System.out;\n        }\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task(in, out);\n        Debug.out = out;\n        solver.solve();\n        out.close();\n    }\n}\nclass Dsu {\n    private int n;\n    int[] size, parent;\n\n    Dsu(int n) {\n        this.n = n;\n        size = new int[n];\n        Arrays.fill(size, 1);\n        parent = new int[n];\n        for (int i = 0; i < n; i++)\n            parent[i] = i;\n    }\n\n    int findSet(int x) {\n        if (parent[x] == x)\n            return x;\n        return parent[x] = findSet(parent[x]);\n    }\n\n    void union(int x, int y) {\n        if (size[x] > size[y]) {\n            int t = x;\n            x = y;\n            y = t;\n        }\n        size[y] += size[x];\n        parent[x] = y;\n    }\n\n    void normalize() {\n        for (int i = 0; i < n; i++)\n            findSet(i);\n    }\n\n    @Override\n    public String toString(){\n        normalize();\n        return Arrays.toString(parent);\n    }\n}\nclass Task {\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt();\n        Dsu[] d = new Dsu[m];\n        for (int i = 0; i < m; i++)\n            d[i] = new Dsu(n);\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt() - 1;\n            d[c].union(d[c].findSet(a), d[c].findSet(b));\n        }\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            int a = in.nextInt() - 1, b = in.nextInt() - 1;\n            int result = 0;\n            for (int c = 0; c < m; c++) {\n                if (d[c].findSet(a) == d[c].findSet(b))\n                    result++;\n            }\n            out.println(result);\n        }\n    }\n\n    private InputReader in;\n    private PrintWriter out;\n\n    Task(InputReader in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n    }\n}\n\nclass Debug {\n    public static PrintWriter out;\n\n    public static void printObjects(Object... objects) {\n        out.println(Arrays.deepToString(objects));\n        out.flush();\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public double nextDouble(){\n        return Double.parseDouble(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong(){\n        return Long.parseLong(next());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.LinkedList;\n\npublic class Main2 {\n\n    public static class edge {\n        int from;\n        int to;\n        int c;\n\n        public edge(int from, int to, int c) {\n            this.from = from;\n            this.to = to;\n            this.c = c;\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        // BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        // PrintWriter out = new PrintWriter(new BufferedWriter(new\n        // FileWriter(\"output.txt\")));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().split(\" \");\n\n        int n = Integer.parseInt(in[0]);\n        int m = Integer.parseInt(in[1]);\n\n        HashSet<Integer> colour = new HashSet<Integer>();\n\n        LinkedList<edge> e = new LinkedList();\n        for (int i = 0; i < m; i++) {\n            in = br.readLine().split(\" \");\n            colour.add(Integer.parseInt(in[2]));\n            edge temp = new edge(Integer.parseInt(in[0])-1,\n                    Integer.parseInt(in[1])-1, Integer.parseInt(in[2]));\n            e.add(temp);\n        }\n        in = br.readLine().split(\" \");\n        int q = Integer.parseInt(in[0]);\n        int[][]query = new int[q][2];\n        for(int i = 0;i<q;i++){\n            in = br.readLine().split(\" \");\n            query[i][0] = Integer.parseInt(in[0])-1;\n            query[i][1] = Integer.parseInt(in[1])-1;\n        }\n        for (int i = 0; i < q; i++) {\n            int ans = 0;\n\n            for (int c : colour) {\n                LinkedList<Integer>[]adj = new LinkedList[n];\n                for(int j = 0;j<n;j++)\n                {\n                    adj[j] = new LinkedList();\n                }\n                for(edge k:e){\n                    if(k.c==c){\n                        adj[k.from].add(k.to);\n                        adj[k.to].add(k.from);\n                    }\n                }\n                boolean[]visited = new boolean[n];\n                if(dfs(query[i][0],query[i][1],visited,adj)){\n                    ans++;\n                }\n            }\n            System.out.println(ans);\n\n        }\n\n    }\n\n    private static boolean dfs(int i, int j, boolean[] visited,\n            LinkedList<Integer>[] adj) {\n        if(i==j)\n            return true;\n        visited[i] = true;\n        boolean ans = false;\n        for(int k = 0;k<adj[i].size();k++){\n            if(!visited[adj[i].get(k)]){\n                 ans = ans | dfs(adj[i].get(k),j,visited,adj);\n            }\n        }\n        return ans;\n    }\n\n}\n"
        },
        {
            "language": 1,
            "solution": "nvertices, nedges = map(int,raw_input().split())\nmatrix = [[[] for j in xrange(nvertices+1)] for x in xrange(nvertices+1)]\nvisitados = []\n\ndef visita(r, t,cor):\n\tif r == t:\n\t\tif cor not in colors: colors.append(cor)\n\tif r in visitados:\n\t\treturn False\n\telse: visitados.append(r)\n\tfor i in range(1,nvertices+1):\n\t\tif len(matrix[r][i]) >0:\n\t\t\tif cor in matrix[r][i]:\n\t\t\t\tvisita(i,t,cor)\t\t\t\n\t\t\t\nfor i in xrange(nedges):\n\ta,b,c = map(int,raw_input().split())\n\tif c not in matrix[a][b]:\n\t\tmatrix[a][b].append(c)\n\t\tmatrix[b][a].append(c)\n\t\t\nq= int(raw_input())\nfor i in xrange(q):\n\tcolors = []\n\tu,v = map(int,raw_input().split())\n\tfor kor in range(1,101):\n\t\tvisitados = []\n\t\tvisita(u,v,kor)\n\tprint len(colors)\n\t\n\n\t\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Main {\n\t\n\tstatic class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[256]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\t\n\tstatic class FastScanner {\n\n\t    private final BufferedReader bufferedReader;\n\t    private StringTokenizer stringTokenizer;\n\n\t    public FastScanner() {\n\t        bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\t    }\n\n\t    public String next() {\n\t        while (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n\t            try {\n\t                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n\t            } catch (IOException e) {\n\t                throw new RuntimeException(\"Can't read next value\", e);\n\t            }\n\t        }\n\t        return stringTokenizer.nextToken();\n\t    }\n\n\t    public int nextInt() {\n\t        return Integer.parseInt(next());\n\t    }\n\n\t    public long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\n\t    public double nextDouble() {\n\t        return Double.parseDouble(next());\n\t    }\n\n\t    public String nextLine(){\n\t        String str = \"\";\n\t        try {\n\t            str = bufferedReader.readLine();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        }\n\t        return str;\n\t    }\n\t}\n\t\n\tstatic void closeall() throws IOException{\n\t\tprintWriter.close();\n\t\tsc.close();\n\t\tin.close();\n\t}\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Reader in = new Reader();\n\tstatic FastScanner fastScanner = new FastScanner();\n\tstatic PrintWriter printWriter = new PrintWriter(new BufferedOutputStream(System.out));\n\t\n\tclass Node{\n\t\tint v,c;\n\t\tNode(int x,int y){\n\t\t\tv=x;\n\t\t\tc=y;\n\t\t}\n\t}\n\tint V;\n\tArrayList<Node> adj[];\n\tHashSet<Integer> color;\n\tMain(int v){\n\t\tV=v;\n\t\tadj=new ArrayList[v];\n\t\tfor(int i=0;i<v;i++)\n\t\t\tadj[i] = new ArrayList<>();\n\t\tcolor = new HashSet<>();\n\t}\n\tvoid addEdge(int u,int v,int c){\n\t\tadj[u].add(new Node(v,c));\n\t\tadj[v].add(new Node(u,c));\n\t\tcolor.add(c);\n\t}\n\tint dfs(int u,int v){\n\t\tIterator itr = color.iterator();\n\t\tint c=0;\n\t\twhile(itr.hasNext()){\n\t\t\tboolean[] vis = new boolean[V];\n\t\t\tif(dfsutil(vis,u,v,(int)itr.next()))\n\t\t\t\tc++;\n\t\t}\n\t\treturn c;\n\t}\n\tboolean dfsutil(boolean[] vis,int src,int dest,int c){\n\t\tvis[src]=true;\n\t\tif(src==dest)\n\t\t\treturn true;\n\t\tboolean ans = false;\n\t\tfor(int i=0;i<adj[src].size();i++){\n\t\t\tNode ob = adj[src].get(i);\n\t\t\tif(ob.c!=c || vis[ob.v])\n\t\t\t\tcontinue;\n\t\t\tans|=dfsutil(vis,ob.v,dest,c);\n\t\t\tif(ans)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tMain ob = new Main(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tob.addEdge(u-1, v-1, c);\n\t\t}\n\t\tint[][] t = new int[n][n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tArrays.fill(t[i], -1);\n\t\tint q = in.nextInt();\n\t\tfor(int a0=0;a0<q;a0++){\n\t\t\tint u = in.nextInt()-1;\n\t\t\tint v = in.nextInt()-1;\n\t\t\tif(t[u][v]==-1){\n\t\t\t\tint x = ob.dfs(u,v);\n\t\t\t\tt[u][v]=x;\n\t\t\t\tt[v][u]=x;\n\t\t\t}\n\t\t\tprintWriter.println(t[u][v]);\n\t\t}\n\t\tcloseall();\n\t}\n\t\n}"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nfrom sys import stdin, stdout\n\npar = defaultdict(list)\n\ndef build(n):\n    global par, size\n    for c in range(101):\n        par[c] = []\n        for i in range(n):\n            par[c].append(i)\n    return par\n\ndef find(c, i):\n    global par\n    if par[c][i] == i:\n        return i\n    par[c][i] = find(c, par[c][i])\n    return par[c][i]\n\ndef union(a, b, c):\n    global par, scc, size\n    p = find(c, a)\n    q = find(c, b)\n    if p == q:\n        return\n    par[c][q] = par[c][p]\n\ndef main():\n    (n, m) = map(int, stdin.readline().strip().split(' '))\n    par = build(n)\n    max_c = 0\n    for i in range(m):\n        (a, b, c) = map(lambda i: int(i) - 1, stdin.readline().strip().split(' '))\n        union(a, b, c)\n        max_c = max(max_c, c)\n    q = int(stdin.readline().strip())\n    for i in range(q):\n        (a, b) = map(lambda i: int(i) - 1, stdin.readline().strip().split(' '))\n        count = 0\n        for c in range(max_c + 1):\n            p = find(c, a)\n            q = find(c, b)\n            if p == q:\n                count += 1\n        stdout.write('{}\\n'.format(count))\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class Code505B {\n\n    private static List<Pair>[] graph;\n    private static boolean[] visited;\n    private static int V;\n    \n    \n    private static void addEgde(int from, int to, int color){\n        Pair p1 = new Pair(to, color);\n        Pair p2 = new Pair(from, color);\n        graph[from].add(p1);\n        graph[to].add(p2);\n    }\n    \n    private static boolean dfs(int fromV, int toV, int color){\n        visited[fromV] = true;\n        if(fromV == toV){\n            return true;\n        }\n        for (Pair p: graph[fromV]) {\n            if(p.getColor() == color && !visited[p.getToV()]){\n                if(dfs(p.getToV(),toV,color)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] input = br.readLine().split(\" \");\n        V = Integer.parseInt(input[0]);\n        int E = Integer.parseInt(input[1]);\n        int fromV, toV, color, queries, numOfColors;\n        graph = new ArrayList[V+1];\n        visited = new boolean[V+1];\n        for (int i = 1; i <= V; i++) {\n            graph[i] = new ArrayList<Pair>();\n        }\n        for (int i = 0; i < E; i++) {\n            input = br.readLine().split(\" \");\n            fromV = Integer.parseInt(input[0]);\n            toV = Integer.parseInt(input[1]);\n            color = Integer.parseInt(input[2]);\n            addEgde(fromV, toV, color);\n        }\n        queries = Integer.parseInt(br.readLine());\n        for (int i = 0; i < queries; i++) {\n            input = br.readLine().split(\" \");\n            fromV = Integer.parseInt(input[0]);\n            toV = Integer.parseInt(input[1]);\n            numOfColors = 0;\n            for (int c = 1; c <= E; c++) {\n                for (int j = 1; j <= V; j++) { //clear visited[] before the dfs() call \n                    visited[j] = false;\n                }\n                if(dfs(fromV, toV, c)){\n                    numOfColors++;\n                }\n            }\n            System.out.println(numOfColors);\n        }\n    }\n\n}\n\nclass Pair{\n    \n    private int toV;\n    private int color;\n    \n    public Pair(int toV, int color) {\n        this.toV = toV;\n        this.color = color;\n    }\n    \n    public int getColor() {\n        return color;\n    }\n    \n    public int getToV() {\n        return toV;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int>> v[105];\nvector<bool> vis(105, false);\nvoid dfs(int src, int des, int clr, int &aa, int &cc) {\n  if (src == des && cc == 0) {\n    aa++;\n    cc++;\n    return;\n  }\n  if (vis[src]) return;\n  vis[src] = true;\n  for (auto x : v[src]) {\n    if (x.second == clr && vis[x.first] == false) {\n      dfs(x.first, des, clr, aa, cc);\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int mx = 0;\n  for (int i = 0; i < m; i++) {\n    int a, b, clr;\n    cin >> a >> b >> clr;\n    v[a].push_back({b, clr});\n    v[b].push_back({a, clr});\n    if (clr > mx) mx = clr;\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    int ans = 0;\n    for (int i = 1; i <= mx; i++) {\n      int aa = 0;\n      int cc = 0;\n      dfs(a, b, i, aa, cc);\n      ans += aa;\n      for (int i = 0; i <= n; i++) vis[i] = false;\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, us[101], f = 0, t = 0;\nvector<int> v[101][101], ans;\nvoid dfs(int x, int y, int zvet) {\n  if (x == y) f = 1;\n  int i, j;\n  us[x] = 1;\n  for (i = 0; i < v[x][zvet].size(); i++) {\n    int to = v[x][zvet][i];\n    if (us[to] == 0) dfs(to, y, zvet);\n  }\n}\nint main() {\n  int q, x, y, g, z, i, j;\n  cin >> n >> m;\n  for (i = 1; i <= m; i++) {\n    cin >> x >> y >> z;\n    v[x][z].push_back(y);\n    v[y][z].push_back(x);\n  }\n  cin >> q;\n  for (i = 1; i <= q; i++) {\n    int kol = 0;\n    cin >> x >> y;\n    t = 0;\n    for (j = 0; j < 101; j++) {\n      for (g = 0; g < 101; g++) us[g] = 0;\n      f = 0;\n      dfs(x, y, j);\n      kol += f;\n    }\n    ans.push_back(kol);\n  }\n  for (i = 0; i < ans.size(); i++) cout << ans[i] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,m=map(int,raw_input().split())\ng=[[] for i in xrange(n)]\nfor i in xrange(m):\n    a,b,c=map(int,raw_input().split())\n    g[a-1].append((b-1,c))\n    g[b-1].append((a-1,c))\n\ndef sh(x,y,z):\n    qu=[]\n    qu.append(x)\n    at=[x]\n    while len(qu):\n        chk=qu.pop(0)\n        if len(g[chk])>0:\n            for i in g[chk]:\n                if i[1]==z and i[0]==y:\n                    return 1\n                elif i[1]==z and i[0] not in at:\n                    qu.append(i[0])\n                    at.append(i[0])\n    return 0\n\n\nq=int(raw_input())\nfor i in xrange(q):\n    u,v=map(int,raw_input().split())\n    ans=0\n    for r in range(1,m+1):\n#        print \"cnt\",r\n        if sh(u-1,v-1,r):\n            ans+=1\n    print ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cust1(pair<int64_t, pair<int64_t, int64_t> > a,\n           pair<int64_t, pair<int64_t, int64_t> > b) {\n  if (a.first == b.first) {\n    if (a.second.first == b.second.first) {\n      return a.second.second < b.second.second;\n    }\n    return a.second.first < b.second.first;\n  }\n  return a.first < b.first;\n}\nbool cust2(pair<int64_t, int64_t> a, pair<int64_t, int64_t> b) {\n  return a.first < b.first;\n}\nclass CompareDist {\n public:\n  bool operator()(pair<int64_t, int64_t> a, pair<int64_t, int64_t> b) {\n    return a.first > b.first;\n  }\n};\nint64_t gcd(int64_t a, int64_t b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nvector<vector<vector<int> > > nodes(101);\nvector<vector<int> > visited(101);\nbool DFS(int start, int color, int dest) {\n  if (start == dest) return true;\n  visited[color][start] = 1;\n  bool temp = false;\n  for (int i = 0; i < nodes[color][start].size(); i++) {\n    if (visited[color][nodes[color][start][i]] == 0) {\n      temp |= DFS(nodes[color][start][i], color, dest);\n    }\n  }\n  return temp;\n}\nint main() {\n  int n, m, i, j;\n  cin >> n >> m;\n  vector<map<int, int> > colors(101);\n  for (i = 0; i < 101; i++) {\n    vector<vector<int> > temp(101);\n    vector<int> temp_2(101, 0);\n    nodes[i] = temp;\n    visited[i] = temp_2;\n  }\n  for (i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    colors[c][a] = 1;\n    colors[c][b] = 1;\n    nodes[c][a].push_back(b);\n    nodes[c][b].push_back(a);\n  }\n  int q;\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    int a, b, ctr = 0;\n    cin >> a >> b;\n    for (j = 1; j < colors.size(); j++) {\n      if (colors[j].find(a) != colors[j].end() &&\n          colors[j].find(a) != colors[j].end()) {\n        bool temp = DFS(a, j, b);\n        if (temp) ctr++;\n        fill(visited[j].begin(), visited[j].end(), 0);\n      }\n    }\n    cout << ctr << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > v[105];\nint n, m;\nint flag = 0;\nbool visited[101];\nvoid dfs(int x, int y, int p, int j) {\n  int i;\n  if (visited[x]) {\n    return;\n  }\n  if (x == y) {\n    flag = 1;\n    return;\n  }\n  visited[x] = 1;\n  for (i = 0; i < v[x].size(); i++) {\n    if (v[x][i].first != p && v[x][i].second == j) {\n      dfs(v[x][i].first, y, x, j);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int i, j, k;\n  cin >> n >> m;\n  int color[105];\n  for (i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    v[x].push_back(make_pair(y, z));\n    v[y].push_back(make_pair(x, z));\n  }\n  int q;\n  cin >> q;\n  for (i = 0; i < q; i++) {\n    int x, y;\n    cin >> x >> y;\n    int cnt = 0;\n    for (j = 1; j <= m; j++) {\n      memset(visited, 0, sizeof(visited));\n      flag = 0;\n      dfs(x, y, -1, j);\n      if (flag == 1) cnt++;\n    }\n    cout << cnt << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\nusing namespace std;\nconst long long mod = 1000000007;\nint g[110][110][110];\nint n, m;\nvoid dfs(int r, int c, vector<int>& mark) {\n  if (mark[r]) return;\n  mark[r] = 1;\n  for (int u = 1; u <= n; u++) {\n    if (g[c][r][u]) dfs(u, c, mark);\n  }\n}\nint calc(int a, int b) {\n  int ret = 0;\n  for (int c = 1; c <= m; c++) {\n    vector<int> mark(n + 1);\n    dfs(a, c, mark);\n    ret += mark[b];\n  }\n  return ret;\n}\nvoid solve(int ncase) {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    g[c][a][b] = 1;\n    g[c][b][a] = 1;\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << calc(u, v) << endl;\n  }\n}\nint main() {\n  int T = 1;\n  int ncase = 0;\n  while (T--) {\n    solve(++ncase);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint id[101][101];\nint sz[101][101];\nint root(int i, int c) {\n  while (id[c][i] != i) {\n    id[c][i] = id[c][id[c][i]];\n    i = id[c][i];\n  }\n  return i;\n}\nbool connected(int p, int q, int c) { return root(p, c) == root(q, c); }\nvoid qunion(int p, int q, int c) {\n  int rp = root(p, c);\n  int rq = root(q, c);\n  if (rp == rq) return;\n  if (sz[c][rp] < sz[c][rq]) {\n    id[c][rp] = rq;\n    sz[c][rq] += sz[c][rp];\n  } else {\n    id[c][rq] = rp;\n    sz[c][rp] += sz[c][rq];\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for (int j = 1; j <= 100; j++) {\n    for (int i = 1; i <= 100; i++) {\n      id[j][i] = i;\n      sz[j][i] = 1;\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    int x, y, c;\n    cin >> x >> y >> c;\n    qunion(x, y, c);\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int x;\n    int y;\n    cin >> x >> y;\n    int ans = 0;\n    for (int j = 1; j <= 100; j++) {\n      if (connected(x, y, j)) ans++;\n    }\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "def dfs_paths(graph, start, goal, path=list()):\n    if not path:\n        path.append(start)\n    if start == goal:\n        yield path\n    for vertex in graph[start] - set(path):\n        yield from dfs_paths(graph, vertex, goal, path=path + [vertex])\n\nn, m = map(int, input().split())\ngraph = {}\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n\n    if c not in graph:\n        graph[c] = {}\n\n    if a not in graph[c]:\n        graph[c][a] = set()\n\n    if b not in graph[c]:\n        graph[c][b] = set()\n\n    graph[c][a].add(b)\n    graph[c][b].add(a)\n\nq = int(input())\n\nfor _ in range(q):\n    u, v = map(int, input().split())\n    count = 0\n\n    for k in graph:\n        if u not in graph[k] or v not in graph[k]:\n            continue\n        if len(list(dfs_paths(graph[k], u, v, []))) > 0:\n            count += 1\n\n    print(count)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int num, pre;\n  Node(int _num = 0, int _pre = 0) {\n    num = _num;\n    pre = _pre;\n  }\n};\nint flag = 0;\nint cnt = 0;\nvector<bool> vi;\nvoid dfs(vector<vector<vector<int> > > &arc, int n, int u, int v, int c,\n         int pre) {\n  vi[u] = true;\n  int ii = 0, jj = 0;\n  if (u == v) {\n    cnt++;\n    flag = 1;\n    return;\n  }\n  for (jj = 1; jj <= n; jj++) {\n    if (flag == 1) break;\n    if (vi[jj] == false &&\n        find(arc[u][jj].begin(), arc[u][jj].end(), c) != arc[u][jj].end()) {\n      dfs(arc, n, jj, v, c, u);\n    }\n  }\n}\nint main() {\n  int n = 0, m = 0;\n  while (cin >> n >> m) {\n    vector<int> v_tmp;\n    vector<vector<vector<int> > > arc(n + 1,\n                                      vector<vector<int> >(n + 1, v_tmp));\n    int i = 0, j = 0;\n    for (i = 1; i <= m; i++) {\n      int a = 0, b = 0, c = 0;\n      cin >> a >> b >> c;\n      arc[a][b].push_back(c);\n      arc[b][a].push_back(c);\n    }\n    int q = 0;\n    cin >> q;\n    int ii = 0, jj = 0, kk = 0;\n    for (i = 0; i < q; i++) {\n      int u = 0, v = 0;\n      cin >> u >> v;\n      if (u > v) {\n        int tmp = u;\n        u = v;\n        v = tmp;\n      }\n      cnt = 0;\n      for (ii = 1; ii <= m; ii++) {\n        flag = 0;\n        vi = vector<bool>(n + 1, false);\n        dfs(arc, n, u, v, ii, -1);\n      }\n      cout << cnt << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ID506D {\n  static class DSU {\n    int[] parent;\n    int[] size;\n\n    DSU(int N) {\n      parent = new int[N];\n      size = new int[N];\n      for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        size[i] = 1;\n      }\n    }\n\n    int find(int v) {\n      if (parent[v] != v)\n        parent[v] = find(parent[v]);\n      return parent[v];\n    }\n\n    void union(int v, int w) {\n      v = find(v);\n      w = find(w);\n      if (v == w)\n        return;\n      if (size[v] < size[w]) {\n        int t = v;\n        v = w;\n        w = t;\n      }\n      size[v] += size[w];\n      parent[w] = v;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n    StringTokenizer st = new StringTokenizer(in.readLine());\n    int N = Integer.parseInt(st.nextToken());\n    int M = Integer.parseInt(st.nextToken());\n\n    DSU[] dsu = new DSU[M];\n\n    for (int i = 0; i < M; i++) {\n      dsu[i] = new DSU(N);\n    }\n\n    for (int i = 0; i < M; i++) {\n      st = new StringTokenizer(in.readLine());\n      int v = Integer.parseInt(st.nextToken());\n      int w = Integer.parseInt(st.nextToken());\n      int c = Integer.parseInt(st.nextToken());\n      dsu[c - 1].union(v - 1, w - 1);\n    }\n\n    int Q = Integer.parseInt(in.readLine());\n\n    for (int q = 0; q < Q; q++) {\n      st = new StringTokenizer(in.readLine());\n      int v = Integer.parseInt(st.nextToken());\n      int w = Integer.parseInt(st.nextToken());\n      int res = 0;\n      for (int i = 0; i < M; i++) {\n        if (dsu[i].find(v - 1) == dsu[i].find(w - 1))\n          res++;\n      }\n      System.out.println(res);\n    }\n\n    in.close();\n  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class CF505B\n{\n    static class conn\n    {\n        int v;\n        int c;\n        conn(int x,int y)\n        {\n            v=x;\n            c=y;\n        }\n    }\n    static LinkedList<conn> ll[];\n    static boolean[] visited;\n    static long count;\n    public static void main(String[] args)throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String t1=br.readLine();\n        String[] t2=t1.split(\" \");\n        int n=Integer.parseInt(t2[0]);\n        int m=Integer.parseInt(t2[1]);\n        int[][] e=new int[m][3];\n        ll=new LinkedList[n+1];\n        for(int i=1;i<=n;i++)\n        {\n            ll[i]=new LinkedList<>();\n        }\n        for(int i=0;i<m;i++)\n        {\n            String t3=br.readLine();\n            String[] t4=t3.split(\" \");\n            e[i][0]=Integer.parseInt(t4[0]);\n            e[i][1]=Integer.parseInt(t4[1]);\n            e[i][2]=Integer.parseInt(t4[2]);\n            conn temp=new conn(e[i][1],e[i][2]);\n            ll[e[i][0]].add(temp);\n            temp=new conn(e[i][0],e[i][2]);\n            ll[e[i][1]].add(temp);\n        }\n        visited=new boolean[n+1];\n        Arrays.fill(visited,false);\n        int q=Integer.parseInt(br.readLine());\n        for(int j=0;j<q;j++)\n        {\n            String t5=br.readLine();\n            String[] t6=t5.split(\" \");\n            int ui=Integer.parseInt(t6[0]);\n            int vi=Integer.parseInt(t6[1]);\n            count=0;\n            long tt=0;\n            HashSet<Integer> colors=new HashSet<>();\n            for(conn y:ll[ui])\n            {\n                if(colors.contains(y.c))\n                {\n                    continue;\n                }\n                Arrays.fill(visited,false);\n                visited[ui]=true;\n                DFS(ui,vi,y.v,y.c);\n                if(count!=tt)\n                {\n                    colors.add(y.c);\n                    tt=count;\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    public static void DFS(int start,int end,int node,int color)\n    {\n        if(end==node)\n        {\n            count++;\n        }\n        visited[node]=true;\n        for(conn x:ll[node])\n        {\n            if(visited[x.v]==false)\n            {\n                if(x.c==color)\n                {\n                    DFS(start,end,x.v,color);\n                }\n            }\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q, a, b, c, s, t;\nbool v[105];\nvector<int> adj[105][105];\nint dp[105][105][105];\nint dfs(int par, int cur, int t, int cg) {\n  v[cur] = true;\n  if (cur == t) return 1;\n  int ret = 0;\n  for (int x : adj[cur][cg]) {\n    if (v[x]) continue;\n    ret += dfs(cur, x, t, cg);\n  }\n  dp[cur][t][cg] = ret;\n  return dp[cur][t][cg];\n}\nint main() {\n  memset(dp, 0, sizeof dp);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    adj[a][c].push_back(b);\n    adj[b][c].push_back(a);\n  }\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d\", &s, &t);\n    int ans = 0;\n    for (int j = 1; j <= m; j++) {\n      memset(v, 0, sizeof v);\n      ans += dfs(0, s, t, j);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n#sys.setrecursionlimit(111111) \nINF=99999999999999999999999999999999\ndef outIn(x):\n    print(x, flush=True)\n    return input()\ndef main():\n\n    mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    ###CODE\n    tc = 1\n    for _ in range(tc):\n        n,m=ria()\n        d={}\n        for i in range(m):\n            a,b,c=ria()\n            if c not in d:\n                d[c]=[[a,b]]\n            else:\n                d[c].append([a,b])\n        \n        def dfs(graph, start,visited):\n            n = len(graph)\n            comp=[]\n            stack = [start]\n            t=0\n            while stack:\n                start = stack[-1]\n                # push unvisited children into stack\n                if not visited[start]:\n                    comp.append(start)\n                    visited[start] = True\n                    for child in graph[start]:\n                        if not visited[child]:\n                            stack.append(child)\n                else:\n                    stack.pop()\n            return comp,visited\n        fd={}\n        for i in range(1,m+1):\n            if i in d:\n                visited=[False]*(n+1)\n                graph=[[] for i in range(n+1)]\n                vert={}\n                for u,v in d[i]:\n                    vert[u]=1\n                    vert[v]=1\n                    graph[u].append(v)\n                    graph[v].append(u)\n                for j in vert:\n                    if not visited[j]:\n                        comp,visited=dfs(graph,j,visited)\n                        if i in fd:\n                            fd[i].append(comp)\n                        else:\n                            fd[i]=[comp]\n        q=ri()\n        for i in range(q):\n            u,v=ria()\n            count=0\n            for j in range(1,m+1):\n                f=0\n                if j in fd:\n                    for t in fd[j]:\n                        if u in t and v in t:\n                            f=1\n                            break\n                count+=f\n            print(count)\n            \n            \n            \n            \n        \n                        \n                \n                \n            \n                    \n                    \n                     \n                \n        \n                        \n\n            \n            \n                    \n                \n                \n        \n                \n                          \n            \n        \n    \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    "
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class B505 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int M = in.nextInt();\n        UnionFind[] uf = new UnionFind[M];\n        for (int m=0; m<M; m++) {\n            uf[m] = new UnionFind(N);\n        }\n        for (int m=0; m<M; m++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            int c = in.nextInt()-1;\n            uf[c].union(a, b);\n        }\n        int Q = in.nextInt();\n        for (int q=0; q<Q; q++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            int answer = 0;\n            for (int m=0; m<M; m++) {\n                if (uf[m].find(a) == uf[m].find(b)) {\n                    answer++;\n                }\n            }\n            System.out.println(answer);\n        }\n    }\n\n    static class UnionFind {\n        private final int[] group;\n        \n        public UnionFind(int size) {\n            group = new int[size];\n            Arrays.fill(group, -1);\n        }\n\n        public final int find(int x) {\n            while (group[x] >= 0) {\n                x = group[x];\n            }\n            return x;\n        }\n\n        public final boolean union(int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (x != y) {\n                if (group[x] > group[y]) {\n                    group[y] += group[x];\n                    group[x] = y;\n                } else {\n                    group[x] += group[y];\n                    group[y] = x;\n                }\n            }\n            return (x != y);\n        }\n\n        public final int size(int x) {\n            return -group[find(x)];\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\ninput = stdin.readline\n \ndef main():\n    n, m = map(int,input().split())\n    sets = [list(range(n+1)) for i in range(m)]\n    sizes = [[1]*(n+1) for i in range(m)]\n    def get(a,ind):\n        if sets[ind][a] != a:\n            sets[ind][a] = get(sets[ind][a],ind)\n        return sets[ind][a]\n    def union(a, b,ind):\n        a = get(a,ind)\n        b = get(b,ind)\n        if a == b:return\n        if sizes[ind][a] > sizes[ind][b]:\n            a,b = b,a\n        sets[ind][a] = b\n        sizes[ind][b] += sizes[ind][a]\n    for i in range(m):\n        a, b, c = map(int,input().split())\n        a -= 1\n        b -= 1\n        c -= 1\n        union(a,b,c)\n    q = int(input())\n    for i in range(q):\n        ans = 0\n        u,v = map(int,input().split())\n        u-=1\n        v-=1\n        for j in range(m):\n            ans += int(get(u,j) == get(v,j))\n        print(ans)\nmain()\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static boolean[] visited;\n    static ArrayList<Edge>[] graph;\n    static boolean[] colorVisited;\n    static int end;\n    static int count;\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        visited = new boolean[n];\n        colorVisited = new boolean[m + 1];\n\n\n        graph = new ArrayList[n];\n        for (int i = 0; i < graph.length; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        int a, b, c;\n\n        for (int i = 0; i < m; i++) {\n            a = sc.nextInt() - 1;\n            b = sc.nextInt() - 1;\n            c = sc.nextInt();\n            graph[a].add(new Edge(b, c));\n            graph[b].add(new Edge(a, c));\n        }\n\n        int q = sc.nextInt();\n        int u;\n\n        for (int i = 0; i < q; i++) {\n            u = sc.nextInt() - 1;\n            end = sc.nextInt() - 1;\n            count = 0;\n\n            Arrays.fill(colorVisited, false);\n\n            // Visited auto fills false\n            visited[u] = true;\n            dfs(u, 0);\n            visited[u] = false;\n            System.out.println(count);\n        }\n\n    }\n\n\n    public static void dfs(int curr, int color) {\n\n        if (curr == end) {\n            if (!colorVisited[color]) count++;\n            colorVisited[color] = true;\n            return;\n        }\n\n        for (Edge edge : graph[curr]) {\n\n            if (visited[edge.to]) continue;\n\n            if ((edge.color == color || color == 0) && !colorVisited[color]) {\n                visited[edge.to] = true;\n                dfs(edge.to, edge.color);\n                visited[edge.to] = false;\n            }\n        }\n    }\n\n    static class Edge {\n        public int to;\n        public int color;\n\n        public Edge(int to, int color) {\n            this.to = to;\n            this.color = color;\n        }\n    }\n\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > adj[101];\nqueue<pair<int, int> > qu;\nmap<pair<int, int>, int> ans;\nset<pair<int, int> > chk[101];\nset<int> stk;\nint bfs(int st, int en) {\n  int x, cnt, i, y, co, pr;\n  cnt = 0;\n  while (!qu.empty()) {\n    x = qu.front().first;\n    pr = qu.front().second;\n    qu.pop();\n    for (i = 0; i < adj[x].size(); i++) {\n      y = adj[x][i].first;\n      co = adj[x][i].second;\n      if ((chk[co].find({x, y}) != chk[co].end()) || (co != pr && pr != -1))\n        continue;\n      chk[co].insert({x, y});\n      chk[co].insert({y, x});\n      if (y == en && stk.find(co) == stk.end()) {\n        stk.insert(co);\n        cnt++;\n      } else\n        qu.push({y, co});\n    }\n  }\n  return cnt;\n}\nint main() {\n  int n, m, i, q, a, b, c;\n  cin >> n >> m;\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    adj[a].push_back({b, c});\n    adj[b].push_back({a, c});\n  }\n  cin >> q;\n  while (q--) {\n    scanf(\"%d %d\", &a, &b);\n    if (ans.find({a, b}) == ans.end()) {\n      qu.push({a, -1});\n      c = bfs(a, b);\n      if (c == 0) c = -1;\n      ans[{a, b}] = c;\n      ans[{b, a}] = c;\n      stk.clear();\n      for (i = 0; i < 101; i++) chk[i].clear();\n    } else {\n      c = ans[{a, b}];\n    }\n    if (c == -1) c = 0;\n    printf(\"%d\\n\", c);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class KitayutasColorfulGraph {\n\n  static BufferedReader in;\n  static PrintWriter out;\n  static StringTokenizer tok;\n\n  static void solve() throws Exception {\n    int n = nextInt(), m = nextInt();\n    boolean[][][] g = new boolean[m][n][n];\n    for (int i = 0; i < m; i++) {\n      int a = nextInt(), b = nextInt(), c = nextInt();\n      g[c - 1][a - 1][b - 1] = true;\n      g[c - 1][b - 1][a - 1] = true;\n    }\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++) {\n        Queue<Integer> queue = new LinkedList<>();\n        for (int k = 0; k < n; k++)\n          if (k != j && g[i][j][k])\n            queue.offer(k);\n        while (!queue.isEmpty()) {\n          int t = queue.poll();\n          for (int k = 0; k < n; k++)\n            if (k != j && !g[i][j][k] && g[i][t][k]) {\n              g[i][j][k] = true;\n              g[i][k][j] = true;\n              queue.offer(k);\n            }\n        }\n      }\n    int q = nextInt();\n    for (int i = 0; i < q; i++) {\n      int a = nextInt() - 1;\n      int b = nextInt() - 1;\n      int v1 = Math.min(a, b);\n      int v2 = Math.max(a, b);\n      int c = 0;\n      for (int j = 0; j < m; j++)\n        if (g[j][v1][v2])\n          c++;\n      out.println(c);\n    }\n  }\n\n  static void dfs(int i, int c) {\n\n  }\n\n  public static void main(String args[]) {\n    try {\n      in = new BufferedReader(new InputStreamReader(System.in));\n      out = new PrintWriter(new OutputStreamWriter(System.out));\n      solve();\n      in.close();\n      out.close();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n\n  static int nextInt() throws IOException {\n    return Integer.parseInt(next());\n  }\n\n  static int[] nextIntArray(int len, int start) throws IOException {\n    int[] a = new int[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextInt();\n    return a;\n  }\n\n  static long nextLong() throws IOException {\n    return Long.parseLong(next());\n  }\n\n  static long[] nextLongArray(int len, int start) throws IOException {\n    long[] a = new long[len];\n    for (int i = start; i < len; i++)\n      a[i] = nextLong();\n    return a;\n  }\n\n  static String next() throws IOException {\n    while (tok == null || !tok.hasMoreTokens()) {\n      tok = new StringTokenizer(in.readLine());\n    }\n    return tok.nextToken();\n  }\n\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\nn, m = map(int, raw_input().split())\n\nconnection = {}\ncolors = []\n\nfor _ in range(m):\n    a, b, c = map(int, raw_input().split())\n    connection[a * 1000 + c] = connection.get(a * 1000 + c, []) + [b]\n    connection[b * 1000 + c] = connection.get(b * 1000 + c, []) + [a]\n    colors.append(c)\n\ncolors = list(set(colors))\n\nquery = input()\nfor _ in range(query):\n    start, destination = map(int, raw_input().split())\n    result = 0\n\n    for color in colors:\n        qq = deque([start])\n        visited = {start: 1}\n\n        while len(qq):\n            vertex = qq.popleft()\n\n            for v in connection.get(vertex * 1000 + color, []):\n                if v == destination:\n                    result += 1\n                    qq = deque([])\n                    break\n                if v in visited:\n                    continue\n                visited[v] = 1\n                qq.append(v)\n\n    print result\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> adj[101];\nint vis[101][101];\nint id;\nbool dfs(const int &idx, int cur, int to) {\n  if (cur == to) return true;\n  bool ret = false;\n  for (int i = 0; i < (int)adj[idx][cur].size(); i++) {\n    if (vis[idx][adj[idx][cur][i]] == id) continue;\n    vis[idx][adj[idx][cur][i]] = id;\n    ret |= dfs(idx, adj[idx][cur][i], to);\n  }\n  return ret;\n}\nint main() {\n  int n, m, q;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < 101; i++) adj[i].resize(n);\n  for (int i = 0, u, v, c; i < m; i++) {\n    scanf(\"%d%d%d\", &u, &v, &c);\n    adj[c - 1][u - 1].push_back(v - 1);\n    adj[c - 1][v - 1].push_back(u - 1);\n  }\n  int u, v;\n  scanf(\"%d\", &q);\n  while (q--) {\n    id++;\n    scanf(\"%d%d\", &u, &v);\n    int ans = 0;\n    for (int i = 0; i < m; i++) ans += dfs(i, u - 1, v - 1);\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nclass DisjSet: \n    def __init__(self, n): \n        # Constructor to create and \n        # initialize sets of n items \n        self.rank = [1] * n \n        self.parent = [i for i in range(n)] \n  \n  \n    # Finds set of given item x \n    def find(self, x): \n          \n        # Finds the representative of the set \n        # that x is an element of \n        if (self.parent[x] != x): \n              \n            # if x is not the parent of itself \n            # Then x is not the representative of \n            # its set, \n            self.parent[x] = self.find(self.parent[x]) \n              \n            # so we recursively call Find on its parent \n            # and move i's node directly under the \n            # representative of this set \n  \n        return self.parent[x] \n  \n  \n    # Do union of two sets represented \n    # by x and y. \n    def Union(self, x, y): \n          \n        # Find current sets of x and y \n        xset = self.find(x) \n        yset = self.find(y) \n  \n        # If they are already in same set \n        if xset == yset: \n            return\n  \n        # Put smaller ranked item under \n        # bigger ranked item if ranks are \n        # different \n        if self.rank[xset] < self.rank[yset]: \n            self.parent[xset] = yset \n  \n        elif self.rank[xset] > self.rank[yset]: \n            self.parent[yset] = xset \n  \n        # If ranks are same, then move y under \n        # x (doesn't matter which one goes where) \n        # and increment rank of x's tree \n        else: \n            self.parent[yset] = xset \n            self.rank[xset] = self.rank[xset] + 1\nL = []\nn,m = map(int,input().split())\nedges = []\nfor k in range(m):\n  a,b,c = map(int,input().split())\n  edges.append([a,b,c])\nq = int(input())\nqueries = []\nfor l in range(q):\n  x,y = map(int,input().split())\n  queries.append([x,y])\ncount = [0 for i in range(q)]\nfor i in range(1,101):\n  g = DisjSet(101)\n  for [u,v,c] in edges:\n    if c == i:\n      g.Union(u,v)\n  for z in range(q):\n    if g.find(queries[z][0]) == g.find(queries[z][1]):\n      count[z] += 1\nfor m in range(q):\n    print(count[m])"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class b {\n\tpublic static void main(String[] arg)\n\t{\n\t\tnew b();\n\t}\n\tpublic b()\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tArrayList<ArrayList<Pair>> eList = new ArrayList<ArrayList<Pair>>();\n\t\tfor(int i = 0; i <= n; i++)\n\t\t{\n\t\t\teList.add(new ArrayList<Pair>());\n\t\t\t\n\t\t}\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint v1 = in.nextInt();\n\t\t\tint v2 = in.nextInt();\n\t\t\tint color = in.nextInt();\n\t\t\teList.get(v1).add(new Pair(v2, color));\n\t\t\teList.get(v2).add(new Pair(v1, color));\n\t\t}\n\t\tint query = in.nextInt();\n\t\tfor(int p = 0; p < query; p++)\n\t\t{\n\t\t\tint start = in.nextInt();\n\t\t\tint end = in.nextInt();\n\t\t\tint answer = 0;\n\t\t\tfor(int c = 1; c <= m; c++)\n\t\t\t{\n\t\t\t\tArrayDeque<Pair> q = new ArrayDeque<Pair>();\n\t\t\t\tHashSet<Integer> used = new HashSet<Integer>();\n\t\t\t\tboolean possible = false;\n\t\t\t\tfor(int i = 0; i < eList.get(start).size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif(eList.get(start).get(i).color == c)\n\t\t\t\t\t\tq.add(eList.get(start).get(i));\n\t\t\t\t}\n\t\t\t\twhile(q.size() > 0)\n\t\t\t\t{\n\t\t\t\t\tPair temp = q.poll();\n\t\t\t\t\t\n\t\t\t\t\tif(!used.add(temp.v)) continue;\n\t\t\t\t\tif(temp.color != c) continue;\n\t\t\t\t\tif(temp.v == end)\n\t\t\t\t\t{\n\t\t\t\t\t\tpossible = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i < eList.get(temp.v).size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(eList.get(temp.v).get(i).color == c)\n\t\t\t\t\t\t\tq.add(eList.get(temp.v).get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(possible) answer++;\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t\tin.close();\n\t}\n\tclass Pair\n\t{\n\t\tint v;\n\t\tint color;\n\t\tpublic Pair(int a, int b)\n\t\t{\n\t\t\tv = a;\n\t\t\tcolor = b;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return [str(x) for x in stdin.readline().split()]\n\n\nclass disjointset:\n    def __init__(self, n):\n        self.rank, self.parent, self.n, self.nsets, self.edges = defaultdict(int), defaultdict(int), n, defaultdict(\n            int), defaultdict(int)\n        for i in range(1, n + 1):\n            self.parent[i], self.nsets[i] = i, 1\n\n    def find(self, x):\n\n        if self.parent[x] == x:\n            return x\n\n        result = self.find(self.parent[x])\n\n        self.parent[x] = result\n\n        return result\n\n    def union(self, x, y):\n        xpar, ypar = self.find(x), self.find(y)\n\n        # already union\n        if xpar == ypar:\n            self.edges[xpar] += 1\n            return\n        # perform union by rank\n        if self.rank[xpar] < self.rank[ypar]:\n            self.parent[xpar] = ypar\n            self.edges[ypar] += self.edges[xpar] + 1\n            self.nsets[ypar] += self.nsets[xpar]\n\n        elif self.rank[xpar] > self.rank[ypar]:\n            self.parent[ypar] = xpar\n            self.edges[xpar] += self.edges[ypar] + 1\n            self.nsets[xpar] += self.nsets[ypar]\n\n        else:\n            self.parent[ypar] = xpar\n            self.rank[xpar] += 1\n            self.edges[xpar] += self.edges[ypar] + 1\n            self.nsets[xpar] += self.nsets[ypar]\n\n\nfrom sys import stdin\nfrom collections import defaultdict\n\nn, m = arr_inp(1)\ncolor = [disjointset(n) for i in range(m)]\nfor i in range(m):\n    a, b, c = arr_inp(1)\n    color[c - 1].union(a, b)\n\nfor i in range(int(input())):\n    u, v = arr_inp(1)\n    ans = 0\n    for j in range(m):\n        if color[j].find(u) == color[j].find(v):\n            ans += 1\n    print(ans)\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\ndef ii(): return map(int,raw_input().split())\nn,m = ii()\ng = [[[] for i in xrange(m+1)] for j in xrange(n+1)]\nfor _ in xrange(m):\n    a, b, c = ii()\n    g[a][c].append(b)\n    g[b][c].append(a)\nq = input()\nfor _ in xrange(q):\n    u, v = ii()\n    ans = 0\n    for c in xrange(1,m+1):\n        vis = [False] * (n+1)\n        q = deque(g[u][c])\n        while(q):\n            k = q.pop()\n            if vis[k]: continue\n            vis[k] = True\n            if k == v:\n                ans += 1\n                break\n            q.extend(g[k][c])\n    print ans\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    def dfs(index, color):\n        visited[index] = True\n        for p in adj[index]:\n            if not visited[p[0]] and p[1] == color:\n                dfs(p[0], color)\n\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        adj[a - 1].append((b - 1, c))\n        adj[b - 1].append((a - 1, c))\n    q = int(input())\n    for _ in range(q):\n        a, b = map(int, input().split())\n        ans = 0\n        for i in range(1, m + 1):\n            visited = [False] * n\n            dfs(a - 1, i)\n            if visited[b - 1]:\n                ans += 1\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 1,
            "solution": "\n\nfrom sys import stdin\n\nimport fileinput\nimport string\nimport sys\nfrom collections import defaultdict\n\ninp1 = map(int, stdin.readline().rstrip().split())\ncount1 = inp1[1]\ngraph = []\ng = defaultdict(lambda: ([], [])) # dest, col\nallcols = set()\nfor i in xrange(count1):\n\tline = map(int, stdin.readline().rstrip().split())\n\tgraph.append(line)\n\tt = g[line[0]]\n\tt[0].append(line[1])\n\tt[1].append(line[2])\n\tt = g[line[1]]\n\tt[0].append(line[0])\n\tt[1].append(line[2])\n\tallcols.add(line[2])\n\ncount2 = int(stdin.readline().rstrip())\nqueries = []\n\n\ndef bfsAAA(start, dest, col):\n\tif start == dest:\n\t\treturn 0\n\tseen = set([start])\n\tbest = None\n\tcur = g[start]\n\tnewcur = ([],[])\n\tfor i in xrange(len(cur[0])):\n\t\tnode = cur[0][i]\n\t\tif node == dest and col == cur[1][i]:\n\t\t\treturn 1\n\t\tif node != dest and col == cur[1][i]:\n\t\t\tseen.add(node)\n\t\t\tnewcur[0].append(node)\n\t\t\tnewcur[1].append(cur[1][i])\n\tcur = newcur\n\ttraversed = 1\n\t#print cur\n\twhile True:\n\t\tnewcur = ([],[])\n\t\tfor i in xrange(len(cur[0])):\n\t\t\tnode = cur[0][i]\n\t\t\tneighbors = g[node]\n\t\t\tneighnodes = neighbors[0]\n\t\t\tneighcols = neighbors[1]\n\t\t\tfor j in xrange(len(neighnodes)):\n\t\t\t\tif neighnodes[j] == dest and neighcols[j] == col:\n\t\t\t\t\treturn traversed + 1\n\t\t\t\tif neighnodes[j] not in seen and neighcols[j] == col and neighcols[j] != dest:\n\t\t\t\t\tseen.add(neighnodes[j])\n\t\t\t\t\tnewcur[0].append(neighnodes[j])\n\t\t\t\t\tnewcur[1].append(neighcols[j])\n\t\tif len(newcur[0]) == 0:\n\t\t\tbreak\n\t\tcur = newcur\n\t\ttraversed += 1\n\treturn None\n\n\ndef bfs(start, dest, col, seen=set(), tot=0):\n\tnewnodes = []\n\tfor i in start:\n\t\ttot += 1\n\t\tcur = g[i]\n\t\tneighnodes = cur[0]\n\t\tneighcols = cur[1]\n\t\t#print neighnodes, neighcols\n\t\tfor idx, n in enumerate(neighnodes):\n\t\t\t#print seen#n, dest, neighcols[idx], col, n in seen\n\t\t\tif n == dest and neighcols[idx] == col:\n\t\t\t\treturn tot\n\t\t\tif n not in seen and neighcols[idx] == col:\n\t\t\t\tnewnodes.append(n)\n\t\t\t\tseen.add(n)\n\tif len(newnodes) == 0:\n\t\treturn None\n\treturn bfs(newnodes, dest, col, seen, tot + 1)\n\n\n\nfor i in xrange(count2):\n\tline = map(int, stdin.readline().rstrip().split())\n\ttot = 0\n\tfor color in allcols:\n\t\t#print [line[0]], line[1], color\n\t\tr = bfs([line[0]], line[1], color, set())\n\t\tif r != None:\n\t\t\ttot += 1\n\tprint tot\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tEscanner sc = new Escanner();\n\t\tn = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tg = new ArrayList[n][n];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint u = sc.nextInt()-1;\n\t\t\tint v = sc.nextInt()-1;\n\t\t\tint c = sc.nextInt();\n\t\t\tif(g[u][v]==null)\n\t\t\t\tg[u][v] = new ArrayList<Integer>();\n\t\t\tg[u][v].add(c);\n\t\t\tif(g[v][u]==null)\n\t\t\t\tg[v][u] = new ArrayList<Integer>();\n\t\t\tg[v][u].add(c);\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tfor(int i=0; i<q; i++){\n\t\t\tvisited = new boolean[n];\n\t\t\tclrs = new ArrayList<Integer>();\n\t\t\tu = sc.nextInt()-1;\n\t\t\tv = sc.nextInt()-1;\n\t\t\tdfs(u, -1);\n\t\t\tSystem.out.println(clrs.size());\n\t\t}\n\t}\n\t\n\tstatic class Escanner{\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\t\tEscanner(){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\t\tint nextInt()throws IOException{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\treturn nextInt();\n\t\t}\n\t}\n\n\tstatic ArrayList<Integer> g[][];\n\tstatic int n;\n\tstatic int u;\n\tstatic int v;\n\tstatic ArrayList<Integer> clrs;\n\t\n\tstatic boolean[] visited;\n\n\tstatic void dfs(int i, int c){\n\t\tif(i==v){\n\t\t\tif(!clrs.contains(c))\n\t\t\t\tclrs.add(c);\n\t\t\treturn;\n\t\t}\n\t\tvisited[i] = true;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(g[i][j]!=null && !visited[j]){\n\t\t\t\tfor(int k=0; k<g[i][j].size(); k++){\n\t\t\t\t\tif(c==-1 || c==g[i][j].get(k))\n\t\t\t\t\t\tdfs(j, g[i][j].get(k));\n\t\t\t\t\tvisited[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\n\n\t\n\t\npublic class Solution  {\n\t\n\tstatic class FastScanner{\n\t\tBufferedReader s;\n\t\tStringTokenizer st;\n\t\t\n\t\t\n\t\tpublic FastScanner(){\n\t\t\tst = new StringTokenizer(\"\");\n\t\t\ts = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic FastScanner(File f) throws FileNotFoundException{\n\t\t\tst = new StringTokenizer(\"\");\n\t\t\ts = new BufferedReader (new FileReader(f));\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t\treturn Integer.parseInt(st.nextToken());\n\t\t\telse{\n\t\t\t\tst = new StringTokenizer(s.readLine());\n\t\t\t\treturn nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t\treturn Double.parseDouble(st.nextToken());\n\t\t\telse{\n\t\t\t\tst = new StringTokenizer(s.readLine());\n\t\t\t\treturn nextDouble();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t\treturn Long.parseLong(st.nextToken());\n\t\t\telse{\n\t\t\t\tst = new StringTokenizer(s.readLine());\n\t\t\t\treturn nextLong();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String nextString() throws IOException{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t\treturn st.nextToken();\n\t\t\telse{\n\t\t\t\tst = new StringTokenizer(s.readLine());\n\t\t\t\treturn nextString();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpublic String readLine() throws IOException{\n\t\t\treturn s.readLine();\n\t\t}\n\t\t\n\t\tpublic void close() throws IOException{\n\t\t\ts.close();\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t//FastScanner s = new FastScanner(new File(\"input.txt\"));       copy inside void solve\n    //PrintWriter ww = new PrintWriter(new FileWriter(\"output.txt\"));\n    static FastScanner s = new FastScanner();   \n    static PrintWriter ww = new PrintWriter(new OutputStreamWriter(System.out));\n\t\n    public static void main(String args[])throws IOException{\n    \t//Main ob=new Main();\n    \tSolution ob=new Solution();\n\t\tob.solve();\n\t\t\tww.close();\n    }\n    ///////////////////////////////////\nstatic class UF{\n\t\t\n\t    private int[] id;    \n\t    private byte[] rank;  \n\t    public UF(int N) {\n\t        id = new int[N];\n\t        rank = new byte[N];\n\t        for (int i = 0; i < N; i++) {\n\t            id[i] = i;\n\t            rank[i] = 1;\n\t        }\n\t    }\n\n\t    public int find(int p) {\n\t        while (p != id[p]) {\n\t            id[p] = id[id[p]];    // path compression by halving\n\t            p = id[p];\n\t        }\n\t        return p;\n\t    }\n\n\t    public boolean connected(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\n\n\t    public void union(int p, int q) {\n\t        int i = find(p);\n\t        int j = find(q);\n\t        if (i == j) return;\n\n\t        // make root of smaller rank point to root of larger rank\n\t        if(rank[i] > rank[j]){\n\t        \trank[i]+=rank[j];\n\t        \tid[j]=i;\n\t        }\n\t        \n\t        else{\n\t        \trank[j]+=rank[i];\n\t        \tid[i]=j;\n\t        }\n\t        \n\t        \n\t    }\n\t    \n}\n       \n     \n    //////////////////////////////\n\t\n   \n    void solve() throws IOException{\n    \tint n=s.nextInt();\n    \tint m=s.nextInt();\n    \t\n    \tUF ob[]=new UF[m+1];\n    \tfor(int i=0;i<=m;i++){\n    \t\tob[i]=new UF(n+1);\n    \t}\n    \t\n    \tfor(int i=0;i<m;i++){\n    \t\tint a=s.nextInt();\n    \t\tint b=s.nextInt();\n    \t\tint c=s.nextInt();\n    \t\tob[c].union(a, b);\n    \t}\n    \tint q=s.nextInt();\n    \tfor(int i=0;i<q;i++){\n    \t\tint a=s.nextInt();\n    \t\tint b=s.nextInt();\n    \t\tint cnt=0;\n    \t\tfor(int j=1;j<=m;j++){\n    \t\t\tif(ob[j].connected(a, b))\n    \t\t\t\tcnt++;\n    \t\t}\n    \t\tww.println(cnt);\n    \t}\n    \t    \n    \n    \t\n    \t\n    \t\n    \t\t\t\n    \t\n \n    \t\t\n    } //solve\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint X[] = {1, -1, 0, 0};\nint Y[] = {0, 0, 1, -1};\nconst int N = 2e5 + 5;\nint n, m, q;\nvector<vector<int> > graph(101);\nmap<pair<int, int>, vector<int> > clr;\nvector<vector<int> > ans(101, vector<int>(101, 0));\nvoid bfs(int pos) {\n  queue<int> q;\n  q.push(pos);\n  vector<vector<int> > color(n + 1, vector<int>(m + 1));\n  for (int i = 1; i <= m; i++) color[pos][i] = 1;\n  vector<int> vis(n + 1, 0);\n  vis[pos] = 1000;\n  int now = 101;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int to : graph[u]) {\n      int cnt = 0;\n      vector<int> tmp = clr[make_pair(min(to, u), max(to, u))];\n      for (auto it : tmp) (color[u][it] == 1) ? color[to][it] = 1 : 1;\n      for (int i = 1; i <= m; i++) {\n        if (color[to][i]) cnt++;\n      }\n      if (vis[to] < cnt) {\n        vis[to] = cnt;\n        q.push(to);\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) ans[i][pos] = ans[pos][i] = vis[i];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  int a, b, c;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b >> c;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n    if (a > b) swap(a, b);\n    clr[make_pair(a, b)].push_back(c);\n  }\n  for (int i = 1; i <= n; i++) bfs(i);\n  cin >> q;\n  while (q--) {\n    cin >> a >> b;\n    cout << ans[a][b] << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static boolean graph[][][];\n    static boolean visited[][];\n    static int n, m;\n    \n    public static boolean dfs(int start, int target, int c) {\n        if(start == target) {\n            return true;\n        }\n        visited[c][start] = true;\n        for(int i = 1; i <= n; i++) {\n            if(graph[c][start][i] && !visited[c][i]) {\n                if(dfs(i, target, c))\n                    return true;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        graph = new boolean[m+1][n+1][n+1];\n        visited = new boolean[m+1][n+1];\n        for(int i = 0; i < m; i++) {\n            int a, b, c;\n            a = in.nextInt();\n            b = in.nextInt();\n            c = in.nextInt();\n            graph[c][a][b] = graph[c][b][a] = true;\n        }\n        int q = in.nextInt();\n        for(int i = 0; i < q; i++) {\n            int u, v;\n            u = in.nextInt();\n            v = in.nextInt();\n            int count = 0;\n            for(int j = 1; j <= m; j++) {\n                if(dfs(u, v, j)) {\n                    count++;\n                }\n                for(boolean[] row : visited)\n                    Arrays.fill(row, false);\n            }\n            System.out.println(count);\n        }\n        in.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from sys import setrecursionlimit as setrec\nsetrec(10010)\n\ndef dfs(i, s, cnt):\n    if colored[i][s] > 0: return\n    colored[i][s] = cnt\n    for t in g[i][s]:\n        dfs(i, t, cnt)\n\nver_n, edge_n = map(int, input().split())\ng = [[[] for _ in range(ver_n)] for _ in range(edge_n)]\nfor _ in range(edge_n):\n    a, b, c = map(lambda x: int(x)-1, input().split())\n    g[c][a].append(b)\n    g[c][b].append(a)\n\ncolored = [[0] * ver_n for _ in range(edge_n)]\nfor i in range(edge_n):\n    cnt = 1\n    for j in range(ver_n):\n        dfs(i, j, cnt)\n        cnt += 1\n\nq = int(input())\nfor i in range(q):\n    cnt = 0\n    u, v = map(lambda x: int(x)-1, input().split())\n    for j in range(edge_n):\n        if colored[j][u] == colored[j][v]:\n            cnt += 1\n    print(cnt)\n    \n    \n"
        },
        {
            "language": 3,
            "solution": "import copy\ninfo= list(map(int, input().split()))\nn=info[0]\nm=info[1]\nmat=[[[] for i in range(n)] for j in range(n)]\nfor i in range(m):\n    info= list(map(int, input().split()))\n    a=info[0]\n    b=info[1]\n    c=info[2]\n    mat[a-1][b-1].append(c)\n    mat[b-1][a-1].append(c)\nq=int(input())\nfor i in range(q):\n    info= list(map(int, input().split()))\n    u=info[0]-1\n    v=info[1]-1\n    l=[]\n    for j in range(n):\n        p=len(mat[u][j])\n        for h in range(p):\n            l.append(mat[u][j][h])\n    l=list(set(l))\n    p=len(l)\n    c=0\n    for j in range(p):\n        co=l[j]\n        lis=[False]*n\n        stk=[]\n        curr=u\n        while(True):\n            found=False\n            for h in range(n):\n                if(not(lis[h]) and co in mat[curr][h]):\n                    stk.append(curr)\n                    lis[h]=True\n                    curr=h\n                    found=True\n                    break\n            if(curr==v):\n                c+=1\n                break\n            if(not(found)):\n                if(len(stk)==0):\n                    break\n                curr=stk[-1]\n                stk.pop(-1)\n    print(c)"
        },
        {
            "language": 1,
            "solution": "n, m = [int(i) for i in raw_input().split()]\ngraph = {}\ncolors = set()\nfor i in range(1, n + 1):\n\tgraph[i] = {}\nfor i in range(m):\n\ta, b, c = [int(i) for i in raw_input().split()]\n\tcolors.add(c)\n\tif c in graph[a]:\n\t\tgraph[a][c].append(b)\n\telse:\n\t\tgraph[a][c] = [b]\n\tif c in graph[b]:\n\t\tgraph[b][c].append(a)\n\telse:\n\t\tgraph[b][c] = [a]\nq = int(raw_input())\n\ndef dfs(u, v, c):\n\tvisited, stack = set(), [u]\n\twhile stack:\n\t\tnode = stack.pop()\n\t\tif node not in visited:\n\t\t\tvisited.add(node)\n\t\t\tif c in graph[node]:\n\t\t\t\tfor neighbor in graph[node][c]:\n\t\t\t\t\tif neighbor == v:\n\t\t\t\t\t\treturn True\n\t\t\t\t\tstack.append(neighbor)\n\treturn False\n\t\nfor i in range(q):\n\tu, v = [int(i) for i in raw_input().split()]\n\tcount = 0\n\tfor c in colors:\n\t\tif dfs(u, v, c):\n\t\t\tcount += 1\n\tprint count\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n \n \npublic class Solution{\n    \n    ///////////////////////////////////////////////////////////////////////////\n    static class FastScanner{\n        BufferedReader s;\n        StringTokenizer st;\n        \n        public FastScanner(InputStream InputStream){\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader(new InputStreamReader(InputStream));\n        }\n        \n        public FastScanner(File f) throws FileNotFoundException{\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader (new FileReader(f));\n        }\n        \n        public int nextInt() throws IOException{\n            if(st.hasMoreTokens())\n                return Integer.parseInt(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextInt();\n            }\n        }\n        \n        public BigInteger big() throws IOException{\n            if(st.hasMoreTokens())\n                return new BigInteger(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return big();\n            }\n        }\n        \n        public double nextDouble() throws IOException{\n            if(st.hasMoreTokens())\n                return Double.parseDouble(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextDouble();\n            }\n        }\n      \n        public long nextLong() throws IOException{\n            if(st.hasMoreTokens())\n                return Long.parseLong(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextLong();\n            }\n        }\n        \n        public String nextString() throws IOException{\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextString();\n            }\n            \n        }\n        public String readLine() throws IOException{\n            return s.readLine();\n        }\n        \n        public void close() throws IOException{\n            s.close();\n        }\n        \n    }\n    \n    ////////////////////////////////////////////////////////////////////\n    //      Number Theory\n    \n    long pow(long a,long b,long mod){\n        if(b == 0)  return 1;\n        long t = pow(a,b>>1,mod);\n        t = (t * t) % mod;\n        if((b & 1) == 1)    t = (t * a);\n        if(t >= mod)    t %= mod;\n        return t;\n    }\n    \n    int divisor(long x,long[] a){\n        long limit = x;\n        int numberOfDivisors = 0;\n \n        for (int i=1; i < limit; ++i) {\n            if (x % i == 0) {\n                limit = x / i;\n                if (limit != i) {\n                    numberOfDivisors++;\n                }\n                numberOfDivisors++;\n            }\n        }\n        return numberOfDivisors;\n    }\n    \n    void findSubsets(int array[]){\n        long numOfSubsets = 1 << array.length; \n        for(int i = 0; i < numOfSubsets; i++){    \n            @SuppressWarnings(\"unused\")\n            int pos = array.length - 1;\n            int bitmask = i;\n            while(bitmask > 0){     \n                if((bitmask & 1) == 1)\n//                    ww.print(array[pos]+\" \");\n                bitmask >>= 1;\n                pos--;\n            }\n//            ww.println();\n        }\n    }\n    \n    \n    public static long gcd(long a, long b){\n        return b == 0 ? a : gcd(b,a%b);\n    }\n    \n  \n    public static long lcm(int a,int b, int c){\n        return lcm(lcm(a,b),c);\n    }\n    \n    public static long lcm(long a, long b){\n        return (a*b/gcd(a,b));\n    }\n    \n    public static long invl(long a, long mod) {\n        long b = mod;\n        long p = 1, q = 0;\n        while (b > 0) {\n            long c = a / b;\n            long d;\n            d = a;\n            a = b;\n            b = d % b;\n            d = p;\n            p = q;\n            q = d - c * q;\n        }\n        return p < 0 ? p + mod : p;\n    }\n    \n    ////////////////////////////////////////////////////////////////////\n    \n    \n//     FastScanner s = new FastScanner(new File(\"a.pdf\"));\n//   PrintWriter ww = new PrintWriter(new FileWriter(\"output.txt\")); \n    static InputStream inputStream = System.in;\n    static FastScanner s = new FastScanner(inputStream); \n    static OutputStream outputStream = System.out;\n    static PrintWriter ww = new PrintWriter(new OutputStreamWriter(outputStream));\n//      private static Scanner s = new Scanner(System.in);\n    @SuppressWarnings(\"unused\")\n    private static int[][] states = { {-1,0} , {1,0} , {0,-1} , {0,1} };\n    \n      \n    //////////////////////////////////////////////////////////////////// \n     \n    \n     \n    public static void main(String[] args) throws Exception{\n        new Solution().solve();\n        s.close();\n        ww.close();\n    }\n    \n\n    ////////////////////////////////////////////////////////////////////\n    \n    class Node{\n        int to;\n        int color;\n        Node(int to,int color){\n            this.to = to;\n            this.color = color;\n        }\n    }\n    \n    ArrayList<Node>[] a;\n    int an = 0;\n    boolean[][] vis;\n    \n    void dfs(int in,int col,int dst){\n        if(vis[in][col]) return;\n        vis[in][col] = true;\n        if(in == dst){\n            an++;\n            return;\n        }\n        for(Node x : a[in]){\n            Node node = x;\n            if(col == 0 || col == node.color)\n                dfs(node.to,node.color,dst);\n        }\n    }\n    \n    void solve() throws IOException  {\n    \n        int n = s.nextInt();\n        int m = s.nextInt();\n        \n        a = new ArrayList[n];\n        vis = new boolean[101][101];\n        \n        for(int i=0;i<a.length;i++) a[i] = new ArrayList<Node>();\n        \n        while(m-->0){\n            int x = s.nextInt()-1;\n            int y = s.nextInt()-1;\n            int color = s.nextInt();\n            a[x].add(new Node(y,color));\n            a[y].add(new Node(x,color));\n        }\n        \n        int q = s.nextInt();\n        while(q-->0){\n            an = 0;\n            for(int i=0;i<vis.length;i++) Arrays.fill(vis[i], false);\n            int x = s.nextInt()-1;\n            int y = s.nextInt()-1;\n            dfs(x,0,y);\n            ww.println(an);\n        }\n        \n    }\n        \n}   \n    \n\n\n"
        },
        {
            "language": 3,
            "solution": "\n#make a table\nn,m = map(int,input().split())\narr = [[] for i in range(n+1)]\nfor i in range(1,m+1):\n    l = list(map(int,input().split()))\n    arr[l[0]].append((l[1],l[2]))\n    arr[l[1]].append((l[0],l[2]))\n\n\n#dfs\ndef dfs(a,b,k):\n    if a == b:\n        return True\n    seen.append(a)\n    for i in arr[a]:\n        x,c = i\n        if c == k and x not in seen:\n            if dfs(x,b,k):\n                return True\n    return False\n    \nquery = int(input())\ncount = 0\nscore = [0]*(query)\nseen = []\n#get destination inputs\nfor i in range(query):\n    a,b = map(int,input().split())\n    for k in range(1,101):\n        seen = []\n        if dfs(a,b,k):\n            count += 1\n    score[i] = count\n    count = 0\n\nprint(\"\\n\".join(list(map(str,score))))"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\ndef dfs(adjlist, start, visited, nodes, color):\n    if start in visited:\n        return\n    \n    visited.add(start)\n    for (v,c) in adjlist[start]:\n        if c == color:\n            nodes[v-1] = nodes[start-1]\n            dfs(adjlist, v, visited, nodes, color)\n    \nif __name__ =='__main__':\n    n,m = map(int, input().split())\n    adjlist = defaultdict(list)\n    all_color = set()\n    for i in range(0,m):\n        tmp = list(map(int, input().split()))\n        adjlist[tmp[0]].append((tmp[1],tmp[2]))\n        adjlist[tmp[1]].append((tmp[0],tmp[2]))\n        all_color.add(tmp[2])\n    \n    num_queries = int(input())\n    queries = []\n    for i in range(0,num_queries):\n        queries.append(list(map(int, input().split())))\n    \n    color_map = {}\n    for c in all_color:\n        nodes = [i for i in range(1,n+1)]\n        for src in range(1,n+1):\n            visited = set()\n            dfs(adjlist, src, visited, nodes, c)\n            if len(visited) == n:\n                break\n        color_map[c] = nodes\n        \n    #print(color_map)\n    for q in queries:\n        count = 0\n        for c in color_map.keys():\n            if color_map[c][q[0]-1] == color_map[c][q[1]-1]:\n                count += 1\n        print(count)"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\ne = {}\nfor i in range(m):\n    a, b, c = map(int, raw_input().split())\n    x=min(a,b)\n    y=max(a,b)\n    if c not in e:\n        e[c] = [[x,y]]\n    else:\n        e[c].append([x,y])\n\ndef canmake(i, start, goal):\n    if sorted([start, goal]) in i:\n        return True\n    f = True\n    for xx in i:\n        if start in xx:\n            f = False\n            break\n    if f:\n        return False\n    \n    for xx in i:\n        if start in xx:\n            xxx = xx[:]\n            xxx.remove(start)\n            ii = i[:]\n            ii.remove(xx)\n            if canmake(ii, xxx[0], goal):\n                return True\n    return False\n    \n\ndef solve(ed):\n    count = 0\n    for a in e:\n        i = e[a]\n        if canmake(i, ed[0], ed[1]):\n            count += 1\n    return count\n\nq = input()\nfor i in range(q):\n    u, v = map(int, raw_input().split())\n    x=min(u,v)\n    y=max(u,v)\n    print solve([x, y])\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<pair<long long, long long>>> adj;\nvector<bool> visited;\nlong long ans;\nlong long u, v;\nbool dfs(long long node, long long color) {\n  visited[node] = true;\n  if (node == v) {\n    return 1;\n  }\n  long long sum = 0;\n  for (auto x : adj[node]) {\n    if (x.second == color && !visited[x.first]) {\n      sum += dfs(x.first, x.second);\n    }\n  }\n  return sum > 0 ? true : false;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  adj.resize(n + 1);\n  for (long long i = 0; i < m; i++) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back({b, c});\n    adj[b].push_back({a, c});\n  }\n  long long q;\n  cin >> q;\n  while (q--) {\n    cin >> u >> v;\n    ans = 0;\n    set<long long> s;\n    for (auto x : adj[u]) {\n      visited.clear();\n      visited.resize(n + 1, false);\n      visited[u] = true;\n      if (dfs(x.first, x.second)) {\n        s.insert(x.second);\n      }\n    }\n    cout << s.size() << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class B {\n\tstatic boolean visited[];\n\tstatic boolean graph[][][];\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\n\t\tgraph = new boolean[101][101][101];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt();\n\t\t\tint color = sc.nextInt();\n\t\t\tgraph[from][to][color] = graph[to][from][color] = true;\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint cnt = 0;\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tfor (int j = 1; j <= 100; j++) {\n\t\t\t\tvisited = new boolean[102];\n\t\t\t\tif (dfs(a, b, j)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tstatic boolean dfs(int u, int v, int color) {\n\t\tvisited[u] = true;\n\t\tif (u == v)\n\t\t\treturn true;\n\t\tboolean res = false;\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tif (graph[u][i][color] && !visited[i])\n\t\t\t\tres |= dfs(i, v, color);\n\t\t}\n\t\treturn res;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_505B {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner s = new Scanner(System.in);\n\t\tStringTokenizer st1 = new StringTokenizer(s.nextLine());\n\t\tint n = Integer.parseInt(st1.nextToken());\n\t\tint m = Integer.parseInt(st1.nextToken());\n\t\t\n\t\t//if(!(n == 100 && m == 100)) {\n\t\t\tint[][] djs = new int[101][n+1]; //color, vertex\n\t\t\tfor(int[] x : djs) {\n\t\t\t\tArrays.fill(x, -2);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint[] data = new int[3];\n\t\t\t\tStringTokenizer st = new StringTokenizer(s.nextLine());\n\t\t\t\tfor(int j = 0; j < 3; j++) data[j] = Integer.parseInt(st.nextToken());\n\t\t\t\t/**\n\t\t\t\tif(i == 61) {\n\t\t\t\t\tSystem.out.println(data[0] + \" \" + data[1] + \" \" + data[2]);\n\t\t\t\t\tfor(int x : djs[data[2]]) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t**/\n\t\t\t\tif(parentOf(data[0], djs[data[2]]) != parentOf(data[1], djs[data[2]])) {\n\t\t\t\t\tint parent = parentOf(data[0], djs[data[2]]);\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tif(parent == data[0]) {\n\t\t\t\t\t\tif(data[1] != parentOf(data[1], djs[data[2]])) {\n\t\t\t\t\t\t\tparent = parentOf(data[1], djs[data[2]]);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(first) {\n\t\t\t\t\t\tdjs[data[2]][parent] = -1;\n\t\t\t\t\t\tdjs[data[2]][parentOf(data[1], djs[data[2]])] = parent;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdjs[data[2]][data[0]] = parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(data[2]);\n\t\t\t\tcollapse(djs[data[2]]);\n\t\t\t}\n\t\t\t\n\t\t\tint t = Integer.parseInt(s.nextLine());\n\t\t\tint[][] tests = new int[t][2];\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(s.nextLine());\n\t\t\t\ttests[i][0] = Integer.parseInt(st.nextToken());\n\t\t\t\ttests[i][1] = Integer.parseInt(st.nextToken());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j = 1; j < 101; j++) {\n\t\t\t\t\tif(djs[j][tests[i][0]] > -2 && djs[j][tests[i][1]] > -2) {\n\t\t\t\t\t\tif(parentOf(tests[i][0], djs[j]) == parentOf(tests[i][1], djs[j])) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(count);\n\t\t\t}\n\t\t\t/**\n\t\t} else {\n\t\t\tint line = 0;\n\t\t\twhile(s.hasNext()) {\n\t\t\t\tif(line > 135) {\n\t\t\t\t\tSystem.out.println(s.nextLine());\n\t\t\t\t} else {\n\t\t\t\t\ts.nextLine();\n\t\t\t\t}\n\t\t\t\tline++;\n\t\t\t}\n\t\t}\n\t\t**/\n\t}\n\tprivate static void collapse(int[] arr) {\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tif(arr[i] > -1)\n\t\t\tarr[i] = parentOf(i, arr);\n\t\t}\n\t}\n\tprivate static int parentOf(int idx, int[] a) {\n\t\twhile(a[idx] > -1) {\n\t\t\tidx = a[idx];\n\t\t\t//System.out.println(idx);\n\t\t}\n\t\treturn idx;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}\n        String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());} \n        catch (IOException  e){e.printStackTrace();}}return st.nextToken();}\n        int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}\n        String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; } \n    }\n\tstatic FastReader sc = new FastReader();\n\tstatic List<pair> g[];\n\tpublic static void main (String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(System.out);\n        int k = 1;\n//        t = sc.nextInt();\n        z : while(k-->0) {\n        \tint n = sc.nextInt();\n    \t\tint m = sc.nextInt();\n    \t\tg = new LinkedList[n+1];\n    \t\tfor(int i=1;i<=n;i++) g[i] = new LinkedList<>();\n    \t\tfor(int i=0;i<m;i++) {\n    \t\t\tint u = sc.nextInt();\n    \t\t\tint v = sc.nextInt();\n    \t\t\tint c = sc.nextInt();\n    \t\t\tg[u].add(new pair(v,c));\n    \t\t\tg[v].add(new pair(u,c));\n    \t\t}\n    \t\tint q = sc.nextInt();\n    \t\twhile(q-->0) {\n    \t\t\tint u = sc.nextInt();\n    \t\t\tint v = sc.nextInt();\n    \t\t\tint cnt = 0;\n    \t\t\tboolean zxc[] = new boolean [m+1];\n    \t\t\tfor(pair p : g[u]) {\n        \t\t\tboolean vis[] = new boolean[n+1];\n        \t\t\tvis[u] = true;\n    \t\t\t\tif(!zxc[p.b] && dfs(p.a,v,p.b,vis)) {\n    \t\t\t\t\tcnt++;\n    \t\t\t\t\tzxc[p.b]= true; \n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tout.write(cnt+\"\\n\");\n    \t\t}\n      \t}\n\t\tout.close();\n\t}\n\tprivate static boolean dfs(int u, int v, int b, boolean[] vis) {\n\t\tvis[u] = true;\n\t\tif(u == v) return true;\n\t\t\n\t\tfor(pair p : g[u]) {\n\t\t\tif(!vis[p.a] && p.b == b)\n\t\t\t\tif(dfs(p.a,v,b,vis)) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\nclass pair implements Comparable<pair>{\n\tint a;\n\tint b; \n\tpair(int a,int b){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n    public int compareTo(pair p){\n        return this.b - p.b;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int N = 105;\nvector<pair<long long int, long long int>> adj[N];\nvector<bool> vis(N);\nbool dfs(long long int u, long long int v, long long int col) {\n  vis[u] = true;\n  if (u == v) {\n    return true;\n  }\n  for (auto i : adj[u]) {\n    long long int vert = i.first;\n    long long int color = i.second;\n    if (color == col && !vis[vert]) {\n      if (dfs(vert, v, col)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nvoid assignFalse() {\n  for (long long int i = 0; i < N; i++) {\n    vis[i] = false;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, m;\n  cin >> n >> m;\n  for (long long int i = 1; i <= m; i++) {\n    long long int u, v, c;\n    cin >> u >> v >> c;\n    adj[u].push_back({v, c});\n    adj[v].push_back({u, c});\n  }\n  long long int Q;\n  cin >> Q;\n  while (Q--) {\n    long long int cnt = 0;\n    long long int u, v;\n    cin >> u >> v;\n    for (long long int i = 1; i <= 100; i++) {\n      assignFalse();\n      if (dfs(u, v, i)) {\n        cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B_MrKitayutasColorfulGraph {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt(), m = inp.nextInt();\n            DSU[] dsu = new DSU[m];\n            for (int i = 0; i < m; i++) dsu[i] = new DSU(n);\n            for (int i = 0; i < m; i++) {\n                int u = inp.nextInt() - 1, v = inp.nextInt() - 1, c = inp.nextInt() - 1;\n                if (!dsu[c].sameSet(u, v)) dsu[c].union(u, v);\n            }\n            int q = inp.nextInt();\n            for (int i = 0; i < q; i++) {\n                int u = inp.nextInt() - 1, v = inp.nextInt() - 1;\n                int res = 0;\n                for (DSU d: dsu) if (d.sameSet(u, v)) res++;\n                out.println(res);\n            }\n        }\n\n        public class DSU {\n            private int[] parents, rank;\n\n            public DSU(int n) {\n                parents = new int[n];\n                rank = new int[n];\n                for (int i = 0; i < n; i++) parents[i] = -1;\n            }\n\n            public int findParent(int node) {\n                if (parents[node] == -1) return node; //recursively search\n                int parent = findParent(parents[node]);\n                parents[node] = parent; //don't search another time for parent\n                return parent;\n            }\n\n            public void union(int x, int y) {\n                int xParent = findParent(x), yParent = findParent(y);\n                if (rank[x] < rank[y]) parents[xParent] = yParent;\n                else if (rank[x] > rank[y]) parents[yParent] = xParent;\n                else {\n                    parents[yParent] = xParent;\n                    rank[xParent]++;\n                }\n            }\n\n            public boolean sameSet(int x, int y) {\n                return findParent(x) == findParent(y);\n            }\n        }\n    }\n\n\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "scanf = lambda:map(int,input().split())\nn,m  = scanf()\nf = [list(range(n+1)) for _ in range(m+2)]\ndef fd(a,c):\n    if f[c][a]!=a:f[c][a] = fd(f[c][a],c)\n    return f[c][a]\ndef un(a,b,c):\n    ra,rb = fd(a,c),fd(b,c)\n    if ra==rb:return\n    f[c][ra] = rb\ndef swap(a,b):\n    tmp = a\n    a = b\n    b = tmp\nfor a,b,c in [map(int,input().split()) for _ in range(m)]:\n    un(a,b,c)\nq = int(input())\nfor x,y in [map(int,input().split()) for _ in range(q)]:\n    print(sum(1 for i in range(1,m+1) if fd(x,i) == fd(y,i)))"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\n\npublic class graph {\n    static ArrayList<ArrayList<int[]>> graph=new ArrayList<>();\n    static HashSet<Integer> hs=new HashSet<>();\n    // static int ct=0;\n    public static void dfs(int s,int targ,int lc,boolean[] vd){\n        if(s==targ){\n            hs.add(lc);\n            // ct++;\n            return ;\n        }\n\n        for(int[] nbr:graph.get(s)){\n\n            if(!vd[nbr[0]] && (nbr[1]==lc || lc==-1)){\n                vd[nbr[0]]=true;\n                dfs(nbr[0], targ, nbr[1], vd);\n                vd[nbr[0]]=false;\n            }\n        }\n    }\n    public static void main(String[] args) throws Exception{\n                InputStreamReader ip=new InputStreamReader(System.in);\n                BufferedReader br = new BufferedReader(ip);\n        \t\t// int n = Integer.parseInt(br.readLine());\n        \t\t// StringBuilder sb = new StringBuilder();\n                // ArrayList<Integer> list=new ArrayList<>();\n        \n                String[] strs=(br.readLine()).trim().split(\" \");\n                \n                int n=Integer.parseInt(strs[0]);\n                int m=Integer.parseInt(strs[1]);\n\n                for(int i=0;i<=n;i++){ graph.add(new ArrayList<>());}\n              \n\n               for(int i=0;i<m;i++){\n                strs=(br.readLine()).trim().split(\" \");\n                int u=Integer.parseInt(strs[0]);\n                int v=Integer.parseInt(strs[1]);\n                int w=Integer.parseInt(strs[2]);\n\n                (graph.get(u)).add(new int[]{v,w});\n                (graph.get(v)).add(new int[]{u,w});\n               }\n               \n               int q=Integer.parseInt(br.readLine());\n\n               boolean[] vd=new boolean[n+1];\n               for(int i=0;i<q;i++){\n                strs=(br.readLine()).trim().split(\" \");\n                int u=Integer.parseInt(strs[0]);\n                int v=Integer.parseInt(strs[1]);\n                // ct=0;\n                hs=new HashSet<>();\n                vd[u]=true;\n                dfs(u,v,-1,vd);\n                vd[u]=false;\n                // ans+=ct;\n                System.out.println(hs.size());\n               }\n\n               \n    }\n\n}\n\n\n//     static long mod=10000_00007;\n//     // Approach\n//     // Property: Look at one tree and take its diameter. Name its endpoints A and B. \n//     //For each vertex u from this component, p[u]\u2009=\u2009A or p[u]\u2009=\u2009B. It's easy to prove that.\n//     //We can just count number of different elements in P and divide it by two.\n//    //Special case : Isolated vertices (those with p[i]\u2009=\u2009i).\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n// \t\t// StringBuilder sb = new StringBuilder();\n//         ArrayList<Integer> list=new ArrayList<>();\n\n//         String[] strs=(br.readLine()).trim().split(\" \");\n\n//         int[] arr=new int[n];\n//         HashSet<Integer> hs=new HashSet<>();\n\n//         long ans=0;\n//         for(int i=0;i<n;i++){\n//             int val=Integer.parseInt(strs[i]);\n//             if(val==(i+1)){ans++;}\n//             else{hs.add(val);}\n//         }\n//         ans+=(hs.size()/2);\n//         System.out.println(ans);\n//     }\n// }\n\n\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n//         ArrayList<Integer> list=new ArrayList<>();\n\n//         if(n%4==0 || n%4==2){\n//             for(int i=1;i<=n;i++){\n//                 if(i%4==1 || i%4==0){\n//                    list.add(i); // System.out.print(i+\" \");\n//                 }\n//             }\n//         }else if(n%4==1){\n//             for(int i=1;i<=(1+(n/4));i++){\n//                 list.add(i);//System.out.print(i+\" \");\n//             }\n//             for(int i=((n-(n/4))+1);i<=(n);i++){\n//                 list.add(i);// System.out.print(i+\" \");\n//             }\n//         }else if(n%4==3){\n//             for(int i=1;i<=((n/4));i++){\n//                 list.add(i);// System.out.print(i+\" \");\n//             }\n//             for(int i=((n-(n/4)));i<=(n);i++){\n//                 list.add(i); //System.out.print(i+\" \");\n//             }\n//         }\n//         if(n%4==0 || n%4==3){System.out.println(0);}\n//         else{System.out.println(1);}\n        \n//         System.out.print(list.size()+\" \");\n//         for(int val:list){System.out.print(val+\" \");}\n//         System.out.println();\n//     }\n// }\n\n\n\n\n\n\n    // public static int find(int a,int[] p){\n    //     if(a!=p[a]){return p[a]=find(p[a], p);}\n    //     else{return a;}\n    // }\n    // public static int findrank(int a,int[] p,int [] r){\n    //     if(a!=p[a]){return findrank(p[a], p,r);}\n    //     else{return r[a];}\n    // }\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \t// int t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \t// while (t-- > 0) {\n    //         String[] str = (br.readLine()).trim().split(\" \");\n    //         int n = Integer.parseInt(str[0]);\n    //         int m=Integer.parseInt(str[1]);\n    //         int[] parent=new int[n+1];\n    //         int[] rank=new int[n+1];\n    //         for(int i=0;i<=n;i++){parent[i]=i; rank[i]=1;}\n\n    //         for(int i=0;i<m;i++){\n    //             str = (br.readLine()).trim().split(\" \");\n\n    //             int k=Integer.parseInt(str[0]);\n\n    //             for(int j=2;j<str.length;j++){\n    //                 int a=Integer.parseInt(str[j-1]);\n    //                 int b=Integer.parseInt(str[j]);\n    //                 int la=find(a, parent),lb=find(b, parent);\n    //                 if(la!=lb){\n    //                     if(rank[la]<rank[lb]){int tmp=la; la=lb; lb=tmp;}\n\n    //                     rank[la]+=rank[lb];\n    //                     parent[lb]=la;\n    //                 }\n    //             }\n    //         }\n\n    //         for(int i=1;i<=n;i++){\n    //             int ans=findrank(i,parent,rank);\n    //             System.out.print(ans+\" \");  //\" r=\"+rank[i]+\"  \"\n    //         }\n    //         System.out.println();\n    //     }\n    // }\n\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n//             String[] str = (br.readLine()).trim().split(\" \");\n//             int n = Integer.parseInt(str[0]);\n//             int m=Integer.parseInt(str[1]);\n//             int k = Integer.parseInt(str[2]);\n            \n//             int[][] arr=new int[m][3];\n\n//             for(int i=0;i<m;i++){\n//                 str = (br.readLine()).trim().split(\" \");\n//                 arr[i][0]=Integer.parseInt(str[0]);\n//                 arr[i][1]=Integer.parseInt(str[1]);\n//                 arr[i][2]=Integer.parseInt(str[2]);\n//             }\n            \n//             if(k==0){\n//                 System.out.println(-1); \n//                 return;\n//             }\n\n//             boolean[] flr=new boolean[n+1];\n//             str = (br.readLine()).trim().split(\" \");\n//             for(int i=0;i<k;i++){\n//                 int idx=Integer.parseInt(str[i]);\n//                 flr[idx]=true;\n//             }\n\n//             int ans=Integer.MAX_VALUE;\n\n//             for(int i=0;i<m;i++){\n//                 if((flr[arr[i][0]] && !flr[arr[i][1]]) || (!flr[arr[i][0]] && flr[arr[i][1]])){\n//                     ans=Math.min(ans,arr[i][2]);\n//                 }\n//             }\n\n//             if(ans==Integer.MAX_VALUE){\n//                 System.out.println(-1);\n//             }else{\n//                 System.out.println(ans);\n//             }\n//         // }\n//     }\n// }\n\n\n\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \tint t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \twhile (t-- > 0) {\n    //         int n = Integer.parseInt(br.readLine());\n    //         String str = (br.readLine()).trim();\n\n    //         int cw=0,acw=0,bh=0;\n    //         int ans=0;\n    //         for(int i=0;i<n;i++){\n    //             if(str.charAt(i)=='-'){\n    //                 if(str.charAt(((i-1)+n)%n)==str.charAt(i)){\n    //                     ans++;\n    //                 }else{\n    //                     ans+=2;\n    //                 }\n    //                 bh++;\n    //             }else if(str.charAt(i)=='>'){\n    //                 cw++;\n    //             }else{\n    //                 acw++;\n    //             }\n    //         }\n\n    //         if(acw==n || cw==n || bh==n){\n    //             System.out.println(n);\n    //         }else if((acw+bh)==n || (cw+bh)==n){\n    //             System.out.println(n);\n    //         }else{\n    //             System.out.println(ans);\n    //         }\n    //     }\n    //     }\n\n    // }\n\n\n//      public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n// \t\t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n//             int n = Integer.parseInt(arrp[0]);\n//             int m= Integer.parseInt(arrp[1]);\n            \n//             String[] str = (br.readLine()).trim().split(\" \");\n//             int[] cost=new int[n+1];\n//             for(int i=0;i<n;i++){\n//                 cost[i+1]=Integer.parseInt(str[i]);\n//             }\n//             long ans=0;\n//             for(int i=0;i<m;i++){\n//                 str = (br.readLine()).trim().split(\" \");\n\n//                 int u=Integer.parseInt(str[0]);\n//                 int v=Integer.parseInt(str[1]);\n//                 ans+=Math.min(cost[u],cost[v]);\n//             }\n\n//             System.out.println(ans);\n//         // }\n//     }\n// } \n    \n//     public static long binexp(long a,long b){\n//         long res=1;\n//         while(b>0){\n//             if((b&1)==1){\n//                 res=res*a;  res=res%mod;\n//             }\n//             a=a*a; a=a%mod;\n//             b>>=1;\n//         }\n//         return res;\n//     }\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\tint n = Integer.parseInt(br.readLine());\n//         // StringBuilder sb = new StringBuilder();\n        \n//         long fact=1;\n//         for(int i=1;i<=n;i++){\n//             fact=((long)(fact*(long)(i)));\n//             fact=fact%mod;\n//         }\n\n//         long ump=binexp(2, n-1);//(long)(Math.pow(2, n-1));\n//         ump=ump%mod;\n//         long ans=fact-ump;\n//         if(ans<0){ans+=mod;}\n//         System.out.println(ans);\n//     }\n// }\n\n\n\n    // public static void main(String[] args) throws Exception{\n    //     InputStreamReader ip=new InputStreamReader(System.in);\n    //     BufferedReader br = new BufferedReader(ip);\n\t// \t// int t = Integer.parseInt(br.readLine());\n\t// \tStringBuilder sb = new StringBuilder();\n \n\t// \t// while (t-- > 0) {\n\t// \t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n    //         int n = Integer.parseInt(arrp[0]);\n    //         int m= Integer.parseInt(arrp[1]);\n            \n    //         boolean[] invalid=new boolean[n+1];\n    //         for(int i=0;i<m;i++){\n    //             String[] pr = (br.readLine()).trim().split(\" \");\n    //             int val=Integer.parseInt(pr[0]);\n    //             invalid[val]=true;\n    //             val=Integer.parseInt(pr[1]);\n    //             invalid[val]=true;\n    //         }\n    //         int valid=-1;\n    //         for(int i=1;i<=n;i++){\n    //             if(!invalid[i]){valid=i; break;}\n    //         }            \n\n    //         System.out.println(n-1);\n    //         for(int i=1;i<=n;i++){\n    //             if(i!=valid){System.out.println(valid+\" \"+i);}\n    //         }\n    //     }\n    // }\n\n\n\n  //Q1  \n//     static int mcost=0;\n//     public static void dfs(ArrayList<ArrayList<Integer>> graph,int s,boolean[] visited,int[] cost){\n//         mcost=Math.min(mcost,cost[s-1]);\n//         visited[s]=true;\n//         for(int nbr:graph.get(s)){\n//             if(visited[nbr]==false){\n//                 dfs(graph,nbr,visited,cost);\n//             }\n//         }\n//     }\n//     public static void main(String[] args) throws Exception{\n//         InputStreamReader ip=new InputStreamReader(System.in);\n//         BufferedReader br = new BufferedReader(ip);\n// \t\t// int t = Integer.parseInt(br.readLine());\n// \t\tStringBuilder sb = new StringBuilder();\n \n// \t\t// while (t-- > 0) {\n// \t\t\tString[] arrp = (br.readLine()).trim().split(\" \");\n           \n//             int n = Integer.parseInt(arrp[0]);\n//             int m= Integer.parseInt(arrp[1]);\n            \n//             String[] strs = (br.readLine()).trim().split(\" \");\n//             int[] cost=new int[n];\n//             ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\n//             graph.add(new ArrayList<>());\n//             for(int i=0;i<n;i++){\n//                 cost[i]=Integer.parseInt(strs[i]);\n//                 graph.add(new ArrayList<>());\n//             }\n\n            \n//             for(int i=0;i<m;i++){\n//                 arrp = (br.readLine()).trim().split(\" \");\n//                 int u = Integer.parseInt(arrp[0]);\n//                 int v= Integer.parseInt(arrp[1]);\n\n//                 (graph.get(u)).add(v);\n//                 (graph.get(v)).add(u);\n//             }\n\n//             //dfs\n//             boolean[] visited=new boolean[n+1];\n//             long ans=0;\n//             for(int i=1;i<=n;i++){\n//                 if(visited[i]==false){\n//                     mcost=Integer.MAX_VALUE;\n//                     dfs(graph,i,visited,cost);\n//                     ans+=mcost;\n//                 }\n//             }\n\n//             System.out.println(ans);\n//         // }\n//     }\n// }\n\n\n"
        },
        {
            "language": 1,
            "solution": "n,m = map(int,raw_input().split())\ncolors = [{j:j for j in range(1,n)} for i in xrange(m)]\n\ndef find(i,parent):    \n    if i not in parent:\n        parent[i] = i\n    while i != parent[i]:\n        i = parent[i];\n    return i\n\ndef union(i, j,parent):\n    i = find(i,parent)\n    j = find(j,parent)\n    parent[i] = j\n    \nfor i in xrange(m):\n    a,b,c = map(int,raw_input().split())\n    union(a,b,colors[c-1])\n\n       \nq = int(raw_input())\nfor i in xrange(q):\n    u,v = map(int,raw_input().split())\n    count = 0\n    for c in colors:\n        if find(u,c) == find(v,c):\n            count += 1\n    print count\n        \n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, q, a, b, c, s, t;\nbool v[105];\nvector<int> adj[105][105];\nint dp[105][105][105];\nint dfs(int par, int cur, int t, int cg) {\n  v[cur] = true;\n  if (cur == t) return 1;\n  int ret = 0;\n  for (int x : adj[cur][cg]) {\n    if (v[x]) continue;\n    ret += dfs(cur, x, t, cg);\n  }\n  dp[cur][t][cg] = ret;\n  return dp[cur][t][cg];\n}\nint main() {\n  memset(dp, 0, sizeof dp);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d%d%d\", &a, &b, &c);\n    adj[a][c].push_back(b);\n    adj[b][c].push_back(a);\n  }\n  scanf(\"%d\", &q);\n  for (int i = 1; i <= q; i++) {\n    scanf(\"%d%d\", &s, &t);\n    int ans = 0;\n    for (int j = 1; j <= m; j++) {\n      memset(v, 0, sizeof v);\n      ans += dfs(0, s, t, j);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> v[101];\nvector<pair<long long int, long long int>> con[101];\nbool f;\nbool b[101];\nvoid dfs(long long int u, long long int u1) {\n  if (b[u] == true || f) return;\n  if (u == u1) {\n    f = true;\n    return;\n  }\n  b[u] = true;\n  for (auto ad : v[u]) dfs(ad, u1);\n}\nint main() {\n  long long int t = 1;\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  while (t--) {\n    long long int i, j, k, m, n, u, v1, c, q;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n      cin >> u >> v1 >> c;\n      con[c].push_back({u, v1});\n    }\n    cin >> q;\n    long long int ans[101];\n    for (int i = 0; i < 101; i++) ans[i] = 0;\n    long long int qu[101][2];\n    for (int i = 0; i < q; i++) cin >> qu[i][0] >> qu[i][1];\n    for (i = 1; i <= m; i++) {\n      for (int j = 0; j < 101; j++) v[j].clear();\n      for (int j = 0; j < 101; j++) b[j] = false;\n      for (j = 0; j < con[i].size(); j++) {\n        v[con[i][j].first].push_back(con[i][j].second);\n        v[con[i][j].second].push_back(con[i][j].first);\n      }\n      for (j = 0; j < q; j++) {\n        f = false;\n        for (int k = 0; k < 101; k++) b[k] = false;\n        dfs(qu[j][0], qu[j][1]);\n        if (f) ans[j + 1]++;\n      }\n    }\n    for (int i = 1; i < q + 1; i++) cout << ans[i] << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class KitayutaColorfulGraph {\n    public static void main(String asd[])throws Exception\n    {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int m=in.nextInt();\n        int a[][][]=new int[n][n][m+1];\n        int b[]=new int[m+1];\n        for(int i=0;i<m;i++)\n        {\n            int q=in.nextInt()-1;\n            int w=in.nextInt()-1;\n            int c=in.nextInt();\n            a[q][w][c]=1;a[w][q][c]=1;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++)\n                for(int j=0;j<n;j++)\n                    for(int g=1;g<=m;g++)\n                        if(a[i][k][g]==1 && a[k][j][g]==1){\n                            a[i][j][g]=1;\n                            a[j][i][g]=1;\n                        }\n        }\n        int k=in.nextInt();int e=0;\n        for(int i=0;i<k;i++)\n        {\n            Arrays.fill(b,0);e=0;\n            int u=in.nextInt()-1;\n            int v=in.nextInt()-1;\n            for(int ii=1;ii<=m;ii++)\n                for(int kk=0;kk<n;kk++)\n                {\n                    if(a[u][v][ii]!=0)\n                    {\n                        if(b[ii]==0)\n                        {\n                            e+=1;\n                            b[ii]=1;\n                        }\n                    }\n                       }\n                    \n             System.out.println(e);\n        \n    }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class acm {\n\n\tstatic int n , m ,ans;\n\tstatic ArrayList<ArrayList<Pair>>graph;\n\tstatic boolean vis[],cVis[];\n\t\n\tpublic static void dfs(int cur,int end,int col) {\n\t\t\n\t\tif(vis[cur])\n\t\t\treturn ;\n\t\tvis[cur]=true;\n\t\tif(cur==end)\n\t\t{\n\t\t\t\n\t\t\tans++;\n\t\t\treturn;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<graph.get(cur).size();i++)\n\t\t{\n\t\t\tif(graph.get(cur).get(i).c==col&&!vis[graph.get(cur).get(i).x])\n\t\t\t\tdfs(graph.get(cur).get(i).x,end,col);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tn=in.nextInt();m=in.nextInt();\n\t\tgraph=new ArrayList<ArrayList<Pair>>();\n\t\t\n\t\tfor(int i=0;i<=n+1;i++)\n\t\t\tgraph.add(new ArrayList<Pair>());\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint u=in.nextInt(),v=in.nextInt(),c=in.nextInt();\n\t\t\tgraph.get(u).add(new Pair(v,c));\n\t\t\tgraph.get(v).add(new Pair(u,c));\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint q=in.nextInt();\n\t\twhile(q-->0)\n\t\t{\n\t\t\t\n\t\t\tvis=new boolean[130];\n\t\t\tcVis=new boolean[130];\n\t\t\tans=0;\n\t\t\tint x=in.nextInt(),y=in.nextInt();\n\t\t\tfor(int i=0;i<graph.get(x).size();i++)\n\t\t\t{\n\t\t\t\tif(!cVis[graph.get(x).get(i).c])\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tcVis[graph.get(x).get(i).c]=true;\n\t\t\t\t\tdfs(x,y,graph.get(x).get(i).c);\n\t\t\t\t\tArrays.fill(vis, false);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\t}\npublic static class Pair {\n\tint x ,c ;\n\t\n\n\tpublic Pair(int xc,int color)\n\t{\n\t\tx=xc;\n\t\tc=color;\n\t}\n\n\t\n\t\n}\t\n\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    int a[];\n    List<List<Node>> gr = new ArrayList<>();\n    int k = 0;\n\n    int used[];\n    void dfs(int v, int c) {\n        used[v] = 1;\n\n        for (Node next: gr.get(v)) {\n            if (used[next.v] != 0 || next.c != c) {\n                continue;\n            }\n            dfs(next.v, c);\n        }\n    }\n\n    void solve() {\n        int n = scanner.nextInt(), m = scanner.nextInt();\n\n        for (int i = 0; i < n; i++) {\n            gr.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1, c = scanner.nextInt() - 1;\n            gr.get(u).add(new Node(v, c));\n            gr.get(v).add(new Node(u, c));\n        }\n\n        int q = scanner.nextInt();\n\n        for (int i = 0; i < q; i++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;\n            int ans = 0;\n            for (int j = 0; j < m; j++) {\n                used = new int[n];\n                dfs(u, j);\n                ans += used[v];\n            }\n            out.println(ans);\n        }\n    }\n\n    class Node {\n        int v;\n        int c;\n\n        public Node(int v, int c) {\n            this.v = v;\n            this.c = c;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def find(c, x):\n    p = dsu[c]\n    if x == p[x]:\n        return x\n    return find(c, p[x])\n\ndef union(c, x, y):\n    x = find(c, x)\n    y = find(c, y)\n    if x == y:\n        return\n    p = dsu[c]\n    p[x] = y\n\nn, m = map(int, input().split())\ndsu = [[i for i in range(n + 1)] for _ in range(m + 1)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    union(c, a, b)\n\nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n    count = 0\n    for c in range(1, m + 1):\n        if find(c, a) == find(c, b):\n            count += 1\n    print(count)\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\n\ngraphs = {}\nfor i in range(m):\n\ta, b, c = map(int, raw_input().split())\n\tif c in graphs:\n\t\tgraph = graphs[c]\n\telse:\n\t\tgraphs[c] = {}\n\t\tgraph = graphs[c]\n\tif a not in graph:\n\t\tgraph[a] = {}\n\tif b not in graph:\n\t\tgraph[b] = {}\n\tgraph[a][b] = 1\n\tgraph[b][a] = 1\n\n\ndef dfs(graph, curr, dest, visited):\n\tvisited[curr] = True\n\tif curr == dest:\n\t\treturn True\n\telse:\n\t\tif curr in graph:\n\t\t\tfor neighbour in graph[curr]:\n\t\t\t\tif neighbour not in visited: \n\t\t\t\t\tres = dfs(graph, neighbour, dest, visited)\n\t\t\t\t\tif res == True:\n\t\t\t\t\t\treturn True\n\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n\n\nq = int(raw_input())\nfor i in range(q):\n\ta, b = map(int, raw_input().split())\n\tcount = 0\n\tfor colour in graphs.keys():\n\t\tif dfs(graphs[colour], a, b, {}):\n\t\t\tcount += 1\n\tprint count\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n *\n * @author Meo Nam\n */\npublic class UVA {\n    static List<ArrayList<Edge>> list = new ArrayList(100);\n    static List<Set<Integer>> color = new ArrayList(100);\n    static boolean checked = false;\n    static class Edge {\n        public int x;\n        public int y;\n        public int c;\n        \n        public Edge(int x, int y, int c) {\n            this.x = x;\n            this.y = y;\n            this.c = c;\n        }\n    }\n    \n    static void dfs(int u, boolean[] isVisited, int color, int v) {\n        isVisited[u] = true;\n        if (u == v )  {\n            checked = true;\n        }\n        \n        for (Edge e : list.get(u)) {\n            if (!isVisited[e.y] && e.c == color) {\n                dfs(e.y, isVisited, color, v);\n            }\n        }\n        //return false;\n    }\n    \n    \n    public static void main(String arg[]) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        for (int i=0; i<=n+1; i++) {\n           list.add(i,new ArrayList<Edge>() );\n           color.add(i,new TreeSet<Integer>());\n        }\n        //list.add(new ArrayList<Edge>());\n        //color.add(new ArrayList<Integer>());\n        for (int i=0; i<m; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            \n            list.get(a).add(new Edge(a,b,c));\n            list.get(b).add(new Edge(b,a,c));\n            \n            color.get(a).add(c);\n            color.get(b).add(c);\n        }\n        int q = sc.nextInt();\n        \n        boolean [] isVisited = new boolean[n+1];\n        for (int k=0; k<=n; k++) {\n               isVisited[k] = false;\n        }\n        for (int i=0; i<q; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n           \n            int count = 0;\n            for (int c : color.get(u)) {\n                if (color.get(v).contains(c)) {\n                    checked = false;\n                    for (int k=1; k<=n; k++) {\n                        isVisited[k] = false;\n                    }\n                     dfs(u, isVisited, c, v);\n                     if (checked)    \n                        count++;\n                    \n                }\n            }\n            System.out.println(count);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mxn = 233;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) f = c == '-' ? -1 : 1, c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long ksm(long long a, long long b, long long mod) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long inv2(long long a, long long mod) { return ksm(a, mod - 2, mod); }\nvoid exgcd(long long a, long long b, long long &x, long long &y, long long &d) {\n  if (!b) {\n    d = a;\n    x = 1;\n    y = 0;\n  } else {\n    exgcd(b, a % b, y, x, d);\n    y -= x * (a / b);\n  }\n}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint n, m, f[mxn][mxn];\nvoid init() {\n  for (int i = 1; i < mxn; ++i)\n    for (int j = 1; j < mxn; ++j) f[i][j] = j;\n}\nint find(int u, int c) {\n  int rt = u;\n  while (f[c][rt] != rt) rt = f[c][rt];\n  int y = u;\n  while (y != rt) {\n    int t = f[c][y];\n    f[c][y] = rt;\n    y = t;\n  }\n  return rt;\n}\nvoid join(int u, int v, int c) {\n  int fu = find(u, c), fv = find(v, c);\n  if (fu != fv) f[c][fu] = fv;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  ;\n  cin >> n >> m;\n  init();\n  int u, v, c;\n  for (int i = 1; i <= m; ++i) {\n    cin >> u >> v >> c;\n    join(u, v, c);\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> u >> v;\n    int res = 0;\n    for (int i = 1; i <= m; ++i)\n      if (find(u, i) == find(v, i)) res++;\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport javax.swing.text.InternationalFormatter;\n\nimport java.math.*;\n\nimport org.omg.CORBA.Any;\n\npublic class template {\n\n\tstatic long time = 0, mp = Integer.MAX_VALUE, k = 0, cnt = 0, edge = 0, no = 0;\n\n\tstatic int[] bp;\n\tstatic int[] low;\n\tstatic int[] des;\n\tstatic boolean bipar = true;\n\tstatic String sb = \"\";\n\tstatic ArrayList<pair>[] a;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader scn = new Reader();\n\n\t\tint n = scn.nextInt(), m = scn.nextInt();\n\t\ta = new ArrayList[n + 1];\n\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = new ArrayList<pair>();\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint x = scn.nextInt(), y = scn.nextInt(), z = scn.nextInt();\n\t\t\ta[x].add(new pair(y, z));\n\t\t\ta[y].add(new pair(x, z));\n\t\t}\n\n\t\tint q = scn.nextInt();\n\n\t\twhile (q-- != 0) {\n\t\t\tint u = scn.nextInt(), v = scn.nextInt();\n\t\t\tcnt = 0;\n\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tdfs(u, v, i, new HashSet<Integer>());\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\n\t}\n\n\tprivate static void dfs(int u, int v, int c, HashSet<Integer> visited) {\n\t\tif (u == v) {\n\t\t\tcnt++;\n\t\t\t\n\t\t}\n\n\t\tvisited.add(u);\n\n\t\tfor (pair p : a[u]) {\n\n\t\t\tif (!visited.contains(p.v) && p.clr == c) {\n\n\t\t\t\tdfs(p.v, v, c, visited);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint v = 0;\n\t\tint clr = 0;\n\t\t// int cnt;\n\n\t\tpair(int b, int a) {\n\t\t\tv = b;\n\t\t\tclr = a;\n\t\t\t// cnt = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\t// return -this.sum + o.sum;\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// -----------PrintWriter for faster output---------------------------------\n\tpublic static PrintWriter out;\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[100000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n\n\t// private static void rem(HashMap<Integer, Integer> hm) {\n\t//\n\t// Iterator<Map.Entry<Integer, Integer>> itr = hm.entrySet().iterator();\n\t// ArrayList<Integer> p=new ArrayList<>();\n\t//\n\t//\n\t// while(itr.hasNext()){\n\t// Map.Entry<Integer, Integer> entry = itr.next();\n\t// p.add(entry.getKey());\n\t//\n\t// }\n\t//\n\t//\n\t// for(int i:p){\n\t//\n\t// if(hm.get(i)>1)\n\t// hm.put(i, hm.get(i)-1);\n\t// else\n\t// hm.remove(i);\n\t// }\n\t// }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mxn = 233;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) f = c == '-' ? -1 : 1, c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long ksm(long long a, long long b, long long mod) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long inv2(long long a, long long mod) { return ksm(a, mod - 2, mod); }\nvoid exgcd(long long a, long long b, long long &x, long long &y, long long &d) {\n  if (!b) {\n    d = a;\n    x = 1;\n    y = 0;\n  } else {\n    exgcd(b, a % b, y, x, d);\n    y -= x * (a / b);\n  }\n}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint n, m, f[mxn][mxn];\nvoid init() {\n  for (int i = 1; i < mxn; ++i)\n    for (int j = 1; j < mxn; ++j) f[i][j] = j;\n}\nint find(int u, int c) {\n  int i;\n  for (i = u; i != f[c][i]; i = f[c][i]) f[c][i] = f[c][f[c][i]];\n  return i;\n}\nvoid join(int u, int v, int c) {\n  int fu = find(u, c), fv = find(v, c);\n  if (fu != fv) f[c][fu] = fv;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  ;\n  cin >> n >> m;\n  init();\n  int u, v, c;\n  for (int i = 1; i <= m; ++i) {\n    cin >> u >> v >> c;\n    join(u, v, c);\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> u >> v;\n    int res = 0;\n    for (int i = 1; i <= m; ++i)\n      if (find(u, i) == find(v, i)) res++;\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split(' '))\nmp = [[set() for j in range(0, n)] for i in range(0, n)]\nfor i in range(0, m):\n    a, b, c = map(int, raw_input().split(' '))\n    a -= 1\n    b -= 1\n    if c not in mp[a][b]:\n        mp[a][b].add(c)\n        mp[b][a].add(c)\n# print mp\nfor k in range(0, n):\n    for i in range(0, n):\n        for j in range(0, n):\n            mp[i][j] |= (mp[i][k]&mp[k][j])\n# print mp\nq = int(raw_input())\nfor i in range(0, q):\n    u, v = map(int, raw_input().split(' '))\n    u -= 1\n    v -= 1\n    print len(mp[u][v]) if mp[u][v] else 0"
        }
    ]
}