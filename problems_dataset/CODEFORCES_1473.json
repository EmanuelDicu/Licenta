{
    "name": "1473_G. Tiles",
    "source": "CODEFORCES",
    "description": "Consider a road consisting of several rows. Each row is divided into several rectangular tiles, and all tiles in the same row are equal. The first row contains exactly one rectangular tile. Look at the picture below which shows how the tiles are arranged.\n\nThe road is constructed as follows: \n\n  * the first row consists of 1 tile; \n  * then a_1 rows follow; each of these rows contains 1 tile greater than the previous row; \n  * then b_1 rows follow; each of these rows contains 1 tile less than the previous row; \n  * then a_2 rows follow; each of these rows contains 1 tile greater than the previous row; \n  * then b_2 rows follow; each of these rows contains 1 tile less than the previous row; \n  * ... \n  * then a_n rows follow; each of these rows contains 1 tile greater than the previous row; \n  * then b_n rows follow; each of these rows contains 1 tile less than the previous row. \n\n<image> An example of the road with n = 2, a_1 = 4, b_1 = 2, a_2 = 2, b_2 = 3. Rows are arranged from left to right. \n\nYou start from the only tile in the first row and want to reach the last row (any tile of it). From your current tile, you can move to any tile in the next row which touches your current tile.\n\nCalculate the number of different paths from the first row to the last row. Since it can be large, print it modulo 998244353.\n\nInput\n\nThe first line contains one integer n (1 \u2264 n \u2264 1000).\n\nThen n lines follow. The i-th of them contains two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 10^5; |a_i - b_i| \u2264 5).\n\nAdditional constraint on the input: the sequence of a_i and b_i never results in a row with non-positive number of tiles.\n\nOutput\n\nPrint one integer \u2014 the number of paths from the first row to the last row, taken modulo 998244353.\n\nExamples\n\nInput\n\n\n2\n4 2\n2 3\n\n\nOutput\n\n\n850\n\n\nInput\n\n\n3\n4 1\n2 3\n3 1\n\n\nOutput\n\n\n10150\n\n\nInput\n\n\n8\n328 323\n867 868\n715 718\n721 722\n439 435\n868 870\n834 834\n797 796\n\n\nOutput\n\n\n759099319",
    "difficulty": "G",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "rating": 2800,
    "public_test": [
        {
            "input": "2\n4 2\n2 3\n",
            "output": "\n850\n"
        },
        {
            "input": "8\n328 323\n867 868\n715 718\n721 722\n439 435\n868 870\n834 834\n797 796\n",
            "output": "\n759099319\n"
        },
        {
            "input": "3\n4 1\n2 3\n3 1\n",
            "output": "\n10150\n"
        }
    ],
    "generated_test": [
        {
            "input": "2\n4 2\n2 2\n",
            "output": "610\n"
        },
        {
            "input": "3\n4 1\n2 3\n6 1\n",
            "output": "84070\n"
        },
        {
            "input": "3\n4 1\n2 3\n6 2\n",
            "output": "164770\n"
        },
        {
            "input": "3\n4 1\n2 4\n6 1\n",
            "output": "115570\n"
        },
        {
            "input": "3\n4 1\n2 3\n5 1\n",
            "output": "41830\n"
        },
        {
            "input": "2\n4 2\n4 2\n",
            "output": "2950\n"
        },
        {
            "input": "3\n4 1\n1 3\n6 1\n",
            "output": "31750\n"
        },
        {
            "input": "3\n4 1\n2 3\n1 2\n",
            "output": "3140\n"
        },
        {
            "input": "3\n4 1\n2 4\n6 2\n",
            "output": "223860\n"
        },
        {
            "input": "3\n4 1\n0 3\n5 1\n",
            "output": "4340\n"
        },
        {
            "input": "2\n5 2\n4 2\n",
            "output": "6804\n"
        },
        {
            "input": "3\n4 1\n1 3\n10 1\n",
            "output": "511750\n"
        },
        {
            "input": "3\n3 1\n2 3\n1 2\n",
            "output": "720\n"
        },
        {
            "input": "3\n4 1\n2 4\n1 2\n",
            "output": "2730\n"
        },
        {
            "input": "2\n5 2\n8 2\n",
            "output": "114156\n"
        },
        {
            "input": "3\n4 2\n1 3\n10 1\n",
            "output": "491040\n"
        },
        {
            "input": "2\n5 3\n8 2\n",
            "output": "184996\n"
        },
        {
            "input": "3\n4 1\n2 4\n1 0\n",
            "output": "1820\n"
        },
        {
            "input": "2\n4 2\n0 2\n",
            "output": "70\n"
        },
        {
            "input": "2\n4 2\n-1 2\n",
            "output": "0\n"
        },
        {
            "input": "3\n4 1\n3 3\n6 2\n",
            "output": "387660\n"
        },
        {
            "input": "3\n4 1\n2 4\n6 0\n",
            "output": "58240\n"
        },
        {
            "input": "3\n4 1\n2 3\n8 1\n",
            "output": "337510\n"
        },
        {
            "input": "3\n4 1\n1 3\n6 0\n",
            "output": "16000\n"
        },
        {
            "input": "3\n4 0\n2 3\n1 2\n",
            "output": "2436\n"
        },
        {
            "input": "3\n4 1\n1 3\n11 1\n",
            "output": "1023750\n"
        },
        {
            "input": "2\n5 2\n8 4\n",
            "output": "439712\n"
        },
        {
            "input": "3\n4 0\n2 4\n1 1\n",
            "output": "2268\n"
        },
        {
            "input": "2\n5 3\n12 2\n",
            "output": "2980068\n"
        },
        {
            "input": "3\n4 1\n3 4\n1 1\n",
            "output": "8260\n"
        },
        {
            "input": "3\n2 1\n2 3\n8 1\n",
            "output": "30600\n"
        },
        {
            "input": "3\n4 0\n2 3\n1 4\n",
            "output": "3360\n"
        },
        {
            "input": "2\n5 2\n8 6\n",
            "output": "1548820\n"
        },
        {
            "input": "3\n4 1\n3 5\n1 1\n",
            "output": "10080\n"
        },
        {
            "input": "3\n2 1\n3 3\n8 1\n",
            "output": "107310\n"
        },
        {
            "input": "2\n5 3\n8 6\n",
            "output": "2334332\n"
        },
        {
            "input": "3\n4 2\n3 5\n1 1\n",
            "output": "6160\n"
        },
        {
            "input": "3\n2 1\n3 3\n8 0\n",
            "output": "53760\n"
        },
        {
            "input": "3\n4 2\n3 5\n2 1\n",
            "output": "18480\n"
        },
        {
            "input": "2\n4 2\n2 4\n",
            "output": "850\n"
        },
        {
            "input": "2\n4 2\n1 2\n",
            "output": "240\n"
        },
        {
            "input": "3\n4 1\n1 3\n6 2\n",
            "output": "61500\n"
        },
        {
            "input": "3\n5 1\n2 4\n6 2\n",
            "output": "622472\n"
        },
        {
            "input": "3\n4 2\n2 3\n5 1\n",
            "output": "53550\n"
        },
        {
            "input": "3\n4 2\n1 3\n6 1\n",
            "output": "30240\n"
        },
        {
            "input": "3\n4 1\n2 3\n0 2\n",
            "output": "910\n"
        },
        {
            "input": "3\n4 1\n4 4\n6 2\n",
            "output": "1464420\n"
        },
        {
            "input": "2\n5 3\n4 2\n",
            "output": "10724\n"
        },
        {
            "input": "3\n4 1\n1 3\n10 2\n",
            "output": "1020500\n"
        },
        {
            "input": "3\n3 1\n2 3\n1 0\n",
            "output": "480\n"
        },
        {
            "input": "3\n4 1\n2 4\n2 2\n",
            "output": "9100\n"
        },
        {
            "input": "2\n5 3\n8 1\n",
            "output": "93072\n"
        },
        {
            "input": "3\n2 1\n3 3\n6 2\n",
            "output": "51660\n"
        },
        {
            "input": "3\n4 2\n2 4\n6 0\n",
            "output": "54400\n"
        },
        {
            "input": "3\n4 1\n2 3\n8 2\n",
            "output": "670830\n"
        },
        {
            "input": "3\n4 2\n1 3\n11 1\n",
            "output": "982560\n"
        },
        {
            "input": "2\n2 2\n8 4\n",
            "output": "20988\n"
        },
        {
            "input": "2\n5 2\n12 2\n",
            "output": "1834308\n"
        },
        {
            "input": "2\n4 3\n1 2\n",
            "output": "210\n"
        },
        {
            "input": "3\n4 0\n2 5\n6 0\n",
            "output": "59136\n"
        },
        {
            "input": "2\n5 2\n8 3\n",
            "output": "225652\n"
        },
        {
            "input": "3\n1 1\n3 3\n8 1\n",
            "output": "20400\n"
        },
        {
            "input": "3\n4 2\n3 4\n2 1\n",
            "output": "21560\n"
        },
        {
            "input": "3\n2 1\n3 3\n6 0\n",
            "output": "13440\n"
        },
        {
            "input": "3\n6 2\n3 5\n2 1\n",
            "output": "258720\n"
        },
        {
            "input": "2\n4 1\n1 2\n",
            "output": "180\n"
        },
        {
            "input": "3\n4 1\n1 2\n6 1\n",
            "output": "22930\n"
        },
        {
            "input": "3\n5 1\n2 4\n4 2\n",
            "output": "146768\n"
        },
        {
            "input": "3\n4 2\n2 3\n5 0\n",
            "output": "27200\n"
        },
        {
            "input": "3\n4 1\n4 7\n6 2\n",
            "output": "2984520\n"
        },
        {
            "input": "2\n5 3\n6 2\n",
            "output": "45444\n"
        },
        {
            "input": "3\n4 1\n2 3\n10 2\n",
            "output": "2697530\n"
        },
        {
            "input": "3\n2 1\n3 1\n6 2\n",
            "output": "22710\n"
        },
        {
            "input": "3\n4 1\n2 2\n8 2\n",
            "output": "417830\n"
        },
        {
            "input": "3\n4 2\n1 3\n6 0\n",
            "output": "15360\n"
        },
        {
            "input": "2\n2 2\n8 5\n",
            "output": "36036\n"
        },
        {
            "input": "3\n4 0\n1 5\n6 0\n",
            "output": "16128\n"
        },
        {
            "input": "3\n4 0\n4 3\n0 4\n",
            "output": "12870\n"
        },
        {
            "input": "3\n1 1\n3 3\n6 0\n",
            "output": "2560\n"
        },
        {
            "input": "2\n4 1\n2 2\n",
            "output": "410\n"
        },
        {
            "input": "3\n7 1\n4 7\n6 2\n",
            "output": "84334624\n"
        },
        {
            "input": "2\n5 2\n6 2\n",
            "output": "28224\n"
        },
        {
            "input": "3\n5 1\n2 3\n10 2\n",
            "output": "6429540\n"
        },
        {
            "input": "3\n4 2\n1 3\n8 0\n",
            "output": "61440\n"
        },
        {
            "input": "2\n4 3\n1 0\n",
            "output": "140\n"
        },
        {
            "input": "3\n4 2\n2 4\n4 0\n",
            "output": "13600\n"
        },
        {
            "input": "3\n7 1\n4 8\n6 2\n",
            "output": "129752128\n"
        },
        {
            "input": "2\n4 2\n6 2\n",
            "output": "12490\n"
        },
        {
            "input": "3\n7 0\n4 8\n6 2\n",
            "output": "84450288\n"
        },
        {
            "input": "2\n4 2\n6 3\n",
            "output": "23790\n"
        },
        {
            "input": "3\n7 0\n4 8\n12 2\n",
            "output": "510039299\n"
        },
        {
            "input": "2\n4 1\n6 3\n",
            "output": "14680\n"
        },
        {
            "input": "2\n4 1\n6 4\n",
            "output": "27610\n"
        },
        {
            "input": "2\n4 0\n6 4\n",
            "output": "15444\n"
        },
        {
            "input": "3\n4 2\n2 3\n3 1\n",
            "output": "12750\n"
        },
        {
            "input": "3\n4 1\n2 5\n6 1\n",
            "output": "114660\n"
        },
        {
            "input": "3\n2 1\n2 3\n6 2\n",
            "output": "14280\n"
        },
        {
            "input": "2\n4 1\n4 2\n",
            "output": "1830\n"
        },
        {
            "input": "3\n4 1\n0 3\n6 1\n",
            "output": "8820\n"
        },
        {
            "input": "3\n4 1\n3 4\n6 1\n",
            "output": "312060\n"
        },
        {
            "input": "3\n4 1\n1 4\n1 1\n",
            "output": "500\n"
        },
        {
            "input": "2\n5 5\n8 1\n",
            "output": "128520\n"
        },
        {
            "input": "2\n3 0\n0 2\n",
            "output": "20\n"
        },
        {
            "input": "3\n4 1\n2 4\n10 0\n",
            "output": "931840\n"
        },
        {
            "input": "3\n4 1\n1 3\n11 2\n",
            "output": "2044250\n"
        },
        {
            "input": "3\n4 2\n2 4\n1 1\n",
            "output": "1700\n"
        },
        {
            "input": "2\n5 3\n12 3\n",
            "output": "5947872\n"
        },
        {
            "input": "3\n4 1\n3 4\n2 1\n",
            "output": "18060\n"
        },
        {
            "input": "2\n8 2\n8 6\n",
            "output": "15493794\n"
        },
        {
            "input": "2\n4 3\n8 6\n",
            "output": "800800\n"
        },
        {
            "input": "3\n4 2\n4 5\n1 1\n",
            "output": "34020\n"
        },
        {
            "input": "3\n5 2\n3 5\n2 1\n",
            "output": "86436\n"
        },
        {
            "input": "3\n4 1\n0 3\n6 2\n",
            "output": "16660\n"
        },
        {
            "input": "3\n5 1\n2 5\n6 2\n",
            "output": "840336\n"
        },
        {
            "input": "3\n3 2\n2 3\n5 1\n",
            "output": "12400\n"
        },
        {
            "input": "3\n1 1\n4 4\n6 2\n",
            "output": "33320\n"
        },
        {
            "input": "3\n4 1\n1 3\n10 3\n",
            "output": "2021500\n"
        },
        {
            "input": "3\n2 1\n3 3\n11 2\n",
            "output": "1717170\n"
        },
        {
            "input": "3\n4 1\n2 4\n8 2\n",
            "output": "920920\n"
        },
        {
            "input": "2\n5 2\n11 2\n",
            "output": "916846\n"
        },
        {
            "input": "2\n5 1\n8 3\n",
            "output": "125772\n"
        },
        {
            "input": "3\n1 1\n4 3\n8 1\n",
            "output": "71540\n"
        },
        {
            "input": "3\n4 2\n3 4\n2 0\n",
            "output": "12320\n"
        },
        {
            "input": "3\n6 2\n3 5\n4 1\n",
            "output": "1102080\n"
        },
        {
            "input": "2\n4 1\n1 4\n",
            "output": "250\n"
        },
        {
            "input": "3\n4 1\n1 2\n12 1\n",
            "output": "1474450\n"
        },
        {
            "input": "3\n5 0\n2 4\n4 2\n",
            "output": "95832\n"
        },
        {
            "input": "2\n5 3\n6 4\n",
            "output": "157584\n"
        },
        {
            "input": "3\n2 1\n3 2\n6 2\n",
            "output": "37470\n"
        },
        {
            "input": "3\n4 1\n2 2\n8 4\n",
            "output": "1608360\n"
        },
        {
            "input": "3\n4 0\n4 3\n1 4\n",
            "output": "35640\n"
        },
        {
            "input": "2\n1 1\n2 2\n",
            "output": "12\n"
        },
        {
            "input": "3\n7 1\n4 7\n10 2\n",
            "output": "373637983\n"
        },
        {
            "input": "2\n5 2\n6 3\n",
            "output": "54642\n"
        },
        {
            "input": "3\n5 1\n0 3\n10 2\n",
            "output": "1028664\n"
        },
        {
            "input": "2\n3 3\n1 0\n",
            "output": "40\n"
        },
        {
            "input": "2\n4 0\n6 3\n",
            "output": "8008\n"
        },
        {
            "input": "2\n4 4\n2 2\n",
            "output": "420\n"
        },
        {
            "input": "3\n7 0\n4 8\n11 2\n",
            "output": "753066882\n"
        },
        {
            "input": "2\n4 1\n6 6\n",
            "output": "84370\n"
        },
        {
            "input": "2\n4 1\n5 4\n",
            "output": "12930\n"
        },
        {
            "input": "3\n4 2\n3 3\n3 1\n",
            "output": "34300\n"
        },
        {
            "input": "3\n4 1\n4 5\n6 1\n",
            "output": "1169220\n"
        },
        {
            "input": "3\n5 1\n0 3\n6 1\n",
            "output": "32004\n"
        },
        {
            "input": "3\n4 1\n2 4\n10 1\n",
            "output": "1862770\n"
        },
        {
            "input": "3\n4 1\n1 2\n11 2\n",
            "output": "1472880\n"
        },
        {
            "input": "2\n8 2\n9 6\n",
            "output": "31612872\n"
        },
        {
            "input": "3\n4 1\n4 5\n1 1\n",
            "output": "30900\n"
        },
        {
            "input": "3\n5 1\n3 5\n2 1\n",
            "output": "68964\n"
        },
        {
            "input": "2\n6 2\n2 4\n",
            "output": "9324\n"
        },
        {
            "input": "3\n5 1\n2 5\n6 1\n",
            "output": "433832\n"
        },
        {
            "input": "3\n3 2\n2 3\n6 1\n",
            "output": "25200\n"
        },
        {
            "input": "3\n4 0\n2 3\n0 2\n",
            "output": "924\n"
        },
        {
            "input": "3\n4 0\n1 3\n10 3\n",
            "output": "1478568\n"
        },
        {
            "input": "2\n5 1\n11 3\n",
            "output": "1014046\n"
        },
        {
            "input": "3\n6 2\n1 5\n4 1\n",
            "output": "102480\n"
        },
        {
            "input": "3\n2 1\n3 2\n6 4\n",
            "output": "130050\n"
        },
        {
            "input": "3\n6 1\n4 7\n10 2\n",
            "output": "554490552\n"
        },
        {
            "input": "2\n5 2\n9 3\n",
            "output": "454454\n"
        },
        {
            "input": "3\n5 1\n0 3\n10 1\n",
            "output": "515844\n"
        },
        {
            "input": "2\n3 3\n2 0\n",
            "output": "80\n"
        },
        {
            "input": "2\n1 1\n6 6\n",
            "output": "1848\n"
        },
        {
            "input": "2\n4 2\n3 4\n",
            "output": "3080\n"
        },
        {
            "input": "3\n4 1\n4 5\n3 1\n",
            "output": "141060\n"
        },
        {
            "input": "3\n4 1\n2 4\n8 1\n",
            "output": "465010\n"
        },
        {
            "input": "2\n2 2\n9 6\n",
            "output": "137280\n"
        },
        {
            "input": "2\n6 4\n2 4\n",
            "output": "11340\n"
        },
        {
            "input": "3\n3 2\n2 3\n6 0\n",
            "output": "12800\n"
        },
        {
            "input": "2\n1 1\n11 3\n",
            "output": "32344\n"
        },
        {
            "input": "3\n6 2\n1 5\n4 2\n",
            "output": "170800\n"
        },
        {
            "input": "2\n4 0\n2 4\n",
            "output": "672\n"
        },
        {
            "input": "3\n2 1\n2 2\n6 4\n",
            "output": "47520\n"
        },
        {
            "input": "2\n1 1\n9 6\n",
            "output": "45760\n"
        },
        {
            "input": "3\n4 1\n2 3\n2 1\n",
            "output": "4870\n"
        },
        {
            "input": "2\n6 3\n2 4\n",
            "output": "12348\n"
        },
        {
            "input": "3\n3 2\n2 3\n1 0\n",
            "output": "400\n"
        },
        {
            "input": "3\n2 1\n2 3\n6 4\n",
            "output": "40320\n"
        },
        {
            "input": "2\n1 1\n9 3\n",
            "output": "7876\n"
        },
        {
            "input": "3\n2 1\n2 0\n6 4\n",
            "output": "22308\n"
        },
        {
            "input": "3\n4 1\n2 3\n1 1\n",
            "output": "2230\n"
        },
        {
            "input": "2\n10 5\n2 4\n",
            "output": "1273272\n"
        },
        {
            "input": "3\n2 1\n2 0\n12 4\n",
            "output": "1565904\n"
        },
        {
            "input": "3\n4 2\n2 3\n1 1\n",
            "output": "2550\n"
        },
        {
            "input": "3\n2 1\n2 0\n9 4\n",
            "output": "192426\n"
        },
        {
            "input": "3\n4 2\n2 3\n2 1\n",
            "output": "5950\n"
        },
        {
            "input": "3\n2 1\n4 0\n9 4\n",
            "output": "780504\n"
        },
        {
            "input": "3\n4 2\n2 4\n2 1\n",
            "output": "5100\n"
        },
        {
            "input": "3\n2 1\n2 3\n3 1\n",
            "output": "840\n"
        },
        {
            "input": "2\n4 2\n2 1\n",
            "output": "370\n"
        },
        {
            "input": "3\n4 1\n2 3\n9 2\n",
            "output": "1346260\n"
        },
        {
            "input": "3\n4 1\n3 4\n4 1\n",
            "output": "76860\n"
        },
        {
            "input": "2\n4 2\n3 2\n",
            "output": "1380\n"
        },
        {
            "input": "3\n4 1\n1 3\n9 0\n",
            "output": "128000\n"
        },
        {
            "input": "3\n4 1\n0 3\n5 0\n",
            "output": "2240\n"
        },
        {
            "input": "2\n5 2\n4 3\n",
            "output": "12488\n"
        },
        {
            "input": "3\n3 1\n2 3\n2 2\n",
            "output": "2400\n"
        },
        {
            "input": "3\n4 1\n3 4\n1 2\n",
            "output": "11620\n"
        },
        {
            "input": "3\n6 2\n1 3\n10 1\n",
            "output": "5102048\n"
        },
        {
            "input": "2\n5 2\n0 2\n",
            "output": "252\n"
        },
        {
            "input": "3\n4 1\n2 4\n4 0\n",
            "output": "14560\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n//#define int long long\n#define ll long long\n#define p pair<int, int>\n#define endl '\\n'\nconst int INF = 1000000001;\n\nusing namespace std;\n\nconst int C = 998244353;\nvector<ll> fact, minus_fact;\n\nll pow1(ll x, ll y, ll z=C){\n    if (y == 0){\n        return 1;\n    }\n    if (y % 2 == 0){\n        return pow1(x*x % z, y/2, z);\n    }\n    return pow1(x, y-1, z)*x % z;\n}\n\nvoid facts(int n){\n    fact = {1}, minus_fact = {1};\n    for (int q = 1; q <= n; q++){\n        fact.push_back(fact.back()*q % C);\n        minus_fact.push_back(minus_fact.back()*pow1(q, C-2) % C);\n    }\n}\n\nll c(int k, int n){\n    if (k < 0 || k > n){\n        return 0;\n    }\n    return fact[n]*minus_fact[k] % C*minus_fact[n-k] % C;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    facts(200179);\n    int n;\n    cin >> n;\n    vector<p> a(n);\n    for (int q = 0; q < n; q++){\n        cin >> a[q].first >> a[q].second;\n    }\n    vector<int> now = {1};\n    for (int q = 0; q < n; q++){\n        int w3 = (now.size()+a[q].first+a[q].second+1)/2, w4 = now.size()+a[q].first+a[q].second;\n        vector<__int128> will(w3-a[q].second, 0);\n        vector<ll> cc(now.size()+a[q].first);\n        for (int q1 = 0; q1 < cc.size(); q1++){\n            cc[q1] = c(q1, a[q].first+a[q].second);\n        }\n        for (int q1 = a[q].second; q1 < w3; q1++){\n            int w = min(q1+1, (int)now.size()), w1 = q1-a[q].second, w2 = max(0, q1-a[q].first-a[q].second);\n            for (int q2 = w2; q2 < w; q2++){\n                will[w1] += cc[q1-q2]*now[q2];\n            }\n        }\n        now = {};\n        for (__int128 q1: will){\n            now.push_back(q1 % C);\n        }\n        for (int q1 = (int)now.size()-1-w4 % 2; q1 > -1; q1--){\n            now.push_back(now[q1]);\n        }\n    }\n    ll ans = 0;\n    for (int q: now){\n        ans += q;\n    }\n    cout << ans % C << endl;\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "//CLOCKS_PER_SEC\nusing namespace std;\n#include<bits/stdc++.h>\n#define sqr(x) 1ll*(x)*(x)\n//#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=(c&15);while (isdigit(c=getchar())) v=(v<<1)+(v<<3)+(c&15);x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=(c&15);while (isdigit(c=getchar())) v=(v<<1)+(v<<3)+(c&15);x=v*f;}\ninline void readc(char &x){char c;while (((c=getchar())==' ')||c=='\\n');x=c;}\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,a,b) for ((i)=(a);(i)<=(b);(i)++)\n#define fordo(i,a,b) for ((i)=(a);(i)>=(b);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define rep0(i,x) forup ((i),0,((int)(x))-1)\n#define rep0d(i,x) fordo ((i),((int)(x))-1,0)\n#define itr iterator\n#define fe(itcalc,c) for(__typeof((c).begin()) itcalc=(c).begin();itcalc!=(c).end();itcalc++)\n#define NO {cout<<\"NO\";return 0;}\n#define YES {cout<<\"YES\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x2bbbbbbbbbbbbbbbll\n//#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nconst int mod=998244353,maxn=16384;\nint n,m,i,j,fac[240005],inv[240005],fi[240005],rev[maxn+5],a[maxn+5],b[maxn+5],w[maxn+5];\nvector<int> v,nxt;\nint c(int x,int y)\n{\n\tif(x<y||x<0||y<0) return 0;\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint pw(int x,int y)\n{\n\tint z=1;\n\twhile(y){\n\t\tif(y&1)z=1ll*z*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn z;\n}\nvoid ntt(int *a,int len,int op)\n{\n\tint i,j,k;\n\trep0(i,len){\n\t\tif(rev[i]<i){\n\t\t\tswap(a[i],a[rev[i]]);\n\t\t}\n\t}\n\tfor(i=1;i<len;i<<=1){\n\t\tint stp=maxn/i/2;\n\t\tfor(j=0;j<len;j+=i+i){\n\t\t\tint t=(op==1?0:maxn);\n\t\t\trep0(k,i){\n\t\t\t\tint x=a[j+k],y=a[j+k+i]*1ll*w[t]%mod;\n\t\t\t\ta[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;\n\t\t\t\tt+=stp*op;\n\t\t\t}\n\t\t}\n\t}\n\tif(op==-1){\n\t\trep0(i,len) a[i]=1ll*a[i]*inv[len]%mod;\n\t}\n}\nint getrev(int x)\n{\n\tint len=1,i;\n\twhile(len<=x)len<<=1;\n\trep0(i,len){\n\t\trev[i]=(rev[i/2]/2)+((i&1)*(len/2));\n\t}\n\treturn len;\n}\nint main()\n{\n\tw[0]=1;w[1]=pw(3,(mod-1)/maxn);\n\tforup(i,2,maxn) w[i]=1ll*w[i-1]*w[1]%mod;\n\tfac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;\n\tforup(i,2,240003){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfi[i]=1ll*fi[i-1]*inv[i]%mod; \n\t}\n\tread(n);\n\tv.push_back(1);\n\tint _;\n\trep(_,n){\n\t\tint x,y;\n\t\tread(x);read(y);\n\t\tnxt.clear();nxt.resize(v.size()+x-y);\n\t\tint l=1-((int)v.size())+y,r=nxt.size()-1+y;\n\t\tint len=getrev(v.size()+(r-l+1));\n\t\trep0(i,len) a[i]=b[i]=0;\n\t\trep0(i,v.size()) a[i]=v[i];\n\t\trep0(i,r-l+1) b[i]=c(x+y,l+i);\n\t\tntt(a,len,1);ntt(b,len,1);\n\t\trep0(i,len) a[i]=1ll*a[i]*b[i]%mod;\n\t\tntt(a,len,-1);\n\t\trep0(i,len){\n\t\t\tint to=1-((int)v.size())+i;\n\t\t\tif(0<=to&&to<nxt.size()){\n\t\t\t\tnxt[to]=a[i];\n\t\t\t}\n\t\t}\n\t\tv=nxt;\n\t}\n\tint ans=0;\n\tfe(it,v)ans=(ans+*it)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int maxm=200025;\nconst int maxn=1005;\nconst int maxf=16384+25;\nconst int mod=998244353;\nint n,m,i,j,t,k,s,jc[maxm],ijc[maxm],a[maxn][2],Log[maxm];\nint *rev[15];ull *pre3[15],f[maxf],g[maxf],iv_2[15];\n\ninline int Pow(int x,int y,int mo)\n{\n\tint ret=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mo;\n\t\tx=1ll*x*x%mo;y>>=1;\n\t}\n\treturn ret;\n}\ninline int C(int x,int y){return x<y||y<0?0:1ll*jc[x]*ijc[y]%mod*ijc[x-y]%mod;}\ninline void NTT(ull *a,int bit,int x)\n{\n\tint len=(1<<bit);\n\tfor (int i=1;i<len;++i) if (rev[bit][i]>i){swap(a[rev[bit][i]],a[i]);}\n\tfor (int i=1;i<len;i<<=1)\n\t{\n\t\tfor (int j=0;j<len;j+=(i<<1))\n\t\t{\n\t\t\tull *a0=a+j,*a1=a+j+i,*wn=pre3[Log[i]+1];\n\t\t\tfor (int k=0;k<i;++k,++a0,++a1,++wn)\n\t\t\t{\n\t\t\t\tull tmp=*a1**wn%mod;\n\t\t\t\t*a1=*a0+mod-tmp;*a0+=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0;i<len;++i) a[i]%=mod;\n\tif (x==-1)\n\t{\n\t\treverse(a+1,a+len);\n\t\tull tmp=iv_2[bit];\n\t\tfor (int i=0;i<len;++i) a[i]=a[i]*tmp%mod;\n\t}\n}\n\nint main()\n{\n\tjc[0]=jc[1]=ijc[0]=ijc[1]=1;iv_2[0]=1;\n\tfor (i=2;i<maxm;++i) jc[i]=1ll*i*jc[i-1]%mod,Log[i]=Log[i>>1]+1;\n\tfor (i=1;i<=14;++i)\n\t{\n\t\tiv_2[i]=iv_2[i-1]*499122177ull%mod;\n\t\trev[i]=new int[(1<<i)+1];pre3[i]=new ull[(1<<i)+1];\n\t\trev[i][0]=0;\n\t\tfor (j=1;j<(1<<i);++j) rev[i][j]=((rev[i][j>>1]>>1)|((j&1)<<i-1));\n\t\tpre3[i][0]=1;pre3[i][1]=Pow(3,(mod-1)/(1<<i),mod);\n\t\tfor (j=2;j<=(1<<i);++j) pre3[i][j]=1ll*pre3[i][1]*pre3[i][j-1]%mod;\n\t}\n\tijc[maxm-1]=Pow(jc[maxm-1],mod-2,mod);\n\tfor (i=maxm-2;i>1;--i) ijc[i]=1ll*ijc[i+1]*(i+1)%mod;\n\t//for (i=1;i<=10;++i) printf(\"%d %d %d\\n\",i,jc[i],ijc[i]);\n\t//g[0]=1;g[1]=1;NTT(g,10,1);for (i=0;i<1024;++i) g[i]=g[i]*g[i]%mod*g[i]%mod;NTT(g,10,-1);printf(\"%llu %llu %llu\\n\",g[0],g[1],g[2]);\n\t\n\tscanf(\"%d\",&n);\n\tt=0;f[0]=1;\n\tfor (i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&a[i][0],&a[i][1]);\n\t\tk=t+a[i][0]-a[i][1];\n\t\tif (t<64||k<64)\n\t\t{\n\t\t\tfor (j=0;j<=t;++j) g[j]=f[j],f[j]=0;\n\t\t\tfor (j=0;j<=t;++j)\n\t\t\t{\n\t\t\t\tull mul=g[j];\n\t\t\t\tfor (s=0;s<=k;++s) f[s]+=mul*C(a[i][0]+a[i][1],a[i][1]+s-j);\n\t\t\t\tif ((j&15)==15)\n\t\t\t\t{\n\t\t\t\t\tfor (s=0;s<=k;++s) f[s]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0;j<=t;++j) g[j]=0;\n\t\t\tfor (j=0;j<=k;++j) f[j]%=mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bit=Log[t+k]+1;\n\t\t\tfor (j=0;j<=t+k;++j) g[j]=C(a[i][0]+a[i][1],a[i][1]+j-t);\n\t\t\tNTT(f,bit,1);NTT(g,bit,1);\n\t\t\tfor (j=0;j<(1<<bit);++j) f[j]=f[j]*g[j]%mod,g[j]=0ull;\n\t\t\tNTT(f,bit,-1);\n\t\t\tfor (j=0;j<(1<<bit);++j) f[j]=(j<=k?f[j+t]:0ull);\n\t\t}\n\t\tt=k;\n\t\t//for (j=0;j<=t;++j) printf(\"%llu \",f[j]);puts(\"\");\n\t}\n\tull ans=0;\n\tfor (i=0;i<=t;++i)\n\t{\n\t\tans+=f[i];if ((i&15)==15) ans%=mod;\n\t}\n\tans%=mod;\n\tprintf(\"%llu\\n\",ans);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define all(v) (v).begin(), (v).end()\ntemplate<class A, class B> ostream& operator<<(ostream& os, const pair<A,B>& p) {\n\treturn os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<class T> auto operator<<(ostream& os, T&& x) -> decltype(x.begin(), os) {\n\tos << '{';\n\tfor(auto it = x.begin(); it != x.end(); ++it) os << *it << (it == prev(x.end()) ? \"\" : \", \");\n\treturn os << '}';\n}\nvoid dump() {}\ntemplate<class T,class... Args> void dump(T&& x,Args... args) { cerr<<x<<\";  \"; dump(args...); }\n#ifdef DEBUG\n    struct Lf{ ~Lf() { cerr << '\\n'; } };\n    #define debug(x...) cerr << (strcmp(#x, \"\") ? #x \":  \" : \"\"), dump(x), Lf(), cerr << \"\"\n#else\n    #define debug(...) 0&&cerr\n#endif\n\nconst int MAX = 1<<23;\t\t//max input vector length\nconst int MOD = 998244353;\t//prime modulus e.g. 998244353 = 1 + 7*17*2^23\nconst int G = 3;\t\t\t//generator for Z_MOD\n \nint modpow(int base, int exp) {\n  base %= MOD;\n  int result = 1;\n  while (exp > 0) {\n\tif (exp & 1) result = (1ll*result * base) % MOD;\n\tbase = (1ll*base * base) % MOD;\n\texp >>= 1;\n  }\n  return result;\n}\nint modinv(int a) {\n    return modpow(a,MOD-2);\n}\n//FFT=1 for transform, FFT=-1 for inverse transform; N=current input length, should use a power of 2\nvoid fft(vector<int>& a, int FFT, int N) {\n    static int rev[MAX];\n    for (int i = 0; i < N; i++) {\n\t\trev[i] = (rev[i>>1]>>1)|((i&1)?(N>>1):0);\n        if (i < rev[i]) swap(a[i], a[rev[i]]);\n    }\n    for (int m = 2, m2 = 1; m <= N; m <<= 1, m2 <<= 1) {\n        int wm = modpow(G, (MOD-1)/m*FFT+(FFT==-1?MOD-1:0));\n        for (int k = 0; k < N; k += m)\n            for (int j = 0, u, t, w = 1; j < m2; j++)\n                t = 1ll*w*a[k+j+m2]%MOD, u = a[k+j], w = 1ll*w*wm%MOD,\n                a[k+j] = (u+t)%MOD, a[k+j+m2] = (u-t+MOD)%MOD;\n    }\n    if (FFT == -1)\n        for (int i = 0, invN = modinv(N); i < N; i++)\n            a[i] = 1ll * a[i] * invN % MOD;\n}\n \nint degp,degq;\nvector<int> P,Q;\n\nvoid mul() {\n    int N=1;\n\tfor (; N<degp+degq+1; N<<=1);\n\twhile ((int)P.size()<N) P.push_back(0);\n\twhile ((int)Q.size()<N) Q.push_back(0);\n\t\n\tfft(P,1,N);\n\tfft(Q,1,N);\n\tfor (int i=0; i<N; ++i) P[i] = (1ll*P[i]*Q[i])%MOD;\n\tfft(P,-1,N);\n\twhile (P.back()==0) P.pop_back();\n}\n\nint n, a,b, fact[200010], ifact[200010];\nvoid calc() {\n    fact[0] = 1, fact[1] = 1, ifact[0] = 1, ifact[1] = 1;\n    for (int i=2; i<=200000; ++i) {\n        fact[i] = (1ll*fact[i-1]*i) % MOD;\n        ifact[i] = modinv(fact[i]);\n    }\n}\nint C(int x, int y) {\n    if (y<0 || y>x) return 0;\n    int div = (1ll*ifact[y]*ifact[x-y])%MOD;\n    return (1ll*fact[x]*div)%MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    calc();\n    cin >> n;\n    P = {1};\n    for (int i=0; i<n; ++i) {\n        cin >> a >> b;\n        int m = P.size();\n        Q.clear();\n        for (int j=b-m+1; j<m+a; ++j) Q.push_back(C(a+b,j));\n        degp = m-1;\n        degq = Q.size()-1;\n        mul();\n        for (int j=0; j<m+a-b; ++j) P[j] = P[m+j-1];\n        P.resize(m+a-b);\n    }\n    int sum = 0;\n    for (int x : P) {\n        sum = (sum+x) % MOD;\n    }\n    cout << sum << endl;\n\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned long long uint64;\n\nconst int mod = 998244353;\n//const int mod = 1e9+7\nint inc(int a, int b) { a += b; return a >= mod ? a - mod : a; }\nint dec(int a, int b) { a -= b; return a < 0 ? a + mod : a; }\nint fpow(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1) {\n        if (x & 1) ret = 1LL * ret * a % mod;\n        a = 1LL * a * a % mod;\n    }\n    return ret;\n}\nint inv(int x) { return fpow(x, mod - 2); }\n\nint n, a[1010], b[1010], sa[1010], sb[1010];\n\nint fac[200010], rfac[200010];\nint C(int n, int m) {\n    if (n < m || m < 0) return 0;\n    return 1LL * fac[n] * rfac[n - m] % mod * rfac[m] % mod;\n}\nvoid init(int n) {\n    for (int i = fac[0] = 1; i <= n; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n    rfac[n] = fpow(fac[n], mod - 2); for (int i = n; i; --i) rfac[i - 1] = 1LL * rfac[i] * i % mod;\n}\n\nnamespace polynomial {\n    const int mod = 998244353, modg = 3;\n\n    const int N = 1 << 19;\n\n    inline int inc(int a, int b) { a += b; return a >= mod ? a - mod : a; }\n\n    inline int dec(int a, int b) { a -= b; return a < 0 ? a + mod : a; }\n\n    inline int fpow(int a, int x)\n    {\n    \tint ret = 1;\n    \tfor (; x; x >>= 1)\n    \t{\n    \t\tif (x & 1) ret = 1LL * ret * a % mod;\n    \t\ta = 1LL * a * a % mod;\n    \t}\n    \treturn ret;\n    }\n\n    inline int legendre(int x) { return fpow(x, (mod - 1) >> 1); }\n\n    inline int fsqrt(int x)\n    {\n    \tif (!x) return 0;\n    \tif (mod == 2) return x & 1;\n    \tif (legendre(x) == mod - 1) return -1;\n    \tint b, w;\n    \tdo\n    \t{\n    \t\tb = rand() % mod;\n    \t\tw = (1LL * b * b - x + mod) % mod;\n    \t} while (legendre(w) != mod - 1);\n    \tstruct item\n    \t{\n    \t\tint a, b;\n    \t\titem(int _a = 0, int _b = 0) : a(_a), b(_b) {  }\n    \t\titem mul(item y, int w)\n    \t\t{\n    \t\t\titem x = *this, z;\n    \t\t\tz.a = (1LL * x.a * y.a + 1LL * x.b * y.b % mod * w) % mod;\n    \t\t\tz.b = (1LL * x.a * y.b + 1LL * x.b * y.a) % mod;\n    \t\t\treturn z;\n    \t\t}\n    \t};\n    \titem res(1, 0), a(b, 1);\n    \tint p = (mod + 1) / 2;\n    \tfor (; p; p >>= 1)\n    \t{\n    \t\tif (p & 1) res = res.mul(a, w);\n    \t\ta = a.mul(a, w);\n    \t}\n    \treturn min(res.a, dec(0, res.a));\n    \t//\u4e24\u4e2a\u6839\n    }\n\n    inline int inv(int x) { return fpow(x, mod - 2); }\n    //NTT\n    inline void dft(int *a, int n, int sig)\n    {\n    \tfor (int i = 0, j = 0; i < n; ++i)\n    \t{\n    \t\tif (i > j) swap(a[i], a[j]);\n    \t\tfor (int l = n >> 1; (j ^= l) < l; l >>= 1);\n    \t}\n    \tfor (int i = 1; i < n; i <<= 1)\n    \t{\n    \t\tint m = i << 1;\n    \t\tint w = fpow(modg, (mod - 1) / m);\n    \t\tif (sig == -1) w = inv(w);\n    \t\tfor (int j = 0; j < n; j += m)\n    \t\t\tfor (int k = 0, v = 1; k < i; ++k, v = 1LL * v * w % mod)\n    \t\t\t{\n    \t\t\t\tint x = a[j + k], y = 1LL * a[j + i + k] * v % mod;\n    \t\t\t\ta[j + k] = inc(x, y), a[j + i + k] = dec(x, y);\n    \t\t\t}\n    \t}\n    \tif (sig == -1)\n    \t{\n    \t\tint invn = inv(n);\n    \t\tfor (int i = 0; i < n; ++i)\n    \t\t\ta[i] = 1LL * a[i] * invn % mod;\n    \t}\n    }\n\n    inline void get_inv(int *a, int *r, int n)\n    {\n    \tif (n == 1)\n    \t{\n    \t\tr[0] = inv(a[0]);\n    \t\tif (!a[0]) throw \"error!\";\n    \t\treturn;\n    \t}\n    \tstatic int x[N], y[N], z[N];\n    \tget_inv(a, x, (n + 1) >> 1);\n    \tint m = 1;\n    \tfor (; m < (n << 1); m <<= 1);\n    \tmemset(y, 0, sizeof(int) * m);\n    \tmemset(z, 0, sizeof(int) * m);\n    \tmemcpy(y, x, sizeof(int) * ((n + 1) >> 1));\n    \tmemcpy(z, a, sizeof(int) * n);\n    \tdft(y, m, 1); dft(z, m, 1);\n    \tfor (int i = 0; i < m; ++i)\n    \t\tz[i] = (((y[i] << 1) - 1LL * y[i] * y[i] % mod * z[i]) % mod + mod) % mod;\n    \tdft(z, m, -1);\n    \tmemcpy(r, z, sizeof(int) * n);\n    }\n\n    inline void get_sqrt(int *a, int *r, int n)\n    {\n    \tif (n == 1)\n    \t{\n    \t\tr[0] = fsqrt(a[0]);\n    \t\tif (r[0] == -1) throw \"error!\";\n    \t\treturn;\n    \t}\n    \tstatic int x[N], y[N], z[N], w[N];\n    \tget_sqrt(a, x, (n + 1) >> 1);\n    \tint m = 1;\n    \tfor (; m < (n << 1); m <<= 1);\n    \tmemset(y, 0, sizeof(int) * m);\n    \tmemset(z, 0, sizeof(int) * m);\n    \tmemset(w, 0, sizeof(int) * m);\n    \tmemcpy(y, x, sizeof(int) * ((n + 1) >> 1));\n    \tget_inv(y, z, n);\n    \tmemcpy(w, z, sizeof(int) * n);\n    \tmemset(z, 0, sizeof(int) * m);\n    \tmemcpy(z, a, sizeof(int) * n);\n    \tdft(z, m, 1), dft(w, m, 1);\n    \tfor (int i = 0; i < m; ++i)\n    \t\tz[i] = 1LL * z[i] * w[i] % mod;\n    \tdft(z, m, -1);\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tx[i] = inc(x[i], z[i]);\n    \t\tif (x[i] & 1) x[i] += mod;\n    \t\tx[i] >>= 1;\n    \t}\n    \tmemcpy(r, x, sizeof(int) * n);\n    }\n\n    void get_division(int *A, int *B, int *D, int n, int m)\n    {\n    \tif (n < m) return void(D[0] = 0);\n    \tint t = n - m + 1, p = 1;\n    \tfor (; p < (t << 1); p <<= 1);\n    \tstatic int x[N], y[N];\n    \tfill(x, x + p, 0);\n    \treverse_copy(B, B + m, x);\n    \tget_inv(x, y, t);\n    \tfill(y + t, y + p, 0);\n    \tdft(y, p, 1);\n    \treverse_copy(A, A + n, x);\n    \tfill(x + t, x + p, 0);\n    \tdft(x, p, 1);\n    \tfor (int i = 0; i < p; ++i) x[i] = 1LL * x[i] * y[i] % mod;\n    \tdft(x, p, -1);\n    \treverse_copy(x, x + t, D);\n    }\n\n    struct poly\n    {\n\n    \tvector< int > a;\n\n    \tpoly() { redeg(0); }\n\n    \tpoly(int n, ...)\n    \t{\n    \t\tva_list scan;\n    \t\tva_start(scan, n);\n    \t\tredeg(n);\n    \t\tfor (int i = n; ~i; --i) a[i] = va_arg(scan, int);\n    \t\tva_end(scan);\n    \t}\n\n    \tinline int& operator[](const int &x) { return a[x]; }\n\n    \tinline int deg() { return a.size() - 1; }\n\n    \tinline void redeg(int n) { a.resize(n + 1); }\n\n    \tinline void swap(poly &x) { a.swap(x.a); }\n\n    \tinline void maintain()\n    \t{\n    \t\tint p = deg();\n    \t\twhile (p > 0 && !a[p]) --p;\n    \t\tredeg(p);\n    \t}\n\n    \tinline void scan(int *x, int n)\n    \t{\n    \t\tredeg(n);\n    \t\tfor (int i = 0; i <= n; ++i) a[i] = x[i];\n    \t}\n\n    \tinline int print(int *x)\n    \t{\n    \t\tint n = deg();\n    \t\tfor (int i = 0; i <= n; ++i) x[i] = a[i];\n    \t\treturn n;\n    \t}\n    \t//\u7ffb\u8f6c\n    \tinline poly reverse()\n    \t{\n    \t\tpoly x = *this;\n    \t\tstd::reverse(x.a.begin(), x.a.end());\n    \t\treturn x;\n    \t}\n    \t//\u79ef\u5206\n    \tinline poly integral()\n    \t{\n    \t\tpoly x = *this;\n    \t\tx.redeg(deg() + 1);\n    \t\tstatic int Inv[N];\n    \t\tstatic int init_n;\n    \t\tif (!init_n)\n    \t\t\tinit_n = Inv[1] = 1;\n    \t\tif (init_n < x.deg())\n    \t\t{\n    \t\t\tfor (int i = init_n + 1, n = x.deg(); i <= n; ++i)\n    \t\t\t\tInv[i] = dec(mod, 1LL * Inv[mod % i] * (mod / i) % mod);\n    \t\t\tinit_n = x.deg();\n    \t\t}\n    \t\tfor (int i = x.deg(); i; --i) x[i] = 1LL * x[i - 1] * Inv[i] % mod;\n    \t\tx[0] = 0;\n    \t\treturn x;\n    \t}\n    \t//\u5fae\u5206\n    \tinline poly diff()\n    \t{\n    \t\tpoly x = *this;\n    \t\tfor (int i = 1; i <= x.deg(); ++i) x[i - 1] = 1LL * x[i] * i % mod;\n    \t\tx[x.deg()] = 0;\n    \t\tx.maintain();\n    \t\treturn x;\n    \t}\n    \t//\u52a0\u6cd5\n    \tfriend inline poly operator + (poly a, poly b)\n    \t{\n    \t\tif (a.deg() < b.deg()) a.swap(b);\n    \t\tfor (int i = 0; i <= b.deg(); ++i) a[i] = inc(a[i], b[i]);\n    \t\treturn a;\n    \t}\n    \t//\u51cf\u6cd5\n    \tfriend inline poly operator - (poly a, poly b)\n    \t{\n    \t\tif (a.deg() < b.deg()) a.redeg(b.deg());\n    \t\tfor (int i = 0; i <= b.deg(); ++i) a[i] = dec(a[i], b[i]);\n    \t\treturn a;\n    \t}\n    \t//\u4e58\u6cd5\n    \tfriend inline poly operator * (poly a, int x)\n    \t{\n    \t\tfor (int i = 0; i <= a.deg(); ++i)\n    \t\t\ta[i] = 1LL * a[i] * x % mod;\n    \t\treturn a;\n    \t}\n    \t//\u4e58\u6cd5\n    \tfriend inline poly operator * (poly a, poly b)\n    \t{\n    \t\tif (min(a.deg(), b.deg()) < 28)\n    \t\t{\n    \t\t\tpoly c;\n    \t\t\tc.redeg(a.deg() + b.deg());\n    \t\t\tfor (int i = 0; i <= a.deg(); ++i)\n    \t\t\t\tif (a[i]) for (int j = 0; j <= b.deg(); ++j)\n    \t\t\t\t\tif (b[j]) c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % mod;\n    \t\t\treturn c;\n    \t\t}\n    \t\tstatic int x[N], y[N];\n    \t\tint n = 1; for (; n <= a.deg() + b.deg(); n <<= 1);\n    \t\tmemset(x, 0, sizeof(int) * n);\n    \t\tmemset(y, 0, sizeof(int) * n);\n    \t\ta.print(x), b.print(y);\n    \t\tdft(x, n, 1), dft(y, n, 1);\n    \t\tfor (int i = 0; i < n; ++i) x[i] = 1LL * x[i] * y[i] % mod;\n    \t\tdft(x, n, -1);\n    \t\tpoly c;\n    \t\tc.scan(x, a.deg() + b.deg());\n    \t\treturn c;\n    \t}\n    \t//\u9664\u6cd5\n    \tfriend inline poly operator / (poly a, poly b)\n    \t{\n    \t\ta.maintain(), b.maintain();\n    \t\tstatic int A[N], B[N], D[N];\n    \t\tint n = a.print(A);\n    \t\tint m = b.print(B);\n    \t\tpoly d;\n    \t\tget_division(A, B, D, n + 1, m + 1);\n    \t\td.scan(D, max(n - m + 1, 0));\n    \t\td.maintain();\n    \t\treturn d;\n    \t}\n    \t//\u53d6\u6a21\n    \tfriend inline poly operator % (poly a, poly b)\n    \t{\n    \t\tpoly d = a / b;\n    \t\tpoly r = a - b * d;\n    \t\tr.maintain();\n    \t\treturn r;\n    \t}\n\n\n    \t//\u6c42\u9006\u5143 (\u6ee1\u8db3\uff1a\u5e38\u6570\u9879\u53ef\u4ee5\u6c42\u9006(\u4e0d\u4e3a0))\n    \tinline poly inv();\n    \t//\u6c42ln (\u6ee1\u8db3\uff1a\u591a\u9879\u5f0f\u53ef\u4ee5\u6c42\u9006)\n    \tinline poly ln();\n    \t//\u6c42exp (\u6ee1\u8db3\uff1a\u591a\u9879\u5f0f\u5e38\u6570\u9879\u4e3a0)\n    \tinline poly exp();\n    \t//\u5f00\u6839\u53f7 (\u6ee1\u8db3\uff1a\u591a\u9879\u5f0f\u5e38\u6570\u9879\u6709\u4e8c\u6b21\u5269\u4f59)\n    \tinline poly sqrt();\n    \t//\u5feb\u901f\u5e42\u524dn\u9879 (\u6ee1\u8db3\uff1a\u591a\u9879\u5f0f\u5e38\u6570\u9879\u4e3a1)\n    \tinline poly pow(int);\n    \t//\u6b27\u62c9\u516c\u5f0f\n    \tinline pair< poly, poly > euler();\n    \t//\u6c42sin\n    \tinline poly sin();\n    \t//\u6c42cos\n    \tinline poly cos();\n    \t//\u6c42tan\n    \tinline poly tan();\n    \t//\u4e58\u65b9\n    \tfriend inline poly operator ^ (poly a, int x)\n    \t{\n    \t\tint j = -1;\n    \t\tfor (int i = 0; i <= a.deg(); ++i)\n    \t\t{\n    \t\t\tif (a[i])\n    \t\t\t{\n    \t\t\t\tj = i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tint n = a.deg();\n    \t\tif (~j) return poly(0, 0);\n    \t\tif (1LL * j * x > n) return poly(0, 0);\n    \t\tfor (int i = 0; i <= n - j; ++i)\n    \t\t\ta[i] = a[i + j];\n    \t\ta.redeg(n - j);\n    \t\tint INV = ::inv(a[0]), X = fpow(a[2], x);\n    \t\tfor (int i = 0; i <= n - j; ++i) a[i] = 1LL * a[i] * INV % mod;\n    \t\ta = a.pow(x);\n    \t\tfor (int i = 0; i <= n - j; ++i) a[i] = 1LL * a[i] * X % mod;\n    \t\tj = fpow(j, x);\n    \t\ta.redeg(n);\n    \t\tfor (int i = n; i >= j; --i) a[i] = a[i - j];\n    \t\tfor (int i = j - 1; ~i; --i) a[i] = 0;\n    \t\treturn a;\n    \t}\n    };\n\n    inline poly get_exp(poly &x, int n)\n    {\n    \tif (!n)\n    \t{\n    \t\tif (x[0]) throw \"error!\";\n    \t\treturn poly(0, 1);\n    \t}\n    \tpoly F = get_exp(x, n >> 1);\n    \tF.redeg(n);\n    \tpoly G = poly(0, 1) - F.ln();\n    \tG.redeg(n);\n    \tfor (int i = 0; i <= n && i <= x.deg(); ++i)\n    \t\tG[i] = inc(G[i], x.a[i]);\n    \tF = G * F;\n    \tF.redeg(n);\n    \tF.maintain();\n    \treturn F;\n    }\n\n    inline poly poly::inv()\n    {\n    \tint n = deg();\n    \tstatic int a[N], r[N];\n    \tpoly c;\n    \tmemset(a, 0, sizeof(int) * (n + 1));\n    \tmemset(r, 0, sizeof(int) * (n + 1));\n    \tprint(a);\n    \tget_inv(a, r, n + 1);\n    \tc.scan(r, n);\n    \treturn c;\n    }\n\n    inline poly poly::ln()\n    {\n    \tpoly a = this -> diff();\n    \tpoly b = this -> inv();\n    \tpoly c = (a * b).integral();\n    \tc.redeg(deg());\n    \tc.maintain();\n    \treturn c;\n    }\n\n    inline poly poly::exp() { return get_exp(*this, deg()); }\n\n    inline poly poly::sqrt()\n    {\n    \tint n = deg();\n    \tstatic int a[N], r[N];\n    \tpoly c;\n    \tmemset(a, 0, sizeof(int) * (n + 1));\n    \tmemset(r, 0, sizeof(int) * (n + 1));\n    \tprint(a);\n    \tget_sqrt(a, r, n + 1);\n    \tc.scan(r, n);\n    \treturn c;\n    }\n\n    inline poly poly::pow(int x)\n    {\n    \tif (a[0] != 1) throw \"error!\";\n    \tint n = deg();\n    \tpoly c = this -> ln();\n    \tc = c * x;\n    \tc = c.exp();\n    \tc.redeg(n);\n    \treturn c;\n    }\n\n    //\u4e09\u89d2\u51fd\u6570\u64cd\u4f5c\n\n    namespace trigonometric_function\n    {\n\n    \tstruct complex\n    \t{\n    \t\tint a, b;\n    \t\tcomplex(int _a = 0, int _b = 0) : a(_a), b(_b) {  }\n    \t\tinline complex operator + (const complex &x) { return complex(inc(a, x.a), inc(b, x.b)); }\n    \t\tinline complex operator - (const complex &x) { return complex(dec(a, x.a), dec(b, x.b)); }\n    \t\tinline complex operator * (const complex &x)\n    \t\t{\n    \t\t\treturn complex(dec(1LL * a * x.a % mod, 1LL * b * x.b % mod), inc(1LL * a * x.b % mod, 1LL * b * x.a % mod));\n    \t\t}\n    \t\tinline complex operator * (const int &x) { return complex(1LL * a * x % mod, 1LL * b * x % mod); }\n    \t\tinline complex inv()\n    \t\t{\n    \t\t\tint v = size();\n    \t\t\tv = ::inv(v);\n    \t\t\treturn complex(a, dec(0, b)) * v;\n    \t\t}\n    \t\tinline int size()\n    \t\t{\n    \t\t\treturn (1LL * a * a + 1LL * b * b) % mod;\n    \t\t}\n    \t};\n\n    \tinline void dft(complex *a, int n, int sig)\n    \t{\n    \t\tfor (int i = 0, j = 0; i < n; ++i)\n    \t\t{\n    \t\t\tif (i > j) swap(a[i], a[j]);\n    \t\t\tfor (int l = n >> 1; (j ^= l) < l; l >>= 1);\n    \t\t}\n    \t\tfor (int i = 1; i < n; i <<= 1)\n    \t\t{\n    \t\t\tint m = i << 1;\n    \t\t\tint w = fpow(modg, (mod - 1) / m);\n    \t\t\tif (sig == -1) w = inv(w);\n    \t\t\tfor (int j = 0; j < n; j += m)\n    \t\t\t\tfor (int k = 0, v = 1; k < i; ++k, v = 1LL * v * w % mod)\n    \t\t\t\t{\n    \t\t\t\t\tcomplex x = a[j + k], y = a[j + i + k] * v;\n    \t\t\t\t\ta[j + k] = x + y, a[j + i + k] = x - y;\n    \t\t\t\t}\n    \t\t}\n    \t\tif (sig == -1)\n    \t\t{\n    \t\t\tint invn = inv(n);\n    \t\t\tfor (int i = 0; i < n; ++i)\n    \t\t\t\ta[i] = a[i] * invn;\n    \t\t}\n    \t}\n\n    \tinline void get_inv(complex *a, complex *r, int n)\n    \t{\n    \t\tif (n == 1)\n    \t\t{\n    \t\t\tr[0] = a[0].inv();\n    \t\t\tif (!a[0].size()) throw \"error!\";\n    \t\t\treturn;\n    \t\t}\n    \t\tstatic complex x[N], y[N], z[N];\n    \t\tget_inv(a, x, (n + 1) >> 1);\n    \t\tint m = 1;\n    \t\tfor (; m < (n << 1); m <<= 1);\n    \t\tmemset(y, 0, sizeof(complex) * m);\n    \t\tmemset(z, 0, sizeof(complex) * m);\n    \t\tmemcpy(y, x, sizeof(complex) * ((n + 1) >> 1));\n    \t\tmemcpy(z, a, sizeof(complex) * n);\n    \t\tdft(y, m, 1); dft(z, m, 1);\n    \t\tfor (int i = 0; i < m; ++i)\n    \t\t\tz[i] = y[i] * 2 - y[i] * y[i] * z[i];\n    \t\tdft(z, m, -1);\n    \t\tmemcpy(r, z, sizeof(complex) * n);\n    \t}\n\n    \tinline void get_ln(complex *a, complex *r, int n)\n    \t{\n    \t\tstatic complex x[N], y[N];\n    \t\tmemcpy(x, a, sizeof(complex) * n);\n    \t\tfor (int i = 1; i < n; ++i) x[i - 1] = x[i] * i;\n    \t\tx[n - 1] = complex();\n    \t\tget_inv(a, y, n);\n    \t\tint m = 1;\n    \t\tfor (; m < (n << 1); m <<= 1);\n    \t\tstatic complex A[N], B[N];\n    \t\tmemset(A, 0, sizeof(complex) * m);\n    \t\tmemcpy(A, x, sizeof(complex) * n);\n    \t\tmemset(B, 0, sizeof(complex) * m);\n    \t\tmemcpy(B, y, sizeof(complex) * n);\n    \t\tdft(A, m, 1), dft(B, m, 1);\n    \t\tfor (int i = 0; i < m; ++i) A[i] = A[i] * B[i];\n    \t\tdft(A, m, -1);\n    \t\tmemcpy(r, A, sizeof(complex) * (n - 1));\n    \t\tstatic int Inv[N];\n    \t\tstatic int init_n;\n    \t\tif (!init_n)\n    \t\t\tinit_n = Inv[1] = 1;\n    \t\tif (init_n < n)\n    \t\t{\n    \t\t\tfor (int i = init_n + 1; i <= n; ++i)\n    \t\t\t\tInv[i] = dec(mod, 1LL * Inv[mod % i] * (mod / i) % mod);\n    \t\t\tinit_n = n;\n    \t\t}\n    \t\tfor (int i = n; i; --i) r[i] = r[i - 1] * Inv[i];\n    \t\tr[0] = complex(0, 0);\n    \t}\n\n    \tinline void get_exp(complex *a, complex *r, int n)\n    \t{\n    \t\tif (!n)\n    \t\t{\n    \t\t\tif (a[0].a || a[0].b) throw \"error!\";\n    \t\t\tr[0] = complex(1);\n    \t\t\treturn;\n    \t\t}\n    \t\tstatic complex x[N];\n    \t\tget_exp(a, x, n >> 1);\n    \t\tstatic complex y[N];\n    \t\tmemset(y, 0, sizeof(complex) * (n + 1));\n    \t\tmemcpy(y, x, sizeof(complex) * ((n >> 1) + 1));\n    \t\tstatic complex z[N];\n    \t\tget_ln(y, z, n + 1);\n    \t\tstatic complex w[N];\n    \t\tmemset(w, 0, sizeof(complex) * (n + 1));\n    \t\tmemcpy(w, z, sizeof(complex) * (n + 1));\n    \t\tw[0] = complex(1) - w[0];\n    \t\tfor (int i = 1; i <= n; ++i)\n    \t\t\tw[i] = complex(0) - w[i];\n    \t\tfor (int i = 0; i <= n; ++i)\n    \t\t\tw[i] = w[i] + a[i];\n    \t\tint m = 1;\n    \t\tfor (; m < (n << 1); m <<= 1);\n    \t\tstatic complex t[N], s[N];\n    \t\tmemset(s, 0, sizeof(complex) * m);\n    \t\tmemcpy(s, x, sizeof(complex) * ((n >> 1) + 1));\n    \t\tmemset(t, 0, sizeof(complex) * m);\n    \t\tmemcpy(t, w, sizeof(complex) * (n + 1));\n    \t\tdft(s, m, 1), dft(t, m, 1);\n    \t\tfor (int i = 0; i < m; ++i) s[i] = s[i] * t[i];\n    \t\tdft(s, m, -1);\n    \t\tmemcpy(r, s, sizeof(complex) * (n + 1));\n    \t}\n\n    }\n\n    inline pair< poly, poly > poly::euler()\n    {\n    \tstatic trigonometric_function::complex x[N], y[N];\n    \tint n = deg();\n    \tfor (int i = 0; i <= n; ++i) x[i] = trigonometric_function::complex(0, a[i]);\n    \tpoly a, b;\n    \ttrigonometric_function::get_exp(x, y, n);\n    \tstatic int A[N], B[N];\n    \tfor (int i = 0; i <= n; ++i) A[i] = y[i].a, B[i] = y[i].b;\n    \ta.scan(A, n);\n    \tb.scan(B, n);\n    \treturn make_pair(a, b);\n    }\n\n    inline poly poly::sin() { return euler().second; }\n\n    inline poly poly::cos() { return euler().first; }\n\n    inline poly poly::tan()\n    {\n    \tpair< poly, poly > res = euler();\n    \tres.first = res.first.inv();\n    \tpoly v = res.first * res.second;\n    \tv.redeg(deg());\n    \treturn v;\n    }\n}\n\nusing polynomial::poly;\n\npoly ans, p;\n\nint main() {\n    scanf(\"%d\", &n);\n    init(200000);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", a + i, b + i);\n    }\n    ans = poly(0, 1);\n    int t = 0;\n    for (int i = 1; i <= n; ++i) {\n        //[b[i] - t, a[i]]\n        static int x[5010]; int tp = 0;\n        for (int j = b[i] - t; j <= a[i] + t; ++j)\n            x[tp] = C(a[i] + b[i], j), tp++;\n        p.scan(x, tp - 1);\n        poly now = ans * p;\n        ans.redeg(now.deg() - 2 * t);\n        for (int j = t; j <= now.deg() - t; ++j) {\n            ans[j - t] = now[j];\n        }\n        t += a[i] - b[i];\n    }\n    int res = 0;\n    for (int i = 0; i <= ans.deg(); ++i) res = inc(res, ans[i]);\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef NeverBeRed\n#include \"debug.h\"\n#else\n#define debug(...) 9715\n#endif\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\n#define F first\n#define S second\n\ntemplate<typename T, typename U>\nT pow_mod(T a, U b, int mod)\n{\n\tT r = 1;\n\tfor (; b > 0; b >>= 1)\n\t{\n\t\tif (b & 1) r = (ll)r * a % mod;\n\t\ta = (ll)a * a % mod;\n\t}\n\treturn r;\n}\n\nnamespace ntt\n{\n\tconst int mod = 998244353;\n\tconst int root = 5;\n\n\tint base = 1;\n\tvector<int> roots;\n\n\tvoid ensure_base(int nbase)\n\t{\n\t\tif (nbase <= base) return;\n\t\troots.resize(nbase);\n\t\tfor (int mh = base; mh << 1 <= nbase; mh <<= 1)\n\t\t{\n\t\t\tint wm = pow_mod(root, (mod - 1) / (mh << 1), mod);\n\t\t\troots[mh] = 1;\n\t\t\tfor (int i = 1; i < mh; ++i)\n\t\t\t\troots[i + mh] = (ll)roots[i + mh - 1] * wm % mod;\n\t\t}\n\t\tbase = nbase;\n\t}\n\n\tvoid fft(int a[], int n, int sign)\n\t{\n\t\tensure_base(n);\n\n\t\tfor (int i = 1, j = 0; i < n - 1; ++i)\n\t\t{\n\t\t\tfor (int k = n >> 1; (j ^= k) < k; k >>= 1);\n\t\t\tif (i < j) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m, mh = 1; (m = mh << 1) <= n; mh = m)\n\t\t\tfor (int i = 0; i < n; i += m)\n\t\t\t\tfor (int j = i; j < i + mh; ++j)\n\t\t\t\t{\n\t\t\t\t\tint y = (ll)a[j + mh] * roots[j - i + mh] % mod;\n\t\t\t\t\tif ((a[j + mh] = a[j] - y) < 0) a[j + mh] += mod;\n\t\t\t\t\tif ((a[j] += y) >= mod) a[j] -= mod;\n\t\t\t\t}\n\n\t\tif (sign < 0)\n\t\t{\n\t\t\tint inv = pow_mod(n, mod - 2, mod);\n\t\t\tfor (int i = 0; i < n; ++i) a[i] = (ll)a[i] * inv % mod;\n\t\t\treverse(a + 1, a + n);\n\t\t}\n\t}\n\n\tvector<int> convolve(vector<int> x, vector<int> y)\n\t{\n\t\tint n = x.size() + y.size() - 1, sz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tx.resize(sz);\n\t\ty.resize(sz);\n\t\tfft(x.data(), sz, +1);\n\t\tfft(y.data(), sz, +1);\n\t\tfor (int i = 0; i < sz; ++i)\n\t\t\tx[i] = (ll)x[i] * y[i] % mod;\n\t\tfft(x.data(), sz, -1);\n\t\tx.resize(n);\n\t\treturn x;\n\t}\n}\n\nnamespace combinatorics\n{\n\tconst int mod = 998244353, N = 2e5+5;\n\tint fac[N], ifac[N];\n\n\tvoid init()\n\t{\n\t\tfac[0] = ifac[0] = 1;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tfac[i] = (ll)fac[i-1] * i % mod;\n\t\t\tifac[i] = pow_mod(fac[i], mod-2, mod);\n\t\t}\n\t}\n\n\tint comb(int n, int k)\n\t{\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn (ll)fac[n] * ifac[n-k] % mod * ifac[k] % mod;\n\t}\n}\n\nusing namespace combinatorics;\n\nint main()\n{\n\t#ifdef TurnRed\n\t\t//freopen(\"a.in\", \"r\", stdin);\n\t\t//freopen(\"a.out\", \"w\", stdout);\n\t#endif\n\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> p = { 1 };\n\tfor (int a, b; n--; )\n\t{\n\t\tcin >> a >> b;\n\n\t\tint sz = p.size();\n\t\tvector<int> q(2 * sz + a - b);\n\t\tfor (size_t i = 0; i < q.size(); ++i)\n\t\t\tq[i] = comb(a + b, b + i - sz);\n\n\t\tp = ntt::convolve(p, q);\n\t\tp.erase(p.begin(), p.begin() + sz);\n\t\tp.resize(sz + a - b);\n\t}\n\n\tint ans = 0;\n\tfor (auto i : p)\n\t\tans = (ans + i) % ntt::mod;\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class G4 {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n \n\tfinal int mod = 998244353;\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] fif = enumFIF(200005, mod);\n\t\tlong[] base = {1L};\n\t\tint L = base.length;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint a = ni(), b = ni();\n \n\t\t\tint h = (L+a-b)/2;\n\t\t\tlong[] cs = new long[h+1+(L-1+1)];\n\t\t\tfor(int d = -(L-1);d < h+1;d++) {\n\t\t\t\tcs[d + L - 1] = C(a + b, d + b, mod, fif);\n\t\t\t}\n \n\t\t\tbase = Arrays.copyOfRange(NTTStockham998244353.convolute(base, cs), L - 1, L - 1 + L + a - b);\n\t\t\tfor(int j = h;j < L+a-b;j++){\n\t\t\t\tbase[j] = base[L+a-b-1-j];\n\t\t\t}\n\t\t\tL += a - b;\n\t\t}\n \n\t\tlong ans = 0;\n\t\tfor(long v : base){\n\t\t\tans += v;\n\t\t}\n\t\tout.println(ans%mod);\n\t}\n \n \n \n\tfinal long big = 8L*mod*mod;\n\tpublic long[] mulnaive(long[] a, long[] b)\n\t{\n\t\tlong[] c = new long[a.length+b.length-1];\n\t\tfor(int i = 0;i < a.length;i++){\n\t\t\tfor(int j = 0;j < b.length;j++){\n\t\t\t\tc[i+j] += a[i]*b[j];\n\t\t\t\tif(c[i+j] >= big)c[i+j] -= big;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < c.length;i++)c[i] %= mod;\n\t\treturn c;\n\t}\n \n \n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n) return 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n \n \n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][]{f, invf};\n\t}\n \n \n\tpublic static class NTTStockham998244353 {\n\t\tprivate static final int P = 998244353, mod = P, G = 3;\n\t\tprivate static long[] wps;\n \n\t\tpublic static long[] convolute(long[] a, long[] b)\n\t\t{\n\t\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n \n\t\t\twps = new long[m];\n\t\t\tlong unit = pow(G, (P-1)/m);\n\t\t\twps[0] = 1;\n\t\t\tfor(int p = 1;p < m;p++) {\n\t\t\t\twps[p] = wps[p-1] * unit % mod;\n\t\t\t}\n \n\t\t\tlong[] fa = go(a, m, false);\n\t\t\tlong[] fb = a == b ? fa : go(b, m, false);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i] % mod;\n\t\t\t}\n\t\t\tfa = go(fa, m, true);\n\t\t\tfor(int i = 1, j = m-1;i < j;i++,j--) {\n\t\t\t\tlong d = fa[i]; fa[i] = fa[j]; fa[j] = d;\n\t\t\t}\n\t\t\treturn fa;\n\t\t}\n \n\t\tprivate static void fft(long[] X, long[] Y)\n\t\t{\n\t\t\tint s = 1;\n\t\t\tboolean eo = false;\n\t\t\tfor(int n = X.length;n >= 4;n /= 2) {\n\t\t\t\tint m = n/2;\n\t\t\t\tfor(int p = 0;p < m;p++) {\n\t\t\t\t\tlong wp = wps[s*p];\n\t\t\t\t\tlong wk = (wp<<32)/P;\n\t\t\t\t\tfor(int q = 0;q < s;q++) {\n\t\t\t\t\t\tlong a = X[q + s*(p+0)];\n\t\t\t\t\t\tlong b = X[q + s*(p+m)];\n\t\t\t\t\t\tlong ndsts = a + b;\n\t\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\t\tlong T = a - b + 2*P;\n\t\t\t\t\t\tlong Q = wk*T>>>32;\n\t\t\t\t\t\tY[q + s*(2*p+0)] = ndsts;\n\t\t\t\t\t\tY[q + s*(2*p+1)] = wp*T-Q*P&(1L<<32)-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts *= 2;\n\t\t\t\teo = !eo;\n\t\t\t\tlong[] D = X; X = Y; Y = D;\n\t\t\t}\n\t\t\tlong[] z = eo ? Y : X;\n\t\t\tfor(int q = 0;q < s;q++) {\n\t\t\t\tlong a = X[q + 0];\n\t\t\t\tlong b = X[q + s];\n\t\t\t\tz[q+0] = (a+b) % P;\n\t\t\t\tz[q+s] = (a-b+2*P) % P;\n\t\t\t}\n\t\t}\n \n\t\t//\tprivate static void fft(long[] X, long[] Y)\n\t\t//\t{\n\t\t//\t\tint s = 1;\n\t\t//\t\tboolean eo = false;\n\t\t//\t\tfor(int n = X.length;n >= 4;n /= 2) {\n\t\t//\t\t\tint m = n/2;\n\t\t//\t\t\tfor(int p = 0;p < m;p++) {\n\t\t//\t\t\t\tlong wp = wps[s*p];\n\t\t//\t\t\t\tfor(int q = 0;q < s;q++) {\n\t\t//\t\t\t\t\tlong a = X[q + s*(p+0)];\n\t\t//\t\t\t\t\tlong b = X[q + s*(p+m)];\n\t\t//\t\t\t\t\tY[q + s*(2*p+0)] = (a+b) % P;\n\t\t//\t\t\t\t\tY[q + s*(2*p+1)] = (a-b+P) * wp % P;\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t\ts *= 2;\n\t\t//\t\t\teo = !eo;\n\t\t//\t\t\tlong[] D = X; X = Y; Y = D;\n\t\t//\t\t}\n\t\t//\t\tlong[] z = eo ? Y : X;\n\t\t//\t\tfor(int q = 0;q < s;q++) {\n\t\t//\t\t\tlong a = X[q + 0];\n\t\t//\t\t\tlong b = X[q + s];\n\t\t//\t\t\tz[q+0] = (a+b) % P;\n\t\t//\t\t\tz[q+s] = (a-b+P) % P;\n\t\t//\t\t}\n\t\t//\t}\n \n\t\tprivate static long[] go(long[] src, int n, boolean inverse)\n\t\t{\n\t\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\tfft(dst, new long[n]);\n\t\t\tif(inverse){\n\t\t\t\tlong in = invl(n);\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tdst[i] = dst[i] * in % mod;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\treturn dst;\n\t\t}\n \n\t\tprivate static long pow(long a, long n) {\n\t\t\t//\t\ta %= mod;\n\t\t\tlong ret = 1;\n\t\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\t\tfor (; x >= 0; x--) {\n\t\t\t\tret = ret*ret % mod;\n\t\t\t\tif (n<<~x<0)ret = ret*a%mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tprivate static long invl(long a) {\n\t\t\tlong b = mod;\n\t\t\tlong p = 1, q = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tlong c = a / b;\n\t\t\t\tlong d;\n\t\t\t\td = a;\n\t\t\t\ta = b;\n\t\t\t\tb = d % b;\n\t\t\t\td = p;\n\t\t\t\tp = q;\n\t\t\t\tq = d - c * q;\n\t\t\t}\n\t\t\treturn p < 0 ? p + mod : p;\n\t\t}\n\t}\n \n \n\tvoid run() throws Exception\n\t{\n//\t\tint n = 1000, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(100000 + \" \");\n//\t\t\tsb.append(99995 + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n \n \n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new G4().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n \n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n \n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n \n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n \n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n \n\tprivate int ni() { return (int)nl(); }\n \n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n \n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n \n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n \n\t\tprivate FastWriter(){out = null;}\n \n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n \n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n \n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n \n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n \n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n \n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n \n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n \n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n \n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n \n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n \n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n \n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n \n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n \n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n \n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n \n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n \n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n \n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n \n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n \n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n \n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n \n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n\t   \t\t\t  \t\t  \t\t\t\t  \t  \t\t  \t\t \t"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x)  (int)x.size()\n#define cl(x)  x.clear()\n#define all(x)  x.begin() , x.end()\n#define rep(i , x , n)  for(int i = x ; i <= n ; i ++)\n#define per(i , n , x)  for(int i = n ; i >= x ; i --)\n#define mem0(x)  memset(x , 0 , sizeof(x))\n#define mem_1(x)  memset(x , -1 , sizeof(x))\n#define mem_inf(x)  memset(x , 0x3f , sizeof(x))\n#define debug(x)  cerr << #x << \" = \" << x << '\\n'\n#define ddebug(x , y)  cerr << #x << \" = \" << x << \"   \" << #y << \" = \" << y << '\\n'\n#define ios std::ios::sync_with_stdio(false) , cin.tie(0)\nusing namespace std ;\ntypedef long long ll ;\ntypedef long double ld ;\ntypedef pair<int , int> pii ;\ntypedef pair<ll , ll> pll ;\ntypedef double db ;\nconst int maxn = 2e5 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst double eps = 1e-6 ; \nconst int mod = 998244353 ;\nstruct NTT\n{\n    int n , m ;\n    ll a[maxn << 2] , b[maxn << 2] ;\n    ll up , l ;\n    ll pos[maxn << 2] ;\n    ll powmod(ll a , ll b)\n    {\n        ll ans = 1 ;\n        while(b)\n        {\n            if(b & 1)  ans = ans * a % mod ;\n            a = a * a % mod ;\n            b >>= 1 ;\n        }\n        return ans ;\n    }\n    void init(int n , int m) \n    {\n        up = 1 , l = 0 ;\n        while(up < (n + m))  up <<= 1 , l ++ ;\n        rep(i , 0 , up - 1)  pos[i] = (pos[i >> 1] >> 1) | ((i & 1) << (l - 1)) , a[i] = b[i] = 0 ;\n    }\n    void solve(ll *a , int mode)\n    {\n        rep(i , 0 , up - 1)  if(i < pos[i])  swap(a[i] , a[pos[i]]) ;\n        for(int i = 1 ; i < up ; i <<= 1)\n        {\n            ll gn = powmod(3 , (mod - 1) / (i << 1)) ; \n            if(mode == -1)  gn = powmod(gn , mod - 2) ;\n            for(int j = 0 ; j < up ; j += (i << 1))\n            {\n                ll g = 1 ;\n                for(int k = 0 ; k < i ; k ++ , g = g * gn % mod)\n                {\n                    ll x = a[j + k] , y = g * a[j + k + i] % mod ;\n                    a[j + k] = (x + y) % mod , a[j + k + i] = (x - y + mod) % mod ;\n                }\n            }\n        }\n        if(mode == -1) \n        {\n            ll invup = powmod(up , mod - 2) ;\n            rep(i , 0 , up - 1)  a[i] = a[i] * invup % mod ;\n        }\n    }\n} ntt ; \nstruct Easymath\n{\n    ll qpow(ll a , ll b) //\u5feb\u901f\u5e42\n    {\n        if(b < 0)  return 0 ;\n        ll ans = 1 ; \n        a %= mod ;\n        while(b)\n        {\n            if(b & 1)  ans = (ans * a) % mod ;\n            b >>= 1 , a = (a * a) % mod ;\n        }\n        return ans % mod ;\n    }\n    ll ksc_log(ll x , ll y , ll mod) //\u5feb\u901f\u4e58\n    {\n        x %= mod , y %= mod ;\n        ll ans = 0;\n        while(y)\n        {\n            if(y & 1) ans = (ans + x) % mod ; \n            y >>= 1 ;\n            x = (x + x) % mod ;\n        }\n        return ans;\n    }\n    ll ksc_O1(ll x , ll y , ll mod) //\u5feb\u901f\u4e58\n    {\n        x %= mod , y %= mod ;\n        ll z = (ld)x * y / mod ;\n        ll ans = x * y - z * mod ;\n        if(ans < 0)  ans += mod ;\n        else if(ans >= mod)  ans -= mod ;\n        return ans ;\n    }\n    int cnt = 0 ;\n    bool vis[maxn] ;\n    int prime[maxn] ;\n    void get_prime(int up) //\u7d20\u6570\u7b5b\n    {\n        memset(vis , 0 , sizeof(vis)) ;\n        vis[1] = 1 ;\n        for(int i = 2 ; i <= up ; i ++)\n        {\n            if(!vis[i]) \n            prime[++ cnt] = i ;\n            for(int j = 1 ; j <= cnt && i * prime[j] <= up ; j ++)\n            {\n                vis[i * prime[j]] = 1 ;\n                if(i % prime[j] == 0) break ;\n            }\n        }\n    }\n    //begin \u5224\u5b9a\u5927\u7d20\u6570\n    ll mul(ll a , ll b , ll mod)\n    {\n        ll ret = 0 ;\n        while(b) \n        {\n            if(b & 1)  ret = (ret + a) % mod ;\n            a = (a + a) % mod ;\n            b >>= 1 ;\n        }\n        return ret ;\n    }\n    ll pow(ll a , ll b , ll mod)\n    {\n        ll ret = 1 ;\n        while(b) \n        {\n            if(b & 1)  ret = mul(ret , a , mod) ;\n            a = mul(a , a , mod) ;\n            b >>= 1 ;\n        }\n        return ret ;\n    }\n    bool check(ll a , ll n)\n    {\n        ll x = n - 1 ;\n        int t = 0 ;\n        while((x & 1) == 0) \n        {\n            x >>= 1 ;\n            t ++ ;\n        }\n        x = pow(a , x , n) ;\n        ll y ;\n        rep(i , 1 , t)\n        {\n            y = mul(x , x , n) ;\n            if(y == 1 && x != 1 && x != n - 1)  return 1 ;\n            x = y ;\n        }\n        if(y != 1) return 1 ;\n        return 0 ;\n    }\n    bool Miller_Rabin(ll n) \n    {\n        if(n == 2)  return 1 ;\n        if(n == 1 || !(n & 1))  return 0 ;\n        const int arr[12] = {2,3,5,7,11,13,17,19,23,29,31,37} ;\n        rep(i , 0 , 11) \n        {\n            if(arr[i] >= n) break ;\n            if(check(arr[i] , n)) return 0 ;\n        }\n        return 1 ;\n    }\n    //end \u5224\u5b9a\u5927\u7d20\u6570\n    ll get_inv(ll x) //\u9006\u5143\n    {\n       return qpow(x , mod - 2) % mod ;\n    }\n    ll inv1[maxn] ;  //\u4e58\u6cd5\u9006\u5143\n    void init1(int up)\n    {\n       inv1[1] = 1 ;\n       for(int i = 2 ; i <= up ; i ++)\n         inv1[i] = (ll)(mod - mod / i) * inv1[int(mod % (ll)i)] % mod ;\n    }\n    ll fac[maxn] ;\n    ll inv[maxn] ; //\u9636\u4e58\u9006\u5143\n    void init(int up) \n    {\n       fac[0] = fac[1] = inv[0] = inv[1] = 1 ;\n       for(int i = 2 ; i <= up ; i ++)\n       {\n         fac[i] = fac[i - 1] * i % mod ;\n         inv[i] = -inv[mod % i] * (mod / i) % mod ;\n         while(inv[i] < 0) inv[i] += mod ;\n       }\n       for(int i = 2 ; i <= up ; i ++)  \n         inv[i] = inv[i] * inv[i - 1] % mod ;\n    }\n    ll C(int n , int m)\n    {\n        if(m < 0 || n < m)  return 0 ;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod ;\n    }\n} em ;\nint main()\n{\n    ios ;\n    int n ;\n    cin >> n ;\n    vector<int> dp(10005 , 0) ;\n    em.init(200000) ;\n    int m = 1 ;\n    dp[1] = 1 ;\n    while(n --)\n    {\n        int a , b ;\n        cin >> a >> b ;\n        ntt.init(m + 1 , m + a - b - 1 + m + 1) ;\n        for(int i = 1 ; i <= m ; i ++)  ntt.a[i] = dp[i] ;\n        for(int i = 1 ; i <= m + a - b - 1 + m ; i ++)  ntt.b[i] = em.C(a + b , b + i - m) ;\n        ntt.solve(ntt.a , 1) ;\n        ntt.solve(ntt.b , 1) ;\n        rep(i , 0 , ntt.up - 1)  ntt.a[i] *= ntt.b[i] , ntt.a[i] %= mod ;\n        ntt.solve(ntt.a , -1) ;\n        for(int i = 1 ; i <= m + a - b ; i ++)  dp[i] = ntt.a[i + m] ;\n        m += a - b ;\n    }\n    long long ans = 0 ;\n    for(int i = 1 ; i <= m ; i ++)  ans += dp[i] , ans %= mod ;\n    cout << ans << '\\n' ;\n    return 0 ;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < int(n); i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n \nconst int MX = 200005, mod = 998244353, g = 3;\nint n, a[MX], b[MX];\nll fac[MX], inv[MX];\n \nll pot (ll b, ll p) {\n\tll res = 1;\n\tif (p < 0) p += mod - 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n \nll comb (int n, int k) {\n\treturn fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n \nint nearestPowerOfTwo (int n) {\n\tint ans = 1;\n\twhile (ans < n) ans <<= 1;\n\treturn ans;\n}\n \nvoid ntt (vi &X, int inv) {\n\tint n = X.size();\n\t\n\tfor (int i = 1, j = 0; i < n - 1; ++i) {\n\t\tfor (int k = n >> 1; (j ^= k) < k; k >>= 1);\n\t\tif(i < j) swap(X[i], X[j]);\n\t}\n\t\n\tvector<ll> wp(n >> 1, 1);\n\tfor (int k = 1; k < n; k <<= 1) {\n\t\tll wk = pot(g, inv * (mod - 1) / (k << 1));\n\t\t\n\t\tfor (int j = 1; j < k; ++j)\n\t\t\twp[j] = wp[j - 1] * wk % mod;\n\t\t\n\t\tfor (int i = 0; i < n; i += k << 1) {\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint u = X[i + j], v = X[i + j + k] * wp[j] % mod;\n\t\t\t\tX[i + j] = u + v < mod ? u + v : u + v - mod;\n\t\t\t\tX[i + j + k] = u - v < 0 ? u - v + mod : u - v;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (inv == -1) {\n\t\tll nrev = pot(n, mod - 2);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tX[i] = X[i] * nrev % mod;\n\t}\n}\n \nvi convolution (vi A, vi B){\n\tint sz = A.size() + B.size() - 1;\n\tint size = nearestPowerOfTwo(sz);\n\t\n\tA.resize(size), B.resize(size);\n\tntt(A, 1), ntt(B, 1);\n\t\n\tfor(int i = 0; i < size; i++)\n\t\tA[i] = 1ll * A[i] * B[i] % mod;\n\t\n\tntt(A, -1);\n\tA.resize(sz);\n\t\n\treturn A;\n}\n \nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < MX; i++) {\n\t\tfac[i] = i * fac[i - 1] % mod;\n\t\tinv[i] = pot(fac[i], mod - 2);\n\t}\n\t\n\tcin >> n;\n\tforn (i, n) cin >> a[i] >> b[i];\n\t\n\tvi res = {1};\n\tforn (i, n) {\n\t\tint sz = (int)res.size() + a[i] - b[i];\n\t\tint ini = max(0, b[i] - (int)res.size() + 1);\n\t\tint fin = min(a[i] + b[i], b[i] + sz - 1);\n\t\t\n\t\tvi p(fin - ini + 1);\n\t\tforn (j, p.size())\n\t\t\tp[j] = comb(a[i] + b[i], ini + j);\n\t\t\n\t\tvi q = convolution(res, p);\n\t\t\n\t\tres.resize(sz);\n\t\tfor (int j = 0, k = b[i] - ini; j < sz; j++, k++)\n\t\t\tres[j] = q[k];\n\t}\n\t\n\tcout << accumulate(all(res), 0, [&] (int a, int b) {\n\t\treturn (a + b) % mod;\n\t}) % mod << endl;\n \n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n \n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n \n  inline explicit operator bool() {\n    return cur != -1;\n  }\n \n  inline static bool is_blank(char c) {\n    return c <= ' ';\n  }\n \n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn't check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == '-') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - '0';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n \n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), \"%lf\", &n);\n    }\n    return *this;\n  }\n} fast_input;\n \n#define cin fast_input\n \nstatic struct FastOutput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t buf_pos = 0;\n  static constexpr int TMP_SIZE = 1 << 20;\n  char tmp[TMP_SIZE];\n  FILE *out = stdout;\n \n  inline void put_char(char c) {\n    buf[buf_pos++] = c;\n    if (buf_pos == BUF_SIZE) {\n      fwrite(buf, 1, buf_pos, out);\n      buf_pos = 0;\n    }\n  }\n \n  ~FastOutput() {\n    fwrite(buf, 1, buf_pos, out);\n  }\n \n  inline FastOutput& operator<<(char c) {\n    put_char(c);\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const char* s) {\n    while (*s) {\n      put_char(*s++);\n    }\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const string& s) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      put_char(s[i]);\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline char* integer_to_string(T n) {\n    // beware of TMP_SIZE\n    char* p = tmp + TMP_SIZE - 1;\n    if (n == 0) {\n      *--p = '0';\n    } else {\n      bool is_negative = false;\n      if (n < 0) {\n        is_negative = true;\n        n = -n;\n      }\n      while (n > 0) {\n        *--p = (char) ('0' + n % 10);\n        n /= 10;\n      }\n      if (is_negative) {\n        *--p = '-';\n      }\n    }\n    return p;\n  }\n \n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n    return integer_to_string(n);\n  }\n \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline char* stringify(__int128 n) {\n    return integer_to_string(n);\n  }\n  #endif\n \n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n    sprintf(tmp, \"%.17f\", n);\n    return tmp;\n  }\n \n  template <typename T>\n  inline FastOutput& operator<<(const T& n) {\n    auto p = stringify(n);\n    for (; *p != 0; p++) {\n      put_char(*p);\n    }\n    return *this;\n  }\n} fast_output;\n\n// here puts define\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n#define rint register int\n#define rll register ll \n#define pii pair<int, int>\n#define pll pair<ll, ll>\n//#define p1 first\n//#define p2 second\n#define fors(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define _fors(i, a, b) for (ll i = (a); i >= (b); --i)\n#define mp(a, b) make_pair(a, b)\n#define mt(a, b, c) make_tuple(a, b, c)\n#define mem(A, b) memset(A, b, sizeof(A))\n#define all(X) (X).begin(), (X).end()\n#define pb push_back\n#define eb emplace_back\n#define cout fast_output\n#define endl '\\n'\n\nconst int mod = 998244353;\nconst int maxn = 1e6 + 5;\n\ninline int add(int a, int b) {\n  return (((a + b) % mod) + mod) % mod;\n}\n\ninline int mul(int a, int b) {\n  return (((1LL * a * b) % mod) + mod) % mod;\n}\n\ninline int qpow(int a, int p) {\n  int ret = 1;\n  while (p) {\n    if (p & 1) ret = mul(ret, a);\n    a = mul(a, a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nint cda[4*maxn], cdb[4*maxn];\nint res[4*maxn];\n\ninline void NTT(int* a, int a_size, bool inverse) {\n  int n = a_size;\n  // \u539f\u5730\u5feb\u901fbit reversal\n  for(int i = 0, j = 0; i < n; i++) {\n    if(j > i) swap(a[i], a[j]);\n    int k = n;\n    while(j & (k >>= 1)) j &= ~k;\n    j |= k;\n  }\n\n  int root = inverse ? qpow(3, mod-2) : 3;\n\n  for(int step = 1; step < n; step <<= 1) {\n    int alpha = (mod-1) / step / 2;\n    // \u4e3a\u6c42\u9ad8\u6548\uff0c\u6211\u4eec\u5e76\u4e0d\u662f\u4f9d\u6b21\u6267\u884c\u5404\u4e2a\u5b8c\u6574\u7684DFT\u5408\u5e76\uff0c\u800c\u662f\u679a\u4e3e\u4e0b\u6807k\n    // \u5bf9\u4e8e\u4e00\u4e2a\u4e0b\u6807k\uff0c\u6267\u884c\u6240\u6709DFT\u5408\u5e76\u4e2d\u8be5\u4e0b\u6807\u5bf9\u5e94\u7684\u8774\u8776\u64cd\u4f5c\uff0c\u5373\u901a\u8fc7E[k]\u548cO[k]\u8ba1\u7b97X[k]\n    int omega = qpow(root, alpha), omegak = 1;\n    for(int k = 0; k < step; k++) {\n      // \u8ba1\u7b97omega^k. \u8fd9\u4e2a\u65b9\u6cd5\u6548\u7387\u4f4e\uff0c\u4f46\u5982\u679c\u7528\u6bcf\u6b21\u4e58omega\u7684\u65b9\u6cd5\u9012\u63a8\u4f1a\u6709\u7cbe\u5ea6\u95ee\u9898\u3002\n      // \u6709\u66f4\u5feb\u66f4\u7cbe\u786e\u7684\u9012\u63a8\u65b9\u6cd5\uff0c\u4e3a\u4e86\u6e05\u6670\u8d77\u89c1\u8fd9\u91cc\u7565\u53bb\n      for(int Ek = k; Ek < n; Ek += step << 1) { // Ek\u662f\u67d0\u6b21DFT\u5408\u5e76\u4e2dE[k]\u5728\u539f\u59cb\u5e8f\u5217\u4e2d\u7684\u4e0b\u6807\n        int Ok = Ek + step; // Ok\u662f\u8be5DFT\u5408\u5e76\u4e2dO[k]\u5728\u539f\u59cb\u5e8f\u5217\u4e2d\u7684\u4e0b\u6807\n        int t = mul(a[Ok], omegak); // \u8774\u8776\u64cd\u4f5c\uff1ax1 * omega^k\n        a[Ok] = add(a[Ek], -t);  // \u8774\u8776\u64cd\u4f5c\uff1ay1 = x0 - t\n        a[Ek] = add(a[Ek], t);         // \u8774\u8776\u64cd\u4f5c\uff1ay0 = x0 + t\n      }\n      omegak = mul(omegak, omega);\n    }\n  }\n\n  if(inverse) {\n    int invn = qpow(n, mod - 2);\n    fors(i, 0, n-1) a[i] = mul(a[i], invn);\n  }\n\n  return ;\n}\n\n// \u7528FFT\u5b9e\u73b0\u7684\u5feb\u901f\u591a\u9879\u5f0f\u4e58\u6cd5\ninline int NTT_mul(int* v1, int v1_size, int* v2, int v2_size) {\n  int s1 = v1_size, s2 = v2_size, S = 2;\n  while(S < s1 + s2) S <<= 1;\n  fors(i, 0, S-1) cda[i] = 0, cdb[i] = 0;\n  for(int i = 0; i < s1; i++) cda[i] = v1[i];\n  NTT(cda, S, false);\n  for(int i = 0; i < s2; i++) cdb[i] = v2[i];\n  NTT(cdb, S, false);\n  for(int i = 0; i < S; i++) cda[i] = mul(cda[i], cdb[i]);\n  NTT(cda, S, true);\n  for(int i = 0; i < s1 + s2 - 1; i++) res[i] = cda[i]; // \u865a\u90e8\u5747\u4e3a0\n  return s1 + s2 - 1;\n}\n\nint n;\nint a[maxn], b[maxn], s[maxn], t[maxn], inv[maxn];\nint tab[maxn], itab[maxn];\nint m;\n\nvoid solve() {\n  inv[1] = 1, tab[0] = 1, itab[0] = 1;\n  fors(i, 2, 2e5 + 5) inv[i]= mul(-mod/i, inv[mod%i]);\n  fors(i, 1, 2e5 + 5) tab[i] = mul(tab[i-1], i);\n  fors(i, 1, 2e5 + 5) itab[i] = mul(itab[i-1], inv[i]); \n  cin >> n;\n  fors(i, 1, n) cin >> a[i] >> b[i];\n  s[0] = 1;\n  m = 0;\n  fors(i, 1, n) {\n    fors(j, 0, a[i] + m - b[i] + m) {\n      t[j] = j + b[i] - m <= a[i] + b[i] && j + b[i] - m >= 0 ? mul(tab[a[i] + b[i]], mul(itab[j + b[i] - m], itab[a[i] + m - j])) : 0;\n    }\n    int tmp = NTT_mul(s, m + 1, t, a[i] + m - b[i] + m + 1);\n    fors(j, 0, m + a[i] - b[i]) s[j] = res[j + m];\n    m += a[i] - b[i];\n    // fors(j, 0, s_siz - 1) cout << s[j] << ' ';\n    // cout << endl;\n  }\n  int ret = 0;\n  fors(i, 0, m) ret = add(ret, s[i]);\n  cout << ret << endl;\n  return ;\n}\n\nsigned main() {\n  #ifdef Sakuyalove\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n  #endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int start_time = clock();\n\n  int T = 1;\n  // cin >> T;\n  while (T--) {\n\n    solve();\n  }\n  #ifdef Sakuyalove\n    cout << \"time = \" << clock() - start_time << endl;\n  #endif\n  return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<cstdio>\ntypedef long long ll;\nconst int mod=119<<23|1;\nconst ll M2=mod*1ll*mod;\nint qpow(int x,int k)\n{int r=1;for(;k;k>>=1,x=x*1ll*x%mod)if(k&1)r=r*1ll*x%mod;return r;}\nint fac[1111111],inv[1111111];\nint C(int n,int r)\n{return(r<0||n<r)?0:fac[n]*1ll*inv[r]%mod*inv[n-r]%mod;}\nvoid init()\n{\n\tregister int i;\n\tconst int V=1e6; \n\tfor(i=fac[0]=1;i<=V;i++)fac[i]=fac[i-1]*1ll*i%mod;\n\tfor(inv[i=V]=qpow(fac[V],mod-2);i;i--)\n\t\tinv[i-1]=inv[i]*1ll*i%mod;\n}\nint n;\nint rv[22222],wi[22222];\nvoid swap(register int&x,register int&y){int t=x;x=y,y=t;}\nvoid NTT(int*x,int SZ,int op)\n{\n\tregister int i,ii,iii;\n\tfor(i=1;i<SZ;i++)rv[i]=(rv[i>>1]>>1)+(i&1)*(SZ>>1);\n\tfor(i=1;i<SZ;i++)if(i<rv[i])swap(x[i],x[rv[i]]);\n\tfor(i=1;i<SZ;i<<=1)\n\t{\n\t\tint w=qpow(3,(mod-1)/(i<<1));\n\t\tif(op<0)w=qpow(w,mod-2);\n\t\tfor(iii=wi[0]=1;iii<i;iii++)wi[iii]=wi[iii-1]*1ll*w%mod;\n\t\tfor(ii=0;ii<SZ;ii+=(i<<1))\n\t\t\tfor(iii=0;iii<i;iii++)\n\t\t\t{\n\t\t\t\tint px=ii+iii,py=px+i;\n\t\t\t\tll Dt=x[py]*1ll*wi[iii];\n\t\t\t\tx[py]=(x[px]+M2-Dt)%mod,x[px]=(x[px]+Dt)%mod;\n\t\t\t}\n\t}if(op<0)\n\t{\n\t\tint a=qpow(SZ,mod-2);\n\t\tfor(i=0;i<SZ;i++)x[i]=x[i]*1ll*a%mod;\n\t}\n}\nint cur[22222],pwr,cs[22222];\nvoid upd(int a,int b)\n{\n\tregister int i;\n\tint pwt=pwr+a-b,tp=pwt+pwr*2,S;\n\tfor(i=2;i<=tp;i<<=1);S=i;\n\tfor(i=0;i<S;i++)cs[i]=0;\n\tfor(i=-pwr;i<=pwt;i++)cs[i+pwr]=C(a+b,b+i);\n\tNTT(cs,S,1),NTT(cur,S,1);\n\tfor(i=0;i<S;i++)cur[i]=cur[i]*1ll*cs[i]%mod;\n\tNTT(cur,S,-1);\n\tfor(i=0;i<=pwt;i++)cur[i]=cur[i+pwr];\n\tfor(i=pwt+1;i<S;i++)cur[i]=0;\n\tpwr=pwt;\n}\nint main()\n{\n\tinit(),cur[0]=1,pwr=0;\n\tscanf(\"%d\",&n);\n\tregister int i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b),upd(a,b);\n\t}ll ans=0;\n\tfor(i=0;i<=pwr;i++)ans+=cur[i];\n\tprintf(\"%lld\\n\",ans%mod);\n}\n/*\nPlease don't let me down.\n*/\n// resubmission\n\t\t\t\t    \t \t \t\t\t\t\t\t   \t\t\t\t \t\t\t\t\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#ifdef ALGO\n#include \"el_psy_congroo.hpp\"\n#else\n#define DUMP(...) 1145141919810\n#define CHECK(...) (__VA_ARGS__)\n#endif\n\ntemplate<int MOD>\nstruct Integral {\n  int v_ = 0;\n\n  template<typename T> Integral(T v) : v_(norm(v)) {  // Implicit conversion is allowed.\n    static_assert(std::is_integral<T>::value, \"input should be an integral.\");\n  }\n  Integral() = default;\n  ~Integral() = default;\n\n  template<typename T> T norm(T v) const {\n    if constexpr(std::is_same<long long, T>::value) {\n      v %= MOD;\n      if (v < 0) v += MOD;\n    } else {\n      if (v >= MOD) v -= MOD;\n      if (v < 0) v += MOD;\n      if (v >= MOD || v < 0) {\n        v %= MOD;\n        if (v < 0) v += MOD;\n      }\n    }\n    return v;\n  }\n\n  int val() const { return v_; }\n  Integral& operator += (const Integral& rhs) { v_ += rhs.val(); if (v_ >= MOD) v_ -= MOD; return *this; }\n  Integral& operator -= (const Integral& rhs) { v_ += MOD - rhs.val(); if (v_ >= MOD) v_ -= MOD; return *this; }\n  Integral& operator *= (const Integral& rhs) { v_ = v_ * 1LL * rhs.val() % MOD; return *this; }\n  Integral& operator /= (const Integral& rhs) { v_ = v_ * 1LL * power(rhs.val(), MOD - 2) % MOD; return *this; }\n  Integral operator + (const Integral& rhs) const { auto copy = *this; return copy += rhs; }\n  Integral operator - (const Integral& rhs) const { auto copy = *this; return copy -= rhs; }\n  Integral operator * (const Integral& rhs) const { auto copy = *this; return copy *= rhs; }\n  Integral operator / (const Integral& rhs) const { auto copy = *this; return copy /= rhs; }\n  bool operator == (const Integral& rhs) const { return val() == rhs.val(); }\n  bool operator != (const Integral& rhs) const { return !(*this == rhs); }\n  const Integral operator - () const { return Integral(-val()); }\n  const Integral operator ++ () { v_ = norm(v_ + 1); return *this; }\n  const Integral operator ++ (int) { Integral ret = *this; ++(*this); return ret; }\n  const Integral operator -- () { v_ = norm(v_ - 1); return *this; }\n  const Integral operator -- (int) { Integral ret = *this; --(*this); return ret; }\n\n  Integral power(long long b) const {\n    long long ret = 1 % MOD, a = v_;\n    for ( ; b; b >>= 1, a = a * a % MOD) if (b & 1) ret = ret * a % MOD; return ret;\n  }\n  Integral inv() const { return power(MOD - 2); }\n};\n\ntemplate<int MOD>\nstd::string to_string(const Integral<MOD>& v) {\n  return std::string(\"Int<>{\") + std::to_string(v.val()) + \"}\";\n}\n\ntemplate<int MOD, bool kAllowBruteForce = false>\nstruct Binomial {\n  std::vector<Integral<MOD>> factor, inv_factor;\n\n  explicit Binomial(int n = 0) : factor(n + 1), inv_factor(n + 1) {\n    factor[0] = 1;\n    for (int i = 1; i <= n; ++i) factor[i] = factor[i - 1] * i;\n    inv_factor[n] = factor[n].inv();\n    for (int i = n; i >= 1; --i) inv_factor[i - 1] = inv_factor[i] * i;\n  }\n  ~Binomial() = default;\n\n  template<typename T>\n  Integral<MOD> operator () (T a, T b) const {\n    if (a < b || b < 0) return 0;\n    if (a < factor.size()) return factor[a] * inv_factor[b] * inv_factor[a - b];\n    if constexpr(!kAllowBruteForce) {\n      throw std::out_of_range(\"Binomial\");\n    } else {\n      b = std::min(b, a - b);\n      Integral<MOD> ret = 1;\n      for (T i = 1; i <= b; ++i) ret = ret * (a + 1 - i) / i;\n      return ret;\n    }\n  }\n};\n\ntemplate<int MOD>\nstruct PowerTable : public std::vector<Integral<MOD>> {\n  PowerTable(int n, const Integral<MOD>& g) {\n    static_assert(sizeof(PowerTable) == sizeof(std::vector<Integral<MOD>>), \"\");\n    this->resize(n + 1);\n    this->at(0) = 1;\n    this->at(1) = g;\n    for (int i = 2; i < this->size(); ++i) this->at(i) = this->at(i - 1) * this->at(1);\n  }\n};\n\nconst int MOD = 998244353;\nusing Mint = Integral<MOD>;\nusing Binom = Binomial<MOD>;\n\nBinom binom(200000);\n// PowerTable<MOD> pw2(200000, 2);\n\ntemplate<int MOD = 998244353, int kPrimRoot = 3>\nvoid ntt(Integral<MOD> A[], int n, int inv) {\n  // inv == 1: ntt, == -1: intt\n\n  // MOD == a * b ^ k + 1, n <= b ^ k.\n  // 998244353 == (7 * 17) * 2 ^ 23 + 1.\n  // This code works only when b == 2.\n  Integral<MOD> w = 1, d = Integral<MOD>(kPrimRoot).power((MOD - 1) / n), t;\n  int i, j, c, s;\n  if (inv == -1) {\n    for (i = 1, j = n - 1; i < j; ++i, --j) std::swap(A[i], A[j]);\n    for (t = Integral<MOD>(n).inv(), i = 0; i < n; ++i) A[i] = A[i] * t;\n  }\n  for (s = n >> 1; s; s >>= 1, w = 1, d = d * d) {\n    for (c = 0; c < s; ++c, w = w * d) {\n      for (i = c; i < n; i += s << 1) {\n        A[i | s] = (A[i] - (t = A[i | s])) * w;\n        A[i] += t;\n      }\n    }\n  }\n  for (i = 1; i < n; ++i) {\n    for (j = 0, s = i, c = n >> 1; c; c >>= 1, s >>= 1) j = j << 1 | (s & 1);\n    if (i < j) std::swap(A[i], A[j]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::istream& reader = std::cin;\n\n  int n;\n  reader >> n;\n  std::vector<Mint> f(1, 1);\n\n  for (int at = 1; at <= n; ++at) {\n    int a, b;\n    reader >> a >> b;\n    int m = f.size();\n    int w = m + a - b + m + 1;  // b - m, m + a\n    int L = 1;\n    while (L < m + w) L <<= 1;\n    f.resize(L, 0);\n    std::vector<Mint> y(L);\n    for (int i = 0; i < w; ++i) {\n      y[i] = binom(a + b, i + b - m);\n    }\n    ntt(&f[0], L, 1);\n    ntt(&y[0], L, 1);\n    for (int i = 0; i < L; ++i) f[i] *= y[i];\n    ntt(&f[0], L, -1);\n    for (int i = 0; i < m + a - b; ++i) f[i] = i + m < L ? f[i + m] : 0;\n    f.resize(m + a - b);\n  }\n  std::cout << std::accumulate(f.begin(), f.end(), Mint(0)).val() << std::endl;\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int mod = 998244353;\n\nconst int maxn = 17000;\nint fac[202020], ifac[202020];\nint x[maxn], f[maxn], g[maxn];\n\n\nint C(int n, int k) {\n    if (k < 0 || k > n || n < 0) return 0;\n    return fac[n] * (ll)ifac[k] % mod * (ll)ifac[n-k] % mod;\n}\n\nconst int G = 3;\n\ninline int add(int a, int b) { return a+b>=mod?a+b-mod:a+b; }\ninline void inc(int&a, int b) { if ((a+=b)>=mod) a-=mod; }\ninline int sub(int a, int b) { return a-b<0?a-b+mod:a-b; }\ninline void dec(int&a, int b) { if ((a-=b)<0) a+=mod; }\ninline int mul(int a, int b) { return (ll)a*b%mod; }\ninline int qpow(int x, int n) { int ans=1; for ( ; n; n>>=1, x=(ll)x*x%mod) if (n&1) ans=(ll)ans*x%mod; return ans; }\n//-------------------------------NTT--------------------------------\nint wn[30],iwn[30]; //wn[i] = G^((P-1)/(2^i)) (mod P), iwn[i] = wn[i]^(-1) (mod P)\ninline void init() {\n    wn[21] = qpow(G, (mod-1)/(1<<21));\n    for (int i=20; i>=0; i--) wn[i] = mul(wn[i+1], wn[i+1]);\n    iwn[21] = qpow(wn[21], (1<<21)-1);\n    for (int i=20; i>=0; i--) iwn[i] = mul(iwn[i+1], iwn[i+1]);\n}\ninline void revbin_permute(int a[], int n) {\n    int i=1, j=n>>1, k;\n    for ( ; i<n-1; i++) {\n        if (i < j) swap(a[i], a[j]);\n        for (k=n>>1; j>=k; ) { j -= k; k >>= 1; }\n        if (j < k) j += k;\n    }\n}\nvoid NTT(int f[], int ldn, int is) {\n    int n = (1<<ldn);\n    revbin_permute(f, n);\n    for (int i=0; i<n; i+=2) {\n        int tmp1 = f[i], tmp2 = f[i+1];\n        f[i] = add(tmp1, tmp2), f[i+1] = sub(tmp1, tmp2);\n    }\n    for (int ldm=2; ldm<=ldn; ldm++) {\n        int m = (1<<ldm), mh = (m>>1);\n        int dw = is>0?wn[ldm]:iwn[ldm], w = 1;\n        for (int j=0; j<mh; j++) {\n            for (int r=0; r<n; r+=m) {\n                int u = f[r+j], v = mul(f[r+j+mh], w);\n                f[r+j] = add(u, v);\n                f[r+j+mh] = sub(u, v);\n            }\n            w = mul(w, dw);\n        }\n    }\n}\nvoid convolution(int f[], int g[], int n) {\n    int ldn; for (int i=20; i>=0; i--) if (n&(1<<i)) { ldn=i; break; }\n    NTT(f, ldn, 1); NTT(g, ldn, 1); //\u4f1a\u6539\u53d8g\n    for (int i=0; i<n; i++) f[i] = mul(f[i], g[i]);\n    NTT(f, ldn, -1);\n    int iv = qpow(n, mod-2);\n    for (int i=0; i<n; i++) f[i] = mul(f[i], iv);\n}\n\nint main(void) {\n    //freopen(\"g.in\", \"r\", stdin);\n\n    int N = 200002;\n    fac[0]=1; for (int i=1; i<=N; i++) fac[i]=fac[i-1]*(ll)i%mod;\n    ifac[N]=qpow(fac[N], mod-2); for (int i=N-1; i>=0; i--) ifac[i]=ifac[i+1]*(ll)(i+1)%mod;\n\n    init();\n\n    int n; scanf(\"%d\", &n);\n\n    int cur_len = 1;\n    x[0] = 1;\n\n    for (int i=0; i<n; i++) {\n        int a, b; scanf(\"%d%d\", &a, &b);\n\n        int nex_len = cur_len + a - b;\n\n        int tot_len = cur_len + nex_len - 1;\n        int L = 2; while (L <= cur_len + tot_len) L <<= 1;\n\n//        for (int j=0; j<L; j++) f[j] = g[j] = 0;\n        for (int j=0; j<cur_len; j++) f[j] = x[j];\n        for (int j=cur_len; j<L; j++) f[j] = 0;\n        for (int j=0; j<tot_len; j++) {\n            g[j] = C(a + b, a + cur_len-1 - j);\n        }\n        for (int j=tot_len; j<L; j++) g[j] = 0;\n\n//        for (int j=0; j<tot_len; j++) printf(\"%d \", g[j]); puts(\"\");\n\n        convolution(f, g, L);\n\n        for (int j=cur_len-1; j<cur_len-1+nex_len; j++) x[j-cur_len+1] = f[j];\n        cur_len = nex_len;\n\n//        printf(\"i = %d, a = %d, b = %d\\n\", i, a, b);\n//        for (int j=0; j<cur_len; j++) printf(\"%d \", x[j]); puts(\"\");\n    }\n\n    int ans = 0;\n    for (int i=0; i<cur_len; i++) {\n        ans = (ans + x[i]) % mod;\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6 + 50;\nconst ll mod = 998244353;\n\nint n, ans, cnt = 1;\nint jc[N], jc_inv[N];\nll f[N], g[N];\n\nll qpow(ll a, ll b, int mod){\n    ll t = 1;\n    while(b){\n        if(b & 1)  t = (t *a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return t;\n}\n\nvoid NTT(int n, ll *a, int opt){\n    int i, j = 0, k;\n    for(i = 0; i < n; i++){\n        if(i > j)  swap(a[i], a[j]);\n        for(int l = n >> 1; (j ^= l) < l; l >>= 1);\n    }\n    for(i = 1; i < n; i <<= 1){\n        ll wn = qpow(3, (mod - 1) / (i << 1), mod);\n        int m = i << 1;\n        for(j = 0; j < n; j += m){\n            ll w = 1;\n            for(k = 0; k < i; k++, w = (w * wn) % mod){\n                ll z = (a[j + i + k] * w) % mod;\n                a[i + j + k] =( a[j+ k] - z + mod) % mod;\n                a[j + k] = (a[j + k] + z) % mod;\n            }\n        }\n    } \n    if(opt == -1)  reverse(a + 1, a + n);\n}\n\n// \u6ce8\u610f\u591a\u6b21\u4f7f\u7528\u7684\u8bdd\u8981\u521d\u59cb\u5316\uff0c\u5c06\u6570\u7ec4\u503c\u6e05\u96f6\uff0c\u6ce8\u610fn\u548cm\u7684\u610f\u4e49 \n// a\u6570\u7ec4\u50a8\u5b58\u6700\u540e\u7ed3\u679c\uff0cn,m\u5206\u522b\u662fa,b\u7684\u9879\u6570\uff0c\u6570\u7ec4\u4e0b\u6807\u4ece0\u5f00\u59cb \nint work(ll *a, int n, ll *b, int m){\n\tint fn = 1;\n    while(fn <= n + m)  fn <<= 1;\n    NTT(fn, a, 1);  NTT(fn, b, 1);\n    // \u8fd9\u91cca\u6570\u7ec4\u50a8\u5b58\u7ed3\u679c\uff0c\u6240\u4ee5\u662fa[i] = (a[i] * b[i]) % mod\n    // \u5982\u679c\u662f\u7b97\u5176\u4ed6\u5f62\u5f0f\u591a\u9879\u5f0f\u76f8\u4e58\uff0c\u5982(2 - a[x] * b[x]) * b[x]\u7684\u591a\u9879\u5f0f\u76f8\u4e58\n    // \u90a3\u4e48\u8981\u6539\u4e3aa[i] = ((2 - a[i] * b[i]) % mod * b[i] % mod + mod) % mod \n    for(int i = 0; i <= fn; i++)  a[i] = (a[i] * b[i]) % mod;\n    // \u5bf9\u50a8\u5b58\u7ed3\u679c\u7684\u6570\u7ec4NTT\n    NTT(fn, a, -1);\n    ll t = qpow(fn, mod - 2, mod);\n    for(int i = 0; i < fn; i++)  a[i] = (a[i] * t) % mod;\n\treturn fn;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    jc[0] = 1;\n    for(int i = 1; i < N; ++i)  jc[i] = 1LL * jc[i - 1] * i % mod;\n    jc_inv[N - 1] = qpow(jc[N - 1], mod - 2, mod);\n    for(int i = N - 2; ~i; --i)  jc_inv[i] = 1LL * jc_inv[i + 1] * (i + 1) % mod;\n    f[1] = 1;\n    while(n--){\n        int a, b, tot = -1;\n        scanf(\"%d%d\", &a, &b);\n        int max_j = a - b + cnt,  max_k = cnt;\n        int p = 1e9;\n        for(int i = 1 - max_k; i <= max_j - 1; ++i){\n            if(a - i >= 0 && b + i >= 0){\n                if(p == 1e9)  p = i;\n                g[++tot] = 1LL * jc_inv[a - i] * jc_inv[b + i] % mod;\n            \t//printf(\"hh %lld\\n\", g[tot]);\n\t\t\t}\n        }\n        int len = work(f, cnt, g, tot);\n        //for(int i = 0; i <= cnt + tot; ++i)  printf(\"hh  %lld\\n\", f[i]);\n        for(int i = 0; i < len; ++i)  f[i] = f[i] * jc[a + b] % mod;\n        int tt = -1;\n        for(int i = 0; i < len; ++i){\n            if(p >= 0 && p <= max_j)  f[++tt] = f[i];\n            ++p;  \n        }\n        for(int i = tt + 1; i < len; ++i)  f[i] = 0;\n        f[0] = 0,  cnt = tt;\n        //for(int i = 0; i <= cnt; ++i) printf(\"hh %lld\\n\", f[i]);\n        for(int i = 0; i < len; ++i)  g[i] = 0;\n    }\n    for(int i = 1; i <= cnt; ++i)  ans = (ans + f[i]) % mod;\n    printf(\"%d\", ans);  \n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1000005;\nconst int MOD = 998244353;\n\nint n;\nint fact[N], ifact[N];\n\nint power(int x, int y) {\n  int ret = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) ret = 1LL * ret * x % MOD;\n    x = 1LL * x * x % MOD;\n  }\n  return ret;\n}\n\nnamespace FFT {\n\nconst int LN = 21;\nconst int N = 1 << LN;\n\nconst int PRIMITIVE_ROOT = 3; // Primitive root modulo `MOD`.\n\nint root[N];\n\nvoid init_fft() {\n  const int UNITY = power(PRIMITIVE_ROOT, MOD-1 >> LN);\n  root[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    root[i] = 1LL * UNITY * root[i-1] % MOD;\n  }\n}\n\n// n is the length of polynom\nvoid fft(int n, vector<int> &a, bool invert) {\n  for (int i = 1, j = 0; i < n; ++i) {\n    int bit = n >> 1;\n    for (; j & bit; bit >>= 1) j ^= bit;\n    j ^= bit;\n    if (i < j) swap(a[i], a[j]);\n  }\n\n  for (int len = 2; len <= n; len <<= 1) {\n    int wlen = (invert ? root[N - N/len] : root[N/len]);\n    for (int i = 0; i < n; i += len) {\n      int w = 1;\n      for (int j = 0; j < len>>1; ++j) {\n        int u = a[i+j];\n        int v = 1LL * a[i+j + len/2] * w % MOD;\n\n        a[i+j] = (u + v) % MOD;\n        a[i+j + len/2] = (u - v + MOD) % MOD;\n\n        w = 1LL * w * wlen % MOD;\n      }\n    }\n  }\n\n  if (invert) {\n    int inv = power(n, MOD-2);\n    for (int i = 0; i < n; ++i) a[i] = 1LL * a[i] * inv % MOD;\n  }\n}\n\nvector<int> multiply(vector<int> a, vector<int> b) {\n  int len = (a.size() + b.size() == 2 ? 1 : 1 << (32 - __builtin_clz(a.size() + b.size() - 2)));\n  a.resize(len); b.resize(len);\n  fft(len, a, false); fft(len, b, false);\n  a.resize(len);\n  for (int i = 0; i < len; ++i) a[i] = 1LL * a[i] * b[i] % MOD; \n  fft(len, a, true);\n  return a;\n}\n\n}\n\nint C(int n, int k) {\n  return 1LL * fact[n] * ifact[k] % MOD * ifact[n - k] % MOD;\n}\n\nvoid init() {\n  fact[0] = 1;\n  for (int i = 1; i < N; ++i) fact[i] = 1LL * fact[i - 1] * i % MOD;\n  ifact[N - 1] = power(fact[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; --i) ifact[i] = 1LL * ifact[i + 1] * (i + 1) % MOD;\n  FFT::init_fft();\n}\n\nint solve() {\n  scanf(\"%d\", &n);\n\n  vector<int> v(1, 1);\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n\n    int sz = v.size();\n    int nsz = sz + a - b;\n\n    vector<int> mul(sz + nsz);\n    for (int k = 0; k < mul.size(); ++k) {\n      int col = b - (int) v.size() + 1 + k;\n      if (col < 0 || col > a + b) continue;\n      mul[k] = C(a + b, col);\n    }\n    v = FFT::multiply(v, mul);\n\n    for (int i = 0; i < nsz; ++i) v[i] = v[i + sz - 1];\n    v.resize(nsz);\n\n\n    // for (int j = 0; j < nv.size(); ++j) {\n    //   for (int k = 0; k < v.size(); ++k) {\n    //     if (k >= v.size()) break;\n    //     if (b + j - k < 0) continue;\n    //     if (b + j - k > a + b) continue;\n    //     nv[j] = (1LL * C(a + b, b + j - k) * v[k] + nv[j]) % MOD;\n    //   }\n    // }\n  }\n\n  int ans = 0;\n  for (int u : v) ans = (ans + u) % MOD;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\nint main() {\n  int t = 1;\n  init();\n  // scanf(\"%d\", &t);\n  for (int tc = 0; tc < t; ++tc) {\n    // printf(\"Case #%d: \", tc+1);\n    solve();\n  }\n  return 0;\n}\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define DB double\n#define U unsigned\n#define P std::pair\n#define LL long long\n#define LD long double\n#define pb emplace_back\n#define MP std::make_pair\n#define SZ(x) ((int)x.size())\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 3e5+5;\nconst int ha = 998244353;\n\ninline int qpow(int a,int n=ha-2){\n\tint res = 1;\n\twhile(n){\n\t\tif(n & 1) res = 1ll*res*a%ha;\n\t\ta = 1ll*a*a%ha;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n,a[MAXN],b[MAXN];\nint sz[MAXN];\nint f[2][MAXN],now;\nint fac[MAXN],inv[MAXN];\n\ninline int C(int n,int m){\n    return n < 0 || m < 0 || n < m ? 0 : 1ll*fac[n]*inv[m]%ha*inv[n-m]%ha;\n}\n\ninline void add(int &x,int y){\n    x += y-ha;x += x>>31&ha;\n}\n\nstruct Poly{\n    std::vector<int> x;\n    inline int deg(){return SZ(x)-1;}\n    inline void ext(int n){x.resize(n+1);}\n    inline int& operator [] (const int &n){return x[n];}\n};\n\nint r[MAXN<<2],N;\nint W[MAXN<<2];\n\ninline void init(int n){\n    N = 1;int len = 0;while(N <= n) N <<= 1,++len;\n    FOR(i,0,N-1) r[i] = (r[i>>1]>>1)|((i&1)<<(len-1));\n}\n\ninline void NTT(Poly &A){\n    A.ext(N-1);FOR(i,0,N-1) if(i < r[i]) std::swap(A[i],A[r[i]]);\n    int *w = W;\n    for(int mid = 1;mid < N;mid <<= 1){\n        for(int i = 0;i < N;i += (mid<<1)){\n            for(int j = 0;j < mid;++j){\n                int x = A[i+j],y = 1ll*w[j]*A[i+mid+j]%ha;\n                A[i+j] = (x+y)%ha;A[i+mid+j] = (x+ha-y)%ha;\n            }\n        }\n        w += (mid<<1);\n    }\n}\n\ninline Poly operator * (Poly A,Poly B){\n    int len = A.deg()+B.deg();init(len);\n    NTT(A);NTT(B);FOR(i,0,N-1) A[i] = 1ll*A[i]*B[i]%ha;\n    NTT(A);std::reverse(A.x.begin()+1,A.x.end());int inv = qpow(N);\n    A.ext(len);FOR(i,0,A.deg()) A[i] = 1ll*A[i]*inv%ha;\n    return A;\n}\n\nint main(){\n//    freopen(\"A.in\",\"r\",stdin);\n    fac[0] = 1;FOR(i,1,MAXN-1) fac[i] = 1ll*fac[i-1]*i%ha;\n    int *w = W;for(int n = 2,i = 0;i <= 16;++i,n <<= 1) FOR(j,0,n-1) *w = qpow(3,((ha-1)/n)*j),++w;\n    inv[MAXN-1] = qpow(fac[MAXN-1]);ROF(i,MAXN-2,0) inv[i] = 1ll*inv[i+1]*(i+1)%ha;\n    scanf(\"%d\",&n);\n    FOR(i,1,n) scanf(\"%d%d\",a+i,b+i);\n    sz[0] = 1;Poly ans;ans.ext(1);ans[1] = 1;\n    FOR(i,1,n){\n        sz[i] = sz[i-1]+a[i]-b[i];\n        int l = std::max(-b[i],1-sz[i-1]),r = std::min(a[i],sz[i-1]+a[i]-b[i]-1);\n        Poly F,G;F.ext(sz[i-1]);G.ext(r-l);\n        FOR(j,1,sz[i-1]) F[j] = ans[j];\n        FOR(j,0,r-l) G[j] = 1ll*inv[b[i]+j+l]*inv[a[i]-j-l]%ha;\n        F = F*G;\n        ans.x.clear();ans.ext(sz[i]);\n        FOR(j,1,sz[i]) if(0 <= j-l && j-l <= F.deg()) ans[j] = 1ll*F[j-l]*fac[a[i]+b[i]]%ha;\n    }\n    int res = 0;FOR(i,1,ans.deg()) add(res,ans[i]);\n    printf(\"%d\\n\",res);\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst uint64_t seed = std::chrono::system_clock::now().time_since_epoch().count();\nmt19937_64 rnd(seed);\nconst int MOD = 998244353;\n\n#ifdef VIPJML_LOCAL\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    os << \"{\";\n    for (typename vector<T>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << *vi;\n    }\n    os << \"}\";\n    return os;\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const vector<pair<A, B>> &v)\n{\n    os << \"{\";\n    for (typename vector<pair<A, B>>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << '(' << vi->first << \" \" << vi->second << \")\";\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p)\n{\n    os << '(' << p.first << \", \" << p.second << ')';\n    return os;\n}\n\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T)\n{\n    cerr << ' ' << H;\n    dbg_out(T...);\n}\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\nusing LL = long long;\n\nstruct Mint\n{\n    int v;\n    Mint() : v(0) {}\n    Mint(int t)\n    {\n        v = t % MOD;\n        if (v < 0)\n            v += MOD;\n    }\n\n    Mint pow(long long k)\n    {\n        Mint res(1), tmp(v);\n        while (k)\n        {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    Mint inv() { return pow(MOD - 2); }\n\n    Mint &operator+=(Mint a)\n    {\n        v += a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &operator-=(Mint a)\n    {\n        v += MOD - a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n\n    Mint &operator*=(Mint a)\n    {\n        v = fast_mod(uint64_t(v) * a.v);\n        return *this;\n    }\n    Mint &operator/=(Mint a) { return (*this) *= a.inv(); }\n\n    Mint operator+(Mint a) const { return Mint(v) += a; }\n    Mint operator-(Mint a) const { return Mint(v) -= a; }\n    Mint operator*(Mint a) const { return Mint(v) *= a; }\n    Mint operator/(Mint a) const { return Mint(v) /= a; }\n\n    Mint operator-() const { return v ? Mint(MOD - v) : Mint(v); }\n\n    bool operator==(const Mint a) const { return v == a.v; }\n    bool operator!=(const Mint a) const { return v != a.v; }\n    bool operator<(const Mint a) const { return v < a.v; }\n\n    static Mint comb(long long n, int k)\n    {\n        Mint num(1), dom(1);\n        for (int i = 0; i < k; i++)\n        {\n            num *= Mint(n - i);\n            dom *= Mint(i + 1);\n        }\n        return num / dom;\n    }\n\n    static Mint inv(int n)\n    {\n        return Mint(n).inv();\n    }\n\n    static vector<Mint> getInvArray(int N)\n    {\n        vector<Mint> inv(N + 1, 1);\n        for (int i = 2; i <= N; i++)\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n        return inv;\n    }\n};\n\nostream &operator<<(ostream &os, Mint m)\n{\n    os << m.v;\n    return os;\n}\n\nnamespace NTT\n{\n    const int G = 3;\n    const int LOGN = 15;\n    vector<Mint> w[LOGN];\n    vector<int> rv[LOGN];\n\n    void prepare()\n    {\n         for(int st=0;st<LOGN;st++)\n        {\n            w[st].assign(1 << st, 1);\n            Mint bw = Mint(G).pow((MOD-1)/(1 << st));\n            Mint cw = 1;\n            for(int k=0;k<( 1 << st);k++) {\n                w[st][k] = cw;\n                cw *= bw;\n            } \n        }\n        for(int st=0;st<LOGN;st++)\n        {\n            rv[st].assign(1 << st, 0);\n            if (st == 0)\n            {\n                rv[st][0] = 0;\n                continue;\n            }\n            int h = (1 << (st - 1));\n            for(int k=0;k<( 1 << st);k++)\n                rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n        }\n    }\n\n    void ntt(vector<Mint> &d, bool inv = false)\n    {\n        int N = 1;\n        int st=0;\n        while (N < d.size()){\n            N *= 2;\n            st++;\n        }\n        //d.resize(N);\n       \n        for (int i = 0;i<N;i++)\n        {\n           if(i<rv[st][i]) swap(d[i],d[rv[st][i]]);\n        }\n        int tt=0;\n        for (int len = 1; len * 2 <= N; len <<= 1)\n        {\n            tt++;\n            for (int i = 0; i + len * 2 <= N; i += len * 2)\n            {\n                int dd = N / 2 / len;\n                for (int j = 0; j < len; j++)\n                {\n                    Mint t = d[i + j + len] * w[tt][j];\n                    d[i + j + len] = d[i + j] - t;\n                    d[i + j] += t;\n                }\n            }\n        }\n        if (inv)\n        {\n            Mint invN = Mint::inv(N);\n            for (int i = 0; i < N; i++)\n                d[i] = d[i] * invN;\n            reverse(d.begin()+1,d.end());\n        }\n        //return d;\n    }\n    vector<Mint> conv(vector<Mint> d1, vector<Mint> d2)\n    {\n        int num = d1.size() + d2.size() - 1;\n        int cnt = 1 << (32 - __builtin_clz(num));\n        d1.resize(cnt), d2.resize(cnt);\n        ntt(d1);\n        ntt(d2);\n        vector<Mint> tmp(d1.size());\n        for (int i = 0; i < d1.size(); i++)\n            tmp[i] = d1[i] * d2[i];\n        ntt(tmp, true);\n        //r.resize(num);\n        return tmp;\n    }\n} // namespace NTT\n\nvoid solve(int caseNum)\n{\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    vector<Mint> r(1, 1);\n    auto inv = Mint::getInvArray(2e5);\n    vector<Mint> P(2e5 + 1, 1);\n    vector<Mint> IP(2e5 + 1, 1);\n    for (int i = 2; i < P.size(); i++)\n    {\n        P[i] = P[i - 1] * i;\n        IP[i] = IP[i - 1] * inv[i];\n    }\n\n    NTT::prepare();\n    for (int i = 0; i < n; i++)\n    {\n        int s = max(0, b[i] - (int)r.size() + 1);\n        int e = min(a[i] + (int)r.size() - 1, a[i] + b[i]);\n        vector<Mint> x(e - s + 1);\n        for (int j = s; j <= e; j++)\n        {\n            x[j - s] = P[a[i] + b[i]] * IP[j] * IP[a[i] + b[i] - j];\n        }\n        auto t = NTT::conv(r, x);\n        int t1 = b[i] - s;\n        int t2 = min(a[i] + (int)r.size() - 1 - s, (int)t.size() - 1);\n        vector<Mint> res(t2-t1+1);\n        for (int j = t1; j <= t2;j++)\n        {\n            res[j-t1]=t[j];\n        }\n        swap(r, res);\n    }\n    Mint sum;\n    for (auto t : r)\n        sum += t;\n    cout << sum.v << endl;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.precision(10);\n    int T = 1;\n    //cin >> T;\n    for (int i = 1; i <= T; i++)\n    {\n        solve(i);\n    }\n    cout.flush();\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <cstdio>\n#include <cstring>\n\nconst int MAXN =1e3+20, MAXV =1e5+20, M =998244353;\n\n/*------------------------------IO------------------------------*/\n\nnamespace IO_base{\n\tconst int MAXB =1<<10;\n\tchar gbuf[MAXB], *ps =gbuf, *pt =gbuf;\n\t\n\tinline char Getchar(){\n\t\tif(ps == pt){\n\t\t\tps =gbuf;\n\t\t\tpt =gbuf+fread(gbuf, 1, MAXB, stdin);\n\t\t}\n\t\treturn (ps == pt) ? EOF : *ps++;\n\t}\n}\n#define getchar IO_base::Getchar\n#define putchar IO_base::Putchar\n\nnamespace IO_number{\n\tint read(){\n\t\tint x =0; char c =getchar(); bool f =0;\n\t\twhile(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();\n\t\twhile(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();\n\t\treturn (f) ? -x : x;\n\t}\n}\nusing namespace IO_number;\n\n/*------------------------------Number_Theory------------------------------*/\n\nnamespace Number_Theory_base{\n\t// naive mod\n\tinline int mul(const int &x, const int &y, const int &M){\n\t\treturn 1ll*x*y%M;\n\t}\n\t\n\tint Pow(int x, int k, const int &M){\n\t\tint ret =1;\n\t\tfor(; k; k >>=1, x =mul(x, x, M))\n\t\t\tif(k&1)\n\t\t\t\tret =mul(ret, x, M);\n\t\treturn ret;\n\t}\n\t\n\tint fact[MAXV*2], fact_inv[MAXV*2];\n\t\n\tvoid pre_Fact(){\n\t\tfact[0] =1;\n\t\tfor(int i =1; i < MAXV*2; ++i)\n\t\t\tfact[i] =mul(fact[i-1], i, M);\n\t\tfact_inv[MAXV*2-1] =Pow(fact[MAXV*2-1], M-2, M);\n\t\tfor(int i =MAXV*2-1 -1; i >= 0; --i)\n\t\t\tfact_inv[i] =mul(fact_inv[i+1], i+1, M);\n\t}\n\t\n\tinline int Fact(const int &x){\n\t\treturn fact[x];\n\t}\n\t\n\tinline int Fact_Inv(const int &x){\n\t\treturn fact_inv[x];\n\t}\n}\nusing namespace Number_Theory_base;\n\n/*------------------------------Poly------------------------------*/\n\nconst int MAXN_Poly =1<<14;\n#define MAXN MAXN_Poly\n\nnamespace Poly_base{\n\tstruct Poly{\n\t\tint N;\n\t\tint data[MAXN];\n\t\t\n\t\tPoly():N(0){\n\t\t\tmemset(data, 0, sizeof(data));\n\t\t}\n\t\tPoly(const int &_N)\n\t\t\t:N(_N){\n\t\t\tmemset(data, 0, sizeof(data));\n\t\t}\n\t\t\n\t\tint & operator [] (const int &index){\n\t\t\treturn data[index];\n\t\t}\n\t\tint operator [] (const int &index) const{\n\t\t\treturn data[index];\n\t\t}\n\t};\n}\nusing namespace Poly_base;\n\n// *require `Number_Theory_base`\nnamespace Poly_calc{\n\t#define mul(x, y) mul(x, y, M_NTT)\n\t#define Pow(x, k) Pow(x, k, M_NTT)\n\t#define Inv(x) Pow(x, M_NTT-2)\n\t\n\t// helper for Poly_calc\n\tnamespace Poly_calc_base{\n\t\tconst int M_NTT =998244353, g_NTT =3;\n\t\t#define M M_NTT\n\t\t/* reference of \"g\": https://en.wikipedia.org/wiki/Primitive_root_modulo_n */\n\t\t\n\t\t// helper arrays/variables for NTT\n\t\tint S[MAXN];\n\t\tbool op;\n\t\t\n\t\t// helper function for NTT\n\t\tvoid NTT_pre(const int &N){\n\t\t\tint shift_of_highest_bit =0;\n\t\t\twhile(N >= (1<<(shift_of_highest_bit+1)))\n\t\t\t\t++shift_of_highest_bit;\n\t\t\t--shift_of_highest_bit;\n\t\t\tfor(int i =0; i < N; ++i)\n\t\t\t\tS[i] =(S[i>>1]>>1)|((i&1)<<shift_of_highest_bit);\n\t\t\top =1;\n\t\t}\n\t\t\n\t\t// helper function for NTT\n\t\tinline void NTT_rev_op(){\n\t\t\top ^=1;\n\t\t}\n\t\t\n\t\t// helper function for NTT\n\t\tinline void swap(int &x, int &y){\n\t\t\tx ^=y ^=x ^=y;\n\t\t}\n\t\t\n\t\tvoid NTT(Poly &A){\n\t\t\tfor(int i =0; i < A.N; ++i)\n\t\t\t\tif(i < S[i])\n\t\t\t\t\tswap(A[i], A[S[i]]);\n\t\t\tfor(int N =1; N < A.N; N <<=1){\n\t\t\t\tconst int wn =(op) ? Pow(g_NTT, (M-1)/(N<<1)) : Inv(Pow(g_NTT, (M-1)/(N<<1)));\n\t\t\t\tfor(int shift_A =0; shift_A < A.N; shift_A +=(N<<1)){\n\t\t\t\t\tint w =1, *f0 =&A[0]+shift_A, *f1 =&A[0]+shift_A+N;\n\t\t\t\t\tfor(int i =0; i < N; ++i){\n\t\t\t\t\t\tconst int res =mul(*f1, w);\n\t\t\t\t\t\t*f1 =(*f0-res+M)%M, *f0 =(*f0+res)%M;\n\t\t\t\t\t\tw =mul(w, wn), ++f0, ++f1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#undef M\n\t}\n\tusing namespace Poly_calc_base;\n\t\n\t// helper function for conv\n\tint get_Result_N(const int &limit){\n\t\tint N =1;\n\t\twhile(N < limit)\n\t\t\tN <<=1;\n\t\treturn N;\n\t}\n\t\n\t// *tips: `MAXN_Poly =get_Result_N(MAXN*2-1);`\n\tvoid conv(Poly &A, Poly &B, Poly &Result){\n\t\tconst int N =Result.N =A.N =B.N =get_Result_N(A.N+B.N-1);\n\t\tNTT_pre(N);\n\t\tNTT(A), NTT(B);\n\t\tconst int Inv_N =Inv(N);\n\t\tfor(int i =0; i < N; ++i)\n\t\t\tResult[i] =mul(mul(A[i], B[i]), Inv_N);\n\t\tNTT_rev_op();\n\t\tNTT(Result);\n\t}\n\t\n\t#undef mul\n\t#undef Pow\n\t#undef Inv\n}\nusing namespace Poly_calc;\n\n#undef MAXN\n\n/*------------------------------Main------------------------------*/\n\nint main(){\n\tpre_Fact();\n\t\n\tconst int n =read();\n\t\n\tPoly A(1);\n\tA[0] =1;\n\tfor(int _t =0; _t < n; ++_t){\n\t\tconst int a =read(), b =read();\n\t\tconst int n_A =A.N;\n\t\t\n\t\tPoly B((n_A+a)-(b-n_A+1)+1);\n\t\tfor(int i =0, j =b-n_A+1; j <= n_A+a; ++i, ++j)\n\t\t\tif(j >= 0 && a+b-j >= 0)\n\t\t\t\tB[i] =mul(Fact_Inv(j), Fact_Inv(a+b-j), M);\n\t\tconv(A, B, B);\n\t\tA.N =n_A+a-b;\n\t\tmemset(A.data, 0, sizeof(A.data));\n\t\tfor(int i =0; i < A.N; ++i)\n\t\t\tA[i] =mul(Fact(a+b), B[n_A+i-1], M);\n\t}\n\tint ans =0;\n\tfor(int i =0; i < A.N; ++i)\n\t\tans =(ans+A[i])%M;\n\tprintf(\"%d\", ans);\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.function.Supplier;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            GTiles solver = new GTiles();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class GTiles {\n        int mod = 998244353;\n        Combination comb = new Combination((int) 1e6, mod);\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int[] last = new int[]{1};\n            IntPoly poly = new IntPolyFFT(mod);\n            for (int i = 0; i < n; i++) {\n                int a = in.ri();\n                int b = in.ri();\n                int nextLevel = a - b + last.length;\n                int height = a + b;\n                int[] next = new int[nextLevel];\n                int low = a - (nextLevel - 1);\n                int high = last.length - 1 + a;\n                int[] p = PrimitiveBuffers.allocIntPow2(high - low + 1);\n                for (int j = low; j <= high; j++) {\n                    p[j - low] = comb.combination(height, j);\n                }\n                int[] conv = poly.deltaConvolution(p, last);\n                for (int j = 0; j < nextLevel; j++) {\n                    int id = a - j - low;\n                    next[j] = conv.length <= id ? 0 : conv[id];\n                }\n                debug.debugArray(\"next\", next);\n                PrimitiveBuffers.release(p, conv);\n                last = next;\n            }\n\n            long sum = 0;\n            for (long x : last) {\n                sum += x;\n            }\n            sum %= mod;\n            out.println(sum);\n        }\n\n    }\n\n    static class IntPoly {\n        protected int mod;\n        protected Power power;\n\n        public IntPoly(int mod) {\n            this.mod = mod;\n            this.power = new Power(mod);\n        }\n\n        public int[] convolution(int[] a, int[] b) {\n            return mulBF(a, b);\n        }\n\n        public int rankOf(int[] p) {\n            int r = p.length - 1;\n            while (r >= 0 && p[r] == 0) {\n                r--;\n            }\n            return Math.max(0, r);\n        }\n\n        public int[] mulBF(int[] a, int[] b) {\n            int rA = rankOf(a);\n            int rB = rankOf(b);\n            if (rA > rB) {\n                {\n                    int tmp = rA;\n                    rA = rB;\n                    rB = tmp;\n                }\n                {\n                    int[] tmp = a;\n                    a = b;\n                    b = tmp;\n                }\n            }\n            int[] c = PrimitiveBuffers.allocIntPow2(rA + rB + 1);\n            for (int i = 0; i <= rA; i++) {\n                for (int j = 0; j <= rB; j++) {\n                    c[i + j] = (int) ((c[i + j] + (long) a[i] * b[j]) % mod);\n                }\n            }\n            return c;\n        }\n\n        public int[] deltaConvolution(int[] a, int[] b) {\n            int rA = rankOf(a);\n            SequenceUtils.reverse(a, 0, rA);\n            int[] ans = convolution(a, b);\n            SequenceUtils.reverse(a, 0, rA);\n            for (int i = rA + 1; i < ans.length; i++) {\n                ans[i] = 0;\n            }\n            SequenceUtils.reverse(ans, 0, rA);\n            return Polynomials.normalizeAndReplace(ans);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void swap(double[] data, int i, int j) {\n            double tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void reverse(int[] data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(long x, int mod) {\n            if (x < -mod || x >= mod) {\n                x %= mod;\n            }\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        public static int mod(int x, int mod) {\n            if (x < -mod || x >= mod) {\n                x %= mod;\n            }\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        int modVal;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modVal = factorial.getMod();\n        }\n\n        public Combination(int limit, int mod) {\n            this(new Factorial(limit, mod));\n        }\n\n        public int combination(int m, int n) {\n            if (n > m || n < 0) {\n                return 0;\n            }\n            return (int) ((long) factorial.fact(m) * factorial.invFact(n) % modVal * factorial.invFact(m - n) % modVal);\n        }\n\n    }\n\n    static class FastFourierTransform {\n        private static double[][] realLevels = new double[30][];\n        private static double[][] imgLevels = new double[30][];\n\n        private static void prepareLevel(int i) {\n            if (realLevels[i] == null) {\n                realLevels[i] = new double[1 << i];\n                imgLevels[i] = new double[1 << i];\n                for (int j = 0, s = 1 << i; j < s; j++) {\n                    realLevels[i][j] = Math.cos(Math.PI / s * j);\n                    imgLevels[i][j] = Math.sin(Math.PI / s * j);\n                }\n            }\n        }\n\n        public static void fft(double[][] p, boolean inv) {\n            int m = Log2.ceilLog(p[0].length);\n            int n = 1 << m;\n            int shift = 32 - Integer.numberOfTrailingZeros(n);\n            for (int i = 1; i < n; i++) {\n                int j = Integer.reverse(i << shift);\n                if (i < j) {\n                    SequenceUtils.swap(p[0], i, j);\n                    SequenceUtils.swap(p[1], i, j);\n                }\n            }\n\n            double[][] t = new double[2][1];\n            for (int d = 0; d < m; d++) {\n                int s = 1 << d;\n                int s2 = s << 1;\n                prepareLevel(d);\n                for (int i = 0; i < n; i += s2) {\n                    for (int j = 0; j < s; j++) {\n                        int a = i + j;\n                        int b = a + s;\n                        mul(realLevels[d][j], imgLevels[d][j], p[0][b], p[1][b], t, 0);\n                        sub(p[0][a], p[1][a], t[0][0], t[1][0], p, b);\n                        add(p[0][a], p[1][a], t[0][0], t[1][0], p, a);\n                    }\n                }\n            }\n\n            if (inv) {\n                for (int i = 0, j = 0; i <= j; i++, j = n - i) {\n                    double a = p[0][j];\n                    double b = p[1][j];\n                    div(p[0][i], p[1][i], n, p, j);\n                    if (i != j) {\n                        div(a, b, n, p, i);\n                    }\n                }\n            }\n        }\n\n        public static void add(double r1, double i1, double r2, double i2, double[][] r, int i) {\n            r[0][i] = r1 + r2;\n            r[1][i] = i1 + i2;\n        }\n\n        public static void sub(double r1, double i1, double r2, double i2, double[][] r, int i) {\n            r[0][i] = r1 - r2;\n            r[1][i] = i1 - i2;\n        }\n\n        public static void mul(double r1, double i1, double r2, double i2, double[][] r, int i) {\n            r[0][i] = r1 * r2 - i1 * i2;\n            r[1][i] = r1 * i2 + i1 * r2;\n        }\n\n        public static void div(double r1, double i1, double r2, double[][] r, int i) {\n            r[0][i] = r1 / r2;\n            r[1][i] = i1 / r2;\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public int getMod() {\n            return mod;\n        }\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);\n        }\n\n        public int fact(int n) {\n            if (n >= mod) {\n                return 0;\n            }\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            if (n >= mod) {\n                throw new IllegalArgumentException();\n            }\n            return inv[n];\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Polynomials {\n        public static int rankOf(int[] p) {\n            int r = p.length - 1;\n            while (r >= 0 && p[r] == 0) {\n                r--;\n            }\n            return Math.max(0, r);\n        }\n\n        public static int[] normalizeAndReplace(int[] p) {\n            int r = rankOf(p);\n            return PrimitiveBuffers.resize(p, r + 1);\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        int mod;\n\n        public Power(int mod) {\n            this.mod = mod;\n        }\n\n    }\n\n    static interface IntCombination {\n    }\n\n    static class Buffer<T> {\n        private Deque<T> deque;\n        private Supplier<T> supplier;\n        private Consumer<T> cleaner;\n        private int allocTime;\n        private int releaseTime;\n\n        public Buffer(Supplier<T> supplier) {\n            this(supplier, (x) -> {\n            });\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner) {\n            this(supplier, cleaner, 0);\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner, int exp) {\n            this.supplier = supplier;\n            this.cleaner = cleaner;\n            deque = new ArrayDeque<>(exp);\n        }\n\n        public T alloc() {\n            allocTime++;\n            return deque.isEmpty() ? supplier.get() : deque.removeFirst();\n        }\n\n        public void release(T e) {\n            releaseTime++;\n            cleaner.accept(e);\n            deque.addLast(e);\n        }\n\n    }\n\n    static class PrimitiveBuffers {\n        public static Buffer<int[]>[] intPow2Bufs = new Buffer[30];\n        public static Buffer<double[]>[] doublePow2Bufs = new Buffer[30];\n\n        static {\n            for (int i = 0; i < 30; i++) {\n                int finalI = i;\n                intPow2Bufs[i] = new Buffer<>(() -> new int[1 << finalI], x -> Arrays.fill(x, 0));\n                doublePow2Bufs[i] = new Buffer<>(() -> new double[1 << finalI], x -> Arrays.fill(x, 0));\n            }\n        }\n\n        public static int[] allocIntPow2(int n) {\n            return intPow2Bufs[Log2.ceilLog(n)].alloc();\n        }\n\n        public static int[] resize(int[] data, int want) {\n            int log = Log2.ceilLog(want);\n            if (data.length == 1 << log) {\n                return data;\n            }\n            return replace(allocIntPow2(data, want), data);\n        }\n\n        public static int[] allocIntPow2(int[] data, int newLen) {\n            int[] ans = allocIntPow2(newLen);\n            System.arraycopy(data, 0, ans, 0, Math.min(data.length, newLen));\n            return ans;\n        }\n\n        public static void release(int[] data) {\n            intPow2Bufs[Log2.ceilLog(data.length)].release(data);\n        }\n\n        public static void release(int[] a, int[] b) {\n            release(a);\n            release(b);\n        }\n\n        public static double[] allocDoublePow2(int n) {\n            return doublePow2Bufs[Log2.ceilLog(n)].alloc();\n        }\n\n        public static double[] allocDoublePow2(double[] data, int newLen) {\n            double[] ans = allocDoublePow2(newLen);\n            System.arraycopy(data, 0, ans, 0, Math.min(data.length, newLen));\n            return ans;\n        }\n\n        public static void release(double[] data) {\n            doublePow2Bufs[Log2.ceilLog(data.length)].release(data);\n        }\n\n        public static void release(double[]... data) {\n            for (double[] x : data) {\n                release(x);\n            }\n        }\n\n        public static int[] replace(int[] a, int[] b) {\n            release(b);\n            return a;\n        }\n\n    }\n\n    static class Log2 {\n        public static int ceilLog(int x) {\n            if (x <= 0) {\n                return 0;\n            }\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class IntPolyFFT extends IntPoly {\n        private static final int FFT_THRESHOLD = 50;\n\n        public IntPolyFFT(int mod) {\n            super(mod);\n        }\n\n        public int[] convolution(int[] a, int[] b) {\n            if (a != b) {\n                return multiplyMod(a, b);\n            } else {\n                return pow2(a);\n            }\n        }\n\n        public int[] pow2(int[] a) {\n            int rA = rankOf(a);\n            if (rA < FFT_THRESHOLD) {\n                return mulBF(a, a);\n            }\n\n            int need = rA * 2 + 1;\n\n            double[] aReal = PrimitiveBuffers.allocDoublePow2(need);\n            double[] aImag = PrimitiveBuffers.allocDoublePow2(need);\n            int n = aReal.length;\n\n            for (int i = 0; i <= rA; i++) {\n                int x = DigitUtils.mod(a[i], mod);\n                aReal[i] = x & ((1 << 15) - 1);\n                aImag[i] = x >> 15;\n            }\n            FastFourierTransform.fft(new double[][]{aReal, aImag}, false);\n\n            double[] bReal = PrimitiveBuffers.allocDoublePow2(aReal, aReal.length);\n            double[] bImag = PrimitiveBuffers.allocDoublePow2(aImag, bReal.length);\n\n\n            for (int i = 0, j = 0; i <= j; i++, j = n - i) {\n                double ari = aReal[i];\n                double aii = aImag[i];\n                double bri = bReal[i];\n                double bii = bImag[i];\n                double arj = aReal[j];\n                double aij = aImag[j];\n                double brj = bReal[j];\n                double bij = bImag[j];\n\n                double a1r = (ari + arj) / 2;\n                double a1i = (aii - aij) / 2;\n                double a2r = (aii + aij) / 2;\n                double a2i = (arj - ari) / 2;\n\n                double b1r = (bri + brj) / 2;\n                double b1i = (bii - bij) / 2;\n                double b2r = (bii + bij) / 2;\n                double b2i = (brj - bri) / 2;\n\n                aReal[i] = a1r * b1r - a1i * b1i - a2r * b2i - a2i * b2r;\n                aImag[i] = a1r * b1i + a1i * b1r + a2r * b2r - a2i * b2i;\n                bReal[i] = a1r * b2r - a1i * b2i + a2r * b1r - a2i * b1i;\n                bImag[i] = a1r * b2i + a1i * b2r + a2r * b1i + a2i * b1r;\n\n                if (i != j) {\n                    a1r = (arj + ari) / 2;\n                    a1i = (aij - aii) / 2;\n                    a2r = (aij + aii) / 2;\n                    a2i = (ari - arj) / 2;\n\n                    b1r = (brj + bri) / 2;\n                    b1i = (bij - bii) / 2;\n                    b2r = (bij + bii) / 2;\n                    b2i = (bri - brj) / 2;\n\n                    aReal[j] = a1r * b1r - a1i * b1i - a2r * b2i - a2i * b2r;\n                    aImag[j] = a1r * b1i + a1i * b1r + a2r * b2r - a2i * b2i;\n                    bReal[j] = a1r * b2r - a1i * b2i + a2r * b1r - a2i * b1i;\n                    bImag[j] = a1r * b2i + a1i * b2r + a2r * b1i + a2i * b1r;\n                }\n            }\n\n            FastFourierTransform.fft(new double[][]{aReal, aImag}, true);\n            FastFourierTransform.fft(new double[][]{bReal, bImag}, true);\n\n            int[] ans = PrimitiveBuffers.allocIntPow2(need);\n            for (int i = 0; i < need; i++) {\n                long aa = DigitUtils.mod(Math.round(aReal[i]), mod);\n                long bb = DigitUtils.mod(Math.round(bReal[i]), mod);\n                long cc = DigitUtils.mod(Math.round(aImag[i]), mod);\n                ans[i] = DigitUtils.mod(aa + (bb << 15) + (cc << 30), mod);\n            }\n\n            PrimitiveBuffers.release(aReal, bReal, aImag, bImag);\n            return ans;\n        }\n\n        private int[] multiplyMod(int[] a, int[] b) {\n            int rA = rankOf(a);\n            int rB = rankOf(b);\n            if (Math.min(rA, rB) < FFT_THRESHOLD) {\n                return mulBF(a, b);\n            }\n\n            int need = rA + rB + 1;\n\n            double[] aReal = PrimitiveBuffers.allocDoublePow2(need);\n            double[] aImag = PrimitiveBuffers.allocDoublePow2(need);\n            int n = aReal.length;\n\n            for (int i = 0; i <= rA; i++) {\n                int x = DigitUtils.mod(a[i], mod);\n                aReal[i] = x & ((1 << 15) - 1);\n                aImag[i] = x >> 15;\n            }\n            FastFourierTransform.fft(new double[][]{aReal, aImag}, false);\n\n            double[] bReal = PrimitiveBuffers.allocDoublePow2(need);\n            double[] bImag = PrimitiveBuffers.allocDoublePow2(need);\n            for (int i = 0; i <= rB; i++) {\n                int x = DigitUtils.mod(b[i], mod);\n                bReal[i] = x & ((1 << 15) - 1);\n                bImag[i] = x >> 15;\n            }\n            FastFourierTransform.fft(new double[][]{bReal, bImag}, false);\n\n\n            for (int i = 0, j = 0; i <= j; i++, j = n - i) {\n                double ari = aReal[i];\n                double aii = aImag[i];\n                double bri = bReal[i];\n                double bii = bImag[i];\n                double arj = aReal[j];\n                double aij = aImag[j];\n                double brj = bReal[j];\n                double bij = bImag[j];\n\n                double a1r = (ari + arj) / 2;\n                double a1i = (aii - aij) / 2;\n                double a2r = (aii + aij) / 2;\n                double a2i = (arj - ari) / 2;\n\n                double b1r = (bri + brj) / 2;\n                double b1i = (bii - bij) / 2;\n                double b2r = (bii + bij) / 2;\n                double b2i = (brj - bri) / 2;\n\n                aReal[i] = a1r * b1r - a1i * b1i - a2r * b2i - a2i * b2r;\n                aImag[i] = a1r * b1i + a1i * b1r + a2r * b2r - a2i * b2i;\n                bReal[i] = a1r * b2r - a1i * b2i + a2r * b1r - a2i * b1i;\n                bImag[i] = a1r * b2i + a1i * b2r + a2r * b1i + a2i * b1r;\n\n                if (i != j) {\n                    a1r = (arj + ari) / 2;\n                    a1i = (aij - aii) / 2;\n                    a2r = (aij + aii) / 2;\n                    a2i = (ari - arj) / 2;\n\n                    b1r = (brj + bri) / 2;\n                    b1i = (bij - bii) / 2;\n                    b2r = (bij + bii) / 2;\n                    b2i = (bri - brj) / 2;\n\n                    aReal[j] = a1r * b1r - a1i * b1i - a2r * b2i - a2i * b2r;\n                    aImag[j] = a1r * b1i + a1i * b1r + a2r * b2r - a2i * b2i;\n                    bReal[j] = a1r * b2r - a1i * b2i + a2r * b1r - a2i * b1i;\n                    bImag[j] = a1r * b2i + a1i * b2r + a2r * b1i + a2i * b1r;\n                }\n            }\n\n            FastFourierTransform.fft(new double[][]{aReal, aImag}, true);\n            FastFourierTransform.fft(new double[][]{bReal, bImag}, true);\n\n            int[] ans = PrimitiveBuffers.allocIntPow2(need);\n            for (int i = 0; i < need; i++) {\n                long aa = DigitUtils.mod(Math.round(aReal[i]), mod);\n                long bb = DigitUtils.mod(Math.round(bReal[i]), mod);\n                long cc = DigitUtils.mod(Math.round(aImag[i]), mod);\n                ans[i] = DigitUtils.mod(aa + (bb << 15) + (cc << 30), mod);\n            }\n\n            PrimitiveBuffers.release(aReal, bReal, aImag, bImag);\n            return ans;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debugArray(String name, int[] matrix) {\n            if (offline) {\n                debug(name, Arrays.toString(matrix));\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "//EDIR\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\ntemplate<const int &MOD>\nstruct _m_int {\n  int val;\n \n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n \n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n \n    while (r != 0) {\n      int q = g / r;\n      g %= r; swap(g, r);\n      x -= q * y; swap(x, y);\n    }\n \n    return x < 0 ? x + m : x;\n  }\n \n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n \n  _m_int& operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  _m_int& operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n \n  _m_int& operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n \n  _m_int& operator/=(const _m_int &other) {\n    return *this *= other.inv();\n  }\n \n  friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n \n  _m_int& operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n \n  _m_int& operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n \n  _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n  _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n \n  _m_int operator-() const {\n    return val == 0 ? 0 : MOD - val;\n  }\n \n  friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n  friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n  friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n  friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n  friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n  friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n \n  _m_int inv() const {\n    return inv_mod(val);\n  }\n \n  _m_int pow(int64_t p) const {\n    if (p < 0)\n      return inv().pow(-p);\n \n    _m_int a = *this, result = 1;\n \n    while (p > 0) {\n      if (p & 1)\n        result *= a;\n      a *= a;\n      p >>= 1;\n    }\n \n    return result;\n  }\n  \n  friend string to_string(_m_int<MOD> x) {\n    return to_string(x.val);\n  }\n \n  friend ostream& operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\n\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\n\nconst int g = 3;\nconst int LOGN = 15;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    forn(i, n) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\nint main() {\n  prepare();\n  \n  vector<Mint> fact(1, 1), ifact(1, 1);\n  auto C = [&](int n, int k) -> Mint {\n    if (k < 0 || k > n) return 0;\n    while (sz(fact) <= n) {\n      fact.push_back(fact.back() * sz(fact));\n      ifact.push_back(fact.back().inv());\n    }\n    return fact[n] * ifact[k] * ifact[n - k];\n  };\n  \n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  forn(i, n) cin >> a[i] >> b[i];\n  \n  vector<Mint> ans(1, 1);\n  forn(i, n) {\n    vector<Mint> Cs;\n    for (int j = b[i] - sz(ans) + 1; j < sz(ans) + a[i]; ++j)\n      Cs.push_back(C(a[i] + b[i], j));\n    auto res = mul(ans, Cs);\n    int cnt = sz(ans);\n    ans.resize(cnt + a[i] - b[i]);\n    forn(j, sz(ans)) ans[j] = res[cnt + j - 1];\n  }\n  \n  cout << accumulate(ans.begin(), ans.end(), Mint(0)) << endl;\n}"
        },
        {
            "language": 2,
            "solution": "/*\n   ___                         ______      __                  __\n   /   |____  __  ___________ _/ ____/___ _/ /___  ____  ______/ /____\n   / /| /_  / / / / / ___/ __ `/ /   / __ `/ __/ / / / / / / __  / ___/\n   / ___ |/ /_/ /_/ (__  ) /_/ / /___/ /_/ / /_/ /_/ / /_/ / /_/ (__  )\n   /_/  |_/___/\\__,_/____/\\__,_/\\____/\\__,_/\\__/\\__, /\\__, /\\__,_/____/\n   /____//____/\n\n   \u3000\u3000\u3000\u3000\u3000\uff0f\uff1e\u3000 \u30d5\n   \u3000\u3000\u3000\u3000\u3000| \u3000_\u3000 _|\n   \u3000 \u3000\u3000\u3000\uff0f`\u30df _x \u5f61\n   \u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\n   \u3000\u3000\u3000 /\u3000  \u30fd\u3000\u3000 ?\n   \u3000\uff0f\uffe3|\u3000\u3000 |\u3000|\u3000|\n   \u3000| (\uffe3\u30fd\uff3f_\u30fd_)_)\n   \u3000\uff3c\u4e8c\u3064\n\n*/\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = 0; bool f = 0;\n\tchar c = getchar();\n\tfor (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n\tfor (;isdigit(c);c=getchar()) x=x*10+(c^48);\n\tif (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n\tstatic short st[30];short tp=0;\n\tif(x<0) putchar('-'),x=-x;\n\tdo st[++tp]=x%10,x/=10; while(x);\n\twhile(tp) putchar('0'|st[tp--]);\n\tputchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\n//#pragma GCC optimize(2)\nconst int P = 998244353;\nnamespace Poly {\n#define poly vector<int> \n#define reg register\n\tinline int mod(int x) { return x >= P ? x - P : x; }\n\tinline void Add(int &x, int y) { x += y; if (x >= P) x -= P; }\n\ttemplate <typename T>\n\t\tinline int max(T x, T y) { return x > y ? x : y; }\n\ttemplate <typename T>\n\t\tinline int min(T x, T y) { return x > y ? y : x; }\n\tint fpw(ll x, int mi) {\n\t\tll res = 1;\n\t\tfor (; mi; mi >>= 1, x = x * x % P)\n\t\t\tif (mi & 1) res = res * x % P;\n\t\treturn res;\n\t}\n\tconst int N = 600500;\n\tint E[N], r[N], lim;\n\tinline void Prework(int Maxsize) {\n\t\tE[1] = lim = 1;\n\t\twhile (lim <= Maxsize) lim <<= 1;\n\t\tfor (int i = 2;i < lim;i <<= 1) {\n\t\t\tint *e0 = E + (i >> 1), *e1 = E + i;\n\t\t\tll w = fpw(3, (P - 1) / (i << 1));\n\t\t\tfor (int j = 0;j < i; j += 2)\n\t\t\t\te1[j] = e0[j >> 1], e1[j + 1] = e1[j] * w % P;\n\t\t}\n\t}\n\n\tinline void getR(int len = lim >> 1) {\n\t\tfor (reg int i = 1;i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len : 0);\n\t}\n\tinline int getlen(int Maxsize) { lim = 1; while (lim <= Maxsize) lim <<= 1; return lim; } \n\tvoid init(int Maxsize) { getlen(Maxsize); getR(); }\n\n\tinline void Dft(poly &A) {\n\t\tfor (reg int i = 1;i < lim; ++i)\n\t\t\tif (r[i] < i) std::swap(A[i], A[r[i]]);\n\t\tif (lim >= 2) \n\t\t\tfor (reg int j = 0;j < lim; j += 2) {\n\t\t\t\tint x = A[j], y = A[j+1];\n\t\t\t\tA[j] = mod(x + y), A[j+1] = mod(P + x - y);\n\t\t\t}\n\t\tfor (int i = 2;i < lim; i <<= 1) {\n\t\t\tfor (int j = 0;j < lim; j += (i << 1)) {\n\t\t\t\tpoly::iterator f = A.begin() + j, g = A.begin() + i + j;\n\t\t\t\tint *e = E + i;\n\t\t\t\tfor (int k = 0;k < i; ++k) {\n\t\t\t\t\tint x = f[k], y = 1ll * g[k] * e[k] % P;\n\t\t\t\t\tf[k] = mod(x + y), g[k] = mod(P + x - y);\n\t\t\t\t\t++k;\n\t\t\t\t\tx = f[k], y = 1ll * g[k] * e[k] % P;\n\t\t\t\t\tf[k] = mod(x + y), g[k] = mod(P + x - y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void iDft(poly &f) { \n\t\tDft(f), reverse(f.begin() + 1, f.begin() + lim); \n\t\tll inv = P - (P - 1) / lim;\n\t\tfor (int i = 0;i < lim; i++) f[i] = f[i] * inv % P;\n\t}\n\n\tpoly Mul(poly &a, poly &b) {\n\t\tint s1 = a.size(), s2 = b.size();\n\t\tif (s1 <= 28 || s2 <= 28) {\n\t\t\tpoly ans(s1 + s2 - 1);\n\t\t\tfor (reg int i = 0;i < s1 + s2 - 1; ++i) ans[i] = 0;\n\t\t\tfor (reg int i = 0;i < s1; ++i)\n\t\t\t\tfor (reg int j = 0;j < s2; ++j)\n\t\t\t\t\tAdd(ans[i + j], 1ll * a[i] * b[j] % P);\n\t\t\treturn ans;\n\t\t}\n\t\tinit(s1 + s2 - 2);\n\t\tpoly ans(lim); a.resize(lim), b.resize(lim);\n\t\tDft(a), Dft(b);\n\t\tfor (int i = 0;i < lim; ++i) ans[i] = 1ll * a[i] * b[i] % P;\n\t\treturn iDft(ans), ans.resize(s1 + s2 - 1), ans;\n\t}\n\tpoly operator * (poly a, poly b) { return Mul(a, b); }\n}\n\nusing Poly::Prework;\nusing Poly::operator*;\n\nconst int N = 205000;\nint n;\nll fac[N], inv[N];\nint main() {\n\tread(n), fac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2;i <= 200000; ++i) \n\t\tfac[i] = fac[i-1] * i % P, inv[i] = (P - P / i) * inv[P % i] % P;\n\tfor (int i = 1;i <= 200000; ++i)\n\t\tinv[i] = inv[i-1] * inv[i] % P;\n\tauto C = [&](int x, int y) {\n\t\tif (y > x || y < 0) return 0ll;\n\t\treturn fac[x] * inv[y] % P * inv[x-y] % P;\n\t};\n\tPrework(10000);\n\tpoly st(2); st[1] = 1;\n\tint nw = 1, tnw;\n\tfor (int i = 1, a, b;i <= n; ++i) {\n\t\tread(a), read(b), tnw = nw + a - b;\n\t\tpoly res(tnw + nw + 1);\n\t\tfor (int i = 0;i <= tnw + nw; ++i)  res[i] = C(a + b, a + nw - i);\n\t\tpoly T = st * res;\n\t\tst.clear();\n\t\tst.resize(tnw + 1);\n\t\tfor (int i = 1;i <= tnw; ++i) st[i] = T[i + nw];\n\t\tnw = tnw; \n\t}\n\tll ans = 0;\n\tfor (int i = 1;i <= nw; ++i) ans += st[i];\n\twrite(ans % P);\n\treturn 0;\n}\n\n/*\n\n3\n24 21\n66 64\n1 1\n\n*/"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;  // 2^23 * 7 * 17 + 1\nconst int ROOT_OF_UNITY = 15311432;\nint mul(int a, int b) { return 1LL * a * b % MOD; }\nint powmod(int base, int expo)\n{\n    int t = 1;\n    for (; expo > 0; expo >>= 1) {\n        if (expo & 1) t = mul(t, base);\n        base = mul(base, base);\n    }\n    return t;\n}\n\nconst int MAX2N = 1 << 23;\nint roots[MAX2N], inv_roots[MAX2N];\n\nvoid fft(vector<int>& a, const vector<int>&p, int root[])\n{\n    int n = a.size();\n    for (int i = 0; i < n; ++i)\n        if (i < p[i]) swap(a[i], a[p[i]]);\n\n    for (int m = 1, t = MAX2N / 2; m < n; m *= 2, t /= 2)\n        for (int i = 0; i < n; i += m * 2)\n            for (int j = 0; j < m; ++j) {\n                int& u = a[i + j];\n                int& v = a[i + j + m];\n                v = mul(v, root[j * t]);\n                int tmp = u - v;\n                if (tmp < 0) tmp += MOD;\n                u += v;\n                if (u >= MOD) u -= MOD;\n                v = tmp;\n            }\n}\n\nvector<int> polymul(const vector<int>& a, const vector<int>& b)\n{\n    int n = a.size() + b.size();\n    if (__builtin_popcount(n) != 1) n = 1 << (32 - __builtin_clz(n));\n\n    vector<int> pa(a), pb(b);\n    pa.resize(n), pb.resize(n);\n\n    vector<int> p(n);\n    for (int i = 1; i < n; ++i)\n        if (i & 1) p[i] = p[i - 1] + n / 2;\n        else p[i] = p[i / 2] / 2;\n\n    fft(pa, p, roots);\n    fft(pb, p, roots);\n    for (int i = 0; i < n; ++i)\n        pa[i] = mul(pa[i], pb[i]);\n\n    fft(pa, p, inv_roots);\n    int inv_n = powmod(n, MOD - 2);\n    for (int i = 0; i < n; ++i)\n        pa[i] = mul(pa[i], inv_n);\n\n    return pa;\n}\n\nconst int N = 2e5;\n\nint ft[N + 2], invft[N + 2];\nint C(int n, int k) { return k >= 0 && k <= n ? mul(ft[n], mul(invft[k], invft[n - k])) : 0; }\n\nvector<int> src(1, 1);\n\nvoid add_row(int x, int y)\n{\n    int n = src.size();\n    int m = n + x - y;\n    vector<int> b;\n    for (int i = 0; i < n + m; ++i)\n        b.push_back(C(x + y, y - n + i));\n\n    b = polymul(src, b);\n    src.resize(m);\n    copy(b.begin() + n, b.begin() + n + m, src.begin());\n}\n\nint main()\n{\n    ft[0] = 1;\n    for (int i = 1; i <= N; ++i) ft[i] = mul(ft[i - 1], i);\n    invft[N] = powmod(ft[N], MOD - 2);\n    for (int i = N - 1; i >= 0; --i) invft[i] = mul(invft[i + 1], i + 1);\n\n    roots[0] = 1;\n    for (int i = 1; i < MAX2N; ++i) roots[i] = mul(roots[i - 1], ROOT_OF_UNITY);\n    inv_roots[MAX2N - 1] = powmod(roots[MAX2N - 1], MOD - 2);\n    for (int i = MAX2N - 2; i >= 0; --i) inv_roots[i] = mul(inv_roots[i + 1], ROOT_OF_UNITY);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int x, y;\n        cin >> x >> y;\n        add_row(x, y);\n    }\n    int res = 0;\n    for (int x : src) {\n        res += x;\n        if (res >= MOD) res -= MOD;\n    }\n    cout << res;\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define io_speed_up ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;} //\u8bfb\u6574\u578b\ntemplate<typename T>void pt(T x,int c=10){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10,-1);putchar(x%10+48);if(c!=-1)putchar(c);}\ntemplate<typename T>void umax(T&x,const T&y){if(x<y)x=y;}\ntemplate<typename T>void umin(T&x,const T&y){if(x>y)x=y;}\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define for1(i,n) for (int i=1;i<=n;i++)\n#define for0(i,n) for (int i=0;i<n;i++)\n#define ms(a,b)  memset(a,b,sizeof a)\n#define all(n) (n).begin(), (n).end()\n#define sz(x) (int)x.size()\n#define fi first\n#define se second\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int,int>;\nusing pll = pair<long,long>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 200005;\nconst int mod = 998244353;\ninline int pow_mod(ll x, int n) {\n    ll res;\n    for(res = 1; n; n >>= 1, x = x * x % mod)\n        if(n & 1)\n            res = res * x % mod;\n    return res;\n}\n \ninline int add_mod(int x, int y) {\n    x += y;\n    return x >= mod ? x - mod : x;\n}\n \ninline int sub_mod(int x, int y) {\n    x -= y;\n    return x < 0 ? x + mod : x;\n}\n \nvoid NTT(int a[], int n, int op) {\n    for(int i = 1, j = n >> 1; i < n - 1; ++i) {\n        if(i < j)\n            swap(a[i], a[j]);\n        int k = n >> 1;\n        while(k <= j) {\n            j -= k;\n            k >>= 1;\n        }\n        j += k;\n    }\n    for(int len = 2; len <= n; len <<= 1) {\n        int g = pow_mod(3, (mod - 1) / len);\n        for(int i = 0; i < n; i += len) {\n            int w = 1;\n            for(int j = i; j < i + (len >> 1); ++j) {\n                int u = a[j], t = 1ll * a[j + (len >> 1)] * w % mod;\n                a[j] = add_mod(u, t), a[j + (len >> 1)] = sub_mod(u, t);\n                w = 1ll * w * g % mod;\n            }\n        }\n    }\n    if(op == -1) {\n        reverse(a + 1, a + n);\n        int inv = pow_mod(n, mod - 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = 1ll * a[i] * inv % mod;\n    }\n}\n \nint A[maxn + 5], B[maxn + 5];\n \nint pow2(int x) {\n    int res = 1;\n    while(res < x)\n        res <<= 1;\n    return res;\n}\n \nvoid convolution(int A[], int B[], int Asize, int Bsize) {\n    int n = pow2(Asize + Bsize - 1);\n    for(int i = Asize; i < n; ++i)\n        A[i] = 0;\n    for(int i = Bsize; i < n; ++i)\n        B[i] = 0;\n    NTT(A, n, 1);\n    NTT(B, n, 1);\n    for(int i = 0; i < n; ++i)\n        A[i] = 1ll * A[i] * B[i] % mod;\n    NTT(A, n, -1);\n    return;\n}\nconst int N = 200002;\nll jc[N+1],inv[N+1];\nint C(int x,int y) {\n    if(x<y || y<0) return 0;\n    return jc[x] * inv[y] % mod * inv[x-y] % mod;\n}\nint n;\nint main() {\n    io_speed_up;\n    jc[0] = inv[0] = 1;\n    rep(i,1,N) jc[i] = jc[i-1]*i%mod;\n    inv[N] = pow_mod(jc[N],mod-2);\n    per(i,N-1,1) inv[i] = inv[i+1]*(i+1)%mod;\n    \n    cin>>n;\n    A[0] = 1; \n    int Asize = 1;\n    rep(i,1,n) {\n        int a,b,c;\n        cin>>a>>b; c = a+b;\n        int sz = Asize + a - b;\n        per(i,Asize-1,0) B[i] = C(c,b+i-Asize+1);\n        for0(i,sz-1) B[Asize+i] = C(c,b+i+1);\n        convolution(A,B,Asize,Asize+sz-1);\n        for(int i=0;i<sz;i++) A[i] = A[i+Asize-1];\n        Asize = sz;\n    }\n    int ans = 0;\n    for0(i,Asize) ans = add_mod(ans, A[i]);\n    cout<<ans<<\"\\n\";\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\nconst int N=5010,M=2e5;\nconst int mod=998244353,g=3,invg=332748118;\nint rev_tag=0;\nint cir[N<<4];\nint fac[M+10],inv[M+10];\ninline int C(int x,int y)\n{ \n\tif(x<y||y<0) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod; \n}\ninline int power(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\ninline void mul(int *A,int *B,int x,int y){ for(int i=x;i<y;i++) A[i]=1ll*A[i]*B[i]%mod; }\ninline void clear(int *A,int x,int y){ for(int i=x;i<y;i++) A[i]=0; }\ninline void NTT(int *A,int lim,int tag)\n{\n    if(rev_tag!=lim) for(int i=0;i<=lim;i++) cir[i]=(cir[i>>1]>>1)|((i&1)?lim>>1:0); \n    rev_tag=lim; int buf,w,inv0=power(lim,mod-2); \n    for(int i=0;i<lim;i++) if(i<cir[i]) swap(A[i],A[cir[i]]);\n    for(int l=2;l<=lim;l<<=1)\n    {\n        int r=l>>1; buf=power(tag?g:invg,(mod-1)/l),w=1;\n        for(int i=0;i<lim;i+=l,w=1)\n        for(int j=i;j<i+r;j++,w=1ll*w*buf%mod)\n        {\n            int tmp=1ll*w*A[j+r]%mod;\n            A[j+r]=(A[j]-tmp+mod)%mod;\n            A[j]=(A[j]+tmp)%mod;\n        }\n    }\n    if(!tag) for(int i=0;i<lim;i++) A[i]=1ll*A[i]*inv0%mod;\n}\nint f[1010][N],F[N<<4],G[N<<4];\nint main()\n{\n\tfac[0]=1; for(int i=1;i<=M;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[M]=power(fac[M],mod-2); for(int i=M-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tint n,ans=0,a,b;\n\tscanf(\"%d\",&n);\n\tint high=1; f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b),high+=a-b;\n\t\tint cur=high-a+b,now=high;\n\t\tfor(int j=1;j<=cur;j++) F[j]=f[i-1][j];\n\t\tfor(int j=-cur;j<=now;j++) G[j+cur]=C(a+b,b+j);\n\t\tint lim=1; while(lim<(now+cur+1)+cur) lim<<=1;\n\t\tNTT(F,lim,1),NTT(G,lim,1),mul(F,G,0,lim),NTT(F,lim,0);\n\t\tfor(int j=1;j<=now;j++) f[i][j]=F[j+cur];\n\t\tclear(F,0,lim),clear(G,0,lim);\n\t}\n\tfor(int i=1;i<=high;i++) ans=(ans+f[n][i])%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\ntemplate<const int &MOD>\nstruct _m_int {\n  int val;\n \n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n \n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n \n    while (r != 0) {\n      int q = g / r;\n      g %= r; swap(g, r);\n      x -= q * y; swap(x, y);\n    }\n \n    return x < 0 ? x + m : x;\n  }\n \n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n \n  _m_int& operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  _m_int& operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n \n  _m_int& operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n \n  _m_int& operator/=(const _m_int &other) {\n    return *this *= other.inv();\n  }\n \n  friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n \n  _m_int& operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n \n  _m_int& operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n \n  _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n  _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n \n  _m_int operator-() const {\n    return val == 0 ? 0 : MOD - val;\n  }\n \n  friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n  friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n  friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n  friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n  friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n  friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n \n  _m_int inv() const {\n    return inv_mod(val);\n  }\n \n  _m_int pow(int64_t p) const {\n    if (p < 0)\n      return inv().pow(-p);\n \n    _m_int a = *this, result = 1;\n \n    while (p > 0) {\n      if (p & 1)\n        result *= a;\n      a *= a;\n      p >>= 1;\n    }\n \n    return result;\n  }\n  \n  friend string to_string(_m_int<MOD> x) {\n    return to_string(x.val);\n  }\n \n  friend ostream& operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\n\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\n\nconst int g = 3;\nconst int LOGN = 20;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    forn(i, n) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\nint main() {\n  prepare();\n  \n  vector<Mint> fact(1, 1), ifact(1, 1);\n  auto C = [&](int n, int k) -> Mint {\n    if (k < 0 || k > n) return 0;\n    while (sz(fact) <= n) {\n      fact.push_back(fact.back() * sz(fact));\n      ifact.push_back(fact.back().inv());\n    }\n    return fact[n] * ifact[k] * ifact[n - k];\n  };\n  \n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  forn(i, n) cin >> a[i] >> b[i];\n  \n  vector<Mint> ans(1, 1);\n  forn(i, n) {\n    vector<Mint> Cs;\n    for (int j = b[i] - sz(ans) + 1; j < sz(ans) + a[i]; ++j)\n      Cs.push_back(C(a[i] + b[i], j));\n    auto res = mul(ans, Cs);\n    int cnt = sz(ans);\n    ans.resize(cnt + a[i] - b[i]);\n    forn(j, sz(ans)) ans[j] = res[cnt + j - 1];\n  }\n  \n  cout << accumulate(ans.begin(), ans.end(), Mint(0)) << endl;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\ntemplate<const int &MOD>\nstruct _m_int {\n  int val;\n \n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n \n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n \n    while (r != 0) {\n      int q = g / r;\n      g %= r; swap(g, r);\n      x -= q * y; swap(x, y);\n    }\n \n    return x < 0 ? x + m : x;\n  }\n \n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n \n  _m_int& operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  _m_int& operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n \n  _m_int& operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n \n  _m_int& operator/=(const _m_int &other) {\n    return *this *= other.inv();\n  }\n \n  friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n \n  _m_int& operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n \n  _m_int& operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n \n  _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n  _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n \n  _m_int operator-() const {\n    return val == 0 ? 0 : MOD - val;\n  }\n \n  friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n  friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n  friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n  friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n  friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n  friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n \n  _m_int inv() const {\n    return inv_mod(val);\n  }\n \n  _m_int pow(int64_t p) const {\n    if (p < 0)\n      return inv().pow(-p);\n \n    _m_int a = *this, result = 1;\n \n    while (p > 0) {\n      if (p & 1)\n        result *= a;\n      a *= a;\n      p >>= 1;\n    }\n \n    return result;\n  }\n  \n  friend string to_string(_m_int<MOD> x) {\n    return to_string(x.val);\n  }\n \n  friend ostream& operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\n\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\n\nconst int g = 3;\nconst int LOGN = 15;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    forn(i, n) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\nint main() {\n  prepare();\n  \n  vector<Mint> fact(1, 1), ifact(1, 1);\n  auto C = [&](int n, int k) -> Mint {\n    if (k < 0 || k > n) return 0;\n    while (sz(fact) <= n) {\n      fact.push_back(fact.back() * sz(fact));\n      ifact.push_back(fact.back().inv());\n    }\n    return fact[n] * ifact[k] * ifact[n - k];\n  };\n  \n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  forn(i, n) cin >> a[i] >> b[i];\n  \n  vector<Mint> ans(1, 1);\n  forn(i, n) {\n    vector<Mint> Cs;\n    for (int j = b[i] - sz(ans) + 1; j < sz(ans) + a[i]; ++j)\n      Cs.push_back(C(a[i] + b[i], j));\n    auto res = mul(ans, Cs);\n    int cnt = sz(ans);\n    ans.resize(cnt + a[i] - b[i]);\n    forn(j, sz(ans)) ans[j] = res[cnt + j - 1];\n  }\n  \n  cout << accumulate(ans.begin(), ans.end(), Mint(0)) << endl;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace NTT\n{\n    const int P=998244353,g=3;\n    const int W=22,S=1<<W;\n    const int J=86583718;\n\n    inline int add(int a,int b) {int r=a+b; return r<P?r:r-P;}\n    inline int sub(int a,int b) {int r=a-b; return r<0?r+P:r;}\n    inline int mul(long long a,long long b) {return (a*b)%P;}\n    inline int inv(int a) {return a==1?a:mul(inv(P%a),P-P/a);}\n    inline int qpow(int a,long long k)\n    {\n        int r=1;\n        while (k)\n        {\n            if (k&1) r=mul(r,a);\n            k>>=1; a=mul(a,a);\n        }\n        return r;\n    }\n\n    int r[S],w[2][S];\n    void init(int lim)\n    {\n        int w0=qpow(g,(P-1)/lim);\n        w[0][0]=w[1][0]=1;\n        for (int i=1;i<lim;i++) w[0][i]=w[1][lim-i]=mul(w[0][i-1],w0);\n        for (int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));\n    }\n\n    void ntt(int *a,int lim,int o)\n    {\n        for (int i=0;i<lim;i++) if (i<r[i]) swap(a[i],a[r[i]]);\n        for (int i=1;i<lim;i<<=1)\n        {\n            for (int j=0,t=lim/(i<<1);j<lim;j+=i<<1)\n            {\n                for (int k=j,l=0;k<j+i;k++,l+=t)\n                {\n                    int x=a[k],y=mul(w[o][l],a[k+i]);\n                    a[k]=add(x,y);\n                    a[k+i]=sub(x,y);\n                }\n            }\n        }\n        if (o)\n        {\n            int tmp=NTT::inv(lim);\n            for (int i=0;i<lim;i++) a[i]=mul(a[i],tmp);\n        }\n    }\n\n    vector<int> poly_add(const vector<int> &a,const vector<int> &b)\n    {\n        int n=a.size(),m=b.size();\n        vector<int> c;\n        for (int i=0;i<max(n,m);i++) c.push_back(add((i<n?a[i]:0),(i<m?b[i]:0)));\n        return c;\n    }\n\n    vector<int> poly_sub(const vector<int> &a,const vector<int> &b)\n    {\n        int n=a.size(),m=b.size();\n        vector<int> c;\n        for (int i=0;i<max(n,m);i++) c.push_back(sub((i<n?a[i]:0),(i<m?b[i]:0)));\n        return c;\n    }\n\n    vector<int> poly_d(const vector<int> &a)\n    {\n        int n=a.size();\n        vector<int> b;\n        for (int i=1;i<n;i++) b.push_back(mul(a[i],i));\n        return b;\n    }\n\n    vector<int> poly_s(const vector<int> &a)\n    {\n        int n=a.size();\n        vector<int> b{0};\n        for (int i=0;i<n;i++) b.push_back(mul(a[i],inv(i+1)));\n        return b;\n    }\n\n    int p1[S],p2[S];\n    vector<int> poly_mul(const vector<int> &a,const vector<int> &b)\n    {\n        int n=a.size(),m=b.size();\n        int lim=1;\n        while (lim<(n<<1)) lim<<=1;\n        while (lim<(m<<1)) lim<<=1;\n        init(lim);\n        for (int i=0;i<lim;i++) r[i]=(i&1)*(lim>>1)+(r[i>>1]>>1);\n        copy_n(a.begin(),n,p1); fill(p1+n,p1+lim,0);\n        copy_n(b.begin(),m,p2); fill(p2+m,p2+lim,0);\n        ntt(p1,lim,0);\n        ntt(p2,lim,0);\n        for (int i=0;i<lim;i++) p1[i]=mul(p1[i],p2[i]);\n        ntt(p1,lim,1);\n        return vector<int>(p1,p1+n+m-1);\n    }\n\n    vector<int> poly_inv(const vector<int> &a)\n    {\n        int n=a.size();\n        if (n==1) return {inv(a[0])};\n        auto b=a; b.resize((n+1)>>1);\n        b=poly_inv(b);\n        int m=b.size();\n        int lim=1;\n        while (lim<(n<<1)) lim<<=1;\n        while (lim<(m<<1)) lim<<=1;\n        init(lim);\n        copy_n(a.begin(),n,p1); fill(p1+n,p1+lim,0);\n        copy_n(b.begin(),m,p2); fill(p2+m,p2+lim,0);\n        ntt(p1,lim,1);\n        ntt(p2,lim,1);\n        for (int i=0;i<lim;i++) p1[i]=mul(p2[i],sub(2,mul(p1[i],p2[i])));\n        ntt(p1,lim,-1);\n        return vector<int>(p1,p1+n);\n    }\n\n    vector<int> poly_div(const vector<int> &a,const vector<int> &b)\n    {\n        int n=a.size(),m=b.size();\n        if (m>n) return {0};\n        auto ar=a,br=b;\n        reverse(ar.begin(),ar.end()); reverse(br.begin(),br.end());\n        ar.resize(n-m+1); br.resize(n-m+1);\n        br=poly_inv(br);\n        auto q=poly_mul(ar,br); q.resize(n-m+1);\n        reverse(q.begin(),q.end());\n        return q;\n    }\n\n    vector<int> poly_mod(const vector<int> &a,const vector<int> &b)\n    {\n        int m=b.size();\n        auto c=poly_div(a,b);\n        c=poly_mul(b,c);\n        c=poly_sub(a,c); c.resize(m-1);\n        return c;\n    }\n\n    vector<int> poly_sqrt(const vector<int> &a)\n    {\n        int n=a.size();\n        if (n==1) return {1};\n        auto b=a; b.resize((n+1)>>1);\n        b=poly_sqrt(b); b.resize(n);\n        auto c=poly_add(b,poly_mul(poly_inv(b),a)); c.resize(n);\n        int i2=inv(2); for (int &i:c) i=mul(i,i2);\n        return c;\n    }\n\n    vector<int> poly_ln(const vector<int> &a)\n    {\n        int n=a.size();\n        auto b=poly_mul(poly_inv(a),poly_d(a));\n        b.resize(n-1); b=poly_s(b);\n        return b;\n    }\n\n    vector<int> poly_exp(const vector<int> &a)\n    {\n        int n=a.size();\n        if (n==1) return {1};\n        auto b=a; b.resize((n+1)>>1);\n        b=poly_exp(b); b.resize(n);\n        auto c=poly_sub(a,poly_ln(b)); c[0]=add(c[0],1);\n        c=poly_mul(b,c); c.resize(n);\n        return c;\n    }\n\n    vector<int> poly_sin(const vector<int> &a)\n    {\n        auto b=a;\n        for (int &i:b) i=mul(i,J);\n        auto c=poly_exp(b);\n        c=poly_sub(c,poly_inv(c));\n        int i2=inv(2),ij=inv(J);\n        for (int &i:c) i=mul(i,mul(i2,ij));\n        return c;\n    }\n\n    vector<int> poly_cos(const vector<int> &a)\n    {\n        auto b=a;\n        for (int &i:b) i=mul(i,J);\n        auto c=poly_exp(b);\n        c=poly_add(c,poly_inv(c));\n        int i2=inv(2);\n        for (int &i:c) i=mul(i,i2);\n        return c;\n    }\n\n    vector<int> poly_asin(const vector<int> &a)\n    {\n        int n=a.size();\n        auto b=poly_d(a),c=poly_mul(a,a); c.resize(n);\n        c=poly_inv(poly_sqrt(poly_sub({1},c)));\n        b=poly_mul(b,c); b.resize(n-1);\n        return poly_s(b);\n    }\n\n    vector<int> poly_atan(const vector<int> &a)\n    {\n        int n=a.size();\n        auto b=poly_d(a),c=poly_mul(a,a); c.resize(n);\n        c=poly_inv(poly_add({1},c));\n        b=poly_mul(b,c); b.resize(n-1);\n        return poly_s(b);\n    }\n}\n\nconst int N=200010;\n\nint n,a,b;\nlong long inv[N];\nlong long fac[N],invf[N];\n\nvoid linear_inv(long long n,long long p)\n{\n    inv[1]=1;\n    for (long long i=2;i<=n;i++) inv[i]=(p-p/i)*inv[p%i]%p;\n    fac[0]=1;\n    for (long long i=1;i<=n;i++) fac[i]=fac[i-1]*i%p;\n    invf[n]=NTT::inv(fac[n]);\n    for (long long i=n-1;i>=0;i--) invf[i]=invf[i+1]*(i+1)%p;\n}\n\nlong long C(long long n,long long m)\n{\n    if (m>n) return 0;\n    return NTT::mul(fac[n],NTT::mul(invf[m],invf[n-m]));\n}\n\nint main()\n{\n    linear_inv(200000,NTT::P);\n    scanf(\"%d\",&n);\n    vector<int> ans={1};\n    int l=1;\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        vector<int> f;\n        int sz=min(l+l+a-b-1,a+b+1);\n        for (int j=(a+b+1-sz)/2;j<=a+b-(a+b+1-sz)/2;j++)\n        {\n            f.push_back(C(a+b,j));\n        }\n        ans=NTT::poly_mul(ans,f);\n        l+=a-b;\n        int now=ans.size();\n        ans.erase(ans.begin(),ans.begin()+(now-l)/2);\n        ans.erase(ans.end()-(now-l)/2,ans.end());\n    }\n    int sum=0;\n    for (int i:ans)\n    {\n        sum=NTT::add(sum,i);\n    }\n    printf(\"%d\",sum);\n    getchar(); getchar();\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst uint64_t seed = std::chrono::system_clock::now().time_since_epoch().count();\nmt19937_64 rnd(seed);\nconst int MOD = 998244353;\n\n#ifdef VIPJML_LOCAL\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    os << \"{\";\n    for (typename vector<T>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << *vi;\n    }\n    os << \"}\";\n    return os;\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const vector<pair<A, B>> &v)\n{\n    os << \"{\";\n    for (typename vector<pair<A, B>>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << '(' << vi->first << \" \" << vi->second << \")\";\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p)\n{\n    os << '(' << p.first << \", \" << p.second << ')';\n    return os;\n}\n\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T)\n{\n    cerr << ' ' << H;\n    dbg_out(T...);\n}\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\nusing LL = long long;\n\nstruct Mint\n{\n    long long v;\n    Mint() : v(0) {}\n    Mint(long long t)\n    {\n        v = t % MOD;\n        if (v < 0)\n            v += MOD;\n    }\n\n    Mint pow(long long k)\n    {\n        Mint res(1), tmp(v);\n        while (k)\n        {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    Mint inv() { return pow(MOD - 2); }\n\n    Mint &operator+=(Mint a)\n    {\n        v += a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &operator-=(Mint a)\n    {\n        v += MOD - a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &operator*=(Mint a)\n    {\n        v = v * a.v % MOD;\n        return *this;\n    }\n    Mint &operator/=(Mint a) { return (*this) *= a.inv(); }\n\n    Mint operator+(Mint a) const { return Mint(v) += a; }\n    Mint operator-(Mint a) const { return Mint(v) -= a; }\n    Mint operator*(Mint a) const { return Mint(v) *= a; }\n    Mint operator/(Mint a) const { return Mint(v) /= a; }\n\n    Mint operator-() const { return v ? Mint(MOD - v) : Mint(v); }\n\n    bool operator==(const Mint a) const { return v == a.v; }\n    bool operator!=(const Mint a) const { return v != a.v; }\n    bool operator<(const Mint a) const { return v < a.v; }\n\n    static Mint comb(long long n, int k)\n    {\n        Mint num(1), dom(1);\n        for (int i = 0; i < k; i++)\n        {\n            num *= Mint(n - i);\n            dom *= Mint(i + 1);\n        }\n        return num / dom;\n    }\n\n    static Mint inv(int n)\n    {\n        return Mint(n).inv();\n    }\n\n    static vector<Mint> getInvArray(int N)\n    {\n        vector<Mint> inv(N + 1, 1);\n        for (int i = 2; i <= N; i++)\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n        return inv;\n    }\n};\n\nostream &operator<<(ostream &os, Mint m)\n{\n    os << m.v;\n    return os;\n}\n\nnamespace NTT\n{\n    const int G = 3;\n\n    vector<Mint> ntt(vector<Mint> d, bool inv = false)\n    {\n        int N = 1;\n        while (N < d.size())\n            N *= 2;\n        d.resize(N);\n        Mint base = Mint(G).pow((MOD - 1) / N);\n        if (!inv)\n        {\n            base = base.inv();\n        }\n\n        vector<Mint> pp(N + 1);\n        pp[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            pp[i] = pp[i - 1] * base;\n        }\n\n        for (int i = 0, j = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                swap(d[i], d[j]);\n            }\n            int k = N >> 1;\n            while (k <= j)\n            {\n                j -= k;\n                k >>= 1;\n            }\n            j += k;\n        }\n        for (int len = 1; len * 2 <= N; len <<= 1)\n        {\n            for (int i = 0; i + len * 2 <= N; i += len * 2)\n            {\n                int dd = N / 2 / len;\n                for (int j = 0; j < len; j++)\n                {\n                    Mint t = d[i + j + len] * pp[dd * j];\n                    d[i + j + len] = d[i + j] - t;\n                    d[i + j] += t;\n                }\n            }\n        }\n        if (inv)\n        {\n            Mint invN = Mint::inv(N);\n            for (int i = 0; i < N; i++)\n                d[i] = d[i] * invN;\n        }\n        return d;\n    }\n    vector<Mint> conv(vector<Mint> d1, vector<Mint> d2)\n    {\n        int num = d1.size() + d2.size() - 1;\n        d1.resize(num), d2.resize(num);\n        auto t1 = ntt(d1);\n        auto t2 = ntt(d2);\n        vector<Mint> tmp(t1.size());\n        for (int i = 0; i < t1.size(); i++)\n            tmp[i] = t1[i] * t2[i];\n        auto r = ntt(tmp, true);\n        r.resize(num);\n        return r;\n    }\n} // namespace NTT\n\nvoid solve(int caseNum)\n{\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    vector<Mint> r(1, 1);\n    auto inv = Mint::getInvArray(2e5);\n    vector<Mint> P(2e5 + 1, 1);\n    vector<Mint> IP(2e5 + 1, 1);\n    for (int i = 2; i < P.size(); i++)\n    {\n        P[i] = P[i - 1] * i;\n        IP[i] = IP[i - 1] * inv[i];\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        int s = max(0, b[i] - (int)r.size() + 1);\n        int e = min(a[i] + (int)r.size() - 1, a[i] + b[i]);\n        vector<Mint> x(e - s + 1);\n        for (int j = s; j <= e; j++)\n        {\n            x[j - s] = P[a[i] + b[i]] * IP[j] * IP[a[i] + b[i] - j];\n        }\n        auto t = NTT::conv(r, x);\n        int t1 = b[i] - s;\n        int t2 = min(a[i] + (int)r.size() - 1 - s, (int)t.size() - 1);\n        r.resize(t2-t1+1);\n        for (int j = t1; j <= t2;j++)\n        {\n            r[j-t1]=t[j];\n        }\n    }\n    Mint sum;\n    for (auto t : r)\n        sum += t;\n    cout << sum.v << endl;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.precision(10);\n    int T = 1;\n    //cin >> T;\n    for (int i = 1; i <= T; i++)\n    {\n        solve(i);\n    }\n    cout.flush();\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INFi = 1e9+67;\nconst ll INFll = 1e18;\n\nusing NumberType = double;\n\n//ll mod = 1e9+7;\nll mod = 998244353;\n\nnamespace std {\n    template<typename a, typename b>\n    struct hash<std::pair<a, b> > {\n    public:\n        hash() {}\n        size_t operator()(const std::pair<a, b> &p) const {\n            return hash<a>()(p.first) + hash<b>()(p.second)*998242353;\n        }\n    };\n};\n\n//integer division, correctly works with negative values\npair<ll,ll> divNorm(ll a, ll b) {\n    ll res = a/b;\n    ll mod = a%b;\n    if (mod<0) {\n        res--;\n        mod+=b;\n    }\n    return {res, mod};\n}\n\nll divRoundDown(ll a, ll b) {\n    auto divRes = divNorm(a,b);\n    return divRes.first;\n}\n\nll divRoundUp(ll a, ll b) {\n    auto divRes = divNorm(a,b);\n    ll res = divRes.first;\n    if (divRes.second) {\n        res++;\n    }\n    return res;\n}\n\nll bin_pow(ll a, ll b) {\n    ll res = 1;\n    while (b) {\n        if (b & 1) {\n            res*=a;\n            res %=mod;\n        }\n        a*=a;\n        a %= mod;\n        b>>=1;\n    }\n    return res;\n}\nll reverse(ll a) {\n    return bin_pow(a,mod-2);\n}\n\ntemplate<int mod, int root, int rootPw>\nstruct FFT {\nprivate:\n    ll mul(ll a, ll b) {\n        return (a*b) % mod;\n    }\n\n    ll bin_pow(ll a, ll b) {\n        ll res = 1;\n        while (b) {\n            if (b & 1) {\n                res = mul(res, a);\n            }\n            a = mul(a,a);\n            b>>=1;\n        }\n        return res;\n    }\n    ll reverse(ll a) {\n        return bin_pow(a,mod-2);\n    }\npublic:\n    vector<int> operator()(const vector<int>& a, int n, bool invert) {\n        assert(mod==::mod);\n        int root_1 = reverse(root);\n\n        int pow2 = 1;\n        while (pow2<n) {\n            pow2 <<= 1;\n        }\n        n = pow2;\n        vector<int> res(n, 0);\n        std::copy(a.begin(), a.end(), res.begin());\n\n\n        for (int i=1, j=0; i<n; ++i) {\n            int bit = n >> 1;\n            for (; j>=bit; bit>>=1)\n                j -= bit;\n            j += bit;\n            if (i < j)\n                swap (res[i], res[j]);\n        }\n\n        for (int len=2; len<=n; len<<=1) {\n            int wlen = invert ? root_1 : root;\n            for (int i=len; i<rootPw; i<<=1)\n                wlen = int (wlen * 1ll * wlen % mod);\n            for (int i=0; i<n; i+=len) {\n                int w = 1;\n                for (int j=0; j<len/2; ++j) {\n                    int u = res[i+j],  v = int (res[i+j+len/2] * 1ll * w % mod);\n                    res[i+j] = u+v < mod ? u+v : u+v-mod;\n                    res[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;\n                    w = int (w * 1ll * wlen % mod);\n                }\n            }\n        }\n        if (invert) {\n            int nrev = reverse (n);\n            for (int i=0; i<n; ++i)\n                res[i] = int (res[i] * 1ll * nrev % mod);\n        }\n        return res;\n    }\n};\n\nFFT<998244353, 15311432 /*3^(7*17)*/, 1<<23> fft;\n\n\nusing ld = double;\n\nconst int maxn = 3e5+7;\n//const int maxn2 = maxn*maxn;\n\n//double dp[10][maxn][maxn*maxn];\n\nll dpL[maxn][2], dpR[maxn][2];\n\nll fact[maxn], iFact[maxn];\n\nll C(ll n, ll k) {\n    if (n<0 || k<0) return 0;\n    if (n<k) return 0;\n    ll kekw = fact[n];\n    kekw = (kekw*iFact[n-k]) % mod;\n    kekw = (kekw*iFact[k]) % mod;\n    return kekw;\n}\n\nvoid solve() {\n    fact[0] = iFact[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fact[i] = (fact[i-1] * i) % mod;\n        iFact[i] = reverse(fact[i]);\n    }\n    int n;\n    cin >> n;\n    vector<ll> a(n), b(n);\n    vector<int> ans{1};\n    for (int i=0;i<n;i++) {\n        int m = ans.size();\n        cin >> a[i] >> b[i];\n        vector<int> otherToConv;\n        for (int j=b[i]-m+1;j<=b[i]+m+a[i]-b[i]-1;j++) {\n            otherToConv.push_back(C(a[i]+b[i], j));\n        }\n        int resLen = m-1 + (m+a[i]-b[i]);\n        auto image1 = fft(otherToConv, resLen, false);\n        auto image2 = fft(ans, resLen, false);\n        for (int i=0;i<image1.size();i++) {\n            image1[i] = (((ll) image1[i])*((ll) image2[i])) % mod;\n        }\n        auto out = fft(image1, resLen, true);\n        ans.clear();\n        for (int i=m-1;i<resLen;i++) {\n            ans.push_back(out[i]);\n        }\n    }\n    ll res = 0;\n    for (int i=0;i<ans.size();i++) {\n        res += ans[i];\n        res %= mod;\n    }\n    cout << res;\n\n\n}\nint main() {\n\n//        freopen(\"input.txt\",\"w\",stdout);\n//        int n = 100'000;\n//        for (int i=0;i<n;i++) {\n//            cout << 1 << \" \";\n//        }\n//        cout << \"\\n\";\n//        for (int i=1;i<n;i++) {\n//            cout << 1 << \" \" << i+1 << \"\\n\";\n//        }\n//        for (int i=0;i<n;i++) {\n//            cout << 200'000 << \" \";\n//        }\n    //    cout << 10 << \" \" << 0 << \"\\n\";\n    //    int starsLeft = 5;\n    //    for (int i=0;i<10;i++) {\n    //        for (int j=0;j<10;j++) {\n    //            int kekw = rand() % 20;\n    //            if (kekw==1 && starsLeft) {\n    //                cout << \"*\";\n    //                starsLeft--;\n    //            } else {\n    //                cout << ((char) ('0' + (rand() % 10)));\n    //            }\n    //        }\n    //        cout << \"\\n\";\n    //    }\n//        return 0;\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    // freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.bin\",\"w\",stdout);\n    //freopen(\"/tmp/output.txt\",\"w\",stdout);\n    cout << setprecision(2) << fixed;\n//    int t;\n//    cin >> t;\n//    for (int i=0;i<t;i++)\n        //    ll start = clock();\n        //    while (1)\n        solve();\n    //    double time = (clock() - start) * 1.0 / CLOCKS_PER_SEC;\n    //    cout<< time << \"s.\";\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst uint64_t seed = std::chrono::system_clock::now().time_since_epoch().count();\nmt19937_64 rnd(seed);\nconst int MOD = 998244353;\n\n#ifdef VIPJML_LOCAL\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    os << \"{\";\n    for (typename vector<T>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << *vi;\n    }\n    os << \"}\";\n    return os;\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const vector<pair<A, B>> &v)\n{\n    os << \"{\";\n    for (typename vector<pair<A, B>>::const_iterator vi = v.begin(); vi != v.end(); ++vi)\n    {\n        if (vi != v.begin())\n            os << \", \";\n        os << '(' << vi->first << \" \" << vi->second << \")\";\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p)\n{\n    os << '(' << p.first << \", \" << p.second << ')';\n    return os;\n}\n\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T)\n{\n    cerr << ' ' << H;\n    dbg_out(T...);\n}\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\nusing LL = long long;\n\nstruct Mint\n{\n    int v;\n    Mint() : v(0) {}\n    Mint(int t)\n    {\n        v = t % MOD;\n        if (v < 0)\n            v += MOD;\n    }\n\n    Mint pow(int k)\n    {\n        Mint res(1), tmp(v);\n        while (k)\n        {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    Mint inv() { return pow(MOD - 2); }\n\n    Mint &operator+=(Mint a)\n    {\n        v += a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &operator-=(Mint a)\n    {\n        v += MOD - a.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    Mint &operator*=(Mint a)\n    {\n        v = (long long)v * a.v % MOD;\n        return *this;\n    }\n    Mint &operator/=(Mint a) { return (*this) *= a.inv(); }\n\n    Mint operator+(Mint a) const { return Mint(v) += a; }\n    Mint operator-(Mint a) const { return Mint(v) -= a; }\n    Mint operator*(Mint a) const { return Mint(v) *= a; }\n    Mint operator/(Mint a) const { return Mint(v) /= a; }\n\n    Mint operator-() const { return v ? Mint(MOD - v) : Mint(v); }\n\n    bool operator==(const Mint a) const { return v == a.v; }\n    bool operator!=(const Mint a) const { return v != a.v; }\n    bool operator<(const Mint a) const { return v < a.v; }\n\n    static Mint comb(long long n, int k)\n    {\n        Mint num(1), dom(1);\n        for (int i = 0; i < k; i++)\n        {\n            num *= Mint(n - i);\n            dom *= Mint(i + 1);\n        }\n        return num / dom;\n    }\n\n    static Mint inv(int n)\n    {\n        return Mint(n).inv();\n    }\n\n    static vector<Mint> getInvArray(int N)\n    {\n        vector<Mint> inv(N + 1, 1);\n        for (int i = 2; i <= N; i++)\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n        return inv;\n    }\n};\n\nostream &operator<<(ostream &os, Mint m)\n{\n    os << m.v;\n    return os;\n}\n\nnamespace NTT\n{\n    const int G = 3;\n\n    vector<Mint> ntt(vector<Mint> d, bool inv = false)\n    {\n        int N = 1;\n        while (N < d.size())\n            N *= 2;\n        d.resize(N);\n        Mint base = Mint(G).pow((MOD - 1) / N);\n        if (!inv)\n        {\n            base = base.inv();\n        }\n\n        vector<Mint> pp(N + 1);\n        pp[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            pp[i] = pp[i - 1] * base;\n        }\n\n        for (int i = 0, j = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                swap(d[i], d[j]);\n            }\n            int k = N >> 1;\n            while (k <= j)\n            {\n                j -= k;\n                k >>= 1;\n            }\n            j += k;\n        }\n        for (int len = 1; len * 2 <= N; len <<= 1)\n        {\n            for (int i = 0; i + len * 2 <= N; i += len * 2)\n            {\n                int dd = N / 2 / len;\n                for (int j = 0; j < len; j++)\n                {\n                    Mint t = d[i + j + len] * pp[dd * j];\n                    d[i + j + len] = d[i + j] - t;\n                    d[i + j] += t;\n                }\n            }\n        }\n        if (inv)\n        {\n            Mint invN = Mint::inv(N);\n            for (int i = 0; i < N; i++)\n                d[i] = d[i] * invN;\n        }\n        return d;\n    }\n    vector<Mint> conv(vector<Mint> d1, vector<Mint> d2)\n    {\n        int num = d1.size() + d2.size() - 1;\n        d1.resize(num), d2.resize(num);\n        auto t1 = ntt(d1);\n        auto t2 = ntt(d2);\n        vector<Mint> tmp(t1.size());\n        for (int i = 0; i < t1.size(); i++)\n            tmp[i] = t1[i] * t2[i];\n        auto r = ntt(tmp, true);\n        r.resize(num);\n        return r;\n    }\n} // namespace NTT\n\nvoid solve(int caseNum)\n{\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i] >> b[i];\n    vector<Mint> r(1, 1);\n    auto inv = Mint::getInvArray(2e5);\n    vector<Mint> P(2e5 + 1, 1);\n    vector<Mint> IP(2e5 + 1, 1);\n    for (int i = 2; i < P.size(); i++)\n    {\n        P[i] = P[i - 1] * i;\n        IP[i] = IP[i - 1] * inv[i];\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        int s = max(0, b[i] - (int)r.size() + 1);\n        int e = min(a[i] + (int)r.size() - 1, a[i] + b[i]);\n        vector<Mint> x(e - s + 1);\n        for (int j = s; j <= e; j++)\n        {\n            x[j - s] = P[a[i] + b[i]] * IP[j] * IP[a[i] + b[i] - j];\n        }\n        auto t = NTT::conv(r, x);\n        int t1 = b[i] - s;\n        int t2 = min(a[i] + (int)r.size() - 1 - s, (int)t.size() - 1);\n        r.resize(t2-t1+1);\n        for (int j = t1; j <= t2;j++)\n        {\n            r[j-t1]=t[j];\n        }\n    }\n    Mint sum;\n    for (auto t : r)\n        sum += t;\n    cout << sum.v << endl;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.precision(10);\n    int T = 1;\n    //cin >> T;\n    for (int i = 1; i <= T; i++)\n    {\n        solve(i);\n    }\n    cout.flush();\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint quick_power(int a,int b,int Mod){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tans=1ll*ans*a%Mod;\n\t\t}\n\t\tb>>=1;\n\t\ta=1ll*a*a%Mod;\n\t}\n\treturn ans;\n}\nconst int Mod=998244353;\nconst int Maxn=20000;\nconst int Maxm=200000;\nconst int G=3;\nvoid NTT(int *a,int flag,int n){\n\tstatic int R[Maxn+5],last_len;\n\tint len=1,L=0;\n\twhile(len<n){\n\t\tlen<<=1;\n\t\tL++;\n\t}\n\tif(last_len!=len){\n\t\tlast_len=len;\n\t\tfor(int i=0;i<len;i++){\n\t\t\tR[i]=(R[i>>1]>>1)|((i&1)<<(L-1));\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tif(i<R[i]){\n\t\t\tswap(a[i],a[R[i]]);\n\t\t}\n\t}\n\tfor(int j=1;j<len;j<<=1){\n\t\tint T=quick_power(G,(Mod-1)/(j<<1),Mod);\n\t\tfor(int k=0;k<len;k+=(j<<1)){\n\t\t\tfor(int l=0,t=1;l<j;l++,t=1ll*t*T%Mod){\n\t\t\t\tint Nx=a[k+l],Ny=1ll*t*a[j+k+l]%Mod;\n\t\t\t\ta[k+l]=(Nx+Ny)%Mod;\n\t\t\t\ta[j+k+l]=(Nx-Ny+Mod)%Mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==-1){\n\t\treverse(a+1,a+len);\n\t\tfor(int i=0,t=quick_power(len,Mod-2,Mod);i<len;i++){\n\t\t\ta[i]=1ll*a[i]*t%Mod;\n\t\t}\n\t}\n}\nint frac[Maxm+5],inv_f[Maxm+5];\nvoid init(){\n\tfrac[0]=1;\n\tfor(int i=1;i<=Maxm;i++){\n\t\tfrac[i]=1ll*frac[i-1]*i%Mod;\n\t}\n\tinv_f[Maxm]=quick_power(frac[Maxm],Mod-2,Mod);\n\tfor(int i=Maxm-1;i>=0;i--){\n\t\tinv_f[i]=1ll*inv_f[i+1]*(i+1)%Mod;\n\t}\n}\nint C(int n,int m){\n\treturn 1ll*frac[n]*inv_f[m]%Mod*inv_f[n-m]%Mod;\n}\nvoid mul(int *a,int a_len,int *b,int b_len,int *c){\n\tstatic int A[Maxn+5],B[Maxn+5];\n\tfor(int i=0;i<a_len;i++){\n\t\tA[i]=a[i];\n\t}\n\tfor(int i=0;i<b_len;i++){\n\t\tB[i]=b[i];\n\t}\n\tint len=1;\n\twhile(len<(a_len+b_len-1)){\n\t\tlen<<=1;\n\t}\n\tfor(int i=a_len;i<len;i++){\n\t\tA[i]=0;\n\t}\n\tfor(int i=b_len;i<len;i++){\n\t\tB[i]=0;\n\t}\n\tNTT(A,1,len);\n\tNTT(B,1,len);\n\tfor(int i=0;i<len;i++){\n\t\tA[i]=1ll*A[i]*B[i]%Mod;\n\t}\n\tNTT(A,-1,len);\n\tfor(int i=0;i<a_len+b_len-1;i++){\n\t\tc[i]=A[i];\n\t}\n}\nint A[Maxn+5],B[Maxn+5],tmp[Maxn+5];\nint a_len,b_len,c_len;\nint main(){\n\tinit();\n\tint n;\n\tscanf(\"%d\",&n);\n\ta_len=1;\n\tA[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tb_len=(a_len<<1)+20;\n\t\tfor(int i=0;i<b_len;i++){\n\t\t\tB[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b_len;i++){\n\t\t\tint id=i-(a_len+10)+b;\n\t\t\tB[i]=C(a+b,id);\n\t\t}\n\t\tmul(A,a_len,B,b_len,A);\n\t\tfor(int i=0;i<a_len+a-b;i++){\n\t\t\ttmp[i]=0;\n\t\t}\n\t\tfor(int i=0;i<a_len+b_len-1;i++){\n\t\t\tint id=(i-(a_len+10));\n\t\t\tif(id>=0&&id<a_len+a-b){\n\t\t\t\ttmp[id]=A[i];\n\t\t\t}\n\t\t}\n\t\ta_len+=a-b;\n\t\tfor(int i=0;i<a_len;i++){\n\t\t\tA[i]=tmp[i];\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<a_len;i++){\n\t\tans=(ans+A[i])%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pii pair<int, int>\n#define fir first\n#define sec second\n#define pb emplace_back\n\n#define gc() getchar()\ninline int read()\n{\n    int now=0,f=1; char c=gc();\n    for(;!isdigit(c);c=='-'&&(f=-1),c=gc());\n    for(;isdigit(c);now=now*10+c-48,c=gc());\n    return now*f;\n}\n\nconst int mod = 998244353;\ninline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}\ninline int sub(int a,int b){return a<b? a-b+mod: a-b;}\ninline int mul(int a,int b){return 1LL*a*b%mod;}\nint qpow(int a,int b){\n    int ret=1;\n    for(; b; b>>=1){\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a);\n    }\n    return ret;\n}\n\nconst int D = 2e5+10;\nconst int G = 3;\nint wn[D<<4], rev[D<<4];\nint NTT_init(int pn){\n    int step=0; int n = 1;\n    for(; n<pn; n<<=1) ++step;\n    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));\n    int g = qpow(G,(mod-1)/n);\n    wn[0] = 1;\n    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);\n    return n;\n}\nvoid NTT(int a[],int n,int f){\n    for(int i=0; i<n; i++){\n        if(i<rev[i]) swap(a[i], a[rev[i]]);\n    }\n    for(int k=1; k<n; k<<=1){\n        for(int i=0; i<n; i+=(k<<1)){\n            int t = n/(k<<1);\n            for(int j=0; j<k; j++){\n                int w = (f==1)? wn[t*j]: wn[n-t*j];\n                int x = a[i+j];\n                int y = mul(a[i+j+k], w);\n                a[i+j] = add(x, y);\n                a[i+j+k] = sub(x, y);\n            }\n        }\n    }\n    if(f == -1){\n        int ninv = qpow(n, mod-2);\n        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);\n    }\n}\n\nconst int M = 1e6+10;\nint fac[M], inv[M], ifac[M];\nvoid init(int n){\n    fac[0]=1;for(int i=1; i<=n; i++)fac[i]=mul(fac[i-1],i);\n    inv[1]=1;for(int i=2; i<=n; i++)inv[i]=mul(sub(mod,mod/i),inv[mod%i]);\n    ifac[0]=1;for(int i=1; i<=n; i++)ifac[i]=mul(ifac[i-1],inv[i]);\n}\nint C(int n,int m){\n    return (m<0||m>n)? 0: mul(fac[n], mul(ifac[m],ifac[n-m]));\n}\nconst int N = 5e3+10;\nint a[N], b[N];\nint x[D]{0}, y[D]{0}, ans[D]{0};\nint main(){\n    int n=read();\n    for(int i=1; i<=n; i++){\n        a[i]=read(); b[i]=read();\n    }\n    init(M-1);\n    int m=1; ans[0]=1;\n    for(int i=1; i<=n; i++){\n        int n_m=m+a[i]-b[i];\n        for(int j=0; j<m; j++) x[m+j]=ans[j];\n        for(int j=max(-b[i],-m); j<=min(a[i],n_m); j++) y[m+j]=C(a[i]+b[i],b[i]+j);\n        //cout<<\"x:\";for(int j=0; j<10; j++) cout<<x[j]<<' '; cout<<endl;\n        //cout<<\"y:\";for(int j=0; j<10; j++) cout<<y[j]<<' '; cout<<endl;\n        int len = NTT_init(4*(m+5));\n        //cout<<len<<endl;\n        NTT(x,len,1);\n        NTT(y,len,1);\n        for(int j=0; j<=len; j++) x[j]=mul(x[j],y[j]);\n        NTT(x,len,-1);\n        NTT(y,len,-1);\n        //cout<<\"after_x:\"; for(int j=0; j<10; j++) cout<<x[j]<<' '; cout<<endl;\n        for(int j=0; j<m+10; j++) ans[j]=0;\n        for(int j=0; j<n_m; j++) ans[j]=x[2*m+j];\n        //for(int j=0; j<n_m; j++) cout<<ans[j]<<' '; cout<<endl;\n        for(int j=0; j<=len; j++) x[j]=y[j]=0;\n        m=n_m;\n    }\n    int sum=0;\n    for(int i=0; i<m; i++) sum=add(sum,ans[i]);\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define ll long long\n#define p pair<int, int>\n#define endl '\\n'\nconst int INF = 1000000001;using namespace std;const int C = 998244353;vector<ll> fact, minus_fact;\nll pow1(ll x, ll y, ll z=C){if (y == 0)return 1;if (y % 2 == 0)return pow1(x*x % z, y/2, z);return pow1(x, y-1, z)*x % z;}\nvoid facts(int n){fact = {1}, minus_fact = {1};for (int q = 1; q <= n; q++){fact.push_back(fact.back()*q % C);minus_fact.push_back(minus_fact.back()*pow1(q, C-2) % C);}}\nll c(int k, int n){if (k < 0 || k > n)return 0;return fact[n]*minus_fact[k] % C*minus_fact[n-k] % C;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    facts(200179);\n    int n;\n    cin >> n;\n    vector<p> a(n);\n    for (int q = 0; q < n; q++){\n        cin >> a[q].first >> a[q].second;\n    }\n    vector<int> now = {1};\n    for (int q = 0; q < n; q++){\n        int w3 = (now.size()+a[q].first+a[q].second+1)/2, w4 = now.size()+a[q].first+a[q].second;\n        vector<__int128> will(w3-a[q].second, 0);\n        vector<ll> cc(now.size()+a[q].first);\n        for (int q1 = 0; q1 < cc.size(); q1++){\n            cc[q1] = c(q1, a[q].first+a[q].second);\n        }\n        for (int q1 = a[q].second; q1 < w3; q1++){\n            int w = min(q1+1, (int)now.size()), w1 = q1-a[q].second, w2 = max(0, q1-a[q].first-a[q].second);\n            for (int q2 = w2; q2 < w; q2++){\n                will[w1] += cc[q1-q2]*now[q2];\n            }\n        }\n        now = {};\n        for (__int128 q1: will){\n            now.push_back(q1 % C);\n        }\n        for (int q1 = (int)now.size()-1-w4 % 2; q1 > -1; q1--){\n            now.push_back(now[q1]);\n        }\n    }\n    ll ans = 0;\n    for (int q: now){\n        ans += q;\n    }\n    cout << ans % C << endl;\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mod 998244353\n#define poly vector<int>\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=5e5+11;\nint flip[MAXN];\nint mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y>=0?x-y:x-y+mod;}\nint ksm(int a,int b){int ans=1;while(b){if(b&1) ans=mul(ans,a);a=mul(a,a);b>>=1;}return ans;}\nvoid print(poly a){for(auto v:a) printf(\"%d \",v);printf(\"\\n\");return;}\nvoid NTT(poly &f,int opt,int Len){\n    for(int i=0;i<Len;i++) if(i<flip[i]) swap(f[i],f[flip[i]]);\n    for(int p=2;p<=Len;p<<=1){\n        int len=(p>>1),buf=ksm(3,(mod-1)/p); if(opt==-1) buf=ksm(buf,mod-2);\n        for(int be=0;be<Len;be+=p){\n            int tmp=1;\n            for(int l=be;l<be+len;l++){\n                int t=mul(f[l+len],tmp);\n                f[l+len]=sub(f[l],t),f[l]=add(f[l],t);\n                tmp=mul(tmp,buf);\n            }\n        }\n    }\n    if(opt==-1){\n        int Inv=ksm(Len,mod-2); for(int i=0;i<Len;i++) f[i]=mul(f[i],Inv);\n    }return;\n}\nint setN(int siz){\n    int cur=1; while(cur<=siz) cur<<=1;\n    for(int i=1;i<cur;i++) flip[i]=((flip[i>>1]>>1)|(i&1?cur>>1:0));\n    return cur;\n}\npoly operator*(poly a,poly b){\n    int len=a.size()+b.size()-1; int cur=setN(len);\n    a.resize(cur),b.resize(cur);\n    for(int i=1;i<cur;i++) flip[i]=(flip[i>>1]>>1|(i&1?cur>>1:0));\n    NTT(a,1,cur),NTT(b,1,cur);\n    for(int i=0;i<cur;i++) a[i]=mul(a[i],b[i]);\n    NTT(a,-1,cur); a.resize(len);\n    return a;\n}\nint fac[MAXN],ifac[MAXN],inv[MAXN],N; poly f;\nsigned main(){\n    //freopen(\"B.in\",\"r\",stdin);\n    fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n    for(int i=2;i<MAXN;i++) fac[i]=mul(fac[i-1],i),inv[i]=mul((mod-mod/i),inv[mod%i]),ifac[i]=mul(ifac[i-1],inv[i]);\n    f.pb(0),f.pb(1); N=read();\n    while(N--){\n        int a=read(),b=read(); int Maxj=a-b+f.size()-1,Maxk=f.size()-1;\n        poly g; g.clear();\n        int X=INT_MAX;\n        for(int i=1-Maxk;i<=Maxj-1;i++){\n            if(a-i>=0&&b+i>=0){\n                if(X==INT_MAX) X=i;g.pb(mul(ifac[b+i],ifac[a-i]));\n            }\n        }\n        f=f*g;\n        for(int i=0;i<f.size();i++) f[i]=mul(f[i],fac[a+b]);\n        poly F; F.clear();\n        for(int i=0;i<f.size();i++){\n            if(X>=0&&X<=Maxj) F.pb(f[i]);\n            X++;\n        }\n        f=F; f[0]=0;\n        //print(f);\n    } int Ans=0; for(auto v:f) Ans=add(Ans,v);\n    printf(\"%d\\n\",Ans);return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\n//#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n#include <tuple>\n#include <memory>\n#include <random>\n#include <chrono>\n#include <sstream>\n\n#include <iterator>\n\n#define ull unsigned long long\n#define ll long long\n\n#define all(vec) vec.begin(), vec.end()\n#define pb push_back\n#define FOR(i,a,b) for(int i = a; i < b; ++i)\n#define printvec(vec) for(auto el: vec) {cout << el << \" \";}\n\nconstexpr long long INF = 200000000000000001LL;\nconstexpr int INF32 = 2100000001;\nsize_t seed42 = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 rng(seed42);\nstd::uniform_int_distribution<int> unidistrib;\nint randint() {return unidistrib(rng);}\n\nusing namespace std;\null modulo = 998244353 ;  // 1+7*17*2^23.\n//ull modulo = 1000000007 ;\nint modulo32 = 998244353;\n\null poww(ull x, ull n) {\n    if (n == 0)\n        return 1;\n    ull answ = poww(x, n/2);\n    answ = (answ * answ) % modulo;\n    if (n%2)\n        answ = (answ * x) % modulo;\n    return answ;\n}\n\npair<int, int> operator+ (const pair<int, int>& lhs, pair<int, int>& rhs) {\n    return {lhs.first +rhs.first, lhs.second + rhs.second};\n}\n\ntemplate <class T>\nostream& operator << (ostream& lhs, pair<T, T>& rhs) {\n    return (lhs << rhs.first<<\":\" << rhs.second);\n}\n\nvector<int> r;\n\nvector<int> fft(vector<int>& a, bool inv = false) {\n    size_t n = a.size();\n\n    //vector<int> r(n);\n    r.resize(n);\n    for (size_t k = 0; k < n; k++) {\n        size_t b = 0;\n        for (size_t z = 1; z < n; z *= 2) {\n            b *= 2;\n            if (k&z) ++b;\n        }\n        r[b] = a[k];\n    }\n    ull wm;\n\n    for (int m = 2; m <= n; m *= 2) {\n        if (!inv)\n            wm = poww(5ULL, (119ULL<<23)/m);\n        else\n            wm = poww(5ULL, (((119ULL<<23)/m) * (modulo-2))%(modulo-1));\n\n        for (int k = 0; k < n; k += m) {\n            ull w = 1;\n            for (int j = 0; j < m/2; j++) {\n                int u = r[k+j];\n                int t = (w*r[k+j+m/2])%modulo;\n                r[k+j] = (u+t)%modulo32;\n                r[k+j+m/2] = (u + modulo32 - t) % modulo32;\n                w = (w*wm)%modulo;\n            }\n        }\n    }\n    if (inv) {\n        ull ninv = poww(n, modulo-2);\n        for (int i = 0; i < n; i++)\n            r[i] = (ninv*r[i])%modulo;\n    }\n    return r;\n}\n\n\n\n\nint main() {\n    #ifdef DARTH\n    std::ifstream filestream(\"input.txt\");\n    std::cin.rdbuf(filestream.rdbuf());\n    #else\n    ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    #endif //DARTH\n\n    vector<ull> facc(200002,1), invfac(200002,1);\n    for(ull i = 2; i <= 200001; ++i) {\n        facc[i] = (i * facc[i-1]) % modulo;\n        invfac[i] = poww(facc[i], modulo-2);\n    }\n\n\n    auto Cnk = [&](int n, int k) {\n        if (k<0 || k> n)\n            return 0ULL;\n        return (((facc[n] * invfac[k]) % modulo) * invfac[n-k])%modulo;\n    };\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    FOR(i,0,n) {\n        cin >> a[i] >> b[i];\n    }\n\n\n    int maxsz = 1 << 14;\n    vector<int> answ (1, 1);\n    vector<int> cnk;\n    answ.reserve(1<<14);\n    cnk.reserve(1<<14);\n    r.reserve(1<<14);\n    //vector<ull> tmp(1<<14);\n\n    answ[0] = 1;\n    ull m = 1;\n\n    for(int i = 0; i < n; ++i) {\n        int maxj = 2 * m + a[i] - b[i];\n        //int maxjj =  2 *m + max(a[i] - b[i], 0);\n        int maxjpow2 = 1;\n        while (maxjpow2 < maxj)\n            maxjpow2<<=1;\n        answ.resize(maxjpow2, 0ULL);\n        cnk.resize(maxjpow2, 0ULL);\n\n        for (int jplusm = 0; jplusm < maxj; ++jplusm) {\n            cnk[jplusm] = Cnk(a[i] + b[i], b[i] + jplusm - m);\n            //cout << a[i] + b[i] - j << \" a[i] + b[i] - j\" <<  k << \"=\" << cnk[k] << \" \";\n        }\n\n        fill(cnk.begin()+maxj, cnk.end(), 0);\n\n        answ = fft(answ);\n        cnk = fft(cnk);\n\n        for (int j = 0; j < answ.size(); ++j) {\n            answ[j] = (answ[j]*1ULL*cnk[j]) % modulo;\n        }\n\n        answ = fft(answ, true);\n        copy(answ.begin() + m, answ.begin() + maxj, answ.begin());\n\n\n        m = m + a[i] - b[i];\n        fill(answ.begin() + m, answ.end(), 0);\n    }\n\n\n    cout  << (accumulate(answ.begin(), answ.begin()+m, 0ULL)) % modulo;\n    //cout << answ[3];\n    //printvec(answ);\n    return 0;\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e5+5,p=998244353,g=3,gv=(p+1)/3;\nint n,m,rev[N];\nll fc[N],fv[N],iv[N],F[N],G[N],FF[N];\nll qpow(ll a,int b)\n{ll ret=1;while(b){if(b&1)ret=ret*a%p;a=a*a%p;b>>=1;}return ret;}\nll inv(ll a){return qpow(a,p-2);}\nvoid getrev(int len)\n{for(int i=0;i<len;i++){rev[i]=rev[i>>1]>>1;if(i&1)rev[i]|=len>>1;}}\nvoid ntt(ll *f,int len,int tp){\n    getrev(len);\n    for(int i=0;i<len;i++)if(i<rev[i])swap(f[i],f[rev[i]]);\n    for(int i=2;i<=len;i<<=1){\n        int stp=i>>1;ll wn=qpow(tp==1?g:gv,(p-1)/i);\n        for(int j=0;j<len;j+=i){\n            ll w=1;\n            for(int k=j;k<j+stp;k++){\n                ll s1=f[k],s2=f[k+stp]*w%p;w=w*wn%p;\n                f[k]=(s1+s2)%p,f[k+stp]=(s1-s2+p)%p;\n            }\n        }\n    }\n    if(tp==-1){ll lv=inv(len);for(int i=0;i<len;i++)f[i]=f[i]*lv%p;}\n}\nint main(){\n    scanf(\"%d\",&n);\n    m=1;F[1]=1;\n    fc[0]=fc[1]=fv[0]=fv[1]=iv[1]=1;\n    for(int i=2;i<=N-5;i++)fc[i]=fc[i-1]*i%p,\n        iv[i]=(p-p/i)*iv[p%i]%p,fv[i]=fv[i-1]*iv[i]%p;\n    for(int i=1;i<=n;i++){\n        int a,b,m1=m;scanf(\"%d%d\",&a,&b);m+=a-b;\n        int len=1;while(len<=(m1*2+m+1))len<<=1;\n        for(int j=-m1;j<=m;j++)\n            if(b+j>=0&&a-j>=0)G[j+m1]=fv[b+j]*fv[a-j]%p;\n            else G[j+m1]=0;\n        for(int j=m+m1+1;j<len;j++)G[j]=0;\n        for(int j=1;j<=m1;j++)FF[j]=F[j];FF[0]=0;\n        for(int j=m1+1;j<len;j++)FF[j]=0;\n        //for(int j=0;j<len;j++)cout<<G[j]<<\" \";cout<<endl;\n        //for(int j=0;j<len;j++)cout<<FF[j]<<\" \";cout<<endl;cout<<endl;\n        ntt(G,len,1),ntt(FF,len,1);\n        for(int j=0;j<len;j++)F[j]=FF[j]*G[j]%p;\n        ntt(F,len,-1);\n        for(int j=1;j<=m;j++)F[j]=F[j+m1]*fc[a+b]%p;\n        for(int j=m+1;j<len;j++)F[j]=0;F[0]=0;\n        //for(int j=0;j<len;j++)cout<<F[j]<<\" \";cout<<endl;cout<<endl;\n    }\n    ll ans=0;for(int i=1;i<=m;i++)ans=(ans+F[i])%p;\n    printf(\"%lld\\n\",ans);\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+5;\nconst int G = 3;\nconst int mod = 998244353;\n\nint fac[N],rev[N];\n\nint qpow(int a,int b){\n\tint r=1;\n\twhile(b){\n\t\tif(b&1)r=1ll*r*a%mod;\n\t\tb>>=1;a=1ll*a*a%mod; \n\t}\n\treturn r;\n}\n\nstruct NTT{\n\tint n,m,rev[N<<1];\n\tint a[N<<1],b[N<<1];\n\t\n\tvoid init(int len){\n\t\tfor(n=1,m=0;n<=len;n<<=1,m++);\n\t\tfor(int i=0;i<n;++i){\n\t\t\trev[i]=rev[i>>1]>>1|(1&i)<<(m-1);\n\t\t\ta[i]=b[i]=0;\n\t\t}\n\t}\n\t\n\tvoid FFT(int *a,int f){\n\t\tfor(int i=0;i<n;++i)if(i<rev[i])swap(a[i],a[rev[i]]);\n\t\tfor(int i=1;i<n;i<<=1){\n\t\t\tint wn=qpow(G,(mod-1)/(i<<1));\n\t\t\tif(f==-1)wn=qpow(wn,mod-2);\n\t\t\tfor(int j=0;j<n;j+=i<<1){\n\t\t\t\tint w=1;\n\t\t\t\tfor(int k=0;k<i;++k,w=1ll*w*wn%mod){\n\t\t\t\t\tint x=a[j+k],y=1ll*a[j+k+i]*w%mod;\n\t\t\t\t\ta[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tif(f==-1){\n\t\t\tint rn=qpow(n,mod-2);\n\t\t\tfor(int i=0;i<n;++i)a[i]=1ll*a[i]*rn%mod;\n\t\t}\n\t}\n\t\n\tvoid work(){\n\t\tFFT(a,1);FFT(b,1);\n\t\tfor(int i=0;i<n;++i)a[i]=1ll*a[i]*b[i]%mod;\n\t\tFFT(a,-1);\n\t}\n}B;\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\trev[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;~i;--i)rev[i]=1ll*rev[i+1]*(i+1)%mod;\n}\n\nint C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\n\nint n,ans[N];\n\nint main(){\n\tinit();\n\tcin>>n;\n\tint len=0;\n\tans[0]=1;\n\tfor(int i=1,a,b;i<=n;++i){\n\t\tcin>>a>>b;\n\t\tB.init(2*len+a-b);\n\t\tfor(int k=-len;k<=len+a-b;++k)B.a[k+len]=C(a+b,b+k);\n\t\tfor(int j=0;j<=len;++j)B.b[j]=ans[j];\n\t\tB.work();\n//\t\tfor(int k=-len;k<=len+a-b;++k){\n//\t\t\tfor(int j=0;j<=len;++j){\n//\t\t\t\tif(j+k>=0)(nex[j+k]+=C(a+b,b+k)*ans[j])%=mod;\n//\t\t\t}\n//\t\t}\n\t\tfor(int k=0;k<=len+a-b;++k){\n\t\t\tans[k]=B.a[k+len];\n\t\t}\n\t\tlen+=a-b;\n\t}\n\tint res=0;\n\tfor(int i=0;i<=len;++i)(res+=ans[i])%=mod;\n\tcout<<res<<endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing base = ll;//complex<double>;\nconst ll mod = 998244353;\nll mexp(ll x, ll y) {\n    ll r = 1;\n    for(;y;x=x*x%mod, y>>=1) if(y & 1) r = r * x % mod;\n    return r;\n}\nll modd(ll x) {\n    if(x >= mod) x -= mod;\n    if(x < 0) x += mod;\n    return x;\n}\nbase roots[1<<20];\nvoid fft(vector<base>& a, bool inv) {\n    int n = a.size(), j = 0;\n    for(int i=1;i<n;i++) {\n        int bit = (n >> 1);\n        while(j >= bit) {\n            j -= bit;\n            bit >>= 1;\n        }\n        j += bit;\n        if(i < j) swap(a[i], a[j]);\n    }\n    // In NTT, let prr = primitive root. Then,\n    int prr = 3;\n    ll ang = mexp(prr, (mod - 1) / n);\n    if(inv) ang = mexp(ang, mod - 2);\n    roots[0] = 1;\n    for(int i=1; i<n/2; i++){\n        roots[i] = roots[i-1] * ang % mod;\n    }\n    //also, make sure to apply modulus under here\n    for(int i=2;i<=n;i<<=1) {\n        int step = n / i;\n        for(int j=0;j<n;j+=i) {\n            for(int k=0;k<i/2;k++) {\n                base u = a[j+k], v = a[j+k+i/2] * roots[step * k] % mod;\n                a[j+k] = modd(u+v);\n                a[j+k+i/2] = modd(u-v+mod);\n            }\n        }\n    }\n    if(inv) for(int i=0;i<n;i++) a[i] = a[i] * mexp(n, mod-2) % mod;\n}\nvoid conv(vector<base>& x, vector<base>& y) {\n    int n = 2; while(n < x.size()+y.size()) n <<= 1;\n    x.resize(n), y.resize(n);\n    fft(x, false); fft(y, false);\n    for(int i=0;i<n;i++) x[i] = x[i] * y[i] % mod;\n    fft(x, true);\n}\nconst int lim = 222222;\nll f[lim], fi[lim];\nvector<base> ans, mul, nans;\nint n;\nll binom(int a, int b) {\n    if(b < 0 || b > a) return 0;\n    return f[a] * fi[b] % mod * fi[a-b] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n;\n    ans.reserve(1<<16);\n    mul.reserve(1<<16);\n    f[0] = 1;\n    for(int i=1;i<lim;i++)\n        f[i] = i * f[i-1] % mod;\n    fi[lim-1] = mexp(f[lim-1], mod-2);\n    for(int i=lim-2;i>=0;i--)\n        fi[i] = (i+1) * fi[i+1] % mod;\n    ans.push_back(1);\n    for(int i=0;i<n;i++) {\n        int a, b;\n        cin >> a >> b;\n        int m = ans.size();\n        int m1 = 2 * m + a - b - 1;\n        for(int j=0;j<m1;j++)\n            mul.emplace_back(binom(a+b, b+j-(m-1)));\n        conv(ans, mul);\n        nans.clear(); nans.resize(m+a-b);\n        for(int i=0;i<m+a-b;i++) nans[i] = ans[m-1+i];\n        ans = nans;\n        mul.clear();\n    }\n    cout << accumulate(ans.begin(), ans.end(), 0LL) % mod;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nconst int N=1<<20;\nint jie[N],inv[N],A[N],B[N],w[N],invw[N],len,pos[N],f[N],g[N];\ninline int mul(const int &a,const int &b){return 1ll*a*b%mod;}\ninline int add(int a,const int &b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,const int &b){a-=b;return a<0?a+mod:a;}\nll quick(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid INI(){\n\tjie[0]=1;\n\tinv[0]=inv[1]=1;\n\trep(i,2,N)inv[i]=-1ll*mod/i*inv[mod%i]%mod+mod;\n\trep(i,1,N){\n\t\tjie[i]=mul(jie[i-1],i);\n\t\tinv[i]=mul(inv[i],inv[i-1]);\n\t}\n\tint G=quick(3,(mod-1)/N),IG=quick(G,mod-2);f[0]=g[0]=1;\n\trep(i,1,N)f[i]=mul(f[i-1],G),g[i]=mul(g[i-1],IG);\n}\ninline void init(){\n\tint op=len>>1,k=N/len;\n\tfor(int i=0,j=0;i<len;++i,j+=k){\n\t\tw[i]=f[j];invw[i]=g[j];\n\t\tpos[i]=pos[i>>1]>>1|(i&1?op:0);\n\t}\n}\ninline void NTT(int *a,int *omg){\n\trep(i,0,len)if(i<pos[i])swap(a[i],a[pos[i]]);\n\tfor(int i=2;i<=len;i<<=1){\n\t\tint m=i>>1;\n\t\tfor(int *p=a;p!=a+len;p+=i){\n\t\t\trep(j,0,m){\n\t\t\t\tint t=mul(omg[len/i*j],p[j+m]);\n\t\t\t\tp[j+m]=sub(p[j],t);\n\t\t\t\tp[j]=add(p[j],t);\n\t\t\t}\n\t\t}\n\t}\n}\nint C(int n,int m){\n\tif(n<0||m<0||m>n)return 0;\n\treturn mul(mul(jie[n],inv[m]),inv[n-m]);\n}\nint main(){\n\tINI();\n\tint n,L=1;\n\tscanf(\"%d\",&n);\t\n\tlen=1<<14;\n\tinit();\n\tA[0]=1;\n\twhile(n--){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint nL=L+a-b,j,k;\n\t\tfor(j=b-L+1,k=0;a+b-j>=b-L+1;++j,++k){\n\t\t\tB[k]=C(a+b,j);\n\t\t}\n\t\tfor(;k<len;++k)B[k]=0;\n\t\trep(i,L,len)A[i]=0;\n\t//\trep(i,0,L)cout<<A[i]<<' ';\n\t//\tcout<<\"iniA\\n\";\n\t\tNTT(A,w),NTT(B,w);\n\t\trep(i,0,len)B[i]=mul(B[i],A[i]);NTT(B,invw);\n\t\tint inv=quick(len,mod-2);\n\t//\n\t//\tcout<<\"ans\\n\";\n\t\trep(i,0,nL)A[i]=mul(B[i+L-1],inv);\n\t//\tcout<<nL<<\"L\\n\";\n\t//\trep(i,0,nL)cout<<A[i]<<' ';\n\t//\tcout<<\"A\\n\";\n\t\tL=nL;\n\t}\n\tint ans=0;\n\trep(i,0,L)ans=add(ans,A[i]);\n\tprintf(\"%d\\n\",ans);\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n\nusing namespace std;\n\nconst int MOD=998244353, PR=3;\nvector<int> X, Y;\nint F[300001], Finv[300001];\n\nint mul(int a, int b) {return 1LL*a*b%MOD;}\n\nint fast_pow(int a, int b)\n{\n    int ret=1;\n    for(;b;b>>=1) {\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a);\n    }\n    return ret;\n}\n\nvoid FFT(vector<int> &A,bool inv)\n{\n\tint N=A.size();\n    stack<int> S;\n\tfor(int i=0;i<N;i++) {\n\t\tint j=0;\n\t\tfor(int b=1;b<N;b<<=1) {\n\t\t\tj<<=1;\n\t\t\tif(b&i) j|=1;\n\t\t}\n\t\tif(i<j) swap(A[i],A[j]);\n\t}\n    S.push(fast_pow(inv ? fast_pow(PR,MOD-2):PR,MOD/N));\n    for(int i=2;i<N;i<<=1) S.push(mul(S.top(),S.top()));\n\tfor(int i=1;i<N;i<<=1) {\n        int w=S.top();\n        S.pop();\n\t\tfor(int j=0;j<N;j+=i<<1) {\n\t\t\tint th=1;\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tint temp=mul(A[i+j+k],th);\n\t\t\t\tA[i+j+k]=A[j+k]-temp;\n                if(A[i+j+k]<0) A[i+j+k]+=MOD;\n\t\t\t\tA[j+k]+=temp;\n                if(A[j+k]>=MOD) A[j+k]-=MOD;\n                th=mul(th,w);\n\t\t\t}\n\t\t}\n\t}\n\tif(inv) {\n        int v=fast_pow(N,MOD-2);\n        for(int i=0;i<N;i++) A[i]=mul(A[i],v);\n    }\n}\n\nvoid conv(vector<int> &A, vector<int> &B)\n{\n\tint N=1;\n\tfor(;N<A.size()+B.size();N<<=1);\n\tA.resize(N); B.resize(N);\n\tFFT(A,false); FFT(B,false);\n\tfor(int i=0;i<N;i++) A[i]=mul(A[i],B[i]);\n\tFFT(A,true);\n}\n\nint nCr(int n, int r)\n{\n\treturn mul(F[n],mul(Finv[r],Finv[n-r]));\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N=1, M, ans=0;\n\tF[0]=Finv[0]=1;\n\tfor(int i=1;i<=300000;i++) F[i]=mul(i,F[i-1]);\n\tFinv[300000]=fast_pow(F[300000],MOD-2);\n\tfor(int i=300000;--i;) Finv[i]=mul(Finv[i+1],i+1);\n\tX.resize(1,1);\n\tfor(cin>>M;M--;) {\n\t\tint a, b, sz=X.size()+10, os=X.size()+10;\n\t\tcin>>a>>b;\n\t\tY.clear();\n\t\tfor(int i=-sz;i<=sz;i++) {\n\t\t\tif(b+i<0 || i>a) {\n\t\t\t\tif(Y.empty()) os--;\n\t\t\t}\n\t\t\telse Y.push_back(nCr(a+b,b+i));\n\t\t}\n\t\tconv(X,Y);\n\t\tN+=a-b;\n\t\tfor(int i=0;i<N;i++) X[i]=X[os+i];\n\t\tX.resize(N);\n\t}\n\tfor(int i=0;i<N;i++) {\n\t\tans+=X[i];\n\t\tif(ans>=MOD) ans-=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\ntypedef int LL;\ntypedef double dl;\n#define opt operator\n#define pb push_back\n#define pii std::pair<LL,LL>\nconst LL maxn=1e6+9,mod=998244353,inf=0x3f3f3f3f,G=3;\nLL Read(){\n\tLL x(0),f(1); char c=getchar();\n\twhile(c<'0' || c>'9'){\n\t\tif(c=='-') f=-1; c=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tx=(x<<3ll)+(x<<1ll)+c-'0'; c=getchar();\n\t}return x*f;\n}\nvoid Chkmin(LL &x,LL y){\n\tif(y<x) x=y;\n}\nvoid Chkmax(LL &x,LL y){\n\tif(y>x) x=y;\n}\nLL add(LL x,LL y){\n\treturn x+=y,x>=mod?x-mod:x;\n}\nLL dec(LL x,LL y){\n\treturn x-=y,x<0?x+mod:x;\n}\nLL mul(LL x,LL y){\n\treturn 1ll*x*y%mod;\n}\nLL Pow(LL base,LL b){\n\tLL ret(1); while(b){\n\t\tif(b&1) ret=mul(ret,base); base=mul(base,base); b>>=1;\n\t}return ret;\n}\nnamespace Poly{\n\tLL r[maxn];\n\tLL Fir(LL N){\n\t\tLL limit(1),len(0);\n\t\twhile(limit<N) limit<<=1,++len;\n\t\tfor(LL i=1;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<len-1);\n\t\treturn limit;\n\t}\n\tvoid Ntt(LL *A,LL N,LL op){\n\t\tfor(LL i=1;i<N;++i) if(i<r[i]) std::swap(A[i],A[r[i]]);\n\t\tfor(LL len=1;len<N;len<<=1){\n\t\t\tLL wn(Pow(G,(mod-1)/(len<<1))); if(op==-1) wn=Pow(wn,mod-2);\n\t\t\tfor(LL j=0;j<N;j+=(len<<1)){\n\t\t\t\tfor(LL k=0,w=1;k<len;++k,w=mul(w,wn)){\n\t\t\t\t\tLL x(A[j+k]),y(mul(w,A[j+k+len]));\n\t\t\t\t\tA[j+k]=add(x,y); A[j+k+len]=dec(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(op==-1){\n\t\t\tLL Tmp(Pow(N,mod-2));\n\t\t\tfor(LL i=0;i<N;++i) A[i]=mul(A[i],Tmp);\n\t\t}\n\t}\n\tvoid Mul(LL *A,LL *B,LL *C,LL N,LL M,LL len){\n\t\tstatic LL tA[maxn],tB[maxn];\n\t\tLL limit(Fir(N+M-1));\n\t\tfor(LL i=0;i<N;++i) tA[i]=A[i]; for(LL i=N;i<limit;++i) tA[i]=0;\n\t\tfor(LL i=0;i<M;++i) tB[i]=B[i]; for(LL i=M;i<limit;++i) tB[i]=0;\n\t\tNtt(tA,limit,1); Ntt(tB,limit,1);\n\t\tfor(LL i=0;i<limit;++i) tA[i]=mul(tA[i],tB[i]);\n\t\tNtt(tA,limit,-1);\n        for(LL i=0;i<limit;++i) C[i]=tA[i];\n\t\tfor(LL i=limit;i<len;++i) C[i]=0;\n\t}\n}\nLL n;\nLL a[maxn],b[maxn],fav[maxn],fac[maxn],f[maxn],h[maxn];\nLL C(LL N,LL M){\n\tif(M<0) return 0;\n    if(N<M) return 0;\n\treturn 1ll*fac[N]*fav[M]%mod*fav[N-M]%mod;\n}\nvoid Fir(){\n\tLL N(1000000);\n\tfac[0]=1; for(LL i=1;i<=N;++i) fac[i]=mul(fac[i-1],i);\n\tfav[N]=Pow(fac[N],mod-2); for(LL i=N;i>=1;--i) fav[i-1]=mul(fav[i],i);\n}\nint main(){\n\tFir();\n\tn=Read();\n\tfor(LL i=1;i<=n;++i){\n\t\ta[i]=Read(); b[i]=Read();\n\t}\n\tLL num(1);\n\tf[num]=1;\n\tLL V(0);\n\tfor(LL l=1;l<=n;++l){\n\t\tLL _num(num+a[l]-b[l]);\n\t\tLL len1(a[l]),len2(b[l]);\n\t\tstatic LL A[maxn],B[maxn],C[maxn],F[maxn];\n\t\tA[0]=0;\n\t\tfor(LL i=1;i<=num;++i) A[i]=f[i];\n\t\tfor(LL i=0;i<=V+len1;++i) B[i]=0;\n\t\tLL L(std::max(-len2,-num+1)),R(std::min(len1,_num));\n\t\tLL tlen(len2-L);\n\t\t/*\n\t\tV=len2;\n\t\tfor(LL i=-len2;i<=len1;++i) B[V+i]=mul(fav[len1-i],fav[len2+i]);\n\t\tprintf(\"%d,%d,%d\\n\",num+1,V+len1+1,V+_num+1);\n\t\tPoly::Mul(A,B,C,num+1,V+len1+1,V+_num+1);\n\t\t*/\n\t\tV=-L;\n\t\tfor(LL i=L;i<=R;++i) B[V+i]=mul(fav[len1-i],fav[len2+i]);\n\t\tPoly::Mul(A,B,C,num+1,V+R+1,V+_num+1);\n\t\tLL tmp(fac[len1+len2]);\n\t\tfor(LL i=1;i<=_num;++i) f[i]=mul(tmp,C[V+i]);\n//\t\tfor(LL i=1;i<=_num;++i) printf(\"%d \",f[i]); puts(\"\");\n\t\tnum=_num;\n\t}\n\tLL ans(0);\n\tfor(LL i=1;i<=num;++i) ans=add(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define y0 y12\n#define y1 y22\n#define INF 987654321\n#define PI 3.141592653589793238462643383279502884\n#define fup(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))\n#define fdn(i,a,b,c) for(int (i)=(a);(i)>=(b);(i)-=(c))\n#define MEM0(a) memset((a),0,sizeof(a))\n#define MEM_1(a) memset((a),-1,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n#define COMPRESS(a) sort(ALL(a));a.resize(unique(ALL(a))-a.begin())\n#define SYNC ios_base::sync_with_stdio(false);cin.tie(0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<db, db> Pd;\ntypedef vector<int> Vi;\ntypedef Vi Vll;\ntypedef vector<double> Vd;\ntypedef vector<Pi> VPi;\ntypedef vector<Pll> VPll;\ntypedef vector<Pd> VPd;\ntypedef tuple<int, int, int> iii;\ntypedef tuple<int,int,int,int> iiii;\ntypedef tuple<ll, ll, ll> LLL;\ntypedef vector<iii> Viii;\ntypedef vector<LLL> VLLL;\ntypedef complex<double> base;\nconst int MOD = 998244353;\nll POW(ll a, ll b, ll MMM=MOD) {ll ret=1; for(;b;b>>=1,a=(a*a)%MMM)if(b&1)ret=(ret*a)% MMM; return ret; }\nint dx[] = { 0,1,0,-1,1,1,-1,-1 }, dy[] = { 1,0,-1,0,1,-1,1,-1 };\nint ddx[]={2,2,-2,-2,1,1,-1,-1},ddy[]={1,-1,1,-1,2,-2,2,-2};\n\nint fac[300001],inv[300001];\nint nCr(int n, int r)\n{\n\tif(r<0)return 0;\n\tif(r>n)return 0;\n\tint c = fac[n];\n\tc = (1LL*c*inv[r]) % MOD;\n\tc = (1LL*c*inv[n - r]) % MOD;\n\treturn c;\n}\nvoid fft(Vi &a, bool inv){\n\tint n = a.size(), j = 0;\n\tVi roots(n/2);\n\tfor(int i=1; i<n; i++){\n\t\tint bit = (n >> 1);\n\t\twhile(j >= bit){\n\t\t\tj -= bit;\n\t\t\tbit >>= 1;\n\t\t}\n\t\tj += bit;\n\t\tif(i < j) swap(a[i], a[j]);\n\t}\n\tint ang = POW(3,(MOD-1)/n);\n\tif(inv) ang = POW(ang, MOD - 2);\n\tfor(int i=0; i<n/2; i++){\n\t\troots[i] = (i ? (1LL*roots[i-1]* ang % MOD) : 1);\n\t}\n\tfor(int i=2; i<=n; i<<=1){\n\t\tint step = n / i;\n\t\tfor(int j=0; j<n; j+=i){\n\t\t\tfor(int k=0; k<i/2; k++){\n\t\t\t\tint u = a[j+k], v = (1LL*a[j+k+i/2] * roots[step * k])%MOD;\n\t\t\t\ta[j+k] = u+v;\n\t\t\t\tif(a[j+k]>=MOD)a[j+k]-=MOD;\n\t\t\t\ta[j+k+i/2] = u-v;\n\t\t\t\tif(a[j+k+i/2]<0)a[j+k+i/2]+=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif(inv){\n\t\tll t=POW(n,MOD-2);\n\t\tfor(int i=0; i<n; i++) a[i] =1LL*a[i]*t%MOD; // skip for OR convolution.\n\t} \n}\n\nVi multiply(Vi &v, Vi &w){\n\tint n = 2; while(n < v.size() + w.size()) n <<= 1;\n\tv.resize(n); w.resize(n);\n\tfft(v, 0); fft(w, 0);\n\tfor(int i=0; i<n; i++) v[i] = (1LL*v[i]*w[i])%MOD;\n\tfft(v, 1);\n\treturn v;\n}\n\nint main() {\n\tfac[0] = inv[0] = 1;\n\tfup(i, 1, 300000, 1)\n\t\tfac[i] = (1LL*fac[i - 1] * i) % MOD;\n\tinv[300000] = POW(fac[300000], MOD - 2);\n\tfdn(i, 299999, 1, 1)\n\t\tinv[i] = (1LL*inv[i + 1] * (i+1)) % MOD;\n\tint x=1;\n\tint n;\n\tscanf(\"%d\",&n);\n\tVi A={1};\n\tfup(i,0,n-1,1){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint y=x+a-b;\n\t\tint N=a+b;\n\t\tint t=x+y-1;\n\t\tVi B;\n\t\tint l=(N-t+1)>>1,r=(N+t)>>1;\n\t\tfup(i,l,r,1)B.pb(nCr(N,i));\n\t\tA=multiply(A,B);\n\t\tint k=x+t-2;\n\t\tl=(k-y+1)>>1,r=(k+y)>>1;\n\t\tfup(j,l,r,1)A[j-l]=A[j];\n\t\tA.resize(y);\n\t\tx=y;\n\t}\n\tll ans=0;\n\tfor(ll x:A)ans+=x;\n\tprintf(\"%lld\\n\",ans%MOD);\n}"
        },
        {
            "language": 2,
            "solution": "/*                         _\n                        _ooOoo_\n                       o8888888o\n                       88\" . \"88\n                       (| -_- |)\n                  .'  \\\\|     |//  `.\n                 /  \\\\|||  :  |||//  \\\n                /  _||||| -:- |||||_  \\\n                |   | \\\\\\  -  /'| |   |\n                | \\_|  `\\`---'//  |_/ |\n                \\  .-\\__ `-. -'__/-.  /\n              ___`. .'  /--.--\\  `. .'___\n           .\"\" '<  `.___\\_<|>_/___.' _> \\\"\".\n          | | :  `- \\`. ;`. _/; .'/ /  .' ; |\n          \\  \\ `-.   \\_\\_`. _.'_/_/  -' _.' /\n===========`-.`___`-.__\\ \\___  /__.-'_.'_.-'================\n\n                  Please give me AC.\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mem(a) memset(a,0,sizeof(a))\n//#define INF (~(1<<31))\n#define inf 0x3f3f3f3f3f3f3f3f\n#define eps 1e-8\n#define PI 3.141592653589793238462643383\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) ((x)*(x))\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define all(v) (v).begin(),(v).end()\n#define dbg(x,y) cout<<(x)<<\" = \"<<(y)<< endl;\n#define per(i,a,b) for(int i = a; i >= b; --i)\n#define rep(i,a,b) for(int i = a; i <= b; ++i)\n#define fi first\n#define se second\n#define ls (rt<<1)\n#define rs (rt<<1|1)\n#define ll long long\n#define int ll\ntypedef bitset<2010> bt;\ntypedef unsigned long long ull;\ntypedef complex<double> comp;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\nconst ll N = 2e5 + 7;\nconst ll M = 1e9 + 7;\nconst ll MAXN = 2e18 + 7;\nconst ll Mod = 998244353;\n//const ll Mod = 1e9 + 7;\n\nint _,i,j,k,n,m,p,s,T,t,l,r,o,u,v,w,x,y,z,ans,nex,sum,num,len,en,sx,sy,tx,ty,th,ma,mi,mod,cnt,la,op,res,flag,cas,bk,ret,mid,now,tmp,rt;\nint a[N],b[N],c[N],d[N];\nchar ch;\nvector<int> g[N],h;\nstring s1,s2,s3;\n\nconst int G=3,Gi=332748118;\nint R[N];\nll pow(ll a,ll n)\n{\n    ll ret=1;\n    while(n){\n        if(n&1) ret=ret*a%Mod;\n        a=a*a%Mod;\n        n>>=1;\n    }\n    return ret%Mod;\n}\nvoid ntt(int *A,int n,int rev)\n{\n    for(int i = 0;i < n;i++)\n        if(i < R[i]) swap(A[i],A[R[i]]);\n    for(int mid = 1;mid < n;mid<<=1){\n        ll wn=pow(rev==1? G:Gi,(Mod-1)/(mid<<1));\n        for(int j = 0;j < n;j+=(mid<<1)){\n            ll w=1;\n            for(int k = 0;k < mid;k++,w=w*wn%Mod){\n                int x=A[j+k],y=w*A[j+k+mid]%Mod;\n                A[j+k]=(x+y)%Mod;\n                A[j+k+mid]=(x-y+Mod)%Mod;\n            }\n        }\n    }\n}\nint inv[N];\nvoid get_inv(int n,int p){\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<n;i++){\n\t\tinv[i]=inv[p%i]*(p-p/i)%p;\n\t}\n}\nint C(int n,int m)\n{\n    return c[n]*d[m]%Mod*d[n-m]%Mod;\n}\n\nsigned main()\n{\n    int T = 1;\n    x=1;a[0]=1;\n    get_inv(N,Mod);\n    c[0]=1;\n    for(i = 1;i < N;i++) c[i]=c[i-1]*i%Mod;\n    d[0]=1;\n    for(i = 1;i < N;i++) d[i]=d[i-1]*inv[i]%Mod;\n    scanf(\"%lld\",&T);\n    while(T--){\n        scanf(\"%lld%lld\",&n,&m);\n        for(i = 0;i <= 2*x+n-m-2;i++) b[i]=C(n+m,m+1-x+i);\n        int L=0; p=1;\n        while(p<=3*x+n-m-3) p<<=1,L++;\n        for(i = 0;i < p;i++) R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));\n        ntt(a,p,1);ntt(b,p,1);\n        for(i = 0;i < p;i++) a[i]=a[i]*b[i]%Mod;\n        ntt(a,p,-1);\n        //dbg(-1,a[0])\n        ll inv=pow(p,Mod-2);\n        for(i = 0;i < x+n-m;i++) a[i]=a[i+x-1]*inv%Mod,b[i]=0;\n        for(i = x+n-m;i <= p;i++) a[i]=b[i]=0;\n        x=x+n-m;\n    }\n    for(i = 0;i <= p;i++)\n        ans=(ans+a[i])%Mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\ntypedef long long LL;\n\nusing std::vector;\nconstexpr int LOGN=15, M=998244353, G=3;\nvector<int> rev[LOGN];\nvector<LL> g[LOGN];\n\nLL Pow(LL a, int k)\n{\n    LL ans=1;\n    while(k)\n    {\n        if(k&1) ans=(ans*a)%M; \n        a=(a*a)%M, k>>=1;\n    }\n    return ans;\n}\ninline LL Inv(const LL& a)\n{\n    return Pow(a, M-2);\n}\n\nvoid PreNTT()\n{\n    for(int mid=0, len; mid<LOGN-1; mid++)\n    {\n        len=1<<mid;\n        g[mid].assign(len, 1);\n        LL Gn=Pow(G, (M-1)/(len<<1)), tmp=1;\n        for(LL i=0; i<len; i++)\n        {\n            g[mid][i]=tmp;\n            tmp=tmp*Gn%M;\n        }\n    }\n    rev[0].push_back(0);\n    for(int bit_length=1, bit_depth; bit_length<LOGN; bit_length++)\n    {\n        bit_depth=1<<bit_length;\n        vector<int> &rev_now=rev[bit_length];\n        rev_now.assign(bit_depth, 0);\n        for(int i=0; i<bit_depth; i++)\n            rev_now[i]=(rev_now[i>>1]>>1) | (i&1)<<(bit_length-1);\n    }\n}\nvoid NTT(vector<LL> &X, bool reverse=false)\n{\n    int bit_depth=X.size(), bit_length=__builtin_ctz(bit_depth);\n    for(int i=0, ri; i<bit_depth; i++)\n    {\n        ri=rev[bit_length][i];\n        if(i<ri) std::swap(X[i], X[ri]);\n    }\n    for(int mid=0, len; mid<bit_length; mid++)\n    {\n        len=1<<mid;\n        for(int i=0; i<bit_depth; i+=(len<<1))\n            for(int j=0; j<len; j++)\n            {\n                LL x=X[i+j], y=X[i+j+len]*g[mid][j]%M;\n                X[i+j]=(x+y)%M;\n                X[i+j+len]=(x-y+M)%M;\n            }\n    }\n    if(reverse)\n    {\n        LL inv_n=Inv(bit_depth);\n        for(int i=0; i<bit_depth; i++)\n            X[i]=X[i]*inv_n%M;\n        std::reverse(X.begin()+1, X.end());\n    }\n}\n\nvector<LL> Mul(vector<LL> a, vector<LL> b)\n{\n    int len=1<<(32-__builtin_clz(a.size()+b.size()-1));\n    a.resize(len), b.resize(len);\n    NTT(a), NTT(b);\n    vector<LL> ans(len);\n    for(int i=0; i<len; i++) \n        ans[i]=a[i]*b[i];\n    NTT(ans, true);\n    return ans;\n}\n\nLL Combine(int n, int k)\n{\n    static vector<LL> fac(1, 1), inv_fac(1, 1);\n    if(k<0 || k>n) return 0;\n    while((int)fac.size()<=n)\n    {\n        fac.push_back(fac.back()*fac.size()%M);\n        inv_fac.push_back(Inv(fac.back()));\n    }\n    return fac[n]*inv_fac[k]%M*inv_fac[n-k]%M;\n}\n\nvoid Test()\n{\n    freopen(\"temp\\\\in.txt\", \"r\", stdin);\n}\nint main()\n{\n    // Test();\n    PreNTT();\n\n    int n, a, b;\n    scanf(\"%d\", &n);\n    vector<LL> ans(1, 1);\n    for(int i=0, w, new_w; i<n; i++)\n    {\n        scanf(\"%d%d\", &a, &b);\n        w=ans.size(), new_w=w+a-b;\n        vector<LL> tmp;\n        for(int j=b-w+1; j<w+a; j++)\n            tmp.push_back(Combine(a+b, j));\n        auto new_ans=Mul(ans, tmp);\n        ans.resize(new_w);\n        for(int j=0; j<new_w; j++)\n            ans[j]=new_ans[w+j-1];\n    }\n\n    LL sum=0, w=ans.size();\n    for(int i=0; i<w; i++)\n        sum=(sum+ans[i])%M;\n    std::cout<<sum;\n    return 0;\n}\n\t \t \t\t \t\t  \t\t\t \t \t \t\t   \t\t   \t\t"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <algorithm>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nconst int me = 20;\nconst int ms = 1 << me;\n\nlong long fexp(long long x, long long e, long long mod = MOD) {\n\tlong long ans = 1;\n\tx %= mod;\n\tfor(; e > 0; e /= 2, x = x * x % mod) {\n\t\tif(e & 1) ans = ans * x % mod;\n\t}\n\treturn ans;\n}\n\n#define add(x, y) x+y>=MOD?x+y-MOD:x+y\n\nconst int gen = 3; // use search() from PrimitiveRoot.cpp if MOD isn't 998244353\nint bits[ms], root[ms];\n\nvoid initFFT() {\n\troot[1] = 1;\n\tfor(int len = 2; len < ms; len += len) {\n\t\tint z = (int) fexp(gen, (MOD - 1) / len / 2);\n\t\tfor(int i = len / 2; i < len; i++) {\n\t\t\troot[2 * i] = root[i];\n\t\t\troot[2 * i + 1] = (int)((long long) root[i] * z % MOD);\n\t\t}\n\t}\n}\n\nvoid pre(int n) {\n\tint LOG = 0;\n\twhile(1 << (LOG + 1) < n) {\n\t\tLOG++;\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tbits[i] = (bits[i >> 1] >> 1) | ((i & 1) << LOG);\n\t}\n}\n\nstd::vector<int> fft(std::vector<int> a, bool inv = false) {\n\tint n = (int) a.size();\n\tpre(n);\n\tif(inv) {\n\t\tstd::reverse(a.begin() + 1, a.end());\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tint to = bits[i];\n\t\tif(i < to) { std::swap(a[i], a[to]); }\n\t}\n\tfor(int len = 1; len < n; len *= 2) {\n\t\tfor(int i = 0; i < n; i += len * 2) {\n\t\t\tfor(int j = 0; j < len; j++) {\n\t\t\t\tint u = a[i + j], v = (int)((long long) a[i + j + len] * root[len + j] % MOD);\n\t\t\t\ta[i + j] = add(u, v);\n\t\t\t\ta[i + j + len] = add(u, MOD - v);\n\t\t\t}\n\t\t}\n\t}\n\tif(inv) {\n\t\tlong long rev = fexp(n, MOD-2, MOD);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = (int)(a[i] * rev % MOD);\n\t}\n\treturn a;\n}\n\ntemplate <class T>\nT fexp(T x, long long e) {\n\tT ans(1);\n\tfor(; e > 0; e /= 2) {\n\t\tif(e & 1) ans = ans * x;\n\t\tx = x * x;\n\t}\n\treturn ans;\n}\n\ntemplate <int mod = MOD>\nstruct modBase {\n\tmodBase(int v = 0) : val(v < 0 ? v + mod : v) {}\n\tint val;\n \n\tvoid operator += (modBase<mod> o) { *this = *this + o; }\n\tvoid operator -= (modBase<mod> o) { *this = *this - o; }\n\tvoid operator *= (modBase<mod> o) { *this = *this * o; }\n\t//void operator /= (modBase<mod> o) { *this = *this / o; }\n\tmodBase<mod> operator * (modBase<mod> o) { return (int)((long long) val * o.val % mod); }\n\t//modBase<mod> operator / (modBase<mod> o) { return *this * fexp(o, mod - 2); }\n\tmodBase<mod> operator + (modBase<mod> o) { return val + o.val >= mod ? val + o.val - mod : val + o.val; }\n\tmodBase<mod> operator - (modBase<mod> o) { return val - o.val < 0 ? val - o.val + mod : val - o.val; }\n\n\tfriend std::ostream& operator << (std::ostream &os, const modBase<mod> &p) {\n\t\treturn os << p.val;\n\t}\n\tfriend std::istream& operator >> (std::istream &is, modBase<mod> &p) {\n\t\treturn is >> p.val;\n\t}\n};\n\nmodBase<> fat[ms], ifat[ms];\nvoid initComb() {\n\tfat[0] = 1;\n\tfor(int i = 1; i < ms; i++) {\n\t\tfat[i] = fat[i-1] * i;\n\t}\n\tifat[ms-1] = fexp(fat[ms-1], MOD - 2);\n\tfor(int i = ms-1; i > 0; i--) {\n\t\tifat[i-1] = ifat[i] * i;\n\t}\n}\nmodBase<> comb(int n, int a) { return a < 0 || a > n ? modBase<>(0) : fat[n] * ifat[a] * ifat[n-a]; }\n\ntemplate<class T>\nstd::vector<T> partitionNumber(int n) {\n\tstd::vector<T> ans(n, 0);\n\tans[0] = 1;\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = 1; j * (3 * j + 1) / 2 <= i; j++) {\n\t\t\tans[i] = ((j & 1) ? ans[i] + ans[i - j * (3 * j + 1) / 2] : ans[i] - ans[i - j * (3 * j + 1) / 2]);\n\t\t}\n\t\tfor(int j = 1; j * (3 * j - 1) / 2 <= i; j++) {\n\t\t\tans[i] = ((j & 1) ? ans[i] + ans[i - j * (3 * j - 1) / 2] : ans[i] - ans[i - j * (3 * j - 1) / 2]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nstd::vector<int> operator *(std::vector<int> a, std::vector<int> b) {\n\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\twhile(!b.empty() && b.back() == 0) b.pop_back();\n\tif(a.empty() || b.empty()) return std::vector<int>(0, 0);\n\tint n = 1;\n\twhile(n-1 < (int) a.size() + (int) b.size() - 2) n += n;\n\ta.resize(n, 0);\n\tb.resize(n, 0);\n\ta = fft(a, false);\n\tb = fft(b, false);\n\tfor(int i = 0; i < n; i++) {\n\t\ta[i] = (int) ((long long) a[i] * b[i] % MOD); \n\t}\n\treturn fft(a, true);\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tinitComb();\n\tinitFFT();\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int> poly(1, 1);\n\tint got = 1;\n\twhile(n-- && !poly.empty()) {\n\t\tint a, b;\n\t\tstd::cin >> a >> b;\n\t\tstd::vector<int> other(2 * got + 20, 0);\n\t\tfor(int i = 0; i < (int) other.size(); i++) {\n\t\t\tint id = i - (got + 10) + b;\n\t\t\tother[i] = comb(a+b, id).val;\n\t\t}\n\t\tpoly = poly * other;\n\t\tstd::vector<int> ans(got+a-b, 0);\n\t\tfor(int i = 0; i < (int) poly.size(); i++) {\n\t\t\tint id = i - (got + 10);\n\t\t\tif(0 <= id && id < (int) ans.size()) {\n\t\t\t\tans[id] = poly[i];\n\t\t\t}\n\t\t}\n\t\tgot += a - b;\n\t\tpoly = ans;\n\t}\n\tmodBase<> ans(0);\n\tfor(auto v : poly) {\n\t\tans += v;\n\t}\n\tstd::cout << ans << '\\n';\n}"
        },
        {
            "language": 2,
            "solution": "// author: xay5421\n// created: Sun Jan 17 14:55:30 2021\n#include<bits/stdc++.h>\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int P=998244353,N=200005;\nint ad(int k1,int k2){return k1+=k2-P,k1+=k1>>31&P;}\nint su(int k1,int k2){return k1-=k2,k1+=k1>>31&P;}\nint mu(int k1,int k2){return 1LL*k1*k2%P;}\nvoid uad(int&k1,int k2){k1+=k2-P,k1+=k1>>31&P;}\nvoid usu(int&k1,int k2){k1-=k2,k1+=k1>>31&P;}\ntemplate<typename... T>int ad(int k1,T... k2){return ad(k1,ad(k2...));}\ntemplate<typename... T>void uad(int&k1,T... k2){return uad(k1,ad(k2...));}\ntemplate<typename... T>void usu(int&k1,T... k2){return usu(k1,ad(k2...));}\ntemplate<typename... T>int mu(int k1,T... k2){return mu(k1,mu(k2...));}\nint po(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=mu(k1,k1))if(k2&1)k3=mu(k3,k1);\n\treturn k3;\n}\nvoid NTT(vector<int>&a,int g,int lim){\n\ta.resize(lim);\n\tfor(int i=0,j=0;i<lim;++i){\n\t\tif(i<j)swap(a[i],a[j]);\n\t\tfor(int k=lim>>1;(j^=k)<k;k>>=1);\n\t}\n\tvector<int>w(lim>>1); w[0]=1;\n\tfor(int i=1;i<lim;i<<=1){\n\t\tfor(int j=1,wn=po(g,(P-1)/(i<<1));j<i;++j)w[j]=mu(w[j-1],wn);\n\t\tfor(int j=0;j<lim;j+=i<<1)for(int k=0;k<i;++k){\n\t\t\tint x=a[j+k],y=mu(a[i+j+k],w[k]);\n\t\t\ta[j+k]=ad(x,y),a[i+j+k]=su(x,y);\n\t\t}\n\t}\n\tif(g!=3){\n\t\tconst int I=po(lim,P-2);\n\t\trep(i,0,lim-1)a[i]=mu(a[i],I);\n\t}\n}\nvector<int>operator*(vector<int>a,vector<int>b){\n\tint need=SZ(a)+SZ(b)-1,lim=1;\n\twhile(lim<=need)lim<<=1;\n\tNTT(a,3,lim),NTT(b,3,lim);\n\trep(i,0,lim-1)a[i]=mu(a[i],b[i]);\n\tNTT(a,332748118,lim);\n\treturn a.resize(need),a;\n}\nint n,fac[N],inv[N],ifac[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn mu(fac[k1],ifac[k2],ifac[k1-k2]);\n}\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\trep(i,2,N-1)fac[i]=mu(fac[i-1],i),inv[i]=mu(P-P/i,inv[P%i]),ifac[i]=mu(ifac[i-1],inv[i]);\n\tscanf(\"%d\",&n);\n\tvector<int>ans{1};\n\trep(i,1,n){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint m=SZ(ans);\n\t\tvector<int>co;\n\t\trep(j,b-m+1,m+a-1){\n\t\t\tco.push_back(C(a+b,j));\n\t\t}\n\t\tvector<int>res=ans*co;\n\t\tans.resize(m+a-b);\n\t\trep(i,0,SZ(ans)-1)ans[i]=res[m+i-1];\n\t}\n\tint res=0;\n\trep(i,0,SZ(ans)-1)uad(res,ans[i]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define ll long long\n#define p pair<int, int>\n#define endl '\\n'\nconst int INF = 1000000001;using namespace std;const int C = 998244353;vector<ll> fact, minus_fact;\nll pow1(ll x, ll y, ll z=C){if (y == 0)return 1;if (y % 2 == 0)return pow1(x*x % z, y/2, z);return pow1(x, y-1, z)*x % z;}\nvoid facts(int n){fact = {1}, minus_fact = {1};for (int q = 1; q <= n; q++){fact.push_back(fact.back()*q % C);minus_fact.push_back(minus_fact.back()*pow1(q, C-2) % C);}}\nll c(int k, int n){if (k < 0 || k > n)return 0;return fact[n]*minus_fact[k] % C*minus_fact[n-k] % C;}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    facts(200179);\n    int n;\n    cin >> n;\n    vector<p> a(n);\n    for (int q = 0; q < n; q++)cin >> a[q].first >> a[q].second;\n    \n    vector<int> now = {1};\n    for (int q = 0; q < n; q++){\n        int w3 = (now.size()+a[q].first+a[q].second+1)/2, w4 = now.size()+a[q].first+a[q].second;\n        vector<__int128> will(w3-a[q].second, 0);\n        vector<ll> cc(now.size()+a[q].first);\n        for (int q1 = 0; q1 < cc.size(); q1++){\n            cc[q1] = c(q1, a[q].first+a[q].second);\n        }\n        for (int q1 = a[q].second; q1 < w3; q1++){\n            int w = min(q1+1, (int)now.size()), w1 = q1-a[q].second, w2 = max(0, q1-a[q].first-a[q].second);\n            for (int q2 = w2; q2 < w; q2++)will[w1] += cc[q1-q2]*now[q2];            \n        }\n        now = {};\n        for (__int128 q1: will)now.push_back(q1 % C);        \n        for (int q1 = (int)now.size()-1-w4 % 2; q1 > -1; q1--)now.push_back(now[q1]);        \n    }\n    ll ans = 0;for (int q: now)ans += q;\n    cout << ans % C << endl;\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#ifdef ALGO\n#include \"el_psy_congroo.hpp\"\n#else\n#define DUMP(...) 1145141919810\n#define CHECK(...) (__VA_ARGS__)\n#endif\n\ntemplate<int MOD>\nstruct Integral {\n  int v_ = 0;\n\n  template<typename T> Integral(T v) : v_(norm(v)) {  // Implicit conversion is allowed.\n    static_assert(std::is_integral<T>::value, \"input should be an integral.\");\n  }\n  Integral() = default;\n  ~Integral() = default;\n\n  template<typename T> T norm(T v) const {\n    if constexpr(std::is_same<long long, T>::value) {\n      v %= MOD;\n      if (v < 0) v += MOD;\n    } else {\n      if (v >= MOD) v -= MOD;\n      if (v < 0) v += MOD;\n      if (v >= MOD || v < 0) {\n        v %= MOD;\n        if (v < 0) v += MOD;\n      }\n    }\n    return v;\n  }\n\n  int val() const { return v_; }\n  Integral operator + (const Integral& rhs) const { return Integral(val() + rhs.val()); }\n  Integral operator - (const Integral& rhs) const { return Integral(val() - rhs.val()); }\n  Integral operator * (const Integral& rhs) const { return Integral(val() * 1LL * rhs.val()); }\n  Integral operator / (const Integral& rhs) const { return *this * rhs.inv(); }\n  Integral& operator += (const Integral& rhs) { return *this = *this + rhs; }\n  Integral& operator -= (const Integral& rhs) { return *this = *this - rhs; }\n  Integral& operator *= (const Integral& rhs) { return *this = *this * rhs; }\n  Integral& operator /= (const Integral& rhs) { return *this = *this / rhs; }\n  bool operator == (const Integral& rhs) const { return val() == rhs.val(); }\n  bool operator != (const Integral& rhs) const { return !(*this == rhs); }\n  const Integral operator - () const { return Integral(-val()); }\n  const Integral operator ++ () { v_ = norm(v_ + 1); return *this; }\n  const Integral operator ++ (int) { Integral ret = *this; ++(*this); return ret; }\n  const Integral operator -- () { v_ = norm(v_ - 1); return *this; }\n  const Integral operator -- (int) { Integral ret = *this; --(*this); return ret; }\n\n  Integral power(long long b) const {\n    long long ret = 1 % MOD, a = v_;\n    for ( ; b; b >>= 1, a = a * a % MOD) if (b & 1) ret = ret * a % MOD; return ret;\n  }\n  Integral inv() const { return power(MOD - 2); }\n};\n\ntemplate<int MOD>\nstd::string to_string(const Integral<MOD>& v) {\n  return std::string(\"Int<>{\") + std::to_string(v.val()) + \"}\";\n}\n\ntemplate<int MOD, bool kAllowBruteForce = false>\nstruct Binomial {\n  std::vector<Integral<MOD>> factor, inv_factor;\n\n  explicit Binomial(int n = 0) : factor(n + 1), inv_factor(n + 1) {\n    factor[0] = 1;\n    for (int i = 1; i <= n; ++i) factor[i] = factor[i - 1] * i;\n    inv_factor[n] = factor[n].inv();\n    for (int i = n; i >= 1; --i) inv_factor[i - 1] = inv_factor[i] * i;\n  }\n  ~Binomial() = default;\n\n  template<typename T>\n  Integral<MOD> operator () (T a, T b) const {\n    if (a < b || b < 0) return 0;\n    if (a < factor.size()) return factor[a] * inv_factor[b] * inv_factor[a - b];\n    if constexpr(!kAllowBruteForce) {\n      throw std::out_of_range(\"Binomial\");\n    } else {\n      b = std::min(b, a - b);\n      Integral<MOD> ret = 1;\n      for (T i = 1; i <= b; ++i) ret = ret * (a + 1 - i) / i;\n      return ret;\n    }\n  }\n};\n\ntemplate<int MOD>\nstruct PowerTable : public std::vector<Integral<MOD>> {\n  PowerTable(int n, const Integral<MOD>& g) {\n    static_assert(sizeof(PowerTable) == sizeof(std::vector<Integral<MOD>>), \"\");\n    this->resize(n + 1);\n    this->at(0) = 1;\n    this->at(1) = g;\n    for (int i = 2; i < this->size(); ++i) this->at(i) = this->at(i - 1) * this->at(1);\n  }\n};\n\nconst int MOD = 998244353;\nusing Mint = Integral<MOD>;\nusing Binom = Binomial<MOD>;\n\nBinom binom(200000);\n// PowerTable<MOD> pw2(200000, 2);\n\ntemplate<int MOD = 998244353, int kPrimRoot = 3>\nvoid ntt(Integral<MOD> A[], int n, int inv) {\n  // inv == 1: ntt, == -1: intt\n\n  // MOD == a * b ^ k + 1, n <= b ^ k.\n  // 998244353 == (7 * 17) * 2 ^ 23 + 1.\n  // This code works only when b == 2.\n  Integral<MOD> w = 1, d = Integral<MOD>(kPrimRoot).power((MOD - 1) / n), t;\n  int i, j, c, s;\n  if (inv == -1) {\n    for (i = 1, j = n - 1; i < j; ++i, --j) std::swap(A[i], A[j]);\n    for (t = Integral<MOD>(n).inv(), i = 0; i < n; ++i) A[i] = A[i] * t;\n  }\n  for (s = n >> 1; s; s >>= 1, w = 1, d = d * d) {\n    for (c = 0; c < s; ++c, w = w * d) {\n      for (i = c; i < n; i += s << 1) {\n        A[i | s] = (A[i] - (t = A[i | s])) * w;\n        A[i] += t;\n      }\n    }\n  }\n  for (i = 1; i < n; ++i) {\n    for (j = 0, s = i, c = n >> 1; c; c >>= 1, s >>= 1) j = j << 1 | (s & 1);\n    if (i < j) std::swap(A[i], A[j]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::istream& reader = std::cin;\n\n  int n;\n  reader >> n;\n  std::vector<Mint> f(1, 1);\n\n  for (int at = 1; at <= n; ++at) {\n    int a, b;\n    reader >> a >> b;\n    int m = f.size();\n    int w = m + a - b + m + 1;  // b - m, m + a\n    int L = 1;\n    while (L < m + w) L <<= 1;\n    f.resize(L, 0);\n    std::vector<Mint> y(L);\n    for (int i = 0; i < w; ++i) {\n      y[i] = binom(a + b, i + b - m);\n    }\n    ntt(&f[0], L, 1);\n    ntt(&y[0], L, 1);\n    for (int i = 0; i < L; ++i) f[i] *= y[i];\n    ntt(&f[0], L, -1);\n    for (int i = 0; i < m + a - b; ++i) f[i] = i + m < L ? f[i + m] : 0;\n    f.resize(m + a - b);\n  }\n  std::cout << std::accumulate(f.begin(), f.end(), Mint(0)).val() << std::endl;\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<vector>\n#define o 1000005\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=data*10+ch-'0',ch=getchar();\n\treturn data*w;\n}\nint n,m,rev[o];\nconst int mod=998244353;\nint KSM(int x,int k)\n{\n\tint tmp=1,y=x;\n\tfor(int i=k;i;i>>=1,y=1ll*y*y%mod)if(i&1)tmp=1ll*tmp*y%mod;\n\treturn tmp;\n}\nint Make(int n)\n{\n\tint t=0;while(1<<t<=n)t++;\n\tFOR(i,0,(1<<t)-1)rev[i]=rev[i>>1]>>1|(i&1)<<t-1;\n\treturn t; \n}\nvoid fix(int &x){x+=x>>31&mod;}\nvoid NTT(int a[],int n,int d)\n{\n\tFOR(i,0,(1<<n)-1)if(i<rev[i])swap(a[i],a[rev[i]]);\n\tFOR(m,0,n-1)\n\t{\n\t\tint w=KSM(3,mod-1+(mod-1)/(2<<m)*d);\n\t\tfor(int i=0;i<1<<n;i+=2<<m)\n\t\t\tfor(int k=i,x=1;k<i+(1<<m);k++,x=1ll*x*w%mod)\n\t\t\t{\n\t\t\t\tint t0=a[k],t1=1ll*a[k+(1<<m)]*x%mod;\n\t\t\t\t//cout<<\"x=\"<<x<<\"\\n\" \n\t\t\t\tfix(a[k]=t0+t1-mod),fix(a[k+(1<<m)]=t0-t1);\n\t\t\t}\n\t}\n\tif(d==-1){int iv=KSM(1<<n,mod-2);FOR(i,0,(1<<n)-1)a[i]=1ll*a[i]*iv%mod;}\n}\nint fac[o],inv[o],g[o],f[o],a[o];\nvoid init(int n=300000)\n{\n\tfac[0]=1;\n\tFOR(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=KSM(fac[n],mod-2);\n\tREP(i,n-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int n,int m){return n<m||m<0?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n//\tint p=Make(100);\n//\tFOR(i,0,(1<<p)-1)a[i]=1;\n//\tNTT(a,p,1);\n//\tNTT(a,p,-1);\n//\tFOR(i,0,(1<<p)-1)cout<<a[i]<<\" \";\n//\treturn 0;\n\tinit(); \n\tn=read(),m=1;\n\tf[1]=1;\n\twhile(n--)\n\t{\n\t\tint A=read(),B=read(),t=Make(m+A-B+m+m);\n\t\tFOR(i,0,(1<<t)-1)a[i]=g[i]=0;\n\t\tFOR(i,-m,m+A-B)g[i+m]=C(A+B,B+i);\n\t\tFOR(i,1,m)a[i]=f[i];\n\t\tNTT(g,t,1);NTT(a,t,1);\n\t\tFOR(i,0,(1<<t)-1)g[i]=1ll*g[i]*a[i]%mod;\n\t\tNTT(g,t,-1);\n\t\tFOR(i,1,m+A-B)f[i]=g[i+m];\n\t\tm+=A-B;\n\t\t//FOR(i,1,m)cout<<f[i]<<\" \";\n\t}\n\tint ans=0;\n\tFOR(i,1,m)fix(ans+=f[i]-mod);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define C(n,m) (jc[n]*Jc[m]%mod*Jc[(n)-(m)]%mod)\n#define add(a,b) a=((a)+(b))%mod\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define mod 998244353\n#define Mod 998244351\n#define ll long long\n#define G 114514\n//#define file\nusing namespace std;\n\nint n,i,j,k,l,A,B,s,N,N2,len;\nint f[5011],g[5011],ans;\nint a[16384],b[16384],w1[15][16384],w2[15][16384];\nll jc[200001],Jc[200001];\nint a2[15][16384];\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\nvoid init()\n{\n\tint i,j,k,l;\n\tN=1;\n\tfo(len,1,14)\n\t{\n\t\tN*=2;\n\t\tfo(i,0,N-1)\n\t\t{\n\t\t\tj=i,k=0;\n\t\t\tfo(l,1,len) k=k*2+(j&1),j>>=1;\n\t\t\ta2[len][i]=k;\n\t\t}\n\t}\n\tll w,W;\n\tl=2;k=1;\n\tfo(i,1,14)\n\t{\n\t\tw=qpower(G,(mod-1)/l);W=1;\n\t\tfo(j,0,k-1) w1[i][j]=W,W=W*w%mod;\n\t\tw=qpower(G,(mod-1)-(mod-1)/l);W=1;\n\t\tfo(j,0,k-1) w2[i][j]=W,W=W*w%mod;\n\t\tl<<=1;k<<=1;\n\t}\n}\nvoid dft(int *a,int tp)\n{\n\tstatic int A[16384];\n\tint i,j,k,l,s1=2,s2=1,S=N;\n\tll u,v;\n\t\n\tfo(i,0,N-1) A[a2[len][i]]=a[i];memcpy(a,A,N*4);\n\tfo(i,1,len)\n\t{\n\t\tS>>=1;\n\t\tfo(j,0,S-1)\n\t\t{\n\t\t\tfo(k,0,s2-1)\n\t\t\t{\n\t\t\t\tif (tp==1)\n\t\t\t\tu=a[j*s1+k],v=1ll*a[j*s1+k+s2]*w1[i][k];\n\t\t\t\telse\n\t\t\t\tu=a[j*s1+k],v=1ll*a[j*s1+k+s2]*w2[i][k];\n\t\t\t\ta[j*s1+k]=(u+v)%mod;\n\t\t\t\ta[j*s1+k+s2]=(u-v)%mod;\n\t\t\t}\n\t\t}\n\t\ts1<<=1,s2<<=1;\n\t}\n}\n\nvoid work1()\n{\n\tint i,j,k,l;\n\tmemset(g,0,(s+2)*4);\n\tfo(i,1,s) add(g[i],f[i]),add(g[i+1],f[i]);\n\t++s,memcpy(f,g,(s+1)*4);\n}\nvoid work2()\n{\n\tint i,j,k,l;\n\t--s;\n\tfo(i,1,s) g[i]=(f[i]+f[i+1])%mod;\n\tmemcpy(f,g,(s+1)*4);\n}\nvoid work3(int t)\n{\n\tint i,j,k,l;\n\tif (!t) return;\n\tlen=ceil(log2(s+1))+1,N=qpower(2,len);N2=qpower(N,Mod);\n\t\n\tmemset(a,0,N*4),memset(b,0,N*4);\n\tfo(i,1,s) g[i]=1ll*f[i]*C(t*2,t)%mod,a[i]=f[i];\n\tfo(i,1,min(s,t)) b[i]=C(t*2,t+i);\n\t\n\tdft(a,1),dft(b,1);\n\tfo(i,0,N-1) a[i]=1ll*a[i]*b[i]%mod;\n\tdft(a,-1);\n\tfo(i,1,s) a[i]=1ll*a[i]*N2%mod;\n\tfo(i,1,s) add(g[i],1ll*(a[i]+a[s-i+1]));\n\tmemcpy(f,g,(s+1)*4);\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"CF1473G.in\",\"r\",stdin);\n\t#endif\n\t\n\tjc[0]=1;\n\tfo(i,1,200000) jc[i]=jc[i-1]*i%mod;\n\tJc[200000]=qpower(jc[200000],Mod);\n\tfd(i,200000-1,0) Jc[i]=Jc[i+1]*(i+1)%mod;\n\tscanf(\"%d\",&n);s=1,f[1]=1;\n\tinit();\n\t\n\tfo(i,1,n)\n\t{\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tif (A>B) {fo(j,1,A-B) work1();work3(B);}\n\t\telse {work3(A);fo(j,1,B-A) work2();}\n\t}\n\t\n\tfo(i,1,s) add(ans,f[i]);\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"avx,avx2\")\n\nconst ll mod = 998244353;\n\nconst int L = 15;\nconst int N = (1 << L);\n\nint add(int a, int b) {\n  int c = a + b;\n  if (c >= mod) c -= mod;\n  return c;\n}\nint sub(int a, int b) {\n  return add(a, mod - b);\n}\nint mult(int a, int b) {\n  return ((ll) a * b) % mod;\n}\n\nint pw(int a, int b) {\n  if (!b) return 1;\n  if (b & 1) return mult(pw(a, b - 1), a);\n  int x = pw(a, b / 2);\n  return mult(x, x);\n}\n\nint inv2;\nint pws[N + 1], ipws[N + 1];\n\nvoid init() {\n  inv2 = pw(2, mod - 2);\n  pws[N] = pw(31, pw(2, 23 - L));\n  ipws[N] = pw(pws[N], mod - 2);\n  for (int i = (N >> 1); i; i >>= 1) {\n    pws[i] = mult(pws[i << 1], pws[i << 1]);\n    ipws[i] = mult(ipws[i << 1], ipws[i << 1]);\n  }\n}\n\nvoid fft(vector<int> &s, vector<int> &res, int n, int x, int bs = 0, int bstep = 1, int rs = 0) {\n  if (n == 1) {\n    res[rs] = s[bs];\n    return;\n  }\n  fft(s, res, n >> 1, mult(x, x), bs, bstep << 1, rs);\n  fft(s, res, n >> 1, mult(x, x), bs + bstep, bstep << 1, rs + (n >> 1));\n  int c = 1;\n  for (int i = rs; i < rs + (n >> 1); ++i) {\n    int a = res[i], b = res[i + (n >> 1)];\n    res[i] = add(a, mult(b, c));\n    res[i + (n >> 1)] = sub(a, mult(b, c));\n    c = mult(c, x);\n  }\n}\n\nvoid poly_mult(const vector<int> &a, const vector<int> &b, vector<int> &c) {\n  init();\n  vector<int> fa, fb, fra, frb, rt;\n  int n = 1;\n  while (n < max(b.size(), a.size())) n <<= 1;\n  n <<= 1;\n  fa.resize(n);\n  rt = frb = fra = fb = fa;\n  for (int i = 0; i < a.size(); ++i) fa[i] = a[i];\n  for (int i = 0; i < b.size(); ++i) fb[i] = b[i];\n  fft(fa, fra, n, pws[n]);\n  fft(fb, frb, n, pws[n]);\n  for (int i = 0; i < n; ++i)\n    fra[i] = mult(fra[i], frb[i]);\n  fft(fra, rt, n, ipws[n]);\n  int inv_n = pw(n, mod - 2);\n  for (int i = 0; i < n; ++i)\n    rt[i] = mult(rt[i], inv_n);\n  c = rt;\n}\n\nconst ll M = 3e5 + 5;\n\nint fact[M], invfact[M];\n\nint cnk(int n, int k) {\n  if (n < 0 || k < 0 || n - k < 0) return 0;\n  return mult(mult(fact[n], invfact[n - k]), invfact[k]);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  fact[0] = 1;\n  for (int i = 1; i < M; ++i) fact[i] = mult(fact[i - 1], i);\n  invfact[M - 1] = pw(fact[M - 1], mod - 2);\n  for (int i = M - 2; i >= 0; --i) invfact[i] = mult(invfact[i + 1], i + 1);\n\n  int n, d = 0;\n  cin >> n;\n  vector<int> cur = {1};\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    int dd = d + a - b;\n    vector<int> g(d + dd + 1);\n    for (int j = -d; j <= dd; ++j) g[j + d] = cnk(a + b, b + j);\n    vector<int> f;\n    poly_mult(cur, g, f);\n    cur.resize(dd + 1);\n    for (int j = 0; j <= dd; ++j)\n      cur[j] = f[j + d];\n    d = dd;\n  }\n  ll ans = 0;\n  for (ll x : cur) ans = (ans + x) % mod;\n  cout << ans;\n}"
        },
        {
            "language": 2,
            "solution": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 200015\nconst int p=998244353;\nint n,a,b,f[N],finv[N],inv[N],rev[N],ta[N],tb[N];\ninline int C(int nn,int mm){if(nn<mm||nn<0||mm<0)return 0;return 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;}\ninline int ksm(int d,int k){int ret=1;while(k){if(k&1)ret=1ll*ret*d%p;d=1ll*d*d%p;k>>=1;}return ret;}\ninline void ntt(int x[],int len,int mde)\n{for(int i=0;i<len;i++)if(i<rev[i])swap(x[i],x[rev[i]]);\n\tfor(int i=2;i<=len;i<<=1)\n\t{int wn=ksm(3,(p-1)/i);if(mde<0)wn=ksm(wn,p-2);\n\t\tfor(int j=0,stp=i>>1;j<len;j+=i)for(int k=j,w=1;k<j+stp;k++,w=1ll*w*wn%p)\n\t\t{int t1=x[k],t2=1ll*x[k+stp]*w%p;\n\t\t\tx[k]=(t1+t2)%p,x[k+stp]=(t1-t2+p)%p;\n\t\t}\n\t}if(mde<0)for(int i=0,te=ksm(len,p-2);i<len;i++)x[i]=1ll*x[i]*te%p;\n}\nint main()\n{\n\tscanf(\"%d\",&n);int len=1;f[0]=finv[0]=f[1]=finv[1]=inv[1]=1;\n\tfor(int i=2;i<=200000;i++)\n\t{\n\t\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n\t\tf[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n\t}ta[1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint nl=max(len,len+a-b),tle=1;\n\t\twhile(tle<=(nl*3))tle<<=1;\n\t\tfor(int j=1;j<tle;j++){rev[j]=rev[j>>1]>>1;if(j&1)rev[j]|=tle>>1;}\n\t\tfor(int j=len+1;j<tle;j++)ta[j]=0;for(int j=0;j<tle;j++)tb[j]=0;\n\t\tfor(int j=-len;j<=nl;j++)tb[len+j]=C(a+b,b+j);\n\t\tntt(ta,tle,1);ntt(tb,tle,1);for(int j=0;j<tle;j++)ta[j]=1ll*ta[j]*tb[j]%p;ntt(ta,tle,-1);\n\t\tfor(int j=1;j<=len+a-b;j++)ta[j]=ta[j+len];\n\t\tfor(int j=len+a-b+1;j<tle;j++)ta[j]=0;len+=a-b;\n\t}int ans=0;for(int i=1;i<=len;i++)(ans+=ta[i])%=p;printf(\"%d\\n\",ans);\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1000000;\nconst int mod = 998244353;\nconst int g = 3;\nconst int gi = 332748118;\n\nint a[maxn],b[maxn],dp[maxn];\nint c[maxn],pos[maxn],fac[maxn],fav[maxn];\nint qpow(int a,int b,int c){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\tb>>=1;\n\t\ta=1ll*a*a%mod;\n\t}\n\treturn ans;\n}\nint init(int n){\n\tint cur=1,ct=0;\n\twhile(cur<n)cur<<=1,ct++;\n\tfor(int i=0;i<cur;++i)pos[i]=(pos[i>>1]>>1)|((i&1)<<(ct-1));\n\treturn cur;\n}\nint C(int a,int b){\n\tif(b<0 || b>a)return 0;\n\treturn 1ll*fac[a]*fav[b]%mod*fav[a-b]%mod;\n}\nvoid ntt(int *a,int len,int fg){\n\tfor(int i=0;i<len;++i)if(i<pos[i])swap(a[i],a[pos[i]]);\n\tfor(int i=2,mid=1;i<=len;i<<=1,mid<<=1){\n\t\tint wn=qpow(fg==1?g:gi,(mod-1)/i,mod);\n\t\tfor(int j=0;j<len;j+=i){\n\t\t\tint w=1;\n\t\t\tfor(int k=j;k<j+mid;k++){\n\t\t\t\tint l=a[k],r=1ll*a[k+mid]*w%mod;\n\t\t\t\ta[k]=(l+r)%mod,a[k+mid]=(l-r+mod)%mod;\n\t\t\t\tw=1ll*w*wn%mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(fg==-1){\n\t\tint invlen=qpow(len,mod-2,mod);\n\t\tfor(int i=0;i<len;++i)a[i]=1ll*invlen*a[i]%mod;\n\t}\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tfav[maxn-1]=qpow(fac[maxn-1],mod-2,mod);\n\tfor(int i=maxn-2;i>=0;--i)fav[i]=1ll*fav[i+1]*(i+1)%mod;\n\tint n;\n\tscanf(\"%d\",&n);\n\tdp[0]=1;\n\tint cur=1;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tint le=2*cur+a[i]-b[i]-1;\n\t\tint len=init(le);\n\t\tfor(int j=b[i]-cur+1,k=0;j<=b[i]+cur+a[i]-b[i]-1;++j,++k)c[k]=C(b[i]+a[i],j);\n\t\tfor(int j=b[i]+cur+a[i]-b[i];j<len;++j)c[j]=0;\n//\t\tfor(int j=0;j<len;++j)printf(\"%d \",c[j]);puts(\"\");\n//\t\tfor(int j=0;j<len;++j)printf(\"%d \",dp[j]);puts(\"\");\n\t\tntt(dp,len,1);\n\t\tntt(c,len,1);\n\t\tfor(int j=0;j<len;++j)dp[j]=1ll*dp[j]*c[j]%mod;\n\t\tntt(dp,len,-1);\n\t\tfor(int j=0;j<cur+a[i]-b[i];++j)dp[j]=dp[j+cur-1];\n\t\tcur+=a[i]-b[i];\n//\t\tfor(int j=0;j<cur;++j)printf(\"%d \",dp[j]);\n\t\tfor(int j=cur;j<len;++j)dp[j]=0;\n//\t\tputs(\"\");\n\t}\n\tint ans=0;\n\tfor(int i=0;i<cur;++i)ans=(ans+dp[i])%mod;\n\tprintf(\"%d\\n\",ans);\n} "
        },
        {
            "language": 2,
            "solution": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 300001; //check the limits, dummy\n\nll modExp(ll base, ll power) {\n    if (power == 0) {\n        return 1;\n    } else {\n        ll cur = modExp(base, power / 2); cur = cur * cur; cur = cur % MOD;\n        if (power % 2 == 1) cur = cur * base;\n        cur = cur % MOD;\n        return cur;\n    }\n}\n\nll inv(ll base) {\n    int g = MOD, r = base, x = 0, y = 1;\n    while (r != 0) {\n        int q = g / r;\n        g %= r; swap(g, r);\n        x -= q * y; swap(x, y);\n    }\n    return x < 0 ? x+MOD : x;\n}\n\nll mul(ll A, ll B) {\n\treturn (A*B)%MOD;\n}\n\nll add(ll A, ll B) {\n\treturn (A+B)%MOD;\n}\n\nll dvd(ll A, ll B) {\n    return mul(A, inv(B));\n}\n\nll sub(ll A, ll B) {\n    return (A-B+MOD)%MOD;\n}\nnamespace NTT { //Source: Codeforces user neal\n    vector<ll> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    ll root;\n \n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n \n    int round_up_power_two(int n) {\n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n \n        return max(n, 1);\n    }\n \n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n \n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<ll> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n \n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n \n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n \n    void find_root() {\n        max_size = 1 << __builtin_ctz(MOD - 1);\n        root = 2;\n \n        // Find a max_size-th primitive root of MOD.\n        while (!(modExp(root, max_size) == 1 && modExp(root, max_size/2) != 1))\n            root++;\n    }\n \n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n \n        assert(n <= max_size);\n \n        if ((int) roots.size() >= n)\n            return;\n \n        int length = get_length(roots.size());\n        roots.resize(n);\n \n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            ll z = modExp(root, max_size >> (length+1));\n \n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = (roots[i] * z)%MOD;\n            }\n \n            length++;\n        }\n    }\n \n    void fft_iterative(int N, vector<ll> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n \n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    ll even = values[start + i];\n                    ll odd = values[start + n + i] * roots[n + i];\n                    odd %= MOD;\n                    values[start + n + i] = even - odd + MOD;\n                    values[start + i] = even + odd;\n                    values[start + n + i] %= MOD;\n                    values[start + i] %= MOD;\n                }\n    }\n \n    const int FFT_CUTOFF = 150;\n \n    vector<ll> mod_multiply(vector<ll> left, vector<ll> right) {\n        int n = left.size();\n        int m = right.size();\n \n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1, 0);\n \n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n \n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n \n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n \n            return vector<ll>(result.begin(), result.end());\n        }\n \n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n \n        bool equal = left == right;\n        fft_iterative(N, left);\n \n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n \n        ll inv_N = inv(N);\n\n        for (int i = 0; i < N; i++) {\n            left[i] *= (right[i] * inv_N)%MOD;\n            left[i] %= MOD;\n        }\n \n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n \n    vector<ll> mod_power(const vector<ll> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<ll> result = {1};\n \n        if (exponent == 0)\n            return result;\n \n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n \n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n \n        return result;\n    }\n \n    vector<ll> mod_multiply_all(const vector<vector<ll>> &polynomials) {\n        if (polynomials.empty())\n            return {1};\n \n        struct compare_size {\n            bool operator()(const vector<ll> &x, const vector<ll> &y) {\n                return x.size() > y.size();\n            }\n        };\n \n        priority_queue<vector<ll>, vector<vector<ll>>, compare_size> pq(polynomials.begin(), polynomials.end());\n \n        while (pq.size() > 1) {\n            vector<ll> a = pq.top(); pq.pop();\n            vector<ll> b = pq.top(); pq.pop();\n            pq.push(mod_multiply(a, b));\n        }\n \n        return pq.top();\n    }\n}\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\n\nmi facs[MX];\nmi facInvs[MX];\n\nmi choose(mi _a, mi _b) {\n    ll a = (ll) _a, b = (ll) _b;\n\tif (b > a) return 0;\n\tif (a < 0) return 0;\n\tif (b < 0) return 0;\n    mi cur = facs[a];\n    cur = cur * facInvs[b];\n    cur = cur * facInvs[a-b];\n    return cur;\n}\n\nvoid initFacs() {\n\tfacs[0] = 1;\n\tFOR(i, 1, MX) {\n\t\tfacs[i] = (facs[i-1] * i);\n\t}\n    facInvs[MX - 1] = inv(facs[MX-1]);\n    F0Rd(i, MX-1) {\n        facInvs[i] = facInvs[i+1] * (i+1);\n    }\n}\n\nvoid solve() {\n    initFacs();\n    int N; cin >> N;\n    vl dp{1};\n    F0R(i, N) {\n        int A, B; cin >> A >> B;\n        int X = sz(dp);\n        int lo = max(B-X-1, 0);\n        int hi = X+A-1;\n        vl vals;\n        FOR(i, lo, hi+1) {\n            vals.pb(choose(A+B, i).v);\n        }\n        vl res = NTT::mod_multiply(dp, vals);\n        while (sz(dp) < X+A-B) dp.pb(0);\n        while (sz(dp) > X+A-B) dp.pop_back();\n        F0R(i, sz(res)) {\n            if (i + lo >= B && i + lo < X+A) {\n                dp[i+lo-B] = res[i];\n            }\n        }\n        \n\n    }\n    mi ans = 0; F0R(i, sz(dp)) ans += dp[i];\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
        },
        {
            "language": 2,
            "solution": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\n//#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n#include <tuple>\n#include <memory>\n#include <random>\n#include <chrono>\n#include <sstream>\n\n#include <iterator>\n\n#define ull unsigned long long\n#define ll long long\n\n#define all(vec) vec.begin(), vec.end()\n#define pb push_back\n#define FOR(i,a,b) for(int i = a; i < b; ++i)\n#define printvec(vec) for(auto el: vec) {cout << el << \" \";}\n\nconstexpr long long INF = 200000000000000001LL;\nconstexpr int INF32 = 2100000001;\nsize_t seed42 = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 rng(seed42);\nstd::uniform_int_distribution<int> unidistrib;\nint randint() {return unidistrib(rng);}\n\nusing namespace std;\null modulo = 998244353 ;  // 1+7*17*2^23.\n//ull modulo = 1000000007 ;\nint modulo32 = 998244353;\n\n/*ull poww(ull x, ull n) {\n    if (n == 0)\n        return 1;\n    ull answ = poww(x, n/2);\n    answ = (answ * answ) % modulo;\n    if (n%2)\n        answ = (answ * x) % modulo;\n    return answ;\n}*/\n\nint poww(int a, int b) {\n    int res = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % modulo32)\n        if (b & 1)\n            res = 1ll * res * a % modulo32;\n    return res;\n}\n\n\n\n\n\npair<int, int> operator+ (const pair<int, int>& lhs, pair<int, int>& rhs) {\n    return {lhs.first +rhs.first, lhs.second + rhs.second};\n}\n\ntemplate <class T>\nostream& operator << (ostream& lhs, pair<T, T>& rhs) {\n    return (lhs << rhs.first<<\":\" << rhs.second);\n}\n\nvector<int> r;\n\nvector<int> fft(vector<int>& a, bool inv = false) {\n    size_t n = a.size();\n\n    //vector<int> r(n);\n    r.resize(n);\n    for (size_t k = 0; k < n; k++) {\n        size_t b = 0;\n        for (size_t z = 1; z < n; z *= 2) {\n            b *= 2;\n            if (k&z) ++b;\n        }\n        r[b] = a[k];\n    }\n    ull wm;\n\n    for (int m = 2; m <= n; m *= 2) {\n        if (!inv)\n            wm = poww(5ULL, (119ULL<<23)/m);\n        else\n            wm = poww(5ULL, (((119ULL<<23)/m) * (modulo-2))%(modulo-1));\n\n        for (int k = 0; k < n; k += m) {\n            ull w = 1;\n            for (int j = 0; j < m/2; j++) {\n                int u = r[k+j];\n                int t = (w*r[k+j+m/2])%modulo;\n                r[k+j] = (u+t)%modulo32;\n                r[k+j+m/2] = (u + modulo32 - t) % modulo32;\n                w = (w*wm)%modulo;\n            }\n        }\n    }\n    if (inv) {\n        ull ninv = poww(n, modulo-2);\n        for (int i = 0; i < n; i++)\n            r[i] = (ninv*r[i])%modulo;\n    }\n    return r;\n}\n\n\n\n\nint main() {\n    #ifdef DARTH\n    std::ifstream filestream(\"input.txt\");\n    std::cin.rdbuf(filestream.rdbuf());\n    #else\n    ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    #endif //DARTH\n\n    vector<ull> facc(200002,1), invfac(200002,1);\n    for(ull i = 2; i <= 200001; ++i) {\n        facc[i] = (i * facc[i-1]) % modulo;\n        invfac[i] = poww(facc[i], modulo-2);\n    }\n\n\n    auto Cnk = [&](int n, int k) {\n        if (k<0 || k> n)\n            return 0ULL;\n        return (((facc[n] * invfac[k]) % modulo) * invfac[n-k])%modulo;\n    };\n\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    FOR(i,0,n) {\n        cin >> a[i] >> b[i];\n    }\n\n\n    int maxsz = 1 << 14;\n    vector<int> answ (1, 1);\n    vector<int> cnk;\n    answ.reserve(1<<14);\n    cnk.reserve(1<<14);\n    r.reserve(1<<14);\n    //vector<ull> tmp(1<<14);\n\n    answ[0] = 1;\n    ull m = 1;\n\n    for(int i = 0; i < n; ++i) {\n        int maxj = 2 * m + a[i] - b[i];\n        //int maxjj =  2 *m + max(a[i] - b[i], 0);\n        int maxjpow2 = 1;\n        while (maxjpow2 < maxj)\n            maxjpow2<<=1;\n        answ.resize(maxjpow2, 0ULL);\n        cnk.resize(maxjpow2, 0ULL);\n\n        for (int jplusm = 0; jplusm < maxj; ++jplusm) {\n            cnk[jplusm] = Cnk(a[i] + b[i], b[i] + jplusm - m);\n            //cout << a[i] + b[i] - j << \" a[i] + b[i] - j\" <<  k << \"=\" << cnk[k] << \" \";\n        }\n\n        fill(cnk.begin()+maxj, cnk.end(), 0);\n\n        answ = fft(answ);\n        cnk = fft(cnk);\n\n        for (int j = 0; j < answ.size(); ++j) {\n            answ[j] = (answ[j]*1ULL*cnk[j]) % modulo;\n        }\n\n        answ = fft(answ, true);\n        copy(answ.begin() + m, answ.begin() + maxj, answ.begin());\n\n\n        m = m + a[i] - b[i];\n        fill(answ.begin() + m, answ.end(), 0);\n    }\n\n\n    cout  << (accumulate(answ.begin(), answ.begin()+m, 0ULL)) % modulo;\n    //cout << answ[3];\n    //printvec(answ);\n    return 0;\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <algorithm>\n#include <cassert>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <random>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return mod_inv(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n\ntemplate<const int &MOD>\nstruct NTT {\n    using ntt_int = _m_int<MOD>;\n\n    vector<ntt_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    ntt_int root;\n\n    void reset() {\n        roots = {0, 1};\n        max_size = -1;\n    }\n\n    static bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n\n    static int round_up_power_two(int n) {\n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n\n        return max(n, 1);\n    }\n\n    // Given n (a power of two), finds k such that n == 1 << k.\n    static int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n\n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<ntt_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n\n            for (int i = 1; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) | ((i & 1) << (length - 1));\n        }\n\n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n\n    void find_root() {\n        max_size = 1 << __builtin_ctz(MOD - 1);\n        root = 2;\n\n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n\n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n\n        assert(n <= max_size);\n\n        if ((int) roots.size() >= n)\n            return;\n\n        int length = get_length(roots.size());\n        roots.resize(n);\n\n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            ntt_int z = root.pow(max_size >> (length + 1));\n\n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n\n            length++;\n        }\n    }\n\n    void fft_iterative(int N, vector<ntt_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n\n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    ntt_int even = values[start + i];\n                    ntt_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n\n    void invert_fft(int N, vector<ntt_int> &values) {\n        ntt_int inv_N = ntt_int(N).inv();\n\n        for (int i = 0; i < N; i++)\n            values[i] *= inv_N;\n\n        reverse(values.begin() + 1, values.end());\n        fft_iterative(N, values);\n    }\n\n    const int FFT_CUTOFF = 150;\n\n    // Note: `circular = true` can be used for a 2x speedup when only the `max(n, m) - min(n, m) + 1` fully overlapping\n    // ranges are needed. It computes results using indices modulo the power-of-two FFT size; see the brute force below.\n    template<typename T>\n    vector<T> mod_multiply(const vector<T> &_left, const vector<T> &_right, bool circular = false) {\n        if (_left.empty() || _right.empty())\n            return {};\n\n        vector<ntt_int> left(_left.begin(), _left.end());\n        vector<ntt_int> right(_right.begin(), _right.end());\n\n        int n = left.size();\n        int m = right.size();\n\n        int output_size = circular ? round_up_power_two(max(n, m)) : n + m - 1;\n\n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            auto &&mod_output_size = [&](int x) {\n                return x < output_size ? x : x - output_size;\n            };\n\n            static const uint64_t U64_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(output_size, 0);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    int index = mod_output_size(i + j);\n                    result[index] += (uint64_t) (int64_t) left[i] * (int64_t) right[j];\n\n                    if (result[index] > U64_BOUND)\n                        result[index] %= MOD;\n                }\n\n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n\n            return vector<T>(result.begin(), result.end());\n        }\n\n        int N = round_up_power_two(output_size);\n        left.resize(N, 0);\n        right.resize(N, 0);\n\n        if (left == right) {\n            fft_iterative(N, left);\n            right = left;\n        } else {\n            fft_iterative(N, left);\n            fft_iterative(N, right);\n        }\n\n        for (int i = 0; i < N; i++)\n            left[i] *= right[i];\n\n        invert_fft(N, left);\n        return vector<T>(left.begin(), left.begin() + output_size);\n    }\n\n    template<typename T>\n    vector<T> mod_power(const vector<T> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<T> result = {1};\n\n        if (exponent == 0)\n            return result;\n\n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n\n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n\n        return result;\n    }\n\n    template<typename T>\n    vector<T> mod_multiply_all(const vector<vector<T>> &polynomials) {\n        if (polynomials.empty())\n            return {1};\n\n        struct compare_size {\n            bool operator()(const vector<T> &x, const vector<T> &y) {\n                return x.size() > y.size();\n            }\n        };\n\n        priority_queue<vector<T>, vector<vector<T>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\n        while (pq.size() > 1) {\n            vector<T> a = pq.top(); pq.pop();\n            vector<T> b = pq.top(); pq.pop();\n            pq.push(mod_multiply(a, b));\n        }\n\n        return pq.top();\n    }\n};\n\nNTT<MOD> ntt;\n\nauto random_address = [] { char *p = new char; delete p; return (uint64_t) p; };\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));\n\nconst int N = 3e5 + 10;\nmod_int fact[N],ifact[N];\n\nvoid init()\n{\n    fact[0] = 1;\n    \n    for(int i=1;i<N;i++) fact[i] = (fact[i-1]*i);\n    \n    ifact[N-1] = fact[N-1].inv();;\n    \n    for(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1]*(i+1);\n}\n\nmod_int ncr(int n,int r)\n{\n  if(r>n || r < 0) return (mod_int)0;\n  return fact[n]*ifact[r]*ifact[n-r];\n}\n\nint main() {\n\n    init();\n    \n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n,a,b;\n    cin >> n;\n    \n    vector<mod_int> cur = {1};\n    \n    while(n--)\n    {\n        cin >> a >> b;\n        \n        int sz = cur.size();\n        \n        int mn = b - sz + 1;\n        int mx = a + sz - 1;\n        \n        vector<mod_int> mult(mx - mn + 1);\n         for(int i=0;i<mx-mn+1;i++) mult[i] = ncr(a + b , mn + i);\n        \n        auto res = ntt.mod_multiply(cur,mult);\n        \n        cur.clear();\n        \n        for(int i=b;i<=sz+a-1;i++)\n            cur.push_back(res[i - mn]);\n    }\n        \n    mod_int res = 0;\n    for(auto x : cur) res += x;\n    cout << res;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 998244353\n#define MAXN 200500\n#define R1 3\n#define R2 332748118\n\ninline int add(int a, int b){return (a+b>=MOD)?a+b-MOD:a+b;}\ninline void inc(int& a, int b){a = add(a, b);}\ninline int sub(int a, int b){return (a-b<0)?a-b+MOD:a-b;}\ninline void dec(int &a, int b){a = sub(a, b);}\ninline int mul(int a, int b){return 1ll*a*b%MOD;}\ninline void grow(int &a, int b){a = mul(a, b);}\n\nint euclid(int a, int b, int &x, int &y){\n    if(b == 0){\n        x = 1, y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = euclid(b, a%b, x1, y1);\n    x = y1, y = x1-y1*(a/b);\n    return d;\n}\n\nint inv(int a){\n    int x, y;\n    euclid(a, MOD, x, y);\n    return (x%MOD+MOD)%MOD;\n}\n\nint binpow(int a, int pw){\n    int res = 1;\n    while(pw>0){\n        if(pw&1) grow(res, a);\n        grow(a, a);\n        pw >>= 1;\n    }\n    return res;\n}\n\nvoid ntt(vector<int> &a, bool invert){\n    int n = a.size();\n    for(int i = 1, j = 0; i<n; i++){\n        int bit = n>>1;\n        for(; j&bit; bit>>=1) j^=bit;\n        j ^= bit;\n        if(i < j) swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len<=n; len <<= 1){\n        int wlen = binpow((invert)?R2:R1, (MOD-1)/len);\n        for(int i = 0; i<n; i += len){\n            int w = 1;\n            for(int j = 0; j<len/2; j++){\n                int u = a[i+j], v = mul(a[i+j+len/2], w);\n                a[i+j] = add(u, v);\n                a[i+j+len/2] = sub(u, v);\n                grow(w, wlen);\n            }\n        }\n    }\n    if(invert){\n        int n1 = inv(n);\n        for(int &x : a) grow(x, n1);\n    }\n}\n\nvector<int> multiply(vector<int> &a, vector<int> &b){\n    vector<int> na(a.begin(), a.end()), nb(b.begin(), b.end());\n    int n = 1;\n    while(n < a.size()+b.size()) n <<= 1;\n    na.resize(n), nb.resize(n);\n    ntt(na, 0); ntt(nb, 0);\n    for(int i = 0; i<n; i++) grow(na[i], nb[i]);\n    ntt(na, 1);\n    return na;\n}\n\nint n;\nint fac[MAXN], invfac[MAXN];\nvector<pair<int, int>> arr;\n\nvoid init(){\n    fac[0] = 1;\n    for(int i = 1; i<MAXN; i++) fac[i] = mul(fac[i-1], i);\n    for(int i = 0; i<MAXN; i++) invfac[i] = inv(fac[i]);\n}\n\nint comb(int a, int b){\n    if(b < 0 || a < 0 || b > a) return 0;\n    return mul(fac[a], mul(invfac[b], invfac[a-b]));\n}\n\nvoid test(){\n    vector<int> p1 = {1, 1}; vector<int> p2 = {1, 1};\n    vector<int> res = multiply(p1, p2);\n    for(auto x : res) cout << x << \" \";\n    cout << endl;\n}\n\nint main(){\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); init();\n    cin >> n; arr.resize(n);\n    for(int i = 0; i<n; i++) cin >> arr[i].first >> arr[i].second;\n    // test();\n    vector<int> ans; ans.push_back(1);\n    int cur = 1;\n    for(int i = 0; i<n; i++){\n        int a = arr[i].first, b = arr[i].second;\n        int nxt = cur+a-b;\n        int l = b-cur+1, r = a+b-l;\n        // cout << l << \" \" << r << endl;\n        vector<int> poly;\n        for(int j = l; j<=r; j++) poly.push_back(comb(a+b, j));\n        ans = multiply(ans, poly);\n        ans = vector<int>(ans.begin()+cur-1, ans.begin()+cur-1+nxt);\n        cur = nxt;\n    }\n    int res = 0;\n    for(auto x : ans) inc(res, x);\n    cout << res << endl;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)\n#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)\n#define ll long long\n#define db double\n#define pii pair<int, int>\n#define mkp make_pair\nusing namespace std;\nconst int N = 2e5 + 7;\nconst int mod = 998244353;\nconst int G = 3;\nconst int iG = (mod + 1) / G;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint pp[N];\nvoid polyinit(int len) {\n\tL(i, 0, len - 1) pp[i] = ((pp[i >> 1] >> 1) | ((i & 1) * (len >> 1)));\n}\nvoid NTT(int *f, int len, int flag) {\n\tL(i, 0, len - 1) if(pp[i] < i) swap(f[pp[i]], f[i]);\n\tfor(int i = 2; i <= len; i <<= 1) \n\t\tfor(int j = 0, l = (i >> 1), ch = qpow(flag == 1 ? G : iG, (mod - 1) / i); j < len; j += i) \n\t\t\tfor(int k = j, now = 1; k < j + l; k ++) {\n\t\t\t\tint pa = f[k], pb = (ll) f[k + l] * now % mod;\n\t\t\t\tf[k] = (pa + pb) % mod, f[k + l] = (pa + mod - pb) % mod;\n\t\t\t\tnow = (ll) now * ch % mod;\n\t\t\t}\n\tif(flag == -1) {\n\t\tint nylen = qpow(len);\n\t\tL(i, 0, len - 1) f[i] = (ll) f[i] * nylen % mod;\n\t}\n}\nint up(int x) {\n\tint lim = 1;\n\tfor(; lim <= x; lim <<= 1);\n\treturn lim;\n}\nint fac[N], ifac[N];\nint C(int x, int y) {\n\tif(y < 0 || y > x) return 0;\n\treturn (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nvoid math_init(int x) {\n\tfac[0] = 1;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod;\n\tifac[x] = qpow(fac[x]);\n\tR(i, x, 1) ifac[i - 1] = (ll) ifac[i] * i % mod;\n}\nint n, dp[2][N], a[N], b[N];\nint A[N], B[N];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcin >> n;\n\tmath_init(200000);\n\tint bf = 0, now = 0;\n\tdp[0][0] = 1;\n\tL(i, 1, n) {\n\t\tbf ^= 1;\n\t\tmemset(dp[bf], 0, sizeof(dp[bf]));\n\t\tcin >> a[i] >> b[i];\n\t\tint las = now;\n\t\tnow += a[i] - b[i];\n\t\t\n\t\tint mx = max(now, las), lim = up(now + las + mx);\n\t\t\n\t\tL(j, 0, lim - 1) A[j] = B[j] = 0; \n\t\tL(j, 0, las) A[j] = dp[bf ^ 1][j];\n\t\tL(j, -mx, mx) B[j + mx] = C(a[i] + b[i], b[i] + j);\n\t\tpolyinit(lim);\n\t\tNTT(A, lim, 1), NTT(B, lim, 1);\n\t\tL(j, 0, lim - 1) A[j] = (ll) A[j] * B[j] % mod;\n\t\tNTT(A, lim, -1);\n\t\tL(j, 0, now) dp[bf][j] = A[j + mx];\n\t}\n\tint sum = 0;\n\tL(i, 0, now) (sum += dp[bf][i]) %= mod;\n\tcout << sum << endl;\n\treturn 0;\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nnamespace NTT {\n\tconst int BIT = 16, MAXN = 1 << BIT;\n    const int MOD = 998244353, G = 3;\n    int w[2][MAXN], inv[MAXN], hasinit;//power table\n    int modpow(int a, int b) {\n        int res = 1;\n        for (; b; b >>= 1) {\n            if (b & 1) res = (LL)res * a % MOD;\n            a = (LL)a * a % MOD;\n        }\n        return res;\n    }\n    void init() {\n        hasinit = 1;\n        int mul = modpow(G, (MOD - 1) >> BIT);\n        for (int i = w[0][0] = 1; i < MAXN; i++) w[0][i] = (LL)w[0][i - 1] * mul % MOD;\n        mul = modpow(G, MOD - 1 - ((MOD - 1) >> BIT));\n        for (int i = w[1][0] = 1; i < MAXN; i++) w[1][i] = (LL)w[1][i - 1] * mul % MOD;\n        inv[1] = 1;\n        for (int i = 2; i < MAXN; i++) inv[i] = MOD - (LL)MOD / i * inv[MOD % i] % MOD;\n    }\n    int get_tpow(int n) {//return min{2^k|2^k>=n}\n        int k = 1;\n        while (k < n) k <<= 1;\n        return k;\n    }\n    void ntt(int *b, int n, int rev) {\n        if (!hasinit) init();\n        typedef unsigned long long ull;\n        static ull a[MAXN]; static int ww[MAXN];\n        const ull mmod = (ull)MOD * MOD; const int *W = w[rev];\n        for (int i = 0, j = 0; i < n; i++) {\n            a[i] = b[j];\n            for (int k = n >> 1; (j ^= k) < k; k >>= 1);\n        }\n        int n0 = __builtin_ctz(n);\n        if (n0 & 1) {\n            for (int i = 0; i < n; i += 2) {\n                const ull x = a[i], y = a[i + 1];\n                a[i] = x + y, a[i + 1] = x + MOD - y;\n            }\n        }\n        for (int h = n0 & 1 ? 4 : 2; h <= n; h <<= 2) {\n            int hh = h >> 1, t = (1 << BIT) / h >> 1;\n            for (int i = 0; i < h; i++) ww[i] = W[i * t];\n            for (int i = 0; i < n; i += h << 1) {\n                ull *ax = a + i, *ay = a + i + hh, *au = a + i + h, *av = a + i + h + hh;\n                register int *aw = ww, *bw = ww, *cw = ww + hh;\n                for (register int j = i; j < i + hh; ++j, ++ax, ++ay, ++au, ++av, aw += 2, ++bw, ++cw) {\n                    const ull x = *ax, y = *ay % MOD * *aw, u = *au, v = *av % MOD * *aw;\n                    const ull p = x + y, q = x + mmod - y, o = (u + v) % MOD * *bw, r = (u + mmod - v) % MOD * *cw;\n                    *ax = p + o, *ay = q + r, *au = p + mmod - o, *av = q + mmod - r;\n                }\n            }\n            if (h == 65536 || h == 32768) for (int j = 0; j < n; j++) a[j] %= MOD;\n        }\n        for (int i = 0; i < n; i++) b[i] = a[i] % MOD;\n        if (rev) {\n            int inv = modpow(n, MOD - 2);\n            for (int i = 0; i < n; i++) b[i] = (LL)b[i] * inv % MOD;\n        }\n    }\n    //reset a polynomial to zero\n    void reset(int *a, int n) { memset(a, 0, sizeof(int) * n); }\n    //copy polynomial a to b\n    void copy(int *a, int *b, int n) { memcpy(b, a, sizeof(int) * n); }\n    //get multiplication of two polynomial in O(nlogn)\n    void get_mul(int *a, int *b, int *c, int n, int m, int p) {\n        if ((LL)n * m <= 4096) {\n            typedef unsigned long long ull;\n            static ull res[MAXN];\n            for (int i = 0; i < p; i++) res[i] = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m && i + j < p; j++) res[i + j] += (ull)a[i] * b[j];\n                if (!(i & 15)) for (int j = 0; j < p; j++) res[j] %= MOD;\n            }\n            for (int i = 0; i < p; i++) c[i] = res[i] % MOD;\n        } else {\n            static int A[MAXN], B[MAXN];\n            int len = get_tpow(n + m - 1);\n            reset(A, len), reset(B, len);\n            copy(a, A, n), copy(b, B, m);\n            ntt(A, len, 0), ntt(B, len, 0);\n            for (int i = 0; i < len; i++) A[i] = (LL)A[i] * B[i] % MOD;\n            ntt(A, len, 1);\n            copy(A, c, p);\n        }\n    }\n}\n\nconst int MAXN = 5005, MAXM = 200005, MOD = 998244353;\nLL fac[MAXM], inv[MAXM], f[MAXN], g[MAXN];\nint n, a[MAXN], b[MAXN], A[MAXN << 1], B[MAXN << 1];\nLL modpow(LL a, int b) {\n\tLL res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tint n = 2e5;\n\tfor (int i = fac[0] = 1; i <= n; i++) fac[i] = fac[i - 1] * i % MOD;\n\tinv[n] = modpow(fac[n], MOD - 2);\n\tfor (int i = n; i > 0; i--) inv[i - 1] = inv[i] * i % MOD;\n}\n\nLL C(int a, int b) {\n\treturn a < b ? 0 : fac[a] * inv[b] % MOD * inv[a - b] % MOD;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d\", &n);\n\tint m = 1;\n\tf[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", a + i, b + i);\n\t\tif (a[i] >= b[i]) {\n\t\t\tfor (int j = b[i] + 1; j <= a[i]; j++) {\n\t\t\t\tmemset(g, 0, sizeof(g));\n\t\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\t\t(g[k] += f[k]) %= MOD;\n\t\t\t\t\t(g[k + 1] += f[k]) %= MOD;\n\t\t\t\t}\n\t\t\t\tmemcpy(f, g, sizeof(g));\n\t\t\t\t++m;\n\t\t\t}\n\t\t\ta[i] = b[i];\n\t\t}\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(A, 0, sizeof(A));\n\t\tmemset(B, 0, sizeof(B));\n\t\tfor (int j = 1; j <= m; j++) A[j] = f[j];\n\t\tfor (int j = 0; j <= m; j++) B[j] = C(2 * a[i], a[i] + j);\n\t\tNTT::get_mul(A, B, A, m + 1, m + 1, m + 1);\n\t\tfor (int j = 1; j <= m; j++) g[j] = A[j];\n\t\tmemset(A, 0, sizeof(A));\n\t\tfor (int j = 1; j <= m; j++) A[j] = f[j];\n\t\treverse(A, A + m + 1);\n\t\tNTT::get_mul(A, B, A, m + 1, m + 1, m * 2 + 1);\n\t\tfor (int j = 1; j <= m; j++) g[j] = (g[j] + A[m - j]) % MOD;\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tg[j] = (g[j] + C(2 * a[i], a[i]) * (MOD - f[j])) % MOD;\n\t\tmemcpy(f, g, sizeof(g));\n\t\tfor (int j = a[i] + 1; j <= b[i]; j++) {\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int k = 1; k < m; k++)\n\t\t\t\tg[k] = (f[k] + f[k + 1]) % MOD;\n\t\t\tmemcpy(f, g, sizeof(g));\n\t\t\t--m;\n\t\t}\n\t}\n\tLL ans = 0;\n\tfor (int i = 1; i <= m; i++) ans = (ans + f[i]) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nconst int lim = 3e5;\nconst int maxn = 32768 + 177;\nconst int mod = 998244353;\n\nusing ll = long long;\n\nint fac[lim + 17],ifac[lim + 17],n,a[maxn],b[maxn],ans,f[maxn],g[maxn],h[maxn];\n\nint rev[maxn<<2];\n\nint qpow(int a,int b) {\n\tif (b == 0) return 1;\n\tll d = qpow(a,b>>1); d = d * d % mod;\n\tif (b&1) d = d * a % mod;\n\treturn d;\n}\n\nvoid NTT( int *a, int lim, int flag ) {\n\tfor (int i = 1; i < lim; ++ i) rev[i] = (rev[i>>1]>>1) | (i&1) * (lim>>1);\n\tfor (int i = 0; i < lim; ++ i) if (i < rev[i]) std::swap(a[i], a[rev[i]]);\n\tfor (int i = 1; i < lim; i <<= 1) {\n\t\tint wn = qpow(3,(mod-1)/(i<<1));\n\t\tif (flag == -1) wn = qpow(wn, mod - 2);\n\t\tfor (int j = 0; j < lim; j += (i<<1)) {\n\t\t\tfor (int k = 0, w = 1; k < i; w=(ll)w*wn%mod,++k) {\n\t\t\t\tint a1 = a[j+k], a2 = (ll) w * a[j+k+i] % mod;\n\t\t\t\ta[j+k] = (a1 + a2) % mod; a[j+k+i] = (a1 - a2 + mod) % mod;\n\t\t\t}\n\t\t}\n\t} if (flag == -1) \n\t\tfor (int i = 0,inv=qpow(lim,mod-2); i < lim; ++i) a[i] = (ll) a[i] * inv % mod;\n}\n\n\nint main() {\n\tscanf(\"%d\",&n);\n\tint curL = 1;\n\tf[1] = 1;\n\tfac[0] = ifac[0] = ifac[1] = 1;\n\tfor (int i = 1; i <= lim; ++ i) fac[i] = (ll) fac[i-1] * i % mod;\n\tfor (int i = 2; i <= lim; ++ i) ifac[i] = (ll) (mod - mod / i ) * ifac[mod % i] % mod;\n\tfor (int i = 1; i <= lim; ++ i) ifac[i] = (ll) ifac[i - 1] * ifac[i] % mod;\n\tauto binom = [&](int n,int m) {\n\t\tif (n < m || n < 0 || m < 0) return 0ll;\n\t\treturn (ll) fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n\t};\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tint nxtL = curL + a[i] - b[i];\n\t\tint N = curL + a[i];\n\t\tstd::memset(g,0,sizeof(g));\n\t\tint L = 2 * N - curL - nxtL;\n\t\tstd::memset(h,0,sizeof(h));\n\t\tfor (int i = 1; i <= curL + nxtL; ++ i) \n\t\tif (N - i + 1 >= 0 && (L - (N - i + 1)) >= 0)\n\t\t\th[i] = (ll) ifac[N - i + 1] * ifac[L - (N - i + 1)] % mod;\n\t\tstd::reverse(f + 1, f + curL + 1);\n\t\tint lm = 1; while (lm <= nxtL + curL + curL) lm <<= 1;\n\t\tNTT(f,lm,1); NTT(h,lm,1);\n\t\tfor (int i = 0; i < lm; ++ i) g[i] = (ll) f[i] * h[i] % mod;\n\t\tNTT(g,lm,-1);\n\t\tstd::memset(f,0,sizeof(f));\n\t\tfor (int i = 1; i <= nxtL; ++ i) f[i] = (ll) g[curL + 1 + i] * fac[L] % mod;\n\t\tcurL = nxtL;\n\t}\n\tfor (int i = 1; i <= curL; ++ i) ans = (ans + f[i]) % mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\n#define go(i,a,b) for(int i=a;i< b;i++)\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int X=2e5,N=33e3,mo=998244353;\nint fac[X+9],ivf[X+9],n,a,b,m=1,m1,n1,f[2][N],g[N],ans;\nvoid P(int&x,ll y) {x=(x+y)%mo;}\nvoid T(int&x,ll y) {x=x*y%mo;}\nint ksm(int x,int y=mo-2) {int a=1; for(;y;y/=2,T(x,x)) if(y&1)T(a,x); return a;}\nint C(int n,int m) {return m>=0&&m<=n?1ll*fac[n]*ivf[m]%mo*ivf[n-m]%mo:0;}\nnamespace NTT\n{\n\tint tf[N],w[N],o;\n\tvoid build(int n)\n\t{\n\t\to=__builtin_ctz(n);\n\t\tgo(i,1,n) tf[i]=tf[i/2]+n*(i&1)>>1;\n\t\tfor(int i=1;i<n;i*=2)\n\t\t{\n\t\t\tint v=ksm(3,(mo-1)/2/i); w[i]=1;\n\t\t\tgo(j,1,i) w[i+j]=1ll*w[i+j-1]*v%mo;\n\t\t}\n\t}\n\tvoid DFT(int a[N],int n,bool f)\n\t{\n\t\tstatic unsigned long long b[N];\n\t\tint u=o-__builtin_ctz(n),v;\n\t\tgo(i,0,n) b[i]=a[tf[i]>>u];\n\t\tfor(int i=1;i<n;i*=2) for(int j=0;j<n;j+=2*i) go(k,0,i)\n\t\t\tv=b[i+j+k]*w[i+k]%mo, b[i+j+k]=b[j+k]-v+mo, b[j+k]+=v;\n\t\tgo(i,0,n) a[i]=b[i]%mo;\n\t\tif(f)\n\t\t{\n\t\t\treverse(a+1,a+n);\n\t\t\tv=mo-(mo-1)/n;\n\t\t\tgo(i,0,n) T(a[i],v);\n\t\t}\n\t}\n\tvoid mtp(int a[N],int b[N],int n)\n\t{\n\t\tDFT(a,n,0); DFT(b,n,0);\n\t\tgo(i,0,n) T(a[i],b[i]);\n\t\tDFT(a,n,1);\n\t}\n}\nint main()\n{\n\tfac[0]=1;\n\tfo(i,1,X) fac[i]=1ll*fac[i-1]*i%mo;\n\tivf[X]=ksm(fac[X]);\n\tfd(i,X,1) ivf[i-1]=1ll*ivf[i]*i%mo;\n\tNTT::build(32768);\n\tscanf(\"%d\",&n); f[0][1]=1;\n\tfo(i,1,n)\n\t{\n\t\tscanf(\"%d%d\",&a,&b); m1=m+a-b;\n\t\tint I=i&1;\n\t\tfor(n1=1;n1/2<=m+m1+1;n1*=2);\n\t\tmemset(g,0,4*n1);\n\t\tfo(j,0,m+m1) g[j]=C(a+b,b+j-m);\n\t\tNTT::mtp(g,f[!I],n1);\n\t\tmemset(f[!I],0,4*n1);\n\t\tfo(j,1,m+a-b) f[I][j]=g[j+m];\n\t\tm=m1;\n\t}\n\tfo(i,1,m) P(ans,f[n&1][i]);\n\tprintf(\"%d\",ans);\n}\n  \t"
        },
        {
            "language": 2,
            "solution": "/**\n *  created: 14/01/2021, 18:07:05\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream &os, const vector<T> &v) {\n    os << \"[\";\n    for (int i = 0; i < v.size(); ++i) {\n        if (i) {\n            os << \" \";\n        }\n        os << v[i];\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int max_lev = 20, mod = 998244353;\n\ntemplate<int mod, int max_lev>\nstruct NTT {\n    static const int max_n = 1 << max_lev;\n\n    int roots[2][max_lev];\n    int rev[max_n], buf1[max_n], buf2[max_n], bufpw[max_n];\n\n    NTT() {\n        int root = find_root();\n        int rroot = power(root, mod - 2);\n        roots[0][0] = root;\n        roots[1][0] = rroot;\n        for (int i = 1; i < max_lev; ++i) {\n            roots[0][i] = mul(roots[0][i - 1], roots[0][i - 1]);\n            roots[1][i] = mul(roots[1][i - 1], roots[1][i - 1]);\n        }\n        for (int i = 1; i < max_n; ++i) {\n            rev[i] = (rev[i / 2] / 2) + ((i & 1) << (max_lev - 1));\n        }\n    }\n\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, max_n) == 1) {\n                int cur = 1;\n                bool ok = true;\n                for (int i = 1; i < max_n; ++i) {\n                    cur = mul(cur, root);\n                    if (cur == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) {\n                    return root;\n                }\n            }\n        }\n    }\n\n    void fft(int *a, const int *roots, int lg) {\n        const int n = 1 << lg;\n        for (int i = 0; i < n; ++i) {\n            int r = (rev[i] >> (max_lev - lg)) & (n - 1);\n            if (i < r) {\n                swap(a[i], a[r]);\n            }\n        }\n        int pos = max_lev - 1;\n        for (int st = 1; st < n; st *= 2) {\n            int cur = 1;\n            for (int i = 0; i < st; ++i) {\n                bufpw[i] = cur;\n                cur = mul(cur, roots[pos]);\n            }\n            --pos;\n            for (int i = 0; i < n; i += 2 * st) {\n                int *curpw = bufpw;\n                for (int j = i; j < i + st; ++j) {\n                    int y = mul(*curpw++, a[j + st]);\n                    a[j + st] = a[j];\n                    inc(a[j + st], mod - y);\n                    inc(a[j], y);\n                }\n            }\n        }\n    }\n\n    vector<int> product(const vector<int> &a, const vector<int> &b) {\n        int sz = a.size() + b.size() - 1;\n        int n = 1, rn = 1, lg = 0;\n        while (n < sz) {\n            n *= 2;\n            rn = mul(rn, (mod + 1) / 2);\n            ++lg;\n        }\n        memcpy(buf1, a.data(), 4 * a.size());\n        memset(buf1 + a.size(), 0, 4 * (n - a.size()));\n        memcpy(buf2, b.data(), 4 * b.size());\n        memset(buf2 + b.size(), 0, 4 * (n - b.size()));\n        fft(buf1, roots[0], lg);\n        fft(buf2, roots[0], lg);\n        for (int i = 0; i < n; ++i) {\n            buf1[i] = mul(buf1[i], buf2[i]);\n        }\n        fft(buf1, roots[1], lg);\n        vector<int> ans(sz);\n        for (int i = 0; i < sz; ++i) {\n            ans[i] = mul(buf1[i], rn);\n        }\n        return ans;\n    }\n\n    vector<int> square(const vector<int> &a) {\n        int sz = a.size() + a.size() - 1;\n        int n = 1, rn = 1, lg = 0;\n        while (n < sz) {\n            n *= 2;\n            rn = mul(rn, (mod + 1) / 2);\n            ++lg;\n        }\n        memcpy(buf1, a.data(), 4 * a.size());\n        memset(buf1 + a.size(), 0, 4 * (n - a.size()));\n        fft(buf1, roots[0], lg);\n        for (int i = 0; i < n; ++i) {\n            buf1[i] = mul(buf1[i], buf1[i]);\n        }\n        fft(buf1, roots[1], lg);\n        vector<int> ans(sz);\n        for (int i = 0; i < sz; ++i) {\n            ans[i] = mul(buf1[i], rn);\n        }\n        return ans;\n    }\n};\n\nNTT<mod, max_lev> ntt;\n\ninline void inc(int &x, int y) {\n    x += y;\n    if (x >= mod) {\n        x -= mod;\n    }\n}\n\ninline void dec(int &x, int y) {\n    x -= y;\n    if (x < 0) {\n        x += mod;\n    }\n}\n\ninline int mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    int res = 1 % mod;\n    while (b) {\n        if (b % 2) {\n            res = mul(res, a);\n        }\n        b /= 2;\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nstring str_fraq(int x, int n = 20) {\n    stringstream res;\n    pair<int, int> best(x, 1);\n    for (int j = 1; j < n; ++j) {\n        best = min(best, {mul(x, j), j});\n    }\n    res << best.first << \"/\" << best.second;\n    return res.str();\n}\n\nconst int max_f = 200111;\n\nint f[max_f], rf[max_f];\n\nvoid get_all_f() {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < max_f; ++i) {\n        f[i] = mul(i, f[i - 1]);\n    }\n    rf[max_f - 1] = inv(f[max_f - 1]);\n    for (int i = max_f - 2; i > 0; --i) {\n        rf[i] = mul(i + 1, rf[i + 1]);\n    }\n}\n\nint get_c(int n, int k) {\n    if (n < k || k < 0) {\n        return 0;\n    }\n    return mul(f[n], mul(rf[k], rf[n - k]));\n}\n\nint n;\n\nconst bool debug = 0;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    get_all_f();\n    if (debug) {\n        n = 1000;\n    } else {\n        cin >> n;\n    }\n    vector<int> dp{1};\n    while (n--) {\n        int a = 100000, b = 100000 - 5;\n        if (!debug) {\n            cin >> a >> b;\n        }\n        vector<int> ndp(dp.size() + a - b);\n        vector<int> d(dp.size() + ndp.size() - 1);\n        const int shift = dp.size() - 1;\n        for (int pos = 0; pos < d.size(); ++pos) {\n            const int k = pos - shift;\n            d[pos] = get_c(a + b, b + k);\n            continue;\n            for (int j = 0; j <= b; ++j) {\n                const int i = k + j;\n                if (0 <= i && i <= a) {\n                    inc(d[pos], mul(get_c(a, i), get_c(b, j)));\n                }\n            }\n        }\n        /*for (int i = 0; i <= a; ++i) {\n            for (int j = 0; j <= b; ++j) {\n                const int pos = shift + i - j;\n                if (0 <= pos && pos < d.size()) {\n                    inc(d[pos], mul(get_c(a, i), get_c(b, j)));\n                }\n            }\n        }*/\n        vector<int> C = ntt.product(dp, d);\n        for (int i = 0; i < C.size(); ++i) {\n            int pos = i - shift;\n            if (0 <= pos && pos < ndp.size()) {\n                inc(ndp[pos], C[i]);\n            }\n        }\n        dp.swap(ndp);\n        //cout << dp << \", d = \" << d << endl;\n    }\n    int ans = accumulate(dp.begin(), dp.end(), 0LL) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#include\"map\"\n#include\"string\"\n#include\"cmath\"\n#include\"cstdio\"\n#include\"iostream\"\n#include\"cstring\"\n#include\"algorithm\"\n#include\"vector\"\n//#pragma GCC optimize(3, \"Ofast\")\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, ll> pii;\ninline int read() {\n\tint s = 0, w = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch>'9') { if (ch == '-')w = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * w;\n}\n#ifdef local\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n#define f(i, l, r) for (int i = l; i <= r; ++i)\n#define rf(i, r, l) for (int i = r; i >= l; --i)\n#define all(x) (x).begin(), (x).end()\n#define l l\n#define r r\n#define lch (o << 1)\n#define rch (o << 1 | 1)\n#define mid ((l + r) >> 1)\n#define mem(x, y) memset(x, y, sizeof(x))\n#define mod1(x) ((x >= mod) && (x -= mod))\n#define mod2(x) ((x < 0) && (x += mod))\n\nconst int inf = 2e9 + 7;\n//const ll INF = INT64_MAX;\ndouble eps = 1e-6;\nconst int mod = 998244353;\nconst int N = 2e5 + 10;\nconst double pi = acos(-1.0);\nll power(ll a, ll b) { ll res = 1; while (b) { if (b & 1)res = res * a % mod; a = a * a % mod; b >>= 1; }return res; }\nll gcd(ll a, ll b) { return !b ? a : gcd(b, a % b); }\nll exgcd(ll a, ll b, ll& x, ll& y) { ll c; return !b ? (x = 1, y = 0, a) : (c = exgcd(b, a % b, y, x), y -= (a / b) * x, c); }\nll INV(ll a) { ll x, y; exgcd(a, mod, x, y); x %= mod; if (x < 0)x += mod; return x; }\n/*int len, C[N], clen;\nint id(int v) { return lower_bound(C + 1, C + len, v) - C; }\nvoid initC() { sort(C + 1, C + clen+1); len = unique(C + 1, C + 1 + clen) - C - 1; }*/\n\n\ntypedef unsigned int uint;\nnamespace Poly {\n\ttypedef vector<uint> poly;\n\tconstexpr uint Max_size = 1 << 21 | 5;\n\tconstexpr int gn = 3;\n\tinline uint mf(uint x)\n\t{\n\t\treturn (static_cast<ll>(x) << 32) / mod;\n\t}\n\tint sz;\n\tuint w[Max_size], w_mf[Max_size];\n\tinline void init(int n)\n\t{\n\t\tfor (sz = 2; sz < n; sz <<= 1);\n\t\tuint pr = power(gn, (mod - 1) / sz);\n\t\tw[sz / 2] = 1, w_mf[sz / 2] = mf(w[sz / 2]);\n\t\tfor (int i = 1; i < sz / 2; ++i)\n\t\t\tw[sz / 2 + i] = (ll)w[sz / 2 + i - 1] * pr % mod, w_mf[sz / 2 + i] = mf(w[sz / 2 + i]);\n\t\tfor (int i = sz / 2 - 1; i; --i)\n\t\t\tw[i] = w[i << 1], w_mf[i] = w_mf[i << 1];\n\t}\n\tinline void NTT(poly& A, const int L)\n\t{\n\t\tfor (int d = L >> 1; d; d >>= 1)\n\t\t\tfor (int i = 0; i != L; i += d << 1)\n\t\t\t\tfor (int j = 0; j != d; ++j)\n\t\t\t\t{\n\t\t\t\t\tuint x = A[i + j] + A[i + d + j];\n\t\t\t\t\tif (x >= mod * 2)\n\t\t\t\t\t\tx -= mod * 2;\n\t\t\t\t\tll t = A[i + j] + mod * 2 - A[i + d + j];\n\t\t\t\t\tll q = t * w_mf[d + j] >> 32;\n\t\t\t\t\tuint y = t * w[d + j] - q * mod;\n\t\t\t\t\tA[i + j] = x, A[i + d + j] = y;\n\t\t\t\t}\n\t}\n\tinline void INTT(poly& A, const int L)\n\t{\n\t\tfor (int d = 1; d != L; d <<= 1)\n\t\t\tfor (int i = 0; i != L; i += d << 1)\n\t\t\t\tfor (int j = 0; j != d; ++j)\n\t\t\t\t{\n\t\t\t\t\tuint x = A[i + j];\n\t\t\t\t\tif (x >= mod * 2)\n\t\t\t\t\t\tx -= mod * 2;\n\t\t\t\t\tll y = A[i + d + j];\n\t\t\t\t\tll q = y * w_mf[d + j] >> 32;\n\t\t\t\t\tll t = y * w[d + j] - q * mod;\n\t\t\t\t\tA[i + j] = x + t, A[i + d + j] = x + mod * 2 - t;\n\t\t\t\t}\n\t\treverse(A.begin() + 1, A.end());\n\t\tint k = __builtin_ctz(L);\n\t\tfor (int i = 0; i != L; ++i)\n\t\t{\n\t\t\tll m = -A[i] & (L - 1);\n\t\t\tA[i] = (A[i] + m * mod) >> k;\n\t\t}\n\t}\n\tpoly operator*(poly a, poly b) {\n\t\tint n = a.size() + b.size() - 1, R = 2;\n\t\tfor (; R <= n; R <<= 1); init(R);\n\t\ta.resize(R), b.resize(R);\n\t\tNTT(a, R); NTT(b, R);\n\t\tf(i, 0, R - 1)a[i] = 1ll * b[i] * a[i] % mod;\n\t\tINTT(a, R); a.resize(n);\n\t\tf(i, 0, n - 1)if (a[i] >= mod)a[i] -= mod;\n\t\treturn a;\n\t}\n}; using namespace Poly;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef local\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tint start = clock();\n#endif\n\tint n; cin >> n;\n\tconst int N2 = 4e5;\n\tvector<ll> fac(N2+1), ifac(fac);\n\tfac[0] = 1; f(i, 1, N2)fac[i] = fac[i - 1] * i % mod;\n\tifac[N2] = power(fac[N2], mod - 2);\n\trf(i, N2-1, 0)ifac[i] = ifac[i + 1] * (i + 1) % mod;\n\tpoly res; res.push_back(1);\n\tf(i, 1, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tint m = res.size();\n\t\tint m2 = m + a - b;\n\t\tpoly F;\n\t\tf(j, max(0, b - (m-1)), min(a+(m-1), a + b)) {\n\t\t\tF.push_back(fac[a + b] * ifac[j] % mod * ifac[a + b - j] % mod);\n\t\t}\n\t\tres = res * F;\n\t\tint yu = (res.size() - m2) / 2;\n\t\tres.erase(res.end() - yu, res.end());\n\t\tres.erase(res.begin(), res.begin() + yu);\n\t}\n\tll ans = 0;\n\tfor (auto I : res)ans += I;\n\tcout << ans % mod;\n#ifdef local\n\tint end = clock();\n\t//cout << '\\n' << end - start << \"ms\";\n#endif* /\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define REPI(i,a,b) for(ll i=b-1;i>=a;i--)\n#define PB push_back\n#define DB pop_back\n#define V(a) vector<a>\n\nstatic const int N=(1<<20)+5, M=998244353, G=3;\nstatic int fc[N],fci[N],inv[N],rev[N],rt[N];\n\nint powM(int x,int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1)\n            ans=1LL*ans*x%M;\n        x=1LL*x*x%M;\n        y>>=1;\n    }\n    return ans;\n}\n\nvoid fft(V(ll) &a,ll n,bool invert)\n{\n    for(int i=1; i<n; i++)\n    {\n        if(rev[n+i]>i)\n        {\n            swap(a[i],a[rev[n+i]]);\n        }\n    }\n    for(int s=1; s<n; s<<=1)\n    {\n        ll y=powM(G, (M-1)/(s<<1) );\n        for(int j=0; j<n; j+=(s<<1))\n        {\n            ll r=1;\n            for(int i=0; i<s; i++)\n            {\n                ll u=a[i+j];\n                ll v=(r*a[i+j+s])%M;\n\n                a[i+j]=u+v;\n                if(a[i+j]>M) a[i+j]-=M;\n\n                a[i+j+s]=u-v;\n                if(a[i+j+s]<0) a[i+j+s]+=M;\n\n                r*=y;\n                r%=M;\n            }\n        }\n    }\n    if(invert)\n    {\n        int invn=inv[n];\n        REP(i,0,n)\n        {\n            a[i]=(a[i]*invn)%M;\n        }\n        reverse(a.begin()+1,a.end());\n    }\n    return;\n}\n\nvoid PolyMult(V(ll) &a,V(ll) &b,V(ll) &v)\n{\n    ll n=1;\n    while(n<((ll)a.size())+((ll)b.size()))\n    { \n        n<<=1;\n    }\n    V(ll) fa(a.begin(),a.end());\n    fa.resize(n,0);\n    V(ll) fb(b.begin(),b.end());\n    fb.resize(n,0);\n    // cout<<\"fa\"<<endl;\n    // for(auto it:fa) cout<<it<<' ';cout<<endl;\n    // cout<<\"fb\"<<endl;\n    // for(auto it:fb) cout<<it<<' ';cout<<endl;\n    fft(fa,n,false);\n    fft(fb,n,false);\n    // cout<<\"fa\"<<endl;\n    // for(auto it:fa) cout<<it<<' ';cout<<endl;\n    // cout<<\"fb\"<<endl;\n    // for(auto it:fb) cout<<it<<' ';cout<<endl;\n    v.resize(n,0);\n    REP(i,0,n)\n    {\n        v[i]=((fa[i]*fb[i])%M);\n    }\n    // cout<<\"v\"<<endl;\n    // for(auto it:v) cout<<it<<' ';cout<<endl;\n    fft(v,n,true);\n    // cout<<\"v\"<<endl;\n    // for(auto it:v) cout<<it<<' ';cout<<endl;\n    v.resize(((ll)a.size())+((ll)b.size())-1,0LL);\n    // cout<<\"v\"<<endl;\n    // for(auto it:v) cout<<it<<' ';cout<<endl;\n    return;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    fc[0]=1;\n    REP(i,1,N) fc[i] = 1LL*fc[i-1]*i % M;\n\n    fci[N-1]=powM(fc[N-1], M-2);\n    REPI(i,0,N-1) fci[i] = 1LL*fci[i+1]*(i+1) % M;\n\n    REP(i,1,N) inv[i] = 1LL*fci[i]*fc[i-1]%M;\n\n    rev[1]=0;\n    for(int s=2; (s<<1)<=N; s<<=1)\n    {\n        for(int i=0; i<(s>>1); i++)\n        {\n            rev[s+i]=(rev[(s>>1)+i]<<1);\n            rev[s+(s>>1)+i]=((rev[(s>>1)+i]<<1)|1);\n        }\n    }\n\n    ll n;\n    cin>>n;\n    V(ll) v={1};\n    while(n--)\n    {\n        ll a,b;\n        cin>>a>>b;\n\n        ll nv=v.size();\n\n        // cout<<a<<' '<<b<<endl;\n        // for(auto it:v) cout<<it<<' ';cout<<endl;\n\n        V(ll) tmp(2*nv+a-b,0LL);\n        REP(i,b-nv,a+nv)\n        {\n            if(i>=0&&i<=a+b)\n            {\n                tmp[i-(b-nv)]=1LL*fc[a+b]*fci[i]%M*fci[a+b-i]%M;\n            }\n        }\n\n        // cout<<a<<' '<<b<<endl;\n        // for(auto it:tmp) cout<<it<<' ';cout<<endl;\n\n        V(ll) ans;\n        PolyMult(v,tmp,ans);\n\n        // cout<<a<<' '<<b<<endl;\n        // for(auto it:ans) cout<<it<<' ';cout<<endl;\n\n        V(ll) newv(nv+a-b,0LL);\n        REP(i,0,nv+a-b)\n        {\n            newv[i]=ans[i+nv];\n        }\n\n        // cout<<a<<' '<<b<<endl;\n        // for(auto it:newv) cout<<it<<' ';cout<<endl;\n\n        v=newv;\n    }\n\n    ll ans=0;\n    for(auto it:v) ans = (ans+it)%M;\n    cout<<ans;\n\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\ntemplate<const int &MOD>\nstruct _m_int {\n  int val;\n \n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n \n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n \n    while (r != 0) {\n      int q = g / r;\n      g %= r; swap(g, r);\n      x -= q * y; swap(x, y);\n    }\n \n    return x < 0 ? x + m : x;\n  }\n \n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n \n  _m_int& operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  _m_int& operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n \n  _m_int& operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n \n  _m_int& operator/=(const _m_int &other) {\n    return *this *= other.inv();\n  }\n \n  friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n \n  _m_int& operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n \n  _m_int& operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n \n  _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n  _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n \n  _m_int operator-() const {\n    return val == 0 ? 0 : MOD - val;\n  }\n \n  friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n  friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n  friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n  friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n  friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n  friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n \n  _m_int inv() const {\n    return inv_mod(val);\n  }\n \n  _m_int pow(int64_t p) const {\n    if (p < 0)\n      return inv().pow(-p);\n \n    _m_int a = *this, result = 1;\n \n    while (p > 0) {\n      if (p & 1)\n        result *= a;\n      a *= a;\n      p >>= 1;\n    }\n \n    return result;\n  }\n  \n  friend string to_string(_m_int<MOD> x) {\n    return to_string(x.val);\n  }\n \n  friend ostream& operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\n\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\n\nconst int g = 3;\nconst int LOGN = 15;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    forn(i, n) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\n#define ll long long\nconst int M = 202020;\n\nint pwr(int a, int b){\n\tint ret = 1;\n\tfor(int c=1; c<=b; c*=2){\n\t\tif(c&b) ret = ((ll)ret*a)%MOD;\n\t\ta = ((ll)a*a)%MOD;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n  \n\tprepare();\n\n\tint n;\n\tcin >> n;\n \n\tvector<int> a(n), b(n);\n\tfor(int i=0; i<n; i++) cin >> a[i] >> b[i];\n \n\tvector<ll> f(M), inv(M);\n\tf[0] = 1;\n\tfor(ll i=1; i<M; i++) f[i] = (f[i-1]*i)%MOD;\n\tfor(int i=0; i<M; i++) inv[i] = pwr(f[i], MOD-2);\n\t\n\tvector<Mint> ans(1, 1);\n\tforn(i, n){\n\t\tvector<Mint> Cs;\n\t\tint sum = a[i]+b[i];\n\t\tfor(int j = b[i] - sz(ans) + 1; j < sz(ans) + a[i]; ++j){\n\t\t\tint tmp = 0;\n\t\t\tif(j >= 0 && j <= sum) tmp = (((f[sum]*inv[j])%MOD)*inv[sum-j])%MOD;\n\t\t\tMint tmp2 = tmp;\n\t\t\tCs.push_back(tmp2);\n\t\t}\n\t\tauto res = mul(ans, Cs);\n\t\tint cnt = sz(ans);\n\n\t\tans.resize(cnt + a[i] - b[i]);\n\t\tforn(j, sz(ans)) ans[j] = res[cnt + j - 1];\n\t}\n\t  \n\tcout << accumulate(ans.begin(), ans.end(), Mint(0)) << endl;\n\n\treturn 0;\n}\t\n"
        },
        {
            "language": 2,
            "solution": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAXN 600000\n\nconst int G = 3, MOD = 998244353;\n\nint L;\nint R[MAXN + 10];\n\nint n;\nint fac[MAXN + 10], inv[MAXN + 10];\n\nint qpow(int a,int b){\n\tint ans = 1;\n\tfor (; b; b >>= 1,a = 1ll * a * a % MOD)\n\t\tif (b & 1) ans = 1ll * ans * a % MOD;\n\treturn ans;\n}\n\nvoid ntt(int a[], int len, int f){\n\tfor (int i = 0; i < len; i++) if (i < R[i]) swap(a[i],a[R[i]]);\n\tfor (int i = 1; i < len; i <<= 1){\n\t\tint gn = qpow(G, (MOD - 1) / (i << 1));\n\t\tfor (int j = 0; j < len; j += (i << 1)){\n\t\t\tint g = 1;\n\t\t\tfor (int k = 0; k < i; k++, g = 1ll * g * gn % MOD){\n\t\t\t\tint x = a[j + k],y = 1ll * g * a[j + k + i] % MOD;\n\t\t\t\ta[j + k] = (x + y) % MOD; a[j + k + i] = (x - y + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif(f == 1) return;\n\tint nv = qpow(len, MOD - 2); reverse(a + 1, a + len);\n\tfor(int i = 0; i < len; i++) a[i] = 1ll * a[i] * nv % MOD;\n}\n\nvoid NTT(int len, int A[], int B[], int C[]) {\n    ntt(A, len, 1);\n    ntt(B, len, 1);\n    for(int i = 0;i < len; i++) C[i] = 1ll * A[i] * B[i] % MOD;\n    ntt(C, len, -1);\n}\n\nvoid init(int up) {\n    fac[0] = inv[0] = 1;\n    for(int i = 1;i <= up; i++) fac[i] = (1ll * fac[i - 1] * i) % MOD;\n    inv[up] = qpow(fac[up], MOD - 2);\n    for(int i = up - 1;i >= 1; i--) inv[i] = (1ll * inv[i + 1] * (i + 1)) % MOD;\n}\n\nint get_C(int a, int b) {\n    if(a < 0 || b < 0 || a > b) return 0;\n    return ((1ll * fac[b] * inv[a]) % MOD * inv[b - a]) % MOD;\n}\n\n\nint A[MAXN], B[MAXN],C[MAXN];\n\nint main(){\n\tscanf(\"%d\", &n);\n    A[0] = 1;\n    int tot = 0;\n    init(600000);\n    for(int i = 0;i < n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        int ntot = tot + a - b;\n        int p = 2 * tot + ntot;\n        int len;\n        L = 0;\n        for(len = 1;len <= p; len <<= 1) L++;\n        for(int i = 0;i < len; i++) R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));\n        for(int i = 0;i < len; i++) B[i] = 0;\n        for(int i = -tot;i <= ntot; i++) B[tot + i] = get_C(b + i, a + b);\n        // for(int i = 0;i < len; i++) printf(\"%d \", A[i]);\n        // puts(\"\");\n        // for(int i = 0;i < len; i++) printf(\"%d \", B[i]);\n        // puts(\"\");\n\t    ntt(A, len, 1); ntt(B, len, 1);\n        for(int i = 0;i < len; i++) A[i] = 1ll * A[i] * B[i] % MOD;\n        ntt(A, len, -1);\n        // for(int i = 0;i < len; i++) printf(\"%d \", A[i]);\n        // puts(\"\");\n        for(int i = 0;i <= ntot; i++) A[i] = A[i + tot];\n        for(int i = ntot + 1;i < len; i++) A[i] = 0;\n        tot = ntot;\n    }\n    int ans = 0;\n\tfor (int i = 0; i <= tot; i++) ans = (ans + A[i]) % MOD;\n    printf(\"%d\\n\", ans);\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+5;\nconst int G = 3;\nconst int mod = 998244353;\n \nint fac[N],rev[N];\n \nint qpow(int a,int b){\n\tint r=1;\n\twhile(b){\n\t\tif(b&1)r=1ll*r*a%mod;\n\t\tb>>=1;a=1ll*a*a%mod; \n\t}\n\treturn r;\n}\n \nstruct NTT{\n\tint n,m,rev[N<<1];\n\tint a[N<<1],b[N<<1];\n\t\n\tvoid init(int len){\n\t\tfor(n=1,m=0;n<=len;n<<=1,m++);\n\t\tfor(int i=0;i<n;++i){\n\t\t\trev[i]=rev[i>>1]>>1|(1&i)<<(m-1);\n\t\t\ta[i]=b[i]=0;\n\t\t}\n\t}\n\t\n\tvoid FFT(int *a,int f){\n\t\tfor(int i=0;i<n;++i)if(i<rev[i])swap(a[i],a[rev[i]]);\n\t\tfor(int i=1;i<n;i<<=1){\n\t\t\tint wn=qpow(G,(mod-1)/(i<<1));\n\t\t\tif(f==-1)wn=qpow(wn,mod-2);\n\t\t\tfor(int j=0;j<n;j+=i<<1){\n\t\t\t\tint w=1;\n\t\t\t\tfor(int k=0;k<i;++k,w=1ll*w*wn%mod){\n\t\t\t\t\tint x=a[j+k],y=1ll*a[j+k+i]*w%mod;\n\t\t\t\t\ta[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tif(f==-1){\n\t\t\tint rn=qpow(n,mod-2);\n\t\t\tfor(int i=0;i<n;++i)a[i]=1ll*a[i]*rn%mod;\n\t\t}\n\t}\n\t\n\tvoid work(){\n\t\tFFT(a,1);FFT(b,1);\n\t\tfor(int i=0;i<n;++i)a[i]=1ll*a[i]*b[i]%mod;\n\t\tFFT(a,-1);\n\t}\n}B;\n \nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\trev[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;~i;--i)rev[i]=1ll*rev[i+1]*(i+1)%mod;\n}\n \nint C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\n \nint n,ans[N];\n \nint main(){\n\tinit();\n\tcin>>n;\n\tint len=0;\n\tans[0]=1;\n\tfor(int i=1,a,b;i<=n;++i){\n\t\tcin>>a>>b;\n\t\tB.init(2*len+a-b);\n\t\tfor(int k=-len;k<=len+a-b;++k)B.a[k+len]=C(a+b,b+k);\n\t\tfor(int j=0;j<=len;++j)B.b[j]=ans[j];\n\t\tB.work();\n\t\tfor(int k=0;k<=len+a-b;++k){\n\t\t\tans[k]=B.a[k+len];\n\t\t}\n\t\tlen+=a-b;\n\t}\n\tint res=0;\n\tfor(int i=0;i<=len;++i)(res+=ans[i])%=mod;\n\tcout<<res<<endl;\n}\n \t   \t      \t\t\t \t\t \t  \t\t \t\t  \t\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> P;\nconst int inf = 0x3f3f3f3f, N = 5005, mod = 998244353, M = 6e5 + 10;\ntemplate <typename T>\nvoid rd_(T &x) {\n\tx = 0; int f = 1;\n\tchar ch = getchar();\n\tfor (; ch > '9' || ch < '0'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = x*10 + ch - '0';\n\tx *= f;\n}\n\nLL fpow_(LL a, LL b, LL res = 1) {\n\tfor (; b; b >>= 1, a = a*a%mod)\n\t\tif (b&1) res = res*a%mod;\n\treturn res;\n}\n\nint n, a, b, f[M], g[M], len, tr[M], tot, tk, R = 3, iR = fpow_(3, mod - 2);\nLL fac[M], inv[M], ans; \n\nvoid init_(int n) {\n\tfac[0] = inv[0] = 1;\n\trep (i, 1, n) fac[i] = fac[i - 1]*i%mod;\n\tinv[n] = fpow_(fac[n], mod - 2);\n\tper (i, n - 1, 1) inv[i] = inv[i + 1]*(i + 1)%mod;\n}\n\nvoid ntt_(int *a, int f = 1) {\n\trep (i, 0, len - 1)\n\t\tif (i < tr[i]) swap(a[i], a[tr[i]]);\n\tfor (int l = 2; l <= len; l <<= 1) {\n\t\tint wn = fpow_(f == 1 ? R : iR, (mod - 1)/l);\n\t\tfor (int j = 0; j < len; j += l) {\n\t\t\tint w = 1;\n\t\t\tfor (int k = 0; k < l/2; k++) {\n\t\t\t\tint u = a[j + k], v = 1ll*a[j + k + l/2]*w%mod;\n\t\t\t\ta[j + k] = (u + v)%mod, a[j + k + l/2] = (u - v + mod)%mod;\n\t\t\t\tw = 1ll*w*wn%mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (f == -1) {\n\t\tint iL = fpow_(len, mod - 2);\n\t\trep (i, 0, len - 1)\n\t\t\ta[i] = 1ll*a[i]*iL%mod;\n\t}\n}\n\nint main() {\n\trd_(n), init_(600000);\n\tf[0] = 1, tot = 0;\n\trep (T, 1, n) {\n\t\trd_(a), rd_(b);\n\t\tfor (len = 1, tk = 0; len <= 3*tot + a - b; len <<= 1) tk++;\n\t\trep (i, 0, len - 1) {\n\t\t\ttr[i] = (tr[i>>1]>>1) | ((i&1)<<tk - 1);\n\t\t\tg[i] = 0;\n\t\t}\n\t\trep (i, 0, tot + tot + a - b)\n\t\t\tif (b + (i - tot) >= 0 && a - (i - tot) >= 0) \n\t\t\t\tg[i] = inv[b + (i - tot)]*inv[a - (i - tot)]%mod;\n\t\trep (i, tot + 1, len - 1) f[i] = 0;\n\t\tntt_(f), ntt_(g);\n\t\trep (i, 0, len - 1) f[i] = 1ll*f[i]*g[i]%mod;\n\t\tntt_(f, -1);\n\t\trep (i, 0, tot + a - b)\n\t\t\tf[i] = f[i + tot]*fac[a + b]%mod;\n\t\ttot += a - b;\n\t}\n\trep (i, 0, tot)\n\t\tans = (ans + f[i])%mod;\n\tprintf(\"%lld\\n\", ans);\n}"
        },
        {
            "language": 2,
            "solution": "#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod =998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nint get_premitive_root() {\n\tint primitive_root = 0;\n\tif (!primitive_root) {\n\t\tprimitive_root = [&]() {\n\t\t\tset<int> fac;\n\t\t\tint v = mod - 1;\n\t\t\tfor (ll i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n\t\t\tif (v > 1) fac.insert(v);\n\t\t\tfor (int g = 1; g < mod; g++) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto i : fac) if (mod_pow(g, (mod - 1) / i) == 1) { ok = false; break; }\n\t\t\t\tif (ok) return g;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}();\n\t}\n\treturn primitive_root;\n}\nconst int proot = get_premitive_root();\n\ntypedef vector <modint> poly;\nvoid dft(poly& f, bool inverse = false) {\n\tint n = f.size(); if (n == 1)return;\n\n\tstatic poly w{ 1 }, iw{ 1 };\n\tfor (int m = w.size(); m < n / 2; m *= 2) {\n\t\tmodint dw = mod_pow(proot, (mod - 1) / (4 * m)), dwinv = (modint)1 / dw;\n\t\tw.resize(m * 2); iw.resize(m * 2);\n\t\tfor (int i = 0; i < m; i++)w[m + i] = w[i] * dw, iw[m + i] = iw[i] * dwinv;\n\t}\n\tif (!inverse) {\n\t\tfor (int m = n; m >>= 1;) {\n\t\t\tfor (int s = 0, k = 0; s < n; s += 2 * m, k++) {\n\t\t\t\tfor (int i = s; i < s + m; i++) {\n\t\t\t\t\tmodint x = f[i], y = f[i + m] * w[k];\n\t\t\t\t\tf[i] = x + y, f[i + m] = x - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tfor (int s = 0, k = 0; s < n; s += 2 * m, k++) {\n\t\t\t\tfor (int i = s; i < s + m; i++) {\n\t\t\t\t\tmodint x = f[i], y = f[i + m];\n\t\t\t\t\tf[i] = x + y, f[i + m] = (x - y) * iw[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodint n_inv = (modint)1 / (modint)n;\n\t\tfor (modint& v : f)v *= n_inv;\n\t}\n}\npoly multiply(poly g, poly h) {\n\tint n = 1;\n\tint pi = 0, qi = 0;\n\trep(i, g.size())if (g[i])pi = i;\n\trep(i, h.size())if (h[i])qi = i;\n\tint sz = pi + qi + 2;\n\twhile (n < sz)n *= 2;\n\tg.resize(n); h.resize(n);\n\tdft(g); dft(h);\n\trep(i, n) {\n\t\tg[i] *= h[i];\n\t}\n\tdft(g, true);\n\treturn g;\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n), b(n);\n\trep(i, n)cin >> a[i] >> b[i];\n\tvector<modint> dp = { 1 };\n\tint cur = 1;\n\trep(i, n) {\n\t\tint nex = cur + a[i] - b[i];\n\t\tint ri = min(a[i], nex / 2);\n\t\tint le = max(-b[i], -(cur - 1));\n\t\tle = abs(le);\n\t\t//cout << \"? \" << le << \" \" << ri << \"\\n\";\n\t\t//le,ri\n\t\tpoly p(ri + le + 1);\n\t\trep(k, ri + le + 1) {\n\t\t\tp[k] = fact[a[i]+b[i]]*factinv[b[i] + (k - le)] * factinv[a[i] - (k - le)];\n\t\t}\n\t\tpoly q(cur);\n\t\trep(i, cur)q[i] = dp[i];\n\t\tpoly r = multiply(p, q);\n\t\tvector<modint> ndp(nex);\n\t\tfor (int j = 0; j < (nex + 1) / 2; j++) {\n\t\t\tif (j + le < r.size())ndp[j] = r[j + le];\n\t\t}\n\t\tfor (int j = (nex + 1) / 2; j < nex;j++) {\n\t\t\tndp[j] = ndp[nex - 1 - j];\n\t\t}\n\t\tswap(dp, ndp);\n\t\tcur = nex;\n\t\t//cout << dp[0] << \"\\n\";\n\t}\n\tmodint ans = 0;\n\trep(i, dp.size())ans += dp[i];\n\tcout << ans << \"\\n\";\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\tinit_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i,t)\n\tsolve();\n\treturn 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing base = ll;//complex<double>;\nconst ll mod = 998244353;\nll mexp(ll x, ll y) {\n    ll r = 1;\n    for(;y;x=x*x%mod, y>>=1) if(y & 1) r = r * x % mod;\n    return r;\n}\nll modd(ll x) {\n    if(x >= mod) x -= mod;\n    if(x < 0) x += mod;\n    return x;\n}\nvoid fft(vector<base>& a, bool inv) {\n    int n = a.size(), j = 0;\n    vector<base> roots(n/2);\n    for(int i=1;i<n;i++) {\n        int bit = (n >> 1);\n        while(j >= bit) {\n            j -= bit;\n            bit >>= 1;\n        }\n        j += bit;\n        if(i < j) swap(a[i], a[j]);\n    }\n    // In NTT, let prr = primitive root. Then,\n    int prr = 3;\n    ll ang = mexp(prr, (mod - 1) / n);\n    if(inv) ang = mexp(ang, mod - 2);\n    for(int i=0; i<n/2; i++){\n        roots[i] = (i ? (1ll * roots[i-1] * ang % mod) : 1);\n    }\n    //also, make sure to apply modulus under here\n    for(int i=2;i<=n;i<<=1) {\n        int step = n / i;\n        for(int j=0;j<n;j+=i) {\n            for(int k=0;k<i/2;k++) {\n                base u = a[j+k], v = a[j+k+i/2] * roots[step * k] % mod;\n                a[j+k] = modd(u+v);\n                a[j+k+i/2] = modd(u-v+mod);\n            }\n        }\n    }\n    if(inv) for(int i=0;i<n;i++) a[i] = a[i] * mexp(n, mod-2) % mod;\n}\nvoid conv(vector<base>& x, vector<base>& y) {\n    int n = 2; while(n < x.size()+y.size()) n <<= 1;\n    x.resize(n), y.resize(n);\n    fft(x, false); fft(y, false);\n    for(int i=0;i<n;i++) x[i] = x[i] * y[i] % mod;\n    fft(x, true);\n}\nconst int lim = 222222;\nll f[lim], fi[lim];\nvector<base> ans, mul, nans;\nint n;\nll binom(int a, int b) {\n    if(b < 0 || b > a) return 0;\n    return f[a] * fi[b] % mod * fi[a-b] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n;\n    ans.reserve(1<<16);\n    mul.reserve(1<<16);\n    f[0] = 1;\n    for(int i=1;i<lim;i++)\n        f[i] = i * f[i-1] % mod;\n    fi[lim-1] = mexp(f[lim-1], mod-2);\n    for(int i=lim-2;i>=0;i--)\n        fi[i] = (i+1) * fi[i+1] % mod;\n    ans.push_back(1);\n    for(int i=0;i<n;i++) {\n        int a, b;\n        cin >> a >> b;\n        int m = ans.size();\n        int m1 = 2 * m + a - b - 1;\n        for(int j=0;j<m1;j++)\n            mul.emplace_back(binom(a+b, b+j-(m-1)));\n        conv(ans, mul);\n        nans.clear(); nans.resize(m+a-b);\n        for(int i=0;i<m+a-b;i++) nans[i] = ans[m-1+i];\n        ans = nans;\n        mul.clear();\n    }\n    cout << accumulate(ans.begin(), ans.end(), 0LL) % mod;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int N = 4e5 + 9;\nconst int P = 998244353;\nconst int g = 3;\n\ninline int add(int a, int b) { int r = a + b; return r < P ? r : r - P; }\ninline int sub(int a, int b) { int r = a - b; return r < 0 ? r + P : r; }\ninline int mul(ll a, ll b) { ll r = a * b; return r % P; }\ninline int inv(int a) { return a == 1 ? a : mul(inv(P % a), P - P / a); }\ninline int qpm(int a, int b) {\n    int r = 1;\n    do if (b & 1) r = mul(r, a);\n    while (a = mul(a, a), b >>= 1);\n    return r;\n}\n\nll invs[N], f[N], fi[N];\nll binom(ll n, ll k) { if (n < k || k < 0) return 0; return mul(f[n], mul(fi[n - k], fi[k])); }\nvoid ginv() {\n    invs[1] = 1; f[0] = fi[0] = 1;\n    for (int i = 2; i != N; ++i) invs[i] = mul(invs[P % i], (P - P / i));\n    for (int i = 1; i != N; ++i) f[i] = mul(f[i - 1], i);\n    for (int i = 1; i != N; ++i) fi[i] = mul(fi[i - 1], invs[i]);\n}\n\nconst int W = 19, S = 1 << W;\nint w[S + 1], rev[S << 1], *r[W + 1];\nvoid init() {\n    for (int s = 0; s <= W&&(r[s]=rev+(1<<s),1); ++s)\n        for (int i = 0; i != (1 << s); ++i)\n            r[s][i] = (r[s][i >> 1] >> 1) | ((i & 1) << (s - 1));\n    w[0] = 1; w[1] = qpm(g, (P - 1) / S);\n    for (int i = 2; i <= S; ++i) w[i] = mul(w[i - 1], w[1]);\n}\n\nint m, s, im;\nint init(int n) {\n    for (s = 0, m = 1; m < n; m <<= 1, ++s);\n    im = inv(m); return m;\n}\n\nvoid ntt(int* p, int t) {\n    for (int i = 0; i != m; ++i) if (i < r[s][i]) swap(p[i], p[r[s][i]]);\n    for (int i = 1, z = 0; i != m; i <<= 1, z++)\n        for (int j = 0; j != m; j += (i << 1))\n            for (int k = 0, u, v; k != i; k++)\n                u = p[j+k], v = mul(w[(t?(i<<1)-k:k)<<W-z-1], p[i+j+k]),\n                p[j + k] = add(u, v), p[i + j + k] = sub(u, v);\n    if (t) for (int i = 0; i != m; ++i) p[i] = mul(p[i], im);\n}\n\nint px[N], py[N];\nvi mul(const vi& p1, const vi& p2, int n = 0) {\n    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;\n    init(n3);\n    copy_n(p1.begin(), n1, px); fill(px + n1, px + m, 0);\n    copy_n(p2.begin(), n2, py); fill(py + n2, py + m, 0);\n    ntt(px, 0); ntt(py, 0);\n    for (int i = 0; i != m; ++i) px[i] = mul(px[i], py[i]);\n    ntt(px, 1); vi p3(n3); copy_n(px, n3, p3.begin());\n    if (n && n3 > n) p3.resize(n); return p3;\n}\n\nint n;\nint a[N], b[N];\nvector<int> vc[N];\n\nint main()\n{\n    //freopen(\"C:/Users/MACHENIKE/Desktop/data.in\",\"r\",stdin);\n    ginv(); init();\n    scanf (\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf (\"%d %d\", a + i, b + i);\n    vc[0].push_back (1);\n    int u = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        vc[i].resize(2 * u + a[i] - b[i] + 1);\n        for (int j = -u; j <= u + a[i] - b[i]; j++) vc[i][j + u] = binom (a[i] + b[i], b[i] + j);\n        vector<int> temp = mul (vc[i - 1], vc[i]);\n        int v = u + a[i] - b[i];\n\n        vc[i].resize (v + 1);\n        for (int j = 0; j <= v; j++) vc[i][j] = temp[j + u];\n        u = v;\n    }\n    int ans = 0;\n    for (auto it : vc[n]) ans = add (it, ans);\n    printf (\"%d\\n\", ans);\n    return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#define pb push_back\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define mem(a) memset(a, 0, sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef __int128_t int128;\nconst int maxn = 4 * 1e5 + 10, P = 998244353, G = 3, Gi = 332748118;\nconst ll mod = P;\n//Gi\u662f\u539f\u6839\u7684\u9006\u5143\nint limit = 1, L, rev[maxn];\nvector<ll> a, b;\nll fac[maxn], inv[maxn];\nint n;\nll in[maxn], de[maxn];\nvector<ll> tmp;\ninline ll qp(ll a, ll k, ll mod = P)\n{\n    ll base = 1;\n    while (k)\n    {\n        if (k & 1)\n            base = (base * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return base % mod;\n}\nint cnt = 0;\ninline void NTT(vector<ll> &A, int type)\n{\n    //cout << \"SSSSS\" << cnt++ << endl;\n    for (int i = 0; i < limit; i++)\n        if (i < rev[i])\n            swap(A[i], A[rev[i]]);\n    for (int mid = 1; mid < limit; mid <<= 1)\n    {\n        ll Wn = qp(type == 1 ? G : Gi, (P - 1) / (mid << 1));\n        for (int j = 0; j < limit; j += (mid << 1))\n        {\n            ll w = 1;\n            for (int k = 0; k < mid; k++, w = (w * Wn) % P)\n            {\n                //cout << mid << \" \" << j << \" \" << k << endl;\n                int x = A[j + k], y = w * A[j + k + mid] % P;\n                A[j + k] = (x + y) % P, A[j + k + mid] = (x - y + P) % P;\n            }\n        }\n    }\n    if (type == -1)\n    {\n        ll inv = qp(limit, P - 2);\n        for (int i = 0; i < limit; i++)\n            A[i] = A[i] * inv % P;\n    }\n}\nvoid init(int N, int M)\n{\n    limit = 1;\n    L = 0;\n    while (limit <= N + M)\n        limit <<= 1, L++;\n    for (int i = 0; i < limit; i++)\n    {\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (L - 1));\n    }\n}\nvoid I()\n{\n    fac[0] = 1, inv[0] = 1;\n    for (int i = 1; i < maxn; i++)\n        fac[i] = fac[i - 1] * i % P, inv[i] = qp(fac[i], mod - 2);\n}\nll C(int n, int k)\n{\n    if (k < 0 || k > n)\n        return 0;\n    return 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\nvoid mul(vector<ll> &a, vector<ll> &b)\n{\n    int n = a.size(), m = b.size();\n    init(n, m);\n    a.resize(limit), b.resize(limit);\n    //cout << limit << endl;\n    NTT(a, 1), NTT(b, 1);\n    for (int i = 0; i < limit; i++)\n        a[i] = a[i] * b[i] % mod;\n    NTT(a, -1);\n}\nint main()\n{\n    I();\n    //cout << C(6, 3) << \" \" << C(6, 2) << endl;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> in[i] >> de[i];\n    a.pb(1);\n    int len = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        //cout << \"I= \" << i << endl;\n        len += in[i] - de[i];\n        tmp.clear();\n        int prev = a.size();\n        for (int j = de[i] - prev + 1; j <= prev + in[i] - 1; j++)\n        {\n            tmp.pb(C(in[i] + de[i], j));\n        }\n        mul(tmp, a);\n        vector<ll> tmp2(len,0);\n        for (int i = 0; i < len; i++)\n            tmp2[i]=(tmp[i + prev - 1]);\n        a.clear();\n        a = tmp2;\n    }\n    ll ans = 0;\n    for (auto c : a)\n    {\n        //cout << c << endl;\n        ans = (ans + c) % mod;\n    }\n    cout << ans << endl;\n    return 0;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n\n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n\nusing namespace std;\n\nconst int MOD=998244353, PR=3;\nvector<int> X, Y;\nint F[300001], Finv[300001];\n\nint mul(int a, int b) {return 1LL*a*b%MOD;}\n\nint fast_pow(int a, int b)\n{\n    int ret=1;\n    for(;b;b>>=1) {\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a);\n    }\n    return ret;\n}\n\nvoid FFT(vector<int> &A,bool inv)\n{\n\tint N=A.size();\n    stack<int> S;\n\tfor(int i=0;i<N;i++) {\n\t\tint j=0;\n\t\tfor(int b=1;b<N;b<<=1) {\n\t\t\tj<<=1;\n\t\t\tif(b&i) j|=1;\n\t\t}\n\t\tif(i<j) swap(A[i],A[j]);\n\t}\n    S.push(fast_pow(inv ? fast_pow(PR,MOD-2):PR,MOD/N));\n    for(int i=2;i<N;i<<=1) S.push(mul(S.top(),S.top()));\n\tfor(int i=1;i<N;i<<=1) {\n        int w=S.top();\n        S.pop();\n\t\tfor(int j=0;j<N;j+=i<<1) {\n\t\t\tint th=1;\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tint temp=mul(A[i+j+k],th);\n\t\t\t\tA[i+j+k]=A[j+k]-temp;\n                if(A[i+j+k]<0) A[i+j+k]+=MOD;\n\t\t\t\tA[j+k]+=temp;\n                if(A[j+k]>=MOD) A[j+k]-=MOD;\n                th=mul(th,w);\n\t\t\t}\n\t\t}\n\t}\n\tif(inv) {\n        int v=fast_pow(N,MOD-2);\n        for(int i=0;i<N;i++) A[i]=mul(A[i],v);\n    }\n}\n\nvoid conv(vector<int> &A, vector<int> &B)\n{\n\tint N=1;\n\tfor(;N<A.size()+B.size();N<<=1);\n\tA.resize(N); B.resize(N);\n\tFFT(A,false); FFT(B,false);\n\tfor(int i=0;i<N;i++) A[i]=mul(A[i],B[i]);\n\tFFT(A,true);\n}\n\nint nCr(int n, int r)\n{\n\treturn mul(F[n],mul(Finv[r],Finv[n-r]));\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N=1, M, ans=0;\n\tF[0]=Finv[0]=1;\n\tfor(int i=1;i<=300000;i++) F[i]=mul(i,F[i-1]);\n\tFinv[300000]=fast_pow(F[300000],MOD-2);\n\tfor(int i=300000;--i;) Finv[i]=mul(Finv[i+1],i+1);\n\tX.resize(1,1);\n\tfor(cin>>M;M--;) {\n\t\tint a, b, sz=X.size()+10;\n\t\tcin>>a>>b;\n\t\tY.clear();\n\t\tfor(int i=-sz;i<=sz;i++) {\n\t\t\tif(b+i<0 || i>a) Y.push_back(0);\n\t\t\telse Y.push_back(nCr(a+b,b+i));\n\t\t}\n\t\tconv(X,Y);\n\t\tN+=a-b;\n\t\tfor(int i=0;i<N;i++) X[i]=X[sz+i];\n\t\tX.resize(N);\n\t}\n\tfor(int i=0;i<N;i++) {\n\t\tans+=X[i];\n\t\tif(ans>=MOD) ans-=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
        },
        {
            "language": 4,
            "solution": "//package ecr102;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class G4 {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n\n\tfinal int mod = 998244353;\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] fif = enumFIF(200005, mod);\n\t\tlong[] base = {1L};\n\t\tint L = base.length;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint a = ni(), b = ni();\n\n\t\t\tint h = (L+a-b)/2;\n\t\t\tlong[] cs = new long[h+1+(L-1+1)];\n\t\t\tfor(int d = -(L-1);d < h+1;d++) {\n\t\t\t\tcs[d + L - 1] = C(a + b, d + b, mod, fif);\n\t\t\t}\n\n\t\t\tbase = Arrays.copyOfRange(NTTStockham998244353.convolute(base, cs), L - 1, L - 1 + L + a - b);\n\t\t\tfor(int j = h;j < L+a-b;j++){\n\t\t\t\tbase[j] = base[L+a-b-1-j];\n\t\t\t}\n\t\t\tL += a - b;\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor(long v : base){\n\t\t\tans += v;\n\t\t}\n\t\tout.println(ans%mod);\n\t}\n\n\n\n\tfinal long big = 8L*mod*mod;\n\tpublic long[] mulnaive(long[] a, long[] b)\n\t{\n\t\tlong[] c = new long[a.length+b.length-1];\n\t\tfor(int i = 0;i < a.length;i++){\n\t\t\tfor(int j = 0;j < b.length;j++){\n\t\t\t\tc[i+j] += a[i]*b[j];\n\t\t\t\tif(c[i+j] >= big)c[i+j] -= big;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < c.length;i++)c[i] %= mod;\n\t\treturn c;\n\t}\n\n\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n) return 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][]{f, invf};\n\t}\n\n\n\tpublic static class NTTStockham998244353 {\n\t\tprivate static final int P = 998244353, mod = P, G = 3;\n\t\tprivate static long[] wps;\n\n\t\tpublic static long[] convolute(long[] a, long[] b)\n\t\t{\n\t\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\n\t\t\twps = new long[m];\n\t\t\tlong unit = pow(G, (P-1)/m);\n\t\t\twps[0] = 1;\n\t\t\tfor(int p = 1;p < m;p++) {\n\t\t\t\twps[p] = wps[p-1] * unit % mod;\n\t\t\t}\n\n\t\t\tlong[] fa = go(a, m, false);\n\t\t\tlong[] fb = a == b ? fa : go(b, m, false);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i] % mod;\n\t\t\t}\n\t\t\tfa = go(fa, m, true);\n\t\t\tfor(int i = 1, j = m-1;i < j;i++,j--) {\n\t\t\t\tlong d = fa[i]; fa[i] = fa[j]; fa[j] = d;\n\t\t\t}\n\t\t\treturn fa;\n\t\t}\n\n\t\tprivate static void fft(long[] X, long[] Y)\n\t\t{\n\t\t\tint s = 1;\n\t\t\tboolean eo = false;\n\t\t\tfor(int n = X.length;n >= 4;n /= 2) {\n\t\t\t\tint m = n/2;\n\t\t\t\tfor(int p = 0;p < m;p++) {\n\t\t\t\t\tlong wp = wps[s*p];\n\t\t\t\t\tlong wk = (wp<<32)/P;\n\t\t\t\t\tfor(int q = 0;q < s;q++) {\n\t\t\t\t\t\tlong a = X[q + s*(p+0)];\n\t\t\t\t\t\tlong b = X[q + s*(p+m)];\n\t\t\t\t\t\tlong ndsts = a + b;\n\t\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\t\tlong T = a - b + 2*P;\n\t\t\t\t\t\tlong Q = wk*T>>>32;\n\t\t\t\t\t\tY[q + s*(2*p+0)] = ndsts;\n\t\t\t\t\t\tY[q + s*(2*p+1)] = wp*T-Q*P&(1L<<32)-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts *= 2;\n\t\t\t\teo = !eo;\n\t\t\t\tlong[] D = X; X = Y; Y = D;\n\t\t\t}\n\t\t\tlong[] z = eo ? Y : X;\n\t\t\tfor(int q = 0;q < s;q++) {\n\t\t\t\tlong a = X[q + 0];\n\t\t\t\tlong b = X[q + s];\n\t\t\t\tz[q+0] = (a+b) % P;\n\t\t\t\tz[q+s] = (a-b+2*P) % P;\n\t\t\t}\n\t\t}\n\n\t\t//\tprivate static void fft(long[] X, long[] Y)\n\t\t//\t{\n\t\t//\t\tint s = 1;\n\t\t//\t\tboolean eo = false;\n\t\t//\t\tfor(int n = X.length;n >= 4;n /= 2) {\n\t\t//\t\t\tint m = n/2;\n\t\t//\t\t\tfor(int p = 0;p < m;p++) {\n\t\t//\t\t\t\tlong wp = wps[s*p];\n\t\t//\t\t\t\tfor(int q = 0;q < s;q++) {\n\t\t//\t\t\t\t\tlong a = X[q + s*(p+0)];\n\t\t//\t\t\t\t\tlong b = X[q + s*(p+m)];\n\t\t//\t\t\t\t\tY[q + s*(2*p+0)] = (a+b) % P;\n\t\t//\t\t\t\t\tY[q + s*(2*p+1)] = (a-b+P) * wp % P;\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t\ts *= 2;\n\t\t//\t\t\teo = !eo;\n\t\t//\t\t\tlong[] D = X; X = Y; Y = D;\n\t\t//\t\t}\n\t\t//\t\tlong[] z = eo ? Y : X;\n\t\t//\t\tfor(int q = 0;q < s;q++) {\n\t\t//\t\t\tlong a = X[q + 0];\n\t\t//\t\t\tlong b = X[q + s];\n\t\t//\t\t\tz[q+0] = (a+b) % P;\n\t\t//\t\t\tz[q+s] = (a-b+P) % P;\n\t\t//\t\t}\n\t\t//\t}\n\n\t\tprivate static long[] go(long[] src, int n, boolean inverse)\n\t\t{\n\t\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\tfft(dst, new long[n]);\n\t\t\tif(inverse){\n\t\t\t\tlong in = invl(n);\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tdst[i] = dst[i] * in % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dst;\n\t\t}\n\n\t\tprivate static long pow(long a, long n) {\n\t\t\t//\t\ta %= mod;\n\t\t\tlong ret = 1;\n\t\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\t\tfor (; x >= 0; x--) {\n\t\t\t\tret = ret*ret % mod;\n\t\t\t\tif (n<<~x<0)ret = ret*a%mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate static long invl(long a) {\n\t\t\tlong b = mod;\n\t\t\tlong p = 1, q = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tlong c = a / b;\n\t\t\t\tlong d;\n\t\t\t\td = a;\n\t\t\t\ta = b;\n\t\t\t\tb = d % b;\n\t\t\t\td = p;\n\t\t\t\tp = q;\n\t\t\t\tq = d - c * q;\n\t\t\t}\n\t\t\treturn p < 0 ? p + mod : p;\n\t\t}\n\t}\n\n\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 1000, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tsb.append(100000 + \" \");\n//\t\t\tsb.append(99995 + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new G4().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        }
    ]
}